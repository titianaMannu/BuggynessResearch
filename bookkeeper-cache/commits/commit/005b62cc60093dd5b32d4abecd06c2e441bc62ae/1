{"sha":"005b62cc60093dd5b32d4abecd06c2e441bc62ae","node_id":"MDY6Q29tbWl0MTU3NTk1NjowMDViNjJjYzYwMDkzZGQ1YjMyZDRhYmVjZDA2YzJlNDQxYmM2MmFl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-04T10:32:49Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-04T10:32:49Z"},"message":"BOOKKEEPER-293: Periodic checking of ledger replication status (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1428777 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7a64e2e08fa871715352c27e8cff1bbbe5588825","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7a64e2e08fa871715352c27e8cff1bbbe5588825"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/005b62cc60093dd5b32d4abecd06c2e441bc62ae","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/005b62cc60093dd5b32d4abecd06c2e441bc62ae","html_url":"https://github.com/apache/bookkeeper/commit/005b62cc60093dd5b32d4abecd06c2e441bc62ae","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/005b62cc60093dd5b32d4abecd06c2e441bc62ae/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"ee29f75f3f6a0168008da2e424e4174f2aee8cbb","url":"https://api.github.com/repos/apache/bookkeeper/commits/ee29f75f3f6a0168008da2e424e4174f2aee8cbb","html_url":"https://github.com/apache/bookkeeper/commit/ee29f75f3f6a0168008da2e424e4174f2aee8cbb"}],"stats":{"total":608,"additions":589,"deletions":19},"files":[{"sha":"14c2471446d083f8edc8cb08f9640b31a797c116","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -285,6 +285,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-409: Integration Test - Perform bookie rereplication cycle by Auditor-RW processes (rakeshr via ivank)\n \n+        BOOKKEEPER-293: Periodic checking of ledger replication status (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"9f1b52a4bafd59610231b3da6de730d9c8b02279","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -76,6 +76,7 @@\n     final static int LOGFILE_HEADER_SIZE = 1024;\n     final ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n \n+    final static int MIN_SANE_ENTRY_SIZE = 8 + 8;\n     final static long MB = 1024 * 1024;\n \n     /**\n@@ -374,6 +375,10 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n             LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \" + entryLogId);\n \n         }\n+        if (entrySize < MIN_SANE_ENTRY_SIZE) {\n+            LOG.error(\"Read invalid entry length {}\", entrySize);\n+            throw new IOException(\"Invalid entry length \" + entrySize);\n+        }\n         byte data[] = new byte[entrySize];\n         ByteBuffer buff = ByteBuffer.wrap(data);\n         int rc = fc.read(buff, pos);"},{"sha":"f6e985126df8fb38b4f91dcb644e6cb77248f367","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -154,7 +154,8 @@ public boolean isFlushRequired() {\n     };\n \n     @Override\n-    public void flush() throws IOException {\n+    public synchronized void flush() throws IOException {\n+\n         if (!somethingWritten) {\n             return;\n         }"},{"sha":"168b41c7b6d778c204e1a5b9249499e69808304e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -35,6 +35,8 @@\n import java.util.Map.Entry;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import com.google.common.annotations.VisibleForTesting;\n+\n import org.apache.bookkeeper.util.SnapshotMap;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n@@ -232,7 +234,8 @@ public long getEntryOffset(long ledger, long entry) throws IOException {\n         }\n     }\n \n-    static final String getLedgerName(long ledgerId) {\n+    @VisibleForTesting\n+    public static final String getLedgerName(long ledgerId) {\n         int parent = (int) (ledgerId & 0xff);\n         int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n         StringBuilder sb = new StringBuilder();"},{"sha":"b55a1dd993c529a8418ced531f9785b98c8fe4f9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -63,6 +63,7 @@\n     //Disk utilization\n     protected final static String DISK_USAGE_THRESHOLD = \"diskUsageThreshold\";\n     protected final static String DISK_CHECK_INTERVAL = \"diskCheckInterval\";\n+    protected final static String AUDITOR_PERIODIC_CHECK_INTERVAL = \"auditorPeriodicCheckInterval\";\n \n     /**\n      * Construct a default configuration object\n@@ -646,4 +647,23 @@ public ServerConfiguration setDiskCheckInterval(int interval) {\n     public int getDiskCheckInterval() {\n         return getInt(DISK_CHECK_INTERVAL, 10 * 1000);\n     }\n+\n+    /**\n+     * Set the regularity at which the auditor will run a check\n+     * of all ledgers. This should not be run very often, and at most,\n+     * once a day.\n+     *\n+     * @param interval The interval in seconds. e.g. 86400 = 1 day, 604800 = 1 week\n+     */\n+    public void setAuditorPeriodicCheckInterval(long interval) {\n+        setProperty(AUDITOR_PERIODIC_CHECK_INTERVAL, interval);\n+    }\n+\n+    /**\n+     * Get the regularity at which the auditor checks all ledgers.\n+     * @return The interval in seconds\n+     */\n+    public long getAuditorPeriodicCheckInterval() {\n+        return getLong(AUDITOR_PERIODIC_CHECK_INTERVAL, 86400);\n+    }\n }"},{"sha":"b565e7fe340edc30e25002ef376ee742ad1be6a2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -50,6 +50,15 @@ void markLedgerReplicated(long ledgerId)\n     long getLedgerToRereplicate()\n             throws ReplicationException.UnavailableException;\n \n+    /**\n+     * Poll for a underreplicated ledger to rereplicate.\n+     * @see #getLedgerToRereplicate\n+     * @return the ledgerId, or -1 if none are available\n+     */\n+    long pollLedgerToRereplicate()\n+            throws ReplicationException.UnavailableException;\n+\n+\n     /**\n      * Release a previously acquired ledger. This allows others to acquire\n      * the ledger"},{"sha":"bea8a1c6f9920421d68362c40e161ef099fea228","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -369,6 +369,24 @@ private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watc\n         return -1;\n     }\n \n+\n+    @Override\n+    public long pollLedgerToRereplicate() throws ReplicationException.UnavailableException {\n+        LOG.debug(\"pollLedgerToRereplicate()\");\n+        try {\n+            Watcher w = new Watcher() {\n+                    public void process(WatchedEvent e) { // do nothing\n+                    }\n+                };\n+            return getLedgerToRereplicateFromHierarchy(urLedgerPath, 0, w);\n+        } catch (KeeperException ke) {\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while connecting zookeeper\", ie);\n+        }\n+    }\n+\n     @Override\n     public long getLedgerToRereplicate() throws ReplicationException.UnavailableException {\n         LOG.debug(\"getLedgerToRereplicate()\");"},{"sha":"5f616fc4f14376853d4b931b5b16566afc633118","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":213,"deletions":12,"changes":225,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -26,22 +26,46 @@\n import java.util.ArrayList;\n import java.util.Map;\n import java.util.Set;\n+\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ThreadFactory;\n \n-import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import java.net.InetSocketAddress;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerChecker;\n+import org.apache.bookkeeper.client.LedgerFragment;\n+import org.apache.bookkeeper.util.StringUtils;\n+\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+\n import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.commons.collections.CollectionUtils;\n+import com.google.common.collect.Sets;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.Watcher.Event.EventType;\n import org.apache.zookeeper.Watcher.Event.KeeperState;\n import org.slf4j.Logger;\n@@ -56,21 +80,21 @@\n  */\n public class Auditor implements Watcher {\n     private static final Logger LOG = LoggerFactory.getLogger(Auditor.class);\n-\n-    private final AbstractConfiguration conf;\n+    private final ServerConfiguration conf;\n     private final ZooKeeper zkc;\n     private BookieLedgerIndexer bookieLedgerIndexer;\n+    private LedgerManager ledgerManager;\n     private LedgerUnderreplicationManager ledgerUnderreplicationManager;\n-    private final ExecutorService executor;\n+    private final ScheduledExecutorService executor;\n     private List<String> knownBookies = new ArrayList<String>();\n \n-    public Auditor(final String bookieIdentifier, AbstractConfiguration conf,\n-            ZooKeeper zkc) throws UnavailableException {\n+    public Auditor(final String bookieIdentifier, ServerConfiguration conf,\n+                   ZooKeeper zkc) throws UnavailableException {\n         this.conf = conf;\n         this.zkc = zkc;\n         initialize(conf, zkc);\n \n-        executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n+        executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n                 @Override\n                 public Thread newThread(Runnable r) {\n                     Thread t = new Thread(r, \"AuditorBookie-\" + bookieIdentifier);\n@@ -80,14 +104,13 @@ public Thread newThread(Runnable r) {\n             });\n     }\n \n-    private void initialize(AbstractConfiguration conf, ZooKeeper zkc)\n+    private void initialize(ServerConfiguration conf, ZooKeeper zkc)\n             throws UnavailableException {\n         try {\n             LedgerManagerFactory ledgerManagerFactory = LedgerManagerFactory\n                     .newLedgerManagerFactory(conf, zkc);\n-\n-            this.bookieLedgerIndexer = new BookieLedgerIndexer(\n-                    ledgerManagerFactory.newLedgerManager());\n+            ledgerManager = ledgerManagerFactory.newLedgerManager();\n+            this.bookieLedgerIndexer = new BookieLedgerIndexer(ledgerManager);\n \n             this.ledgerUnderreplicationManager = ledgerManagerFactory\n                     .newLedgerUnderreplicationManager();\n@@ -173,6 +196,42 @@ public void start() {\n             if (executor.isShutdown()) {\n                 return;\n             }\n+\n+            long interval = conf.getAuditorPeriodicCheckInterval();\n+            if (interval > 0) {\n+                LOG.info(\"Periodic checking enabled\");\n+                executor.scheduleAtFixedRate(new Runnable() {\n+                        public void run() {\n+                            LOG.info(\"Running periodic check\");\n+\n+                            try {\n+                                if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {\n+                                    LOG.info(\"Ledger replication disabled, skipping\");\n+                                    return;\n+                                }\n+\n+                                checkAllLedgers();\n+                            } catch (KeeperException ke) {\n+                                LOG.error(\"Exception while running periodic check\", ke);\n+                            } catch (InterruptedException ie) {\n+                                Thread.currentThread().interrupt();\n+                                LOG.error(\"Interrupted while running periodic check\", ie);\n+                            } catch (BKAuditException bkae) {\n+                                LOG.error(\"Exception while running periodic check\", bkae);\n+                            } catch (BKException bke) {\n+                                LOG.error(\"Exception running periodic check\", bke);\n+                            } catch (IOException ioe) {\n+                                LOG.error(\"I/O exception running periodic check\", ioe);\n+                            } catch (ReplicationException.UnavailableException ue) {\n+                                LOG.error(\"Underreplication manager unavailable \"\n+                                          +\"running periodic check\", ue);\n+                            }\n+                        }\n+                    }, interval, interval, TimeUnit.MILLISECONDS);\n+            } else {\n+                LOG.info(\"Periodic checking disabled\");\n+            }\n+\n             executor.submit(new Runnable() {\n                     public void run() {\n                         try {\n@@ -262,6 +321,148 @@ private void publishSuspectedLedgers(String bookieIP, Set<Long> ledgers)\n         }\n     }\n \n+    /**\n+     * Process the result returned from checking a ledger\n+     */\n+    private class ProcessLostFragmentsCb implements GenericCallback<Set<LedgerFragment>> {\n+        final LedgerHandle lh;\n+        final AsyncCallback.VoidCallback callback;\n+\n+        ProcessLostFragmentsCb(LedgerHandle lh, AsyncCallback.VoidCallback callback) {\n+            this.lh = lh;\n+            this.callback = callback;\n+        }\n+\n+        public void operationComplete(int rc, Set<LedgerFragment> fragments) {\n+            try {\n+                if (rc == BKException.Code.OK) {\n+                    Set<InetSocketAddress> bookies = Sets.newHashSet();\n+                    for (LedgerFragment f : fragments) {\n+                        bookies.add(f.getAddress());\n+                    }\n+                    for (InetSocketAddress bookie : bookies) {\n+                        publishSuspectedLedgers(StringUtils.addrToString(bookie),\n+                                                Sets.newHashSet(lh.getId()));\n+                    }\n+                }\n+                lh.close();\n+            } catch (BKException bke) {\n+                LOG.error(\"Error closing lh\", bke);\n+                if (rc == BKException.Code.OK) {\n+                    rc = BKException.Code.ZKException;\n+                }\n+            } catch (KeeperException ke) {\n+                LOG.error(\"Couldn't publish suspected ledger\", ke);\n+                if (rc == BKException.Code.OK) {\n+                    rc = BKException.Code.ZKException;\n+                }\n+            } catch (InterruptedException ie) {\n+                LOG.error(\"Interrupted publishing suspected ledger\", ie);\n+                Thread.currentThread().interrupt();\n+                if (rc == BKException.Code.OK) {\n+                    rc = BKException.Code.InterruptedException;\n+                }\n+            } catch (BKAuditException bkae) {\n+                LOG.error(\"Auditor exception publishing suspected ledger\", bkae);\n+                if (rc == BKException.Code.OK) {\n+                    rc = BKException.Code.ZKException;\n+                }\n+            }\n+\n+            callback.processResult(rc, null, null);\n+        }\n+    }\n+\n+    /**\n+     * List all the ledgers and check them individually. This should not\n+     * be run very often.\n+     */\n+    private void checkAllLedgers() throws BKAuditException, BKException,\n+            IOException, InterruptedException, KeeperException {\n+        ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(conf.getZkTimeout());\n+        ZooKeeper newzk = ZkUtils.createConnectedZookeeperClient(conf.getZkServers(), w);\n+\n+        final BookKeeper client = new BookKeeper(new ClientConfiguration(conf),\n+                                                 newzk);\n+        final BookKeeperAdmin admin = new BookKeeperAdmin(client);\n+\n+        try {\n+            final LedgerChecker checker = new LedgerChecker(client);\n+\n+            final AtomicInteger returnCode = new AtomicInteger(BKException.Code.OK);\n+            final CountDownLatch processDone = new CountDownLatch(1);\n+\n+            Processor<Long> checkLedgersProcessor = new Processor<Long>() {\n+                @Override\n+                public void process(final Long ledgerId,\n+                                    final AsyncCallback.VoidCallback callback) {\n+                    try {\n+                        if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {\n+                            LOG.info(\"Ledger rereplication has been disabled, aborting periodic check\");\n+                            processDone.countDown();\n+                            return;\n+                        }\n+                    } catch (ReplicationException.UnavailableException ue) {\n+                        LOG.error(\"Underreplication manager unavailable \"\n+                                  +\"running periodic check\", ue);\n+                        processDone.countDown();\n+                        return;\n+                    }\n+\n+                    LedgerHandle lh = null;\n+                    try {\n+                        lh = admin.openLedgerNoRecovery(ledgerId);\n+                        checker.checkLedger(lh, new ProcessLostFragmentsCb(lh, callback));\n+                    } catch (BKException bke) {\n+                        LOG.error(\"Couldn't open ledger \" + ledgerId, bke);\n+                        callback.processResult(BKException.Code.BookieHandleNotAvailableException,\n+                                         null, null);\n+                        return;\n+                    } catch (InterruptedException ie) {\n+                        LOG.error(\"Interrupted opening ledger\", ie);\n+                        Thread.currentThread().interrupt();\n+                        callback.processResult(BKException.Code.InterruptedException, null, null);\n+                        return;\n+                    } finally {\n+                        if (lh != null) {\n+                            try {\n+                                lh.close();\n+                            } catch (BKException bke) {\n+                                LOG.warn(\"Couldn't close ledger \" + ledgerId, bke);\n+                            } catch (InterruptedException ie) {\n+                                LOG.warn(\"Interrupted closing ledger \" + ledgerId, ie);\n+                                Thread.currentThread().interrupt();\n+                            }\n+                        }\n+                    }\n+                }\n+            };\n+\n+            ledgerManager.asyncProcessLedgers(checkLedgersProcessor,\n+                    new AsyncCallback.VoidCallback() {\n+                        @Override\n+                        public void processResult(int rc, String s, Object obj) {\n+                            returnCode.set(rc);\n+                            processDone.countDown();\n+                        }\n+                    }, null, BKException.Code.OK, BKException.Code.ReadException);\n+            try {\n+                processDone.await();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new BKAuditException(\n+                        \"Exception while checking ledgers\", e);\n+            }\n+            if (returnCode.get() != BKException.Code.OK) {\n+                throw BKException.create(returnCode.get());\n+            }\n+        } finally {\n+            admin.close();\n+            client.close();\n+            newzk.close();\n+        }\n+    }\n+\n     @Override\n     public void process(WatchedEvent event) {\n         // listen children changed event from ZooKeeper"},{"sha":"fb82dab6152eb91156657b3c2b2bad9e5159309d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -32,7 +32,7 @@\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.commons.lang.StringUtils;\n@@ -74,7 +74,7 @@\n     private final String electionPath;\n \n     private final String bookieId;\n-    private final AbstractConfiguration conf;\n+    private final ServerConfiguration conf;\n     private final ZooKeeper zkc;\n     private final ExecutorService executor;\n \n@@ -95,7 +95,7 @@\n      * @throws UnavailableException\n      *             throws unavailable exception while initializing the elector\n      */\n-    public AuditorElector(final String bookieId, AbstractConfiguration conf,\n+    public AuditorElector(final String bookieId, ServerConfiguration conf,\n                           ZooKeeper zkc) throws UnavailableException {\n         this.bookieId = bookieId;\n         this.conf = conf;"},{"sha":"8f09707db29fc05753930a49b13fff35d0da20da","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -0,0 +1,35 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Accessor class to avoid making Bookie internals public\n+ */\n+public class BookieAccessor {\n+    /**\n+     * Force a bookie to flush its ledger storage\n+     */\n+    public static void forceFlush(Bookie b) throws IOException {\n+        b.ledgerStorage.flush();\n+    }\n+}\n\\ No newline at end of file"},{"sha":"1bd3141b4fab06d2e7b0d30387e3fdc4a5caa062","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -233,7 +233,7 @@ private void startAuditorElector(String addr) throws Exception {\n         zkClients.add(zk);\n \n         AuditorElector auditorElector = new AuditorElector(addr,\n-                                                           baseClientConf, zk);\n+                                                           baseConf, zk);\n         auditorElectors.put(addr, auditorElector);\n         auditorElector.start();\n         LOG.debug(\"Starting Auditor Elector\");"},{"sha":"8e35d6ce0d8652b93c994b47617526e78c767be2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -111,7 +111,7 @@ private void startAuditorElectors() throws Exception {\n         for (BookieServer bserver : bs) {\n             String addr = StringUtils.addrToString(bserver.getLocalAddress());\n             AuditorElector auditorElector = new AuditorElector(addr,\n-                    baseClientConf, zkc);\n+                    baseConf, zkc);\n             auditorElectors.put(addr, auditorElector);\n             auditorElector.start();\n             LOG.debug(\"Starting Auditor Elector\");"},{"sha":"b30bd4958e6e122eac40216212b600ce7f6a1d00","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","status":"added","additions":276,"deletions":0,"changes":276,"blob_url":"https://github.com/apache/bookkeeper/blob/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/005b62cc60093dd5b32d4abecd06c2e441bc62ae/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java?ref=005b62cc60093dd5b32d4abecd06c2e441bc62ae","patch":"@@ -0,0 +1,276 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.bookkeeper.bookie.BookieAccessor;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.LedgerCacheImpl;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.junit.Before;\n+import org.junit.After;\n+import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This test verifies that the period check on the auditor\n+ * will pick up on missing data in the client\n+ */\n+public class AuditorPeriodicCheckTest extends BookKeeperClusterTestCase {\n+    private final static Logger LOG = LoggerFactory\n+            .getLogger(AuditorPeriodicCheckTest.class);\n+\n+    private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n+    private List<ZooKeeper> zkClients = new LinkedList<ZooKeeper>();\n+\n+    private final static int CHECK_INTERVAL = 1000; // run every second\n+\n+    public AuditorPeriodicCheckTest() {\n+        super(3);\n+        baseConf.setPageLimit(1); // to make it easy to push ledger out of cache\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        for (int i = 0; i < numBookies; i++) {\n+            ServerConfiguration conf = new ServerConfiguration(bsConfs.get(i));\n+            conf.setAuditorPeriodicCheckInterval(CHECK_INTERVAL);\n+\n+            String addr = StringUtils.addrToString(bs.get(i).getLocalAddress());\n+\n+            ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(10000);\n+            ZooKeeper zk = ZkUtils.createConnectedZookeeperClient(\n+                    zkUtil.getZooKeeperConnectString(), w);\n+            zkClients.add(zk);\n+\n+            AuditorElector auditorElector = new AuditorElector(addr,\n+                                                               conf, zk);\n+            auditorElectors.put(addr, auditorElector);\n+            auditorElector.start();\n+            LOG.debug(\"Starting Auditor Elector\");\n+        }\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        for (AuditorElector e : auditorElectors.values()) {\n+            e.shutdown();\n+        }\n+        for (ZooKeeper zk : zkClients) {\n+            zk.close();\n+        }\n+        zkClients.clear();\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * test that the periodic checking will detect corruptions in\n+     * the bookie entry log\n+     */\n+    @Test(timeout=30000)\n+    public void testEntryLogCorruption() throws Exception {\n+        LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bsConfs.get(0), zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory.newLedgerUnderreplicationManager();\n+        underReplicationManager.disableLedgerReplication();\n+\n+        LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, \"passwd\".getBytes());\n+        long ledgerId = lh.getId();\n+        for (int i = 0; i < 100; i++) {\n+            lh.addEntry(\"testdata\".getBytes());\n+        }\n+        lh.close();\n+\n+        BookieAccessor.forceFlush(bs.get(0).getBookie());\n+\n+\n+        File ledgerDir = bsConfs.get(0).getLedgerDirs()[0];\n+        ledgerDir = Bookie.getCurrentDirectory(ledgerDir);\n+        // corrupt of entryLogs\n+        File[] entryLogs = ledgerDir.listFiles(new FilenameFilter() {\n+                public boolean accept(File dir, String name) {\n+                    return name.endsWith(\".log\");\n+                }\n+            });\n+        ByteBuffer junk = ByteBuffer.allocate(1024*1024);\n+        for (File f : entryLogs) {\n+            FileOutputStream out = new FileOutputStream(f);\n+            out.getChannel().write(junk);\n+            out.close();\n+        }\n+        restartBookies(); // restart to clear read buffers\n+\n+        underReplicationManager.enableLedgerReplication();\n+        long underReplicatedLedger = -1;\n+        for (int i = 0; i < 10; i++) {\n+            underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n+            if (underReplicatedLedger != -1) {\n+                break;\n+            }\n+            Thread.sleep(CHECK_INTERVAL);\n+        }\n+        assertEquals(\"Ledger should be under replicated\", ledgerId, underReplicatedLedger);\n+        underReplicationManager.close();\n+    }\n+\n+    /**\n+     * test that the period checker will detect corruptions in\n+     * the bookie index files\n+     */\n+    @Test(timeout=30000)\n+    public void testIndexCorruption() throws Exception {\n+        LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bsConfs.get(0), zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory.newLedgerUnderreplicationManager();\n+\n+        LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, \"passwd\".getBytes());\n+        long ledgerToCorrupt = lh.getId();\n+        for (int i = 0; i < 100; i++) {\n+            lh.addEntry(\"testdata\".getBytes());\n+        }\n+        lh.close();\n+\n+        // push ledgerToCorrupt out of page cache (bookie is configured to only use 1 page)\n+        lh = bkc.createLedger(3, 3, DigestType.CRC32, \"passwd\".getBytes());\n+        for (int i = 0; i < 100; i++) {\n+            lh.addEntry(\"testdata\".getBytes());\n+        }\n+        lh.close();\n+\n+        BookieAccessor.forceFlush(bs.get(0).getBookie());\n+\n+        File ledgerDir = bsConfs.get(0).getLedgerDirs()[0];\n+        ledgerDir = Bookie.getCurrentDirectory(ledgerDir);\n+\n+        // corrupt of entryLogs\n+        File index = new File(ledgerDir, LedgerCacheImpl.getLedgerName(ledgerToCorrupt));\n+        LOG.info(\"file to corrupt{}\" , index);\n+        ByteBuffer junk = ByteBuffer.allocate(1024*1024);\n+        FileOutputStream out = new FileOutputStream(index);\n+        out.getChannel().write(junk);\n+        out.close();\n+\n+        long underReplicatedLedger = -1;\n+        for (int i = 0; i < 10; i++) {\n+            underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n+            if (underReplicatedLedger != -1) {\n+                break;\n+            }\n+            Thread.sleep(CHECK_INTERVAL);\n+        }\n+        assertEquals(\"Ledger should be under replicated\", ledgerToCorrupt, underReplicatedLedger);\n+        underReplicationManager.close();\n+    }\n+\n+    /**\n+     * Test that the period checker will not run when auto replication has been disabled\n+     */\n+    @Test(timeout=60000)\n+    public void testPeriodicCheckWhenDisabled() throws Exception {\n+        LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bsConfs.get(0), zkc);\n+        final LedgerUnderreplicationManager underReplicationManager = mFactory.newLedgerUnderreplicationManager();\n+        final int numLedgers = 100;\n+\n+        for (int i = 0; i < numLedgers; i++) {\n+            LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, \"passwd\".getBytes());\n+\n+            for (int j = 0; j < 100; j++) {\n+                lh.addEntry(\"testdata\".getBytes());\n+            }\n+            lh.close();\n+        }\n+        underReplicationManager.disableLedgerReplication();\n+\n+        final AtomicInteger numReads = new AtomicInteger(0);\n+        ServerConfiguration conf = killBookie(0);\n+\n+        Bookie deadBookie = new Bookie(conf) {\n+            @Override\n+            public ByteBuffer readEntry(long ledgerId, long entryId)\n+                    throws IOException, NoLedgerException {\n+                // we want to disable during checking\n+                numReads.incrementAndGet();\n+                try {\n+                    underReplicationManager.disableLedgerReplication();\n+                } catch (ReplicationException.UnavailableException ue) {\n+                    LOG.error(\"Couldn't disable ledger replication\", ue);\n+                }\n+                throw new IOException(\"Fake I/O exception\");\n+            }\n+        };\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf, deadBookie));\n+\n+        Thread.sleep(CHECK_INTERVAL * 2);\n+        assertEquals(\"Nothing should have tried to read\", 0, numReads.get());\n+        underReplicationManager.enableLedgerReplication();\n+\n+        int numUnderreplicated = 0;\n+        long underReplicatedLedger = -1;\n+        for (int i = 0; i < 10; i++) {\n+            underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n+            if (underReplicatedLedger != -1) {\n+                break;\n+            }\n+            Thread.sleep(CHECK_INTERVAL);\n+        }\n+        assertTrue(\"Some ledger should be under replicated\", -1 != underReplicatedLedger);\n+        numUnderreplicated++;\n+        underReplicationManager.markLedgerReplicated(underReplicatedLedger);\n+        while (underReplicatedLedger != -1) {\n+            underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n+            if (underReplicatedLedger == -1) {\n+                break;\n+            } else {\n+                numUnderreplicated++;\n+            }\n+            underReplicationManager.markLedgerReplicated(underReplicatedLedger);\n+        }\n+        LOG.info(\"{} of {} ledgers underreplicated\", numUnderreplicated, numLedgers);\n+        assertTrue(\"Some but not all should be underreplicated\",\n+                   numUnderreplicated > 0 && numUnderreplicated < numLedgers);\n+    }\n+}"}]}

