{"sha":"028a6d5360637417141f7f819a404e8e71117f9b","node_id":"MDY6Q29tbWl0MTU3NTk1NjowMjhhNmQ1MzYwNjM3NDE3MTQxZjdmODE5YTQwNGU4ZTcxMTE3Zjli","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-03-09T13:48:20Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-03-09T13:48:20Z"},"message":"BOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1298825 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7071337c81eb3d1f33583a21a873a07b021108c1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7071337c81eb3d1f33583a21a873a07b021108c1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/028a6d5360637417141f7f819a404e8e71117f9b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/028a6d5360637417141f7f819a404e8e71117f9b","html_url":"https://github.com/apache/bookkeeper/commit/028a6d5360637417141f7f819a404e8e71117f9b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/028a6d5360637417141f7f819a404e8e71117f9b/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"cb8296636b961253f9586f535db285bfafa54a8a","url":"https://api.github.com/repos/apache/bookkeeper/commits/cb8296636b961253f9586f535db285bfafa54a8a","html_url":"https://github.com/apache/bookkeeper/commit/cb8296636b961253f9586f535db285bfafa54a8a"}],"stats":{"total":1360,"additions":1359,"deletions":1},"files":[{"sha":"6aced17b372cf09a629ed4b39ef20a9abf630d6f","filename":"CHANGES.txt","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -84,6 +84,9 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n \n+      bookkeeper-benchmark/\n+\tBOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n+\n Release 4.0.0 - 2011-11-30\n \n   Non-backward compatible changes:"},{"sha":"3158aac140f83444b9bf0698c044a75b78ebaaae","filename":"bookkeeper-benchmark/bin/benchmark","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/bin/benchmark","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/bin/benchmark","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/bin/benchmark?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,131 @@\n+#!/usr/bin/env bash\n+#\n+#/**\n+# * Copyright 2007 The Apache Software Foundation\n+# *\n+# * Licensed to the Apache Software Foundation (ASF) under one\n+# * or more contributor license agreements.  See the NOTICE file\n+# * distributed with this work for additional information\n+# * regarding copyright ownership.  The ASF licenses this file\n+# * to you under the Apache License, Version 2.0 (the\n+# * \"License\"); you may not use this file except in compliance\n+# * with the License.  You may obtain a copy of the License at\n+# *\n+# *     http://www.apache.org/licenses/LICENSE-2.0\n+# *\n+# * Unless required by applicable law or agreed to in writing, software\n+# * distributed under the License is distributed on an \"AS IS\" BASIS,\n+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# * See the License for the specific language governing permissions and\n+# * limitations under the License.\n+# */\n+\n+# check if net.ipv6.bindv6only is set to 1\n+bindv6only=$(/sbin/sysctl -n net.ipv6.bindv6only 2> /dev/null)\n+if [ -n \"$bindv6only\" ] && [ \"$bindv6only\" -eq \"1\" ]\n+then\n+  echo \"Error: \\\"net.ipv6.bindv6only\\\" is set to 1 - Java networking could be broken\"\n+  echo \"For more info (the following page also applies to bookkeeper): http://wiki.apache.org/hadoop/HadoopIPv6\"\n+  exit 1\n+fi\n+\n+BINDIR=`dirname \"$0\"`\n+BENCH_HOME=`cd $BINDIR/..;pwd`\n+\n+RELEASE_JAR=`ls $BENCH_HOME/bookkeeper-benchmark-*.jar 2> /dev/null | tail -1` \n+if [ $? == 0 ]; then\n+    BENCHMARK_JAR=$RELEASE_JAR\n+fi\n+\n+BUILT_JAR=`ls $BENCH_HOME/target/bookkeeper-benchmark-*.jar 2> /dev/null | tail -1`\n+if [ $? != 0 ] && [ ! -e \"$BENCHMARK_JAR\" ]; then \n+    echo \"\\nCouldn't find benchmark jar.\";\n+    echo \"Make sure you've run 'mvn package'\\n\";\n+    exit 1;\n+elif [ -e \"$BUILT_JAR\" ]; then\n+    BENCHMARK_JAR=$BUILT_JAR\n+fi\n+\n+benchmark_help() {\n+    cat <<EOF\n+Usage: $0 <command>\n+where command is one of:\n+    writes              Benchmark throughput and latency for writes\n+    reads               Benchmark throughput and latency for reads\n+    bookie              Benchmark an individual bookie\n+    help                This help message\n+\n+use -help with individual commands for more options. For example,\n+   $0 writes -help\n+\n+or command is the full name of a class with a defined main() method.\n+\n+Environment variables:\n+   BENCHMARK_LOG_CONF        Log4j configuration file (default: conf/log4j.properties)\n+   BENCHMARK_EXTRA_OPTS      Extra options to be passed to the jvm\n+   BENCHMARK_EXTRA_CLASSPATH Add extra paths to the bookkeeper classpath\n+\n+EOF\n+}\n+\n+add_maven_deps_to_classpath() {\n+    MVN=\"mvn\"\n+    if [ \"$MAVEN_HOME\" != \"\" ]; then\n+\tMVN=${MAVEN_HOME}/bin/mvn\n+    fi\n+    \n+    # Need to generate classpath from maven pom. This is costly so generate it\n+    # and cache it. Save the file into our target dir so a mvn clean will get\n+    # clean it up and force us create a new one.\n+    f=\"${BENCH_HOME}/target/cached_classpath.txt\"\n+    if [ ! -f \"${f}\" ]\n+    then\n+\t${MVN} -f \"${BENCH_HOME}/pom.xml\" dependency:build-classpath -Dmdep.outputFile=\"${f}\" &> /dev/null\n+    fi\n+    BENCHMARK_CLASSPATH=${CLASSPATH}:`cat \"${f}\"`\n+}\n+\n+if [ -d \"$BENCH_HOME/lib\" ]; then\n+    for i in $BENCH_HOME/lib/*.jar; do\n+\tBENCHMARK_CLASSPATH=$BENCHMARK_CLASSPATH:$i\n+    done\n+else\n+    add_maven_deps_to_classpath\n+fi\n+\n+# if no args specified, show usage\n+if [ $# = 0 ]; then\n+    benchmark_help;\n+    exit 1;\n+fi\n+\n+# get arguments\n+COMMAND=$1\n+shift\n+\n+BENCHMARK_CLASSPATH=\"$BENCHMARK_JAR:$BENCHMARK_CLASSPATH:$BENCHMARK_EXTRA_CLASSPATH\"\n+BENCHMARK_LOG_CONF=${BENCHMARK_LOG_CONF:-$BENCH_HOME/conf/log4j.properties}\n+\n+if [ \"$BENCHMARK_LOG_CONF\" != \"\" ]; then\n+    BENCHMARK_CLASSPATH=\"`dirname $BENCHMARK_LOG_CONF`:$BENCHMARK_CLASSPATH\"\n+    OPTS=\"$OPTS -Dlog4j.configuration=`basename $BENCHMARK_LOG_CONF`\"\n+fi\n+OPTS=\"-cp $BENCHMARK_CLASSPATH $OPTS $BENCHMARK_EXTRA_OPTS\"\n+\n+OPTS=\"$OPTS $BENCHMARK_EXTRA_OPTS\"\n+\n+# Disable ipv6 as it can cause issues\n+OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n+\n+if [ $COMMAND == \"writes\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.benchmark.BenchThroughputLatency $@\n+elif [ $COMMAND == \"reads\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.benchmark.BenchReadThroughputLatency $@\n+elif [ $COMMAND == \"bookie\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.benchmark.BenchBookie $@\n+elif [ $COMMAND == \"help\" ]; then\n+    benchmark_help;\n+else\n+    exec java $OPTS $COMMAND $@\n+fi\n+"},{"sha":"79e0db26a66e74fd6f6908e1e27962e34e5d9c04","filename":"bookkeeper-benchmark/conf/log4j.properties","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/conf/log4j.properties?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,73 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+#\n+# Bookkeeper Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+log4j.rootLogger=ERROR, CONSOLE\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+log4j.logger.org.apache.bookkeeper.benchmark=INFO\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=DEBUG\n+log4j.appender.ROLLINGFILE.File=bookkeeper-benchmark.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"4164253dd4a622ba1b6bbad299c5fe704f8dc257","filename":"bookkeeper-benchmark/pom.xml","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/pom.xml?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -106,5 +106,10 @@\n \t</exclusion>\n       </exclusions>\n     </dependency>\n+    <dependency>\n+      <groupId>commons-cli</groupId>\n+      <artifactId>commons-cli</artifactId>\n+      <version>1.2</version>\n+    </dependency>\n   </dependencies>\n </project>"},{"sha":"46ca77c9d4dd0148bc23750f1adb4743cb8971e6","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BenchBookie {\n+    static Logger LOG = LoggerFactory.getLogger(BenchBookie.class);\n+\n+    static class LatencyCallback implements WriteCallback {\n+        boolean complete;\n+        @Override\n+        synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n+                InetSocketAddress addr, Object ctx) {\n+            if (rc != 0) {\n+                LOG.error(\"Got error \" + rc);\n+            }\n+            complete = true;\n+            notifyAll();\n+        }\n+        synchronized public void resetComplete() {\n+            complete = false;\n+        }\n+        synchronized public void waitForComplete() throws InterruptedException {\n+            while(!complete) {\n+                wait();\n+            }\n+        }\n+    }\n+\n+    static class ThroughputCallback implements WriteCallback {\n+        int count;\n+        int waitingCount = Integer.MAX_VALUE;\n+        synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n+                InetSocketAddress addr, Object ctx) {\n+            if (rc != 0) {\n+                LOG.error(\"Got error \" + rc);\n+            }\n+            count++;\n+            if (count >= waitingCount) {\n+                notifyAll();\n+            }\n+        }\n+        synchronized public void waitFor(int count) throws InterruptedException {\n+            while(this.count < count) {\n+                waitingCount = count;\n+                wait(1000);\n+            }\n+            waitingCount = Integer.MAX_VALUE;\n+        }\n+    }\n+\n+    /**\n+     * @param args\n+     * @throws InterruptedException\n+     */\n+    public static void main(String[] args) throws InterruptedException, ParseException {\n+        Options options = new Options();\n+        options.addOption(\"host\", true, \"Hostname or IP of bookie to benchmark\");\n+        options.addOption(\"port\", true, \"Port of bookie to benchmark (default 3181)\");\n+        options.addOption(\"ledger\", true, \"Ledger Id to write to (default 1)\");\n+        options.addOption(\"help\", false, \"This message\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\") || !cmd.hasOption(\"host\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"BenchBookie <options>\", options);\n+            System.exit(-1);\n+        }\n+\n+        String addr = cmd.getOptionValue(\"host\");\n+        int port = Integer.valueOf(cmd.getOptionValue(\"port\", \"3181\"));\n+        int ledger = Integer.valueOf(cmd.getOptionValue(\"ledger\", \"1\"));\n+\n+        ClientSocketChannelFactory channelFactory\n+            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n+                                                .newCachedThreadPool());\n+        OrderedSafeExecutor executor = new OrderedSafeExecutor(1);\n+\n+        ClientConfiguration conf = new ClientConfiguration();\n+        BookieClient bc = new BookieClient(conf, channelFactory, executor);\n+        LatencyCallback lc = new LatencyCallback();\n+\n+        ThroughputCallback tc = new ThroughputCallback();\n+        int warmUpCount = 999;\n+        for(long entry = 0; entry < warmUpCount; entry++) {\n+            ChannelBuffer toSend = ChannelBuffers.buffer(128);\n+            toSend.resetReaderIndex();\n+            toSend.resetWriterIndex();\n+            toSend.writeLong(ledger);\n+            toSend.writeLong(entry);\n+            toSend.writerIndex(toSend.capacity());\n+            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20], \n+                        entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n+        }\n+        LOG.info(\"Waiting for warmup\");\n+        tc.waitFor(warmUpCount);\n+\n+        LOG.info(\"Benchmarking latency\");\n+        int entryCount = 5000;\n+        long startTime = System.nanoTime();\n+        for(long entry = 0; entry < entryCount; entry++) {\n+            ChannelBuffer toSend = ChannelBuffers.buffer(128);\n+            toSend.resetReaderIndex();\n+            toSend.resetWriterIndex();\n+            toSend.writeLong(ledger+1);\n+            toSend.writeLong(entry);\n+            toSend.writerIndex(toSend.capacity());\n+            lc.resetComplete();\n+            bc.addEntry(new InetSocketAddress(addr, port), ledger+1, new byte[20], \n+                        entry, toSend, lc, null, BookieProtocol.FLAG_NONE);\n+            lc.waitForComplete();\n+        }\n+        long endTime = System.nanoTime();\n+        LOG.info(\"Latency: \" + (((double)(endTime-startTime))/((double)entryCount))/1000000.0);\n+\n+        entryCount = 50000;\n+        LOG.info(\"Benchmarking throughput\");\n+        startTime = System.currentTimeMillis();\n+        tc = new ThroughputCallback();\n+        for(long entry = 0; entry < entryCount; entry++) {\n+            ChannelBuffer toSend = ChannelBuffers.buffer(128);\n+            toSend.resetReaderIndex();\n+            toSend.resetWriterIndex();\n+            toSend.writeLong(ledger+2);\n+            toSend.writeLong(entry);\n+            toSend.writerIndex(toSend.capacity());\n+            bc.addEntry(new InetSocketAddress(addr, port), ledger+2, new byte[20], \n+                        entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n+        }\n+        tc.waitFor(entryCount);\n+        endTime = System.currentTimeMillis();\n+        LOG.info(\"Throughput: \" + ((long)entryCount)*1000/(endTime-startTime));\n+    }\n+\n+}"},{"sha":"7435863b102555fd2b72d93fd88a6922956fe877","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","status":"added","additions":260,"deletions":0,"changes":260,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher.Event;\n+\n+import java.util.Enumeration;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BenchReadThroughputLatency {\n+    static Logger LOG = LoggerFactory.getLogger(BenchReadThroughputLatency.class);\n+\n+    private static final Pattern LEDGER_PATTERN = Pattern.compile(\"L([0-9]+)$\");\n+\n+    private static final Comparator<String> ZK_LEDGER_COMPARE = new Comparator<String>() {\n+        public int compare(String o1, String o2) {\n+            try {\n+                Matcher m1 = LEDGER_PATTERN.matcher(o1);\n+                Matcher m2 = LEDGER_PATTERN.matcher(o2);\n+                if (m1.find() && m2.find()) {\n+                    return Integer.valueOf(m1.group(1))\n+                        - Integer.valueOf(m2.group(1));\n+                } else {\n+                    return o1.compareTo(o2);\n+                }\n+            } catch (Throwable t) {\n+                return o1.compareTo(o2);\n+            }\n+        }\n+    };\n+\n+    private static void readLedger(String zkservers, long ledgerId, byte[] passwd) {\n+        LOG.info(\"Reading ledger {}\", ledgerId);\n+        BookKeeper bk = null;\n+        long time = 0;\n+        long entriesRead = 0;\n+        long lastRead = 0;\n+        int nochange = 0;\n+\n+        LedgerHandle lh = null;\n+        try {\n+            bk = new BookKeeper(zkservers);\n+            while (true) {\n+                lh = bk.openLedgerNoRecovery(ledgerId, BookKeeper.DigestType.CRC32, \n+                                             passwd);\n+                long lastConfirmed = lh.getLastAddConfirmed();\n+                if (lastConfirmed == lastRead) {\n+                    nochange++;\n+                    if (nochange == 10) {\n+                        break;\n+                    } else {\n+                        Thread.sleep(1000);\n+                        continue;\n+                    }\n+                } else {\n+                    nochange = 0;\n+                }\n+                long starttime = System.nanoTime();\n+\n+                Enumeration<LedgerEntry> entries = lh.readEntries(lastRead+1, lastConfirmed);\n+                lastRead = lastConfirmed;\n+                while (entries.hasMoreElements()) {\n+                    LedgerEntry e = entries.nextElement();\n+                    entriesRead++;\n+                    if ((entriesRead % 10000) == 0) {\n+                        LOG.info(\"{} entries read\", entriesRead);\n+                    }\n+                }\n+                long endtime = System.nanoTime();\n+                time += endtime - starttime;\n+\n+                lh.close();\n+                lh = null;\n+                Thread.sleep(1000);\n+            }\n+        } catch (InterruptedException ie) {\n+            // ignore\n+        } catch (Exception e ) {\n+            LOG.error(\"Exception in reader\", e);\n+        } finally {\n+            LOG.info(\"Read {} in {}ms\", entriesRead, time/1000/1000);\n+\n+            try {\n+                if (lh != null) {\n+                    lh.close();\n+                }\n+                if (bk != null) {\n+                    bk.close();\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Exception closing stuff\", e);\n+            }\n+        }\n+    }\n+\n+    private static void usage(Options options) {\n+        HelpFormatter formatter = new HelpFormatter();\n+        formatter.printHelp(\"BenchReadThroughputLatency <options>\", options);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Options options = new Options();\n+        options.addOption(\"ledger\", true, \"Ledger to read. If empty, read all ledgers which come available. \" \n+                          + \" Cannot be used with -listen\");\n+        options.addOption(\"listen\", true, \"Listen for creation of <arg> ledgers, and read each one fully\");\n+        options.addOption(\"password\", true, \"Password used to access ledgers (default 'benchPasswd')\");\n+        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n+        options.addOption(\"help\", false, \"This message\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\")) {\n+            usage(options);\n+            System.exit(-1);\n+        }\n+\n+        final String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n+        final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes();\n+        if (cmd.hasOption(\"ledger\") && cmd.hasOption(\"listen\")) {\n+            LOG.error(\"Cannot used -ledger and -listen together\");\n+            usage(options);\n+            System.exit(-1);\n+        }\n+\n+        final AtomicInteger ledger = new AtomicInteger(0);\n+        final AtomicInteger numLedgers = new AtomicInteger(0);\n+        if (cmd.hasOption(\"ledger\")) {\n+            ledger.set(Integer.valueOf(cmd.getOptionValue(\"ledger\")));\n+        } else if (cmd.hasOption(\"listen\")) {\n+            numLedgers.set(Integer.valueOf(cmd.getOptionValue(\"listen\")));\n+        } else {\n+            LOG.error(\"You must use -ledger or -listen\");\n+            usage(options);\n+            System.exit(-1);\n+        }\n+\n+        final CountDownLatch shutdownLatch = new CountDownLatch(1);\n+        final CountDownLatch connectedLatch = new CountDownLatch(1);\n+        final String nodepath = String.format(\"/ledgers/L%010d\", ledger.get());\n+\n+        final ZooKeeper zk = new ZooKeeper(servers, 3000, new Watcher() {\n+                public void process(WatchedEvent event) {\n+                    if (event.getState() == Event.KeeperState.SyncConnected\n+                            && event.getType() == Event.EventType.None) {\n+                        connectedLatch.countDown();\n+                    }\n+                }\n+            });\n+        try {\n+            zk.register(new Watcher() {\n+                    public void process(WatchedEvent event) {\n+                        try {\n+                            if (event.getState() == Event.KeeperState.SyncConnected \n+                                && event.getType() == Event.EventType.None) {\n+                                connectedLatch.countDown();\n+                            } else if (event.getType() == Event.EventType.NodeCreated\n+                                       && event.getPath().equals(nodepath)) {\n+                                readLedger(servers, ledger.get(), passwd);\n+                                shutdownLatch.countDown();\n+                            } else if (event.getType() == Event.EventType.NodeChildrenChanged) {\n+                                if (numLedgers.get() < 0) {\n+                                    return;\n+                                }\n+                                List<String> children = zk.getChildren(\"/ledgers\", true);\n+                                List<String> ledgers = new ArrayList<String>();\n+                                for (String child : children) {\n+                                    if (LEDGER_PATTERN.matcher(child).find()) {\n+                                        ledgers.add(child);\n+                                    }\n+                                }\n+                                Collections.sort(ledgers, ZK_LEDGER_COMPARE);\n+                                String last = ledgers.get(ledgers.size() - 1);\n+                                final Matcher m = LEDGER_PATTERN.matcher(last);\n+                                if (m.find()) {\n+                                    int ledgersLeft = numLedgers.decrementAndGet();\n+                                    Thread t = new Thread() {\n+                                            public void run() {\n+                                                readLedger(servers, Long.valueOf(m.group(1)), passwd);\n+                                            }\n+                                        };\n+                                    t.start();\n+                                    if (ledgersLeft <= 0) {\n+                                        shutdownLatch.countDown();\n+                                    }\n+                                } else {\n+                                    LOG.error(\"Cant file ledger id in {}\", last);\n+                                }\n+                            } else {\n+                                LOG.warn(\"Unknown event {}\", event);\n+                            }\n+                        } catch (Exception e) {\n+                            LOG.error(\"Exception in watcher\", e);\n+                        }\n+                    }\n+                });\n+            connectedLatch.await();\n+            if (ledger.get() != 0) {\n+                if (zk.exists(nodepath, true) != null) {\n+                    readLedger(servers, ledger.get(), passwd);\n+                    shutdownLatch.countDown();\n+                } else {\n+                    LOG.info(\"Watching for creation of\" + nodepath);\n+                }\n+            } else {\n+                zk.getChildren(\"/ledgers\", true);\n+            }\n+            shutdownLatch.await();\n+            LOG.info(\"Shutting down\");\n+        } finally {\n+            zk.close();\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"e918996e20ec4748ed13860964add9867e6fda40","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","status":"added","additions":425,"deletions":0,"changes":425,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+public class BenchThroughputLatency implements AddCallback, Runnable {\n+    static Logger LOG = LoggerFactory.getLogger(BenchThroughputLatency.class);\n+\n+    BookKeeper bk;\n+    LedgerHandle lh[];\n+    AtomicLong counter;\n+\n+    Semaphore sem;\n+    int pace;\n+    int throttle;\n+    int numberOfLedgers = 1;\n+    final String servers;\n+\n+    class Context {\n+        long localStartTime;\n+        long globalStartTime;\n+        long id;\n+\n+        Context(long id, long time){\n+            this.id = id;\n+            this.localStartTime = this.globalStartTime = time;\n+        }\n+    }\n+\n+    public BenchThroughputLatency(int ensemble, int qSize, byte[] passwd,\n+                                  int throttle, int numberOfLedgers, String servers) \n+            throws KeeperException, IOException, InterruptedException {\n+        this.sem = new Semaphore(throttle);\n+        this.pace = pace;\n+        this.throttle = throttle;\n+\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setThrottleValue(100000);\n+        conf.setZkServers(servers);\n+        this.servers = servers;\n+\n+        bk = new BookKeeper(conf);\n+        this.counter = new AtomicLong(0);\n+        this.numberOfLedgers = numberOfLedgers;\n+        try{\n+            lh = new LedgerHandle[this.numberOfLedgers];\n+\n+            for(int i = 0; i < this.numberOfLedgers; i++) {\n+                lh[i] = bk.createLedger(ensemble, qSize, BookKeeper.DigestType.CRC32, \n+                                        passwd);\n+                LOG.info(\"Ledger Handle: \" + lh[i].getId());\n+            }\n+        } catch (BKException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    Random rand = new Random();\n+    public void close() throws InterruptedException, BKException {\n+        for(int i = 0; i < numberOfLedgers; i++) {\n+            lh[i].close();\n+        }\n+        bk.close();\n+    }\n+\n+    long previous = 0;\n+    byte bytes[];\n+\n+    void setEntryData(byte data[]) {\n+        bytes = data;\n+    }\n+\n+    int lastLedger = 0;\n+    private int getRandomLedger() {\n+         return rand.nextInt(numberOfLedgers);\n+    }\n+\n+    int sendLimit = 2000000;\n+    long latencies[] = new long[sendLimit];\n+    int latencyIndex = -1;\n+    AtomicLong completedRequests = new AtomicLong(0);\n+\n+    public void setSendLimit(int sendLimit) {\n+        this.sendLimit = sendLimit;\n+        latencies = new long[sendLimit];\n+    }\n+\n+    long duration = -1;\n+    synchronized public long getDuration() {\n+        return duration;\n+    }\n+\n+    public void run() {\n+        LOG.info(\"Running...\");\n+        long start = previous = System.currentTimeMillis();\n+\n+        byte messageCount = 0;\n+        int sent = 0;\n+\n+        Thread reporter = new Thread() {\n+                public void run() {\n+                    try {\n+                        while(true) {\n+                            Thread.sleep(200);\n+                            LOG.info(\"ms: {} req: {}\", System.currentTimeMillis(), completedRequests.getAndSet(0));\n+                        }\n+                    } catch (InterruptedException ie) {\n+                        LOG.info(\"Caught interrupted exception, going away\");\n+                    }\n+                }\n+            };\n+        reporter.start();\n+        long beforeSend = System.nanoTime();\n+\n+        while(!Thread.currentThread().isInterrupted() && sent < sendLimit) {\n+            try {\n+                sem.acquire();\n+                if (sent == 10000) {\n+                    long afterSend = System.nanoTime();\n+                    long time = afterSend - beforeSend;\n+                    LOG.info(\"Time to send first batch: {}s {}ns \",\n+                             time/1000/1000/1000, time);\n+                }\n+            } catch (InterruptedException e) {\n+                break;\n+            }\n+\n+            final int index = getRandomLedger();\n+            LedgerHandle h = lh[index];\n+            if (h == null) {\n+                LOG.error(\"Handle \" + index + \" is null!\");\n+            } else {\n+                long nanoTime = System.nanoTime();\n+                lh[index].asyncAddEntry(bytes, this, new Context(sent, nanoTime));\n+                counter.incrementAndGet();\n+            }\n+            sent++;\n+        }\n+        LOG.info(\"Sent: \"  + sent);\n+        try {\n+            synchronized (this) {\n+                while(this.counter.get() > 0)\n+                    Thread.sleep(1000);\n+            }\n+        } catch(InterruptedException e) {\n+            LOG.error(\"Interrupted while waiting\", e);\n+        }\n+        synchronized(this) {\n+            duration = System.currentTimeMillis() - start;\n+        }\n+        throughput = sent*1000/duration;\n+\n+        reporter.interrupt();\n+        try {\n+            reporter.join();\n+        } catch (InterruptedException ie) {\n+            // ignore\n+        }\n+        LOG.info(\"Finished processing in ms: \" + duration + \" tp = \" + throughput);\n+    }\n+\n+    long throughput = -1;\n+    public long getThroughput() {\n+        return throughput;\n+    }\n+\n+    long threshold = 20000;\n+    long runningAverageCounter = 0;\n+    long totalTime = 0;\n+    @Override\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        Context context = (Context) ctx;\n+\n+        // we need to use the id passed in the context in the case of\n+        // multiple ledgers, and it works even with one ledger\n+        entryId = context.id;\n+        long newTime = System.nanoTime() - context.localStartTime;\n+\n+        sem.release();\n+        counter.decrementAndGet();\n+\n+        latencies[(int)entryId] = newTime;\n+\n+        completedRequests.incrementAndGet();\n+    }\n+\n+    public static void main(String[] args)\n+            throws KeeperException, IOException, InterruptedException, ParseException, BKException {\n+        Options options = new Options();\n+        options.addOption(\"time\", true, \"Running time (seconds), default 60\");\n+        options.addOption(\"entrysize\", true, \"Entry size (bytes), default 1024\");\n+        options.addOption(\"ensemble\", true, \"Ensemble size, default 3\");\n+        options.addOption(\"quorum\", true, \"Quorum size, default 2\");\n+        options.addOption(\"throttle\", true, \"Max outstanding requests, default 10000\");\n+        options.addOption(\"ledgers\", true, \"Number of ledgers, default 1\");\n+        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n+        options.addOption(\"password\", true, \"Password used to create ledgers (default 'benchPasswd')\");\n+        options.addOption(\"coord_node\", true, \"Coordination znode for multi client benchmarks (optional)\");\n+        options.addOption(\"help\", false, \"This message\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"BenchThroughputLatency <options>\", options);\n+            System.exit(-1);\n+        }\n+\n+        long runningTime = Long.valueOf(cmd.getOptionValue(\"time\", \"60\"));\n+        String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n+        int entrysize = Integer.valueOf(cmd.getOptionValue(\"entrysize\", \"1024\"));\n+\n+        int ledgers = Integer.valueOf(cmd.getOptionValue(\"ledgers\", \"1\"));\n+        int ensemble = Integer.valueOf(cmd.getOptionValue(\"ensemble\", \"3\"));\n+        int quorum = Integer.valueOf(cmd.getOptionValue(\"quorum\", \"2\"));\n+        int throttle = Integer.valueOf(cmd.getOptionValue(\"throttle\", \"10000\"));\n+\n+        String coordinationZnode = cmd.getOptionValue(\"coord_node\");\n+        final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes();\n+\n+        LOG.warn(\"(Parameters received) running time: \" + runningTime +\n+                \", entry size: \" + entrysize + \", ensemble size: \" + ensemble +\n+                \", quorum size: \" + quorum +\n+                \", throttle: \" + throttle +\n+                \", number of ledgers: \" + ledgers +\n+                \", zk servers: \" + servers);\n+\n+        long totalTime = runningTime*1000;\n+\n+        // Do a warmup run\n+        Thread thread;\n+\n+        long lastWarmUpTP = -1;\n+        long throughput;\n+        LOG.info(\"Starting warmup\");\n+        byte data[] = new byte[entrysize];\n+        Arrays.fill(data, (byte)'x');\n+\n+        while(lastWarmUpTP < (throughput = warmUp(servers, data, ledgers, ensemble, quorum, passwd, throttle))) {\n+            LOG.info(\"Warmup tp: \" + throughput);\n+            lastWarmUpTP = throughput;\n+            // we will just run once, so lets break\n+            break;\n+        }\n+        LOG.info(\"Warmup phase finished\");\n+\n+        // Now do the benchmark\n+        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, passwd, throttle, ledgers, servers);\n+        bench.setEntryData(data);\n+        thread = new Thread(bench);\n+        ZooKeeper zk = null;\n+\n+        if (coordinationZnode != null) {\n+            final CountDownLatch connectLatch = new CountDownLatch(1);\n+            zk = new ZooKeeper(servers, 15000, new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        if (event.getState() == KeeperState.SyncConnected) {\n+                            connectLatch.countDown();\n+                        }\n+                    }});\n+            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n+                LOG.error(\"Couldn't connect to zookeeper at \" + servers);\n+                zk.close();\n+                System.exit(-1);\n+            }\n+\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            LOG.info(\"Waiting for \" + coordinationZnode);\n+            if (zk.exists(coordinationZnode, new Watcher() {\n+                @Override\n+                public void process(WatchedEvent event) {\n+                    if (event.getType() == EventType.NodeCreated) {\n+                        latch.countDown();\n+                    }\n+                }}) != null) {\n+                latch.countDown();\n+            }\n+            latch.await();\n+            LOG.info(\"Coordination znode created\");\n+        }\n+        thread.start();\n+        Thread.sleep(totalTime);\n+        thread.interrupt();\n+        thread.join();\n+\n+        LOG.info(\"Calculating percentiles\");\n+        ArrayList<Long> latency = new ArrayList<Long>();\n+        for(int i = 0; i < bench.latencies.length; i++) {\n+            if (bench.latencies[i] > 0) {\n+                latency.add(bench.latencies[i]);\n+            }\n+        }\n+        double tp = (double)latency.size()*1000.0/(double)bench.getDuration();\n+        LOG.info(latency.size() + \" completions in \" + bench.getDuration() + \" seconds: \" + tp + \" ops/sec\");\n+\n+        if (zk != null) {\n+            zk.create(coordinationZnode + \"/worker-\", \n+                      (\"tp \" + tp + \" duration \" + bench.getDuration()).getBytes(), \n+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n+            zk.close();\n+        }\n+\n+        // dump the latencies for later debugging (it will be sorted by entryid)\n+        OutputStream fos = new BufferedOutputStream(new FileOutputStream(\"latencyDump.dat\"));\n+\n+        for(Long l: latency) {\n+            fos.write((Long.toString(l)+\"\\t\"+(l/1000000)+ \"ms\\n\").getBytes());\n+        }\n+        fos.flush();\n+        fos.close();\n+\n+        // now get the latencies\n+        Collections.sort(latency);\n+        LOG.info(\"99th percentile latency: {}\", percentile(latency, 99));\n+        LOG.info(\"95th percentile latency: {}\", percentile(latency, 95));\n+\n+        bench.close();\n+    }\n+\n+    private static double percentile(ArrayList<Long> latency, int percentile) {\n+        int size = latency.size();\n+        int sampleSize = (size * percentile) / 100;\n+        long total = 0;\n+        int count = 0;\n+        for(int i = 0; i < sampleSize; i++) {\n+            total += latency.get(i);\n+            count++;\n+        }\n+        return ((double)total/(double)count)/1000000.0;\n+    }\n+\n+    private static long warmUp(String servers, byte[] data,\n+                               int ledgers, int ensemble, int qSize, byte[] passwd, int throttle)\n+            throws KeeperException, IOException, InterruptedException, BKException {\n+        final CountDownLatch connectLatch = new CountDownLatch(1);\n+        final int bookies;\n+        ZooKeeper zk = null;\n+        try {\n+            zk = new ZooKeeper(servers, 15000, new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        if (event.getState() == KeeperState.SyncConnected) {\n+                            connectLatch.countDown();\n+                        }\n+                    }});\n+            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n+                LOG.error(\"Couldn't connect to zookeeper at \" + servers);\n+                throw new IOException(\"Couldn't connect to zookeeper \" + servers);\n+            }\n+            bookies = zk.getChildren(\"/ledgers/available\", false).size();\n+        } finally {\n+            if (zk != null) {\n+                zk.close();\n+            }\n+        }\n+\n+        BenchThroughputLatency warmup = new BenchThroughputLatency(bookies, bookies, passwd,\n+                                                                   throttle, ledgers, servers);\n+        int limit = 50000;\n+\n+        warmup.setSendLimit(limit);\n+        warmup.setEntryData(data);\n+        Thread thread = new Thread(warmup);\n+        thread.start();\n+        thread.join();\n+        warmup.close();\n+        return warmup.getThroughput();\n+    }\n+}"},{"sha":"0ded938c78c875b770adf3ca2318063257e9667e","filename":"bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","status":"added","additions":211,"deletions":0,"changes":211,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import org.junit.BeforeClass;\n+import org.junit.AfterClass;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.util.LocalBookKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n+\n+public class TestBenchmark {\n+    protected static final Logger LOG = LoggerFactory.getLogger(TestBenchmark.class);\n+\n+    private static Thread ensembleThread = null;\n+    private final static String zkString = \"localhost:2181\";\n+    private static List<String> bookies = null;\n+\n+    @BeforeClass\n+    public static void startEnsemble() throws Exception {\n+        final int numBookies = 5;\n+\n+        ensembleThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        LocalBookKeeper.main(new String[]{String.valueOf(numBookies)});\n+                    } catch (InterruptedException ie) {\n+                        LOG.info(\"Shutting down ensemble thread\");\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error running bookkeeper ensemble\", e);\n+                    }\n+                }\n+            };\n+        ensembleThread.start();\n+\n+        if (!LocalBookKeeper.waitForServerUp(zkString, 5000)) {\n+            throw new Exception(\"Failed to start zookeeper\");\n+        }\n+        ZooKeeper zk = null;\n+        try {\n+            final CountDownLatch connectLatch = new CountDownLatch(1);\n+\n+            zk = new ZooKeeper(zkString, 15000, new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        if (event.getState() == KeeperState.SyncConnected) {\n+                            connectLatch.countDown();\n+                        }\n+                    }});\n+            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n+                LOG.error(\"Couldn't connect to zookeeper at \" + zkString);\n+            } else {\n+                for (int i = 0; i < 10; i++) {\n+                    try {\n+                        bookies = zk.getChildren(\"/ledgers/available\", false);\n+                        if (zk.getChildren(\"/ledgers/available\", false).size()\n+                            == numBookies) {\n+                            return;\n+                        }\n+                    } catch (Exception e) {\n+                        // do nothing\n+                    }\n+                    Thread.sleep(1000);\n+                }\n+                throw new Exception(\"Not enough bookies started\");\n+            }\n+        } finally {\n+            zk.close();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void stopEnsemble() throws Exception {\n+        if (ensembleThread != null) {\n+            ensembleThread.interrupt();\n+            ensembleThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void testThroughputLatency() throws Exception {\n+        BenchThroughputLatency.main(new String[] {\n+                \"--time\", \"10\"\n+            });\n+    }\n+\n+    @Test\n+    public void testBookie() throws Exception {\n+        String bookie = bookies.get(0);\n+        String[] parts = bookie.split(\":\");\n+        BenchBookie.main(new String[] {\n+                \"--host\", parts[0],\n+                \"--port\", parts[1],\n+                \"--ledger\", \"12345\"\n+                });\n+    }\n+\n+    @Test\n+    public void testReadThroughputLatency() throws Exception {\n+        AtomicBoolean threwException = new AtomicBoolean(false);\n+        Thread t = new Thread() {\n+                public void run() {\n+                    try {\n+                        BenchReadThroughputLatency.main(new String[] {\n+                                \"--listen\", \"10\"});\n+                    } catch (Throwable t) {\n+                        LOG.error(\"Error reading\", t);\n+                    }\n+                }\n+            };\n+        t.start();\n+\n+        Thread.sleep(10000);\n+        byte data[] = new byte[1024];\n+        Arrays.fill(data, (byte)'x');\n+\n+        long lastLedgerId = 0;\n+        Assert.assertTrue(\"Thread should be running\", t.isAlive());\n+        for (int i = 0; i < 10; i++) {\n+            BookKeeper bk = new BookKeeper(zkString);\n+            LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.CRC32, \"benchPasswd\".getBytes());\n+            lastLedgerId = lh.getId();\n+            try {\n+                for (int j = 0; j < 100; j++) {\n+                    lh.addEntry(data);\n+                }\n+            } finally {\n+                lh.close();\n+                bk.close();\n+            }\n+        }\n+        for (int i = 0; i < 60; i++) {\n+            if (!t.isAlive()) {\n+                break;\n+            }\n+            Thread.sleep(1000); // wait for 10 seconds for reading to finish\n+        }\n+\n+        Assert.assertFalse(\"Thread should be finished\", t.isAlive());\n+\n+        BenchReadThroughputLatency.main(new String[] {\n+                \"--ledger\", String.valueOf(lastLedgerId)});\n+\n+        final long nextLedgerId = lastLedgerId+1;\n+        t = new Thread() {\n+                public void run() {\n+                    try {\n+                        BenchReadThroughputLatency.main(new String[] {\n+                                \"--ledger\", String.valueOf(nextLedgerId)});\n+                    } catch (Throwable t) {\n+                        LOG.error(\"Error reading\", t);\n+                    }\n+                }\n+            };\n+        t.start();\n+\n+        Assert.assertTrue(\"Thread should be running\", t.isAlive());\n+        BookKeeper bk = new BookKeeper(zkString);\n+        LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.CRC32, \"benchPasswd\".getBytes());\n+        try {\n+            for (int j = 0; j < 100; j++) {\n+                lh.addEntry(data);\n+            }\n+        } finally {\n+            lh.close();\n+            bk.close();\n+        }\n+        for (int i = 0; i < 60; i++) {\n+            if (!t.isAlive()) {\n+                break;\n+            }\n+            Thread.sleep(1000); // wait for 10 seconds for reading to finish\n+        }\n+        Assert.assertFalse(\"Thread should be finished\", t.isAlive());\n+    }\n+}\n\\ No newline at end of file"},{"sha":"0d88e2b25846130f4aebf18e19a70171a24355b7","filename":"bookkeeper-benchmark/src/test/resources/log4j.properties","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/test/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-benchmark/src/test/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/test/resources/log4j.properties?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -0,0 +1,72 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+#\n+# Bookkeeper Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+log4j.rootLogger=OFF, CONSOLE\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=DEBUG\n+log4j.appender.ROLLINGFILE.File=bookkeeper-benchmark.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"2394bfa0a36ccd249cb6132f272eef974026e681","filename":"bookkeeper-server/bin/bookkeeper","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-server/bin/bookkeeper","raw_url":"https://github.com/apache/bookkeeper/raw/028a6d5360637417141f7f819a404e8e71117f9b/bookkeeper-server/bin/bookkeeper","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/bin/bookkeeper?ref=028a6d5360637417141f7f819a404e8e71117f9b","patch":"@@ -65,6 +65,7 @@ Environment variables:\n    BOOKIE_LOG_CONF        Log4j configuration file\n    BOOKIE_CONF            Configuration file (default: conf/bk_server.conf)\n    BOOKIE_EXTRA_OPTS      Extra options to be passed to the jvm\n+   BOOKIE_EXTRA_CLASSPATH Add extra paths to the bookkeeper classpath\n \n These variable can also be set in conf/bkenv.sh\n EOF\n@@ -109,7 +110,7 @@ if [ \"$BOOKIE_CONF\" == \"\" ]; then\n     BOOKIE_CONF=$DEFAULT_CONF\n fi\n \n-BOOKIE_CLASSPATH=\"$BOOKIE_JAR:$BOOKIE_CLASSPATH\"\n+BOOKIE_CLASSPATH=\"$BOOKIE_JAR:$BOOKIE_CLASSPATH:$BOOKIE_EXTRA_CLASSPATH\"\n if [ \"$BOOKIE_LOG_CONF\" != \"\" ]; then\n     BOOKIE_CLASSPATH=\"`dirname $BOOKIE_LOG_CONF`:$BOOKIE_CLASSPATH\"\n     OPTS=\"$OPTS -Dlog4j.configuration=`basename $BOOKIE_LOG_CONF`\""}]}

