{"sha":"03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","node_id":"MDY6Q29tbWl0MTU3NTk1NjowM2JmMjhkYjRlOGU5OWE0MzI2ZTBlMDFjN2E5ZjcxMzRmMTUxYTdi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-03T13:54:19Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-03T13:54:19Z"},"message":"BOOKKEEPER-459: Rename metastore mock implementation to InMemory implementation (jiannan via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1416519 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6ede40eeea557675f0290918084fe4c13a6baa95","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6ede40eeea557675f0290918084fe4c13a6baa95"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","html_url":"https://github.com/apache/bookkeeper/commit/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"bdf3bfd631493d82688404dde35eed491ec946ad","url":"https://api.github.com/repos/apache/bookkeeper/commits/bdf3bfd631493d82688404dde35eed491ec946ad","html_url":"https://github.com/apache/bookkeeper/commit/bdf3bfd631493d82688404dde35eed491ec946ad"}],"stats":{"total":107,"additions":48,"deletions":59},"files":[{"sha":"afaec4553042c17a9f531ebbaca49266bccb889a","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","patch":"@@ -116,6 +116,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-291: BKMBeanRegistry uses log4j directly (fpj via ivank)\n \n+        BOOKKEEPER-459: Rename metastore mock implementation to InMemory implementation (jiannan via ivank)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"7358504f1abdb62c9e63c132b989fbce53043627","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java","status":"renamed","additions":9,"deletions":13,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java?ref=03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","patch":"@@ -15,23 +15,19 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.bookkeeper.metastore.mock;\n+package org.apache.bookkeeper.metastore;\n \n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.bookkeeper.metastore.MetaStore;\n-import org.apache.bookkeeper.metastore.MetastoreException;\n-import org.apache.bookkeeper.metastore.MetastoreTable;\n-import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n import org.apache.commons.configuration.Configuration;\n \n-public class MockMetaStore implements MetaStore {\n+public class InMemoryMetaStore implements MetaStore {\n \n     static final int CUR_VERSION = 1;\n \n-    static Map<String, MockMetastoreTable> tables =\n-        new HashMap<String, MockMetastoreTable>();\n+    static Map<String, InMemoryMetastoreTable> tables =\n+        new HashMap<String, InMemoryMetastoreTable>();\n \n     // for test\n     public static void reset() {\n@@ -61,18 +57,18 @@ public void close() {\n \n     @Override\n     public MetastoreTable createTable(String name) {\n-        return createMockTable(name);\n+        return createInMemoryTable(name);\n     }\n \n     @Override\n     public MetastoreScannableTable createScannableTable(String name) {\n-        return createMockTable(name);\n+        return createInMemoryTable(name);\n     }\n \n-    private MockMetastoreTable createMockTable(String name) {\n-        MockMetastoreTable t = tables.get(name);\n+    private InMemoryMetastoreTable createInMemoryTable(String name) {\n+        InMemoryMetastoreTable t = tables.get(name);\n         if (t == null) {\n-            t = new MockMetastoreTable(this, name);\n+            t = new InMemoryMetastoreTable(this, name);\n             tables.put(name, t);\n         }\n         return t;","previous_filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetaStore.java"},{"sha":"4e643d5262d0b2f45f6ffaee34f48abda4649efc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java","status":"renamed","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java","raw_url":"https://github.com/apache/bookkeeper/raw/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java?ref=03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","patch":"@@ -15,9 +15,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.bookkeeper.metastore.mock;\n+package org.apache.bookkeeper.metastore;\n \n-import static org.apache.bookkeeper.metastore.mock.MockMetastoreTable.cloneValue;\n+import static org.apache.bookkeeper.metastore.InMemoryMetastoreTable.cloneValue;\n \n import java.io.IOException;\n import java.util.ArrayList;\n@@ -28,20 +28,16 @@\n import java.util.Set;\n import java.util.concurrent.ScheduledExecutorService;\n \n-import org.apache.bookkeeper.metastore.MSException;\n import org.apache.bookkeeper.metastore.MSException.Code;\n-import org.apache.bookkeeper.metastore.MetastoreCursor;\n-import org.apache.bookkeeper.metastore.MetastoreTableItem;\n-import org.apache.bookkeeper.metastore.Value;\n import org.apache.bookkeeper.versioning.Versioned;\n \n-class MockMetastoreCursor implements MetastoreCursor {\n+class InMemoryMetastoreCursor implements MetastoreCursor {\n \n     private final ScheduledExecutorService scheduler;\n     private final Iterator<Map.Entry<String, Versioned<Value>>> iter;\n     private final Set<String> fields;\n \n-    public MockMetastoreCursor(NavigableMap<String, Versioned<Value>> map, Set<String> fields,\n+    public InMemoryMetastoreCursor(NavigableMap<String, Versioned<Value>> map, Set<String> fields,\n             ScheduledExecutorService scheduler) {\n         this.iter = map.entrySet().iterator();\n         this.fields = fields;","previous_filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreCursor.java"},{"sha":"0173f64f64a5906972fe93fb3d9ad9eb85cc3f18","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java","status":"renamed","additions":26,"deletions":30,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java?ref=03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.bookkeeper.metastore.mock;\n+package org.apache.bookkeeper.metastore;\n \n import java.util.NavigableMap;\n import java.util.Set;\n@@ -24,27 +24,23 @@\n import java.util.concurrent.ScheduledExecutorService;\n \n import org.apache.bookkeeper.metastore.MSException.Code;\n-import org.apache.bookkeeper.metastore.MetastoreCallback;\n-import org.apache.bookkeeper.metastore.MetastoreCursor;\n-import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n-import org.apache.bookkeeper.metastore.Value;\n import org.apache.bookkeeper.versioning.Version;\n import org.apache.bookkeeper.versioning.Versioned;\n \n-public class MockMetastoreTable implements MetastoreScannableTable {\n+public class InMemoryMetastoreTable implements MetastoreScannableTable {\n \n-    public static class MockVersion implements Version {\n+    public static class MetadataVersion implements Version {\n         int version;\n \n-        public MockVersion(int v) {\n+        public MetadataVersion(int v) {\n             this.version = v;\n         }\n \n-        public MockVersion(MockVersion v) {\n+        public MetadataVersion(MetadataVersion v) {\n             this.version = v.version;\n         }\n \n-        public synchronized MockVersion incrementVersion() {\n+        public synchronized MetadataVersion incrementVersion() {\n             ++version;\n             return this;\n         }\n@@ -58,10 +54,10 @@ public Occurred compare(Version v) {\n                 return Occurred.AFTER;\n             } else if (v == Version.ANY) {\n                 return Occurred.CONCURRENTLY;\n-            } else if (!(v instanceof MockVersion)) {\n+            } else if (!(v instanceof MetadataVersion)) {\n                 throw new IllegalArgumentException(\"Invalid version type\");\n             }\n-            MockVersion mv = (MockVersion)v;\n+            MetadataVersion mv = (MetadataVersion)v;\n             int res = version - mv.version;\n             if (res == 0) {\n                 return Occurred.CONCURRENTLY;\n@@ -75,10 +71,10 @@ public Occurred compare(Version v) {\n         @Override\n         public boolean equals(Object obj) {\n             if (null == obj ||\n-                !(obj instanceof MockVersion)) {\n+                !(obj instanceof MetadataVersion)) {\n                 return false;\n             }\n-            MockVersion v = (MockVersion)obj;\n+            MetadataVersion v = (MetadataVersion)obj;\n             return 0 == (version - v.version);\n         }\n \n@@ -97,7 +93,7 @@ public int hashCode() {\n     private TreeMap<String, Versioned<Value>> map = null;\n     private ScheduledExecutorService scheduler;\n \n-    public MockMetastoreTable(MockMetaStore metastore, String name) {\n+    public InMemoryMetastoreTable(InMemoryMetaStore metastore, String name) {\n         this.map = new TreeMap<String, Versioned<Value>>();\n         this.name = name;\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n@@ -124,8 +120,8 @@ public String getName () {\n             throw new NullPointerException(\"Version isn't allowed to be null.\");\n         }\n         if (Version.ANY != version && Version.NEW != version) {\n-            if (version instanceof MockVersion) {\n-                version = new MockVersion(((MockVersion)version).version);\n+            if (version instanceof MetadataVersion) {\n+                version = new MetadataVersion(((MetadataVersion)version).version);\n             } else {\n                 throw new IllegalStateException(\"Wrong version type.\");\n             }\n@@ -160,7 +156,7 @@ public synchronized void scheduleGet(String key, Set<String> fields, MetastoreCa\n             cb.complete(Code.IllegalOp.getCode(), null, ctx);\n             return;\n         }\n-        Versioned<Value> vv = mockGet(key);\n+        Versioned<Value> vv = get(key);\n         int rc = null == vv ? Code.NoKey.getCode() : Code.OK.getCode();\n         if (vv != null) {\n             vv = cloneValue(vv.getValue(), vv.getVersion(), fields);\n@@ -178,7 +174,7 @@ public void run() {\n                     cb.complete(Code.IllegalOp.getCode(), null, ctx);\n                     return;\n                 }\n-                Result<Version> result = mockPut(key, value, version);\n+                Result<Version> result = put(key, value, version);\n                 cb.complete(result.code.getCode(), result.value, ctx);\n             }\n         });\n@@ -193,7 +189,7 @@ public void run() {\n                     cb.complete(Code.IllegalOp.getCode(), null, ctx);\n                     return;\n                 }\n-                Code code = mockRemove(key, version);\n+                Code code = remove(key, version);\n                 cb.complete(code.getCode(), null, ctx);\n             }\n         });\n@@ -229,18 +225,18 @@ public void openCursor(final String firstKey, final boolean firstInclusive,\n         scheduler.submit(new Runnable() {\n             @Override\n             public void run() {\n-                Result<MetastoreCursor> result = mockOpenCursor(firstKey, firstInclusive, lastKey, lastInclusive,\n+                Result<MetastoreCursor> result = openCursor(firstKey, firstInclusive, lastKey, lastInclusive,\n                         order, fields);\n                 cb.complete(result.code.getCode(), result.value, ctx);\n             }\n         });\n     }\n \n-    private synchronized Versioned<Value> mockGet(String key) {\n+    private synchronized Versioned<Value> get(String key) {\n         return map.get(key);\n     }\n \n-    private synchronized Code mockRemove(String key, Version version) {\n+    private synchronized Code remove(String key, Version version) {\n         Versioned<Value> vv = map.get(key);\n         if (null == vv) {\n             return Code.NoKey;\n@@ -262,29 +258,29 @@ public Result(Code code, T value) {\n         }\n     }\n \n-    private synchronized Result<Version> mockPut(String key, Value value, Version version) {\n+    private synchronized Result<Version> put(String key, Value value, Version version) {\n         Versioned<Value> vv = map.get(key);\n         if (vv == null) {\n             if (Version.NEW != version) {\n                 return new Result<Version>(Code.NoKey, null);\n             }\n             vv = cloneValue(value, version, ALL_FIELDS);\n-            vv.setVersion(new MockVersion(0));\n+            vv.setVersion(new MetadataVersion(0));\n             map.put(key, vv);\n-            return new Result<Version>(Code.OK, new MockVersion(0));\n+            return new Result<Version>(Code.OK, new MetadataVersion(0));\n         }\n         if (Version.NEW == version) {\n             return new Result<Version>(Code.KeyExists, null);\n         }\n         if (Version.Occurred.CONCURRENTLY != vv.getVersion().compare(version)) {\n             return new Result<Version>(Code.BadVersion, null);\n         }\n-        vv.setVersion(((MockVersion)vv.getVersion()).incrementVersion());\n+        vv.setVersion(((MetadataVersion)vv.getVersion()).incrementVersion());\n         vv.setValue(vv.getValue().merge(value));\n-        return new Result<Version>(Code.OK, new MockVersion((MockVersion)vv.getVersion()));\n+        return new Result<Version>(Code.OK, new MetadataVersion((MetadataVersion)vv.getVersion()));\n     }\n \n-    private synchronized Result<MetastoreCursor> mockOpenCursor(\n+    private synchronized Result<MetastoreCursor> openCursor(\n             String firstKey, boolean firstInclusive,\n             String lastKey, boolean lastInclusive,\n             Order order, Set<String> fields) {\n@@ -329,7 +325,7 @@ public Result(Code code, T value) {\n         if (!isLegalCursor || null == myMap) {\n             return new Result<MetastoreCursor>(Code.IllegalOp, null);\n         }\n-        MetastoreCursor cursor = new MockMetastoreCursor(\n+        MetastoreCursor cursor = new InMemoryMetastoreCursor(\n                 myMap.subMap(firstKey, firstInclusive, lastKey, lastInclusive), fields, scheduler);\n         return new Result<MetastoreCursor>(Code.OK, cursor);\n     }","previous_filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreTable.java"},{"sha":"35151df8218728919fc79b476bbc8b0622485399","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/03bf28db4e8e99a4326e0e01c7a9f7134f151a7b/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java?ref=03bf28db4e8e99a4326e0e01c7a9f7134f151a7b","patch":"@@ -31,10 +31,9 @@\n \n import junit.framework.TestCase;\n \n+import org.apache.bookkeeper.metastore.InMemoryMetastoreTable.MetadataVersion;\n import org.apache.bookkeeper.metastore.MSException.Code;\n import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n-import org.apache.bookkeeper.metastore.mock.MockMetaStore;\n-import org.apache.bookkeeper.metastore.mock.MockMetastoreTable.MockVersion;\n import org.apache.bookkeeper.versioning.Version;\n import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.commons.configuration.CompositeConfiguration;\n@@ -156,32 +155,32 @@ public void checkEqual(Versioned<Value> vv) {\n     protected MetastoreScannableTableAsyncToSyncConverter myTable;\n \n     protected String getMetaStoreName() {\n-        return MockMetaStore.class.getName();\n+        return InMemoryMetaStore.class.getName();\n     }\n \n     protected Configuration getConfiguration() {\n         return new CompositeConfiguration();\n     }\n \n     protected Version newBadVersion() {\n-        return new MockVersion(-1);\n+        return new MetadataVersion(-1);\n     }\n \n     protected Version nextVersion(Version version) {\n         if (Version.NEW == version) {\n-            return new MockVersion(0);\n+            return new MetadataVersion(0);\n         }\n         if (Version.ANY == version) {\n             return Version.ANY;\n         }\n-        assertTrue(version instanceof MockVersion);\n-        return new MockVersion(((MockVersion) version).incrementVersion());\n+        assertTrue(version instanceof MetadataVersion);\n+        return new MetadataVersion(((MetadataVersion) version).incrementVersion());\n     }\n \n     private void checkVersion(Version v) {\n         assertNotNull(v);\n         if (v != Version.NEW && v != Version.ANY) {\n-            assertTrue(v instanceof MockVersion);\n+            assertTrue(v instanceof MetadataVersion);\n         }\n     }\n "}]}

