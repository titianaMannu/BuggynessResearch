{"sha":"0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","node_id":"MDY6Q29tbWl0MTU3NTk1NjowOTEwZDZjZDdmZmIxYTdiNzhhYjkxYTMyNzcxNWU5MzZhM2ViOWU1","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2011-08-11T18:36:52Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2011-08-11T18:36:52Z"},"message":"BOOKKEEPER-33: Add length and offset parameter to addEntry (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1156723 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4bb3371e8d971a3b2ed3ef6436d838f4b0fc20a4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4bb3371e8d971a3b2ed3ef6436d838f4b0fc20a4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","html_url":"https://github.com/apache/bookkeeper/commit/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"de1c3b26a1162fb545c91d9cef4eed435c662a66","url":"https://api.github.com/repos/apache/bookkeeper/commits/de1c3b26a1162fb545c91d9cef4eed435c662a66","html_url":"https://github.com/apache/bookkeeper/commit/de1c3b26a1162fb545c91d9cef4eed435c662a66"}],"stats":{"total":289,"additions":233,"deletions":56},"files":[{"sha":"95f9020a8afa6e54dc8bc20940d6e4118d41b53d","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","patch":"@@ -26,3 +26,5 @@ BUGFIXES:\n   \n   BOOKKEEPER-29: BookieRecoveryTest fails intermittently (fpj via ivank)\n \n+  BOOKKEEPER-33: Add length and offset parameter to addEntry (ivank via fpj)\n+"},{"sha":"750b113a32074280f8c46cda760f83f0d34909ee","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","patch":"@@ -79,7 +79,7 @@ static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digest\n      * @return\n      */\n     \n-    public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data) {\n+    public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data, int doffset, int dlength) {\n \n         byte[] bufferArray = new byte[METADATA_LENGTH + macCodeLength];\n         ByteBuffer buffer = ByteBuffer.wrap(bufferArray);\n@@ -90,15 +90,15 @@ public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAd\n         buffer.flip();\n \n         update(buffer.array(), 0, METADATA_LENGTH);\n-        update(data);\n+        update(data, doffset, dlength);\n         byte[] digest = getValueAndReset();\n \n         buffer.limit(buffer.capacity());\n         buffer.position(METADATA_LENGTH);\n         buffer.put(digest);\n         buffer.flip();\n \n-        return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer), ChannelBuffers.wrappedBuffer(data));\n+        return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer), ChannelBuffers.wrappedBuffer(data, doffset, dlength));\n     }\n \n     private void verifyDigest(ChannelBuffer dataReceived) throws BKDigestMatchException {"},{"sha":"7b30d136e0d5c177adab8cb037a41245245c4054","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":92,"deletions":51,"changes":143,"blob_url":"https://github.com/apache/bookkeeper/blob/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","patch":"@@ -319,23 +319,37 @@ public void asyncReadEntries(long firstEntry, long lastEntry,\n     }\n   }\n \n-  /**\n-   * Add entry synchronously to an open ledger.\n-   * \n-   * @param data\n-   *         array of bytes to be written to the ledger\n-   */\n-\n-  public long addEntry(byte[] data) throws InterruptedException, BKException {\n-    LOG.debug(\"Adding entry \" + data);\n-    SyncCounter counter = new SyncCounter();\n-    counter.inc();\n-\n-    asyncAddEntry(data, this, counter);\n-    counter.block(0);\n+    /**\n+     * Add entry synchronously to an open ledger.\n+     * \n+     * @param data\n+     *         array of bytes to be written to the ledger\n+     */\n+    public long addEntry(byte[] data) throws InterruptedException, BKException {\n+        return addEntry(data, 0, data.length);\n+    }\n \n-    return counter.getrc();\n-  }\n+    /**\n+     * Add entry synchronously to an open ledger.\n+     * \n+     * @param data\n+     *         array of bytes to be written to the ledger\n+     * @param offset\n+     *          offset from which to take bytes from data\n+     * @param length\n+     *          number of bytes to take from data\n+     */\n+    public long addEntry(byte[] data, int offset, int length) \n+            throws InterruptedException, BKException {\n+        LOG.debug(\"Adding entry \" + data);\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+        \n+        asyncAddEntry(data, offset, length, this, counter);\n+        counter.block(0);\n+\n+        return counter.getrc();\n+    }\n \n   /**\n    * Add entry asynchronously to an open ledger.\n@@ -347,41 +361,68 @@ public long addEntry(byte[] data) throws InterruptedException, BKException {\n    * @param ctx\n    *          some control object\n    */\n-  public void asyncAddEntry(final byte[] data, final AddCallback cb,\n-      final Object ctx) {\n-      try{\n-          opCounterSem.acquire();\n-      } catch (InterruptedException e) {\n-          cb.addComplete(BKException.Code.InterruptedException,\n-                  LedgerHandle.this, -1, ctx);\n-      }\n-      \n-      try{\n-          bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-              @Override\n-              public void safeRun() {\n-                  if (metadata.isClosed()) {\n-                      LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                      LedgerHandle.this.opCounterSem.release();\n-                      cb.addComplete(BKException.Code.LedgerClosedException,\n-                              LedgerHandle.this, -1, ctx);\n-                      return;\n-                  }\n-\n-                  long entryId = ++lastAddPushed;\n-                  long currentLength = addToLength(data.length);\n-                  PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);\n-                  pendingAddOps.add(op);\n-                  ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n-                          entryId, lastAddConfirmed, currentLength, data);\n-                  op.initiate(toSend);\n-              }\n-          });\n-      } catch (RuntimeException e) {\n-          opCounterSem.release();\n-          throw e;\n-      }\n-  }\n+    public void asyncAddEntry(final byte[] data, final AddCallback cb, \n+                              final Object ctx) {\n+        asyncAddEntry(data, 0, data.length, cb, ctx);\n+    }\n+\n+    /**\n+     * Add entry asynchronously to an open ledger, using an offset and range.\n+     * \n+     * @param data\n+     *          array of bytes to be written\n+     * @param offset\n+     *          offset from which to take bytes from data\n+     * @param length\n+     *          number of bytes to take from data\n+     * @param cb\n+     *          object implementing callbackinterface\n+     * @param ctx\n+     *          some control object\n+     * @throws ArrayIndexOutOfBoundsException if offset or length is negative or \n+     *          offset and length sum to a value higher than the length of data.\n+     */\n+    public void asyncAddEntry(final byte[] data, final int offset, final int length, \n+                              final AddCallback cb, final Object ctx) {\n+        if (offset < 0 || length < 0\n+            || (offset + length) > data.length) {\n+            throw new ArrayIndexOutOfBoundsException(\n+                    \"Invalid values for offset(\"+offset\n+                    +\") or length(\"+length+\")\");\n+        }\n+        try{\n+            opCounterSem.acquire();\n+        } catch (InterruptedException e) {\n+            cb.addComplete(BKException.Code.InterruptedException,\n+                    LedgerHandle.this, -1, ctx);\n+        }\n+        \n+        try{\n+            bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        if (metadata.isClosed()) {\n+                            LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n+                            LedgerHandle.this.opCounterSem.release();\n+                            cb.addComplete(BKException.Code.LedgerClosedException,\n+                                           LedgerHandle.this, -1, ctx);\n+                            return;\n+                        }\n+                        \n+                        long entryId = ++lastAddPushed;\n+                        long currentLength = addToLength(length);\n+                        PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);\n+                        pendingAddOps.add(op);\n+                        ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n+                                entryId, lastAddConfirmed, currentLength, data, offset, length);\n+                        op.initiate(toSend);\n+                    }\n+                });\n+        } catch (RuntimeException e) {\n+            opCounterSem.release();\n+            throw e;\n+        }\n+    }\n \n   /**\n    * Obtains last confirmed write from a quorum of bookies."},{"sha":"0e9f86299a07faed00eff46fc8d120bb0e080c44","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","patch":"@@ -687,8 +687,9 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n                  * bookie we've selected.\n                  */\n                 LedgerEntry entry = seq.nextElement();\n+                byte[] data = entry.getEntry();\n                 ChannelBuffer toSend = lh.getDigestManager().computeDigestAndPackageForSending(entryId,\n-                        lh.getLastAddConfirmed(), entry.getLength(), entry.getEntry());\n+                        lh.getLastAddConfirmed(), entry.getLength(), data, 0, data.length);\n                 bkc.getBookieClient().addEntry(newBookie, lh.getId(), lh.getLedgerKey(), entryId, toSend,\n                         new WriteCallback() {\n                             @Override"},{"sha":"36cc2bd83bc37e8f37906ab50223717dac8e607e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","patch":"@@ -32,6 +32,7 @@\n import java.util.Enumeration;\n import java.util.Random;\n import java.util.Set;\n+import java.util.Arrays;\n import java.util.concurrent.Semaphore;\n \n \n@@ -246,6 +247,137 @@ public void testReadWriteAsyncSingleClient() throws IOException {\n         }\n     }\n \n+    /**\n+     * Check that the add api with offset and length work correctly.\n+     * First try varying the offset. Then the length with a fixed non-zero\n+     * offset.\n+     */\n+    @Test\n+    public void testReadWriteRangeAsyncSingleClient() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            byte bytes[] = {'a','b','c','d','e','f','g','h','i'};\n+            \n+            lh.asyncAddEntry(bytes, 0, bytes.length, this, sync);\n+            lh.asyncAddEntry(bytes, 0, 4, this, sync); // abcd\n+            lh.asyncAddEntry(bytes, 3, 4, this, sync); // defg\n+            lh.asyncAddEntry(bytes, 3, (bytes.length-3), this, sync); // defghi\n+            int numEntries = 4;\n+\n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntries) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            try {\n+                lh.asyncAddEntry(bytes, -1, bytes.length, this, sync); \n+                fail(\"Shouldn't be able to use negative offset\");\n+            } catch (ArrayIndexOutOfBoundsException aiob) {\n+                // expected\n+            }\n+            try {\n+                lh.asyncAddEntry(bytes, 0, bytes.length+1, this, sync); \n+                fail(\"Shouldn't be able to use that much length\");\n+            } catch (ArrayIndexOutOfBoundsException aiob) {\n+                // expected\n+            }\n+            try {\n+                lh.asyncAddEntry(bytes, -1, bytes.length+2, this, sync); \n+                fail(\"Shouldn't be able to use negative offset \"\n+                     + \"with that much length\");\n+            } catch (ArrayIndexOutOfBoundsException aiob) {\n+                // expected\n+            }\n+            try {\n+                lh.asyncAddEntry(bytes, 4, -3, this, sync); \n+                fail(\"Shouldn't be able to use negative length\");\n+            } catch (ArrayIndexOutOfBoundsException aiob) {\n+                // expected\n+            }\n+            try {\n+                lh.asyncAddEntry(bytes, -4, -3, this, sync); \n+                fail(\"Shouldn't be able to use negative offset & length\");\n+            } catch (ArrayIndexOutOfBoundsException aiob) {\n+                // expected\n+            }\n+            \n+\n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+\n+            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n+\n+            // open ledger\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n+            assertTrue(\"Verifying number of entries written\", \n+                       lh.getLastAddConfirmed() == (numEntries - 1));\n+\n+            // read entries\n+            lh.asyncReadEntries(0, numEntries - 1, this, (Object) sync);\n+\n+            synchronized (sync) {\n+                while (sync.value == false) {\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** READ COMPLETE ***\");\n+\n+            // at this point, Enumeration<LedgerEntry> ls is filled with the returned\n+            // values\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                byte[] expected = null;\n+                byte[] entry = ls.nextElement().getEntry();\n+                \n+                switch (i) {\n+                case 0: \n+                    expected = Arrays.copyOfRange(bytes, 0, bytes.length);\n+                    break;\n+                case 1: \n+                    expected = Arrays.copyOfRange(bytes, 0, 4);\n+                    break;\n+                case 2: \n+                    expected = Arrays.copyOfRange(bytes, 3, 3+4);\n+                    break;\n+                case 3: \n+                    expected = Arrays.copyOfRange(bytes, 3, 3+(bytes.length-3));\n+                    break;\n+                }\n+                assertNotNull(\"There are more checks than writes\", expected);\n+                \n+                String message = \"Checking entry \" + i + \" for equality [\"\n+                    + new String(entry, \"UTF-8\") + \",\" \n+                    + new String(expected, \"UTF-8\") + \"]\";\n+                assertTrue(message, Arrays.equals(entry, expected));\n+\n+                i++;\n+            }\n+            assertTrue(\"Checking number of read entries\", i == numEntries);\n+\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n     class ThrottleTestCallback implements ReadCallback {\n         int throttle;\n         "},{"sha":"a8ef703c35f3bc9323c51adc3ac9908b95144c2c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java?ref=0910d6cd7ffb1a7b78ab91a327715e936a3eb9e5","patch":"@@ -119,7 +119,8 @@ public void testAddEntryException()\n             byte[] masterKey = \"blah\".getBytes();\n             for( int i = 0; i < 30000; i++){\n                 MacDigestManager dm = new MacDigestManager(i, masterKey);\n-                ByteBuffer entry = dm.computeDigestAndPackageForSending(0, 0, 10, \"0123456789\".getBytes()).toByteBuffer();\n+                byte[] data = \"0123456789\".getBytes();\n+                ByteBuffer entry = dm.computeDigestAndPackageForSending(0, 0, 10, data, 0, data.length).toByteBuffer();\n                 bookie.addEntry(entry, new TestWriteCallback(), null, masterKey);\n             }\n         } catch (IOException e) {"}]}

