{"sha":"0ea460606e4a45a07a79c356ad1d58a6119e0d31","node_id":"MDY6Q29tbWl0MTU3NTk1NjowZWE0NjA2MDZlNGE0NWEwN2E3OWMzNTZhZDFkNThhNjExOWUwZDMx","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-03T15:27:32Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-03T15:27:32Z"},"message":"BOOKKEEPER-442: Failed to deliver messages due to inconsistency between SubscriptionState and LedgerRanges. (jiannan via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1416560 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"618480046e8ddc862c889030b0e8c91ed39e763c","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/618480046e8ddc862c889030b0e8c91ed39e763c"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0ea460606e4a45a07a79c356ad1d58a6119e0d31","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0ea460606e4a45a07a79c356ad1d58a6119e0d31","html_url":"https://github.com/apache/bookkeeper/commit/0ea460606e4a45a07a79c356ad1d58a6119e0d31","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0ea460606e4a45a07a79c356ad1d58a6119e0d31/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"4380e52969beac534fd1da6a68bd28d48b9ba7e9","url":"https://api.github.com/repos/apache/bookkeeper/commits/4380e52969beac534fd1da6a68bd28d48b9ba7e9","html_url":"https://github.com/apache/bookkeeper/commit/4380e52969beac534fd1da6a68bd28d48b9ba7e9"}],"stats":{"total":241,"additions":224,"deletions":17},"files":[{"sha":"b40c9a278e4cacdc59e97fcaff5dc8b76f13ce6e","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/0ea460606e4a45a07a79c356ad1d58a6119e0d31/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/0ea460606e4a45a07a79c356ad1d58a6119e0d31/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=0ea460606e4a45a07a79c356ad1d58a6119e0d31","patch":"@@ -160,6 +160,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-482: Precommit is reporting findbugs errors in trunk (ivank via sijie)\n \n+        BOOKKEEPER-442: Failed to deliver messages due to inconsistency between SubscriptionState and LedgerRanges. (jiannan via ivank)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-467: Allocate ports for testing dynamically (ivank)"},{"sha":"e700f549e7a564c2b9789886fd946763a4c688ee","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=0ea460606e4a45a07a79c356ad1d58a6119e0d31","patch":"@@ -231,6 +231,19 @@ protected void runInternal() {\n         }\n \n         protected void read(final InMemoryLedgerRange imlr, final long startSeqId, final long endSeqId) {\n+            // Verify whether startSeqId falls in ledger range.\n+            // Only the left endpoint of range needs to be checked.\n+            if (imlr.getStartSeqIdIncluded() > startSeqId) {\n+                logger.error(\n+                        \"Invalid RangeScan read, startSeqId {} doesn't fall in ledger range [{} ~ {}]\",\n+                        va(startSeqId, imlr.getStartSeqIdIncluded(), imlr.range.hasEndSeqIdIncluded() ? imlr.range\n+                                .getEndSeqIdIncluded().getLocalComponent() : \"\"));\n+                request.callback.scanFailed(request.ctx, new PubSubException.UnexpectedConditionException(\"Scan request is out of range\"));\n+\n+                // try release topic to reset the state\n+                lostTopic(topic);\n+                return;\n+            }\n \n             if (imlr.handle == null) {\n "},{"sha":"f199fbdf9217428a27af307f8d2341bf9e2947ce","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":25,"deletions":14,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=0ea460606e4a45a07a79c356ad1d58a6119e0d31","patch":"@@ -129,24 +129,24 @@ public void run() {\n \n                 long minConsumedMessage = Long.MAX_VALUE;\n                 boolean hasBound = true;\n-                // Loop through all subscribers to the current topic to find the\n-                // minimum consumed message id. The consume pointers are\n-                // persisted lazily so we'll use the stale in-memory value\n-                // instead. This keeps things consistent in case of a server\n-                // crash.\n+                // Loop through all subscribers on the current topic to find the\n+                // minimum persisted message id. The reason not using in-memory\n+                // consumed message id is LedgerRangs and InMemorySubscriptionState\n+                // may be inconsistent in case of a server crash.\n                 for (InMemorySubscriptionState curSubscription : topicSubscriptions.values()) {\n-                    if (curSubscription.getSubscriptionState().getMsgId().getLocalComponent() < minConsumedMessage)\n-                        minConsumedMessage = curSubscription.getSubscriptionState().getMsgId().getLocalComponent();\n+                    if (curSubscription.getLastPersistedSeqId() < minConsumedMessage) {\n+                        minConsumedMessage = curSubscription.getLastPersistedSeqId();\n+                    }\n                     hasBound = hasBound && curSubscription.getSubscriptionPreferences().hasMessageBound();\n                 }\n                 boolean callPersistenceManager = true;\n-                // Don't call the PersistenceManager if nobody is subscribed to\n-                // the topic yet, or the consume pointer has not changed since\n-                // the last time, or if this is the initial subscription.\n+                // Call the PersistenceManager if nobody subscribes to the topic\n+                // yet, or the consume pointer has moved ahead since the last\n+                // time, or if this is the initial subscription.\n                 Long minConsumedFromMap = topic2MinConsumedMessagesMap.get(topic);\n                 if (topicSubscriptions.isEmpty()\n-                    || (minConsumedFromMap != null && minConsumedFromMap.equals(minConsumedMessage))\n-                    || minConsumedMessage == 0) {\n+                    || (minConsumedFromMap != null && minConsumedFromMap < minConsumedMessage)\n+                    || (minConsumedFromMap == null && minConsumedMessage != 0)) {\n                     topic2MinConsumedMessagesMap.put(topic, minConsumedMessage);\n                     pm.consumedUntil(topic, minConsumedMessage);\n                 } else if (hasBound) {\n@@ -547,14 +547,25 @@ public void run() {\n                 return;\n             }\n \n-            InMemorySubscriptionState subState = topicSubs.get(subscriberId);\n+            final InMemorySubscriptionState subState = topicSubs.get(subscriberId);\n             if (subState == null) {\n                 cb.operationFinished(ctx, null);\n                 return;\n             }\n \n             if (subState.setLastConsumeSeqId(consumeSeqId, cfg.getConsumeInterval())) {\n-                updateSubscriptionState(topic, subscriberId, subState, cb, ctx);\n+                updateSubscriptionState(topic, subscriberId, subState, new Callback<Void>() {\n+                    @Override\n+                    public void operationFinished(Object ctx, Void resultOfOperation) {\n+                        subState.setLastPersistedSeqId(consumeSeqId.getLocalComponent());\n+                        cb.operationFinished(ctx, resultOfOperation);\n+                    }\n+\n+                    @Override\n+                    public void operationFailed(Object ctx, PubSubException exception) {\n+                        cb.operationFailed(ctx, exception);\n+                    }\n+                }, ctx);\n             } else {\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Only advanced consume pointer in memory, will persist later, topic: \""},{"sha":"05c4a03029a034aecb801b6f6c0c827cd03c7c5f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=0ea460606e4a45a07a79c356ad1d58a6119e0d31","patch":"@@ -34,7 +34,8 @@\n     SubscriptionState subscriptionState;\n     SubscriptionPreferences subscriptionPreferences;\n     MessageSeqId lastConsumeSeqId;\n-\tVersion version;\n+    Version version;\n+    long lastPersistedSeqId;\n \n     public InMemorySubscriptionState(SubscriptionData subscriptionData, Version version, MessageSeqId lastConsumeSeqId) {\n         this.subscriptionState = subscriptionData.getState();\n@@ -50,6 +51,7 @@ public InMemorySubscriptionState(SubscriptionData subscriptionData, Version vers\n         }\n         this.lastConsumeSeqId = lastConsumeSeqId;\n         this.version = version;\n+        this.lastPersistedSeqId = subscriptionState.getMsgId().getLocalComponent();\n     }\n \n     public InMemorySubscriptionState(SubscriptionData subscriptionData, Version version) {\n@@ -125,6 +127,14 @@ public boolean setLastConsumeSeqIdImmediately() {\n         return true;\n     }\n \n+    public long getLastPersistedSeqId() {\n+        return lastPersistedSeqId;\n+    }\n+\n+    public void setLastPersistedSeqId(long lastPersistedSeqId) {\n+        this.lastPersistedSeqId = lastPersistedSeqId;\n+    }\n+\n     /**\n      * Update preferences.\n      *"},{"sha":"1cb28aa550e938b4ea5afa03b0383120fe5f176a","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","status":"modified","additions":173,"deletions":2,"changes":175,"blob_url":"https://github.com/apache/bookkeeper/blob/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/0ea460606e4a45a07a79c356ad1d58a6119e0d31/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java?ref=0ea460606e4a45a07a79c356ad1d58a6119e0d31","patch":"@@ -24,6 +24,7 @@\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Iterator;\n+import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n@@ -36,19 +37,27 @@\n import org.apache.bookkeeper.versioning.Versioned;\n \n import org.apache.hedwig.HelperMethods;\n+import org.apache.hedwig.StubCallback;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol;\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.meta.SubscriptionDataManager;\n import org.apache.hedwig.server.meta.TopicOwnershipManager;\n import org.apache.hedwig.server.meta.TopicPersistenceManager;\n+import org.apache.hedwig.server.subscriptions.MMSubscriptionManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.ConcurrencyUtils;\n+import org.apache.hedwig.util.Either;\n import org.apache.zookeeper.ZooKeeper;\n import org.junit.After;\n import org.junit.Before;\n@@ -77,6 +86,7 @@\n     PubSubException failureException = null;\n     TestMetadataManagerFactory metadataManagerFactory;\n     TopicPersistenceManager tpManager;\n+    MMSubscriptionManager sm;\n \n     boolean removeStartSeqId;\n \n@@ -160,7 +170,66 @@ public void deleteTopicPersistenceInfo(ByteString topic, Version version,\n \n         @Override\n         public SubscriptionDataManager newSubscriptionDataManager() {\n-            return factory.newSubscriptionDataManager();\n+            final SubscriptionDataManager sdm = factory.newSubscriptionDataManager();\n+            return new SubscriptionDataManager() {\n+                @Override\n+                public void close() throws IOException {\n+                    sdm.close();\n+                }\n+\n+                @Override\n+                public void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n+                        Callback<Version> callback, Object ctx) {\n+                    sdm.createSubscriptionData(topic, subscriberId, data, callback, ctx);\n+                }\n+\n+                @Override\n+                public boolean isPartialUpdateSupported() {\n+                    return sdm.isPartialUpdateSupported();\n+                }\n+\n+                @Override\n+                public void updateSubscriptionData(ByteString topic, ByteString subscriberId,\n+                        SubscriptionData dataToUpdate, Version version, Callback<Version> callback, Object ctx) {\n+                    if (serviceDownCount > 0) {\n+                        --serviceDownCount;\n+                        callback.operationFailed(ctx,\n+                                new PubSubException.ServiceDownException(\"Metadata Store is down\"));\n+                        return;\n+                    }\n+                    sdm.updateSubscriptionData(topic, subscriberId, dataToUpdate, version, callback, ctx);\n+                }\n+\n+                @Override\n+                public void replaceSubscriptionData(ByteString topic, ByteString subscriberId,\n+                        SubscriptionData dataToReplace, Version version, Callback<Version> callback, Object ctx) {\n+                    if (serviceDownCount > 0) {\n+                        --serviceDownCount;\n+                        callback.operationFailed(ctx,\n+                                new PubSubException.ServiceDownException(\"Metadata Store is down\"));\n+                        return;\n+                    }\n+                    sdm.replaceSubscriptionData(topic, subscriberId, dataToReplace, version, callback, ctx);\n+                }\n+\n+                @Override\n+                public void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Version version,\n+                        Callback<Void> callback, Object ctx) {\n+                    sdm.deleteSubscriptionData(topic, subscriberId, version, callback, ctx);\n+                }\n+\n+                @Override\n+                public void readSubscriptionData(ByteString topic, ByteString subscriberId,\n+                        Callback<Versioned<SubscriptionData>> callback, Object ctx) {\n+                    sdm.readSubscriptionData(topic, subscriberId, callback, ctx);\n+                }\n+\n+                @Override\n+                public void readSubscriptions(ByteString topic,\n+                        Callback<Map<ByteString, Versioned<SubscriptionData>>> cb, Object ctx) {\n+                    sdm.readSubscriptions(topic, cb, ctx);\n+                }\n+            };\n         }\n \n         @Override\n@@ -194,7 +263,16 @@ public void setUp() throws Exception {\n         bktb = new BookKeeperTestBase(numBookies, readDelay);\n         bktb.setUp();\n \n-        conf = new ServerConfiguration();\n+        conf = new ServerConfiguration() {\n+            @Override\n+            public int getMessagesConsumedThreadRunInterval() {\n+                return 2000;\n+            }\n+            @Override\n+            public int getConsumeInterval() {\n+                return 0;\n+            }\n+        };\n         org.apache.bookkeeper.conf.ClientConfiguration bkClientConf =\n                 new org.apache.bookkeeper.conf.ClientConfiguration();\n         bkClientConf.setNumWorkerThreads(1).setReadTimeout(9999)\n@@ -208,13 +286,15 @@ public void setUp() throws Exception {\n         tm = new TrivialOwnAllTopicManager(conf, scheduler);\n         manager = new BookkeeperPersistenceManager(bktb.bk, metadataManagerFactory,\n                                                    tm, conf, scheduler);\n+        sm = new MMSubscriptionManager(conf, metadataManagerFactory, tm, manager, null, scheduler);\n     }\n \n     @Override\n     @After\n     public void tearDown() throws Exception {\n         tm.stop();\n         manager.stop();\n+        sm.stop();\n         tpManager.close();\n         metadataManagerFactory.shutdown();\n         scheduler.shutdown();\n@@ -464,6 +544,97 @@ public void testScanMessagesOnTwoLedgers() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testInconsistentSubscriptionStateAndLedgerRanges1() throws Exception {\n+        // See the comment of inconsistentSubscriptionStateAndLedgerRanges.\n+        // For this case, Step (2) failed to update subscription state metadata,\n+        // but LedgerRanges is updated success.\n+        // Result: scan messages from 1 to 4 take place on ledger L2.\n+        inconsistentSubscriptionStateAndLedgerRanges(1);\n+    }\n+\n+    @Test\n+    public void testInconsistentSubscriptionStateAndLedgerRanges2() throws Exception {\n+        // See the comment of inconsistentSubscriptionStateAndLedgerRanges.\n+        // For this case, step (2) failed to update subscription state metadata,\n+        // step (3) successfully delete L1 but failed to update LedgerRanges.\n+        // Result: scan messages from 1 to 4 falls in L1 and L2,\n+        //         but BookKeeper may complain L1 not found.\n+        inconsistentSubscriptionStateAndLedgerRanges(2);\n+    }\n+\n+    /**\n+     * Since InMemorySubscriptionState and LedgerRanges is maintained\n+     * separately, there may exist such inconsistent state:\n+     * (1). Topic ledgers: L1 [1 ~ 2], L2 [3 ~ ]\n+     * (2). Subscriber consumes to 2 and InMemorySubscriptionState is updated\n+     *      successfully but failed when updating subscription state metadata\n+     * (3). AbstractSubscriptionManager#MessagesConsumedTask use\n+     *      InMemorySubscriptionState to do garbage collection\n+     *      and L1 is delete\n+     * (4). If Hub restarts at this time, old subscription state is read and\n+     *      Hub will try to deliver message from 1\n+     */\n+    public void inconsistentSubscriptionStateAndLedgerRanges(int failedCount) throws Exception {\n+        final ByteString topic = ByteString.copyFromUtf8(\"inconsistentSubscriptionStateAndLedgerRanges\");\n+        final ByteString subscriberId = ByteString.copyFromUtf8(\"subId\");\n+        LinkedList<Message> msgs = new LinkedList<Message>();\n+\n+        // make ledger L1 [1 ~ 2]\n+        acquireTopic(topic);\n+        msgs.addAll(publishMessages(topic, 2));\n+        releaseTopic(topic);\n+\n+        // acquire topic again to force a new ledger L2 [3 ~ ]\n+        acquireTopic(topic);\n+        msgs.addAll(publishMessages(topic, 2));\n+\n+        StubCallback<Void> voidCb = new StubCallback<Void>();\n+        StubCallback<SubscriptionData> subDataCb = new StubCallback<SubscriptionData>();\n+        Either<Void, PubSubException> voidResult;\n+        Either<SubscriptionData, PubSubException> subDataResult;\n+\n+        // prepare for subscription\n+        sm.acquiredTopic(topic, voidCb, null);\n+        voidResult = ConcurrencyUtils.take(voidCb.queue);\n+        assertNull(voidResult.right()); // no exception\n+\n+        // Do subscription\n+        SubscribeRequest subRequest = SubscribeRequest.newBuilder().setSubscriberId(subscriberId)\n+                .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();\n+        sm.serveSubscribeRequest(topic, subRequest, MessageSeqId.newBuilder().setLocalComponent(0).build(), subDataCb,\n+                null);\n+        subDataResult = ConcurrencyUtils.take(subDataCb.queue);\n+        assertNotNull(subDataResult.left()); // serveSubscribeRequest success\n+                                             // and return a SubscriptionData\n+                                             // object\n+        assertNull(subDataResult.right()); // no exception\n+\n+        // simulate inconsistent situation between InMemorySubscriptionState and\n+        // LedgerRanges\n+        metadataManagerFactory.setServiceDownCount(failedCount);\n+        sm.setConsumeSeqIdForSubscriber(topic, subscriberId, MessageSeqId.newBuilder().setLocalComponent(2).build(),\n+                voidCb, null);\n+        voidResult = ConcurrencyUtils.take(voidCb.queue);\n+        assertNotNull(voidResult.right()); // update subscription state failed\n+                                           // and expect a exception\n+\n+        // wait AbstractSubscriptionManager#MessagesConsumedTask to garbage\n+        // collect ledger L1\n+        Thread.sleep(conf.getMessagesConsumedThreadRunInterval() * 2);\n+\n+        // simulate hub restart: read old subscription state metadata and deliver\n+        // messages from 1\n+        LinkedBlockingQueue<Boolean> statusQueue = new LinkedBlockingQueue<Boolean>();\n+        RangeScanRequest scan = new RangeScanRequest(topic, 1, 4, Long.MAX_VALUE, new RangeScanVerifier(msgs, null),\n+                statusQueue);\n+        manager.scanMessages(scan);\n+        Boolean b = statusQueue.poll(10 * readDelay, TimeUnit.MILLISECONDS);\n+        if (b == null) {\n+            fail(\"Scan request doesn't finish\");\n+        }\n+    }\n+\n     class TestCallback implements Callback<PubSubProtocol.MessageSeqId> {\n \n         @Override"}]}

