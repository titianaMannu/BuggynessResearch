{"sha":"1374b7ad2738f6c52a2aed1d0ee4e412aa382086","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxMzc0YjdhZDI3MzhmNmM1MmEyYWVkMWQwZWU0ZTQxMmFhMzgyMDg2","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-01-11T04:16:41Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-01-11T04:16:41Z"},"message":"BOOKKEEPER-539: ClientNotSubscribedException & doesn't receive enough messages in TestThrottlingDelivery#testServerSideThrottle (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1431869 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cd9c52ccc4c59b920dcae1394e9b7dd115cf33d5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/cd9c52ccc4c59b920dcae1394e9b7dd115cf33d5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1374b7ad2738f6c52a2aed1d0ee4e412aa382086","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1374b7ad2738f6c52a2aed1d0ee4e412aa382086","html_url":"https://github.com/apache/bookkeeper/commit/1374b7ad2738f6c52a2aed1d0ee4e412aa382086","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4250c1f93962af30e6e40759e006035a7089613e","url":"https://api.github.com/repos/apache/bookkeeper/commits/4250c1f93962af30e6e40759e006035a7089613e","html_url":"https://github.com/apache/bookkeeper/commit/4250c1f93962af30e6e40759e006035a7089613e"}],"stats":{"total":268,"additions":231,"deletions":37},"files":[{"sha":"125834885e2bcc1ca8fd7a449f0fce53997f0544","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=1374b7ad2738f6c52a2aed1d0ee4e412aa382086","patch":"@@ -236,6 +236,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-540: #stopServingSubscriber when channel is disconnected. (Fangmin via sijie)\n \n+        BOOKKEEPER-539: ClientNotSubscribedException & doesn't receive enough messages in TestThrottlingDelivery#testServerSideThrottle (sijie)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-467: Allocate ports for testing dynamically (ivank)"},{"sha":"e7dc1fa0b70e19536aaaef8d23d4b6e64e77295e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","raw_url":"https://github.com/apache/bookkeeper/raw/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java?ref=1374b7ad2738f6c52a2aed1d0ee4e412aa382086","patch":"@@ -82,4 +82,9 @@ public boolean equals(Object obj) {\n     public int hashCode() {\n         return channel.hashCode();\n     }\n+\n+    @Override\n+    public String toString() {\n+        return channel.toString();\n+    }\n }"},{"sha":"a178538baa6162251c0dc6a4b5152c37f7eb76fe","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":27,"deletions":37,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=1374b7ad2738f6c52a2aed1d0ee4e412aa382086","patch":"@@ -217,33 +217,7 @@ public void startServingSubscription(ByteString topic, ByteString subscriberId,\n     public void stopServingSubscriber(ByteString topic, ByteString subscriberId,\n                                       SubscriptionEvent event,\n                                       Callback<Void> cb, Object ctx) {\n-        ActiveSubscriberState subState =\n-            subscriberStates.remove(new TopicSubscriber(topic, subscriberId));\n-\n-        if (subState != null) {\n-            stopServingSubscriber(subState, event, cb, ctx);\n-        } else {\n-            cb.operationFinished(ctx, null);\n-        }\n-    }\n-\n-    /**\n-     * Due to some error or disconnection or unsusbcribe, someone asks us to\n-     * stop serving a particular endpoint\n-     *\n-     * @param subscriber\n-     *          Subscriber instance\n-     * @param event\n-     *          Subscription event indicates why to stop subscriber.\n-     * @param cb\n-     *          Callback after the subscriber is stopped.\n-     * @param ctx\n-     *          Callback context\n-     */\n-    protected void stopServingSubscriber(ActiveSubscriberState subscriber,\n-                                         SubscriptionEvent event,\n-                                         Callback<Void> cb, Object ctx) {\n-        enqueueWithoutFailure(new StopServingSubscriber(subscriber, event, cb, ctx));\n+        enqueueWithoutFailure(new StopServingSubscriber(topic, subscriberId, event, cb, ctx));\n     }\n \n     /**\n@@ -252,7 +226,6 @@ protected void stopServingSubscriber(ActiveSubscriberState subscriber,\n      *\n      * @param subscriber\n      */\n-\n     public void retryErroredSubscriberAfterDelay(ActiveSubscriberState subscriber) {\n \n         subscriber.setLastScanErrorTime(MathUtils.now());\n@@ -279,6 +252,8 @@ public void performRequest() {\n         }\n     }\n \n+    // TODO: for now, I don't move messageConsumed request to delivery manager thread,\n+    //       which is supposed to be fixed in {@link https://issues.apache.org/jira/browse/BOOKKEEPER-503}\n     @Override\n     public void messageConsumed(ByteString topic, ByteString subscriberId,\n                                 MessageSeqId consumedSeqId) {\n@@ -716,7 +691,7 @@ public void permanentErrorOnSend() {\n             // the underlying channel is broken, the channel will\n             // be closed in UmbrellaHandler when exception happened.\n             // so we don't need to close the channel again\n-            stopServingSubscriber(this, null,\n+            stopServingSubscriber(topic, subscriberId, null,\n                                   NOP_CALLBACK, null);\n         }\n \n@@ -729,18 +704,30 @@ public void transientErrorOnSend() {\n          * {@link DeliveryManagerRequest} methods\n          */\n         public void performRequest() {\n-            // try the callback to tell it started to deliver the message\n-            cb.operationFinished(ctx, (Void)null);\n-\n             // Put this subscriber in the channel to subscriber mapping\n             ActiveSubscriberState prevSubscriber =\n                 subscriberStates.put(new TopicSubscriber(topic, subscriberId), this);\n \n+            // after put the active subscriber in subscriber states mapping\n+            // trigger the callback to tell it started to deliver the message\n+            // should let subscriber response go first before first delivered message.\n+            cb.operationFinished(ctx, (Void)null);\n+\n             if (prevSubscriber != null) {\n                 // we already in the delivery thread, we don't need to equeue a stop request\n                 // just stop it now, since stop is not blocking operation.\n                 // and also it cleans the old state of the active subscriber immediately.\n-                doStopServingSubscriber(prevSubscriber, SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED);\n+                SubscriptionEvent se;\n+                if (deliveryEndPoint.equals(prevSubscriber.deliveryEndPoint)) {\n+                    logger.debug(\"Subscriber {} replaced a duplicated subscriber {} at same delivery point {}.\",\n+                                 va(this, prevSubscriber, deliveryEndPoint));\n+                    se = null;\n+                } else {\n+                    logger.debug(\"Subscriber {} from delivery point {} forcelly closed delivery point {}.\",\n+                                 va(this, deliveryEndPoint, prevSubscriber.deliveryEndPoint));\n+                    se = SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED;\n+                }\n+                doStopServingSubscriber(prevSubscriber, se);\n             }\n \n             lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n@@ -762,23 +749,26 @@ public String toString() {\n     }\n \n     protected class StopServingSubscriber implements DeliveryManagerRequest {\n-        ActiveSubscriberState subscriber;\n+        TopicSubscriber ts;\n         SubscriptionEvent event;\n         final Callback<Void> cb;\n         final Object ctx;\n \n-        public StopServingSubscriber(ActiveSubscriberState subscriber,\n+        public StopServingSubscriber(ByteString topic, ByteString subscriberId,\n                                      SubscriptionEvent event,\n                                      Callback<Void> callback, Object ctx) {\n-            this.subscriber = subscriber;\n+            this.ts = new TopicSubscriber(topic, subscriberId);\n             this.event = event;\n             this.cb = callback;\n             this.ctx = ctx;\n         }\n \n         @Override\n         public void performRequest() {\n-            doStopServingSubscriber(subscriber, event);\n+            ActiveSubscriberState subscriber = subscriberStates.remove(ts);\n+            if (null != subscriber) {\n+                doStopServingSubscriber(subscriber, event);\n+            }\n             cb.operationFinished(ctx, null);\n         }\n "},{"sha":"f0a43174341429cc804a7725ee9dad8b0bd5a36d","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","status":"added","additions":197,"deletions":0,"changes":197,"blob_url":"https://github.com/apache/bookkeeper/blob/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/1374b7ad2738f6c52a2aed1d0ee4e412aa382086/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java?ref=1374b7ad2738f6c52a2aed1d0ee4e412aa382086","patch":"@@ -0,0 +1,197 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.delivery;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertNotNull;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.filter.PipelineFilter;\n+import org.apache.hedwig.server.subscriptions.AllToAllTopologyFilter;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.exceptions.PubSubException;\n+\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.server.persistence.StubPersistenceManager;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.persistence.PersistRequest;\n+\n+public class TestFIFODeliveryManager {\n+    static Logger logger = LoggerFactory.getLogger(TestFIFODeliveryManager.class);\n+\n+    static class TestCallback implements Callback<MessageSeqId> {\n+        AtomicBoolean success = new AtomicBoolean(false);\n+        final CountDownLatch latch;\n+        MessageSeqId msgid = null;\n+\n+        TestCallback(CountDownLatch l) {\n+            this.latch = l;\n+        }\n+        public void operationFailed(Object ctx, PubSubException exception) {\n+            logger.error(\"Persist operation failed\", exception);\n+            latch.countDown();\n+        }\n+\n+        public void operationFinished(Object ctx, MessageSeqId resultOfOperation) {\n+            msgid = resultOfOperation;\n+            success.set(true);\n+            latch.countDown();\n+        }\n+\n+        MessageSeqId getId() {\n+            assertTrue(\"Persist operation failed\", success.get());\n+            return msgid;\n+        }\n+    }\n+\n+    /**\n+     * Delivery endpoint which puts all responses on a queue\n+     */\n+    static class ExecutorDeliveryEndPointWithQueue implements DeliveryEndPoint {\n+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+        AtomicInteger numResponses = new AtomicInteger(0);\n+        ConcurrentLinkedQueue<PubSubResponse> queue = new ConcurrentLinkedQueue<PubSubResponse>();\n+\n+        public void send(final PubSubResponse response, final DeliveryCallback callback) {\n+            logger.info(\"Received response {}\", response);\n+            queue.add(response);\n+            numResponses.incrementAndGet();\n+            executor.submit(new Runnable() {\n+                    public void run() {\n+                        callback.sendingFinished();\n+                    }\n+                });\n+        }\n+\n+        public void close() {\n+            executor.shutdown();\n+        }\n+\n+        PubSubResponse getNextResponse() {\n+            return queue.poll();\n+        }\n+\n+        int getNumResponses() {\n+            return numResponses.get();\n+        }\n+    }\n+\n+    /**\n+     * Test that the FIFO delivery manager executes stopServing and startServing\n+     * in the correct order\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-539}\n+     */\n+    @Test\n+    public void testFIFODeliverySubCloseSubRace() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration();\n+        ByteString topic = ByteString.copyFromUtf8(\"subRaceTopic\");\n+        ByteString subscriber = ByteString.copyFromUtf8(\"subRaceSubscriber\");\n+\n+        PersistenceManager pm = new StubPersistenceManager();\n+        FIFODeliveryManager fdm = new FIFODeliveryManager(pm, conf);\n+        ExecutorDeliveryEndPointWithQueue dep = new ExecutorDeliveryEndPointWithQueue();\n+        SubscriptionPreferences prefs = SubscriptionPreferences.newBuilder().build();\n+\n+        PipelineFilter filter = new PipelineFilter();\n+        filter.addLast(new AllToAllTopologyFilter());\n+        filter.initialize(conf.getConf());\n+        filter.setSubscriptionPreferences(topic, subscriber, prefs);\n+        MessageSeqId startId = MessageSeqId.newBuilder().build();\n+\n+        CountDownLatch l = new CountDownLatch(1);\n+        Message m = Message.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(1))).build();\n+        TestCallback cb = new TestCallback(l);\n+        pm.persistMessage(new PersistRequest(topic, m, cb, null));\n+        assertTrue(\"Persistence never finished\", l.await(10, TimeUnit.SECONDS));\n+\n+        final CountDownLatch oplatch = new CountDownLatch(3);\n+        fdm.start();\n+        fdm.startServingSubscription(topic, subscriber, prefs, startId, dep, filter,\n+                new Callback<Void>() {\n+                     @Override\n+                     public void operationFinished(Object ctx, Void result) {\n+                         oplatch.countDown();\n+                     }\n+                     @Override\n+                     public void operationFailed(Object ctx, PubSubException exception) {\n+                         oplatch.countDown();\n+                     }\n+                }, null);\n+        fdm.stopServingSubscriber(topic, subscriber, null,\n+                new Callback<Void>() {\n+                     @Override\n+                     public void operationFinished(Object ctx, Void result) {\n+                         oplatch.countDown();\n+                     }\n+                     @Override\n+                     public void operationFailed(Object ctx, PubSubException exception) {\n+                         oplatch.countDown();\n+                     }\n+                }, null);\n+        fdm.startServingSubscription(topic, subscriber, prefs, startId, dep, filter,\n+                new Callback<Void>() {\n+                     @Override\n+                     public void operationFinished(Object ctx, Void result) {\n+                         oplatch.countDown();\n+                     }\n+                     @Override\n+                     public void operationFailed(Object ctx, PubSubException exception) {\n+                         oplatch.countDown();\n+                     }\n+                }, null);\n+\n+        assertTrue(\"Ops never finished\", oplatch.await(10, TimeUnit.SECONDS));\n+        int seconds = 5;\n+        while (dep.getNumResponses() < 2) {\n+            if (seconds-- == 0) {\n+                break;\n+            }\n+            Thread.sleep(1000);\n+        }\n+        PubSubResponse r = dep.getNextResponse();\n+        assertNotNull(\"There should be a response\", r);\n+        assertTrue(\"Response should contain a message\", r.hasMessage());\n+        r = dep.getNextResponse();\n+        assertNotNull(\"There should be a response\", r);\n+        assertTrue(\"Response should contain a message\", r.hasMessage());\n+        r = dep.getNextResponse();\n+        assertNull(\"There should only be 2 responses\", r);\n+    }\n+}"}]}

