{"sha":"14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxNGUyM2I2ZDljZjQwMTVjZDc2YzdlZDNkNTI1OGJmYmNiYjA1ZWY4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-17T15:32:23Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-17T15:32:23Z"},"message":"BOOKKEEPER-332: Add SubscriptionPreferences to record all preferences for a subscription (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1374321 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"64ea3e4cee54212c57acdde7dcdc8470240d4832","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/64ea3e4cee54212c57acdde7dcdc8470240d4832"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","html_url":"https://github.com/apache/bookkeeper/commit/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"bb0888acafee138989dffb1cfee732145c953f38","url":"https://api.github.com/repos/apache/bookkeeper/commits/bb0888acafee138989dffb1cfee732145c953f38","html_url":"https://github.com/apache/bookkeeper/commit/bb0888acafee138989dffb1cfee732145c953f38"}],"stats":{"total":7327,"additions":5215,"deletions":2112},"files":[{"sha":"834c1b20441dddddc0cb5e982ea619456e9b5db5","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -98,6 +98,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-283: Improve Hedwig Console to use Hedwig Metadata Manager. (sijie via ivank)\n \n+        BOOKKEEPER-332: Add SubscriptionPreferences to record all preferences for a subscription (sijie via ivank)\n+\n       hedwig-client:\n \n         BOOKKEEPER-306: Change C++ client to use gtest for testing (ivank via sijie)"},{"sha":"a9d00f8c81bd2bdd8ca6974123573320b089fbfb","filename":"bookkeeper-server/pom.xml","status":"modified","additions":45,"deletions":33,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/pom.xml?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -88,32 +88,32 @@\n       <version>2.1</version>\n     </dependency>\n     <!--\n-\tAnnoying dependency we need to include because\n-\tzookeeper uses log4j and so we transatively do, but\n-\tlog4j has some dependencies which aren't in the \n-\tdefault maven repositories\n+        Annoying dependency we need to include because\n+        zookeeper uses log4j and so we transatively do, but\n+        log4j has some dependencies which aren't in the \n+        default maven repositories\n     //-->\n     <dependency>\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n       <version>1.2.15</version>\n       <exclusions>\n-\t<exclusion>\n-\t  <groupId>javax.mail</groupId>\n-\t  <artifactId>mail</artifactId>\n-\t</exclusion>\n-\t<exclusion>\n-\t  <groupId>javax.jms</groupId>\n-\t  <artifactId>jms</artifactId>\n-\t</exclusion>\n-\t<exclusion>\n-\t  <groupId>com.sun.jdmk</groupId>\n-\t  <artifactId>jmxtools</artifactId>\n-\t</exclusion>\n-\t<exclusion>\n-\t  <groupId>com.sun.jmx</groupId>\n-\t  <artifactId>jmxri</artifactId>\n-\t</exclusion>\n+        <exclusion>\n+          <groupId>javax.mail</groupId>\n+          <artifactId>mail</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>javax.jms</groupId>\n+          <artifactId>jms</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>com.sun.jdmk</groupId>\n+          <artifactId>jmxtools</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>com.sun.jmx</groupId>\n+          <artifactId>jmxri</artifactId>\n+        </exclusion>\n       </exclusions>\n     </dependency>\n     <dependency>\n@@ -164,12 +164,24 @@\n           </execution>\n         </executions>\n       </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-jar-plugin</artifactId>\n+        <version>2.2</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>test-jar</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n       <plugin>\n         <artifactId>maven-assembly-plugin</artifactId>\n         <version>2.2.1</version>\n         <configuration>\n           <descriptors>\n-\t    <descriptor>../src/assemble/bin.xml</descriptor>\n+            <descriptor>../src/assemble/bin.xml</descriptor>\n           </descriptors>\n         </configuration>\n       </plugin>\n@@ -192,18 +204,18 @@\n         </configuration>\n       </plugin>\n       <plugin>\n-\t<artifactId>maven-dependency-plugin</artifactId>\n-\t<executions>\n-\t  <execution>\n-\t    <phase>package</phase>\n-\t    <goals>\n-\t      <goal>copy-dependencies</goal>\n-\t    </goals>\n-\t    <configuration>\n-\t      <outputDirectory>${basedir}/lib</outputDirectory>\n-\t    </configuration>\n-\t  </execution>\n-\t</executions>\n+        <artifactId>maven-dependency-plugin</artifactId>\n+        <executions>\n+          <execution>\n+            <phase>package</phase>\n+            <goals>\n+              <goal>copy-dependencies</goal>\n+            </goals>\n+            <configuration>\n+              <outputDirectory>${basedir}/lib</outputDirectory>\n+            </configuration>\n+          </execution>\n+        </executions>\n       </plugin>\n     </plugins>\n   </build>"},{"sha":"ea221ae78363987eaf829ad382900750ced71347","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"modified","additions":12,"deletions":3,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -98,6 +98,17 @@ const MessageSeqId PubSubData::getMessageSeqId() const {\n   return msgid;\n }\n \n+void PubSubData::setPreferencesForSubRequest(SubscribeRequest * subreq,\n+                                             const SubscriptionOptions &options) {\n+  Hedwig::SubscriptionPreferences* preferences = subreq->mutable_preferences();\n+  if (options.messagebound() > 0) {\n+    preferences->set_messagebound(options.messagebound());\n+  }\n+  if (options.has_options()) {\n+    preferences->mutable_options()->CopyFrom(options.options());\n+  }\n+}\n+\n const PubSubRequestPtr PubSubData::getRequest() {\n   PubSubRequestPtr request(new Hedwig::PubSubRequest());\n   request->set_protocolversion(Hedwig::VERSION_ONE);\n@@ -120,9 +131,7 @@ const PubSubRequestPtr PubSubData::getRequest() {\n     Hedwig::SubscribeRequest* subreq = request->mutable_subscriberequest();\n     subreq->set_subscriberid(subscriberid);\n     subreq->set_createorattach(options.createorattach());\n-    if (options.messagebound() > 0) {\n-      subreq->set_messagebound(options.messagebound());\n-    }\n+    setPreferencesForSubRequest(subreq, options);\n   } else if (type == CONSUME) {\n     LOG4CXX_DEBUG(logger, \"Creating consume request\");\n "},{"sha":"1539a1836d906945a7d4c48175472a28290b9be6","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -95,6 +95,9 @@ namespace Hedwig {\n   private:\n \n     PubSubData();\n+\n+    void setPreferencesForSubRequest(SubscribeRequest * subreq,\n+                                     const SubscriptionOptions &options);\n     \n     OperationType type;\n     long txnid;"},{"sha":"754ba6b502a5a992cfcc76b86bb233e8d5bc5725","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"modified","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -182,3 +182,45 @@ TEST(MessageBoundTest, testMultipleSubscribers) {\n   sub.unsubscribe(topic, subid5);\n }\n \n+TEST(MessageBoundTest, testUpdateMessageBound) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  Hedwig::SubscriptionOptions options5;\n+  options5.set_messagebound(5);\n+  options5.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  Hedwig::SubscriptionOptions options20;\n+  options20.set_messagebound(20);\n+  options20.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  Hedwig::SubscriptionOptions options10;\n+  options10.set_messagebound(10);\n+  options10.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+  std::string topic = \"testUpdateMessageBound\";\n+  std::string subid = \"updateSubId\";\n+\n+  sub.subscribe(topic, subid, options5);\n+  sub.closeSubscription(topic, subid);\n+  sendXExpectLastY(pub, sub, topic, subid, 50, 5);\n+\n+  // update bound to 20\n+  sub.subscribe(topic, subid, options20);\n+  sub.closeSubscription(topic, subid);\n+  sendXExpectLastY(pub, sub, topic, subid, 50, 20);\n+\n+  // update bound to 10\n+  sub.subscribe(topic, subid, options10);\n+  sub.closeSubscription(topic, subid);\n+  sendXExpectLastY(pub, sub, topic, subid, 50, 10);\n+\n+  // message bound is not provided, no update\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.closeSubscription(topic, subid);\n+  sendXExpectLastY(pub, sub, topic, subid, 50, 10);\n+}"},{"sha":"520ca2023e9396bf319426cba7a6b434a2ac5a0a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":33,"deletions":5,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -53,6 +53,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n@@ -354,6 +355,31 @@ public void consume(ByteString topic, ByteString subscriberId, MessageSeqId mess\n         doConsume(pubSubData, topicSubscriber2Channel.get(topicSubscriber), messageSeqId);\n     }\n \n+    /**\n+     * Convert client-side subscription options to subscription preferences\n+     *\n+     * @param options\n+     *          Client-Side subscription options\n+     */\n+    protected SubscriptionPreferences.Builder options2Preferences(SubscriptionOptions options) {\n+        // prepare subscription preferences\n+        SubscriptionPreferences.Builder preferencesBuilder = SubscriptionPreferences.newBuilder();\n+\n+        // set message bound\n+        if (options.getMessageBound() > 0) {\n+            preferencesBuilder.setMessageBound(options.getMessageBound());\n+        } else if (cfg.getSubscriptionMessageBound() > 0) {\n+            preferencesBuilder.setMessageBound(cfg.getSubscriptionMessageBound());\n+        }\n+\n+        // set user options\n+        if (options.hasOptions()) {\n+            preferencesBuilder.setOptions(options.getOptions());\n+        }\n+\n+        return preferencesBuilder;\n+    }\n+\n     /**\n      * This is a helper method to write the actual subscribe/unsubscribe message\n      * once the client is connected to the server and a Channel is available.\n@@ -388,12 +414,14 @@ protected void doSubUnsub(PubSubData pubSubData, Channel channel) {\n             // For now, all subscribes should wait for all cross-regional\n             // subscriptions to be established before returning.\n             subscribeRequestBuilder.setSynchronous(true);\n-\n-            if (pubSubData.options.getMessageBound() > 0) {\n-                subscribeRequestBuilder.setMessageBound(pubSubData.options.getMessageBound());\n-            } else if (cfg.getSubscriptionMessageBound() > 0) {\n-                subscribeRequestBuilder.setMessageBound(cfg.getSubscriptionMessageBound());\n+            // set subscription preferences\n+            SubscriptionPreferences.Builder preferencesBuilder =\n+                options2Preferences(pubSubData.options);\n+            // backward compatable with 4.1.0\n+            if (preferencesBuilder.hasMessageBound()) {\n+                subscribeRequestBuilder.setMessageBound(preferencesBuilder.getMessageBound());\n             }\n+            subscribeRequestBuilder.setPreferences(preferencesBuilder);\n \n             // Set the SubscribeRequest into the outer PubSubRequest\n             pubsubRequestBuilder.setSubscribeRequest(subscribeRequestBuilder);"},{"sha":"c2c6d8a87542db704bc51af94d2403ee6b70aa2e","filename":"hedwig-protocol/pom.xml","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/pom.xml?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -41,6 +41,16 @@\n       <version>4.8.1</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+      <version>1.6.4</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-log4j12</artifactId>\n+      <version>1.6.4</version>\n+    </dependency>\n   </dependencies>\n   <repositories>\n   </repositories>"},{"sha":"14e1cab177a8aa5eaabb87f092fe787c46857bc7","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":4307,"deletions":1914,"changes":6221,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8"},{"sha":"e195ace85d9605717798fdcc8aeddb1d3c238917","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","status":"modified","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -17,25 +17,84 @@\n  */\n package org.apache.hedwig.protoextensions;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+\n import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class SubscriptionStateUtils {\n \n+    static final Logger logger = LoggerFactory.getLogger(SubscriptionStateUtils.class);\n+\n     // For now, to differentiate hub subscribers from local ones, the\n     // subscriberId will be prepended with a hard-coded prefix. Local\n     // subscribers will validate that the subscriberId used cannot start with\n     // this prefix. This is only used internally by the hub subscribers.\n     public static final String HUB_SUBSCRIBER_PREFIX = \"__\";\n \n+    public static SubscriptionData parseSubscriptionData(byte[] data)\n+    throws InvalidProtocolBufferException {\n+        try {\n+            return SubscriptionData.parseFrom(data);\n+        } catch (InvalidProtocolBufferException ex) {\n+            logger.info(\"Failed to parse data as SubscriptionData. Fall backward to parse it as SubscriptionState for backward compatability.\");\n+            // backward compability\n+            SubscriptionState state = SubscriptionState.parseFrom(data);\n+            return SubscriptionData.newBuilder().setState(state).build();\n+        }\n+    }\n+\n+    public static String toString(SubscriptionData data) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data.hasState()) {\n+            sb.append(\"State : { \").append(toString(data.getState())).append(\" };\");\n+        }\n+        if (data.hasPreferences()) {\n+            sb.append(\"Preferences : { \").append(toString(data.getPreferences())).append(\" };\");\n+        }\n+        return sb.toString();\n+    }\n+\n     public static String toString(SubscriptionState state) {\n         StringBuilder sb = new StringBuilder();\n         sb.append(\"consumeSeqId: \" + MessageIdUtils.msgIdToReadableString(state.getMsgId()));\n         return sb.toString();\n     }\n \n+    public static String toString(SubscriptionPreferences preferences) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"System Preferences : [\");\n+        if (preferences.hasMessageBound()) {\n+            sb.append(\"(messageBound=\").append(preferences.getMessageBound())\n+              .append(\")\");\n+        }\n+        sb.append(\"]\");\n+        if (preferences.hasOptions()) {\n+            sb.append(\", Customized Preferences : [\");\n+            sb.append(MapUtils.toString(preferences.getOptions()));\n+            sb.append(\"]\");\n+        }\n+        return sb.toString();\n+    }\n+\n     public static boolean isHubSubscriber(ByteString subscriberId) {\n         return subscriberId.toStringUtf8().startsWith(HUB_SUBSCRIBER_PREFIX);\n     }\n \n+    public static Map<String, ByteString> buildUserOptions(SubscriptionPreferences preferences) {\n+        if (preferences.hasOptions()) {\n+            return MapUtils.buildMap(preferences.getOptions());\n+        } else {\n+            return new HashMap<String, ByteString>();\n+        }\n+    }\n+\n }"},{"sha":"22589a45f84729970ab671163f8ce5ff8dfc1b27","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":51,"deletions":11,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -23,6 +23,15 @@ enum ProtocolVersion{\n     VERSION_ONE = 1;\n }\n \n+// common structure to store header or properties\n+message Map {\n+    message Entry {\n+        optional string key  = 1;\n+        optional bytes value = 2;\n+    }\n+    repeated Entry entries = 1;\n+}\n+\n /*\n  * this is the structure that will be serialized\n  */\n@@ -84,24 +93,46 @@ message PublishRequest{\n     required Message msg = 2;\n }\n \n+// record all preferences for a subscription,\n+// would be serialized to be stored in meta store\n+message SubscriptionPreferences {\n+    // user customized subscription options\n+    optional Map options = 1;\n+\n+    ///\n+    /// system defined options\n+    ///\n+\n+    // message bound\n+    optional uint32 messageBound = 2;\n+}\n+\n message SubscribeRequest{\n     required bytes subscriberId = 2;\n-\t\n-\tenum CreateOrAttach{\n-\t    CREATE = 0;\n-\t    ATTACH = 1;\n-\t    CREATE_OR_ATTACH = 2;\n-\t};\n-\toptional CreateOrAttach createOrAttach = 3 [default = CREATE_OR_ATTACH];\n-\t\n-\t// wait for cross-regional subscriptions to be established before returning\n-\toptional bool synchronous = 4 [default = false];\n-\toptional uint32 messageBound = 5;\n+\n+    enum CreateOrAttach{\n+        CREATE = 0;\n+        ATTACH = 1;\n+        CREATE_OR_ATTACH = 2;\n+    };\n+    optional CreateOrAttach createOrAttach = 3 [default = CREATE_OR_ATTACH];\n+\n+    // wait for cross-regional subscriptions to be established before returning\n+    optional bool synchronous = 4 [default = false];\n+    // @Deprecated. set message bound in SubscriptionPreferences\n+    optional uint32 messageBound = 5;\n+\n+    // subscription options\n+    optional SubscriptionPreferences preferences = 6;\n }\n \n+// used in client only\n+// options are stored in SubscriptionPreferences structure\n message SubscriptionOptions {\n     optional SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n     optional uint32 messageBound = 3 [default = 0];\n+    // user customized subscription options\n+    optional Map options = 4;\n }\n \n message ConsumeRequest{\n@@ -189,9 +220,18 @@ enum StatusCode{\n     \n message SubscriptionState {\n     required MessageSeqId msgId = 1;\n+    // @Deprecated.\n+    // It is a bad idea to put fields that don't change frequently\n+    // together with fields that change frequently\n+    // so move it to subscription preferences structure\n     optional uint32 messageBound = 2;\n }\n \n+message SubscriptionData {\n+    optional SubscriptionState state = 1;\n+    optional SubscriptionPreferences preferences = 2;\n+}\n+\n message LedgerRange{\n     required uint64 ledgerId = 1;\n     optional MessageSeqId endSeqIdIncluded = 2;"},{"sha":"df2f9e443dd98bcb2d176298e13d60a9ece60da8","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","status":"modified","additions":11,"deletions":25,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -38,14 +38,12 @@\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n-import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.meta.SubscriptionDataManager;\n import org.apache.hedwig.server.meta.TopicOwnershipManager;\n import org.apache.hedwig.server.meta.TopicPersistenceManager;\n-import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.server.topics.HubLoad;\n import org.apache.hedwig.util.Callback;\n@@ -446,16 +444,14 @@ LedgerRange refreshLastLedgerRange(MessageSeqId lastSeqId, LedgerRange oldRange)\n      * @return subscriptions of a topic\n      * @throws Exception\n      */\n-    public Map<ByteString, SubscriptionState> getTopicSubscriptions(ByteString topic)\n+    public Map<ByteString, SubscriptionData> getTopicSubscriptions(ByteString topic)\n         throws Exception {\n-        Map<ByteString, SubscriptionState> states =\n-            new HashMap<ByteString, SubscriptionState>();\n \n-        final SyncObj<Map<ByteString, InMemorySubscriptionState>> syncObj =\n-            new SyncObj<Map<ByteString, InMemorySubscriptionState>>();\n-        sdm.readSubscriptions(topic, new Callback<Map<ByteString, InMemorySubscriptionState>>() {\n+        final SyncObj<Map<ByteString, SubscriptionData>> syncObj =\n+            new SyncObj<Map<ByteString, SubscriptionData>>();\n+        sdm.readSubscriptions(topic, new Callback<Map<ByteString, SubscriptionData>>() {\n             @Override\n-            public void operationFinished(Object ctx, Map<ByteString, InMemorySubscriptionState> result) {\n+            public void operationFinished(Object ctx, Map<ByteString, SubscriptionData> result) {\n                 syncObj.success(result);\n             }\n             @Override\n@@ -470,17 +466,7 @@ public void operationFailed(Object ctx, PubSubException pse) {\n             throw syncObj.exception;\n         }\n \n-        Map<ByteString, InMemorySubscriptionState> subStats = syncObj.value;\n-\n-        if (null == subStats) {\n-            return states;\n-        }\n-\n-        for (Map.Entry<ByteString, InMemorySubscriptionState> entry : subStats.entrySet()) {\n-            states.put(entry.getKey(), entry.getValue().getSubscriptionState());\n-        }\n-\n-        return states;\n+        return syncObj.value;\n     }\n \n     /**\n@@ -493,11 +479,11 @@ public void operationFailed(Object ctx, PubSubException pse) {\n      * @return subscription state\n      * @throws Exception\n      */\n-    public SubscriptionState getSubscription(ByteString topic, ByteString subscriber) throws Exception {\n-        final SyncObj<SubscriptionState> syncObj = new SyncObj<SubscriptionState>();\n-        sdm.readSubscriptionState(topic, subscriber, new Callback<SubscriptionState>() {\n+    public SubscriptionData getSubscription(ByteString topic, ByteString subscriber) throws Exception {\n+        final SyncObj<SubscriptionData> syncObj = new SyncObj<SubscriptionData>();\n+        sdm.readSubscriptionData(topic, subscriber, new Callback<SubscriptionData>() {\n             @Override\n-            public void operationFinished(Object ctx, SubscriptionState result) {\n+            public void operationFinished(Object ctx, SubscriptionData result) {\n                 syncObj.success(result);\n             }\n             @Override"},{"sha":"7d8e22b9d44f133cb287cb0454af6650fcd0a7a7","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -49,7 +49,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.topics.HubInfo;\n@@ -393,8 +393,9 @@ public boolean runCmd(String[] args) throws Exception {\n                 return false;\n             }\n             long lastConsumedId = 0;\n-            SubscriptionState state = admin.getSubscription(ByteString.copyFromUtf8(args[1]), ByteString.copyFromUtf8(args[2]));\n-            if (null == state) {\n+            SubscriptionData subData = admin.getSubscription(ByteString.copyFromUtf8(args[1]),\n+                                                             ByteString.copyFromUtf8(args[2]));\n+            if (null == subData) {\n                 System.err.println(\"Failed to read subscription for topic: \" + args[1]\n                                  + \" subscriber: \" + args[2]);\n                 return true;\n@@ -605,7 +606,7 @@ protected boolean describeTopic(String topic) throws Exception {\n             ByteString btopic = ByteString.copyFromUtf8(topic);\n             HubInfo owner = admin.getTopicOwner(btopic);\n             List<LedgerRange> ranges = admin.getTopicLedgers(btopic);\n-            Map<ByteString, SubscriptionState> states = admin.getTopicSubscriptions(btopic);\n+            Map<ByteString, SubscriptionData> states = admin.getTopicSubscriptions(btopic);\n \n             System.out.println(\"===== Topic Information : \" + topic + \" =====\");\n             System.out.println();\n@@ -646,13 +647,13 @@ private void printTopicLedgers(List<LedgerRange> lrs) {\n             System.out.println();\n         }\n \n-        private void printTopicSubscriptions(Map<ByteString, SubscriptionState> states) {\n+        private void printTopicSubscriptions(Map<ByteString, SubscriptionData> states) {\n             System.out.println(\">>> Subscription Info <<<\");\n             if (0 == states.size()) {\n                 System.out.println(\"No subscriber.\");\n                 return;\n             }\n-            for (Map.Entry<ByteString, SubscriptionState> entry : states.entrySet()) {\n+            for (Map.Entry<ByteString, SubscriptionData> entry : states.entrySet()) {\n                 System.out.println(\"Subscriber \" + entry.getKey().toStringUtf8() + \" : \"\n                                  + SubscriptionStateUtils.toString(entry.getValue()));\n             }"},{"sha":"bfc501c08c36003696f4e796a22113a96fcdd7ed","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -39,7 +39,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.RegionSpecificSeqId;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.data.Stat;\n@@ -142,13 +142,13 @@ protected int getTopicLedgers() throws Exception {\n     }\n     \n     protected int getLeastSubscription() throws Exception {\n-        Map<ByteString, SubscriptionState> states = admin.getTopicSubscriptions(topic); \n+        Map<ByteString, SubscriptionData> states = admin.getTopicSubscriptions(topic); \n         if (states.isEmpty()) {\n             return RC_NOSUBSCRIBERS;\n         }\n-        for (Map.Entry<ByteString, SubscriptionState> entry : states.entrySet()) {\n-            SubscriptionState state = entry.getValue();\n-            long localMsgId = state.getMsgId().getLocalComponent();\n+        for (Map.Entry<ByteString, SubscriptionData> entry : states.entrySet()) {\n+            SubscriptionData state = entry.getValue();\n+            long localMsgId = state.getState().getMsgId().getLocalComponent();\n             if (localMsgId < leastConsumedSeqId) {\n                 leastConsumedSeqId = localMsgId;\n             }"},{"sha":"4ae4db0b62a5a45cb02d1219ed2bc64697ee9f6d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","status":"modified","additions":47,"deletions":19,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -23,7 +23,7 @@\n import com.google.protobuf.ByteString;\n \n import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n import org.apache.hedwig.util.Callback;\n \n@@ -33,45 +33,73 @@\n public interface SubscriptionDataManager extends Closeable {\n \n     /**\n-     * Create subscription state.\n+     * Create subscription data.\n      *\n      * @param topic\n      *          Topic name\n      * @param subscriberId\n      *          Subscriber id\n-     * @param state\n-     *          Subscription state\n+     * @param data \n+     *          Subscription data\n      * @param callback\n      *          Callback when subscription state created.\n      *          {@link PubSubException.SubscriptionStateExistsException} is returned when subscription state\n      *          existed before.\n      * @param ctx\n      *          Context of the callback\n      */\n-    public void createSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n-                                        Callback<Void> callback, Object ctx);\n+    public void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n+                                       Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Whether the metadata manager supports partial update.\n+     *\n+     * @return true if the metadata manager supports partial update.\n+     *         otherwise, return false.\n+     */\n+    public boolean isPartialUpdateSupported();\n \n     /**\n-     * Update subscription state.\n+     * Update subscription data.\n      *\n      * @param topic\n      *          Topic name\n      * @param subscriberId\n      *          Subscriber id\n-     * @param state\n-     *          Subscription state\n+     * @param dataToUpdate\n+     *          Subscription data to update. So it is a partial data, which contains\n+     *          the part of data to update. The implementation should not replace\n+     *          existing subscription data with <i>dataToUpdate</i> directly.\n+     *          E.g. if there is only state in it, you should update state only.\n      * @param callback\n      *          Callback when subscription state updated.\n      *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n      *          is found.\n      * @param ctx\n      *          Context of the callback\n      */\n-    public void updateSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n+    public void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToUpdate,\n+                                       Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Replace subscription data.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param dataToReplace\n+     *          Subscription data to replace.\n+     * @param callback\n+     *          Callback when subscription state updated.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToReplace,\n                                         Callback<Void> callback, Object ctx);\n \n     /**\n-     * Remove subscription state.\n+     * Remove subscription data.\n      *\n      * @param topic\n      *          Topic name\n@@ -84,24 +112,24 @@ public void updateSubscriptionState(ByteString topic, ByteString subscriberId, S\n      * @param ctx\n      *          Context of the callback\n      */\n-    public void deleteSubscriptionState(ByteString topic, ByteString subscriberId,\n-                                        Callback<Void> callback, Object ctx);\n+    public void deleteSubscriptionData(ByteString topic, ByteString subscriberId,\n+                                       Callback<Void> callback, Object ctx);\n \n     /**\n-     * Read subscription state.\n+     * Read subscription data.\n      *\n      * @param topic\n      *          Topic Name\n      * @param subscriberId\n      *          Subscriber id\n      * @param callback\n-     *          Callback when subscription state read.\n-     *          Null is returned when no subscription state is found.\n+     *          Callback when subscription data read.\n+     *          Null is returned when no subscription data is found.\n      * @param ctx\n      *          Context of the callback\n      */\n-    public void readSubscriptionState(ByteString topic, ByteString subscriberId,\n-                                      Callback<SubscriptionState> callback, Object ctx);\n+    public void readSubscriptionData(ByteString topic, ByteString subscriberId,\n+                                     Callback<SubscriptionData> callback, Object ctx);\n \n     /**\n      * Read all subscriptions of a topic.\n@@ -113,6 +141,6 @@ public void readSubscriptionState(ByteString topic, ByteString subscriberId,\n      * @param ctx\n      *          Contxt of the callback\n      */\n-    public void readSubscriptions(ByteString topic, Callback<Map<ByteString, InMemorySubscriptionState>> cb,\n+    public void readSubscriptions(ByteString topic, Callback<Map<ByteString, SubscriptionData>> cb,\n                                   Object ctx);\n }"},{"sha":"e65ad780301908f29ad9da4084f1d6bd826a40bf","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","status":"modified","additions":38,"deletions":28,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -41,10 +41,10 @@\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n-import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n@@ -377,9 +377,14 @@ private String topicSubscriberPath(ByteString topic, ByteString subscriber) {\n         }\n \n         @Override\n-        public void createSubscriptionState(final ByteString topic, final ByteString subscriberId, final SubscriptionState state,\n-                                            final Callback<Void> callback, final Object ctx) {\n-            ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), state.toByteArray(),\n+        public boolean isPartialUpdateSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void createSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n+                                           final Callback<Void> callback, final Object ctx) {\n+            ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), data.toByteArray(),\n             Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n \n                 @Override\n@@ -393,8 +398,8 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n                     } else if (rc == Code.OK.intValue()) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Successfully recorded subscription for topic: \" + topic.toStringUtf8()\n-                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n-                                         + SubscriptionStateUtils.toString(state));\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" data: \"\n+                                         + SubscriptionStateUtils.toString(data));\n                         }\n                         callback.operationFinished(ctx, null);\n                     } else {\n@@ -408,9 +413,15 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n         }\n \n         @Override\n-        public void updateSubscriptionState(final ByteString topic, final ByteString subscriberId, final SubscriptionState state,\n+        public void updateSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n+                                           final Callback<Void> callback, final Object ctx) {\n+            throw new UnsupportedOperationException(\"ZooKeeper based metadata manager doesn't support partial update!\");\n+        }\n+\n+        @Override\n+        public void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n                                             final Callback<Void> callback, final Object ctx) {\n-            zk.setData(topicSubscriberPath(topic, subscriberId), state.toByteArray(), -1,\n+            zk.setData(topicSubscriberPath(topic, subscriberId), data.toByteArray(), -1,\n             new SafeAsyncZKCallback.StatCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n@@ -423,14 +434,14 @@ public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n                     } else if (rc != Code.OK.intValue()) {\n                         KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n                                             + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                                            + \" could not set subscription state: \" + SubscriptionStateUtils.toString(state),\n+                                            + \" could not set subscription data: \" + SubscriptionStateUtils.toString(data),\n                                             path, rc);\n                         callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                     } else {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Successfully updated subscription for topic: \" + topic.toStringUtf8()\n-                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n-                                         + SubscriptionStateUtils.toString(state));\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" data: \"\n+                                         + SubscriptionStateUtils.toString(data));\n                         }\n \n                         callback.operationFinished(ctx, null);\n@@ -440,8 +451,8 @@ public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n         }\n \n         @Override\n-        public void deleteSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                            final Callback<Void> callback, Object ctx) {\n+        public void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                           final Callback<Void> callback, Object ctx) {\n             zk.delete(topicSubscriberPath(topic, subscriberId), -1, new SafeAsyncZKCallback.VoidCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx) {\n@@ -469,8 +480,8 @@ public void safeProcessResult(int rc, String path, Object ctx) {\n         }\n \n         @Override\n-        public void readSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                          final Callback<SubscriptionState> callback, final Object ctx) {\n+        public void readSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                         final Callback<SubscriptionData> callback, final Object ctx) {\n             zk.getData(topicSubscriberPath(topic, subscriberId), false, new SafeAsyncZKCallback.DataCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n@@ -486,11 +497,11 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                         return;\n                     }\n \n-                    SubscriptionState state;\n+                    SubscriptionData subData;\n                     try {\n-                        state = SubscriptionState.parseFrom(data);\n+                        subData = SubscriptionStateUtils.parseSubscriptionData(data);\n                     } catch (InvalidProtocolBufferException ex) {\n-                        String msg = \"Failed to deserialize state for topic: \" + topic.toStringUtf8()\n+                        String msg = \"Failed to deserialize subscription data for topic: \" + topic.toStringUtf8()\n                                      + \" subscriberId: \" + subscriberId.toStringUtf8();\n                         logger.error(msg, ex);\n                         callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n@@ -500,16 +511,16 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n                                      + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                                     + \"state: \" + SubscriptionStateUtils.toString(state));\n+                                     + \" data: \" + SubscriptionStateUtils.toString(subData));\n                     }\n-                    callback.operationFinished(ctx, state);\n+                    callback.operationFinished(ctx, subData);\n                 }\n             }, ctx);\n         }\n \n         @Override\n         public void readSubscriptions(final ByteString topic,\n-                                      final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n+                                      final Callback<Map<ByteString, SubscriptionData>> cb, final Object ctx) {\n             String topicSubscribersPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n             zk.getChildren(topicSubscribersPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n                 @Override\n@@ -522,7 +533,7 @@ public void safeProcessResult(int rc, String path, final Object ctx, final List<\n                         return;\n                     }\n \n-                    final Map<ByteString, InMemorySubscriptionState> topicSubs = new ConcurrentHashMap<ByteString, InMemorySubscriptionState>();\n+                    final Map<ByteString, SubscriptionData> topicSubs = new ConcurrentHashMap<ByteString, SubscriptionData>();\n \n                     if (rc == Code.NONODE.intValue() || children.size() == 0) {\n                         if (logger.isDebugEnabled()) {\n@@ -556,12 +567,11 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                                     return;\n                                 }\n \n-                                SubscriptionState state;\n-\n+                                SubscriptionData subData;\n                                 try {\n-                                    state = SubscriptionState.parseFrom(data);\n+                                    subData = SubscriptionStateUtils.parseSubscriptionData(data);\n                                 } catch (InvalidProtocolBufferException ex) {\n-                                    String msg = \"Failed to deserialize state for topic: \" + topic.toStringUtf8()\n+                                    String msg = \"Failed to deserialize subscription data for topic: \" + topic.toStringUtf8()\n                                                  + \" subscriberId: \" + subscriberId.toStringUtf8();\n                                     logger.error(msg, ex);\n                                     reportFailure(new PubSubException.UnexpectedConditionException(msg));\n@@ -571,10 +581,10 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                                 if (logger.isDebugEnabled()) {\n                                     logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n                                                  + \" subscriberId: \" + child + \"state: \"\n-                                                 + SubscriptionStateUtils.toString(state));\n+                                                 + SubscriptionStateUtils.toString(subData));\n                                 }\n \n-                                topicSubs.put(subscriberId, new InMemorySubscriptionState(state));\n+                                topicSubs.put(subscriberId, subData);\n                                 if (count.incrementAndGet() == children.size()) {\n                                     assert topicSubs.size() == count.get();\n                                     cb.operationFinished(ctx, topicSubs);"},{"sha":"41e07a7bbd43e776702ef4954d21740b84171ef5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":92,"deletions":18,"changes":110,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -34,6 +34,8 @@\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protoextensions.MessageIdUtils;\n@@ -124,7 +126,7 @@ public void run() {\n                 for (InMemorySubscriptionState curSubscription : topicSubscriptions.values()) {\n                     if (curSubscription.getSubscriptionState().getMsgId().getLocalComponent() < minConsumedMessage)\n                         minConsumedMessage = curSubscription.getSubscriptionState().getMsgId().getLocalComponent();\n-                    hasBound = hasBound && curSubscription.getSubscriptionState().hasMessageBound();\n+                    hasBound = hasBound && curSubscription.getSubscriptionPreferences().hasMessageBound();\n                 }\n                 boolean callPersistenceManager = true;\n                 // Don't call the PersistenceManager if nobody is subscribed to\n@@ -286,8 +288,7 @@ void updateSubscriptionStates(ByteString topic, Callback<Void> finalCb, Object c\n             for (Entry<ByteString, InMemorySubscriptionState> entry : states.entrySet()) {\n                 InMemorySubscriptionState memState = entry.getValue();\n                 if (memState.setLastConsumeSeqIdImmediately()) {\n-                    updateSubscriptionState(topic, entry.getKey(), memState.getSubscriptionState(),\n-                                            mcb, ctx);\n+                    updateSubscriptionState(topic, entry.getKey(), memState, mcb, ctx);\n                 } else {\n                     mcb.operationFinished(ctx, null);\n                 }\n@@ -332,7 +333,7 @@ public void run() {\n             }\n \n             final ByteString subscriberId = subRequest.getSubscriberId();\n-            InMemorySubscriptionState subscriptionState = topicSubscriptions.get(subscriberId);\n+            final InMemorySubscriptionState subscriptionState = topicSubscriptions.get(subscriberId);\n             CreateOrAttach createOrAttach = subRequest.getCreateOrAttach();\n \n             if (subscriptionState != null) {\n@@ -346,11 +347,41 @@ public void run() {\n                     return;\n                 }\n \n+                // Subscription existed before, check whether new preferences provided\n+                // if new preferences provided, merged the subscription data and updated them\n+                // TODO: needs ACL mechanism when changing preferences\n+                if (subRequest.hasPreferences() &&\n+                    subscriptionState.updatePreferences(subRequest.getPreferences())) {\n+                    updateSubscriptionPreferences(topic, subscriberId, subscriptionState, new Callback<Void>() {\n+                        @Override\n+                        public void operationFailed(Object ctx, PubSubException exception) {\n+                            cb.operationFailed(ctx, exception);\n+                        }\n+\n+                        @Override\n+                        public void operationFinished(Object ctx, Void resultOfOperation) {\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                             + \" attaching to subscription with state: \"\n+                                             + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState())\n+                                             + \", with preferences: \"\n+                                             + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionPreferences()));\n+                            }\n+                            // update message bound if necessary\n+                            updateMessageBound(topic);\n+                            cb.operationFinished(ctx, subscriptionState.getLastConsumeSeqId());\n+                        }\n+                    }, ctx);\n+                    return;\n+                }\n+\n                 // otherwise just attach\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n                                  + \" attaching to subscription with state: \"\n-                                 + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState()));\n+                                 + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState())\n+                                 + \", with preferences: \"\n+                                 + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionPreferences()));\n                 }\n \n                 cb.operationFinished(ctx, subscriptionState.getLastConsumeSeqId());\n@@ -368,12 +399,24 @@ public void run() {\n \n             // now the hard case, this is a brand new subscription, must record\n             SubscriptionState.Builder stateBuilder = SubscriptionState.newBuilder().setMsgId(consumeSeqId);\n+\n+            SubscriptionPreferences.Builder preferencesBuilder;\n+            if (subRequest.hasPreferences()) {\n+                preferencesBuilder = SubscriptionPreferences.newBuilder(subRequest.getPreferences());\n+            } else {\n+                preferencesBuilder = SubscriptionPreferences.newBuilder();\n+            }\n+\n+            // backward compability\n             if (subRequest.hasMessageBound()) {\n-                stateBuilder = stateBuilder.setMessageBound(subRequest.getMessageBound());\n+                preferencesBuilder = preferencesBuilder.setMessageBound(subRequest.getMessageBound());\n             }\n-            final SubscriptionState newState = stateBuilder.build();\n \n-            createSubscriptionState(topic, subscriberId, newState, new Callback<Void>() {\n+            SubscriptionData.Builder subDataBuilder =\n+                SubscriptionData.newBuilder().setState(stateBuilder).setPreferences(preferencesBuilder);\n+            final SubscriptionData subData = subDataBuilder.build();\n+\n+            createSubscriptionData(topic, subscriberId, subData, new Callback<Void>() {\n                 @Override\n                 public void operationFailed(Object ctx, PubSubException exception) {\n                     cb.operationFailed(ctx, exception);\n@@ -388,7 +431,7 @@ public void operationFailed(final Object ctx, final PubSubException exception) {\n                             logger.error(\"subscription for subscriber \" + subscriberId.toStringUtf8() + \" to topic \"\n                                          + topic.toStringUtf8() + \" failed due to failed listener callback\", exception);\n                             // should remove subscription when synchronized cross-region subscription failed\n-                            deleteSubscriptionState(topic, subscriberId, new Callback<Void>() {\n+                            deleteSubscriptionData(topic, subscriberId, new Callback<Void>() {\n                                 @Override\n                                 public void operationFinished(Object context,\n                                         Void resultOfOperation) {\n@@ -418,7 +461,7 @@ private void finish() {\n \n                         @Override\n                         public void operationFinished(Object ctx, Void resultOfOperation) {\n-                            topicSubscriptions.put(subscriberId, new InMemorySubscriptionState(newState));\n+                            topicSubscriptions.put(subscriberId, new InMemorySubscriptionState(subData));\n \n                             updateMessageBound(topic);\n \n@@ -446,11 +489,11 @@ public void updateMessageBound(ByteString topic) {\n         }\n         int maxBound = Integer.MIN_VALUE;\n         for (Map.Entry<ByteString, InMemorySubscriptionState> e : topicSubscriptions.entrySet()) {\n-            if (!e.getValue().getSubscriptionState().hasMessageBound()) {\n+            if (!e.getValue().getSubscriptionPreferences().hasMessageBound()) {\n                 maxBound = Integer.MIN_VALUE;\n                 break;\n             } else {\n-                maxBound = Math.max(maxBound, e.getValue().getSubscriptionState().getMessageBound());\n+                maxBound = Math.max(maxBound, e.getValue().getSubscriptionPreferences().getMessageBound());\n             }\n         }\n         if (maxBound == Integer.MIN_VALUE) {\n@@ -492,7 +535,7 @@ public void run() {\n             }\n \n             if (subState.setLastConsumeSeqId(consumeSeqId, cfg.getConsumeInterval())) {\n-                updateSubscriptionState(topic, subscriberId, subState.getSubscriptionState(), cb, ctx);\n+                updateSubscriptionState(topic, subscriberId, subState, cb, ctx);\n             } else {\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Only advanced consume pointer in memory, will persist later, topic: \"\n@@ -534,7 +577,7 @@ public void run() {\n                 return;\n             }\n \n-            deleteSubscriptionState(topic, subscriberId, new Callback<Void>() {\n+            deleteSubscriptionData(topic, subscriberId, new Callback<Void>() {\n                 @Override\n                 public void operationFailed(Object ctx, PubSubException exception) {\n                     cb.operationFailed(ctx, exception);\n@@ -600,13 +643,44 @@ public void operationFailed(Object ctx,\n         }\n     }\n \n-    protected abstract void createSubscriptionState(final ByteString topic, ByteString subscriberId,\n-            SubscriptionState state, Callback<Void> callback, Object ctx);\n+    private void updateSubscriptionState(ByteString topic, ByteString subscriberId,\n+                                         InMemorySubscriptionState state,\n+                                         Callback<Void> callback, Object ctx) {\n+        SubscriptionData subData;\n+        if (isPartialUpdateSupported()) {\n+            subData = SubscriptionData.newBuilder().setState(state.getSubscriptionState()).build();\n+            updateSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+        } else {\n+            subData = state.toSubscriptionData();\n+            replaceSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+        }\n+    }\n+\n+    private void updateSubscriptionPreferences(ByteString topic, ByteString subscriberId,\n+                                               InMemorySubscriptionState state,\n+                                               Callback<Void> callback, Object ctx) {\n+        SubscriptionData subData;\n+        if (isPartialUpdateSupported()) {\n+            subData = SubscriptionData.newBuilder().setPreferences(state.getSubscriptionPreferences()).build();\n+            updateSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+        } else {\n+            subData = state.toSubscriptionData();\n+            replaceSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+        }\n+    }\n+\n+    protected abstract boolean isPartialUpdateSupported();\n+\n+    protected abstract void createSubscriptionData(final ByteString topic, ByteString subscriberId,\n+            SubscriptionData data, Callback<Void> callback, Object ctx);\n+\n+    protected abstract void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n+            Callback<Void> callback, Object ctx);\n \n-    protected abstract void updateSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n+    protected abstract void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n             Callback<Void> callback, Object ctx);\n \n-    protected abstract void deleteSubscriptionState(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n+    protected abstract void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n             Object ctx);\n \n }"},{"sha":"ed04845d2197e66f1f44a5974e888c928165a16d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","status":"modified","additions":16,"deletions":5,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -22,7 +22,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n \n import com.google.protobuf.ByteString;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n import org.apache.hedwig.server.topics.TopicManager;\n@@ -35,21 +35,32 @@ public InMemorySubscriptionManager(TopicManager tm, PersistenceManager pm, Serve\n     }\n \n     @Override\n-    protected void createSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n+    protected void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData subData,\n                                            Callback<Void> callback, Object ctx) {\n         // nothing to do, in-memory info is already recorded by base class\n         callback.operationFinished(ctx, null);\n     }\n \n     @Override\n-    protected void deleteSubscriptionState(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n-                                           Object ctx) {\n+    protected void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n+                                          Object ctx) {\n         // nothing to do, in-memory info is already deleted by base class\n         callback.operationFinished(ctx, null);\n     }\n \n     @Override\n-    protected void updateSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n+    protected boolean isPartialUpdateSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n+                                          Callback<Void> callback, Object ctx) {\n+        throw new UnsupportedOperationException(\"Doesn't support partial update\");\n+    }\n+\n+    @Override\n+    protected void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n                                            Callback<Void> callback, Object ctx) {\n         // nothing to do, in-memory info is already updated by base class\n         callback.operationFinished(ctx, null);"},{"sha":"85da2c2bbfaf6731395ac3f38af1533395c8465d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"modified","additions":81,"deletions":4,"changes":85,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -17,26 +17,56 @@\n  */\n package org.apache.hedwig.server.subscriptions;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.MapUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n \n public class InMemorySubscriptionState {\n     SubscriptionState subscriptionState;\n+    SubscriptionPreferences subscriptionPreferences;\n     MessageSeqId lastConsumeSeqId;\n \n-    public InMemorySubscriptionState(SubscriptionState subscriptionState, MessageSeqId lastConsumeSeqId) {\n-        this.subscriptionState = subscriptionState;\n+    public InMemorySubscriptionState(SubscriptionData subscriptionData, MessageSeqId lastConsumeSeqId) {\n+        this.subscriptionState = subscriptionData.getState();\n+        if (subscriptionData.hasPreferences()) {\n+            this.subscriptionPreferences = subscriptionData.getPreferences();\n+        } else {\n+            // set initial subscription preferences\n+            SubscriptionPreferences.Builder prefsBuilder = SubscriptionPreferences.newBuilder();\n+            // progate the old system preferences from subscription state to preferences\n+            prefsBuilder.setMessageBound(subscriptionState.getMessageBound());\n+            this.subscriptionPreferences = prefsBuilder.build();\n+\n+        }\n         this.lastConsumeSeqId = lastConsumeSeqId;\n     }\n \n-    public InMemorySubscriptionState(SubscriptionState subscriptionState) {\n-        this(subscriptionState, subscriptionState.getMsgId());\n+    public InMemorySubscriptionState(SubscriptionData subscriptionData) {\n+        this(subscriptionData, subscriptionData.getState().getMsgId());\n+    }\n+\n+    public SubscriptionData toSubscriptionData() {\n+        return SubscriptionData.newBuilder().setState(subscriptionState)\n+                                            .setPreferences(subscriptionPreferences)\n+                                            .build();\n     }\n \n     public SubscriptionState getSubscriptionState() {\n         return subscriptionState;\n     }\n \n+    public SubscriptionPreferences getSubscriptionPreferences() {\n+        return subscriptionPreferences;\n+    }\n+\n     public MessageSeqId getLastConsumeSeqId() {\n         return lastConsumeSeqId;\n     }\n@@ -82,4 +112,51 @@ public boolean setLastConsumeSeqIdImmediately() {\n         return true;\n     }\n \n+    /**\n+     * Update preferences.\n+     *\n+     * @return true if preferences is updated, which needs to be persisted, false otherwise.\n+     */\n+    public boolean updatePreferences(SubscriptionPreferences preferences) {\n+        boolean changed = false;\n+        SubscriptionPreferences.Builder newPreferencesBuilder = SubscriptionPreferences.newBuilder(subscriptionPreferences);\n+        if (preferences.hasMessageBound()) {\n+            if (!subscriptionPreferences.hasMessageBound() ||\n+                subscriptionPreferences.getMessageBound() != preferences.getMessageBound()) {\n+                newPreferencesBuilder.setMessageBound(preferences.getMessageBound());\n+                changed = true;\n+            }\n+        }\n+        if (preferences.hasOptions()) {\n+            Map<String, ByteString> userOptions = SubscriptionStateUtils.buildUserOptions(subscriptionPreferences);\n+            Map<String, ByteString> optUpdates = SubscriptionStateUtils.buildUserOptions(preferences);\n+            boolean optChanged = false;\n+            for (Map.Entry<String, ByteString> entry : optUpdates.entrySet()) {\n+                String key = entry.getKey();\n+                if (userOptions.containsKey(key)) {\n+                    if (null == entry.getValue()) {\n+                        userOptions.remove(key);\n+                        optChanged = true;\n+                    } else {\n+                        if (!entry.getValue().equals(userOptions.get(key))) {\n+                            userOptions.put(key, entry.getValue());\n+                            optChanged = true;\n+                        }\n+                    }\n+                } else {\n+                    userOptions.put(key, entry.getValue());\n+                    optChanged = true;\n+                }\n+            }\n+            if (optChanged) {\n+                changed = true;\n+                newPreferencesBuilder.setOptions(MapUtils.buildMapBuilder(userOptions));\n+            }\n+        }\n+        if (changed) {\n+            subscriptionPreferences = newPreferencesBuilder.build();\n+        }\n+        return changed;\n+    }\n+\n }"},{"sha":"b7e22b5d294af3551960231790cdc35dad1238c7","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","status":"modified","additions":37,"deletions":11,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -19,10 +19,12 @@\n \n import java.io.IOException;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledExecutorService;\n \n import com.google.protobuf.ByteString;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.delivery.DeliveryManager;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n@@ -49,25 +51,49 @@ public MMSubscriptionManager(MetadataManagerFactory metaManagerFactory,\n     @Override\n     protected void readSubscriptions(final ByteString topic,\n                                      final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n-        subManager.readSubscriptions(topic, cb, ctx);\n+        subManager.readSubscriptions(topic, new Callback<Map<ByteString, SubscriptionData>>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException pse) {\n+                cb.operationFailed(ctx, pse);\n+            }\n+            @Override\n+            public void operationFinished(Object ctx, Map<ByteString, SubscriptionData> subs) {\n+                Map<ByteString, InMemorySubscriptionState> results = new ConcurrentHashMap<ByteString, InMemorySubscriptionState>();\n+                for (Map.Entry<ByteString, SubscriptionData> subEntry : subs.entrySet()) {\n+                    results.put(subEntry.getKey(), new InMemorySubscriptionState(subEntry.getValue()));\n+                }\n+                cb.operationFinished(ctx, results);\n+            }\n+        }, ctx);\n     }\n \n     @Override\n-    protected void createSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n-        subManager.createSubscriptionState(topic, subscriberId, state, callback, ctx);\n+    protected boolean isPartialUpdateSupported() {\n+        return subManager.isPartialUpdateSupported();\n     }\n \n     @Override\n-    protected void updateSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n-        subManager.updateSubscriptionState(topic, subscriberId, state, callback, ctx);\n+    protected void createSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                          final SubscriptionData subData, final Callback<Void> callback, final Object ctx) {\n+        subManager.createSubscriptionData(topic, subscriberId, subData, callback, ctx);\n     }\n \n     @Override\n-    protected void deleteSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                           final Callback<Void> callback, final Object ctx) {\n-        subManager.deleteSubscriptionState(topic, subscriberId, callback, ctx);\n+    protected void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                           final SubscriptionData subData, final Callback<Void> callback, final Object ctx) {\n+        subManager.replaceSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+    }\n+\n+    @Override\n+    protected void updateSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                          final SubscriptionData subData, final Callback<Void> callback, final Object ctx) {\n+        subManager.updateSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+    }\n+\n+    @Override\n+    protected void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                          final Callback<Void> callback, final Object ctx) {\n+        subManager.deleteSubscriptionData(topic, subscriberId, callback, ctx);\n     }\n \n     @Override"},{"sha":"5efdbf5f71ab074fc7d1a4b2bed8180c96531417","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","status":"modified","additions":243,"deletions":1,"changes":244,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -43,6 +43,7 @@\n \n     private static Logger logger = LoggerFactory.getLogger(TestBackwardCompat.class);\n \n+    static final int CONSUMEINTERVAL = 5;\n     static ZooKeeperUtil zkUtil = new ZooKeeperUtil();\n \n     static class BookKeeperCluster400 {\n@@ -256,6 +257,10 @@ protected void startBookieServer() throws Exception {\n \n         Server410(final String zkHosts) {\n             conf = new org.apache.hw_v4_1_0.hedwig.server.common.ServerConfiguration() {\n+                @Override\n+                public int getConsumeInterval() {\n+                    return CONSUMEINTERVAL;\n+                }\n                 @Override\n                 public String getZkHost() {\n                     return zkHosts;\n@@ -281,8 +286,52 @@ void stop() throws Exception {\n         org.apache.hw_v4_1_0.hedwig.client.api.Publisher publisher;\n         org.apache.hw_v4_1_0.hedwig.client.api.Subscriber subscriber;\n \n+        class IntMessageHandler implements org.apache.hw_v4_1_0.hedwig.client.api.MessageHandler {\n+            ByteString topic;\n+            ByteString subId;\n+            int next;\n+\n+            CountDownLatch latch;\n+\n+            IntMessageHandler(ByteString t, ByteString s, int start, int num) {\n+                this.topic = t;\n+                this.subId = s;\n+                this.next = start;\n+                this.latch = new CountDownLatch(num);\n+            }\n+\n+            @Override\n+            public void deliver(ByteString t, ByteString s,\n+                                org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message msg,\n+                                org.apache.hw_v4_1_0.hedwig.util.Callback<Void> callback, Object context) {\n+                if (!t.equals(topic) || !s.equals(subId)) {\n+                    return;\n+                }\n+                int num = Integer.parseInt(msg.getBody().toStringUtf8());\n+                if (num == next) {\n+                    latch.countDown();\n+                    ++next;\n+                }\n+                callback.operationFinished(context, null);\n+            }\n+\n+            public boolean await(long timeout, TimeUnit unit)\n+            throws InterruptedException {\n+                return latch.await(timeout, unit);\n+            }\n+        }\n+\n         Client410() {\n-            conf = new org.apache.hw_v4_1_0.hedwig.client.conf.ClientConfiguration();\n+            conf = new org.apache.hw_v4_1_0.hedwig.client.conf.ClientConfiguration() {\n+                @Override\n+                public boolean isAutoSendConsumeMessageEnabled() {\n+                    return true;\n+                }\n+                @Override\n+                public int getConsumedMessagesBufferSize() {\n+                    return 1;\n+                }\n+            };\n             client = new org.apache.hw_v4_1_0.hedwig.client.HedwigClient(conf);\n             publisher = client.getPublisher();\n             subscriber = client.getSubscriber();\n@@ -302,6 +351,79 @@ void close() throws Exception {\n             publisher.publish(topic, message);\n             return null;\n         }\n+\n+        void publishInts(ByteString topic, int start, int num) throws Exception {\n+            for (int i=0; i<num; i++) {\n+                org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message msg =\n+                    org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message.newBuilder().setBody(ByteString.copyFromUtf8(\"\" + (start+i))).build();\n+                publisher.publish(topic, msg);\n+            }\n+        }\n+\n+        void sendXExpectLastY(ByteString topic, ByteString subid, final int x, final int y)\n+        throws Exception {\n+            for (int i=0; i<x; i++) {\n+                publisher.publish(topic, org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message.newBuilder().setBody(\n+                                         ByteString.copyFromUtf8(String.valueOf(i))).build());\n+            }\n+            subscriber.subscribe(topic, subid, org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.ATTACH);\n+\n+            final AtomicInteger expected = new AtomicInteger(x - y);\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            subscriber.startDelivery(topic, subid, new org.apache.hw_v4_1_0.hedwig.client.api.MessageHandler() {\n+                @Override\n+                synchronized public void deliver(ByteString topic, ByteString subscriberId,\n+                                                 org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message msg,\n+                                                 org.apache.hw_v4_1_0.hedwig.util.Callback<Void> callback, Object context) {\n+                    try {\n+                        int value = Integer.valueOf(msg.getBody().toStringUtf8());\n+                        if (value == expected.get()) {\n+                            expected.incrementAndGet();\n+                        } else {\n+                            logger.error(\"Did not receive expected value, expected {}, got {}\",\n+                                         expected.get(), value);\n+                            expected.set(0);\n+                            latch.countDown();\n+                        }\n+                        if (expected.get() == x) {\n+                            latch.countDown();\n+                        }\n+                        callback.operationFinished(context, null);\n+                    } catch (Exception e) {\n+                        logger.error(\"Received bad message\", e);\n+                        latch.countDown();\n+                    }\n+                }\n+            });\n+            assertTrue(\"Timed out waiting for messages Y is \" + y + \" expected is currently \"\n+                       + expected.get(), latch.await(10, TimeUnit.SECONDS));\n+            assertEquals(\"Should be expected message with \" + x, x, expected.get());\n+            subscriber.stopDelivery(topic, subid);\n+            subscriber.closeSubscription(topic, subid);\n+        }\n+\n+        void subscribe(ByteString topic, ByteString subscriberId) throws Exception {\n+            org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions options =\n+                org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions.newBuilder()\n+                .setCreateOrAttach(org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH).build();\n+            subscribe(topic, subscriberId, options);\n+        }\n+\n+        void subscribe(ByteString topic, ByteString subscriberId,\n+                       org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions options) throws Exception {\n+            subscriber.subscribe(topic, subscriberId, options);\n+        }\n+\n+        void closeSubscription(ByteString topic, ByteString subscriberId) throws Exception {\n+            subscriber.closeSubscription(topic, subscriberId);\n+        }\n+\n+        void receiveInts(ByteString topic, ByteString subscriberId, int start, int num) throws Exception {\n+            IntMessageHandler msgHandler = new IntMessageHandler(topic, subscriberId, start, num);\n+            subscriber.startDelivery(topic, subscriberId, msgHandler);\n+            msgHandler.await(num, TimeUnit.SECONDS);\n+            subscriber.stopDelivery(topic, subscriberId);\n+        }\n     }\n \n     /**\n@@ -386,6 +508,11 @@ protected void startBookieServer() throws Exception {\n \n         ServerCurrent(final String zkHosts) {\n             conf = new org.apache.hedwig.server.common.ServerConfiguration() {\n+                @Override\n+                public int getConsumeInterval() {\n+                    return CONSUMEINTERVAL;\n+                }\n+\n                 @Override\n                 public String getZkHost() {\n                     return zkHosts;\n@@ -676,4 +803,119 @@ public void testPublishCompat410() throws Exception {\n         bkc410.stop();\n     }\n \n+    /**\n+     * Test compatability between version 4.1.0 and the current version.\n+     *\n+     * A current server could read subscription data recorded by 4.1.0 server.\n+     */\n+    @Test\n+    public void testSubscriptionDataCompat410() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"TestCompat410\");\n+        ByteString sub410 = ByteString.copyFromUtf8(\"sub410\");\n+        ByteString subcur = ByteString.copyFromUtf8(\"subcur\");\n+\n+        // start bookkeeper 410\n+        BookKeeperCluster410 bkc410 = new BookKeeperCluster410(3);\n+        bkc410.start();\n+\n+        // start 410 server\n+        Server410 s410 = new Server410(zkUtil.getZooKeeperConnectString());\n+        s410.start();\n+\n+        Client410 c410 = new Client410();\n+        c410.subscribe(topic, sub410);\n+        c410.closeSubscription(topic, sub410);\n+\n+        ClientCurrent ccur = new ClientCurrent();\n+        ccur.subscribe(topic, subcur);\n+        ccur.closeSubscription(topic, subcur);\n+\n+        // publish messages using old client\n+        c410.publishInts(topic, 0, 10);\n+        // stop 410 server\n+        s410.stop();\n+\n+        // start current server\n+        ServerCurrent scur = new ServerCurrent(zkUtil.getZooKeeperConnectString());\n+        scur.start();\n+\n+        c410.subscribe(topic, sub410);\n+        c410.receiveInts(topic, sub410, 0, 10);\n+\n+        ccur.subscribe(topic, subcur);\n+        ccur.receiveInts(topic, subcur, 0, 10);\n+\n+        // publish messages using current client\n+        ccur.publishInts(topic, 10, 10);\n+\n+        c410.receiveInts(topic, sub410, 10, 10);\n+        ccur.receiveInts(topic, subcur, 10, 10);\n+\n+        // stop current server\n+        scur.stop();\n+\n+        c410.close();\n+        ccur.close();\n+\n+        // stop bookkeeper cluster\n+        bkc410.stop();\n+    }\n+\n+    /**\n+     * Test compatability between version 4.1.0 and the current version.\n+     *\n+     * A 4.1.0 client could not update message bound, while current could do it.\n+     */\n+    @Test\n+    public void testUpdateMessageBoundCompat410() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"TestUpdateMessageBoundCompat410\");\n+        ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n+\n+        // start bookkeeper\n+        BookKeeperClusterCurrent bkccur= new BookKeeperClusterCurrent(3);\n+        bkccur.start();\n+\n+        // start hub server\n+        ServerCurrent scur = new ServerCurrent(zkUtil.getZooKeeperConnectString());\n+        scur.start();\n+\n+        org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions options5cur =\n+            org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH)\n+            .setMessageBound(5).build();\n+        org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions options5v410 =\n+            org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH)\n+            .setMessageBound(5).build();\n+        org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions options20v410 =\n+            org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH)\n+            .setMessageBound(20).build();\n+\n+        Client410 c410 = new Client410();\n+        c410.subscribe(topic, subid, options20v410);\n+        c410.closeSubscription(topic, subid);\n+        c410.sendXExpectLastY(topic, subid, 50, 20);\n+\n+        c410.subscribe(topic, subid, options5v410);\n+        c410.closeSubscription(topic, subid);\n+        // the message bound isn't updated.\n+        c410.sendXExpectLastY(topic, subid, 50, 20);\n+\n+        ClientCurrent ccur = new ClientCurrent();\n+        ccur.subscribe(topic, subid, options5cur);\n+        ccur.closeSubscription(topic, subid);\n+        // the message bound should be updated.\n+        c410.sendXExpectLastY(topic, subid, 50, 5);\n+\n+        // stop current server\n+        scur.stop();\n+\n+        c410.close();\n+        ccur.close();\n+\n+        // stop bookkeeper cluster\n+        bkccur.stop();\n+    }\n+\n }"},{"sha":"d64024568879c50ac9fd51f7c40331351b9b5c65","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","status":"modified","additions":35,"deletions":24,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -32,8 +32,8 @@\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n-import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.util.Either;\n@@ -228,36 +228,41 @@ public void testPersistenceInfo() throws Exception {\n     }\n \n     @Test\n-    public void testSubscriptionState() throws Exception {\n+    public void testSubscriptionData() throws Exception {\n         SubscriptionDataManager subManager = metadataManagerFactory.newSubscriptionDataManager();\n \n-        ByteString topic = ByteString.copyFromUtf8(\"testSubscriptionState\");\n+        ByteString topic = ByteString.copyFromUtf8(\"testSubscriptionData\");\n         ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n \n         StubCallback<Void> callback = new StubCallback<Void>();\n-        StubCallback<SubscriptionState> readCallback = new StubCallback<SubscriptionState>();\n-        StubCallback<Map<ByteString, InMemorySubscriptionState>> subsCallback\n-            = new StubCallback<Map<ByteString, InMemorySubscriptionState>>();\n+        StubCallback<SubscriptionData> readCallback = new StubCallback<SubscriptionData>();\n+        StubCallback<Map<ByteString, SubscriptionData>> subsCallback\n+            = new StubCallback<Map<ByteString, SubscriptionData>>();\n \n-        subManager.readSubscriptionState(topic, subid, readCallback, null);\n-        Either<SubscriptionState, PubSubException> readRes = readCallback.queue.take();\n+        subManager.readSubscriptionData(topic, subid, readCallback, null);\n+        Either<SubscriptionData, PubSubException> readRes = readCallback.queue.take();\n         Assert.assertEquals(\"Found inconsistent subscription state\", null, readRes.left());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, readRes.right());\n \n         // read non-existed subscription state\n         subManager.readSubscriptions(topic, subsCallback, null);\n-        Either<Map<ByteString, InMemorySubscriptionState>, PubSubException> res = subsCallback.queue.take();\n+        Either<Map<ByteString, SubscriptionData>, PubSubException> res = subsCallback.queue.take();\n         Assert.assertEquals(\"Found more than 0 subscribers\", 0, res.left().size());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n \n         // update non-existed subscription state\n-        subManager.updateSubscriptionState(topic, subid, SubscriptionState.getDefaultInstance(),\n-                                            callback, null);\n+        if (subManager.isPartialUpdateSupported()) {\n+            subManager.updateSubscriptionData(topic, subid, SubscriptionData.getDefaultInstance(),\n+                                              callback, null);\n+        } else {\n+            subManager.replaceSubscriptionData(topic, subid, SubscriptionData.getDefaultInstance(),\n+                                               callback, null);\n+        }\n         Assert.assertTrue(\"Should fail to update a non-existed subscriber with PubSubException\",\n                           callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);\n \n         // delete non-existed subscription state\n-        subManager.deleteSubscriptionState(topic, subid, callback, null);\n+        subManager.deleteSubscriptionData(topic, subid, callback, null);\n         Assert.assertTrue(\"Should fail to delete a non-existed subscriber with PubSubException\",\n                           callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);\n \n@@ -266,10 +271,11 @@ public void testSubscriptionState() throws Exception {\n         builder.setLocalComponent(seqId);\n         MessageSeqId msgId = builder.build();\n \n-        SubscriptionState state = SubscriptionState.newBuilder(SubscriptionState.getDefaultInstance()).setMsgId(msgId).build();\n+        SubscriptionState.Builder stateBuilder = SubscriptionState.newBuilder(SubscriptionState.getDefaultInstance()).setMsgId(msgId);\n+        SubscriptionData data = SubscriptionData.newBuilder().setState(stateBuilder).build();\n \n         // create a subscription state\n-        subManager.createSubscriptionState(topic, subid, state, callback, null);\n+        subManager.createSubscriptionData(topic, subid, data, callback, null);\n         Assert.assertEquals(\"Should not fail with PubSubException\",\n                             null, callback.queue.take().right());\n \n@@ -278,28 +284,33 @@ public void testSubscriptionState() throws Exception {\n         res = subsCallback.queue.take();\n         Assert.assertEquals(\"Should find just 1 subscriber\", 1, res.left().size());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n-        InMemorySubscriptionState imss = res.left().get(subid);\n+        SubscriptionData imss = res.left().get(subid);\n         Assert.assertEquals(\"Found inconsistent subscription state\",\n-                            state, imss.getSubscriptionState());\n+                            data, imss);\n         Assert.assertEquals(\"Found inconsistent last consumed seq id\",\n-                            seqId, imss.getLastConsumeSeqId().getLocalComponent());\n+                            seqId, imss.getState().getMsgId().getLocalComponent());\n \n         // move consume seq id\n         seqId = 99;\n         builder = MessageSeqId.newBuilder();\n         builder.setLocalComponent(seqId);\n         msgId = builder.build();\n \n-        state = SubscriptionState.newBuilder(state).setMsgId(msgId).build();\n+        stateBuilder = SubscriptionState.newBuilder(data.getState()).setMsgId(msgId);\n+        data = SubscriptionData.newBuilder().setState(stateBuilder).build();\n \n         // update subscription state\n-        subManager.updateSubscriptionState(topic, subid, state, callback, null);\n+        if (subManager.isPartialUpdateSupported()) {\n+            subManager.updateSubscriptionData(topic, subid, data, callback, null);\n+        } else {\n+            subManager.replaceSubscriptionData(topic, subid, data, callback, null);\n+        }\n         Assert.assertEquals(\"Fail to update a subscription state\", null, callback.queue.take().right());\n \n         // read subscription state\n-        subManager.readSubscriptionState(topic, subid, readCallback, null);\n+        subManager.readSubscriptionData(topic, subid, readCallback, null);\n         Assert.assertEquals(\"Found inconsistent subscription state\",\n-                            state, readCallback.queue.take().left());\n+                            data, readCallback.queue.take().left());\n \n         // read subscriptions again\n         subManager.readSubscriptions(topic, subsCallback, null);\n@@ -308,11 +319,11 @@ public void testSubscriptionState() throws Exception {\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n         imss = res.left().get(subid);\n         Assert.assertEquals(\"Found inconsistent subscription state\",\n-                            state, imss.getSubscriptionState());\n+                            data, imss);\n         Assert.assertEquals(\"Found inconsistent last consumed seq id\",\n-                            seqId, imss.getLastConsumeSeqId().getLocalComponent());\n+                            seqId, imss.getState().getMsgId().getLocalComponent());\n \n-        subManager.deleteSubscriptionState(topic, subid, callback, null);\n+        subManager.deleteSubscriptionData(topic, subid, callback, null);\n         Assert.assertEquals(\"Fail to delete an existed subscriber\", null, callback.queue.take().right());\n \n         // read subscription states again"},{"sha":"03b40f3df2d8f3976c7ce03aa0bcc3d1d43e79ee","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","status":"modified","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java?ref=14e23b6d9cf4015cd76c7ed3d5258bfbcbb05ef8","patch":"@@ -190,6 +190,45 @@ public void testMultipleSubscribers() throws Exception {\n         client.close();\n     }\n \n+    @Test\n+    public void testUpdateMessageBound() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"UpdateMessageBound\");\n+\n+        Client client = new HedwigClient(new ClientConfiguration());\n+        Publisher pub = client.getPublisher();\n+        Subscriber sub = client.getSubscriber();\n+\n+        SubscriptionOptions options5 = SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setMessageBound(5).build();\n+        SubscriptionOptions options20 = SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setMessageBound(20).build();\n+        SubscriptionOptions options10 = SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setMessageBound(10).build();\n+\n+        ByteString subid = ByteString.copyFromUtf8(\"updateSubId\");\n+\n+        sub.subscribe(topic, subid, options5);\n+        sub.closeSubscription(topic, subid);\n+        sendXExpectLastY(pub, sub, topic, subid, 50, 5);\n+\n+        // update bound to 20\n+        sub.subscribe(topic, subid, options20);\n+        sub.closeSubscription(topic, subid);\n+        sendXExpectLastY(pub, sub, topic, subid, 50, 20);\n+\n+        // update bound to 10\n+        sub.subscribe(topic, subid, options10);\n+        sub.closeSubscription(topic, subid);\n+        sendXExpectLastY(pub, sub, topic, subid, 50, 10);\n+\n+        // message bound is not provided, no update\n+        sub.subscribe(topic, subid, CreateOrAttach.CREATE_OR_ATTACH);\n+        sub.closeSubscription(topic, subid);\n+        sendXExpectLastY(pub, sub, topic, subid, 50, 10);\n+\n+        client.close();\n+    }\n+\n     @Test\n     public void testLedgerGC() throws Exception {\n         Client client = new HedwigClient(new MessageBoundClientConfiguration());"}]}

