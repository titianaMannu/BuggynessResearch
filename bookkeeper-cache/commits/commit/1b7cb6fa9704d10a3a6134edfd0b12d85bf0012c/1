{"sha":"1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxYjdjYjZmYTk3MDRkMTBhM2E2MTM0ZWRmZDBiMTJkODViZjAwMTJj","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-03-17T23:31:20Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-03-17T23:31:20Z"},"message":"BOOKKEEPER-576: Bookie client should use netty Decoder/Encoder (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1457592 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7b2b5b24272412c8f67e6ae6d9243b5517e4a888","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7b2b5b24272412c8f67e6ae6d9243b5517e4a888"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","html_url":"https://github.com/apache/bookkeeper/commit/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"94ea9a8629ce404566d875895208dabe82c99fbe","url":"https://api.github.com/repos/apache/bookkeeper/commits/94ea9a8629ce404566d875895208dabe82c99fbe","html_url":"https://github.com/apache/bookkeeper/commit/94ea9a8629ce404566d875895208dabe82c99fbe"}],"stats":{"total":382,"additions":218,"deletions":164},"files":[{"sha":"8bd53610245fe2a53e4285fe5c24847976049a76","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -44,6 +44,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-574: Extend the bookkeeper shell to get a list of available bookies (ivank via umamahesh)\n \n+      BOOKKEEPER-576: Bookie client should use netty Decoder/Encoder (ivank via sijie)\n+\n Release 4.2.0 - 2013-01-14\n \n   Non-backward compatible changes:"},{"sha":"301fa1d1a881114ee302eea3d22c55d7d36b7172","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -141,8 +141,8 @@ public ChannelPipeline getPipeline() throws Exception {\n                              new LengthFieldBasedFrameDecoder(maxMessageSize, 0, 4, 0, 4));\n             pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n \n-            pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.Decoder());\n-            pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.Encoder());\n+            pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.RequestDecoder());\n+            pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.ResponseEncoder());\n             pipeline.addLast(\"bookieRequestHandler\", new BookieRequestHandler(conf, bookie,\n                                                                               allChannels));\n             return pipeline;"},{"sha":"2644f6b00c66218e21cf3d94806e79613e16d635","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"modified","additions":85,"deletions":9,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -35,7 +35,45 @@\n public class BookieProtoEncoding {\n     static Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n \n-    public static class Decoder extends OneToOneDecoder {\n+    public static class RequestEncoder extends OneToOneEncoder {\n+        @Override\n+        public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (!(msg instanceof BookieProtocol.Request)) {\n+                return msg;\n+            }\n+            BookieProtocol.Request r = (BookieProtocol.Request)msg;\n+            if (r instanceof BookieProtocol.AddRequest) {\n+                BookieProtocol.AddRequest ar = (BookieProtocol.AddRequest)r;\n+                int totalHeaderSize = 4 // for the header\n+                    + BookieProtocol.MASTER_KEY_LENGTH; // for the master key\n+                ChannelBuffer buf = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+                buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n+                buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);\n+                return ChannelBuffers.wrappedBuffer(buf, ar.getData());\n+            } else {\n+                assert(r instanceof BookieProtocol.ReadRequest);\n+                int totalHeaderSize = 4 // for request type\n+                    + 8 // for ledgerId\n+                    + 8; // for entryId\n+                if (r.hasMasterKey()) {\n+                    totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;\n+                }\n+\n+                ChannelBuffer buf = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+                buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n+                buf.writeLong(r.getLedgerId());\n+                buf.writeLong(r.getEntryId());\n+                if (r.hasMasterKey()) {\n+                    buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);\n+                }\n+\n+                return buf;\n+            }\n+        }\n+    }\n+\n+    public static class RequestDecoder extends OneToOneDecoder {\n         @Override\n         public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 throws Exception {\n@@ -61,11 +99,11 @@ public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n \n                 ChannelBuffer bb = packet.duplicate();\n+\n                 ledgerId = bb.readLong();\n                 entryId = bb.readLong();\n-\n                 return new BookieProtocol.AddRequest(h.getVersion(), ledgerId, entryId,\n-                        flags, masterKey, packet.toByteBuffer().slice());\n+                        flags, masterKey, packet.slice());\n             case BookieProtocol.READENTRY:\n                 ledgerId = packet.readLong();\n                 entryId = packet.readLong();\n@@ -83,7 +121,7 @@ public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n         }\n     }\n \n-    public static class Encoder extends OneToOneEncoder {\n+    public static class ResponseEncoder extends OneToOneEncoder {\n         @Override\n         public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 throws Exception {\n@@ -100,13 +138,15 @@ public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n             buf.writeLong(r.getEntryId());\n \n             ServerStats.getInstance().incrementPacketsSent();\n-\n             if (msg instanceof BookieProtocol.ReadResponse) {\n                 BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse)r;\n-                return ChannelBuffers.wrappedBuffer(buf,\n-                        ChannelBuffers.wrappedBuffer(rr.getData()));\n-            } else if ((msg instanceof BookieProtocol.AddResponse)\n-                       || (msg instanceof BookieProtocol.ErrorResponse)) {\n+                if (rr.hasData()) {\n+                    return ChannelBuffers.wrappedBuffer(buf,\n+                            ChannelBuffers.wrappedBuffer(rr.getData()));\n+                } else {\n+                    return buf;\n+                }\n+            } else if (msg instanceof BookieProtocol.AddResponse) {\n                 return buf;\n             } else {\n                 LOG.error(\"Cannot encode unknown response type {}\", msg.getClass().getName());\n@@ -115,4 +155,40 @@ public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n         }\n     }\n \n+    public static class ResponseDecoder extends OneToOneDecoder {\n+        @Override\n+        public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (!(msg instanceof ChannelBuffer)) {\n+                return msg;\n+            }\n+\n+            final ChannelBuffer buffer = (ChannelBuffer)msg;\n+            final int rc;\n+            final long ledgerId, entryId;\n+            final PacketHeader header;\n+\n+            header = PacketHeader.fromInt(buffer.readInt());\n+            rc = buffer.readInt();\n+            ledgerId = buffer.readLong();\n+            entryId = buffer.readLong();\n+\n+            switch (header.getOpCode()) {\n+            case BookieProtocol.ADDENTRY:\n+                return new BookieProtocol.AddResponse(header.getVersion(), rc, ledgerId, entryId);\n+            case BookieProtocol.READENTRY:\n+                if (rc == BookieProtocol.EOK) {\n+                    return new BookieProtocol.ReadResponse(header.getVersion(), rc,\n+                                                           ledgerId, entryId, buffer.slice());\n+                } else {\n+                    return new BookieProtocol.ReadResponse(header.getVersion(), rc,\n+                                                           ledgerId, entryId);\n+                }\n+            default:\n+                LOG.error(\"Unexpected response of type {} received from {}\",\n+                          header.getOpCode(), channel.getRemoteAddress());\n+                return msg;\n+            }\n+        }\n+    }\n }"},{"sha":"4dd26d6e6776a2c505da7d8bf0fff6056ff7b863","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":29,"deletions":17,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -21,6 +21,7 @@\n  *\n  */\n \n+import org.jboss.netty.buffer.ChannelBuffer;\n import java.nio.ByteBuffer;\n \n /**\n@@ -216,6 +217,10 @@ long getEntryId() {\n             return entryId;\n         }\n \n+        short getFlags() {\n+            return flags;\n+        }\n+\n         boolean hasMasterKey() {\n             return masterKey != null;\n         }\n@@ -232,18 +237,22 @@ public String toString() {\n     }\n \n     static class AddRequest extends Request {\n-        final ByteBuffer data;\n+        final ChannelBuffer data;\n \n         AddRequest(byte protocolVersion, long ledgerId, long entryId,\n-                   short flags, byte[] masterKey, ByteBuffer data) {\n+                   short flags, byte[] masterKey, ChannelBuffer data) {\n             super(protocolVersion, ADDENTRY, ledgerId, entryId, flags, masterKey);\n             this.data = data;\n         }\n \n-        ByteBuffer getData() {\n+        ChannelBuffer getData() {\n             return data;\n         }\n \n+        ByteBuffer getDataAsByteBuffer() {\n+            return data.toByteBuffer().slice();\n+        }\n+\n         boolean isRecoveryAdd() {\n             return (flags & FLAG_RECOVERY_ADD) == FLAG_RECOVERY_ADD;\n         }\n@@ -302,33 +311,36 @@ int getErrorCode() {\n \n         @Override\n         public String toString() {\n-            return String.format(\"Op(%d)[Ledger:%d,Entry:%d]\", opCode, ledgerId, entryId);\n+            return String.format(\"Op(%d)[Ledger:%d,Entry:%d,errorCode=%d]\",\n+                                 opCode, ledgerId, entryId, errorCode);\n         }\n     }\n \n     static class ReadResponse extends Response {\n-        final ByteBuffer data;\n+        final ChannelBuffer data;\n \n-        ReadResponse(byte protocolVersion, long ledgerId, long entryId, ByteBuffer data) {\n-            super(protocolVersion, READENTRY, EOK, ledgerId, entryId);\n+        ReadResponse(byte protocolVersion, int errorCode, long ledgerId, long entryId) {\n+            super(protocolVersion, READENTRY, errorCode, ledgerId, entryId);\n+            this.data = null;\n+        }\n+\n+        ReadResponse(byte protocolVersion, int errorCode, long ledgerId, long entryId, ChannelBuffer data) {\n+            super(protocolVersion, READENTRY, errorCode, ledgerId, entryId);\n             this.data = data;\n         }\n \n-        ByteBuffer getData() {\n-            return data;\n+        boolean hasData() {\n+            return data != null;\n         }\n-    }\n \n-    static class AddResponse extends Response {\n-        AddResponse(byte protocolVersion, long ledgerId, long entryId) {\n-            super(protocolVersion, ADDENTRY, EOK, ledgerId, entryId);\n+        ChannelBuffer getData() {\n+            return data;\n         }\n     }\n \n-    static class ErrorResponse extends Response {\n-        ErrorResponse(byte protocolVersion, byte opCode, int errorCode,\n-                      long ledgerId, long entryId) {\n-            super(protocolVersion, opCode, errorCode, ledgerId, entryId);\n+    static class AddResponse extends Response {\n+        AddResponse(byte protocolVersion, int errorCode, long ledgerId, long entryId) {\n+            super(protocolVersion, ADDENTRY, errorCode, ledgerId, entryId);\n         }\n     }\n }"},{"sha":"791ddc612ef30f3c57fcab4f5ac404dcf688dd53","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -159,10 +159,11 @@ private void handleAdd(BookieProtocol.Request r, Channel c) {\n         int rc = BookieProtocol.EOK;\n         try {\n             if (add.isRecoveryAdd()) {\n-                bookie.recoveryAddEntry(add.getData(), this, new AddCtx(c, add),\n+                bookie.recoveryAddEntry(add.getDataAsByteBuffer(), this, new AddCtx(c, add),\n                                         add.getMasterKey());\n             } else {\n-                bookie.addEntry(add.getData(), this, new AddCtx(c, add), add.getMasterKey());\n+                bookie.addEntry(add.getDataAsByteBuffer(),\n+                                this, new AddCtx(c, add), add.getMasterKey());\n             }\n         } catch (IOException e) {\n             LOG.error(\"Error writing \" + add, e);"},{"sha":"5876ed79084cb9a8a4e70c31e1e04eadce4f7e28","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":79,"deletions":112,"changes":191,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -52,6 +52,7 @@\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.handler.codec.frame.CorruptedFrameException;\n import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n+import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n import org.jboss.netty.handler.timeout.ReadTimeoutException;\n import org.jboss.netty.handler.timeout.ReadTimeoutHandler;\n@@ -227,27 +228,13 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n+        BookieProtocol.AddRequest r = new BookieProtocol.AddRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                ledgerId, entryId, (short)options, masterKey, toSend);\n         final int entrySize = toSend.readableBytes();\n-\n         final CompletionKey completionKey = new CompletionKey(ledgerId, entryId);\n-\n         addCompletions.put(completionKey, new AddCompletion(cb, entrySize, ctx));\n-\n-        int totalHeaderSize = 4 // for the length of the packet\n-                              + 4 // for the type of request\n-                              + BookieProtocol.MASTER_KEY_LENGTH; // for the master key\n-\n-        try{\n-            ChannelBuffer header = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n-\n-            header.writeInt(totalHeaderSize - 4 + entrySize);\n-            header.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                                             BookieProtocol.ADDENTRY, (short)options).toInt());\n-            header.writeBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n-\n-            ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer(header, toSend);\n-\n-            ChannelFuture future = channel.write(wrappedBuffer);\n+        try {\n+            ChannelFuture future = channel.write(r);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n@@ -274,72 +261,56 @@ public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n         final CompletionKey key = new CompletionKey(ledgerId, entryId);\n         readCompletions.put(key, new ReadCompletion(cb, ctx));\n \n-        int totalHeaderSize = 4 // for the length of the packet\n-                              + 4 // for request type\n-                              + 8 // for ledgerId\n-                              + 8 // for entryId\n-                              + BookieProtocol.MASTER_KEY_LENGTH; // for masterKey\n+        final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n+                BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n+                BookieProtocol.FLAG_DO_FENCING, masterKey);\n \n-        ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n-        tmpEntry.writeInt(totalHeaderSize - 4);\n-\n-        tmpEntry.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                                           BookieProtocol.READENTRY,\n-                                           BookieProtocol.FLAG_DO_FENCING).toInt());\n-        tmpEntry.writeLong(ledgerId);\n-        tmpEntry.writeLong(entryId);\n-        tmpEntry.writeBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n-\n-        ChannelFuture future = channel.write(tmpEntry);\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (future.isSuccess()) {\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"Successfully wrote request for reading entry: \" + entryId + \" ledger-id: \"\n-                                  + ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+        try {\n+            ChannelFuture future = channel.write(r);\n+            future.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture future) throws Exception {\n+                        if (future.isSuccess()) {\n+                            if (LOG.isDebugEnabled()) {\n+                                LOG.debug(\"Successfully wrote request {} to {}\",\n+                                          r, channel.getRemoteAddress());\n+                            }\n+                        } else {\n+                            errorOutReadKey(key);\n+                        }\n                     }\n-                } else {\n-                    errorOutReadKey(key);\n-                }\n-            }\n-        });\n+                });\n+        } catch(Throwable e) {\n+            LOG.warn(\"Read entry operation \" + r + \" failed\", e);\n+            errorOutReadKey(key);\n+        }\n     }\n \n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n         final CompletionKey key = new CompletionKey(ledgerId, entryId);\n         readCompletions.put(key, new ReadCompletion(cb, ctx));\n \n-        int totalHeaderSize = 4 // for the length of the packet\n-                              + 4 // for request type\n-                              + 8 // for ledgerId\n-                              + 8; // for entryId\n+        final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n+                BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n+                BookieProtocol.FLAG_NONE);\n \n         try{\n-            ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n-            tmpEntry.writeInt(totalHeaderSize - 4);\n-\n-            tmpEntry.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                                               BookieProtocol.READENTRY, BookieProtocol.FLAG_NONE).toInt());\n-            tmpEntry.writeLong(ledgerId);\n-            tmpEntry.writeLong(entryId);\n-\n-            ChannelFuture future = channel.write(tmpEntry);\n+            ChannelFuture future = channel.write(r);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         if (LOG.isDebugEnabled()) {\n-                            LOG.debug(\"Successfully wrote request for reading entry: \" + entryId + \" ledger-id: \"\n-                                                            + ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+                            LOG.debug(\"Successfully wrote request {} to {}\",\n+                                      r, channel.getRemoteAddress());\n                         }\n                     } else {\n                         errorOutReadKey(key);\n                     }\n                 }\n             });\n         } catch(Throwable e) {\n-            LOG.warn(\"Read entry operation failed\", e);\n+            LOG.warn(\"Read entry operation \" + r + \" failed\", e);\n             errorOutReadKey(key);\n         }\n     }\n@@ -460,6 +431,11 @@ public ChannelPipeline getPipeline() throws Exception {\n         pipeline.addLast(\"readTimeout\", new ReadTimeoutHandler(readTimeoutTimer, \n                                                                conf.getReadTimeout()));\n         pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));\n+        pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+        pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder());\n+        pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.ResponseDecoder());\n+\n+\n         pipeline.addLast(\"mainhandler\", this);\n         return pipeline;\n     }\n@@ -527,54 +503,41 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n      */\n     @Override\n     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-        if (!(e.getMessage() instanceof ChannelBuffer)) {\n+        if (!(e.getMessage() instanceof BookieProtocol.Response)) {\n             ctx.sendUpstream(e);\n             return;\n         }\n+        final BookieProtocol.Response r = (BookieProtocol.Response)e.getMessage();\n \n-        final ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n-        final int rc;\n-        final long ledgerId, entryId;\n-        final PacketHeader header;\n-\n-        try {\n-            header = PacketHeader.fromInt(buffer.readInt());\n-            rc = buffer.readInt();\n-            ledgerId = buffer.readLong();\n-            entryId = buffer.readLong();\n-        } catch (IndexOutOfBoundsException ex) {\n-            LOG.error(\"Unparseable response from bookie: \" + addr, ex);\n-            return;\n-        }\n-\n-        executor.submitOrdered(ledgerId, new SafeRunnable() {\n+        executor.submitOrdered(r.getLedgerId(), new SafeRunnable() {\n             @Override\n             public void safeRun() {\n-                switch (header.getOpCode()) {\n+                switch (r.getOpCode()) {\n                 case BookieProtocol.ADDENTRY:\n-                    handleAddResponse(ledgerId, entryId, rc);\n+                    BookieProtocol.AddResponse a = (BookieProtocol.AddResponse)r;\n+                    handleAddResponse(a);\n                     break;\n                 case BookieProtocol.READENTRY:\n-                    handleReadResponse(ledgerId, entryId, rc, buffer);\n+                    BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse)r;\n+                    handleReadResponse(rr);\n                     break;\n                 default:\n-                    LOG.error(\"Unexpected response, type: \" + header.getOpCode() \n-                              + \" received from bookie: \" + addr + \" , ignoring\");\n+                    LOG.error(\"Unexpected response, type: {}\", r);\n                 }\n             }\n         });\n     }\n \n-    void handleAddResponse(long ledgerId, long entryId, int rc) {\n+    void handleAddResponse(BookieProtocol.AddResponse a) {\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n-                      + entryId + \" rc: \" + rc);\n+            LOG.debug(\"Got response for add request from bookie: {} for ledger: {}\", addr, a);\n         }\n \n         // convert to BKException code because thats what the uppper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n-        switch (rc) {\n+        int rc = BKException.Code.WriteException;\n+        switch (a.getErrorCode()) {\n         case BookieProtocol.EOK:\n             rc = BKException.Code.OK;\n             break;\n@@ -591,50 +554,53 @@ void handleAddResponse(long ledgerId, long entryId, int rc) {\n             rc = BKException.Code.WriteOnReadOnlyBookieException;\n             break;\n         default:\n-            LOG.error(\"Add for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n-                      + \" with code: \" + rc);\n+            LOG.error(\"Add failed {}\", a);\n             rc = BKException.Code.WriteException;\n             break;\n         }\n \n         AddCompletion ac;\n-        ac = addCompletions.remove(new CompletionKey(ledgerId, entryId));\n+        ac = addCompletions.remove(new CompletionKey(a.getLedgerId(),\n+                                                     a.getEntryId()));\n         if (ac == null) {\n-            LOG.error(\"Unexpected add response received from bookie: \" + addr + \" for ledger: \" + ledgerId\n-                      + \", entry: \" + entryId + \" , ignoring\");\n+            LOG.error(\"Unexpected add response from bookie {} for {}\", addr, a);\n             return;\n         }\n \n-        // totalBytesOutstanding.addAndGet(-ac.size);\n-\n-        ac.cb.writeComplete(rc, ledgerId, entryId, addr, ac.ctx);\n-\n+        ac.cb.writeComplete(rc, a.getLedgerId(), a.getEntryId(), addr, ac.ctx);\n     }\n \n-    void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffer) {\n+    void handleReadResponse(BookieProtocol.ReadResponse rr) {\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n-                      + entryId + \" rc: \" + rc + \" entry length: \" + buffer.readableBytes());\n+            LOG.debug(\"Got response for read request {} entry length: {}\",\n+                      rr, rr.getData().readableBytes());\n         }\n \n         // convert to BKException code because thats what the uppper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n-        if (rc == BookieProtocol.EOK) {\n+        int rc = BKException.Code.ReadException;\n+        switch (rr.getErrorCode()) {\n+        case BookieProtocol.EOK:\n             rc = BKException.Code.OK;\n-        } else if (rc == BookieProtocol.ENOENTRY || rc == BookieProtocol.ENOLEDGER) {\n+            break;\n+        case BookieProtocol.ENOENTRY:\n+        case BookieProtocol.ENOLEDGER:\n             rc = BKException.Code.NoSuchEntryException;\n-        } else if (rc == BookieProtocol.EBADVERSION) {\n+            break;\n+        case BookieProtocol.EBADVERSION:\n             rc = BKException.Code.ProtocolVersionException;\n-        } else if (rc == BookieProtocol.EUA) {\n+            break;\n+        case BookieProtocol.EUA:\n             rc = BKException.Code.UnauthorizedAccessException;\n-        } else {\n-            LOG.error(\"Read for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n-                      + \" with code: \" + rc);\n+            break;\n+        default:\n+            LOG.error(\"Read error for {}\", rr);\n             rc = BKException.Code.ReadException;\n+            break;\n         }\n \n-        CompletionKey key = new CompletionKey(ledgerId, entryId);\n+        CompletionKey key = new CompletionKey(rr.getLedgerId(), rr.getEntryId());\n         ReadCompletion readCompletion = readCompletions.remove(key);\n \n         if (readCompletion == null) {\n@@ -644,16 +610,17 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n              * different entry id.\n              */\n             \n-            readCompletion = readCompletions.remove(new CompletionKey(ledgerId, BookieProtocol.LAST_ADD_CONFIRMED));\n+            readCompletion = readCompletions.remove(new CompletionKey(rr.getLedgerId(),\n+                                                                      BookieProtocol.LAST_ADD_CONFIRMED));\n         }\n \n         if (readCompletion == null) {\n-            LOG.error(\"Unexpected read response received from bookie: \" + addr + \" for ledger: \" + ledgerId\n-                      + \", entry: \" + entryId + \" , ignoring\");\n+            LOG.error(\"Unexpected read response received from bookie: {} for {}\", addr, rr);\n             return;\n         }\n \n-        readCompletion.cb.readEntryComplete(rc, ledgerId, entryId, buffer.slice(), readCompletion.ctx);\n+        readCompletion.cb.readEntryComplete(rc, rr.getLedgerId(), rr.getEntryId(),\n+                                            rr.getData(), readCompletion.ctx);\n     }\n \n     /**"},{"sha":"651c11834a289b19575058713006474dd8247f0f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","status":"modified","additions":12,"deletions":5,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -21,20 +21,27 @@\n package org.apache.bookkeeper.proto;\n \n import java.nio.ByteBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n \n class ResponseBuilder {\n     static BookieProtocol.Response buildErrorResponse(int errorCode, BookieProtocol.Request r) {\n-        return new BookieProtocol.ErrorResponse(r.getProtocolVersion(), r.getOpCode(),\n-                                                errorCode, r.getLedgerId(), r.getEntryId());\n+        if (r.getOpCode() == BookieProtocol.ADDENTRY) {\n+            return new BookieProtocol.AddResponse(r.getProtocolVersion(), errorCode,\n+                                                  r.getLedgerId(), r.getEntryId());\n+        } else {\n+            assert(r.getOpCode() == BookieProtocol.READENTRY);\n+            return new BookieProtocol.ReadResponse(r.getProtocolVersion(), errorCode,\n+                                                   r.getLedgerId(), r.getEntryId());\n+        }\n     }\n \n     static BookieProtocol.Response buildAddResponse(BookieProtocol.Request r) {\n-        return new BookieProtocol.AddResponse(r.getProtocolVersion(), r.getLedgerId(),\n+        return new BookieProtocol.AddResponse(r.getProtocolVersion(), BookieProtocol.EOK, r.getLedgerId(),\n                                               r.getEntryId());\n     }\n \n     static BookieProtocol.Response buildReadResponse(ByteBuffer data, BookieProtocol.Request r) {\n-        return new BookieProtocol.ReadResponse(r.getProtocolVersion(),\n-                                               r.getLedgerId(), r.getEntryId(), data);\n+        return new BookieProtocol.ReadResponse(r.getProtocolVersion(), BookieProtocol.EOK,\n+                r.getLedgerId(), r.getEntryId(), ChannelBuffers.wrappedBuffer(data));\n     }\n }"},{"sha":"b5cf67f365b397d81c4f87e89be148da3895c19b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","status":"modified","additions":6,"deletions":17,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","raw_url":"https://github.com/apache/bookkeeper/raw/1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java?ref=1b7cb6fa9704d10a3a6134edfd0b12d85bf0012c","patch":"@@ -58,7 +58,7 @@ public void teardown() throws Exception {\n         base.tearDown();\n     }\n \n-    private void testVersion(int version, int expectedresult) throws Exception {\n+    private void testVersion(byte version, int expectedresult) throws Exception {\n         PerChannelBookieClient bc = new PerChannelBookieClient(base.executor, base.channelFactory, \n                 new InetSocketAddress(InetAddress.getLocalHost(), base.port), new AtomicLong(0));\n         final AtomicInteger outerrc = new AtomicInteger(-1);\n@@ -83,20 +83,9 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n         bc.readCompletions.put(bc.newCompletionKey(1, 1),\n                                new PerChannelBookieClient.ReadCompletion(cb, this));\n         \n-        int totalHeaderSize = 4 // for the length of the packet\n-            + 4 // for request type\n-            + 8 // for ledgerId\n-            + 8; // for entryId\n-\n-        // This will need to updated if the protocol for read changes\n-        ChannelBuffer tmpEntry = bc.channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n-        tmpEntry.writeInt(totalHeaderSize - 4);\n-        tmpEntry.writeInt(new BookieProtocol.PacketHeader((byte)version, BookieProtocol.READENTRY, (short)0).toInt());\n-        tmpEntry.writeLong(1);\n-        tmpEntry.writeLong(1);\n-        \n+        BookieProtocol.ReadRequest req = new BookieProtocol.ReadRequest(version, 1L, 1L, (short)0);\n         \n-        bc.channel.write(tmpEntry).awaitUninterruptibly();\n+        bc.channel.write(req).awaitUninterruptibly();\n         readLatch.await(5, TimeUnit.SECONDS);\n         assertEquals(\"Expected result differs\", expectedresult, outerrc.get());\n         \n@@ -105,9 +94,9 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n \n     @Test(timeout=60000)\n     public void testVersions() throws Exception {\n-        testVersion(BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION-1, BKException.Code.ProtocolVersionException);\n+        testVersion((byte)(BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION-1), BKException.Code.ProtocolVersionException);\n         testVersion(BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION, BKException.Code.NoSuchEntryException);\n         testVersion(BookieProtocol.CURRENT_PROTOCOL_VERSION, BKException.Code.NoSuchEntryException);\n-        testVersion(BookieProtocol.CURRENT_PROTOCOL_VERSION+1, BKException.Code.ProtocolVersionException);\n+        testVersion((byte)(BookieProtocol.CURRENT_PROTOCOL_VERSION+1), BKException.Code.ProtocolVersionException);\n     }\n-}\n\\ No newline at end of file\n+}"}]}

