{"sha":"1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxYmNiYzQ3YmNjNjM5NGIwYzZmZGViNzMyMDNhYWI1OWVhYjBmZWU1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-21T10:32:40Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-21T10:32:40Z"},"message":"BOOKKEEPER-79: randomly startDelivery/stopDelivery will core dump in c++ hedwig client (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1204437 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a39ab0deaaceb7a00a7d3848c05daa9d5dfb97cc","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a39ab0deaaceb7a00a7d3848c05daa9d5dfb97cc"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","html_url":"https://github.com/apache/bookkeeper/commit/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"aed845b574b88abc825634d3c860dcfd40351fb8","url":"https://api.github.com/repos/apache/bookkeeper/commits/aed845b574b88abc825634d3c860dcfd40351fb8","html_url":"https://github.com/apache/bookkeeper/commit/aed845b574b88abc825634d3c860dcfd40351fb8"}],"stats":{"total":262,"additions":215,"deletions":47},"files":[{"sha":"8fedc1b2570171faf34179f5832fd997cc580e06","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","patch":"@@ -106,6 +106,8 @@ BUGFIXES:\n \n   BOOKKEEPER-87: TestHedwigHub exhausts direct buffer memory with netty 3.2.4.Final (ivank via fpj)  \n \n+  BOOKKEEPER-79: randomly startDelivery/stopDelivery will core dump in c++ hedwig client (Sijie Guo via ivank)\n+\n IMPROVEMENTS:\n \n  BOOKKEEPER-28: Create useful startup scripts for bookkeeper and hedwig (ivank)"},{"sha":"f1d4528d9f9be90166021df45483345642e6ee56","filename":"hedwig-client/src/main/cpp/lib/channel.cpp","status":"modified","additions":79,"deletions":16,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/lib/channel.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/lib/channel.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.cpp?ref=1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","patch":"@@ -52,7 +52,7 @@ DuplexChannel::DuplexChannel(EventDispatcher& dispatcher, const HostAddress& add\n \t\t\t     const Configuration& cfg, const ChannelHandlerPtr& handler)\n   : dispatcher(dispatcher), address(addr), handler(handler), \n     socket(dispatcher.getService()), instream(&in_buf), copy_buf(NULL), copy_buf_length(0),\n-    state(UNINITIALISED), receiving(false), sending(false)\n+    state(UNINITIALISED), receiving(false), reading(false), sending(false)\n {\n   LOG4CXX_DEBUG(logger, \"Creating DuplexChannel(\" << this << \")\");\n }\n@@ -140,6 +140,21 @@ void DuplexChannel::connect() {\n       h = channel->handler;\n     }\n   }\n+\n+  // channel did stopReceiving, we should not call #messageReceived\n+  // store this response in outstanding_response variable and did stop receiving\n+  // when we startReceiving again, we can process this last response.\n+  {\n+    boost::lock_guard<boost::mutex> lock(channel->receiving_lock);\n+    if (!channel->isReceiving()) {\n+      // queue the response\n+      channel->outstanding_response = response;\n+      channel->reading = false;\n+      return;\n+    }\n+  }\n+\n+  // channel is still in receiving status\n   if (h.get()) {\n     h->messageReceived(channel, response);\n   }\n@@ -188,10 +203,6 @@ void DuplexChannel::connect() {\n }\n \n /*static*/ void DuplexChannel::readSize(DuplexChannelPtr channel) {\n-  if (!channel->isReceiving()) {\n-    return;\n-  }\n-\n   int toread = sizeof(uint32_t) - channel->in_buf.size();\n   LOG4CXX_DEBUG(logger, \" size of incoming message \" << sizeof(uint32_t) \n \t\t<< \", currently in buffer \" << channel->in_buf.size() \n@@ -212,14 +223,56 @@ void DuplexChannel::connect() {\n \n void DuplexChannel::startReceiving() {\n   LOG4CXX_DEBUG(logger, \"DuplexChannel::startReceiving channel(\" << this << \") currently receiving = \" << receiving);\n-  \n-  boost::lock_guard<boost::mutex> lock(receiving_lock);\n-  if (receiving) {\n-    return;\n-  } \n-  receiving = true;\n-  \n-  DuplexChannel::readSize(shared_from_this());\n+\n+  PubSubResponsePtr response;\n+  bool inReadingState;\n+  {\n+    boost::lock_guard<boost::mutex> lock(receiving_lock);\n+    // receiving before just return\n+    if (receiving) {\n+      return;\n+    } \n+    receiving = true;\n+\n+    // if we have last response collected in previous startReceiving\n+    // we need to process it, but we should process it under receiving_lock\n+    // otherwise we enter dead lock\n+    // subscriber#startDelivery(subscriber#queue_lock) =>\n+    // channel#startReceiving(channel#receiving_lock) =>\n+    // sbuscriber#messageReceived(subscriber#queue_lock)\n+    if (outstanding_response.get()) {\n+      response = outstanding_response;\n+      outstanding_response = PubSubResponsePtr();\n+    }\n+\n+    // if channel is in reading status wait data from remote server\n+    // we don't need to insert another readSize op\n+    inReadingState = reading;\n+    if (!reading) {\n+      reading = true;\n+    }\n+  }\n+\n+  // consume message buffered in receiving queue\n+  // there is at most one message buffered when we\n+  // stopReceiving between #readSize and #readMsgBody\n+  if (response.get()) {\n+    ChannelHandlerPtr h;\n+    {\n+      boost::shared_lock<boost::shared_mutex> lock(this->destruction_lock);\n+      if (this->handler.get()) {\n+        h = this->handler;\n+      }\n+    }\n+    if (h.get()) {\n+      h->messageReceived(shared_from_this(), response);\n+    }\n+  }\n+\n+  // if channel is not in reading state, #readSize\n+  if (!inReadingState) {\n+    DuplexChannel::readSize(shared_from_this());\n+  }\n }\n \n bool DuplexChannel::isReceiving() {\n@@ -320,9 +373,19 @@ void DuplexChannel::kill() {\n   if (connected) {\n     setState(DEAD);\n     \n-    socket.cancel();\n-    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n-    socket.close();\n+    boost::system::error_code ec;\n+    socket.cancel(ec);\n+    if (ec) {\n+      LOG4CXX_WARN(logger, \"Channel \" << this << \" canceling io error : \" << ec.message().c_str());\n+    }\n+    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n+    if (ec) {\n+      LOG4CXX_WARN(logger, \"Channel \" << this << \" shutdown error : \" << ec.message().c_str());\n+    }\n+    socket.close(ec);\n+    if (ec) {\n+      LOG4CXX_WARN(logger, \"Channel \" << this << \" close error : \" << ec.message().c_str());\n+    }\n   }\n   handler = ChannelHandlerPtr(); // clear the handler in case it ever referenced the channel*/\n }"},{"sha":"7a3c47fd2b80c50954fad21521032e9aeec45e30","filename":"hedwig-client/src/main/cpp/lib/channel.h","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/lib/channel.h","raw_url":"https://github.com/apache/bookkeeper/raw/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/lib/channel.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.h?ref=1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","patch":"@@ -139,6 +139,8 @@ namespace Hedwig {\n     boost::shared_mutex state_lock;\n \n     bool receiving;\n+    bool reading;\n+    PubSubResponsePtr outstanding_response;\n     boost::mutex receiving_lock;\n     \n     bool sending;"},{"sha":"7e53de35d28807a4e1bf512734aad6185321f5bf","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":19,"deletions":12,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","patch":"@@ -235,24 +235,31 @@ void SubscriberClientChannelHandler::channelDisconnected(const DuplexChannelPtr&\n }\n \n void SubscriberClientChannelHandler::startDelivery(const MessageHandlerCallbackPtr& handler) {\n-  boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n \n-  this->handler = handler;\n+    this->handler = handler;\n \n-  if (!(this->handler.get())) {\n-    // no message handler callback\n-    LOG4CXX_WARN(logger, \"Handler \" << this << \" try to start an empty message handler\");\n-    return;\n-  }\n+    if (!(this->handler.get())) {\n+      // no message handler callback\n+      LOG4CXX_WARN(logger, \"Handler \" << this << \" try to start an empty message handler\");\n+      return;\n+    }\n \n-  while (!queue.empty()) {    \n-    PubSubResponsePtr m = queue.front();\n-    queue.pop_front();\n+    while (!queue.empty()) {    \n+      PubSubResponsePtr m = queue.front();\n+      queue.pop_front();\n \n-    OperationCallbackPtr callback(new SubscriberConsumeCallback(client, shared_from_this(), origData, m));\n+      OperationCallbackPtr callback(new SubscriberConsumeCallback(client, shared_from_this(), origData, m));\n \n-    this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n+      this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n+    }\n   }\n+\n+  // put channel#startReceiving out of lock of subscriber#queue_lock\n+  // otherwise we enter dead lock\n+  // subscriber#startDelivery(subscriber#queue_lock) =>\n+  // channel#startReceiving(channel#receiving_lock) =>\n   channel->startReceiving();\n }\n "},{"sha":"25057f56e0b8f476bc007a99b5f04f0e27137c0b","filename":"hedwig-client/src/main/cpp/scripts/server-control.sh","status":"modified","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/scripts/server-control.sh","raw_url":"https://github.com/apache/bookkeeper/raw/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/scripts/server-control.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/server-control.sh?ref=1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","patch":"@@ -95,6 +95,25 @@ start_hw_server () {\n     COUNT=$2\n     PORT=$((4080+$COUNT))\n \n+    export HEDWIG_LOG_CONF=/tmp/hw-log4j-$COUNT.properties\n+    cat > $HEDWIG_LOG_CONF <<EOF\n+log4j.rootLogger=INFO, ROLLINGFILE\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=DEBUG\n+log4j.appender.ROLLINGFILE.File=/tmp/hedwig-server-$COUNT.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+EOF\n+\n     export HEDWIG_SERVER_CONF=/tmp/hw-server-$COUNT.conf\n     cat > $HEDWIG_SERVER_CONF <<EOF\n zk_host=localhost:2181"},{"sha":"08074eb0b57fb6285c1fb767b769ab466abc3021","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"modified","additions":94,"deletions":19,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=1bcbc47bcc6394b0c6fdeb73203aab59eab0fee5","patch":"@@ -42,6 +42,7 @@ class PubSubTestSuite : public CppUnit::TestFixture {\n private:\n   CPPUNIT_TEST_SUITE( PubSubTestSuite );\n   CPPUNIT_TEST(testPubSubOrderChecking);\n+  CPPUNIT_TEST(testRandomDelivery);\n   CPPUNIT_TEST(testPubSubContinuousOverClose);\n   //  CPPUNIT_TEST(testPubSubContinuousOverServerDown);\n   CPPUNIT_TEST(testMultiTopic);\n@@ -118,13 +119,17 @@ class PubSubTestSuite : public CppUnit::TestFixture {\n         int newMsgId = atoi(msg.body().c_str());\n         // checking msgId\n         LOG4CXX_DEBUG(logger, \"received message \" << newMsgId);\n-        if (isInOrder) {\n-          if (newMsgId != startMsgId + 1) {\n-            LOG4CXX_ERROR(logger, \"received out-of-order message : expected \" << (startMsgId + 1) << \", actual \" << newMsgId);\n-            isInOrder = false;\n-          } else {\n-            startMsgId = newMsgId;\n+        if (startMsgId >= 0) { // need to check ordering if start msg id is larger than 0\n+          if (isInOrder) {\n+            if (newMsgId != startMsgId + 1) {\n+              LOG4CXX_ERROR(logger, \"received out-of-order message : expected \" << (startMsgId + 1) << \", actual \" << newMsgId);\n+              isInOrder = false;\n+            } else {\n+              startMsgId = newMsgId;\n+            }\n           }\n+        } else { // we set first msg id as startMsgId when startMsgId is -1\n+          startMsgId = newMsgId;\n         }\n         callback->operationComplete();\n         sleep(sleepTimeInConsume);\n@@ -152,31 +157,101 @@ class PubSubTestSuite : public CppUnit::TestFixture {\n     int sleepTimeInConsume;\n   };\n \n-  class PubForOrderChecking {\n+  // Publisher integer until finished\n+  class IntegerPublisher {\n   public:\n-    PubForOrderChecking(std::string &topic, int startMsgId, int numMsgs, int sleepTime, Hedwig::Publisher &pub)\n-      : topic(topic), startMsgId(startMsgId), numMsgs(numMsgs), sleepTime(sleepTime), pub(pub) {\n+    IntegerPublisher(std::string &topic, int startMsgId, int numMsgs, int sleepTime, Hedwig::Publisher &pub, long runTime)\n+      : topic(topic), startMsgId(startMsgId), numMsgs(numMsgs), sleepTime(sleepTime), pub(pub), running(true), runTime(runTime) {\n     }\n \n     void operator()() {\n-      for (int i=0; i<numMsgs; i++) {\n-        int msg = startMsgId + i;\n-        std::stringstream ss;\n-        ss << msg;\n-        pub.publish(topic, ss.str());\n-        sleep(sleepTime);\n-      }\n+      int i = 1;\n+      long beginTime = curTime();\n+      long elapsedTime = 0;\n+\n+      while (running) {\n+        try {\n+          int msg = startMsgId + i;\n+          std::stringstream ss;\n+          ss << msg;\n+          pub.publish(topic, ss.str());\n+          sleep(sleepTime);\n+          if (numMsgs > 0 && i >= numMsgs) {\n+            running = false;\n+          } else {\n+            if (i % 100 == 0 &&\n+                (elapsedTime = (curTime() - beginTime)) >= runTime) {\n+              LOG4CXX_DEBUG(logger, \"Elapsed time : \" << elapsedTime);\n+              running = false;\n+            }\n+          }\n+          ++i;\n+        } catch (std::exception &e) {\n+          LOG4CXX_WARN(logger, \"Exception when publishing messages : \" << e.what());\n+        }\n+      } \n     }\n \n+    long curTime() {\n+      struct timeval tv;\n+      long mtime;\n+      gettimeofday(&tv, NULL);\n+      mtime = tv.tv_sec * 1000 + tv.tv_usec / 1000.0 + 0.5;\n+      return mtime;\n+    }\n \n   private:\n     std::string topic;\n     int startMsgId;\n     int numMsgs;\n     int sleepTime;\n     Hedwig::Publisher& pub;\n+    bool running;\n+    long runTime;\n   };\n \n+  // test startDelivery / stopDelivery randomly\n+  void testRandomDelivery() {\n+    std::string topic = \"randomDeliveryTopic\";\n+    std::string subscriber = \"mysub-randomDelivery\";\n+\n+    int nLoops = 300;\n+    int sleepTimePerLoop = 1;\n+    int syncTimeout = 10000;\n+\n+    Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout);\n+    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+    Hedwig::Subscriber& sub = client->getSubscriber();\n+    Hedwig::Publisher& pub = client->getPublisher();\n+\n+    // subscribe topic\n+    sub.subscribe(topic, subscriber, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+    // start thread to publish message\n+    IntegerPublisher intPublisher = IntegerPublisher(topic, 0, 0, 0, pub, nLoops * sleepTimePerLoop * 1000);\n+    boost::thread pubThread(intPublisher);\n+\n+    // start random delivery\n+    MyOrderCheckingMessageHandlerCallback* cb =\n+      new MyOrderCheckingMessageHandlerCallback(topic, subscriber, 0, 0);\n+    Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+    for (int i = 0; i < nLoops; i++) {\n+      LOG4CXX_DEBUG(logger, \"Randomly Delivery : \" << i);\n+      sub.startDelivery(topic, subscriber, handler);\n+      // sleep random time\n+      sleep(sleepTimePerLoop);\n+      sub.stopDelivery(topic, subscriber);\n+      CPPUNIT_ASSERT(cb->inOrder());\n+    }\n+    \n+    pubThread.join();\n+  }\n+\n   // check message ordering\n   void testPubSubOrderChecking() {\n     std::string topic = \"orderCheckingTopic\";\n@@ -204,17 +279,17 @@ class PubSubTestSuite : public CppUnit::TestFixture {\n     \n     // we don't start delivery first, so the message will be queued\n     // publish ${numMessages} messages, so the messages will be queued\n-    for (int i=0; i<numMessages; i++) {\n+    for (int i=1; i<=numMessages; i++) {\n       std::stringstream ss;\n       ss << i;\n       pub.publish(topic, ss.str()); \n     }\n \n-    MyOrderCheckingMessageHandlerCallback* cb = new MyOrderCheckingMessageHandlerCallback(topic, sid, -1, sleepTimeInConsume);\n+    MyOrderCheckingMessageHandlerCallback* cb = new MyOrderCheckingMessageHandlerCallback(topic, sid, 0, sleepTimeInConsume);\n     Hedwig::MessageHandlerCallbackPtr handler(cb);\n \n     // create a thread to publish another ${numMessages} messages\n-    boost::thread pubThread(PubForOrderChecking(topic, numMessages, numMessages, sleepTimeInConsume, pub));\n+    boost::thread pubThread(IntegerPublisher(topic, numMessages, numMessages, sleepTimeInConsume, pub, 0));\n \n     // start delivery will consumed the queued messages\n     // new message will recevied and the queued message should be consumed"}]}

