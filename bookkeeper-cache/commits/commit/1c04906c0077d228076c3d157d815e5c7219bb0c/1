{"sha":"1c04906c0077d228076c3d157d815e5c7219bb0c","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxYzA0OTA2YzAwNzdkMjI4MDc2YzNkMTU3ZDgxNWU1YzcyMTliYjBj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-06-12T16:41:47Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-06-12T16:41:47Z"},"message":"BOOKKEEPER-592: allow application to recommend ledger data locality (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1492274 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8669f4bd48d495972be15c430a9f2df6479fe9ac","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8669f4bd48d495972be15c430a9f2df6479fe9ac"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1c04906c0077d228076c3d157d815e5c7219bb0c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1c04906c0077d228076c3d157d815e5c7219bb0c","html_url":"https://github.com/apache/bookkeeper/commit/1c04906c0077d228076c3d157d815e5c7219bb0c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1c04906c0077d228076c3d157d815e5c7219bb0c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"faf2ed87762fabe4f6cb5f629cf5a7132869ca60","url":"https://api.github.com/repos/apache/bookkeeper/commits/faf2ed87762fabe4f6cb5f629cf5a7132869ca60","html_url":"https://github.com/apache/bookkeeper/commit/faf2ed87762fabe4f6cb5f629cf5a7132869ca60"}],"stats":{"total":3812,"additions":3741,"deletions":71},"files":[{"sha":"baeca54e8db446997182dee3ad8fbe7061d41315","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -86,6 +86,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-603: Support Boost 1.53 for Hedwig Cpp Client (jiannan via ivank)\n \n+      BOOKKEEPER-592: allow application to recommend ledger data locality (sijie via ivank)\n+\n     NEW FEATURE:\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)"},{"sha":"ce677f859b36ef7cb33dd79bfd4c3284fadfafa8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":26,"deletions":4,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -37,8 +37,10 @@\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n+import org.apache.commons.configuration.ConfigurationException;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n@@ -85,6 +87,9 @@\n     final LedgerManagerFactory ledgerManagerFactory;\n     final LedgerManager ledgerManager;\n \n+    // Ensemble Placement Policy\n+    final EnsemblePlacementPolicy placementPolicy;\n+\n     final ClientConfiguration conf;\n \n     interface ZKConnectCallback {\n@@ -131,10 +136,12 @@ public BookKeeper(final ClientConfiguration conf)\n         this.channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n                                                                 Executors.newCachedThreadPool());\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+        // initialize the ensemble placement\n+        this.placementPolicy = initializeEnsemblePlacementPolicy(conf);\n \n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n-        bookieWatcher = new BookieWatcher(conf, scheduler, this);\n+        bookieWatcher = new BookieWatcher(conf, scheduler, placementPolicy, this);\n         bookieWatcher.readBookiesBlocking();\n \n         ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n@@ -195,16 +202,28 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n         this.zk = zk;\n         this.channelFactory = channelFactory;\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+        // initialize the ensemble placement\n+        this.placementPolicy = initializeEnsemblePlacementPolicy(conf);\n \n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n-        bookieWatcher = new BookieWatcher(conf, scheduler, this);\n+        bookieWatcher = new BookieWatcher(conf, scheduler, placementPolicy, this);\n         bookieWatcher.readBookiesBlocking();\n \n         ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n         ledgerManager = ledgerManagerFactory.newLedgerManager();\n     }\n \n+    private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf)\n+        throws IOException {\n+        try {\n+            Class<? extends EnsemblePlacementPolicy> policyCls = conf.getEnsemblePlacementPolicy();\n+            return ReflectionUtils.newInstance(policyCls).initialize(conf);\n+        } catch (ConfigurationException e) {\n+            throw new IOException(\"Failed to initialize ensemble placement policy : \", e);\n+        }\n+    }\n+\n     LedgerManager getLedgerManager() {\n         return ledgerManager;\n     }\n@@ -661,6 +680,7 @@ public void close() throws InterruptedException, BKException {\n          * @param ctx\n          *          optional control object\n          */\n+        @Override\n         public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n             SyncCounter counter = (SyncCounter) ctx;\n             counter.setLh(lh);\n@@ -680,12 +700,13 @@ public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n          * @param ctx\n          *          optional control object\n          */\n+        @Override\n         public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n             SyncCounter counter = (SyncCounter) ctx;\n             counter.setLh(lh);\n-            \n+\n             LOG.debug(\"Open complete: {}\", rc);\n-            \n+\n             counter.setrc(rc);\n             counter.dec();\n         }\n@@ -700,6 +721,7 @@ public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n          * @param ctx\n          *            optional control object\n          */\n+        @Override\n         public void deleteComplete(int rc, Object ctx) {\n             SyncCounter counter = (SyncCounter) ctx;\n             counter.setrc(rc);"},{"sha":"9f0445f8f2aad79359fc52b8a9171c1f571f878e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":28,"deletions":59,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -22,7 +22,6 @@\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n@@ -57,15 +56,15 @@\n class BookieWatcher implements Watcher, ChildrenCallback {\n     static final Logger logger = LoggerFactory.getLogger(BookieWatcher.class);\n \n+    public static int ZK_CONNECT_BACKOFF_SEC = 1;\n+    private static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n+\n     // Bookie registration path in ZK\n     private final String bookieRegistrationPath;\n-    static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n-    public static int ZK_CONNECT_BACKOFF_SEC = 1;\n \n     final BookKeeper bk;\n-\n-    HashSet<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n     final ScheduledExecutorService scheduler;\n+    final EnsemblePlacementPolicy placementPolicy;\n \n     SafeRunnable reReadTask = new SafeRunnable() {\n         @Override\n@@ -77,16 +76,24 @@ public void safeRun() {\n \n     public BookieWatcher(ClientConfiguration conf,\n                          ScheduledExecutorService scheduler,\n+                         EnsemblePlacementPolicy placementPolicy,\n                          BookKeeper bk) throws KeeperException, InterruptedException  {\n         this.bk = bk;\n         // ZK bookie registration path\n         this.bookieRegistrationPath = conf.getZkAvailableBookiesPath();\n         this.scheduler = scheduler;\n+        this.placementPolicy = placementPolicy;\n         readOnlyBookieWatcher = new ReadOnlyBookieWatcher(conf, bk);\n     }\n \n-    public synchronized Collection<InetSocketAddress> getBookies() {\n-        return new HashSet<InetSocketAddress>(knownBookies);\n+    public Collection<InetSocketAddress> getBookies() {\n+        try {\n+            List<String> children = bk.getZkHandle().getChildren(this.bookieRegistrationPath, false);\n+            return convertToBookieAddresses(children);\n+        } catch (Exception e) {\n+            logger.error(\"Failed to get bookies : \", e);\n+            return new HashSet<InetSocketAddress>();\n+        }\n     }\n \n     public void readBookies() {\n@@ -118,13 +125,10 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n \n         HashSet<InetSocketAddress> newBookieAddrs = convertToBookieAddresses(children);\n \n-        final HashSet<InetSocketAddress> deadBookies;\n+        final Set<InetSocketAddress> deadBookies;\n         synchronized (this) {\n-            deadBookies = new HashSet<InetSocketAddress>(knownBookies);\n-            deadBookies.removeAll(newBookieAddrs);\n-            // No need to close readonly bookie clients.\n-            deadBookies.removeAll(readOnlyBookieWatcher.getReadOnlyBookies());\n-            knownBookies = newBookieAddrs;\n+            Set<InetSocketAddress> readonlyBookies = readOnlyBookieWatcher.getReadOnlyBookies();\n+            deadBookies = placementPolicy.onClusterChanged(newBookieAddrs, readonlyBookies);\n         }\n \n         if (bk.getBookieClient() != null) {\n@@ -178,12 +182,16 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n \n     /**\n      * Wrapper over the {@link #getAdditionalBookies(Set, int)} method when there is no exclusion list (or exisiting bookies)\n-     * @param numBookiesNeeded\n-     * @return\n+     * @param ensembleSize\n+     *          Ensemble Size\n+     * @param writeQuorumSize\n+     *          Write Quorum Size\n+     * @return list of bookies for new ensemble.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public ArrayList<InetSocketAddress> getNewBookies(int numBookiesNeeded) throws BKNotEnoughBookiesException {\n-        return getAdditionalBookies(EMPTY_SET, numBookiesNeeded);\n+    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize)\n+            throws BKNotEnoughBookiesException {\n+        return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, EMPTY_SET);\n     }\n \n     /**\n@@ -192,49 +200,10 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      * @return\n      * @throws BKNotEnoughBookiesException\n      */\n-    public InetSocketAddress getAdditionalBookie(List<InetSocketAddress> existingBookies)\n+    public InetSocketAddress replaceBookie(List<InetSocketAddress> existingBookies, int bookieIdx)\n             throws BKNotEnoughBookiesException {\n-        return getAdditionalBookies(new HashSet<InetSocketAddress>(existingBookies), 1).get(0);\n-    }\n-\n-    /**\n-     * Returns additional bookies given an exclusion list and how many are needed\n-     * @param existingBookies\n-     * @param numAdditionalBookiesNeeded\n-     * @return\n-     * @throws BKNotEnoughBookiesException\n-     */\n-    public ArrayList<InetSocketAddress> getAdditionalBookies(Set<InetSocketAddress> existingBookies,\n-            int numAdditionalBookiesNeeded) throws BKNotEnoughBookiesException {\n-\n-        ArrayList<InetSocketAddress> newBookies = new ArrayList<InetSocketAddress>();\n-\n-        if (numAdditionalBookiesNeeded <= 0) {\n-            return newBookies;\n-        }\n-\n-        List<InetSocketAddress> allBookies;\n-\n-        synchronized (this) {\n-            allBookies = new ArrayList<InetSocketAddress>(knownBookies);\n-        }\n-\n-        Collections.shuffle(allBookies);\n-\n-        for (InetSocketAddress bookie : allBookies) {\n-            if (existingBookies.contains(bookie)) {\n-                continue;\n-            }\n-\n-            newBookies.add(bookie);\n-            numAdditionalBookiesNeeded--;\n-\n-            if (numAdditionalBookiesNeeded == 0) {\n-                return newBookies;\n-            }\n-        }\n-\n-        throw new BKNotEnoughBookiesException();\n+        InetSocketAddress addr = existingBookies.get(bookieIdx);\n+        return placementPolicy.replaceBookie(addr, new HashSet<InetSocketAddress>(existingBookies));\n     }\n \n     /**"},{"sha":"fe51fd161c322d68204ecbbfb8b972177181d245","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.commons.configuration.Configuration;\n+\n+/**\n+ * Default Ensemble Placement Policy, which picks bookies randomly\n+ */\n+public class DefaultEnsemblePlacementPolicy implements EnsemblePlacementPolicy {\n+\n+    static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n+\n+    private Set<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n+\n+    @Override\n+    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int quorumSize,\n+            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        ArrayList<InetSocketAddress> newBookies = new ArrayList<InetSocketAddress>(ensembleSize);\n+        if (ensembleSize <= 0) {\n+            return newBookies;\n+        }\n+        List<InetSocketAddress> allBookies;\n+        synchronized (this) {\n+            allBookies = new ArrayList<InetSocketAddress>(knownBookies);\n+        }\n+        Collections.shuffle(allBookies);\n+        for (InetSocketAddress bookie : allBookies) {\n+            if (excludeBookies.contains(bookie)) {\n+                continue;\n+            }\n+            newBookies.add(bookie);\n+            --ensembleSize;\n+            if (ensembleSize == 0) {\n+                return newBookies;\n+            }\n+        }\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+    @Override\n+    public InetSocketAddress replaceBookie(InetSocketAddress bookieToReplace,\n+            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        ArrayList<InetSocketAddress> addresses = newEnsemble(1, 1, excludeBookies);\n+        return addresses.get(0);\n+    }\n+\n+    @Override\n+    public synchronized Set<InetSocketAddress> onClusterChanged(Set<InetSocketAddress> writableBookies,\n+            Set<InetSocketAddress> readOnlyBookies) {\n+        HashSet<InetSocketAddress> deadBookies;\n+        deadBookies = new HashSet<InetSocketAddress>(knownBookies);\n+        deadBookies.removeAll(writableBookies);\n+        // readonly bookies should not be treated as dead bookies\n+        deadBookies.removeAll(readOnlyBookies);\n+        knownBookies = writableBookies;\n+        return deadBookies;\n+    }\n+\n+    @Override\n+    public EnsemblePlacementPolicy initialize(Configuration conf) {\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitalize() {\n+        // do nothing\n+    }\n+\n+}"},{"sha":"0b9f28df82b4f44b155adaff75a9172c066db59a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.commons.configuration.Configuration;\n+\n+/**\n+ * Encapsulation of the algorithm that selects a number of bookies from the cluster as an ensemble for storing\n+ * data, based on the data input as well as the node properties.\n+ */\n+public interface EnsemblePlacementPolicy {\n+\n+    /**\n+     * Initialize the policy.\n+     *\n+     * @param conf\n+     *          client configuration.\n+     * @return initialized ensemble placement policy\n+     */\n+    public EnsemblePlacementPolicy initialize(Configuration conf);\n+\n+    /**\n+     * Uninitialize the policy\n+     */\n+    public void uninitalize();\n+\n+    /**\n+     * A consistent view of the cluster (what bookies are available as writable, what bookies are available as\n+     * readonly) is updated when any changes happen in the cluster.\n+     *\n+     * @param writableBookies\n+     *          All the bookies in the cluster available for write/read.\n+     * @param readOnlyBookies\n+     *          All the bookies in the cluster available for readonly.\n+     * @return the dead bookies during this cluster change.\n+     */\n+    public Set<InetSocketAddress> onClusterChanged(Set<InetSocketAddress> writableBookies,\n+            Set<InetSocketAddress> readOnlyBookies);\n+\n+    /**\n+     * Choose <i>numBookies</i> bookies for ensemble. If the count is more than the number of available\n+     * nodes, {@link BKNotEnoughBookiesException} is thrown.\n+     *\n+     * @param ensembleSize\n+     *          Ensemble Size\n+     * @param writeQuorumSize\n+     *          Write Quorum Size\n+     * @param excludeBookies\n+     *          Bookies that should not be considered as targets.\n+     * @return list of bookies chosen as targets.\n+     * @throws BKNotEnoughBookiesException if not enough bookies available.\n+     */\n+    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n+            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+\n+    /**\n+     * Choose a new bookie to replace <i>bookieToReplace</i>. If no bookie available in the cluster,\n+     * {@link BKNotEnoughBookiesException} is thrown.\n+     *\n+     * @param bookieToReplace\n+     *          bookie to replace\n+     * @param excludeBookies\n+     *          bookies that should not be considered as candidate.\n+     * @return the bookie chosen as target.\n+     * @throws BKNotEnoughBookiesException\n+     */\n+    public InetSocketAddress replaceBookie(InetSocketAddress bookieToReplace,\n+            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+}"},{"sha":"0aa5f94dcc76a667b24f1e7fd654e825136a346e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -92,7 +92,8 @@ public void initiate() {\n \n         ArrayList<InetSocketAddress> ensemble;\n         try {\n-            ensemble = bk.bookieWatcher.getNewBookies(metadata.getEnsembleSize());\n+            ensemble = bk.bookieWatcher\n+                    .newEnsemble(metadata.getEnsembleSize(), metadata.getWriteQuorumSize());\n         } catch (BKNotEnoughBookiesException e) {\n             LOG.error(\"Not enough bookies to create ledger\");\n             cb.createComplete(e.getCode(), null, this.ctx);"},{"sha":"e818a90ce8ac09f43ac52fb25f5c751491ba29c6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -655,7 +655,7 @@ void sendAddSuccessCallbacks() {\n \n         // avoid parallel ensemble changes to same ensemble.\n         synchronized (metadata) {\n-            newBookie = bk.bookieWatcher.getAdditionalBookie(metadata.currentEnsemble);\n+            newBookie = bk.bookieWatcher.replaceBookie(metadata.currentEnsemble, bookieIndex);\n \n             newEnsemble.addAll(metadata.currentEnsemble);\n             newEnsemble.set(bookieIndex, newBookie);"},{"sha":"40bfd1c8f82318393c5b7db626f7931aa1bdb11c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","status":"added","additions":572,"deletions":0,"changes":572,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,572 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.Configurable;\n+import org.apache.bookkeeper.net.CachedDNSToSwitchMapping;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.net.Node;\n+import org.apache.bookkeeper.net.NodeBase;\n+import org.apache.bookkeeper.net.ScriptBasedMapping;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.commons.configuration.Configuration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Simple rackware ensemble placement policy.\n+ *\n+ * Make most of the class and methods as protected, so it could be extended to implement other algorithms.\n+ */\n+public class RackawareEnsemblePlacementPolicy implements EnsemblePlacementPolicy {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicy.class);\n+\n+    public static final String REPP_DNS_RESOLVER_CLASS = \"reppDnsResolverClass\";\n+\n+    /**\n+     * Predicate used when choosing an ensemble.\n+     */\n+    protected static interface Predicate {\n+        boolean apply(BookieNode candidate, Ensemble chosenBookies);\n+    }\n+\n+    /**\n+     * Ensemble used to hold the result of an ensemble selected for placement.\n+     */\n+    protected static interface Ensemble {\n+\n+        /**\n+         * Append the new bookie node to the ensemble.\n+         *\n+         * @param node\n+         *          new candidate bookie node.\n+         */\n+        public void addBookie(BookieNode node);\n+\n+        /**\n+         * @return list of addresses representing the ensemble\n+         */\n+        public ArrayList<InetSocketAddress> toList();\n+    }\n+\n+    protected static class TruePredicate implements Predicate {\n+\n+        public static final TruePredicate instance = new TruePredicate();\n+\n+        @Override\n+        public boolean apply(BookieNode candidate, Ensemble chosenNodes) {\n+            return true;\n+        }\n+\n+    }\n+\n+    protected static class EnsembleForReplacement implements Ensemble {\n+\n+        public static final EnsembleForReplacement instance = new EnsembleForReplacement();\n+        static final ArrayList<InetSocketAddress> EMPTY_LIST = new ArrayList<InetSocketAddress>(0);\n+\n+        @Override\n+        public void addBookie(BookieNode node) {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public ArrayList<InetSocketAddress> toList() {\n+            return EMPTY_LIST;\n+        }\n+\n+    }\n+\n+    /**\n+     * A predicate checking the rack coverage for write quorum in {@link RoundRobinDistributionSchedule},\n+     * which ensures that a write quorum should be covered by at least two racks.\n+     */\n+    protected static class RRRackCoverageEnsemble implements Predicate, Ensemble {\n+\n+        class QuorumCoverageSet {\n+            Set<String> racks = new HashSet<String>();\n+            int seenBookies = 0;\n+\n+            boolean apply(BookieNode candidate) {\n+                if (seenBookies + 1 == writeQuorumSize) {\n+                    return racks.size() > (racks.contains(candidate.getNetworkLocation()) ? 1 : 0);\n+                }\n+                return true;\n+            }\n+\n+            void addBookie(BookieNode candidate) {\n+                ++seenBookies;\n+                racks.add(candidate.getNetworkLocation());\n+            }\n+        }\n+\n+        final int ensembleSize;\n+        final int writeQuorumSize;\n+        final ArrayList<BookieNode> chosenNodes;\n+        private final QuorumCoverageSet[] quorums;\n+\n+        protected RRRackCoverageEnsemble(int ensembleSize, int writeQuorumSize) {\n+            this.ensembleSize = ensembleSize;\n+            this.writeQuorumSize = writeQuorumSize;\n+            this.chosenNodes = new ArrayList<BookieNode>(ensembleSize);\n+            this.quorums = new QuorumCoverageSet[ensembleSize];\n+        }\n+\n+        @Override\n+        public boolean apply(BookieNode candidate, Ensemble ensemble) {\n+            if (ensemble != this) {\n+                return false;\n+            }\n+            // candidate position\n+            int candidatePos = chosenNodes.size();\n+            int startPos = candidatePos - writeQuorumSize + 1;\n+            for (int i = startPos; i <= candidatePos; i++) {\n+                int idx = (i + ensembleSize) % ensembleSize;\n+                if (null == quorums[idx]) {\n+                    quorums[idx] = new QuorumCoverageSet();\n+                }\n+                if (!quorums[idx].apply(candidate)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public void addBookie(BookieNode node) {\n+            int candidatePos = chosenNodes.size();\n+            int startPos = candidatePos - writeQuorumSize + 1;\n+            for (int i = startPos; i <= candidatePos; i++) {\n+                int idx = (i + ensembleSize) % ensembleSize;\n+                if (null == quorums[idx]) {\n+                    quorums[idx] = new QuorumCoverageSet();\n+                }\n+                quorums[idx].addBookie(node);\n+            }\n+            chosenNodes.add(node);\n+        }\n+\n+        @Override\n+        public ArrayList<InetSocketAddress> toList() {\n+            ArrayList<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(ensembleSize);\n+            for (BookieNode bn : chosenNodes) {\n+                addresses.add(bn.getAddr());\n+            }\n+            return addresses;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return chosenNodes.toString();\n+        }\n+\n+    }\n+\n+    protected static class BookieNode implements Node {\n+\n+        private final InetSocketAddress addr; // identifier of a bookie node.\n+\n+        private int level; // the level in topology tree\n+        private Node parent; // its parent in topology tree\n+        private String location = NetworkTopology.DEFAULT_RACK; // its network location\n+        private final String name;\n+\n+        BookieNode(InetSocketAddress addr, String networkLoc) {\n+            this.addr = addr;\n+            this.name = StringUtils.addrToString(addr);\n+            setNetworkLocation(networkLoc);\n+        }\n+\n+        public InetSocketAddress getAddr() {\n+            return addr;\n+        }\n+\n+        @Override\n+        public int getLevel() {\n+            return level;\n+        }\n+\n+        @Override\n+        public void setLevel(int level) {\n+            this.level = level;\n+        }\n+\n+        @Override\n+        public Node getParent() {\n+            return parent;\n+        }\n+\n+        @Override\n+        public void setParent(Node parent) {\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getNetworkLocation() {\n+            return location;\n+        }\n+\n+        @Override\n+        public void setNetworkLocation(String location) {\n+            this.location = location;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return name.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof BookieNode)) {\n+                return false;\n+            }\n+            BookieNode other = (BookieNode) obj;\n+            return getName().equals(other.getName());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"<Bookie:%s>\", name);\n+        }\n+\n+    }\n+\n+    static class DefaultResolver implements DNSToSwitchMapping {\n+\n+        @Override\n+        public List<String> resolve(List<String> names) {\n+            List<String> rNames = new ArrayList<String>(names.size());\n+            for (@SuppressWarnings(\"unused\") String name : names) {\n+                rNames.add(NetworkTopology.DEFAULT_RACK);\n+            }\n+            return rNames;\n+        }\n+\n+        @Override\n+        public void reloadCachedMappings() {\n+            // nop\n+        }\n+\n+    };\n+\n+    // for now, we just maintain the writable bookies' topology\n+    private final NetworkTopology topology;\n+    private DNSToSwitchMapping dnsResolver;\n+    private final Map<InetSocketAddress, BookieNode> knownBookies;\n+    private BookieNode localNode;\n+    private final ReentrantReadWriteLock rwLock;\n+\n+    public RackawareEnsemblePlacementPolicy() {\n+        topology = new NetworkTopology();\n+        knownBookies = new HashMap<InetSocketAddress, BookieNode>();\n+\n+        rwLock = new ReentrantReadWriteLock();\n+    }\n+\n+    private BookieNode createBookieNode(InetSocketAddress addr) {\n+        return new BookieNode(addr, resolveNetworkLocation(addr));\n+    }\n+\n+    @Override\n+    public EnsemblePlacementPolicy initialize(Configuration conf) {\n+        String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());\n+        try {\n+            dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);\n+            if (dnsResolver instanceof Configurable) {\n+                ((Configurable) dnsResolver).setConf(conf);\n+            }\n+        } catch (RuntimeException re) {\n+            LOG.info(\"Failed to initialize DNS Resolver {}, used default subnet resolver.\", dnsResolverName, re);\n+            dnsResolver = new DefaultResolver();\n+        }\n+\n+        BookieNode bn;\n+        try {\n+            bn = createBookieNode(new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0));\n+        } catch (UnknownHostException e) {\n+            LOG.error(\"Failed to get local host address : \", e);\n+            bn = null;\n+        }\n+        localNode = bn;\n+        LOG.info(\"Initialize rackaware ensemble placement policy @ {} : {}.\", localNode,\n+                dnsResolver.getClass().getName());\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitalize() {\n+        // do nothing\n+    }\n+\n+    private String resolveNetworkLocation(InetSocketAddress addr) {\n+        List<String> names = new ArrayList<String>(1);\n+        if (dnsResolver instanceof CachedDNSToSwitchMapping) {\n+            names.add(addr.getAddress().getHostAddress());\n+        } else {\n+            names.add(addr.getHostName());\n+        }\n+        // resolve network addresses\n+        List<String> rNames = dnsResolver.resolve(names);\n+        String netLoc;\n+        if (null == rNames) {\n+            LOG.warn(\"Failed to resolve network location for {}, using default rack for them : {}.\", names,\n+                    NetworkTopology.DEFAULT_RACK);\n+            netLoc = NetworkTopology.DEFAULT_RACK;\n+        } else {\n+            netLoc = rNames.get(0);\n+        }\n+        return netLoc;\n+    }\n+\n+    @Override\n+    public Set<InetSocketAddress> onClusterChanged(Set<InetSocketAddress> writableBookies,\n+            Set<InetSocketAddress> readOnlyBookies) {\n+        rwLock.writeLock().lock();\n+        try {\n+            Set<InetSocketAddress> joinedBookies, leftBookies, deadBookies;\n+            Set<InetSocketAddress> oldBookieSet = knownBookies.keySet();\n+            // left bookies : bookies in known bookies, but not in new writable bookie cluster.\n+            leftBookies = Sets.difference(oldBookieSet, writableBookies);\n+            // joined bookies : bookies in new writable bookie cluster, but not in known bookies\n+            joinedBookies = Sets.difference(writableBookies, oldBookieSet);\n+            // dead bookies.\n+            deadBookies = Sets.difference(leftBookies, readOnlyBookies);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\n+                        \"Cluster changed : left bookies are {}, joined bookies are {}, while dead bookies are {}.\",\n+                        new Object[] { leftBookies, joinedBookies, deadBookies });\n+            }\n+\n+            // node left\n+            for (InetSocketAddress addr : leftBookies) {\n+                BookieNode node = knownBookies.remove(addr);\n+                topology.remove(node);\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Cluster changed : bookie {} left from cluster.\", addr);\n+                }\n+            }\n+\n+            // node joined\n+            for (InetSocketAddress addr : joinedBookies) {\n+                BookieNode node = createBookieNode(addr);\n+                topology.add(node);\n+                knownBookies.put(addr, node);\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Cluster changed : bookie {} joined the cluster.\", addr);\n+                }\n+            }\n+\n+            return deadBookies;\n+        } finally {\n+            rwLock.writeLock().unlock();\n+        }\n+    }\n+\n+    private Set<Node> convertBookiesToNodes(Set<InetSocketAddress> excludeBookies) {\n+        Set<Node> nodes = new HashSet<Node>();\n+        for (InetSocketAddress addr : excludeBookies) {\n+            BookieNode bn = knownBookies.get(addr);\n+            if (null == bn) {\n+                bn = createBookieNode(addr);\n+            }\n+            nodes.add(bn);\n+        }\n+        return nodes;\n+    }\n+\n+    @Override\n+    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n+            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        rwLock.readLock().lock();\n+        try {\n+            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n+            RRRackCoverageEnsemble ensemble = new RRRackCoverageEnsemble(ensembleSize, writeQuorumSize);\n+            BookieNode prevNode = null;\n+            int numRacks = topology.getNumOfRacks();\n+            // only one rack, use the random algorithm.\n+            if (numRacks < 2) {\n+                List<BookieNode> bns = selectRandom(ensembleSize, excludeNodes,\n+                        EnsembleForReplacement.instance);\n+                ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>(ensembleSize);\n+                for (BookieNode bn : bns) {\n+                    addrs.add(bn.addr);\n+                }\n+                return addrs;\n+            }\n+            // pick nodes by racks, to ensure there is at least two racks per write quorum.\n+            for (int i = 0; i < ensembleSize; i++) {\n+                String curRack;\n+                if (null == prevNode) {\n+                    if (null == localNode) {\n+                        curRack = NodeBase.ROOT;\n+                    } else {\n+                        curRack = localNode.getNetworkLocation();\n+                    }\n+                } else {\n+                    curRack = \"~\" + prevNode.getNetworkLocation();\n+                }\n+                prevNode = selectFromRack(curRack, excludeNodes, ensemble, ensemble);\n+            }\n+            return ensemble.toList();\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public InetSocketAddress replaceBookie(InetSocketAddress bookieToReplace,\n+            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        rwLock.readLock().lock();\n+        try {\n+            BookieNode bn = knownBookies.get(bookieToReplace);\n+            if (null == bn) {\n+                bn = createBookieNode(bookieToReplace);\n+            }\n+\n+            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n+            // add the bookie to replace in exclude set\n+            excludeNodes.add(bn);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Try to choose a new bookie to replace {}, excluding {}.\", bookieToReplace,\n+                        excludeNodes);\n+            }\n+            // pick a candidate from same rack to replace\n+            BookieNode candidate = selectFromRack(bn.getNetworkLocation(), excludeNodes,\n+                    TruePredicate.instance, EnsembleForReplacement.instance);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Bookie {} is chosen to replace bookie {}.\", candidate, bn);\n+            }\n+            return candidate.addr;\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+\n+    protected BookieNode selectFromRack(String networkLoc, Set<Node> excludeBookies, Predicate predicate,\n+            Ensemble ensemble) throws BKNotEnoughBookiesException {\n+        // select one from local rack\n+        try {\n+            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);\n+        } catch (BKNotEnoughBookiesException e) {\n+            LOG.warn(\"Failed to choose a bookie from {} : \"\n+                     + \"excluded {}, fallback to choose bookie randomly from the cluster.\",\n+                     networkLoc, excludeBookies);\n+            // randomly choose one from whole cluster, ignore the provided predicate.\n+            return selectRandom(1, excludeBookies, ensemble).get(0);\n+        }\n+    }\n+\n+    protected String getRemoteRack(BookieNode node) {\n+        return \"~\" + node.getNetworkLocation();\n+    }\n+\n+    /**\n+     * Choose random node under a given network path.\n+     *\n+     * @param netPath\n+     *          network path\n+     * @param excludeBookies\n+     *          exclude bookies\n+     * @param predicate\n+     *          predicate to check whether the target is a good target.\n+     * @param ensemble\n+     *          ensemble structure\n+     * @return chosen bookie.\n+     */\n+    protected BookieNode selectRandomFromRack(String netPath, Set<Node> excludeBookies, Predicate predicate,\n+            Ensemble ensemble) throws BKNotEnoughBookiesException {\n+        List<Node> leaves = new ArrayList<Node>(topology.getLeaves(netPath));\n+        Collections.shuffle(leaves);\n+        for (Node n : leaves) {\n+            if (excludeBookies.contains(n)) {\n+                continue;\n+            }\n+            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {\n+                continue;\n+            }\n+            BookieNode bn = (BookieNode) n;\n+            // got a good candidate\n+            ensemble.addBookie(bn);\n+            // add the candidate to exclude set\n+            excludeBookies.add(bn);\n+            return bn;\n+        }\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+    /**\n+     * Choose a random node from whole cluster.\n+     *\n+     * @param numBookies\n+     *          number bookies to choose\n+     * @param excludeBookies\n+     *          bookies set to exclude.\n+     * @param ensemble\n+     *          ensemble to hold the bookie chosen.\n+     * @return the bookie node chosen.\n+     * @throws BKNotEnoughBookiesException\n+     */\n+    protected List<BookieNode> selectRandom(int numBookies, Set<Node> excludeBookies, Ensemble ensemble)\n+            throws BKNotEnoughBookiesException {\n+        List<BookieNode> allBookies = new ArrayList<BookieNode>(knownBookies.values());\n+        Collections.shuffle(allBookies);\n+        List<BookieNode> newBookies = new ArrayList<BookieNode>(numBookies);\n+        for (BookieNode bookie : allBookies) {\n+            if (excludeBookies.contains(bookie)) {\n+                continue;\n+            }\n+            ensemble.addBookie(bookie);\n+            excludeBookies.add(bookie);\n+            newBookies.add(bookie);\n+            --numBookies;\n+            if (numBookies == 0) {\n+                return newBookies;\n+            }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Failed to find {} bookies : excludeBookies {}, allBookies {}.\", new Object[] {\n+                    numBookies, excludeBookies, allBookies });\n+        }\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+}"},{"sha":"3ec2b5a1c305a8807d1299b36b99af51b022ab71","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -38,12 +38,13 @@\n \n     static final Logger LOG = LoggerFactory.getLogger(AbstractConfiguration.class);\n \n-    private static ClassLoader defaultLoader;\n+    protected static final ClassLoader defaultLoader;\n     static {\n-        defaultLoader = Thread.currentThread().getContextClassLoader();\n-        if (null == defaultLoader) {\n-            defaultLoader = AbstractConfiguration.class.getClassLoader();\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        if (null == loader) {\n+            loader = AbstractConfiguration.class.getClassLoader();\n         }\n+        defaultLoader = loader;\n     }\n \n     // Ledger Manager"},{"sha":"0fbc0971710441810c376d9a4ad7c9b3c7cc69a2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":31,"deletions":1,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -20,7 +20,10 @@\n import java.util.List;\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-\n+import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n+import org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.lang.StringUtils;\n import static com.google.common.base.Charsets.UTF_8;\n \n@@ -49,6 +52,9 @@\n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n \n+    // Ensemble Placement Policy\n+    protected final static String ENSEMBLE_PLACEMENT_POLICY = \"ensemblePlacementPolicy\";\n+\n     /**\n      * Construct a default client-side configuration\n      */\n@@ -312,4 +318,28 @@ public ClientConfiguration setSpeculativeReadTimeout(int timeout) {\n         setProperty(SPECULATIVE_READ_TIMEOUT, timeout);\n         return this;\n     }\n+\n+    /**\n+     * Get Ensemble Placement Policy Class.\n+     *\n+     * @return ensemble placement policy class.\n+     */\n+    public Class<? extends EnsemblePlacementPolicy> getEnsemblePlacementPolicy()\n+        throws ConfigurationException {\n+        return ReflectionUtils.getClass(this, ENSEMBLE_PLACEMENT_POLICY,\n+                                        RackawareEnsemblePlacementPolicy.class,\n+                                        EnsemblePlacementPolicy.class,\n+                                        defaultLoader);\n+    }\n+\n+    /**\n+     * Set Ensemble Placement Policy Class.\n+     *\n+     * @param policyClass\n+     *          Ensemble Placement Policy Class.\n+     */\n+    public ClientConfiguration setEnsemblePlacementPolicy(Class<? extends EnsemblePlacementPolicy> policyClass) {\n+        setProperty(ENSEMBLE_PLACEMENT_POLICY, policyClass.getName());\n+        return this;\n+    }\n }"},{"sha":"361669043693c6a5ea19f93bf5a153ba79d3c138","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,47 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.conf;\n+\n+import org.apache.commons.configuration.Configuration;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * Class that may be configured with a {@link Configuration}.\n+ */\n+@Beta\n+public interface Configurable {\n+\n+    /**\n+     * Set the configuration to be used by this object.\n+     *\n+     * @param conf\n+     *          Configuration object to use\n+     */\n+    public void setConf(Configuration conf);\n+\n+    /**\n+     * Return the configuration used by this object.\n+     *\n+     * @return configuration used by this object.\n+     */\n+    public Configuration getConf();\n+}"},{"sha":"99ed03894bf7ade35b2d67b0cbaceeadb7c5994c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","status":"added","additions":142,"deletions":0,"changes":142,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,142 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.net;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.conf.Configurable;\n+import org.apache.commons.configuration.Configuration;\n+\n+/**\n+ * This is a base class for DNS to Switch mappings. <p/> It is not mandatory to\n+ * derive {@link DNSToSwitchMapping} implementations from it, but it is strongly\n+ * recommended, as it makes it easy for the Hadoop developers to add new methods\n+ * to this base class that are automatically picked up by all implementations.\n+ * <p/>\n+ *\n+ * This class does not extend the <code>Configured</code>\n+ * base class, and should not be changed to do so, as it causes problems\n+ * for subclasses. The constructor of the <code>Configured</code> calls\n+ * the  {@link #setConf(Configuration)} method, which will call into the\n+ * subclasses before they have been fully constructed.\n+ *\n+ */\n+public abstract class AbstractDNSToSwitchMapping implements DNSToSwitchMapping, Configurable {\n+\n+    private Configuration conf;\n+\n+    /**\n+     * Create an unconfigured instance\n+     */\n+    protected AbstractDNSToSwitchMapping() {\n+    }\n+\n+    /**\n+     * Create an instance, caching the configuration file.\n+     * This constructor does not call {@link #setConf(Configuration)}; if\n+     * a subclass extracts information in that method, it must call it explicitly.\n+     * @param conf the configuration\n+     */\n+    protected AbstractDNSToSwitchMapping(Configuration conf) {\n+        this.conf = conf;\n+    }\n+\n+    public Configuration getConf() {\n+        return conf;\n+    }\n+\n+    public void setConf(Configuration conf) {\n+        this.conf = conf;\n+    }\n+\n+    /**\n+     * Predicate that indicates that the switch mapping is known to be\n+     * single-switch. The base class returns false: it assumes all mappings are\n+     * multi-rack. Subclasses may override this with methods that are more aware\n+     * of their topologies.\n+     *\n+     * <p/>\n+     *\n+     * This method is used when parts of Hadoop need know whether to apply\n+     * single rack vs multi-rack policies, such as during block placement.\n+     * Such algorithms behave differently if they are on multi-switch systems.\n+     * </p>\n+     *\n+     * @return true if the mapping thinks that it is on a single switch\n+     */\n+    public boolean isSingleSwitch() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get a copy of the map (for diagnostics)\n+     * @return a clone of the map or null for none known\n+     */\n+    public Map<String, String> getSwitchMap() {\n+        return null;\n+    }\n+\n+    /**\n+     * Generate a string listing the switch mapping implementation,\n+     * the mapping for every known node and the number of nodes and\n+     * unique switches known about -each entry to a separate line.\n+     * @return a string that can be presented to the ops team or used in\n+     * debug messages.\n+     */\n+    public String dumpTopology() {\n+        Map<String, String> rack = getSwitchMap();\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(\"Mapping: \").append(toString()).append(\"\\n\");\n+        if (rack != null) {\n+            builder.append(\"Map:\\n\");\n+            Set<String> switches = new HashSet<String>();\n+            for (Map.Entry<String, String> entry : rack.entrySet()) {\n+                builder.append(\"  \").append(entry.getKey()).append(\" -> \").append(entry.getValue()).append(\"\\n\");\n+                switches.add(entry.getValue());\n+            }\n+            builder.append(\"Nodes: \").append(rack.size()).append(\"\\n\");\n+            builder.append(\"Switches: \").append(switches.size()).append(\"\\n\");\n+        } else {\n+            builder.append(\"No topology information\");\n+        }\n+        return builder.toString();\n+    }\n+\n+    protected boolean isSingleSwitchByScriptPolicy() {\n+        return conf != null && conf.getString(CommonConfigurationKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY) == null;\n+    }\n+\n+    /**\n+     * Query for a {@link DNSToSwitchMapping} instance being on a single\n+     * switch.\n+     * <p/>\n+     * This predicate simply assumes that all mappings not derived from\n+     * this class are multi-switch.\n+     * @param mapping the mapping to query\n+     * @return true if the base class says it is single switch, or the mapping\n+     * is not derived from this class.\n+     */\n+    public static boolean isMappingSingleSwitch(DNSToSwitchMapping mapping) {\n+        return mapping != null && mapping instanceof AbstractDNSToSwitchMapping\n+                && ((AbstractDNSToSwitchMapping) mapping).isSingleSwitch();\n+    }\n+\n+}"},{"sha":"d7ff251ca51afcbed8acf86f2ffeff9935f0e361","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","status":"added","additions":152,"deletions":0,"changes":152,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * A cached implementation of DNSToSwitchMapping that takes an\n+ * raw DNSToSwitchMapping and stores the resolved network location in\n+ * a cache. The following calls to a resolved network location\n+ * will get its location from the cache.\n+ *\n+ */\n+public class CachedDNSToSwitchMapping extends AbstractDNSToSwitchMapping {\n+  private Map<String, String> cache = new ConcurrentHashMap<String, String>();\n+\n+  /**\n+   * The uncached mapping\n+   */\n+  protected final DNSToSwitchMapping rawMapping;\n+\n+  /**\n+   * cache a raw DNS mapping\n+   * @param rawMapping the raw mapping to cache\n+   */\n+  public CachedDNSToSwitchMapping(DNSToSwitchMapping rawMapping) {\n+    this.rawMapping = rawMapping;\n+  }\n+\n+  /**\n+   * @param names a list of hostnames to probe for being cached\n+   * @return the hosts from 'names' that have not been cached previously\n+   */\n+  private List<String> getUncachedHosts(List<String> names) {\n+    // find out all names without cached resolved location\n+    List<String> unCachedHosts = new ArrayList<String>(names.size());\n+    for (String name : names) {\n+      if (cache.get(name) == null) {\n+        unCachedHosts.add(name);\n+      }\n+    }\n+    return unCachedHosts;\n+  }\n+\n+  /**\n+   * Caches the resolved host:rack mappings. The two list\n+   * parameters must be of equal size.\n+   *\n+   * @param uncachedHosts a list of hosts that were uncached\n+   * @param resolvedHosts a list of resolved host entries where the element\n+   * at index(i) is the resolved value for the entry in uncachedHosts[i]\n+   */\n+  private void cacheResolvedHosts(List<String> uncachedHosts,\n+      List<String> resolvedHosts) {\n+    // Cache the result\n+    if (resolvedHosts != null) {\n+      for (int i=0; i<uncachedHosts.size(); i++) {\n+        cache.put(uncachedHosts.get(i), resolvedHosts.get(i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param names a list of hostnames to look up (can be be empty)\n+   * @return the cached resolution of the list of hostnames/addresses.\n+   *  or null if any of the names are not currently in the cache\n+   */\n+  private List<String> getCachedHosts(List<String> names) {\n+    List<String> result = new ArrayList<String>(names.size());\n+    // Construct the result\n+    for (String name : names) {\n+      String networkLocation = cache.get(name);\n+      if (networkLocation != null) {\n+        result.add(networkLocation);\n+      } else {\n+        return null;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public List<String> resolve(List<String> names) {\n+    // normalize all input names to be in the form of IP addresses\n+    names = NetUtils.normalizeHostNames(names);\n+\n+    List <String> result = new ArrayList<String>(names.size());\n+    if (names.isEmpty()) {\n+      return result;\n+    }\n+\n+    List<String> uncachedHosts = getUncachedHosts(names);\n+\n+    // Resolve the uncached hosts\n+    List<String> resolvedHosts = rawMapping.resolve(uncachedHosts);\n+    //cache them\n+    cacheResolvedHosts(uncachedHosts, resolvedHosts);\n+    //now look up the entire list in the cache\n+    return getCachedHosts(names);\n+\n+  }\n+\n+  /**\n+   * Get the (host x switch) map.\n+   * @return a copy of the cached map of hosts to rack\n+   */\n+  @Override\n+  public Map<String, String> getSwitchMap() {\n+    Map<String, String > switchMap = new HashMap<String, String>(cache);\n+    return switchMap;\n+  }\n+\n+\n+  @Override\n+  public String toString() {\n+    return \"cached switch mapping relaying to \" + rawMapping;\n+  }\n+\n+  /**\n+   * Delegate the switch topology query to the raw mapping, via\n+   * {@link AbstractDNSToSwitchMapping#isMappingSingleSwitch(DNSToSwitchMapping)}\n+   * @return true iff the raw mapper is considered single-switch.\n+   */\n+  @Override\n+  public boolean isSingleSwitch() {\n+    return isMappingSingleSwitch(rawMapping);\n+  }\n+\n+  @Override\n+  public void reloadCachedMappings() {\n+    cache.clear();\n+  }\n+}"},{"sha":"12a3f1ad987d79855bf20c59d7ef91d23569db9a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,31 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.net;\n+\n+public interface CommonConfigurationKeys {\n+\n+    // script file name to resolve network topology\n+    public static final String NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY = \"networkTopologyScriptFileName\";\n+    // number of arguments that network topology resolve script used\n+    public static final String NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY = \"networkTopologyScriptNumberArgs\";\n+    // default value of NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY\n+    public static final int NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_DEFAULT = 100;\n+}"},{"sha":"615699358c7a677d4592cf5b05acb666b26b67bd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,60 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import java.util.List;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * An interface that must be implemented to allow pluggable\n+ * DNS-name/IP-address to RackID resolvers.\n+ *\n+ */\n+@Beta\n+public interface DNSToSwitchMapping {\n+    /**\n+     * Resolves a list of DNS-names/IP-addresses and returns back a list of\n+     * switch information (network paths). One-to-one correspondence must be\n+     * maintained between the elements in the lists.\n+     * Consider an element in the argument list - x.y.com. The switch information\n+     * that is returned must be a network path of the form /foo/rack,\n+     * where / is the root, and 'foo' is the switch where 'rack' is connected.\n+     * Note the hostname/ip-address is not part of the returned path.\n+     * The network topology of the cluster would determine the number of\n+     * components in the network path.\n+     * <p/>\n+     *\n+     * If a name cannot be resolved to a rack, the implementation\n+     * should return {@link NetworkTopology#DEFAULT_RACK}. This\n+     * is what the bundled implementations do, though it is not a formal requirement\n+     *\n+     * @param names the list of hosts to resolve (can be empty)\n+     * @return list of resolved network paths.\n+     * If <i>names</i> is empty, the returned list is also empty\n+     */\n+    public List<String> resolve(List<String> names);\n+\n+    /**\n+     * Reload all of the cached mappings.\n+     *\n+     * If there is a cache, this method will clear it, so that future accesses\n+     * will get a chance to see the new data.\n+     */\n+    public void reloadCachedMappings();\n+}"},{"sha":"978147306d082521e647054dd96788fe882ce378","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,60 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class NetUtils {\n+\n+    /**\n+     * Given a string representation of a host, return its ip address\n+     * in textual presentation.\n+     *\n+     * @param name a string representation of a host:\n+     *             either a textual representation its IP address or its host name\n+     * @return its IP address in the string format\n+     */\n+    public static String normalizeHostName(String name) {\n+        try {\n+            return InetAddress.getByName(name).getHostAddress();\n+        } catch (UnknownHostException e) {\n+            return name;\n+        }\n+    }\n+\n+    /**\n+     * Given a collection of string representation of hosts, return a list of\n+     * corresponding IP addresses in the textual representation.\n+     *\n+     * @param names a collection of string representations of hosts\n+     * @return a list of corresponding IP addresses in the string format\n+     * @see #normalizeHostName(String)\n+     */\n+    public static List<String> normalizeHostNames(Collection<String> names) {\n+        List<String> hostNames = new ArrayList<String>(names.size());\n+        for (String name : names) {\n+            hostNames.add(normalizeHostName(name));\n+        }\n+        return hostNames;\n+    }\n+\n+}"},{"sha":"dde2fdc9d20f84852da06fb9befd61acb9d4c9fa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","status":"added","additions":876,"deletions":0,"changes":876,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,876 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class represents a cluster of computer with a tree hierarchical\n+ * network topology.\n+ * For example, a cluster may be consists of many data centers filled\n+ * with racks of computers.\n+ * In a network topology, leaves represent data nodes (computers) and inner\n+ * nodes represent switches/routers that manage traffic in/out of data centers\n+ * or racks.\n+ *\n+ */\n+public class NetworkTopology {\n+\n+    public final static String DEFAULT_RACK = \"/default-rack\";\n+    public final static int DEFAULT_HOST_LEVEL = 2;\n+    public static final Logger LOG = LoggerFactory.getLogger(NetworkTopology.class);\n+\n+    public static class InvalidTopologyException extends RuntimeException {\n+        private static final long serialVersionUID = 1L;\n+\n+        public InvalidTopologyException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    /** InnerNode represents a switch/router of a data center or rack.\n+     * Different from a leaf node, it has non-null children.\n+     */\n+    static class InnerNode extends NodeBase {\n+        protected List<Node> children = new ArrayList<Node>();\n+        private int numOfLeaves;\n+\n+        /** Construct an InnerNode from a path-like string */\n+        InnerNode(String path) {\n+            super(path);\n+        }\n+\n+        /** Construct an InnerNode from its name and its network location */\n+        InnerNode(String name, String location) {\n+            super(name, location);\n+        }\n+\n+        /** Construct an InnerNode\n+         * from its name, its network location, its parent, and its level */\n+        InnerNode(String name, String location, InnerNode parent, int level) {\n+            super(name, location, parent, level);\n+        }\n+\n+        /** @return its children */\n+        List<Node> getChildren() {\n+            return children;\n+        }\n+\n+        /** @return the number of children this node has */\n+        int getNumOfChildren() {\n+            return children.size();\n+        }\n+\n+        /** Judge if this node represents a rack\n+         * @return true if it has no child or its children are not InnerNodes\n+         */\n+        boolean isRack() {\n+            if (children.isEmpty()) {\n+                return true;\n+            }\n+\n+            Node firstChild = children.get(0);\n+            if (firstChild instanceof InnerNode) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        /** Judge if this node is an ancestor of node <i>n</i>\n+         *\n+         * @param n a node\n+         * @return true if this node is an ancestor of <i>n</i>\n+         */\n+        boolean isAncestor(Node n) {\n+            return getPath(this).equals(NodeBase.PATH_SEPARATOR_STR)\n+                    || (n.getNetworkLocation() + NodeBase.PATH_SEPARATOR_STR).startsWith(getPath(this)\n+                            + NodeBase.PATH_SEPARATOR_STR);\n+        }\n+\n+        /** Judge if this node is the parent of node <i>n</i>\n+         *\n+         * @param n a node\n+         * @return true if this node is the parent of <i>n</i>\n+         */\n+        boolean isParent(Node n) {\n+            return n.getNetworkLocation().equals(getPath(this));\n+        }\n+\n+        /* Return a child name of this node who is an ancestor of node <i>n</i> */\n+        private String getNextAncestorName(Node n) {\n+            if (!isAncestor(n)) {\n+                throw new IllegalArgumentException(this + \"is not an ancestor of \" + n);\n+            }\n+            String name = n.getNetworkLocation().substring(getPath(this).length());\n+            if (name.charAt(0) == PATH_SEPARATOR) {\n+                name = name.substring(1);\n+            }\n+            int index = name.indexOf(PATH_SEPARATOR);\n+            if (index != -1)\n+                name = name.substring(0, index);\n+            return name;\n+        }\n+\n+        /** Add node <i>n</i> to the subtree of this node\n+         * @param n node to be added\n+         * @return true if the node is added; false otherwise\n+         */\n+        boolean add(Node n) {\n+            if (!isAncestor(n))\n+                throw new IllegalArgumentException(n.getName() + \", which is located at \" + n.getNetworkLocation()\n+                        + \", is not a decendent of \" + getPath(this));\n+            if (isParent(n)) {\n+                // this node is the parent of n; add n directly\n+                n.setParent(this);\n+                n.setLevel(this.level + 1);\n+                for (int i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(n.getName())) {\n+                        children.set(i, n);\n+                        return false;\n+                    }\n+                }\n+                children.add(n);\n+                numOfLeaves++;\n+                return true;\n+            } else {\n+                // find the next ancestor node\n+                String parentName = getNextAncestorName(n);\n+                InnerNode parentNode = null;\n+                for (int i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(parentName)) {\n+                        parentNode = (InnerNode) children.get(i);\n+                        break;\n+                    }\n+                }\n+                if (parentNode == null) {\n+                    // create a new InnerNode\n+                    parentNode = createParentNode(parentName);\n+                    children.add(parentNode);\n+                }\n+                // add n to the subtree of the next ancestor node\n+                if (parentNode.add(n)) {\n+                    numOfLeaves++;\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Creates a parent node to be added to the list of children.\n+         * Creates a node using the InnerNode four argument constructor specifying\n+         * the name, location, parent, and level of this node.\n+         *\n+         * <p>To be overridden in subclasses for specific InnerNode implementations,\n+         * as alternative to overriding the full {@link #add(Node)} method.\n+         *\n+         * @param parentName The name of the parent node\n+         * @return A new inner node\n+         * @see InnerNode#InnerNode(String, String, InnerNode, int)\n+         */\n+        protected InnerNode createParentNode(String parentName) {\n+            return new InnerNode(parentName, getPath(this), this, this.getLevel() + 1);\n+        }\n+\n+        /** Remove node <i>n</i> from the subtree of this node\n+         * @param n node to be deleted\n+         * @return true if the node is deleted; false otherwise\n+         */\n+        boolean remove(Node n) {\n+            String parent = n.getNetworkLocation();\n+            String currentPath = getPath(this);\n+            if (!isAncestor(n))\n+                throw new IllegalArgumentException(n.getName() + \", which is located at \" + parent\n+                        + \", is not a descendent of \" + currentPath);\n+            if (isParent(n)) {\n+                // this node is the parent of n; remove n directly\n+                for (int i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(n.getName())) {\n+                        children.remove(i);\n+                        numOfLeaves--;\n+                        n.setParent(null);\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            } else {\n+                // find the next ancestor node: the parent node\n+                String parentName = getNextAncestorName(n);\n+                InnerNode parentNode = null;\n+                int i;\n+                for (i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(parentName)) {\n+                        parentNode = (InnerNode) children.get(i);\n+                        break;\n+                    }\n+                }\n+                if (parentNode == null) {\n+                    return false;\n+                }\n+                // remove n from the parent node\n+                boolean isRemoved = parentNode.remove(n);\n+                // if the parent node has no children, remove the parent node too\n+                if (isRemoved) {\n+                    if (parentNode.getNumOfChildren() == 0) {\n+                        children.remove(i);\n+                    }\n+                    numOfLeaves--;\n+                }\n+                return isRemoved;\n+            }\n+        } // end of remove\n+\n+        /** Given a node's string representation, return a reference to the node\n+         * @param loc string location of the form /rack/node\n+         * @return null if the node is not found or the childnode is there but\n+         * not an instance of {@link InnerNode}\n+         */\n+        private Node getLoc(String loc) {\n+            if (loc == null || loc.length() == 0)\n+                return this;\n+\n+            String[] path = loc.split(PATH_SEPARATOR_STR, 2);\n+            Node childnode = null;\n+            for (int i = 0; i < children.size(); i++) {\n+                if (children.get(i).getName().equals(path[0])) {\n+                    childnode = children.get(i);\n+                }\n+            }\n+            if (childnode == null)\n+                return null; // non-existing node\n+            if (path.length == 1)\n+                return childnode;\n+            if (childnode instanceof InnerNode) {\n+                return ((InnerNode) childnode).getLoc(path[1]);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        /** get <i>leafIndex</i> leaf of this subtree\n+         * if it is not in the <i>excludedNode</i>\n+         *\n+         * @param leafIndex an indexed leaf of the node\n+         * @param excludedNode an excluded node (can be null)\n+         * @return\n+         */\n+        Node getLeaf(int leafIndex, Node excludedNode) {\n+            int count = 0;\n+            // check if the excluded node a leaf\n+            boolean isLeaf = excludedNode == null || !(excludedNode instanceof InnerNode);\n+            // calculate the total number of excluded leaf nodes\n+            int numOfExcludedLeaves = isLeaf ? 1 : ((InnerNode) excludedNode).getNumOfLeaves();\n+            if (isLeafParent()) { // children are leaves\n+                if (isLeaf) { // excluded node is a leaf node\n+                    int excludedIndex = children.indexOf(excludedNode);\n+                    if (excludedIndex != -1 && leafIndex >= 0) {\n+                        // excluded node is one of the children so adjust the leaf index\n+                        leafIndex = leafIndex >= excludedIndex ? leafIndex + 1 : leafIndex;\n+                    }\n+                }\n+                // range check\n+                if (leafIndex < 0 || leafIndex >= this.getNumOfChildren()) {\n+                    return null;\n+                }\n+                return children.get(leafIndex);\n+            } else {\n+                for (int i = 0; i < children.size(); i++) {\n+                    InnerNode child = (InnerNode) children.get(i);\n+                    if (excludedNode == null || excludedNode != child) {\n+                        // not the excludedNode\n+                        int numOfLeaves = child.getNumOfLeaves();\n+                        if (excludedNode != null && child.isAncestor(excludedNode)) {\n+                            numOfLeaves -= numOfExcludedLeaves;\n+                        }\n+                        if (count + numOfLeaves > leafIndex) {\n+                            // the leaf is in the child subtree\n+                            return child.getLeaf(leafIndex - count, excludedNode);\n+                        } else {\n+                            // go to the next child\n+                            count = count + numOfLeaves;\n+                        }\n+                    } else { // it is the excluededNode\n+                        // skip it and set the excludedNode to be null\n+                        excludedNode = null;\n+                    }\n+                }\n+                return null;\n+            }\n+        }\n+\n+        protected boolean isLeafParent() {\n+            return isRack();\n+        }\n+\n+        /**\n+          * Determine if children a leaves, default implementation calls {@link #isRack()}\n+          * <p>To be overridden in subclasses for specific InnerNode implementations,\n+          * as alternative to overriding the full {@link #getLeaf(int, Node)} method.\n+          *\n+          * @return true if children are leaves, false otherwise\n+          */\n+        protected boolean areChildrenLeaves() {\n+            return isRack();\n+        }\n+\n+        /**\n+         * Get number of leaves.\n+         */\n+        int getNumOfLeaves() {\n+            return numOfLeaves;\n+        }\n+    } // end of InnerNode\n+\n+    /**\n+     * the root cluster map\n+     */\n+    InnerNode clusterMap;\n+    /** Depth of all leaf nodes */\n+    private int depthOfAllLeaves = -1;\n+    /** rack counter */\n+    protected int numOfRacks = 0;\n+    /** the lock used to manage access */\n+    protected ReadWriteLock netlock = new ReentrantReadWriteLock();\n+\n+    public NetworkTopology() {\n+        clusterMap = new InnerNode(InnerNode.ROOT);\n+    }\n+\n+    /** Add a leaf node\n+     * Update node counter & rack counter if necessary\n+     * @param node node to be added; can be null\n+     * @exception IllegalArgumentException if add a node to a leave\n+                                           or node to be added is not a leaf\n+     */\n+    public void add(Node node) {\n+        if (node == null)\n+            return;\n+        String oldTopoStr = this.toString();\n+        if (node instanceof InnerNode) {\n+            throw new IllegalArgumentException(\"Not allow to add an inner node: \" + NodeBase.getPath(node));\n+        }\n+        int newDepth = NodeBase.locationToDepth(node.getNetworkLocation()) + 1;\n+        netlock.writeLock().lock();\n+        try {\n+            if ((depthOfAllLeaves != -1) && (depthOfAllLeaves != newDepth)) {\n+                LOG.error(\"Error: can't add leaf node at depth \" + newDepth + \" to topology:\\n\" + oldTopoStr);\n+                throw new InvalidTopologyException(\"Invalid network topology. \"\n+                        + \"You cannot have a rack and a non-rack node at the same level of the network topology.\");\n+            }\n+            Node rack = getNodeForNetworkLocation(node);\n+            if (rack != null && !(rack instanceof InnerNode)) {\n+                throw new IllegalArgumentException(\"Unexpected data node \" + node.toString()\n+                        + \" at an illegal network location\");\n+            }\n+            if (clusterMap.add(node)) {\n+                LOG.info(\"Adding a new node: \" + NodeBase.getPath(node));\n+                if (rack == null) {\n+                    numOfRacks++;\n+                }\n+                if (!(node instanceof InnerNode)) {\n+                    if (depthOfAllLeaves == -1) {\n+                        depthOfAllLeaves = node.getLevel();\n+                    }\n+                }\n+            }\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"NetworkTopology became:\\n\" + this.toString());\n+            }\n+        } finally {\n+            netlock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Return a reference to the node given its string representation.\n+     * Default implementation delegates to {@link #getNode(String)}.\n+     *\n+     * <p>To be overridden in subclasses for specific NetworkTopology\n+     * implementations, as alternative to overriding the full {@link #add(Node)}\n+     *  method.\n+     *\n+     * @param node The string representation of this node's network location is\n+     * used to retrieve a Node object.\n+     * @return a reference to the node; null if the node is not in the tree\n+     *\n+     * @see #add(Node)\n+     * @see #getNode(String)\n+     */\n+    protected Node getNodeForNetworkLocation(Node node) {\n+        return getNode(node.getNetworkLocation());\n+    }\n+\n+    /**\n+     * Given a string representation of a rack, return its children\n+     * @param loc a path-like string representation of a rack\n+     * @return a newly allocated list with all the node's children\n+     */\n+    public List<Node> getDatanodesInRack(String loc) {\n+        netlock.readLock().lock();\n+        try {\n+            loc = NodeBase.normalize(loc);\n+            if (!NodeBase.ROOT.equals(loc)) {\n+                loc = loc.substring(1);\n+            }\n+            InnerNode rack = (InnerNode) clusterMap.getLoc(loc);\n+            if (rack == null) {\n+                return null;\n+            }\n+            return new ArrayList<Node>(rack.getChildren());\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** Remove a node\n+     * Update node counter and rack counter if necessary\n+     * @param node node to be removed; can be null\n+     */\n+    public void remove(Node node) {\n+        if (node == null)\n+            return;\n+        if (node instanceof InnerNode) {\n+            throw new IllegalArgumentException(\"Not allow to remove an inner node: \" + NodeBase.getPath(node));\n+        }\n+        LOG.info(\"Removing a node: \" + NodeBase.getPath(node));\n+        netlock.writeLock().lock();\n+        try {\n+            if (clusterMap.remove(node)) {\n+                InnerNode rack = (InnerNode) getNode(node.getNetworkLocation());\n+                if (rack == null) {\n+                    numOfRacks--;\n+                }\n+            }\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"NetworkTopology became:\\n\" + this.toString());\n+            }\n+        } finally {\n+            netlock.writeLock().unlock();\n+        }\n+    }\n+\n+    /** Check if the tree contains node <i>node</i>\n+     *\n+     * @param node a node\n+     * @return true if <i>node</i> is already in the tree; false otherwise\n+     */\n+    public boolean contains(Node node) {\n+        if (node == null)\n+            return false;\n+        netlock.readLock().lock();\n+        try {\n+            Node parent = node.getParent();\n+            for (int level = node.getLevel(); parent != null && level > 0; parent = parent.getParent(), level--) {\n+                if (parent == clusterMap) {\n+                    return true;\n+                }\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /** Given a string representation of a node, return its reference\n+     *\n+     * @param loc\n+     *          a path-like string representation of a node\n+     * @return a reference to the node; null if the node is not in the tree\n+     */\n+    public Node getNode(String loc) {\n+        netlock.readLock().lock();\n+        try {\n+            loc = NodeBase.normalize(loc);\n+            if (!NodeBase.ROOT.equals(loc))\n+                loc = loc.substring(1);\n+            return clusterMap.getLoc(loc);\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** Given a string representation of a rack for a specific network\n+     *  location\n+     *\n+     * To be overridden in subclasses for specific NetworkTopology\n+     * implementations, as alternative to overriding the full\n+     * {@link #getRack(String)} method.\n+     * @param loc\n+     *          a path-like string representation of a network location\n+     * @return a rack string\n+     */\n+    public String getRack(String loc) {\n+        return loc;\n+    }\n+\n+    /** @return the total number of racks */\n+    public int getNumOfRacks() {\n+        netlock.readLock().lock();\n+        try {\n+            return numOfRacks;\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** @return the total number of leaf nodes */\n+    public int getNumOfLeaves() {\n+        netlock.readLock().lock();\n+        try {\n+            return clusterMap.getNumOfLeaves();\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** Return the distance between two nodes\n+     * It is assumed that the distance from one node to its parent is 1\n+     * The distance between two nodes is calculated by summing up their distances\n+     * to their closest common ancestor.\n+     * @param node1 one node\n+     * @param node2 another node\n+     * @return the distance between node1 and node2 which is zero if they are the same\n+     *  or {@link Integer#MAX_VALUE} if node1 or node2 do not belong to the cluster\n+     */\n+    public int getDistance(Node node1, Node node2) {\n+        if (node1 == node2) {\n+            return 0;\n+        }\n+        Node n1 = node1, n2 = node2;\n+        int dis = 0;\n+        netlock.readLock().lock();\n+        try {\n+            int level1 = node1.getLevel(), level2 = node2.getLevel();\n+            while (n1 != null && level1 > level2) {\n+                n1 = n1.getParent();\n+                level1--;\n+                dis++;\n+            }\n+            while (n2 != null && level2 > level1) {\n+                n2 = n2.getParent();\n+                level2--;\n+                dis++;\n+            }\n+            while (n1 != null && n2 != null && n1.getParent() != n2.getParent()) {\n+                n1 = n1.getParent();\n+                n2 = n2.getParent();\n+                dis += 2;\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+        if (n1 == null) {\n+            LOG.warn(\"The cluster does not contain node: \" + NodeBase.getPath(node1));\n+            return Integer.MAX_VALUE;\n+        }\n+        if (n2 == null) {\n+            LOG.warn(\"The cluster does not contain node: \" + NodeBase.getPath(node2));\n+            return Integer.MAX_VALUE;\n+        }\n+        return dis + 2;\n+    }\n+\n+    /** Check if two nodes are on the same rack\n+     * @param node1 one node (can be null)\n+     * @param node2 another node (can be null)\n+     * @return true if node1 and node2 are on the same rack; false otherwise\n+     * @exception IllegalArgumentException when either node1 or node2 is null, or\n+     * node1 or node2 do not belong to the cluster\n+     */\n+    public boolean isOnSameRack(Node node1, Node node2) {\n+        if (node1 == null || node2 == null) {\n+            return false;\n+        }\n+\n+        netlock.readLock().lock();\n+        try {\n+            return isSameParents(node1, node2);\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Check if network topology is aware of NodeGroup\n+     */\n+    public boolean isNodeGroupAware() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return false directly as not aware of NodeGroup, to be override in sub-class\n+     */\n+    public boolean isOnSameNodeGroup(Node node1, Node node2) {\n+        return false;\n+    }\n+\n+    /**\n+     * Compare the parents of each node for equality\n+     *\n+     * <p>To be overridden in subclasses for specific NetworkTopology\n+     * implementations, as alternative to overriding the full\n+     * {@link #isOnSameRack(Node, Node)} method.\n+     *\n+     * @param node1 the first node to compare\n+     * @param node2 the second node to compare\n+     * @return true if their parents are equal, false otherwise\n+     *\n+     * @see #isOnSameRack(Node, Node)\n+     */\n+    protected boolean isSameParents(Node node1, Node node2) {\n+        return node1.getParent() == node2.getParent();\n+    }\n+\n+    final protected static Random r = new Random();\n+\n+    /** randomly choose one node from <i>scope</i>\n+     * if scope starts with ~, choose one from the all nodes except for the\n+     * ones in <i>scope</i>; otherwise, choose one from <i>scope</i>\n+     * @param scope range of nodes from which a node will be chosen\n+     * @return the chosen node\n+     */\n+    public Node chooseRandom(String scope) {\n+        netlock.readLock().lock();\n+        try {\n+            if (scope.startsWith(\"~\")) {\n+                return chooseRandom(NodeBase.ROOT, scope.substring(1));\n+            } else {\n+                return chooseRandom(scope, null);\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    private Node chooseRandom(String scope, String excludedScope) {\n+        if (excludedScope != null) {\n+            if (scope.startsWith(excludedScope)) {\n+                return null;\n+            }\n+            if (!excludedScope.startsWith(scope)) {\n+                excludedScope = null;\n+            }\n+        }\n+        Node node = getNode(scope);\n+        if (!(node instanceof InnerNode)) {\n+            return node;\n+        }\n+        InnerNode innerNode = (InnerNode) node;\n+        int numOfDatanodes = innerNode.getNumOfLeaves();\n+        if (excludedScope == null) {\n+            node = null;\n+        } else {\n+            node = getNode(excludedScope);\n+            if (!(node instanceof InnerNode)) {\n+                numOfDatanodes -= 1;\n+            } else {\n+                numOfDatanodes -= ((InnerNode) node).getNumOfLeaves();\n+            }\n+        }\n+        int leaveIndex = r.nextInt(numOfDatanodes);\n+        return innerNode.getLeaf(leaveIndex, node);\n+    }\n+\n+    /** return leaves in <i>scope</i>\n+     * @param scope a path string\n+     * @return leaves nodes under specific scope\n+     */\n+    private Set<Node> doGetLeaves(String scope) {\n+        Node node = getNode(scope);\n+        Set<Node> leafNodes = new HashSet<Node>();\n+        if (!(node instanceof InnerNode)) {\n+            leafNodes.add(node);\n+        } else {\n+            InnerNode innerNode = (InnerNode) node;\n+            for (int i = 0; i < innerNode.getNumOfLeaves(); i++) {\n+                leafNodes.add(innerNode.getLeaf(i, null));\n+            }\n+        }\n+        return leafNodes;\n+    }\n+\n+    public Set<Node> getLeaves(String scope) {\n+        netlock.readLock().lock();\n+        try {\n+            if (scope.startsWith(\"~\")) {\n+                Set<Node> allNodes = doGetLeaves(NodeBase.ROOT);\n+                Set<Node> excludeNodes = doGetLeaves(scope.substring(1));\n+                allNodes.removeAll(excludeNodes);\n+                return allNodes;\n+            } else {\n+                return doGetLeaves(scope);\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** return the number of leaves in <i>scope</i> but not in <i>excludedNodes</i>\n+     * if scope starts with ~, return the number of nodes that are not\n+     * in <i>scope</i> and <i>excludedNodes</i>;\n+     * @param scope a path string that may start with ~\n+     * @param excludedNodes a list of nodes\n+     * @return number of available nodes\n+     */\n+    public int countNumOfAvailableNodes(String scope, Collection<Node> excludedNodes) {\n+        boolean isExcluded = false;\n+        if (scope.startsWith(\"~\")) {\n+            isExcluded = true;\n+            scope = scope.substring(1);\n+        }\n+        scope = NodeBase.normalize(scope);\n+        int count = 0; // the number of nodes in both scope & excludedNodes\n+        netlock.readLock().lock();\n+        try {\n+            for (Node node : excludedNodes) {\n+                if ((NodeBase.getPath(node) + NodeBase.PATH_SEPARATOR_STR).startsWith(scope\n+                        + NodeBase.PATH_SEPARATOR_STR)) {\n+                    count++;\n+                }\n+            }\n+            Node n = getNode(scope);\n+            int scopeNodeCount = 1;\n+            if (n instanceof InnerNode) {\n+                scopeNodeCount = ((InnerNode) n).getNumOfLeaves();\n+            }\n+            if (isExcluded) {\n+                return clusterMap.getNumOfLeaves() - scopeNodeCount - excludedNodes.size() + count;\n+            } else {\n+                return scopeNodeCount - count;\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** convert a network tree to a string */\n+    @Override\n+    public String toString() {\n+        // print the number of racks\n+        StringBuilder tree = new StringBuilder();\n+        tree.append(\"Number of racks: \");\n+        tree.append(numOfRacks);\n+        tree.append(\"\\n\");\n+        // print the number of leaves\n+        int numOfLeaves = getNumOfLeaves();\n+        tree.append(\"Expected number of leaves:\");\n+        tree.append(numOfLeaves);\n+        tree.append(\"\\n\");\n+        // print nodes\n+        for (int i = 0; i < numOfLeaves; i++) {\n+            tree.append(NodeBase.getPath(clusterMap.getLeaf(i, null)));\n+            tree.append(\"\\n\");\n+        }\n+        return tree.toString();\n+    }\n+\n+    /**\n+     * Divide networklocation string into two parts by last separator, and get\n+     * the first part here.\n+     *\n+     * @param networkLocation\n+     * @return\n+     */\n+    public static String getFirstHalf(String networkLocation) {\n+        int index = networkLocation.lastIndexOf(NodeBase.PATH_SEPARATOR_STR);\n+        return networkLocation.substring(0, index);\n+    }\n+\n+    /**\n+     * Divide networklocation string into two parts by last separator, and get\n+     * the second part here.\n+     *\n+     * @param networkLocation\n+     * @return\n+     */\n+    public static String getLastHalf(String networkLocation) {\n+        int index = networkLocation.lastIndexOf(NodeBase.PATH_SEPARATOR_STR);\n+        return networkLocation.substring(index);\n+    }\n+\n+    /** swap two array items */\n+    static protected void swap(Node[] nodes, int i, int j) {\n+        Node tempNode;\n+        tempNode = nodes[j];\n+        nodes[j] = nodes[i];\n+        nodes[i] = tempNode;\n+    }\n+\n+    /** Sort nodes array by their distances to <i>reader</i>\n+     * It linearly scans the array, if a local node is found, swap it with\n+     * the first element of the array.\n+     * If a local rack node is found, swap it with the first element following\n+     * the local node.\n+     * If neither local node or local rack node is found, put a random replica\n+     * location at position 0.\n+     * It leaves the rest nodes untouched.\n+     * @param reader the node that wishes to read a block from one of the nodes\n+     * @param nodes the list of nodes containing data for the reader\n+     */\n+    public void pseudoSortByDistance(Node reader, Node[] nodes) {\n+        int tempIndex = 0;\n+        int localRackNode = -1;\n+        if (reader != null) {\n+            //scan the array to find the local node & local rack node\n+            for (int i = 0; i < nodes.length; i++) {\n+                if (tempIndex == 0 && reader == nodes[i]) { //local node\n+                    //swap the local node and the node at position 0\n+                    if (i != 0) {\n+                        swap(nodes, tempIndex, i);\n+                    }\n+                    tempIndex = 1;\n+                    if (localRackNode != -1) {\n+                        if (localRackNode == 0) {\n+                            localRackNode = i;\n+                        }\n+                        break;\n+                    }\n+                } else if (localRackNode == -1 && isOnSameRack(reader, nodes[i])) {\n+                    //local rack\n+                    localRackNode = i;\n+                    if (tempIndex != 0)\n+                        break;\n+                }\n+            }\n+\n+            // swap the local rack node and the node at position tempIndex\n+            if (localRackNode != -1 && localRackNode != tempIndex) {\n+                swap(nodes, tempIndex, localRackNode);\n+                tempIndex++;\n+            }\n+        }\n+\n+        // put a random node at position 0 if it is not a local/local-rack node\n+        if (tempIndex == 0 && localRackNode == -1 && nodes.length != 0) {\n+            swap(nodes, 0, r.nextInt(nodes.length));\n+        }\n+    }\n+\n+}"},{"sha":"e5e696199fbf9cfd822385dd7a26acb741012eca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,61 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import com.google.common.annotations.Beta;\n+\n+/** The interface defines a node in a network topology.\n+ * A node may be a leave representing a data node or an inner\n+ * node representing a datacenter or rack.\n+ * Each data has a name and its location in the network is\n+ * decided by a string with syntax similar to a file name.\n+ * For example, a data node's name is hostname:port# and if it's located at\n+ * rack \"orange\" in datacenter \"dog\", the string representation of its\n+ * network location is /dog/orange\n+ */\n+@Beta\n+public interface Node {\n+    /** @return the string representation of this node's network location */\n+    public String getNetworkLocation();\n+\n+    /** Set this node's network location\n+     * @param location the location\n+     */\n+    public void setNetworkLocation(String location);\n+\n+    /** @return this node's name */\n+    public String getName();\n+\n+    /** @return this node's parent */\n+    public Node getParent();\n+\n+    /** Set this node's parent\n+     * @param parent the parent\n+     */\n+    public void setParent(Node parent);\n+\n+    /** @return this node's level in the tree.\n+     * E.g. the root of a tree returns 0 and its children return 1\n+     */\n+    public int getLevel();\n+\n+    /** Set this node's level in the tree\n+     * @param i the level\n+     */\n+    public void setLevel(int i);\n+}"},{"sha":"2f081b04a2447a26874dd71ea4824273bae48327","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,185 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+/** A base class that implements interface Node\n+ *\n+ */\n+public class NodeBase implements Node {\n+    /** Path separator {@value} */\n+    public final static char PATH_SEPARATOR = '/';\n+    /** Path separator as a string {@value} */\n+    public final static String PATH_SEPARATOR_STR = \"/\";\n+    /** string representation of root {@value} */\n+    public final static String ROOT = \"\";\n+\n+    protected String name; //host:port#\n+    protected String location; //string representation of this node's location\n+    protected int level; //which level of the tree the node resides\n+    protected Node parent; //its parent\n+\n+    /** Default constructor */\n+    public NodeBase() {\n+    }\n+\n+    /** Construct a node from its path\n+     * @param path\n+     *   a concatenation of this node's location, the path seperator, and its name\n+     */\n+    public NodeBase(String path) {\n+        path = normalize(path);\n+        int index = path.lastIndexOf(PATH_SEPARATOR);\n+        if (index == -1) {\n+            set(ROOT, path);\n+        } else {\n+            set(path.substring(index + 1), path.substring(0, index));\n+        }\n+    }\n+\n+    /** Construct a node from its name and its location\n+     * @param name this node's name (can be null, must not contain {@link #PATH_SEPARATOR})\n+     * @param location this node's location\n+     */\n+    public NodeBase(String name, String location) {\n+        set(name, normalize(location));\n+    }\n+\n+    /** Construct a node from its name and its location\n+     * @param name this node's name (can be null, must not contain {@link #PATH_SEPARATOR})\n+     * @param location this node's location\n+     * @param parent this node's parent node\n+     * @param level this node's level in the tree\n+     */\n+    public NodeBase(String name, String location, Node parent, int level) {\n+        set(name, normalize(location));\n+        this.parent = parent;\n+        this.level = level;\n+    }\n+\n+    /**\n+     * set this node's name and location\n+     * @param name the (nullable) name -which cannot contain the {@link #PATH_SEPARATOR}\n+     * @param location the location\n+     */\n+    private void set(String name, String location) {\n+        if (name != null && name.contains(PATH_SEPARATOR_STR))\n+            throw new IllegalArgumentException(\"Network location name contains /: \" + name);\n+        this.name = (name == null) ? \"\" : name;\n+        this.location = location;\n+    }\n+\n+    /** @return this node's name */\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /** @return this node's network location */\n+    @Override\n+    public String getNetworkLocation() {\n+        return location;\n+    }\n+\n+    /** Set this node's network location\n+     * @param location the location\n+     */\n+    @Override\n+    public void setNetworkLocation(String location) {\n+        this.location = location;\n+    }\n+\n+    /**\n+     * Get the path of a node\n+     * @param node a non-null node\n+     * @return the path of a node\n+     */\n+    public static String getPath(Node node) {\n+        return node.getNetworkLocation() + PATH_SEPARATOR_STR + node.getName();\n+    }\n+\n+    /** @return this node's path as its string representation */\n+    @Override\n+    public String toString() {\n+        return getPath(this);\n+    }\n+\n+    /** Normalize a path by stripping off any trailing {@link #PATH_SEPARATOR}\n+     * @param path path to normalize.\n+     * @return the normalised path\n+     * If <i>path</i>is null or empty {@link #ROOT} is returned\n+     * @throws IllegalArgumentException if the first character of a non empty path\n+     * is not {@link #PATH_SEPARATOR}\n+     */\n+    public static String normalize(String path) {\n+        if (path == null || path.length() == 0)\n+            return ROOT;\n+\n+        if (path.charAt(0) != PATH_SEPARATOR) {\n+            throw new IllegalArgumentException(\"Network Location path does not start with \" + PATH_SEPARATOR_STR + \": \"\n+                    + path);\n+        }\n+\n+        int len = path.length();\n+        if (path.charAt(len - 1) == PATH_SEPARATOR) {\n+            return path.substring(0, len - 1);\n+        }\n+        return path;\n+    }\n+\n+    /** @return this node's parent */\n+    @Override\n+    public Node getParent() {\n+        return parent;\n+    }\n+\n+    /** Set this node's parent\n+     * @param parent the parent\n+     */\n+    @Override\n+    public void setParent(Node parent) {\n+        this.parent = parent;\n+    }\n+\n+    /** @return this node's level in the tree.\n+     * E.g. the root of a tree returns 0 and its children return 1\n+     */\n+    @Override\n+    public int getLevel() {\n+        return level;\n+    }\n+\n+    /** Set this node's level in the tree\n+     * @param level the level\n+     */\n+    @Override\n+    public void setLevel(int level) {\n+        this.level = level;\n+    }\n+\n+    public static int locationToDepth(String location) {\n+        String normalizedLocation = normalize(location);\n+        int length = normalizedLocation.length();\n+        int depth = 0;\n+        for (int i = 0; i < length; i++) {\n+            if (normalizedLocation.charAt(i) == PATH_SEPARATOR) {\n+                depth++;\n+            }\n+        }\n+        return depth;\n+    }\n+}"},{"sha":"dd8563cc058ca7e118005ddc5baaf9c6d825ffe9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","status":"added","additions":264,"deletions":0,"changes":264,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,264 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.net;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.bookkeeper.util.Shell.ShellCommandExecutor;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+/**\n+ * This class implements the {@link DNSToSwitchMapping} interface using a\n+ * script configured via the\n+ * {@link CommonConfigurationKeys#NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY} option.\n+ * <p/>\n+ * It contains a static class <code>RawScriptBasedMapping</code> that performs\n+ * the work: reading the configuration parameters, executing any defined\n+ * script, handling errors and such like. The outer\n+ * class extends {@link CachedDNSToSwitchMapping} to cache the delegated\n+ * queries.\n+ * <p/>\n+ * This DNS mapper's {@link #isSingleSwitch()} predicate returns\n+ * true if and only if a script is defined.\n+ */\n+public final class ScriptBasedMapping extends CachedDNSToSwitchMapping {\n+\n+    /**\n+     * Minimum number of arguments: {@value}\n+     */\n+    static final int MIN_ALLOWABLE_ARGS = 1;\n+\n+    /**\n+     * Default number of arguments: {@value}\n+     */\n+    static final int DEFAULT_ARG_COUNT = CommonConfigurationKeys.NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_DEFAULT;\n+\n+    /**\n+     * key to the script filename {@value}\n+     */\n+    static final String SCRIPT_FILENAME_KEY = CommonConfigurationKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY;\n+    /**\n+     * key to the argument count that the script supports\n+     * {@value}\n+     */\n+    static final String SCRIPT_ARG_COUNT_KEY = CommonConfigurationKeys.NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY;\n+    /**\n+     * Text used in the {@link #toString()} method if there is no string\n+     * {@value}\n+     */\n+    public static final String NO_SCRIPT = \"no script\";\n+\n+    /**\n+     * Create an instance with the default configuration.\n+     * </p>\n+     * Calling {@link #setConf(Configuration)} will trigger a\n+     * re-evaluation of the configuration settings and so be used to\n+     * set up the mapping script.\n+     *\n+     */\n+    public ScriptBasedMapping() {\n+        super(new RawScriptBasedMapping());\n+    }\n+\n+    /**\n+     * Create an instance from the given configuration\n+     * @param conf configuration\n+     */\n+    public ScriptBasedMapping(Configuration conf) {\n+        this();\n+        setConf(conf);\n+    }\n+\n+    /**\n+     * Get the cached mapping and convert it to its real type\n+     * @return the inner raw script mapping.\n+     */\n+    private RawScriptBasedMapping getRawMapping() {\n+        return (RawScriptBasedMapping) rawMapping;\n+    }\n+\n+    @Override\n+    public Configuration getConf() {\n+        return getRawMapping().getConf();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"script-based mapping with \" + getRawMapping().toString();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p/>\n+     * This will get called in the superclass constructor, so a check is needed\n+     * to ensure that the raw mapping is defined before trying to relaying a null\n+     * configuration.\n+     * @param conf\n+     */\n+    @Override\n+    public void setConf(Configuration conf) {\n+        super.setConf(conf);\n+        getRawMapping().setConf(conf);\n+    }\n+\n+    /**\n+     * This is the uncached script mapping that is fed into the cache managed\n+     * by the superclass {@link CachedDNSToSwitchMapping}\n+     */\n+    private static final class RawScriptBasedMapping extends AbstractDNSToSwitchMapping {\n+        private String scriptName;\n+        private int maxArgs; //max hostnames per call of the script\n+        private static final Log LOG = LogFactory.getLog(ScriptBasedMapping.class);\n+\n+        /**\n+         * Set the configuration and extract the configuration parameters of interest\n+         * @param conf the new configuration\n+         */\n+        @Override\n+        public void setConf(Configuration conf) {\n+            super.setConf(conf);\n+            if (conf != null) {\n+                scriptName = conf.getString(SCRIPT_FILENAME_KEY);\n+                maxArgs = conf.getInt(SCRIPT_ARG_COUNT_KEY, DEFAULT_ARG_COUNT);\n+            } else {\n+                scriptName = null;\n+                maxArgs = 0;\n+            }\n+        }\n+\n+        /**\n+         * Constructor. The mapping is not ready to use until\n+         * {@link #setConf(Configuration)} has been called\n+         */\n+        public RawScriptBasedMapping() {\n+        }\n+\n+        @Override\n+        public List<String> resolve(List<String> names) {\n+            List<String> m = new ArrayList<String>(names.size());\n+\n+            if (names.isEmpty()) {\n+                return m;\n+            }\n+\n+            if (scriptName == null) {\n+                for (int i = 0; i < names.size(); i++) {\n+                    m.add(NetworkTopology.DEFAULT_RACK);\n+                }\n+                return m;\n+            }\n+\n+            String output = runResolveCommand(names);\n+            if (output != null) {\n+                StringTokenizer allSwitchInfo = new StringTokenizer(output);\n+                while (allSwitchInfo.hasMoreTokens()) {\n+                    String switchInfo = allSwitchInfo.nextToken();\n+                    m.add(switchInfo);\n+                }\n+\n+                if (m.size() != names.size()) {\n+                    // invalid number of entries returned by the script\n+                    LOG.error(\"Script \" + scriptName + \" returned \" + Integer.toString(m.size()) + \" values when \"\n+                            + Integer.toString(names.size()) + \" were expected.\");\n+                    return null;\n+                }\n+            } else {\n+                // an error occurred. return null to signify this.\n+                // (exn was already logged in runResolveCommand)\n+                return null;\n+            }\n+\n+            return m;\n+        }\n+\n+        /**\n+         * Build and execute the resolution command. The command is\n+         * executed in the directory specified by the system property\n+         * \"user.dir\" if set; otherwise the current working directory is used\n+         * @param args a list of arguments\n+         * @return null if the number of arguments is out of range,\n+         * or the output of the command.\n+         */\n+        private String runResolveCommand(List<String> args) {\n+            int loopCount = 0;\n+            if (args.size() == 0) {\n+                return null;\n+            }\n+            StringBuilder allOutput = new StringBuilder();\n+            int numProcessed = 0;\n+            if (maxArgs < MIN_ALLOWABLE_ARGS) {\n+                LOG.warn(\"Invalid value \" + Integer.toString(maxArgs) + \" for \" + SCRIPT_ARG_COUNT_KEY\n+                        + \"; must be >= \" + Integer.toString(MIN_ALLOWABLE_ARGS));\n+                return null;\n+            }\n+\n+            while (numProcessed != args.size()) {\n+                int start = maxArgs * loopCount;\n+                List<String> cmdList = new ArrayList<String>();\n+                cmdList.add(scriptName);\n+                for (numProcessed = start;\n+                     numProcessed < (start + maxArgs) && numProcessed < args.size();\n+                     numProcessed++) {\n+                    cmdList.add(args.get(numProcessed));\n+                }\n+                File dir = null;\n+                String userDir;\n+                if ((userDir = System.getProperty(\"user.dir\")) != null) {\n+                    dir = new File(userDir);\n+                }\n+                ShellCommandExecutor s = new ShellCommandExecutor(cmdList.toArray(new String[cmdList.size()]), dir);\n+                try {\n+                    s.execute();\n+                    allOutput.append(s.getOutput()).append(\" \");\n+                } catch (Exception e) {\n+                    LOG.warn(\"Exception running \" + s, e);\n+                    return null;\n+                }\n+                loopCount++;\n+            }\n+            return allOutput.toString();\n+        }\n+\n+        /**\n+         * Declare that the mapper is single-switched if a script was not named\n+         * in the configuration.\n+         * @return true iff there is no script\n+         */\n+        @Override\n+        public boolean isSingleSwitch() {\n+            return scriptName == null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return scriptName != null ? (\"script \" + scriptName) : NO_SCRIPT;\n+        }\n+\n+        @Override\n+        public void reloadCachedMappings() {\n+            // Nothing to do here, since RawScriptBasedMapping has no cache, and\n+            // does not inherit from CachedDNSToSwitchMapping\n+        }\n+    }\n+}"},{"sha":"5dbfc381359acb9deda890db1b312e4f02dedf22","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","status":"added","additions":677,"deletions":0,"changes":677,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,677 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.util;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import com.google.common.base.Charsets;\n+\n+/**\n+ * A base class for running a Unix command.\n+ *\n+ * <code>Shell</code> can be used to run unix commands like <code>du</code> or\n+ * <code>df</code>. It also offers facilities to gate commands by\n+ * time-intervals.\n+ */\n+abstract public class Shell {\n+\n+    public static final Log LOG = LogFactory.getLog(Shell.class);\n+\n+    private static boolean IS_JAVA7_OR_ABOVE =\n+        System.getProperty(\"java.version\").substring(0, 3).compareTo(\"1.7\") >= 0;\n+\n+    public static boolean isJava7OrAbove() {\n+        return IS_JAVA7_OR_ABOVE;\n+    }\n+\n+    /** a Unix command to get the current user's name */\n+    public final static String USER_NAME_COMMAND = \"whoami\";\n+\n+    /** Windows CreateProcess synchronization object */\n+    public static final Object WindowsProcessLaunchLock = new Object();\n+\n+    /** a Unix command to get the current user's groups list */\n+    public static String[] getGroupsCommand() {\n+        return (WINDOWS) ? new String[] { \"cmd\", \"/c\", \"groups\" } : new String[] { \"bash\", \"-c\", \"groups\" };\n+    }\n+\n+    /** a Unix command to get a given user's groups list */\n+    public static String[] getGroupsForUserCommand(final String user) {\n+        //'groups username' command return is non-consistent across different unixes\n+        return (WINDOWS) ? new String[] { WINUTILS, \"groups\", \"-F\", \"\\\"\" + user + \"\\\"\" } : new String[] { \"bash\", \"-c\",\n+                \"id -Gn \" + user };\n+    }\n+\n+    /** a Unix command to get a given netgroup's user list */\n+    public static String[] getUsersForNetgroupCommand(final String netgroup) {\n+        //'groups username' command return is non-consistent across different unixes\n+        return (WINDOWS) ? new String[] { \"cmd\", \"/c\", \"getent netgroup \" + netgroup } : new String[] { \"bash\", \"-c\",\n+                \"getent netgroup \" + netgroup };\n+    }\n+\n+    /** Return a command to get permission information. */\n+    public static String[] getGetPermissionCommand() {\n+        return (WINDOWS) ? new String[] { WINUTILS, \"ls\", \"-F\" } : new String[] { \"/bin/ls\", \"-ld\" };\n+    }\n+\n+    /** Return a command to set permission */\n+    public static String[] getSetPermissionCommand(String perm, boolean recursive) {\n+        if (recursive) {\n+            return (WINDOWS) ? new String[] { WINUTILS, \"chmod\", \"-R\", perm } : new String[] { \"chmod\", \"-R\", perm };\n+        } else {\n+            return (WINDOWS) ? new String[] { WINUTILS, \"chmod\", perm } : new String[] { \"chmod\", perm };\n+        }\n+    }\n+\n+    /**\n+     * Return a command to set permission for specific file.\n+     *\n+     * @param perm String permission to set\n+     * @param recursive boolean true to apply to all sub-directories recursively\n+     * @param file String file to set\n+     * @return String[] containing command and arguments\n+     */\n+    public static String[] getSetPermissionCommand(String perm, boolean recursive, String file) {\n+        String[] baseCmd = getSetPermissionCommand(perm, recursive);\n+        String[] cmdWithFile = Arrays.copyOf(baseCmd, baseCmd.length + 1);\n+        cmdWithFile[cmdWithFile.length - 1] = file;\n+        return cmdWithFile;\n+    }\n+\n+    /** Return a command to set owner */\n+    public static String[] getSetOwnerCommand(String owner) {\n+        return (WINDOWS) ? new String[] { WINUTILS, \"chown\", \"\\\"\" + owner + \"\\\"\" } : new String[] { \"chown\", owner };\n+    }\n+\n+    /** Return a command to create symbolic links */\n+    public static String[] getSymlinkCommand(String target, String link) {\n+        return WINDOWS ? new String[] { WINUTILS, \"symlink\", link, target } : new String[] { \"ln\", \"-s\", target, link };\n+    }\n+\n+    /** Return a command for determining if process with specified pid is alive. */\n+    public static String[] getCheckProcessIsAliveCommand(String pid) {\n+        return Shell.WINDOWS ? new String[] { Shell.WINUTILS, \"task\", \"isAlive\", pid } : new String[] { \"kill\", \"-0\",\n+                isSetsidAvailable ? \"-\" + pid : pid };\n+    }\n+\n+    /** Return a command to send a signal to a given pid */\n+    public static String[] getSignalKillCommand(int code, String pid) {\n+        return Shell.WINDOWS ? new String[] { Shell.WINUTILS, \"task\", \"kill\", pid } : new String[] { \"kill\",\n+                \"-\" + code, isSetsidAvailable ? \"-\" + pid : pid };\n+    }\n+\n+    /**\n+     * Returns a File referencing a script with the given basename, inside the\n+     * given parent directory.  The file extension is inferred by platform: \".cmd\"\n+     * on Windows, or \".sh\" otherwise.\n+     *\n+     * @param parent File parent directory\n+     * @param basename String script file basename\n+     * @return File referencing the script in the directory\n+     */\n+    public static File appendScriptExtension(File parent, String basename) {\n+        return new File(parent, appendScriptExtension(basename));\n+    }\n+\n+    /**\n+     * Returns a script file name with the given basename.  The file extension is\n+     * inferred by platform: \".cmd\" on Windows, or \".sh\" otherwise.\n+     *\n+     * @param basename String script file basename\n+     * @return String script file name\n+     */\n+    public static String appendScriptExtension(String basename) {\n+        return basename + (WINDOWS ? \".cmd\" : \".sh\");\n+    }\n+\n+    /**\n+     * Returns a command to run the given script.  The script interpreter is\n+     * inferred by platform: cmd on Windows or bash otherwise.\n+     *\n+     * @param script File script to run\n+     * @return String[] command to run the script\n+     */\n+    public static String[] getRunScriptCommand(File script) {\n+        String absolutePath = script.getAbsolutePath();\n+        return WINDOWS ? new String[] { \"cmd\", \"/c\", absolutePath } : new String[] { \"/bin/bash\", absolutePath };\n+    }\n+\n+    /** a Unix command to set permission */\n+    public static final String SET_PERMISSION_COMMAND = \"chmod\";\n+    /** a Unix command to set owner */\n+    public static final String SET_OWNER_COMMAND = \"chown\";\n+\n+    /** a Unix command to set the change user's groups list */\n+    public static final String SET_GROUP_COMMAND = \"chgrp\";\n+    /** a Unix command to create a link */\n+    public static final String LINK_COMMAND = \"ln\";\n+    /** a Unix command to get a link target */\n+    public static final String READ_LINK_COMMAND = \"readlink\";\n+\n+    /**Time after which the executing script would be timedout*/\n+    protected long timeOutInterval = 0L;\n+    /** If or not script timed out*/\n+    private AtomicBoolean timedOut;\n+\n+    /** Centralized logic to discover and validate the sanity of the Hadoop\n+     *  home directory. Returns either NULL or a directory that exists and\n+     *  was specified via either -Dhadoop.home.dir or the HADOOP_HOME ENV\n+     *  variable.  This does a lot of work so it should only be called\n+     *  privately for initialization once per process.\n+     **/\n+    private static String checkHadoopHome() {\n+\n+        // first check the Dflag hadoop.home.dir with JVM scope\n+        String home = System.getProperty(\"hadoop.home.dir\");\n+\n+        // fall back to the system/user-global env variable\n+        if (home == null) {\n+            home = System.getenv(\"HADOOP_HOME\");\n+        }\n+\n+        try {\n+            // couldn't find either setting for hadoop's home directory\n+            if (home == null) {\n+                throw new IOException(\"HADOOP_HOME or hadoop.home.dir are not set.\");\n+            }\n+\n+            if (home.startsWith(\"\\\"\") && home.endsWith(\"\\\"\")) {\n+                home = home.substring(1, home.length() - 1);\n+            }\n+\n+            // check that the home setting is actually a directory that exists\n+            File homedir = new File(home);\n+            if (!homedir.isAbsolute() || !homedir.exists() || !homedir.isDirectory()) {\n+                throw new IOException(\"Hadoop home directory \" + homedir\n+                        + \" does not exist, is not a directory, or is not an absolute path.\");\n+            }\n+\n+            home = homedir.getCanonicalPath();\n+\n+        } catch (IOException ioe) {\n+            LOG.error(\"Failed to detect a valid hadoop home directory\", ioe);\n+            home = null;\n+        }\n+\n+        return home;\n+    }\n+\n+    private static String HADOOP_HOME_DIR = checkHadoopHome();\n+\n+    // Public getter, throws an exception if HADOOP_HOME failed validation\n+    // checks and is being referenced downstream.\n+    public static final String getHadoopHome() throws IOException {\n+        if (HADOOP_HOME_DIR == null) {\n+            throw new IOException(\"Misconfigured HADOOP_HOME cannot be referenced.\");\n+        }\n+\n+        return HADOOP_HOME_DIR;\n+    }\n+\n+    /** fully qualify the path to a binary that should be in a known hadoop\n+     *  bin location. This is primarily useful for disambiguating call-outs\n+     *  to executable sub-components of Hadoop to avoid clashes with other\n+     *  executables that may be in the path.  Caveat:  this call doesn't\n+     *  just format the path to the bin directory.  It also checks for file\n+     *  existence of the composed path. The output of this call should be\n+     *  cached by callers.\n+     * */\n+    public static final String getQualifiedBinPath(String executable) throws IOException {\n+        // construct hadoop bin path to the specified executable\n+        String fullExeName = HADOOP_HOME_DIR + File.separator + \"bin\" + File.separator + executable;\n+\n+        File exeFile = new File(fullExeName);\n+        if (!exeFile.exists()) {\n+            throw new IOException(\"Could not locate executable \" + fullExeName + \" in the Hadoop binaries.\");\n+        }\n+\n+        return exeFile.getCanonicalPath();\n+    }\n+\n+    /** Set to true on Windows platforms */\n+    public static final boolean WINDOWS /* borrowed from Path.WINDOWS */\n+    = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    public static final boolean LINUX = System.getProperty(\"os.name\").startsWith(\"Linux\");\n+\n+    /** a Windows utility to emulate Unix commands */\n+    public static final String WINUTILS = getWinUtilsPath();\n+\n+    public static final String getWinUtilsPath() {\n+        String winUtilsPath = null;\n+\n+        try {\n+            if (WINDOWS) {\n+                winUtilsPath = getQualifiedBinPath(\"winutils.exe\");\n+            }\n+        } catch (IOException ioe) {\n+            LOG.error(\"Failed to locate the winutils binary in the hadoop binary path\", ioe);\n+        }\n+\n+        return winUtilsPath;\n+    }\n+\n+    public static final boolean isSetsidAvailable = isSetsidSupported();\n+\n+    private static boolean isSetsidSupported() {\n+        if (Shell.WINDOWS) {\n+            return false;\n+        }\n+        ShellCommandExecutor shexec = null;\n+        boolean setsidSupported = true;\n+        try {\n+            String[] args = { \"setsid\", \"bash\", \"-c\", \"echo $$\" };\n+            shexec = new ShellCommandExecutor(args);\n+            shexec.execute();\n+        } catch (IOException ioe) {\n+            LOG.warn(\"setsid is not available on this machine. So not using it.\");\n+            setsidSupported = false;\n+        } finally { // handle the exit code\n+            if (null != shexec) {\n+                LOG.info(\"setsid exited with exit code \" + shexec.getExitCode());\n+            }\n+        }\n+        return setsidSupported;\n+    }\n+\n+    /** Token separator regex used to parse Shell tool outputs */\n+    public static final String TOKEN_SEPARATOR_REGEX = WINDOWS ? \"[|\\n\\r]\" : \"[ \\t\\n\\r\\f]\";\n+\n+    private long interval; // refresh interval in msec\n+    private long lastTime; // last time the command was performed\n+    private Map<String, String> environment; // env for the command execution\n+    private File dir;\n+    private Process process; // sub process used to execute the command\n+    private int exitCode;\n+\n+    /**If or not script finished executing*/\n+    private volatile AtomicBoolean completed;\n+\n+    public Shell() {\n+        this(0L);\n+    }\n+\n+    /**\n+     * @param interval the minimum duration to wait before re-executing the\n+     *        command.\n+     */\n+    public Shell(long interval) {\n+        this.interval = interval;\n+        this.lastTime = (interval < 0) ? 0 : -interval;\n+    }\n+\n+    /** set the environment for the command\n+     * @param env Mapping of environment variables\n+     */\n+    protected void setEnvironment(Map<String, String> env) {\n+        this.environment = env;\n+    }\n+\n+    /** set the working directory\n+     * @param dir The directory where the command would be executed\n+     */\n+    protected void setWorkingDirectory(File dir) {\n+        this.dir = dir;\n+    }\n+\n+    /** check to see if a command needs to be executed and execute if needed */\n+    protected void run() throws IOException {\n+        if (lastTime + interval > MathUtils.now())\n+            return;\n+        exitCode = 0; // reset for next run\n+        runCommand();\n+    }\n+\n+    /** Run a command */\n+    private void runCommand() throws IOException {\n+        ProcessBuilder builder = new ProcessBuilder(getExecString());\n+        Timer timeOutTimer = null;\n+        ShellTimeoutTimerTask timeoutTimerTask = null;\n+        timedOut = new AtomicBoolean(false);\n+        completed = new AtomicBoolean(false);\n+\n+        if (environment != null) {\n+            builder.environment().putAll(this.environment);\n+        }\n+        if (dir != null) {\n+            builder.directory(this.dir);\n+        }\n+\n+        if (Shell.WINDOWS) {\n+            synchronized (WindowsProcessLaunchLock) {\n+                // To workaround the race condition issue with child processes\n+                // inheriting unintended handles during process launch that can\n+                // lead to hangs on reading output and error streams, we\n+                // serialize process creation. More info available at:\n+                // http://support.microsoft.com/kb/315939\n+                process = builder.start();\n+            }\n+        } else {\n+            process = builder.start();\n+        }\n+\n+        if (timeOutInterval > 0) {\n+            timeOutTimer = new Timer(\"Shell command timeout\");\n+            timeoutTimerTask = new ShellTimeoutTimerTask(this);\n+            //One time scheduling.\n+            timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n+        }\n+        final BufferedReader errReader = new BufferedReader(new InputStreamReader(process.getErrorStream(),\n+                Charsets.UTF_8));\n+        BufferedReader inReader = new BufferedReader(new InputStreamReader(process.getInputStream(), Charsets.UTF_8));\n+        final StringBuffer errMsg = new StringBuffer();\n+\n+        // read error and input streams as this would free up the buffers\n+        // free the error stream buffer\n+        Thread errThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    String line = errReader.readLine();\n+                    while ((line != null) && !isInterrupted()) {\n+                        errMsg.append(line);\n+                        errMsg.append(System.getProperty(\"line.separator\"));\n+                        line = errReader.readLine();\n+                    }\n+                } catch (IOException ioe) {\n+                    LOG.warn(\"Error reading the error stream\", ioe);\n+                }\n+            }\n+        };\n+        try {\n+            errThread.start();\n+        } catch (IllegalStateException ise) {\n+        }\n+        try {\n+            parseExecResult(inReader); // parse the output\n+            // clear the input stream buffer\n+            String line = inReader.readLine();\n+            while (line != null) {\n+                line = inReader.readLine();\n+            }\n+            // wait for the process to finish and check the exit code\n+            exitCode = process.waitFor();\n+            try {\n+                // make sure that the error thread exits\n+                errThread.join();\n+            } catch (InterruptedException ie) {\n+                LOG.warn(\"Interrupted while reading the error stream\", ie);\n+            }\n+            completed.set(true);\n+            //the timeout thread handling\n+            //taken care in finally block\n+            if (exitCode != 0) {\n+                throw new ExitCodeException(exitCode, errMsg.toString());\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new IOException(ie.toString());\n+        } finally {\n+            if (timeOutTimer != null) {\n+                timeOutTimer.cancel();\n+            }\n+            // close the input stream\n+            try {\n+                inReader.close();\n+            } catch (IOException ioe) {\n+                LOG.warn(\"Error while closing the input stream\", ioe);\n+            }\n+            if (!completed.get()) {\n+                errThread.interrupt();\n+            }\n+            try {\n+                errReader.close();\n+            } catch (IOException ioe) {\n+                LOG.warn(\"Error while closing the error stream\", ioe);\n+            }\n+            process.destroy();\n+            lastTime = MathUtils.now();\n+        }\n+    }\n+\n+    /** return an array containing the command name & its parameters */\n+    protected abstract String[] getExecString();\n+\n+    /** Parse the execution result */\n+    protected abstract void parseExecResult(BufferedReader lines) throws IOException;\n+\n+    /** get the current sub-process executing the given command\n+     * @return process executing the command\n+     */\n+    public Process getProcess() {\n+        return process;\n+    }\n+\n+    /** get the exit code\n+     * @return the exit code of the process\n+     */\n+    public int getExitCode() {\n+        return exitCode;\n+    }\n+\n+    /**\n+     * This is an IOException with exit code added.\n+     */\n+    public static class ExitCodeException extends IOException {\n+        private static final long serialVersionUID = 2241095121609500810L;\n+\n+        int exitCode;\n+\n+        public ExitCodeException(int exitCode, String message) {\n+            super(message);\n+            this.exitCode = exitCode;\n+        }\n+\n+        public int getExitCode() {\n+            return exitCode;\n+        }\n+    }\n+\n+    /**\n+     * A simple shell command executor.\n+     *\n+     * <code>ShellCommandExecutor</code>should be used in cases where the output\n+     * of the command needs no explicit parsing and where the command, working\n+     * directory and the environment remains unchanged. The output of the command\n+     * is stored as-is and is expected to be small.\n+     */\n+    public static class ShellCommandExecutor extends Shell {\n+\n+        private String[] command;\n+        private StringBuffer output;\n+\n+        public ShellCommandExecutor(String[] execString) {\n+            this(execString, null);\n+        }\n+\n+        public ShellCommandExecutor(String[] execString, File dir) {\n+            this(execString, dir, null);\n+        }\n+\n+        public ShellCommandExecutor(String[] execString, File dir, Map<String, String> env) {\n+            this(execString, dir, env, 0L);\n+        }\n+\n+        /**\n+         * Create a new instance of the ShellCommandExecutor to execute a command.\n+         *\n+         * @param execString The command to execute with arguments\n+         * @param dir If not-null, specifies the directory which should be set\n+         *            as the current working directory for the command.\n+         *            If null, the current working directory is not modified.\n+         * @param env If not-null, environment of the command will include the\n+         *            key-value pairs specified in the map. If null, the current\n+         *            environment is not modified.\n+         * @param timeout Specifies the time in milliseconds, after which the\n+         *                command will be killed and the status marked as timedout.\n+         *                If 0, the command will not be timed out.\n+         */\n+        public ShellCommandExecutor(String[] execString, File dir, Map<String, String> env, long timeout) {\n+            command = execString.clone();\n+            if (dir != null) {\n+                setWorkingDirectory(dir);\n+            }\n+            if (env != null) {\n+                setEnvironment(env);\n+            }\n+            timeOutInterval = timeout;\n+        }\n+\n+        /** Execute the shell command. */\n+        public void execute() throws IOException {\n+            this.run();\n+        }\n+\n+        @Override\n+        public String[] getExecString() {\n+            return command.clone();\n+        }\n+\n+        @Override\n+        protected void parseExecResult(BufferedReader lines) throws IOException {\n+            output = new StringBuffer();\n+            char[] buf = new char[512];\n+            int nRead;\n+            while ((nRead = lines.read(buf, 0, buf.length)) > 0) {\n+                output.append(buf, 0, nRead);\n+            }\n+        }\n+\n+        /** Get the output of the shell command.*/\n+        public String getOutput() {\n+            return (output == null) ? \"\" : output.toString();\n+        }\n+\n+        /**\n+         * Returns the commands of this instance.\n+         * Arguments with spaces in are presented with quotes round; other\n+         * arguments are presented raw\n+         *\n+         * @return a string representation of the object.\n+         */\n+        @Override\n+        public String toString() {\n+            StringBuilder builder = new StringBuilder();\n+            String[] args = getExecString();\n+            for (String s : args) {\n+                if (s.indexOf(' ') >= 0) {\n+                    builder.append('\"').append(s).append('\"');\n+                } else {\n+                    builder.append(s);\n+                }\n+                builder.append(' ');\n+            }\n+            return builder.toString();\n+        }\n+    }\n+\n+    /**\n+     * To check if the passed script to shell command executor timed out or\n+     * not.\n+     *\n+     * @return if the script timed out.\n+     */\n+    public boolean isTimedOut() {\n+        return timedOut.get();\n+    }\n+\n+    /**\n+     * Set if the command has timed out.\n+     *\n+     */\n+    private void setTimedOut() {\n+        this.timedOut.set(true);\n+    }\n+\n+    /**\n+     * Static method to execute a shell command.\n+     * Covers most of the simple cases without requiring the user to implement\n+     * the <code>Shell</code> interface.\n+     * @param cmd shell command to execute.\n+     * @return the output of the executed command.\n+     */\n+    public static String execCommand(String... cmd) throws IOException {\n+        return execCommand(null, cmd, 0L);\n+    }\n+\n+    /**\n+     * Static method to execute a shell command.\n+     * Covers most of the simple cases without requiring the user to implement\n+     * the <code>Shell</code> interface.\n+     * @param env the map of environment key=value\n+     * @param cmd shell command to execute.\n+     * @param timeout time in milliseconds after which script should be marked timeout\n+     * @return the output of the executed command.o\n+     */\n+\n+    public static String execCommand(Map<String, String> env, String[] cmd, long timeout) throws IOException {\n+        ShellCommandExecutor exec = new ShellCommandExecutor(cmd, null, env, timeout);\n+        exec.execute();\n+        return exec.getOutput();\n+    }\n+\n+    /**\n+     * Static method to execute a shell command.\n+     * Covers most of the simple cases without requiring the user to implement\n+     * the <code>Shell</code> interface.\n+     * @param env the map of environment key=value\n+     * @param cmd shell command to execute.\n+     * @return the output of the executed command.\n+     */\n+    public static String execCommand(Map<String, String> env, String... cmd) throws IOException {\n+        return execCommand(env, cmd, 0L);\n+    }\n+\n+    /**\n+     * Timer which is used to timeout scripts spawned off by shell.\n+     */\n+    private static class ShellTimeoutTimerTask extends TimerTask {\n+\n+        private Shell shell;\n+\n+        public ShellTimeoutTimerTask(Shell shell) {\n+            this.shell = shell;\n+        }\n+\n+        @Override\n+        public void run() {\n+            Process p = shell.getProcess();\n+            try {\n+                p.exitValue();\n+            } catch (Exception e) {\n+                //Process has not terminated.\n+                //So check if it has completed\n+                //if not just destroy it.\n+                if (p != null && !shell.completed.get()) {\n+                    shell.setTimedOut();\n+                    p.destroy();\n+                }\n+            }\n+        }\n+    }\n+}"},{"sha":"d3cf2ad547fac13feb7356151bb36c5c23131d84","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -279,7 +279,7 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n                                 public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n                                     returnCode.set(rc);\n                                     openLatch.countDown();\n-                                    if (rc != BKException.Code.OK) {\n+                                    if (rc == BKException.Code.OK) {\n                                         try {\n                                             lh.close();\n                                         } catch (Exception e) {"},{"sha":"91c69210e5591f5742dec962e8cbe2faf405c483","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","status":"added","additions":254,"deletions":0,"changes":254,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,254 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy.REPP_DNS_RESOLVER_CLASS;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.util.StaticDNSResolver;\n+import org.apache.commons.configuration.CompositeConfiguration;\n+import org.apache.commons.configuration.Configuration;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestRackawareEnsemblePlacementPolicy extends TestCase {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(TestRackawareEnsemblePlacementPolicy.class);\n+\n+    RackawareEnsemblePlacementPolicy repp;\n+    Configuration conf = new CompositeConfiguration();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        StaticDNSResolver.reset();\n+        StaticDNSResolver.addNodeToRack(InetAddress.getLocalHost().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(\"127.0.0.1\", NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(\"localhost\", NetworkTopology.DEFAULT_RACK);\n+        LOG.info(\"Set up static DNS Resolver.\");\n+        conf.setProperty(REPP_DNS_RESOLVER_CLASS, StaticDNSResolver.class.getName());\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        repp.initialize(conf);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        repp.uninitalize();\n+        super.tearDown();\n+    }\n+\n+    @Test\n+    public void testReplaceBookieWithEnoughBookiesInSameRack() throws Exception {\n+        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n+        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n+        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n+        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r3\");\n+        // Update cluster\n+        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        // replace node under r2\n+        InetSocketAddress replacedBookie = repp.replaceBookie(addr2, new HashSet<InetSocketAddress>());\n+        assertEquals(addr3, replacedBookie);\n+    }\n+\n+    @Test\n+    public void testReplaceBookieWithEnoughBookiesInDifferentRack() throws Exception {\n+        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n+        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n+        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n+        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r4\");\n+        // Update cluster\n+        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        // replace node under r2\n+        Set<InetSocketAddress> excludedAddrs = new HashSet<InetSocketAddress>();\n+        excludedAddrs.add(addr1);\n+        InetSocketAddress replacedBookie = repp.replaceBookie(addr2, excludedAddrs);\n+\n+        assertFalse(addr1.equals(replacedBookie));\n+        assertTrue(addr3.equals(replacedBookie) || addr4.equals(replacedBookie));\n+    }\n+\n+    @Test\n+    public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n+        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n+        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n+        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n+        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r4\");\n+        // Update cluster\n+        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        // replace node under r2\n+        Set<InetSocketAddress> excludedAddrs = new HashSet<InetSocketAddress>();\n+        excludedAddrs.add(addr1);\n+        excludedAddrs.add(addr3);\n+        excludedAddrs.add(addr4);\n+        try {\n+            repp.replaceBookie(addr2, excludedAddrs);\n+            fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\");\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            // should throw not enou\n+        }\n+    }\n+\n+    @Test\n+    public void testNewEnsembleWithSingleRack() throws Exception {\n+        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n+        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n+        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n+        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        // Update cluster\n+        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        try {\n+            ArrayList<InetSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<InetSocketAddress>());\n+            assertEquals(0, getNumCoveredWriteQuorums(ensemble, 2));\n+            ArrayList<InetSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<InetSocketAddress>());\n+            assertEquals(0, getNumCoveredWriteQuorums(ensemble2, 2));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testNewEnsembleWithMultipleRacks() throws Exception {\n+        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n+        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n+        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n+        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r2\");\n+        // Update cluster\n+        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        try {\n+            ArrayList<InetSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<InetSocketAddress>());\n+            int numCovered = getNumCoveredWriteQuorums(ensemble, 2);\n+            assertTrue(numCovered >= 1 && numCovered < 3);\n+            ArrayList<InetSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<InetSocketAddress>());\n+            numCovered = getNumCoveredWriteQuorums(ensemble2, 2);\n+            assertTrue(numCovered >= 1 && numCovered < 3);\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testNewEnsembleWithEnoughRacks() throws Exception {\n+        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n+        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n+        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n+        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        InetSocketAddress addr5 = new InetSocketAddress(\"127.0.0.5\", 3181);\n+        InetSocketAddress addr6 = new InetSocketAddress(\"127.0.0.6\", 3181);\n+        InetSocketAddress addr7 = new InetSocketAddress(\"127.0.0.7\", 3181);\n+        InetSocketAddress addr8 = new InetSocketAddress(\"127.0.0.8\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr6.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr7.getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr8.getAddress().getHostAddress(), \"/r4\");\n+        // Update cluster\n+        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        try {\n+            ArrayList<InetSocketAddress> ensemble1 = repp.newEnsemble(3, 2, new HashSet<InetSocketAddress>());\n+            assertEquals(3, getNumCoveredWriteQuorums(ensemble1, 2));\n+            ArrayList<InetSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<InetSocketAddress>());\n+            assertEquals(4, getNumCoveredWriteQuorums(ensemble2, 2));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    private int getNumCoveredWriteQuorums(ArrayList<InetSocketAddress> ensemble, int writeQuorumSize)\n+            throws Exception {\n+        int ensembleSize = ensemble.size();\n+        int numCoveredWriteQuorums = 0;\n+        for (int i = 0; i < ensembleSize; i++) {\n+            Set<String> racks = new HashSet<String>();\n+            for (int j = 0; j < writeQuorumSize; j++) {\n+                int bookieIdx = (i + j) % ensembleSize;\n+                InetSocketAddress addr = ensemble.get(bookieIdx);\n+                racks.add(StaticDNSResolver.getRack(addr.getAddress().getHostAddress()));\n+            }\n+            numCoveredWriteQuorums += (racks.size() > 1 ? 1 : 0);\n+        }\n+        return numCoveredWriteQuorums;\n+    }\n+}"},{"sha":"a6ffce0288ae2df2178e7d0c67e7ecdf26d3c8d0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/StaticDNSResolver.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/bookkeeper/blob/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/test/java/org/apache/bookkeeper/util/StaticDNSResolver.java","raw_url":"https://github.com/apache/bookkeeper/raw/1c04906c0077d228076c3d157d815e5c7219bb0c/bookkeeper-server/src/test/java/org/apache/bookkeeper/util/StaticDNSResolver.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/util/StaticDNSResolver.java?ref=1c04906c0077d228076c3d157d815e5c7219bb0c","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.bookkeeper.net.AbstractDNSToSwitchMapping;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements {@link DNSToSwitchMapping} via static mappings. Used in test cases to simulate racks.\n+ */\n+public class StaticDNSResolver extends AbstractDNSToSwitchMapping {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(StaticDNSResolver.class);\n+\n+    private static final ConcurrentMap<String, String> name2Racks = new ConcurrentHashMap<String, String>();\n+\n+    public static void addNodeToRack(String name, String rack) {\n+        name2Racks.put(name, rack);\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Add node {} to rack {}.\", name, rack);\n+        }\n+    }\n+\n+    public static String getRack(String name) {\n+        String rack = name2Racks.get(name);\n+        if (null == rack) {\n+            rack = NetworkTopology.DEFAULT_RACK;\n+        }\n+        return rack;\n+    }\n+\n+    public static void reset() {\n+        name2Racks.clear();\n+    }\n+\n+    @Override\n+    public List<String> resolve(List<String> names) {\n+        List<String> racks = new ArrayList<String>();\n+        for (String n : names) {\n+            String rack = name2Racks.get(n);\n+            if (null == rack) {\n+                rack = NetworkTopology.DEFAULT_RACK;\n+            }\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Resolve name {} to rack {}.\", n, rack);\n+            }\n+            racks.add(rack);\n+        }\n+        return racks;\n+    }\n+\n+    @Override\n+    public void reloadCachedMappings() {\n+        // nop\n+    }\n+\n+}"}]}

