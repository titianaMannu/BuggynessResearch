{"sha":"1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxZjUyNzhkMDZkZGJmNGRhMGQyZDZlZDQxNjc2MzIxZjg5YTRhZWNk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-09T16:47:36Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-09T16:47:36Z"},"message":"BOOKKEEPER-529: stopServingSubscriber in delivery manager should remove stub callbacks in ReadAheadCache (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1430954 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1040ff5f5f12fc235a99bf2880030f947078e6b1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1040ff5f5f12fc235a99bf2880030f947078e6b1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","html_url":"https://github.com/apache/bookkeeper/commit/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f0db18abedd30af1d6191d068652b93db0c68fc6","url":"https://api.github.com/repos/apache/bookkeeper/commits/f0db18abedd30af1d6191d068652b93db0c68fc6","html_url":"https://github.com/apache/bookkeeper/commit/f0db18abedd30af1d6191d068652b93db0c68fc6"}],"stats":{"total":273,"additions":234,"deletions":39},"files":[{"sha":"328db89c6833f8fecea5e72a205f283f8222a097","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -224,6 +224,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-531: Cache thread should wait until old entries are collected (sijie via ivank)\n \n+        BOOKKEEPER-529: stopServingSubscriber in delivery manager should remove stub callbacks in ReadAheadCache (sijie via ivank)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-467: Allocate ports for testing dynamically (ivank)"},{"sha":"9301dd7376f88f3e9a553bfaa598642123a8ab9b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":115,"deletions":30,"changes":145,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -29,6 +29,7 @@\n import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -51,9 +52,11 @@\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.common.UnexpectedError;\n import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.persistence.CancelScanRequest;\n import org.apache.hedwig.server.persistence.Factory;\n import org.apache.hedwig.server.persistence.MapMethods;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.persistence.ReadAheadCache;\n import org.apache.hedwig.server.persistence.ScanCallback;\n import org.apache.hedwig.server.persistence.ScanRequest;\n import org.apache.hedwig.util.Callback;\n@@ -108,7 +111,8 @@ public int compare(ActiveSubscriberState as1, ActiveSubscriberState as2) {\n      */\n     Map<TopicSubscriber, ActiveSubscriberState> subscriberStates;\n \n-    private PersistenceManager persistenceMgr;\n+    private final ReadAheadCache cache;\n+    private final PersistenceManager persistenceMgr;\n \n     private ServerConfiguration cfg;\n \n@@ -123,6 +127,11 @@ public int compare(ActiveSubscriberState as1, ActiveSubscriberState as2) {\n \n     public FIFODeliveryManager(PersistenceManager persistenceMgr, ServerConfiguration cfg) {\n         this.persistenceMgr = persistenceMgr;\n+        if (persistenceMgr instanceof ReadAheadCache) {\n+            this.cache = (ReadAheadCache) persistenceMgr;\n+        } else {\n+            this.cache = null;\n+        }\n         perTopicDeliveryPtrs = new HashMap<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>>();\n         subscriberStates = new HashMap<TopicSubscriber, ActiveSubscriberState>();\n         workerThread = new Thread(this, \"DeliveryManagerThread\");\n@@ -208,7 +217,7 @@ public void stopServingSubscriber(ByteString topic, ByteString subscriberId,\n                                       SubscriptionEvent event,\n                                       Callback<Void> cb, Object ctx) {\n         ActiveSubscriberState subState =\n-            subscriberStates.get(new TopicSubscriber(topic, subscriberId));\n+            subscriberStates.remove(new TopicSubscriber(topic, subscriberId));\n \n         if (subState != null) {\n             stopServingSubscriber(subState, event, cb, ctx);\n@@ -396,14 +405,16 @@ protected void addDeliveryPtr(ActiveSubscriberState subscriber, Long seqId) {\n         MapMethods.addToMultiMap(deliveryPtrs, seqId, subscriber, HashMapSubscriberFactory.instance);\n     }\n \n-    public class ActiveSubscriberState implements ScanCallback, DeliveryCallback, DeliveryManagerRequest {\n+    public class ActiveSubscriberState\n+        implements ScanCallback, DeliveryCallback, DeliveryManagerRequest, CancelScanRequest {\n \n         static final int UNLIMITED = 0;\n \n         ByteString topic;\n         ByteString subscriberId;\n         long lastLocalSeqIdDelivered;\n         boolean connected = true;\n+        ReentrantReadWriteLock connectedLock = new ReentrantReadWriteLock();\n         DeliveryEndPoint deliveryEndPoint;\n         long lastScanErrorTime = -1;\n         long localSeqIdDeliveringNow;\n@@ -415,6 +426,10 @@ protected void addDeliveryPtr(ActiveSubscriberState subscriber, Long seqId) {\n         Callback<Void> cb;\n         Object ctx;\n \n+        // track the outstanding scan request\n+        // so we could cancel it\n+        ScanRequest outstandingScanRequest;\n+\n         final static int SEQ_ID_SLACK = 10;\n \n         public ActiveSubscriberState(ByteString topic, ByteString subscriberId,\n@@ -444,11 +459,23 @@ public ActiveSubscriberState(ByteString topic, ByteString subscriberId,\n         }\n \n         public void setNotConnected(SubscriptionEvent event) {\n-            // have closed it.\n-            if (!isConnected()) {\n-                return;\n+            this.connectedLock.writeLock().lock();\n+            try {\n+                // have closed it.\n+                if (!connected) {\n+                    return;\n+                }\n+                this.connected = false;\n+                // put itself in ReadAhead queue to cancel outstanding scan request\n+                // if outstanding scan request callback before cancel op executed,\n+                // nothing it would cancel.\n+                if (null != cache && null != outstandingScanRequest) {\n+                    cache.cancelScanRequest(topic, this);\n+                }\n+            } finally {\n+                this.connectedLock.writeLock().unlock();\n             }\n-            this.connected = false;\n+\n             if (null != event &&\n                 (SubscriptionEvent.TOPIC_MOVED == event ||\n                  SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED == event)) {\n@@ -500,7 +527,12 @@ protected void clearLastScanErrorTime() {\n         }\n \n         protected boolean isConnected() {\n-            return connected;\n+            connectedLock.readLock().lock();\n+            try {\n+                return connected;\n+            } finally {\n+                connectedLock.readLock().unlock();\n+            }\n         }\n \n         protected void messageConsumed(long newSeqIdConsumed) {\n@@ -542,8 +574,16 @@ protected boolean msgLimitExceeded() {\n         }\n \n         public void deliverNextMessage() {\n+            connectedLock.readLock().lock();\n+            try {\n+                doDeliverNextMessage();\n+            } finally {\n+                connectedLock.readLock().unlock();\n+            }\n+        }\n \n-            if (!isConnected()) {\n+        private void doDeliverNextMessage() {\n+            if (!connected) {\n                 return;\n             }\n \n@@ -559,10 +599,41 @@ public void deliverNextMessage() {\n \n             localSeqIdDeliveringNow = persistenceMgr.getSeqIdAfterSkipping(topic, lastLocalSeqIdDelivered, 1);\n \n-            ScanRequest scanRequest = new ScanRequest(topic, localSeqIdDeliveringNow,\n+            outstandingScanRequest = new ScanRequest(topic, localSeqIdDeliveringNow,\n                     /* callback= */this, /* ctx= */null);\n \n-            persistenceMgr.scanSingleMessage(scanRequest);\n+            persistenceMgr.scanSingleMessage(outstandingScanRequest);\n+        }\n+\n+        /**\n+         * ===============================================================\n+         * {@link CancelScanRequest} methods\n+         *\n+         * This method runs ins same threads with ScanCallback. When it runs,\n+         * it checked whether it is outstanding scan request. if there is one,\n+         * cancel it.\n+         */\n+        @Override\n+        public ScanRequest getScanRequest() {\n+            // no race between cancel request and scan callback\n+            // the only race is between stopServing and deliverNextMessage\n+            // deliverNextMessage would be executed in netty callback which is in netty thread\n+            // stopServing is run in delivery thread. if stopServing runs before deliverNextMessage\n+            // deliverNextMessage would have chance to put a stub in ReadAheadCache\n+            // then we don't have any chance to cancel it.\n+            // use connectedLock to avoid such race.\n+            return outstandingScanRequest;\n+        }\n+\n+        private boolean checkConnected() {\n+            connectedLock.readLock().lock();\n+            try {\n+                // message scanned means the outstanding request is executed\n+                outstandingScanRequest = null;\n+                return connected;\n+            } finally {\n+                connectedLock.readLock().unlock();\n+            }\n         }\n \n         /**\n@@ -571,7 +642,7 @@ public void deliverNextMessage() {\n          */\n \n         public void messageScanned(Object ctx, Message message) {\n-            if (!connected) {\n+            if (!checkConnected()) {\n                 return;\n             }\n \n@@ -597,7 +668,7 @@ public void messageScanned(Object ctx, Message message) {\n         }\n \n         public void scanFailed(Object ctx, Exception exception) {\n-            if (!connected) {\n+            if (!checkConnected()) {\n                 return;\n             }\n \n@@ -606,15 +677,15 @@ public void scanFailed(Object ctx, Exception exception) {\n         }\n \n         public void scanFinished(Object ctx, ReasonForFinish reason) {\n-            // no-op\n+            checkConnected();\n         }\n \n         /**\n          * ===============================================================\n          * {@link DeliveryCallback} methods\n          */\n         public void sendingFinished() {\n-            if (!connected) {\n+            if (!isConnected()) {\n                 return;\n             }\n \n@@ -665,8 +736,10 @@ public void performRequest() {\n                 subscriberStates.put(new TopicSubscriber(topic, subscriberId), this);\n \n             if (prevSubscriber != null) {\n-                stopServingSubscriber(prevSubscriber, SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED,\n-                                      NOP_CALLBACK, null);\n+                // we already in the delivery thread, we don't need to equeue a stop request\n+                // just stop it now, since stop is not blocking operation.\n+                // and also it cleans the old state of the active subscriber immediately.\n+                doStopServingSubscriber(prevSubscriber, SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED);\n             }\n \n             lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n@@ -704,24 +777,36 @@ public StopServingSubscriber(ActiveSubscriberState subscriber,\n \n         @Override\n         public void performRequest() {\n-\n-            // This will automatically stop delivery, and disconnect the channel\n-            subscriber.setNotConnected(event);\n-\n-            // if the subscriber has moved on, a move request for its delivery\n-            // pointer must be pending in the request queue. Note that the\n-            // subscriber first changes its delivery pointer and then submits a\n-            // request to move so this works.\n-            removeDeliveryPtr(subscriber, subscriber.getLastSeqIdCommunicatedExternally(), //\n-                              // isAbsenceOk=\n-                              true,\n-                              // pruneTopic=\n-                              true);\n+            doStopServingSubscriber(subscriber, event);\n             cb.operationFinished(ctx, null);\n         }\n \n     }\n \n+    /**\n+     * Stop serving a subscriber. This method should be called in a\n+     * {@link DeliveryManagerRequest}.\n+     *\n+     * @param subscriber\n+     *          Active Subscriber to stop\n+     * @param event\n+     *          Subscription Event for the stop reason\n+     */\n+    private void doStopServingSubscriber(ActiveSubscriberState subscriber, SubscriptionEvent event) {\n+        // This will automatically stop delivery, and disconnect the channel\n+        subscriber.setNotConnected(event);\n+\n+        // if the subscriber has moved on, a move request for its delivery\n+        // pointer must be pending in the request queue. Note that the\n+        // subscriber first changes its delivery pointer and then submits a\n+        // request to move so this works.\n+        removeDeliveryPtr(subscriber, subscriber.getLastSeqIdCommunicatedExternally(), //\n+                          // isAbsenceOk=\n+                          true,\n+                          // pruneTopic=\n+                          true);\n+    }\n+\n     protected class DeliveryPtrMove implements DeliveryManagerRequest {\n \n         ActiveSubscriberState subscriber;"},{"sha":"942aecdd3108ac58ce90acbed7285c439dc027f2","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","status":"modified","additions":18,"deletions":9,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -17,8 +17,8 @@\n  */\n package org.apache.hedwig.server.persistence;\n \n-import java.util.LinkedList;\n-import java.util.Queue;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -35,7 +35,9 @@\n \n     static Logger logger = LoggerFactory.getLogger(ReadAheadCache.class);\n \n-    Queue<ScanCallbackWithContext> callbacks = new LinkedList<ScanCallbackWithContext>();\n+    // Actually we don't care the order of callbacks\n+    // when a scan callback, it should be delivered to both callbacks\n+    Set<ScanCallbackWithContext> callbacks = new HashSet<ScanCallbackWithContext>();\n     Message message;\n     long timeOfAddition = 0;\n \n@@ -61,13 +63,19 @@ public void setMessageAndInvokeCallbacks(Message message, long currTime) {\n \n         this.message = message;\n         this.timeOfAddition = currTime;\n-        ScanCallbackWithContext callbackWithCtx;\n+\n         logger.debug(\"Invoking {} callbacks for {} message added to cache\", callbacks.size(), message);\n-        while ((callbackWithCtx = callbacks.poll()) != null) {\n-            callbackWithCtx.getScanCallback().messageScanned(callbackWithCtx.getCtx(), message);\n+        for (ScanCallbackWithContext callbackWithCtx : callbacks) {\n+            if (null != callbackWithCtx) {\n+                callbackWithCtx.getScanCallback().messageScanned(callbackWithCtx.getCtx(), message);\n+            }\n         }\n     }\n \n+    public boolean removeCallback(ScanCallback callback, Object ctx) {\n+        return callbacks.remove(new ScanCallbackWithContext(callback, ctx));\n+    }\n+\n     public void addCallback(ScanCallback callback, Object ctx) {\n         if (!isStub()) {\n             // call the callback right away\n@@ -83,9 +91,10 @@ public Message getMessage() {\n     }\n \n     public void setErrorAndInvokeCallbacks(Exception exception) {\n-        ScanCallbackWithContext callbackWithCtx;\n-        while ((callbackWithCtx = callbacks.poll()) != null) {\n-            callbackWithCtx.getScanCallback().scanFailed(callbackWithCtx.getCtx(), exception);\n+        for (ScanCallbackWithContext callbackWithCtx : callbacks) {\n+            if (null != callbackWithCtx) {\n+                callbackWithCtx.getScanCallback().scanFailed(callbackWithCtx.getCtx(), exception);\n+            }\n         }\n     }\n "},{"sha":"c3b521433975277e16be35f50ef66f53cc2d5cf5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.persistence;\n+\n+public interface CancelScanRequest {\n+\n+    /**\n+     * @return the scan request to cancel\n+     */\n+    public ScanRequest getScanRequest();\n+\n+}"},{"sha":"872987c1016860a4c3aafab097bf0f81356c1eaa","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"modified","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -688,6 +688,41 @@ public ReadAheadException() {\n         }\n     }\n \n+    public class CancelScanRequestOp implements CacheRequest {\n+\n+        final CancelScanRequest request;\n+\n+        public CancelScanRequestOp(CancelScanRequest request) {\n+            this.request = request;\n+        }\n+\n+        public void performRequest() {\n+            // cancel scan request\n+            cancelScanRequest(request.getScanRequest());\n+        }\n+\n+        void cancelScanRequest(ScanRequest request) {\n+            if (null == request) {\n+                // nothing to cancel\n+                return;\n+            }\n+\n+            CacheKey cacheKey = new CacheKey(request.getTopic(), request.getStartSeqId());\n+            CacheValue cacheValue = cache.get(cacheKey);\n+            if (null == cacheValue) {\n+                // cache value is evicted\n+                // so it's callback would be called, we don't need to worry about\n+                // cancel it. since it was treated as executed.\n+                return;\n+            }\n+            cacheValue.removeCallback(request.getCallback(), request.getCtx());\n+        }\n+    }\n+\n+    public void cancelScanRequest(ByteString topic, CancelScanRequest request) {\n+        enqueueWithoutFailureByTopic(topic, new CancelScanRequestOp(request));\n+    }\n+\n     protected class ScanResponse implements CacheRequest {\n         CacheKey cacheKey;\n         Message message;"},{"sha":"a39a1974d9a97417faea79e91c22ff76bbe20940","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -34,4 +34,21 @@ public Object getCtx() {\n         return ctx;\n     }\n \n+    @Override\n+    public boolean equals(Object other) {\n+        if (!(other instanceof ScanCallbackWithContext)) {\n+            return false;\n+        }\n+        ScanCallbackWithContext otherCb =\n+            (ScanCallbackWithContext) other;\n+        // Ensure that it was same callback & same ctx\n+        return scanCallback == otherCb.scanCallback &&\n+               ctx == otherCb.ctx;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return scanCallback.hashCode();\n+    }\n+\n }"},{"sha":"062e431f79bbc562c86f91d3f793ca71eb7375e7","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/1f5278d06ddbf4da0d2d6ed41676321f89a4aecd/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=1f5278d06ddbf4da0d2d6ed41676321f89a4aecd","patch":"@@ -469,6 +469,26 @@ public void testAsyncSubscribeAndCloseSubscription() throws Exception {\n         assertTrue(true);\n     }\n \n+    @Test(timeout=60000)\n+    public void testSubClosesubAndPublish() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"mySubClosesubAndPublish\");\n+        ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n+        // to populate startServing/stopServing sequeuence\n+        for (int i=0; i<5; i++) {\n+            subscriber.subscribe(topic, subid, CreateOrAttach.CREATE_OR_ATTACH);\n+            subscriber.closeSubscription(topic, subid);\n+        }\n+        subscriber.subscribe(topic, subid, CreateOrAttach.CREATE_OR_ATTACH);\n+        subscriber.startDelivery(topic, subid, new TestMessageHandler());\n+        for (int i=0; i<3; i++) {\n+            publisher.asyncPublish(topic,\n+                Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #\" + i)).build(),\n+                new TestCallback(), null);\n+            assertTrue(queue.take());\n+            assertTrue(consumeQueue.take());\n+        }\n+    }\n+\n     @Test(timeout=60000)\n     public void testSyncSubscribeWithListener() throws Exception {\n         ByteString topic = ByteString.copyFromUtf8(\"mySyncSubscribeWithListener\");"}]}

