{"sha":"223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyMjNhM2ZiM2ZiYzc4ZmU0ZGMxOTIyOTY3ZmUzZGFhM2VkZmMzZmIy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-26T13:13:09Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-26T13:13:09Z"},"message":"BOOKKEEPER-439: No more messages delivered after deleted consumed ledgers. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1402501 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1bdf646fb790e4310343144479764da4ec90eb9f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1bdf646fb790e4310343144479764da4ec90eb9f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","html_url":"https://github.com/apache/bookkeeper/commit/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3a9a88708d3a1e9e2337a8cc99c3bb727f93ffc4","url":"https://api.github.com/repos/apache/bookkeeper/commits/3a9a88708d3a1e9e2337a8cc99c3bb727f93ffc4","html_url":"https://github.com/apache/bookkeeper/commit/3a9a88708d3a1e9e2337a8cc99c3bb727f93ffc4"}],"stats":{"total":969,"additions":762,"deletions":207},"files":[{"sha":"737f5219a2bcd19e286475649d06ca07a30fc248","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -128,6 +128,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-191: Hub server should change ledger to write, so consumed messages have chance to be garbage collected. (sijie via ivank)\n \n+        BOOKKEEPER-439: No more messages delivered after deleted consumed ledgers. (sijie via ivank)\n+\n     IMPROVEMENTS:\n \n       bookkeeper-server:"},{"sha":"68a6fca9666e28da91513ec19047afc268ea1211","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -549,7 +549,7 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n         counter.block(0);\n         if (counter.getrc() != BKException.Code.OK) {\n             LOG.error(\"Error deleting ledger \" + lId + \" : \" + counter.getrc());\n-            throw BKException.create(Code.ZKException);\n+            throw BKException.create(counter.getrc());\n         }\n     }\n "},{"sha":"a019b219822ad38dd0ce0026d5d2ec13174584f2","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":86,"deletions":28,"changes":114,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -13544,6 +13544,10 @@ public Builder clearPreferences() {\n     boolean hasEndSeqIdIncluded();\n     org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId getEndSeqIdIncluded();\n     org.apache.hedwig.protocol.PubSubProtocol.MessageSeqIdOrBuilder getEndSeqIdIncludedOrBuilder();\n+    \n+    // optional uint64 startSeqIdIncluded = 3;\n+    boolean hasStartSeqIdIncluded();\n+    long getStartSeqIdIncluded();\n   }\n   public static final class LedgerRange extends\n       com.google.protobuf.GeneratedMessage\n@@ -13597,9 +13601,20 @@ public boolean hasEndSeqIdIncluded() {\n       return endSeqIdIncluded_;\n     }\n     \n+    // optional uint64 startSeqIdIncluded = 3;\n+    public static final int STARTSEQIDINCLUDED_FIELD_NUMBER = 3;\n+    private long startSeqIdIncluded_;\n+    public boolean hasStartSeqIdIncluded() {\n+      return ((bitField0_ & 0x00000004) == 0x00000004);\n+    }\n+    public long getStartSeqIdIncluded() {\n+      return startSeqIdIncluded_;\n+    }\n+    \n     private void initFields() {\n       ledgerId_ = 0L;\n       endSeqIdIncluded_ = org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId.getDefaultInstance();\n+      startSeqIdIncluded_ = 0L;\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -13629,6 +13644,9 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       if (((bitField0_ & 0x00000002) == 0x00000002)) {\n         output.writeMessage(2, endSeqIdIncluded_);\n       }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        output.writeUInt64(3, startSeqIdIncluded_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -13646,6 +13664,10 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeMessageSize(2, endSeqIdIncluded_);\n       }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeUInt64Size(3, startSeqIdIncluded_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -13779,6 +13801,8 @@ public Builder clear() {\n           endSeqIdIncludedBuilder_.clear();\n         }\n         bitField0_ = (bitField0_ & ~0x00000002);\n+        startSeqIdIncluded_ = 0L;\n+        bitField0_ = (bitField0_ & ~0x00000004);\n         return this;\n       }\n       \n@@ -13829,6 +13853,10 @@ public Builder clone() {\n         } else {\n           result.endSeqIdIncluded_ = endSeqIdIncludedBuilder_.build();\n         }\n+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        result.startSeqIdIncluded_ = startSeqIdIncluded_;\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -13851,6 +13879,9 @@ public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.LedgerRange o\n         if (other.hasEndSeqIdIncluded()) {\n           mergeEndSeqIdIncluded(other.getEndSeqIdIncluded());\n         }\n+        if (other.hasStartSeqIdIncluded()) {\n+          setStartSeqIdIncluded(other.getStartSeqIdIncluded());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -13906,6 +13937,11 @@ public Builder mergeFrom(\n               setEndSeqIdIncluded(subBuilder.buildPartial());\n               break;\n             }\n+            case 24: {\n+              bitField0_ |= 0x00000004;\n+              startSeqIdIncluded_ = input.readUInt64();\n+              break;\n+            }\n           }\n         }\n       }\n@@ -14023,6 +14059,27 @@ public Builder clearEndSeqIdIncluded() {\n         return endSeqIdIncludedBuilder_;\n       }\n       \n+      // optional uint64 startSeqIdIncluded = 3;\n+      private long startSeqIdIncluded_ ;\n+      public boolean hasStartSeqIdIncluded() {\n+        return ((bitField0_ & 0x00000004) == 0x00000004);\n+      }\n+      public long getStartSeqIdIncluded() {\n+        return startSeqIdIncluded_;\n+      }\n+      public Builder setStartSeqIdIncluded(long value) {\n+        bitField0_ |= 0x00000004;\n+        startSeqIdIncluded_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearStartSeqIdIncluded() {\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        startSeqIdIncluded_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:Hedwig.LedgerRange)\n     }\n     \n@@ -16052,34 +16109,35 @@ public Builder clearNumTopics() {\n       \"eSeqId\\022\\024\\n\\014messageBound\\030\\002 \\001(\\r\\\"r\\n\\020Subscrip\" +\n       \"tionData\\022(\\n\\005state\\030\\001 \\001(\\0132\\031.Hedwig.Subscri\" +\n       \"ptionState\\0224\\n\\013preferences\\030\\002 \\001(\\0132\\037.Hedwig\" +\n-      \".SubscriptionPreferences\\\"O\\n\\013LedgerRange\\022\",\n+      \".SubscriptionPreferences\\\"k\\n\\013LedgerRange\\022\",\n       \"\\020\\n\\010ledgerId\\030\\001 \\002(\\004\\022.\\n\\020endSeqIdIncluded\\030\\002 \" +\n-      \"\\001(\\0132\\024.Hedwig.MessageSeqId\\\"3\\n\\014LedgerRange\" +\n-      \"s\\022#\\n\\006ranges\\030\\001 \\003(\\0132\\023.Hedwig.LedgerRange\\\":\" +\n-      \"\\n\\013ManagerMeta\\022\\023\\n\\013managerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016ma\" +\n-      \"nagerVersion\\030\\003 \\002(\\r\\\".\\n\\013HubInfoData\\022\\020\\n\\010hos\" +\n-      \"tname\\030\\002 \\002(\\t\\022\\r\\n\\005czxid\\030\\003 \\002(\\004\\\" \\n\\013HubLoadDat\" +\n-      \"a\\022\\021\\n\\tnumTopics\\030\\002 \\002(\\004*\\\"\\n\\017ProtocolVersion\\022\" +\n-      \"\\017\\n\\013VERSION_ONE\\020\\001*\\207\\001\\n\\rOperationType\\022\\013\\n\\007PU\" +\n-      \"BLISH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013U\" +\n-      \"NSUBSCRIBE\\020\\003\\022\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rSTOP\",\n-      \"_DELIVERY\\020\\005\\022\\025\\n\\021CLOSESUBSCRIPTION\\020\\006*D\\n\\021Su\" +\n-      \"bscriptionEvent\\022\\017\\n\\013TOPIC_MOVED\\020\\001\\022\\036\\n\\032SUBS\" +\n-      \"CRIPTION_FORCED_CLOSED\\020\\002*\\205\\004\\n\\nStatusCode\\022\" +\n-      \"\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\\n\\r\" +\n-      \"NO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUBSC\" +\n-      \"RIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\\n\\021\" +\n-      \"COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\\036\\n\" +\n-      \"\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVICE\" +\n-      \"_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026INVALI\" +\n-      \"D_MESSAGE_FILTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\\036\\n\",\n-      \"\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC_P\" +\n-      \"ERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCRIP\" +\n-      \"TION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EXIS\" +\n-      \"TS\\020\\214\\004\\022\\030\\n\\023NO_TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027TOPIC\" +\n-      \"_OWNER_INFO_EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_COND\" +\n-      \"ITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apache.h\" +\n-      \"edwig.protocolH\\001\"\n+      \"\\001(\\0132\\024.Hedwig.MessageSeqId\\022\\032\\n\\022startSeqIdI\" +\n+      \"ncluded\\030\\003 \\001(\\004\\\"3\\n\\014LedgerRanges\\022#\\n\\006ranges\\030\" +\n+      \"\\001 \\003(\\0132\\023.Hedwig.LedgerRange\\\":\\n\\013ManagerMet\" +\n+      \"a\\022\\023\\n\\013managerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016managerVersion\" +\n+      \"\\030\\003 \\002(\\r\\\".\\n\\013HubInfoData\\022\\020\\n\\010hostname\\030\\002 \\002(\\t\\022\" +\n+      \"\\r\\n\\005czxid\\030\\003 \\002(\\004\\\" \\n\\013HubLoadData\\022\\021\\n\\tnumTopi\" +\n+      \"cs\\030\\002 \\002(\\004*\\\"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_O\" +\n+      \"NE\\020\\001*\\207\\001\\n\\rOperationType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tS\" +\n+      \"UBSCRIBE\\020\\001\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\",\n+      \"\\022\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005\\022\" +\n+      \"\\025\\n\\021CLOSESUBSCRIPTION\\020\\006*D\\n\\021SubscriptionEv\" +\n+      \"ent\\022\\017\\n\\013TOPIC_MOVED\\020\\001\\022\\036\\n\\032SUBSCRIPTION_FOR\" +\n+      \"CED_CLOSED\\020\\002*\\205\\004\\n\\nStatusCode\\022\\013\\n\\007SUCCESS\\020\\000\" +\n+      \"\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\\n\\rNO_SUCH_TOPI\" +\n+      \"C\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUBSCRIBED\\020\\223\\003\\022\\032\\n\\025\" +\n+      \"CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\\n\\021COULD_NOT_CO\" +\n+      \"NNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\\036\\n\\031NOT_RESPONS\" +\n+      \"IBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVICE_DOWN\\020\\366\\003\\022\\024\\n\\017\" +\n+      \"UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026INVALID_MESSAGE_FI\",\n+      \"LTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\\036\\n\\031NO_TOPIC_PE\" +\n+      \"RSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC_PERSISTENCE_I\" +\n+      \"NFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCRIPTION_STATE\\020\\213\" +\n+      \"\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EXISTS\\020\\214\\004\\022\\030\\n\\023NO_\" +\n+      \"TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027TOPIC_OWNER_INFO_\" +\n+      \"EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_CONDITION\\020\\330\\004\\022\\016\\n\\t\" +\n+      \"COMPOSITE\\020\\274\\005B\\036\\n\\032org.apache.hedwig.protoc\" +\n+      \"olH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -16267,7 +16325,7 @@ public Builder clearNumTopics() {\n           internal_static_Hedwig_LedgerRange_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_LedgerRange_descriptor,\n-              new java.lang.String[] { \"LedgerId\", \"EndSeqIdIncluded\", },\n+              new java.lang.String[] { \"LedgerId\", \"EndSeqIdIncluded\", \"StartSeqIdIncluded\", },\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRange.class,\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRange.Builder.class);\n           internal_static_Hedwig_LedgerRanges_descriptor ="},{"sha":"249b02b9288d603156df07c1e0cf1b14edeb1af6","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -286,6 +286,7 @@ message SubscriptionData {\n message LedgerRange{\n     required uint64 ledgerId = 1;\n     optional MessageSeqId endSeqIdIncluded = 2;\n+    optional uint64 startSeqIdIncluded = 3;\n }\n \n message LedgerRanges{"},{"sha":"c21197ddbf9c9072415aad622cd5751b92e4a242","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","status":"modified","additions":51,"deletions":39,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -352,6 +352,13 @@ public void operationFailed(Object ctx, PubSubException pse) {\n         return syncObj.value;\n     }\n \n+    private static LedgerRange buildLedgerRange(long ledgerId, long startOfLedger, MessageSeqId endOfLedger) {\n+        LedgerRange.Builder builder =\n+            LedgerRange.newBuilder().setLedgerId(ledgerId).setStartSeqIdIncluded(startOfLedger)\n+                       .setEndSeqIdIncluded(endOfLedger);\n+        return builder.build();\n+    }\n+\n     /**\n      * Return the ledger range forming the topic\n      *\n@@ -387,49 +394,54 @@ public void operationFailed(Object ctx, PubSubException pse) {\n         if (null == ranges) {\n             return null;\n         }\n+        List<LedgerRange> results = new ArrayList<LedgerRange>();\n         List<LedgerRange> lrs = ranges.getRangesList();\n-        if (lrs.isEmpty()) {\n-            return lrs;\n-        }\n-        // try to check last ledger (it may still open)\n-        LedgerRange lastRange = lrs.get(lrs.size() - 1);\n-        if (lastRange.hasEndSeqIdIncluded()) {\n-            return lrs;\n-        }\n-        // read last confirmed of the opened ledger\n-        try {\n-            List<LedgerRange> newLrs = new ArrayList<LedgerRange>();\n-            newLrs.addAll(lrs);\n-            lrs = newLrs;\n-            MessageSeqId lastSeqId;\n-            if (lrs.size() == 1) {\n-                lastSeqId = MessageSeqId.newBuilder().setLocalComponent(1).build();\n-            } else {\n-                lastSeqId = lrs.get(lrs.size() - 2).getEndSeqIdIncluded();\n+        long startSeqId = 1L;\n+        if (!lrs.isEmpty()) {\n+            LedgerRange range = lrs.get(0);\n+            if (!range.hasStartSeqIdIncluded() && range.hasEndSeqIdIncluded()) {\n+                long ledgerId = range.getLedgerId();\n+                try {\n+                    LedgerHandle lh = bk.openLedgerNoRecovery(ledgerId, DigestType.CRC32, passwd);\n+                    long numEntries = lh.readLastConfirmed() + 1;\n+                    long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                    startSeqId = endOfLedger - numEntries + 1;\n+                } catch (BKException.BKNoSuchLedgerExistsException be) {\n+                    // ignore it\n+                }\n             }\n-            LedgerRange newLastRange = refreshLastLedgerRange(lastSeqId, lastRange);\n-            lrs.set(lrs.size() - 1, newLastRange);\n-        } catch (Exception e) {\n-            e.printStackTrace();\n         }\n-        return lrs;\n-    }\n+        Iterator<LedgerRange> lrIter = lrs.iterator();\n+        while (lrIter.hasNext()) {\n+            LedgerRange range = lrIter.next();\n+            if (range.hasEndSeqIdIncluded()) {\n+                long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                if (range.hasStartSeqIdIncluded()) {\n+                    startSeqId = range.getStartSeqIdIncluded();\n+                } else {\n+                    range = buildLedgerRange(range.getLedgerId(), startSeqId, range.getEndSeqIdIncluded());\n+                }\n+                results.add(range);\n+                if (startSeqId < endOfLedger + 1) {\n+                    startSeqId = endOfLedger + 1;\n+                }\n+                continue;\n+            }\n+            if (lrIter.hasNext()) {\n+                throw new IllegalStateException(\"Ledger \" + range.getLedgerId() + \" for topic \" + topic.toString()\n+                                                + \" is not the last one but still does not have an end seq-id\");\n+            }\n \n-    /**\n-     * Refresh last ledger range to get lastConfirmed entry, which make it available to read\n-     *\n-     * @param lastSeqId\n-     *            Last sequence id of previous ledger\n-     * @param oldRange\n-     *            Ledger range to set lastConfirmed entry\n-     */\n-    LedgerRange refreshLastLedgerRange(MessageSeqId lastSeqId, LedgerRange oldRange)\n-        throws BKException, KeeperException, InterruptedException {\n-        LedgerHandle lh = bk.openLedgerNoRecovery(oldRange.getLedgerId(), DigestType.CRC32, passwd);\n-        long lastConfirmed = lh.readLastConfirmed();\n-        MessageSeqId newSeqId = MessageSeqId.newBuilder().mergeFrom(lastSeqId)\n-                                .setLocalComponent(lastSeqId.getLocalComponent() + lastConfirmed).build();\n-        return LedgerRange.newBuilder().mergeFrom(oldRange).setEndSeqIdIncluded(newSeqId).build();\n+            if (range.hasStartSeqIdIncluded()) {\n+                startSeqId = range.getStartSeqIdIncluded();\n+            }\n+\n+            LedgerHandle lh = bk.openLedgerNoRecovery(range.getLedgerId(), DigestType.CRC32, passwd);\n+            long endOfLedger = startSeqId + lh.readLastConfirmed();\n+            MessageSeqId endSeqId = MessageSeqId.newBuilder().setLocalComponent(endOfLedger).build();\n+            results.add(buildLedgerRange(range.getLedgerId(), startSeqId, endSeqId));\n+        }\n+        return results;\n     }\n \n     /**"},{"sha":"829429a04c5de3f45dd1246ce65e2ad5263eb638","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","status":"modified","additions":8,"deletions":14,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -46,6 +46,7 @@\n import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.HedwigClient;\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n@@ -638,27 +639,20 @@ protected boolean describeTopic(String topic) throws Exception {\n             return true;\n         }\n \n-        private void printTopicLedgers(List<LedgerRange> lrs) {\n+        private void printTopicLedgers(List<LedgerRange> ranges) {\n             System.out.println(\">>> Persistence Info <<<\");\n-            if (null == lrs) {\n+            if (null == ranges) {\n                 System.out.println(\"N/A\");\n                 return;\n             }\n-            if (lrs.isEmpty()) {\n+            if (ranges.isEmpty()) {\n                 System.out.println(\"No Ledger used.\");\n                 return;\n             }\n-            Iterator<LedgerRange> lrIterator = lrs.iterator();\n-            long startOfLedger = 1;\n-            while (lrIterator.hasNext()) {\n-                LedgerRange range = lrIterator.next();\n-                long endOfLedger = Long.MAX_VALUE;\n-                if (range.hasEndSeqIdIncluded()) {\n-                    endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n-                }\n-                System.out.println(\"Ledger \" + range.getLedgerId() + \" [ \" + startOfLedger + \" ~ \" + (endOfLedger == Long.MAX_VALUE ? \"\" : endOfLedger) + \" ]\");\n-\n-                startOfLedger = endOfLedger + 1;\n+            for (LedgerRange range : ranges) {\n+                System.out.println(\"Ledger \" + range.getLedgerId() + \" [ \"\n+                                   + range.getStartSeqIdIncluded() + \" ~ \"\n+                                   + range.getEndSeqIdIncluded().getLocalComponent() + \" ]\");\n             }\n             System.out.println();\n         }"},{"sha":"4d73387640fa6f9d83ef4e09c3631a030572eb52","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","status":"modified","additions":18,"deletions":42,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -21,12 +21,11 @@\n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n+import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -71,17 +70,7 @@\n     \n     static final int NUM_MESSAGES_TO_PRINT = 15;\n \n-    SortedMap<Long, InMemoryLedgerRange> ledgers = new TreeMap<Long, InMemoryLedgerRange>();\n-    \n-    static class InMemoryLedgerRange {\n-        LedgerRange range;\n-        long startSeqIdIncluded;\n-        \n-        public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n-            this.range = range;\n-            this.startSeqIdIncluded = startSeqId;\n-        }\n-    }\n+    List<LedgerRange> ledgers = new ArrayList<LedgerRange>();\n     \n     /**\n      * Constructor\n@@ -121,23 +110,7 @@ protected int getTopicLedgers() throws Exception {\n         if (null == ranges || ranges.isEmpty()) {\n             return RC_NOLEDGERS;\n         }\n-        Iterator<LedgerRange> lrIterator = ranges.iterator();\n-        long startOfLedger = 1;\n-        while (lrIterator.hasNext()) {\n-            LedgerRange range = lrIterator.next();\n-            if (range.hasEndSeqIdIncluded()) {\n-                long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n-                ledgers.put(endOfLedger, new InMemoryLedgerRange(range, startOfLedger));\n-                startOfLedger = endOfLedger + 1;\n-                continue;\n-            }\n-            if (lrIterator.hasNext()) {\n-                throw new IOException(\"Ledger-id: \" + range.getLedgerId() + \" for topic: \" + topic\n-                        + \" is not the last one but still does not have an end seq-id\");\n-            }\n-            // admin has read last confirmed entry of last ledger\n-            // so we don't need to handle here\n-        }\n+        ledgers.addAll(ranges);\n         return RC_OK;\n     }\n     \n@@ -201,13 +174,13 @@ protected int _readTopic() throws Exception {\n         } else {\n             return rc;\n         }\n-        \n-        for (Map.Entry<Long, InMemoryLedgerRange> entry : ledgers.entrySet()) {\n-            long endSeqId = entry.getKey();\n+\n+        for (LedgerRange range : ledgers) {\n+            long endSeqId = range.getEndSeqIdIncluded().getLocalComponent();\n             if (endSeqId < startSeqId) {\n                 continue;\n             }\n-            boolean toContinue = readLedger(entry.getValue(), endSeqId);\n+            boolean toContinue = readLedger(range);\n             startSeqId = endSeqId + 1;\n             if (!toContinue) {\n                 break;\n@@ -227,15 +200,16 @@ protected int _readTopic() throws Exception {\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    protected boolean readLedger(InMemoryLedgerRange ledger, long endSeqId) throws BKException, IOException, InterruptedException {\n-        long tEndSeqId = endSeqId;\n-        \n+    protected boolean readLedger(LedgerRange ledger)\n+    throws BKException, IOException, InterruptedException {\n+        long tEndSeqId = ledger.getEndSeqIdIncluded().getLocalComponent();\n+\n         if (tEndSeqId < this.startSeqId) {\n             return true;\n         }\n         // Open Ledger Handle\n-        long ledgerId = ledger.range.getLedgerId();\n-        System.out.println(\"\\n>>>>> Ledger \" + ledgerId + \" [ \" + ledger.startSeqIdIncluded + \" ~ \" + (endSeqId == Long.MAX_VALUE ? \"\" : endSeqId) + \"] <<<<<\\n\");\n+        long ledgerId = ledger.getLedgerId();\n+        System.out.println(\"\\n>>>>> \" + ledger + \" <<<<<\\n\");\n         LedgerHandle lh = null;\n         try {\n             lh = admin.getBkHandle().openLedgerNoRecovery(ledgerId, admin.getBkDigestType(), admin.getBkPasswd());\n@@ -245,15 +219,17 @@ protected boolean readLedger(InMemoryLedgerRange ledger, long endSeqId) throws B\n         if (null == lh) {\n             return true;\n         }\n-        long expectedEntryId = startSeqId - ledger.startSeqIdIncluded;\n+        long expectedEntryId = startSeqId - ledger.getStartSeqIdIncluded();\n         \n         long correctedEndSeqId = tEndSeqId;\n         try {\n             while (startSeqId <= tEndSeqId) {\n                 correctedEndSeqId = Math.min(startSeqId + NUM_MESSAGES_TO_PRINT - 1, tEndSeqId);\n                 \n                 try {\n-                    Enumeration<LedgerEntry> seq = lh.readEntries(startSeqId - ledger.startSeqIdIncluded, correctedEndSeqId - ledger.startSeqIdIncluded);\n+                    Enumeration<LedgerEntry> seq =\n+                        lh.readEntries(startSeqId - ledger.getStartSeqIdIncluded(),\n+                                       correctedEndSeqId - ledger.getStartSeqIdIncluded());\n                     LedgerEntry entry = null;\n                     while (seq.hasMoreElements()) {\n                         entry = seq.nextElement();\n@@ -266,7 +242,7 @@ protected boolean readLedger(InMemoryLedgerRange ledger, long endSeqId) throws B\n                             continue;\n                         }\n                         if (expectedEntryId != entry.getEntryId()\n-                            || (message.getMsgId().getLocalComponent() - ledger.startSeqIdIncluded) != expectedEntryId) {\n+                            || (message.getMsgId().getLocalComponent() - ledger.getStartSeqIdIncluded()) != expectedEntryId) {\n                             throw new IOException(\"ERROR: Message ids are out of order : expected entry id \" + expectedEntryId\n                                                 + \", current entry id \" + entry.getEntryId() + \", msg seq id \" + message.getMsgId().getLocalComponent());\n                         }"},{"sha":"40811de983c6e4e09afe71fd13406efc42b12cbf","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":254,"deletions":76,"changes":330,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -22,6 +22,7 @@\n import java.util.Iterator;\n import java.util.HashSet;\n import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n@@ -30,6 +31,7 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n@@ -59,6 +61,7 @@\n import org.apache.hedwig.server.topics.TopicOwnershipChangeListener;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.zookeeper.SafeAsynBKCallback;\n+import static org.apache.hedwig.util.VarArgs.va;\n \n /**\n  * This persistence manager uses zookeeper and bookkeeper to store messages.\n@@ -80,26 +83,28 @@\n     private ServerConfiguration cfg;\n     private TopicManager tm;\n \n+    private static final long START_SEQ_ID = 1L;\n     // max number of entries allowed in a ledger\n     private static final long UNLIMITED_ENTRIES = 0L;\n     private final long maxEntriesPerLedger;\n \n     static class InMemoryLedgerRange {\n         LedgerRange range;\n-        long startSeqIdIncluded; // included, for the very first ledger, this\n-        // value is 1\n         LedgerHandle handle;\n \n-        public InMemoryLedgerRange(LedgerRange range, long startSeqId, LedgerHandle handle) {\n+        public InMemoryLedgerRange(LedgerRange range, LedgerHandle handle) {\n             this.range = range;\n-            this.startSeqIdIncluded = startSeqId;\n             this.handle = handle;\n         }\n \n-        public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n-            this(range, startSeqId, null);\n+        public InMemoryLedgerRange(LedgerRange range) {\n+            this(range, null);\n         }\n \n+        public long getStartSeqIdIncluded() {\n+            assert range.hasStartSeqIdIncluded();\n+            return range.getStartSeqIdIncluded();\n+        }\n     }\n \n     static class TopicInfo {\n@@ -184,6 +189,14 @@ public BookkeeperPersistenceManager(BookKeeper bk, MetadataManagerFactory metaMa\n         tm.addTopicOwnershipChangeListener(this);\n     }\n \n+    private static LedgerRange buildLedgerRange(long ledgerId, long startOfLedger,\n+                                                MessageSeqId endOfLedger) {\n+        LedgerRange.Builder builder =\n+            LedgerRange.newBuilder().setLedgerId(ledgerId).setStartSeqIdIncluded(startOfLedger)\n+                       .setEndSeqIdIncluded(endOfLedger);\n+        return builder.build();\n+    }\n+\n     class RangeScanOp extends TopicOpQueuer.SynchronousOp {\n         RangeScanRequest request;\n         int numMessagesRead = 0;\n@@ -245,14 +258,14 @@ public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n \n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Issuing a bk read for ledger: \" + imlr.handle.getId() + \" from entry-id: \"\n-                             + (startSeqId - imlr.startSeqIdIncluded) + \" to entry-id: \"\n-                             + (correctedEndSeqId - imlr.startSeqIdIncluded));\n+                             + (startSeqId - imlr.getStartSeqIdIncluded()) + \" to entry-id: \"\n+                             + (correctedEndSeqId - imlr.getStartSeqIdIncluded()));\n             }\n \n-            imlr.handle.asyncReadEntries(startSeqId - imlr.startSeqIdIncluded, correctedEndSeqId\n-            - imlr.startSeqIdIncluded, new SafeAsynBKCallback.ReadCallback() {\n+            imlr.handle.asyncReadEntries(startSeqId - imlr.getStartSeqIdIncluded(), correctedEndSeqId\n+            - imlr.getStartSeqIdIncluded(), new SafeAsynBKCallback.ReadCallback() {\n \n-                long expectedEntryId = startSeqId - imlr.startSeqIdIncluded;\n+                long expectedEntryId = startSeqId - imlr.getStartSeqIdIncluded();\n \n                 @Override\n                 public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n@@ -283,7 +296,7 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n \n                         assert expectedEntryId == entry.getEntryId() : \"expectedEntryId (\" + expectedEntryId\n                         + \") != entry.getEntryId() (\" + entry.getEntryId() + \")\";\n-                        assert (message.getMsgId().getLocalComponent() - imlr.startSeqIdIncluded) == expectedEntryId;\n+                        assert (message.getMsgId().getLocalComponent() - imlr.getStartSeqIdIncluded()) == expectedEntryId;\n \n                         expectedEntryId++;\n                         request.callback.messageScanned(ctx, message);\n@@ -302,7 +315,7 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                     }\n \n                     // continue scanning messages\n-                    scanMessages(request, imlr.startSeqIdIncluded + entry.getEntryId() + 1, numMessagesRead, totalSizeRead);\n+                    scanMessages(request, imlr.getStartSeqIdIncluded() + entry.getEntryId() + 1, numMessagesRead, totalSizeRead);\n                 }\n             }, request.ctx);\n         }\n@@ -314,7 +327,7 @@ protected void startReadingFrom(long startSeqId) {\n             if (entry == null) {\n                 // None of the old ledgers have this seq-id, we must use the\n                 // current ledger\n-                long endSeqId = topicInfo.currentLedgerRange.startSeqIdIncluded\n+                long endSeqId = topicInfo.currentLedgerRange.getStartSeqIdIncluded()\n                                 + topicInfo.lastEntryIdAckedInCurrentLedger;\n \n                 if (endSeqId < startSeqId) {\n@@ -345,34 +358,44 @@ public void deliveredUntil(ByteString topic, Long seqId) {\n     }\n \n     class UpdateLedgerOp extends TopicOpQueuer.AsynchronousOp<Void> {\n-        private long ledgerDeleted;\n+        private Set<Long> ledgersDeleted;\n \n-        public UpdateLedgerOp(ByteString topic, final Callback<Void> cb, final Object ctx, final long ledgerDeleted) {\n+        public UpdateLedgerOp(ByteString topic, final Callback<Void> cb, final Object ctx,\n+                              Set<Long> ledgersDeleted) {\n             queuer.super(topic, cb, ctx);\n-            this.ledgerDeleted = ledgerDeleted;\n+            this.ledgersDeleted = ledgersDeleted;\n         }\n \n         @Override\n         public void run() {\n             final TopicInfo topicInfo = topicInfos.get(topic);\n             if (topicInfo == null) {\n                 logger.error(\"Server is not responsible for topic!\");\n+                cb.operationFailed(ctx, new PubSubException.ServerNotResponsibleForTopicException(\"\"));\n                 return;\n             }\n-            boolean needsUpdate = false;\n             LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n             final Set<Long> keysToRemove = new HashSet<Long>();\n+            boolean foundUnconsumedLedger = false;\n             for (Map.Entry<Long, InMemoryLedgerRange> e : topicInfo.ledgerRanges.entrySet()) {\n-                if (e.getValue().range.getLedgerId() == ledgerDeleted) {\n-                    needsUpdate = true;\n+                LedgerRange lr = e.getValue().range;\n+                long ledgerId = lr.getLedgerId();\n+                if (!foundUnconsumedLedger && ledgersDeleted.contains(ledgerId)) {\n                     keysToRemove.add(e.getKey());\n+                    if (!lr.hasEndSeqIdIncluded()) {\n+                        String msg = \"Should not remove unclosed ledger \" + ledgerId + \" for topic \" + topic.toStringUtf8();\n+                        logger.error(msg);\n+                        cb.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                        return;\n+                    }\n                 } else {\n-                    builder.addRanges(e.getValue().range);\n+                    foundUnconsumedLedger = true;\n+                    builder.addRanges(lr);\n                 }\n             }\n             builder.addRanges(topicInfo.currentLedgerRange.range);\n \n-            if (needsUpdate) {\n+            if (!keysToRemove.isEmpty()) {\n                 final LedgerRanges newRanges = builder.build();\n                 tpManager.writeTopicPersistenceInfo(\n                 topic, newRanges, topicInfo.ledgerRangesVersion, new Callback<Version>() {\n@@ -410,35 +433,80 @@ public void runInternal() {\n                 return;\n             }\n \n+            final LinkedList<Long> ledgersToDelete = new LinkedList<Long>();\n             for (Long endSeqIdIncluded : topicInfo.ledgerRanges.keySet()) {\n                 if (endSeqIdIncluded <= seqId) {\n                     // This ledger's message entries have all been consumed already\n                     // so it is safe to delete it from BookKeeper.\n                     long ledgerId = topicInfo.ledgerRanges.get(endSeqIdIncluded).range.getLedgerId();\n-                    try {\n-                        bk.deleteLedger(ledgerId);\n-                        Callback<Void> cb = new Callback<Void>() {\n-                            public void operationFinished(Object ctx, Void result) {\n-                                // do nothing, op is async to stop other ops\n-                                // occurring on the topic during the update\n-                            }\n-                            public void operationFailed(Object ctx, PubSubException exception) {\n-                                logger.error(\"Failed to update ledger znode\", exception);\n-                            }\n-                        };\n-                        queuer.pushAndMaybeRun(topic, new UpdateLedgerOp(topic, cb, null, ledgerId));\n-                    } catch (Exception e) {\n-                        // For now, just log an exception error message. In the\n-                        // future, we can have more complicated retry logic to\n-                        // delete a consumed ledger. The next time the ledger\n-                        // garbage collection job runs, we'll once again try to\n-                        // delete this ledger.\n-                        logger.error(\"Exception while deleting consumed ledgerId: \" + ledgerId, e);\n-                    }\n-                } else\n+                    ledgersToDelete.add(ledgerId);\n+                } else {\n                     break;\n+                }\n             }\n+\n+            // no ledgers need to delete\n+            if (ledgersToDelete.isEmpty()) {\n+                return;\n+            }\n+\n+            Set<Long> ledgersDeleted = new HashSet<Long>();\n+            deleteLedgersAndUpdateLedgersRange(topic, ledgersToDelete, ledgersDeleted);\n+        }\n+    }\n+\n+    private void deleteLedgersAndUpdateLedgersRange(final ByteString topic,\n+                                                    final LinkedList<Long> ledgersToDelete,\n+                                                    final Set<Long> ledgersDeleted) {\n+        if (ledgersToDelete.isEmpty()) {\n+            Callback<Void> cb = new Callback<Void>() {\n+                public void operationFinished(Object ctx, Void result) {\n+                    // do nothing, op is async to stop other ops\n+                    // occurring on the topic during the update\n+                }\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    logger.error(\"Failed to update ledger znode for topic {} deleting ledgers {} : {}\",\n+                                 va(topic.toStringUtf8(), ledgersDeleted, exception.getMessage()));\n+                }\n+            };\n+            queuer.pushAndMaybeRun(topic, new UpdateLedgerOp(topic, cb, null, ledgersDeleted));\n+            return;\n+        }\n+\n+        final Long ledger = ledgersToDelete.poll();\n+        if (null == ledger) {\n+            deleteLedgersAndUpdateLedgersRange(topic, ledgersToDelete, ledgersDeleted);\n+            return;\n         }\n+\n+        bk.asyncDeleteLedger(ledger, new DeleteCallback() {\n+            @Override\n+            public void deleteComplete(int rc, Object ctx) {\n+                if (BKException.Code.NoSuchLedgerExistsException == rc ||\n+                    BKException.Code.OK == rc) {\n+                    ledgersDeleted.add(ledger);\n+                    deleteLedgersAndUpdateLedgersRange(topic, ledgersToDelete, ledgersDeleted);\n+                    return;\n+                } else {\n+                    logger.warn(\"Exception while deleting consumed ledger {}, stop deleting other ledgers {} \"\n+                                + \"and update ledger ranges with deleted ledgers {} : {}\",\n+                                va(ledger, ledgersToDelete, ledgersDeleted, BKException.create(rc)));\n+                    // We should not continue when failed to delete ledger\n+                    Callback<Void> cb = new Callback<Void>() {\n+                        public void operationFinished(Object ctx, Void result) {\n+                            // do nothing, op is async to stop other ops\n+                            // occurring on the topic during the update\n+                        }\n+                        public void operationFailed(Object ctx, PubSubException exception) {\n+                            logger.error(\"Failed to update ledger znode for topic {} deleting ledgers {} : {}\",\n+                                         va(topic, ledgersDeleted, exception.getMessage()));\n+                        }\n+                    };\n+                    queuer.pushAndMaybeRun(topic, new UpdateLedgerOp(topic, cb, null, ledgersDeleted));\n+                    return;\n+                }\n+            }\n+        }, null);\n     }\n \n     public void consumedUntil(ByteString topic, Long seqId) {\n@@ -575,7 +643,7 @@ protected void doPersistMessage(final PersistRequest request) {\n \n         // check whether reach the threshold of a ledger, if it does,\n         // open a ledger to write\n-        long entriesInThisLedger = localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded + 1;\n+        long entriesInThisLedger = localSeqId - topicInfo.currentLedgerRange.getStartSeqIdIncluded() + 1;\n         if (UNLIMITED_ENTRIES != maxEntriesPerLedger &&\n             entriesInThisLedger >= maxEntriesPerLedger) {\n             if (topicInfo.doChangeLedger.compareAndSet(false, true)) {\n@@ -616,9 +684,9 @@ public void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n                     return;\n                 }\n \n-                if (entryId + topicInfo.currentLedgerRange.startSeqIdIncluded != localSeqId) {\n+                if (entryId + topicInfo.currentLedgerRange.getStartSeqIdIncluded() != localSeqId) {\n                     String msg = \"Expected BK to assign entry-id: \"\n-                                 + (localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded)\n+                                 + (localSeqId - topicInfo.currentLedgerRange.getStartSeqIdIncluded())\n                                  + \" but it instead assigned entry-id: \" + entryId + \" topic: \"\n                                  + topic.toStringUtf8() + \"ledger: \" + lh.getId();\n                     logger.error(msg);\n@@ -630,7 +698,7 @@ public void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n                 // if this acked entry is the last entry of current ledger\n                 // we can add a ChangeLedgerOp to execute to change ledger\n                 if (topicInfo.doChangeLedger.get() &&\n-                    entryId + topicInfo.currentLedgerRange.startSeqIdIncluded == topicInfo.lastSeqIdBeforeLedgerChange) {\n+                    entryId + topicInfo.currentLedgerRange.getStartSeqIdIncluded() == topicInfo.lastSeqIdBeforeLedgerChange) {\n                     // change ledger\n                     changeLedger(topic, new Callback<Void>() {\n                         @Override\n@@ -708,19 +776,106 @@ public void operationFailed(Object ctx, PubSubException exception) {\n         }\n \n         void processTopicLedgerRanges(final LedgerRanges ranges, final Version version) {\n-            Iterator<LedgerRange> lrIterator = ranges.getRangesList().iterator();\n-            TopicInfo topicInfo = new TopicInfo();\n+            final List<LedgerRange> rangesList = ranges.getRangesList();\n+            if (!rangesList.isEmpty()) {\n+                LedgerRange range = rangesList.get(0);\n+                if (range.hasStartSeqIdIncluded()) {\n+                    // we already have start seq id\n+                    processTopicLedgerRanges(rangesList, version, range.getStartSeqIdIncluded());\n+                    return;\n+                }\n+                getStartSeqIdToProcessTopicLedgerRanges(rangesList, version);\n+                return;\n+            }\n+            // process topic ledger ranges directly\n+            processTopicLedgerRanges(rangesList, version, START_SEQ_ID);\n+        }\n \n-            long startOfLedger = 1;\n+        /**\n+         * Process old version ledger ranges to fetch start seq id.\n+         */\n+        void getStartSeqIdToProcessTopicLedgerRanges(\n+            final List<LedgerRange> rangesList, final Version version) {\n+\n+            final LedgerRange range = rangesList.get(0);\n+\n+            if (!range.hasEndSeqIdIncluded()) {\n+                // process topic ledger ranges directly\n+                processTopicLedgerRanges(rangesList, version, START_SEQ_ID);\n+                return;\n+            }\n+\n+            final long ledgerId = range.getLedgerId();\n+            // open the first ledger to compute right start seq id\n+            bk.asyncOpenLedger(ledgerId, DigestType.CRC32, passwd,\n+            new SafeAsynBKCallback.OpenCallback() {\n+\n+                @Override\n+                public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n+\n+                    if (rc == BKException.Code.NoSuchLedgerExistsException) {\n+                        // process next ledger \n+                        processTopicLedgerRanges(rangesList, version, START_SEQ_ID);\n+                        return;\n+                    } else if (rc != BKException.Code.OK) {\n+                        BKException bke = BKException.create(rc);\n+                        logger.error(\"Could not open ledger {} to get start seq id while acquiring topic {} : {}\",\n+                                     va(ledgerId, topic.toStringUtf8(), bke));\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                        return;\n+                    }\n+\n+                    final long numEntriesInLastLedger = ledgerHandle.getLastAddConfirmed() + 1;\n+\n+                    // the ledger is closed before, calling close is just a nop operation.\n+                    try {\n+                        ledgerHandle.close();\n+                    } catch (InterruptedException ie) {\n+                        // the exception would never be thrown for a read only ledger handle.\n+                    } catch (BKException bke) {\n+                        // the exception would never be thrown for a read only ledger handle.\n+                    }\n \n+                    if (numEntriesInLastLedger <= 0) {\n+                        String msg = \"No entries found in a have-end-seq-id ledger \" + ledgerId\n+                                     + \" when acquiring topic \" + topic.toStringUtf8() + \".\";\n+                        logger.error(msg);\n+                        cb.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                        return;\n+                    }\n+                    long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                    long startOfLedger = endOfLedger - numEntriesInLastLedger + 1;\n+\n+                    processTopicLedgerRanges(rangesList, version, startOfLedger);\n+                }\n+\n+            }, ctx);\n+        }\n+\n+        void processTopicLedgerRanges(final List<LedgerRange> rangesList, final Version version,\n+                                      long startOfLedger) {\n+            logger.info(\"Process {} ledgers for topic {} starting from seq id {}.\",\n+                        va(rangesList.size(), topic.toStringUtf8(), startOfLedger));\n+\n+            Iterator<LedgerRange> lrIterator = rangesList.iterator();\n+\n+            TopicInfo topicInfo = new TopicInfo();\n             while (lrIterator.hasNext()) {\n                 LedgerRange range = lrIterator.next();\n \n                 if (range.hasEndSeqIdIncluded()) {\n                     // this means it was a valid and completely closed ledger\n                     long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n-                    topicInfo.ledgerRanges.put(endOfLedger, new InMemoryLedgerRange(range, startOfLedger));\n-                    startOfLedger = endOfLedger + 1;\n+                    if (range.hasStartSeqIdIncluded()) {\n+                        startOfLedger = range.getStartSeqIdIncluded();\n+                    } else {\n+                        range = buildLedgerRange(range.getLedgerId(), startOfLedger,\n+                                                 range.getEndSeqIdIncluded());\n+                    }\n+                    topicInfo.ledgerRanges.put(endOfLedger, new InMemoryLedgerRange(range));\n+                    if (startOfLedger < endOfLedger + 1) {\n+                        startOfLedger = endOfLedger + 1;\n+                    }\n                     continue;\n                 }\n \n@@ -733,14 +888,19 @@ void processTopicLedgerRanges(final LedgerRanges ranges, final Version version)\n                     return;\n                 }\n \n+                if (range.hasStartSeqIdIncluded()) {\n+                    startOfLedger = range.getStartSeqIdIncluded();\n+                }\n+\n                 // The last ledger does not have a valid seq-id, lets try to\n                 // find it out\n-                recoverLastTopicLedgerAndOpenNewOne(range.getLedgerId(), version, topicInfo);\n+                recoverLastTopicLedgerAndOpenNewOne(range.getLedgerId(), startOfLedger,\n+                                                    version, topicInfo);\n                 return;\n             }\n \n             // All ledgers were found properly closed, just start a new one\n-            openNewTopicLedger(topic, version, topicInfo, false, cb, ctx);\n+            openNewTopicLedger(topic, version, topicInfo, startOfLedger, false, cb, ctx);\n         }\n \n         /**\n@@ -749,9 +909,15 @@ void processTopicLedgerRanges(final LedgerRanges ranges, final Version version)\n          *\n          * @param ledgerId\n          *            Ledger to be recovered\n+         * @param expectedStartSeqId \n+         *            Start seq id of the ledger to recover\n+         * @param expectedVersionOfLedgerNode\n+         *            Expected version to update ledgers range\n+         * @param topicInfo\n+         *            Topic info\n          */\n-        private void recoverLastTopicLedgerAndOpenNewOne(final long ledgerId, final Version expectedVersionOfLedgerNode,\n-                final TopicInfo topicInfo) {\n+        private void recoverLastTopicLedgerAndOpenNewOne(final long ledgerId, final long expectedStartSeqId,\n+                final Version expectedVersionOfLedgerNode, final TopicInfo topicInfo) {\n \n             bk.asyncOpenLedger(ledgerId, DigestType.CRC32, passwd, new SafeAsynBKCallback.OpenCallback() {\n                 @Override\n@@ -772,7 +938,8 @@ public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n                         // couldn't write to, so just ignore it\n                         logger.info(\"Pruning empty ledger: \" + ledgerId + \" for topic: \" + topic.toStringUtf8());\n                         closeLedger(ledgerHandle);\n-                        openNewTopicLedger(topic, expectedVersionOfLedgerNode, topicInfo, false, cb, ctx);\n+                        openNewTopicLedger(topic, expectedVersionOfLedgerNode, topicInfo,\n+                                           expectedStartSeqId, false, cb, ctx);\n                         return;\n                     }\n \n@@ -803,17 +970,25 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                                 return;\n                             }\n \n-                            long prevLedgerEnd = topicInfo.ledgerRanges.isEmpty() ? 0 : topicInfo.ledgerRanges\n-                                                 .lastKey();\n-                            LedgerRange lr = LedgerRange.newBuilder().setLedgerId(ledgerId)\n-                                             .setEndSeqIdIncluded(lastMessage.getMsgId()).build();\n-                            topicInfo.ledgerRanges.put(lr.getEndSeqIdIncluded().getLocalComponent(),\n-                                    new InMemoryLedgerRange(lr, prevLedgerEnd + 1, lh));\n+                            long endOfLedger  = lastMessage.getMsgId().getLocalComponent();\n+                            long startOfLedger = endOfLedger - numEntriesInLastLedger + 1;\n+\n+                            if (startOfLedger != expectedStartSeqId) {\n+                                // gap would be introduced by old version when gc consumed ledgers\n+                                String msg = \"Expected start seq id of recovered ledger \" + ledgerId\n+                                             + \" to be \" + expectedStartSeqId + \" but it was \"\n+                                             + startOfLedger + \".\";\n+                                logger.warn(msg);\n+                            }\n+\n+                            LedgerRange lr = buildLedgerRange(ledgerId, startOfLedger, lastMessage.getMsgId());\n+                            topicInfo.ledgerRanges.put(endOfLedger,\n+                                    new InMemoryLedgerRange(lr, lh));\n \n-                            logger.info(\"Recovered unclosed ledger: \" + ledgerId + \" for topic: \"\n-                                        + topic.toStringUtf8() + \" with \" + numEntriesInLastLedger + \" entries\");\n+                            logger.info(\"Recovered unclosed ledger: {} for topic: {} with {} entries starting from seq id {}\",\n+                                        va(ledgerId, topic.toStringUtf8(), numEntriesInLastLedger, startOfLedger));\n \n-                            openNewTopicLedger(topic, expectedVersionOfLedgerNode, topicInfo, false, cb, ctx);\n+                            openNewTopicLedger(topic, expectedVersionOfLedgerNode, topicInfo, endOfLedger + 1, false, cb, ctx);\n                         }\n                     }, ctx);\n \n@@ -832,6 +1007,8 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n      *          Expected Version to Update Ledgers Node.\n      * @param topicInfo\n      *          Topic Information\n+     * @param startSeqId\n+     *          Start of sequence id for new ledger\n      * @param changeLedger\n      *          Whether is it called when changing ledger\n      * @param cb\n@@ -841,7 +1018,7 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n      */\n     void openNewTopicLedger(final ByteString topic,\n                             final Version expectedVersionOfLedgersNode, final TopicInfo topicInfo,\n-                            final boolean changeLedger,\n+                            final long startSeqId, final boolean changeLedger,\n                             final Callback<Void> cb, final Object ctx) {\n         bk.asyncCreateLedger(cfg.getBkEnsembleSize(), cfg.getBkQuorumSize(), DigestType.CRC32, passwd,\n         new SafeAsynBKCallback.CreateCallback() {\n@@ -864,13 +1041,13 @@ public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n                 // compute last seq id\n                 if (!changeLedger) {\n                     topicInfo.lastSeqIdPushed = topicInfo.ledgerRanges.isEmpty() ? MessageSeqId.newBuilder()\n-                                                .setLocalComponent(0).build() : topicInfo.ledgerRanges.lastEntry().getValue().range\n+                                                .setLocalComponent(startSeqId - 1).build() : topicInfo.ledgerRanges.lastEntry().getValue().range\n                                                 .getEndSeqIdIncluded();\n                 }\n \n-                LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(lh.getId()).build();\n-                topicInfo.currentLedgerRange = new InMemoryLedgerRange(lastRange, topicInfo.lastSeqIdPushed\n-                        .getLocalComponent() + 1, lh);\n+                LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(lh.getId())\n+                                        .setStartSeqIdIncluded(startSeqId).build();\n+                topicInfo.currentLedgerRange = new InMemoryLedgerRange(lastRange, lh);\n \n                 // Persist the fact that we started this new\n                 // ledger to ZK\n@@ -950,18 +1127,19 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                         cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n                         return;\n                     }\n+                    long endSeqId = topicInfo.lastSeqIdPushed.getLocalComponent();\n                     // update last range\n-                    LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(ledgerId)\n-                                            .setEndSeqIdIncluded(topicInfo.lastSeqIdPushed).build();\n+                    LedgerRange lastRange =\n+                        buildLedgerRange(ledgerId, topicInfo.currentLedgerRange.getStartSeqIdIncluded(),\n+                                         topicInfo.lastSeqIdPushed);\n \n                     topicInfo.currentLedgerRange.range = lastRange;\n                     // put current ledger to ledger ranges\n-                    topicInfo.ledgerRanges.put(topicInfo.lastSeqIdPushed.getLocalComponent(),\n-                                               topicInfo.currentLedgerRange);\n+                    topicInfo.ledgerRanges.put(endSeqId, topicInfo.currentLedgerRange);\n                     logger.info(\"Closed written ledger \" + ledgerId + \" for topic \"\n                               + topic.toStringUtf8() + \" to change ledger.\");\n                     openNewTopicLedger(topic, topicInfo.ledgerRangesVersion,\n-                                       topicInfo, true, cb, ctx);\n+                                       topicInfo, endSeqId + 1, true, cb, ctx);\n                 }\n             }, ctx);\n         }"},{"sha":"c645b11bc4c02f5d6ad5d31aa3fe594b65597fe3","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","status":"modified","additions":341,"deletions":7,"changes":348,"blob_url":"https://github.com/apache/bookkeeper/blob/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java?ref=223a3fb3fbc78fe4dc1922967fe3daa3edfc3fb2","patch":"@@ -17,9 +17,13 @@\n  */\n package org.apache.hedwig.server.persistence;\n \n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Iterator;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n@@ -28,23 +32,36 @@\n \n import junit.framework.TestCase;\n \n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n import org.apache.hedwig.HelperMethods;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.SubscriptionDataManager;\n+import org.apache.hedwig.server.meta.TopicOwnershipManager;\n+import org.apache.hedwig.server.meta.TopicPersistenceManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.util.Callback;\n+import org.apache.zookeeper.ZooKeeper;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.protobuf.ByteString;\n \n+@RunWith(Parameterized.class)\n public class TestBookKeeperPersistenceManager extends TestCase {\n     static Logger logger = LoggerFactory.getLogger(TestPersistenceManagerBlackBox.class);\n \n@@ -58,11 +75,114 @@\n     TopicManager tm;\n     BookkeeperPersistenceManager manager;\n     PubSubException failureException = null;\n-    MetadataManagerFactory metadataManagerFactory;\n+    TestMetadataManagerFactory metadataManagerFactory;\n+    TopicPersistenceManager tpManager;\n+\n+    boolean removeStartSeqId;\n+\n+    static class TestMetadataManagerFactory extends MetadataManagerFactory {\n+\n+        final MetadataManagerFactory factory;\n+        int serviceDownCount = 0;\n+\n+        TestMetadataManagerFactory(ServerConfiguration conf, ZooKeeper zk) throws Exception {\n+            factory = MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+        }\n+\n+        public void setServiceDownCount(int count) {\n+            this.serviceDownCount = count;\n+        }\n+\n+        @Override\n+        public int getCurrentVersion() {\n+            return factory.getCurrentVersion();\n+        }\n+\n+        @Override\n+        protected MetadataManagerFactory initialize(\n+            ServerConfiguration cfg, ZooKeeper zk, int version) throws IOException {\n+            // do nothing\n+            return factory;\n+        }\n+\n+        @Override\n+        public void shutdown() throws IOException {\n+            factory.shutdown();\n+        }\n+\n+        @Override\n+        public Iterator<ByteString> getTopics() throws IOException {\n+            return factory.getTopics();\n+        }\n+\n+        @Override\n+        public TopicPersistenceManager newTopicPersistenceManager() {\n+            final TopicPersistenceManager manager = factory.newTopicPersistenceManager();\n+            return new TopicPersistenceManager() {\n+\n+                @Override\n+                public void close() throws IOException {\n+                    manager.close();\n+                }\n+\n+                @Override\n+                public void readTopicPersistenceInfo(ByteString topic,\n+                                                     Callback<Versioned<LedgerRanges>> callback, Object ctx) {\n+                    if (serviceDownCount > 0) {\n+                        --serviceDownCount;\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(\"Metadata Store is down\"));\n+                        return;\n+                    }\n+                    manager.readTopicPersistenceInfo(topic, callback, ctx);\n+                }\n+                @Override\n+                public void writeTopicPersistenceInfo(ByteString topic, LedgerRanges ranges, Version version,\n+                                                      Callback<Version> callback, Object ctx) {\n+                    if (serviceDownCount > 0) {\n+                        --serviceDownCount;\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(\"Metadata Store is down\"));\n+                        return;\n+                    }\n+                    manager.writeTopicPersistenceInfo(topic, ranges, version, callback, ctx);\n+                }\n+                @Override\n+                public void deleteTopicPersistenceInfo(ByteString topic, Version version,\n+                                                       Callback<Void> callback, Object ctx) {\n+                    if (serviceDownCount > 0) {\n+                        --serviceDownCount;\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(\"Metadata Store is down\"));\n+                        return;\n+                    }\n+                    manager.deleteTopicPersistenceInfo(topic, version, callback, ctx);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public SubscriptionDataManager newSubscriptionDataManager() {\n+            return factory.newSubscriptionDataManager();\n+        }\n+\n+        @Override\n+        public TopicOwnershipManager newTopicOwnershipManager() {\n+            return factory.newTopicOwnershipManager();\n+        }\n+    }\n+\n+    public TestBookKeeperPersistenceManager(boolean removeStartSeqId) {\n+        this.removeStartSeqId = removeStartSeqId;\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] {\n+            { true }, { false }\n+        });\n+    }\n \n     @Override\n     @Before\n-    protected void setUp() throws Exception {\n+    public void setUp() throws Exception {\n         super.setUp();\n \n         // delay read response for 2s.\n@@ -76,8 +196,8 @@ protected void setUp() throws Exception {\n         .setThrottleValue(3);\n         conf.addConf(bkClientConf);\n \n-        metadataManagerFactory =\n-            MetadataManagerFactory.newMetadataManagerFactory(conf, bktb.getZooKeeperClient());\n+        metadataManagerFactory = new TestMetadataManagerFactory(conf, bktb.getZooKeeperClient());\n+        tpManager = metadataManagerFactory.newTopicPersistenceManager();\n \n         scheduler = Executors.newScheduledThreadPool(1);\n         tm = new TrivialOwnAllTopicManager(conf, scheduler);\n@@ -87,9 +207,10 @@ protected void setUp() throws Exception {\n \n     @Override\n     @After\n-    protected void tearDown() throws Exception {\n+    public void tearDown() throws Exception {\n         tm.stop();\n         manager.stop();\n+        tpManager.close();\n         metadataManagerFactory.shutdown();\n         scheduler.shutdown();\n         bktb.tearDown();\n@@ -108,6 +229,7 @@ public RangeScanVerifier(LinkedList<Message> pubMsgs, RangeScanRequest nextScan)\n \n         @Override\n         public void messageScanned(Object ctx, Message recvMessage) {\n+            logger.info(\"Scanned message : {}\", recvMessage.getMsgId().getLocalComponent());\n             if (null != nextScan && !runNextScan) {\n                 runNextScan = true;\n                 manager.scanMessages(nextScan);\n@@ -133,7 +255,7 @@ public void scanFailed(Object ctx, Exception exception) {\n         public void scanFinished(Object ctx, ReasonForFinish reason) {\n             LinkedBlockingQueue<Boolean> statusQueue = (LinkedBlockingQueue<Boolean>) ctx;\n             try {\n-                statusQueue.put(true);\n+                statusQueue.put(pubMsgs.isEmpty());\n             } catch (InterruptedException e) {\n                 throw new RuntimeException(e);\n             }\n@@ -149,6 +271,164 @@ public void scanFinished(Object ctx, ReasonForFinish reason) {\n         return result;\n     }\n \n+    @Test\n+    public void testScanMessagesOnClosedLedgerAfterDeleteLedger() throws Exception {\n+        scanMessagesAfterDeleteLedgerTest(2);\n+    }\n+\n+    @Test\n+    public void testScanMessagesOnUnclosedLedgerAfterDeleteLedger() throws Exception {\n+        scanMessagesAfterDeleteLedgerTest(1);\n+    }\n+\n+    private void scanMessagesAfterDeleteLedgerTest(int numLedgers) throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"TestScanMessagesAfterDeleteLedger\");\n+\n+        List<Message> msgs = new ArrayList<Message>();\n+\n+        acquireTopic(topic);\n+        msgs.addAll(publishMessages(topic, 2));\n+\n+        for (int i=0; i<numLedgers; i++) {\n+            releaseTopic(topic);\n+            // acquire topic again to force a new ledger\n+            acquireTopic(topic);\n+            msgs.addAll(publishMessages(topic, 2));\n+        }\n+\n+        consumedUntil(topic, 2L);\n+        // Wait until ledger ranges is updated.\n+        Thread.sleep(2000L);\n+        releaseTopic(topic);\n+\n+        // acquire topic again\n+        acquireTopic(topic);\n+        // scan messages starting from 3\n+        LinkedBlockingQueue<Boolean> statusQueue =\n+            new LinkedBlockingQueue<Boolean>();\n+        manager.scanMessages(new RangeScanRequest(topic, 3, 2, Long.MAX_VALUE,\n+                             new RangeScanVerifier(subMessages(msgs, 2, 3), null), statusQueue));\n+        Boolean b = statusQueue.poll(10 * readDelay, TimeUnit.MILLISECONDS);\n+        assertTrue(\"Should succeed to scan messages after deleted consumed ledger.\", b);\n+    }\n+\n+    @Test\n+    public void testScanMessagesOnEmptyLedgerAfterDeleteLedger() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"TestScanMessagesOnEmptyLedgerAfterDeleteLedger\");\n+\n+        List<Message> msgs = new ArrayList<Message>();\n+\n+        acquireTopic(topic);\n+        msgs.addAll(publishMessages(topic, 2));\n+        releaseTopic(topic);\n+\n+        // acquire topic again to force a new ledger\n+        acquireTopic(topic);\n+        logger.info(\"Consumed messages.\");\n+        consumedUntil(topic, 2L);\n+        // Wait until ledger ranges is updated.\n+        Thread.sleep(2000L);\n+        logger.info(\"Released topic with an empty ledger.\");\n+        // release topic to force an empty ledger\n+        releaseTopic(topic);\n+\n+        // publish 2 more messages, these message expected to be id 3 and 4\n+        acquireTopic(topic);\n+        logger.info(\"Published more messages.\");\n+        msgs.addAll(publishMessages(topic, 2));\n+        releaseTopic(topic);\n+\n+        // acquire topic again\n+        acquireTopic(topic);\n+        // scan messages starting from 3\n+        LinkedBlockingQueue<Boolean> statusQueue =\n+            new LinkedBlockingQueue<Boolean>();\n+        long startSeqId = removeStartSeqId ? 1 : 3;\n+        manager.scanMessages(new RangeScanRequest(topic, startSeqId, 2, Long.MAX_VALUE,\n+                             new RangeScanVerifier(subMessages(msgs, 2, 3), null), statusQueue));\n+        Boolean b = statusQueue.poll(10 * readDelay, TimeUnit.MILLISECONDS);\n+        assertTrue(\"Should succeed to scan messages after deleted consumed ledger.\", b);\n+    }\n+\n+    @Test\n+    public void testFailedToDeleteLedger1() throws Exception {\n+        failedToDeleteLedgersTest(1);\n+    }\n+\n+    @Test\n+    public void testFailedToDeleteLedger2() throws Exception {\n+        // succeed to delete second ledger\n+        failedToDeleteLedgersTest(2);\n+    }\n+\n+    private void failedToDeleteLedgersTest(int numLedgers) throws Exception {\n+        final ByteString topic = ByteString.copyFromUtf8(\"TestFailedToDeleteLedger\");\n+        final int serviceDownCount = 1;\n+\n+        List<Message> msgs = new ArrayList<Message>();\n+\n+        for (int i=0; i<numLedgers; i++) {\n+            acquireTopic(topic);\n+            msgs.addAll(publishMessages(topic, 2));\n+            releaseTopic(topic);\n+        }\n+\n+        // acquire topic again to force a new ledger\n+        acquireTopic(topic);\n+        logger.info(\"Consumed messages.\");\n+        metadataManagerFactory.setServiceDownCount(serviceDownCount);\n+        // failed consumed\n+        consumedUntil(topic, 2L * numLedgers);\n+        // Wait until ledger ranges is updated.\n+        Thread.sleep(2000L);\n+        logger.info(\"Released topic with an empty ledger.\");\n+        // release topic to force an empty ledger\n+        releaseTopic(topic);\n+\n+        // publish 2 more messages, these message expected to be id 3 and 4\n+        acquireTopic(topic);\n+        logger.info(\"Published more messages.\");\n+        msgs.addAll(publishMessages(topic, 2));\n+        releaseTopic(topic);\n+\n+        // acquire topic again\n+        acquireTopic(topic);\n+        LinkedBlockingQueue<Boolean> statusQueue =\n+            new LinkedBlockingQueue<Boolean>();\n+        manager.scanMessages(new RangeScanRequest(topic, numLedgers * 2 + 1, 2, Long.MAX_VALUE,\n+                             new RangeScanVerifier(subMessages(msgs, numLedgers * 2, numLedgers * 2 + 1), null), statusQueue));\n+        Boolean b = statusQueue.poll(10 * readDelay, TimeUnit.MILLISECONDS);\n+        assertTrue(\"Should succeed to scan messages after deleted consumed ledger.\", b);\n+\n+        // consumed \n+        consumedUntil(topic, (numLedgers + 1) * 2L);\n+        // Wait until ledger ranges is updated.\n+        Thread.sleep(2000L);\n+\n+        Semaphore latch = new Semaphore(1);\n+        latch.acquire();\n+        tpManager.readTopicPersistenceInfo(topic, new Callback<Versioned<LedgerRanges>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Versioned<LedgerRanges> ranges) {\n+                if (null == ranges || ranges.getValue().getRangesList().size() > 1) {\n+                    failureException = new PubSubException.NoTopicPersistenceInfoException(\"Invalid persistence info found for topic \" + topic.toStringUtf8());\n+                    ((Semaphore)ctx).release();\n+                    return;\n+                }\n+                failureException = null;\n+                ((Semaphore)ctx).release();\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                failureException = exception;\n+                ((Semaphore)ctx).release();\n+            }\n+        }, latch);\n+        latch.acquire();\n+        latch.release();\n+        assertNull(\"Should not fail with exception.\", failureException);\n+    }\n+\n     @Test\n     public void testScanMessagesOnTwoLedgers() throws Exception {\n         ByteString topic = ByteString.copyFromUtf8(\"TestScanMessagesOnTwoLedgers\");\n@@ -245,8 +525,62 @@ public void operationFailed(Object ctx, PubSubException exception) {\n         }\n     }\n \n-    protected void releaseTopic(ByteString topic) throws Exception {\n+    protected void releaseTopic(final ByteString topic) throws Exception {\n         manager.lostTopic(topic);\n+        // backward testing ledger ranges without start seq id\n+        if (removeStartSeqId) {\n+            Semaphore latch = new Semaphore(1);\n+            latch.acquire();\n+            tpManager.readTopicPersistenceInfo(topic, new Callback<Versioned<LedgerRanges>>() {\n+                @Override\n+                public void operationFinished(Object ctx, Versioned<LedgerRanges> ranges) {\n+                    if (null == ranges) {\n+                        failureException = new PubSubException.NoTopicPersistenceInfoException(\"No persistence info found for topic \" + topic.toStringUtf8());\n+                        ((Semaphore)ctx).release();\n+                        return;\n+                    }\n+\n+                    // build a new ledger ranges w/o start seq id.\n+                    LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n+                    final List<LedgerRange> rangesList = ranges.getValue().getRangesList();\n+                    for (LedgerRange range : rangesList) {\n+                        LedgerRange.Builder newRangeBuilder = LedgerRange.newBuilder();\n+                        newRangeBuilder.setLedgerId(range.getLedgerId());\n+                        if (range.hasEndSeqIdIncluded()) {\n+                            newRangeBuilder.setEndSeqIdIncluded(range.getEndSeqIdIncluded());\n+                        }\n+                        builder.addRanges(newRangeBuilder.build());\n+                    }\n+                    tpManager.writeTopicPersistenceInfo(topic, builder.build(), ranges.getVersion(),\n+                    new Callback<Version>() {\n+                        @Override\n+                        public void operationFinished(Object ctx, Version newVersion) {\n+                            failureException = null;\n+                            ((Semaphore)ctx).release();\n+                        }\n+                        @Override\n+                        public void operationFailed(Object ctx, PubSubException exception) {\n+                            failureException = exception;\n+                            ((Semaphore)ctx).release();\n+                        }\n+                    }, ctx);\n+                }\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    failureException = exception;\n+                    ((Semaphore)ctx).release();\n+                }\n+            }, latch);\n+            latch.acquire();\n+            latch.release();\n+            if (null != failureException) {\n+                throw failureException;\n+            }\n+        }\n+    }\n+\n+    protected void consumedUntil(ByteString topic, long seqId) throws Exception {\n+        manager.consumedUntil(topic, seqId);\n     }\n \n }"}]}

