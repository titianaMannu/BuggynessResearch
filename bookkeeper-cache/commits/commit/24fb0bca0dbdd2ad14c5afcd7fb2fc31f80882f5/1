{"sha":"24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyNGZiMGJjYTBkYmRkMmFkMTRjNWFmY2Q3ZmIyZmMzMWY4MDg4MmY1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-04T10:40:29Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-04T10:40:29Z"},"message":"BOOKKEEPER-278: Ability to disable auto recovery temporarily (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1393983 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"53028b4e8936e438b1c6573759928b71886bacbe","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/53028b4e8936e438b1c6573759928b71886bacbe"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","html_url":"https://github.com/apache/bookkeeper/commit/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"853ac6bf0107a8b80e44328ce825a8e710ee8986","url":"https://api.github.com/repos/apache/bookkeeper/commits/853ac6bf0107a8b80e44328ce825a8e710ee8986","html_url":"https://github.com/apache/bookkeeper/commit/853ac6bf0107a8b80e44328ce825a8e710ee8986"}],"stats":{"total":416,"additions":395,"deletions":21},"files":[{"sha":"032a2a4129e71f53e436959ba0310f733d1137ce","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -146,6 +146,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-388: Document bookie format command (kiran_bc via ivank)\n \n+        BOOKKEEPER-278: Ability to disable auto recovery temporarily (rakeshr via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"a3d13241b3f50f468189f66d15075a38f75fa91a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","status":"modified","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -17,6 +17,7 @@\n  */\n package org.apache.bookkeeper.meta;\n \n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.replication.ReplicationException;\n \n /**\n@@ -61,4 +62,39 @@ void releaseUnderreplicatedLedger(long ledgerId)\n      */\n     void close()\n             throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Stop ledger replication. Currently running ledger rereplication tasks\n+     * will be continued and will be stopped from next task. This will block\n+     * ledger replication {@link #Auditor} and {@link #getLedgerToRereplicate()}\n+     * tasks\n+     */\n+    void disableLedgerReplication()\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Resuming ledger replication. This will allow ledger replication\n+     * {@link #Auditor} and {@link #getLedgerToRereplicate()} tasks to continue\n+     */\n+    void enableLedgerReplication()\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Check whether the ledger replication is enabled or not. This will return\n+     * true if the ledger replication is enabled, otherwise return false\n+     * \n+     * @return - return true if it is enabled otherwise return false\n+     */\n+    boolean isLedgerReplicationEnabled()\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Receive notification asynchronously when the ledger replication process\n+     * is enabled\n+     * \n+     * @param cb\n+     *            - callback implementation to receive the notification\n+     */\n+    void notifyLedgerReplicationEnabled(GenericCallback<Void> cb)\n+            throws ReplicationException.UnavailableException;\n }"},{"sha":"724c653e92277e703a4db4f01db5c94fd37c7942","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":109,"deletions":21,"changes":130,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -18,7 +18,11 @@\n \n package org.apache.bookkeeper.meta;\n \n+import org.apache.bookkeeper.replication.ReplicationEnableCb;\n import org.apache.bookkeeper.replication.ReplicationException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;\n import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n@@ -65,6 +69,7 @@\n     static final Logger LOG = LoggerFactory.getLogger(ZkLedgerUnderreplicationManager.class);\n     static final Charset UTF8 = Charset.forName(\"UTF-8\");\n     public static final String UNDER_REPLICATION_NODE = \"underreplication\";\n+    static final String DISABLE_NODE = \"disable\";\n     static final String LAYOUT=\"BASIC\";\n     static final int LAYOUT_VERSION=1;\n \n@@ -104,22 +109,6 @@ public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc\n         checkLayout();\n     }\n \n-    private void createOptimistic(String path, byte[] data) throws KeeperException, InterruptedException {\n-        try {\n-            zkc.create(path, data,\n-                       Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        } catch (KeeperException.NoNodeException nne) {\n-            int lastSlash = path.lastIndexOf('/');\n-            if (lastSlash <= 0) {\n-                throw nne;\n-            }\n-            String parent = path.substring(0, lastSlash);\n-            createOptimistic(parent, new byte[0]);\n-            zkc.create(path, data,\n-                       Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        }        \n-    }\n-\n     private void checkLayout()\n             throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {\n         if (zkc.exists(basePath, false) == null) {\n@@ -212,8 +201,9 @@ public void markLedgerUnderreplicated(long ledgerId, String missingReplica)\n                 UnderreplicatedLedgerFormat.Builder builder = UnderreplicatedLedgerFormat.newBuilder();\n                 try {\n                     builder.addReplica(missingReplica);\n-                    createOptimistic(znode,\n-                                     TextFormat.printToString(builder.build()).getBytes(UTF8));\n+                    ZkUtils.createFullPathOptimistic(zkc, znode, TextFormat\n+                            .printToString(builder.build()).getBytes(UTF8),\n+                            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                 } catch (KeeperException.NodeExistsException nee) {\n                     Stat s = zkc.exists(znode, false);\n                     if (s == null) {\n@@ -331,6 +321,7 @@ public long getLedgerToRereplicate() throws ReplicationException.UnavailableExce\n         LOG.debug(\"getLedgerToRereplicate()\");\n         try {\n             while (true) {\n+                waitIfLedgerReplicationDisabled();\n                 final CountDownLatch changedLatch = new CountDownLatch(1);\n                 Watcher w = new Watcher() {\n                         public void process(WatchedEvent e) {\n@@ -352,10 +343,19 @@ public void process(WatchedEvent e) {\n             throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n         } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n-            throw new ReplicationException.UnavailableException(\"Interrupted while conecting zookeeper\", ie);\n+            throw new ReplicationException.UnavailableException(\"Interrupted while connecting zookeeper\", ie);\n         }\n     }\n \n+    private void waitIfLedgerReplicationDisabled() throws UnavailableException,\n+            InterruptedException {\n+        ReplicationEnableCb cb = new ReplicationEnableCb();\n+        if (!this.isLedgerReplicationEnabled()) {\n+            this.notifyLedgerReplicationEnabled(cb);\n+            cb.await();\n+        }\n+    }\n+    \n     @Override\n     public void releaseUnderreplicatedLedger(long ledgerId) throws ReplicationException.UnavailableException {\n         LOG.debug(\"releaseLedger(ledgerId={})\", ledgerId);\n@@ -371,7 +371,7 @@ public void releaseUnderreplicatedLedger(long ledgerId) throws ReplicationExcept\n             throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n         } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n-            throw new ReplicationException.UnavailableException(\"Interrupted while conecting zookeeper\", ie);\n+            throw new ReplicationException.UnavailableException(\"Interrupted while connecting zookeeper\", ie);\n         }\n     }\n \n@@ -389,7 +389,95 @@ public void close() throws ReplicationException.UnavailableException {\n             throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n         } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n-            throw new ReplicationException.UnavailableException(\"Interrupted while conecting zookeeper\", ie);\n+            throw new ReplicationException.UnavailableException(\"Interrupted while connecting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void disableLedgerReplication()\n+            throws ReplicationException.UnavailableException {\n+        LOG.debug(\"disableLedegerReplication()\");\n+        try {\n+            ZkUtils.createFullPathOptimistic(zkc, basePath + '/'\n+                    + ZkLedgerUnderreplicationManager.DISABLE_NODE, \"\"\n+                    .getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            LOG.info(\"Auto ledger re-replication is disabled!\");\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Exception while stopping replication\", ke);\n+            throw new ReplicationException.UnavailableException(\n+                    \"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\n+                    \"Interrupted while connecting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void enableLedgerReplication()\n+            throws ReplicationException.UnavailableException {\n+        LOG.debug(\"enableLedegerReplication()\");\n+        try {\n+            zkc.delete(basePath + '/'\n+                    + ZkLedgerUnderreplicationManager.DISABLE_NODE, -1);\n+            LOG.info(\"Resuming automatic ledger re-replication\");\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Exception while resuming ledger replication\", ke);\n+            throw new ReplicationException.UnavailableException(\n+                    \"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\n+                    \"Interrupted while connecting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isLedgerReplicationEnabled()\n+            throws ReplicationException.UnavailableException {\n+        LOG.debug(\"isLedgerReplicationEnabled()\");\n+        try {\n+            if (null != zkc.exists(basePath + '/' + DISABLE_NODE, false)) {\n+                return false;\n+            }\n+            return true;\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error while checking the state of \"\n+                    + \"ledger re-replication\", ke);\n+            throw new ReplicationException.UnavailableException(\n+                    \"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\n+                    \"Interrupted while contacting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void notifyLedgerReplicationEnabled(final GenericCallback<Void> cb)\n+            throws ReplicationException.UnavailableException {\n+        LOG.debug(\"notifyLedgerReplicationEnabled()\");\n+        Watcher w = new Watcher() {\n+            public void process(WatchedEvent e) {\n+                if (e.getType() == Watcher.Event.EventType.NodeDeleted) {\n+                    cb.operationComplete(0, null);\n+                }\n+            }\n+        };\n+        try {\n+            if (null == zkc.exists(basePath + '/' + DISABLE_NODE, w)) {\n+                cb.operationComplete(0, null);\n+                return;\n+            }\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error while checking the state of \"\n+                    + \"ledger re-replication\", ke);\n+            throw new ReplicationException.UnavailableException(\n+                    \"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\n+                    \"Interrupted while contacting zookeeper\", ie);\n         }\n     }\n }"},{"sha":"e1176d10c694948ce2b660aefc067734bd6b87aa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -106,6 +106,10 @@ public void run() {\n             while (true) {\n                 // wait for bookie join/failure notifications\n                 bookieNotifications.take();\n+\n+                // check whether ledger replication is enabled\n+                waitIfLedgerReplicationDisabled();\n+\n                 List<String> availableBookies = getAvailableBookies();\n \n                 // casting to String, as knownBookies and availableBookies\n@@ -132,11 +136,22 @@ public void run() {\n             LOG.error(\"Interrupted while watching available bookies \", ie);\n         } catch (BKAuditException bke) {\n             LOG.error(\"Exception while watching available bookies\", bke);\n+        } catch (UnavailableException ue) {\n+            LOG.error(\"Exception while watching available bookies\", ue);\n         }\n \n         shutdown();\n     }\n \n+    private void waitIfLedgerReplicationDisabled() throws UnavailableException,\n+            InterruptedException {\n+        ReplicationEnableCb cb = new ReplicationEnableCb();\n+        if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {\n+            ledgerUnderreplicationManager.notifyLedgerReplicationEnabled(cb);\n+            cb.await();\n+        }\n+    }\n+    \n     private List<String> getAvailableBookies() throws KeeperException,\n             InterruptedException {\n         return zkc.getChildren(conf.getZkAvailableBookiesPath(), this);"},{"sha":"77625c30c2b45e64e884e5cf7d6f4e816f7e60f3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -0,0 +1,56 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Callback which is getting notified when the replication process is enabled\n+ */\n+public class ReplicationEnableCb implements GenericCallback<Void> {\n+\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(ReplicationEnableCb.class);\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    @Override\n+    public void operationComplete(int rc, Void result) {\n+        latch.countDown();\n+        LOG.debug(\"Automatic ledger re-replication is enabled\");\n+    }\n+\n+    /**\n+     * This is a blocking call and causes the current thread to wait until the\n+     * replication process is enabled\n+     * \n+     * @throws InterruptedException\n+     *             interrupted while waiting\n+     */\n+    public void await() throws InterruptedException {\n+        LOG.debug(\"Automatic ledger re-replication is disabled. \"\n+                + \"Hence waiting until its enabled!\");\n+        latch.await();\n+    }\n+}"},{"sha":"2648ded883076dcfff40da26b1d99029ea06f6d8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","status":"modified","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -140,4 +140,38 @@ public void process(WatchedEvent event) {\n         }\n         return newZk;\n     }\n+\n+    /**\n+     * Utility to create the complete znode path synchronously\n+     * \n+     * @param zkc\n+     *            - ZK instance\n+     * @param path\n+     *            - znode path\n+     * @param data\n+     *            - znode data\n+     * @param acl\n+     *            - Acl of the zk path\n+     * @param createMode\n+     *            - Create mode of zk path\n+     * @throws KeeperException\n+     *             if the server returns a non-zero error code, or invalid ACL\n+     * @throws InterruptedException\n+     *             if the transaction is interrupted\n+     */\n+    public static void createFullPathOptimistic(ZooKeeper zkc, String path,\n+            byte[] data, final List<ACL> acl, final CreateMode createMode)\n+            throws KeeperException, InterruptedException {\n+        try {\n+            zkc.create(path, data, acl, createMode);\n+        } catch (KeeperException.NoNodeException nne) {\n+            int lastSlash = path.lastIndexOf('/');\n+            if (lastSlash <= 0) {\n+                throw nne;\n+            }\n+            String parent = path.substring(0, lastSlash);\n+            createFullPathOptimistic(zkc, parent, new byte[0], acl, createMode);\n+            zkc.create(path, data, acl, createMode);\n+        }\n+    }\n }"},{"sha":"1965de839fbb6ab3d8d9da80deda4aef5153bde8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -256,6 +256,31 @@ public void testMultipleBookieFailures() throws Exception {\n         }\n     }\n \n+    @Test//(timeout = 30000)\n+    public void testToggleLedgerReplication() throws Exception {\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        ledgerList.add(lh1.getId());\n+        LOG.debug(\"Created following ledgers : \" + ledgerList);\n+\n+        // failing another bookie\n+        CountDownLatch urReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        // disabling ledger replication\n+        urLedgerMgr.disableLedgerReplication();\n+        ArrayList<String> shutdownBookieList = new ArrayList<String>();\n+        shutdownBookieList.add(shutdownBookie(bs.size() - 1));\n+        shutdownBookieList.add(shutdownBookie(bs.size() - 1));\n+\n+        assertFalse(\"Ledger replication is not disabled!\", urReplicaLatch\n+                .await(5, TimeUnit.SECONDS));\n+\n+        // enabling ledger replication\n+        urLedgerMgr.enableLedgerReplication();\n+        assertTrue(\"Ledger replication is not disabled!\", urReplicaLatch.await(\n+                5, TimeUnit.SECONDS));\n+    }\n+\n     private CountDownLatch registerUrLedgerWatcher(int count)\n             throws KeeperException, InterruptedException {\n         final CountDownLatch underReplicaLatch = new CountDownLatch(count);"},{"sha":"ea66a88fb87eb55b5bedeeb6b20ce81c3faa734a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","status":"modified","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/apache/bookkeeper/blob/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java?ref=24fb0bca0dbdd2ad14c5afcd7fb2fc31f80882f5","patch":"@@ -49,8 +49,12 @@\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.test.ZooKeeperUtil;\n import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.commons.lang.StringUtils;\n import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -76,6 +80,7 @@\n \n     String basePath;\n     String urLedgerPath;\n+    boolean isLedgerReplicationDisabled = true;\n \n     @Before\n     public void setupZooKeeper() throws Exception {\n@@ -466,6 +471,119 @@ public void testManyFailuresInAnEnsemble() throws Exception {\n         verifyMarkLedgerUnderreplicated(missingReplica);\n     }\n \n+    /**\n+     * Test disabling the ledger re-replication. After disabling, it will not be\n+     * able to getLedgerToRereplicate(). This calls will enter into infinite\n+     * waiting until enabling rereplication process\n+     */\n+    @Test(timeout = 20000)\n+    public void testDisableLedegerReplication() throws Exception {\n+        final LedgerUnderreplicationManager replicaMgr = lmf1\n+                .newLedgerUnderreplicationManager();\n+\n+        // simulate few urLedgers before disabling\n+        final Long ledgerA = 0xfeadeefdacL;\n+        final String missingReplica = \"localhost:3181\";\n+\n+        // disabling replication\n+        replicaMgr.disableLedgerReplication();\n+        LOG.info(\"Disabled Ledeger Replication\");\n+\n+        try {\n+            replicaMgr.markLedgerUnderreplicated(ledgerA, missingReplica);\n+        } catch (UnavailableException e) {\n+            LOG.debug(\"Unexpected exception while marking urLedger\", e);\n+            fail(\"Unexpected exception while marking urLedger\" + e.getMessage());\n+        }\n+\n+        Future<Long> fA = getLedgerToReplicate(replicaMgr);\n+        try {\n+            fA.get(5, TimeUnit.SECONDS);\n+            fail(\"Shouldn't be able to find a ledger to replicate\");\n+        } catch (TimeoutException te) {\n+            // expected behaviour, as the replication is disabled\n+            isLedgerReplicationDisabled = false;\n+        }\n+\n+        assertTrue(\"Ledger replication is not disabled!\",\n+                !isLedgerReplicationDisabled);\n+    }\n+\n+    /**\n+     * Test enabling the ledger re-replication. After enableLedegerReplication,\n+     * should continue getLedgerToRereplicate() task\n+     */\n+    @Test(timeout = 20000)\n+    public void testEnableLedegerReplication() throws Exception {\n+        isLedgerReplicationDisabled = true;\n+        final LedgerUnderreplicationManager replicaMgr = lmf1\n+                .newLedgerUnderreplicationManager();\n+\n+        // simulate few urLedgers before disabling\n+        final Long ledgerA = 0xfeadeefdacL;\n+        final String missingReplica = \"localhost:3181\";\n+        try {\n+            replicaMgr.markLedgerUnderreplicated(ledgerA, missingReplica);\n+        } catch (UnavailableException e) {\n+            LOG.debug(\"Unexpected exception while marking urLedger\", e);\n+            fail(\"Unexpected exception while marking urLedger\" + e.getMessage());\n+        }\n+\n+        // disabling replication\n+        replicaMgr.disableLedgerReplication();\n+        LOG.debug(\"Disabled Ledeger Replication\");\n+\n+        String znodeA = getUrLedgerZnode(ledgerA);\n+        final CountDownLatch znodeLatch = new CountDownLatch(2);\n+        String urledgerA = StringUtils.substringAfterLast(znodeA, \"/\");\n+        String urLockLedgerA = basePath + \"/locks/\" + urledgerA;\n+        zkc1.exists(urLockLedgerA, new Watcher(){\n+            @Override\n+            public void process(WatchedEvent event) {\n+                if (event.getType() == EventType.NodeCreated) {\n+                    znodeLatch.countDown();\n+                    LOG.debug(\"Recieved node creation event for the zNodePath:\"\n+                            + event.getPath());\n+                }\n+                \n+            }});\n+        // getLedgerToRereplicate is waiting until enable rereplication\n+        Thread thread1 = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    Long lA = replicaMgr.getLedgerToRereplicate();\n+                    assertEquals(\"Should be the ledger I just marked\", lA,\n+                            ledgerA);\n+                    isLedgerReplicationDisabled = false;\n+                    znodeLatch.countDown();\n+                } catch (UnavailableException e) {\n+                    LOG.debug(\"Unexpected exception while marking urLedger\", e);\n+                    isLedgerReplicationDisabled = false;\n+                }\n+            }\n+        };\n+        thread1.start();\n+\n+        try {\n+            znodeLatch.await(5, TimeUnit.SECONDS);\n+            assertTrue(\"Ledger replication is not disabled!\",\n+                    isLedgerReplicationDisabled);\n+            assertEquals(\"Failed to disable ledger replication!\", 2, znodeLatch\n+                    .getCount());\n+\n+            replicaMgr.enableLedgerReplication();\n+            znodeLatch.await(5, TimeUnit.SECONDS);\n+            LOG.debug(\"Enabled Ledeger Replication\");\n+            assertTrue(\"Ledger replication is not disabled!\",\n+                    !isLedgerReplicationDisabled);\n+            assertEquals(\"Failed to disable ledger replication!\", 0, znodeLatch\n+                    .getCount());\n+        } finally {\n+            thread1.interrupt();\n+        }\n+    }\n+\n     private void verifyMarkLedgerUnderreplicated(Collection<String> missingReplica)\n             throws KeeperException, InterruptedException,\n             CompatibilityException, UnavailableException {"}]}

