{"sha":"26731c770bf8e3cb54ec0466c027b6e313983bba","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyNjczMWM3NzBiZjhlM2NiNTRlYzA0NjZjMDI3YjZlMzEzOTgzYmJh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-02-12T10:16:44Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-02-12T10:16:44Z"},"message":"BOOKKEEPER-555: Make BookieServer use Netty rather than a custom IO server (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1445085 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2d067c3782fe429defb831b3060d86104e081bdd","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/2d067c3782fe429defb831b3060d86104e081bdd"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/26731c770bf8e3cb54ec0466c027b6e313983bba","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/26731c770bf8e3cb54ec0466c027b6e313983bba","html_url":"https://github.com/apache/bookkeeper/commit/26731c770bf8e3cb54ec0466c027b6e313983bba","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/26731c770bf8e3cb54ec0466c027b6e313983bba/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3bcabc5adb48e75dd041384ebcbb0017d56c3299","url":"https://api.github.com/repos/apache/bookkeeper/commits/3bcabc5adb48e75dd041384ebcbb0017d56c3299","html_url":"https://github.com/apache/bookkeeper/commit/3bcabc5adb48e75dd041384ebcbb0017d56c3299"}],"stats":{"total":1743,"additions":828,"deletions":915},"files":[{"sha":"180dddcf9a992acaa981f220980a7a47d4304e3f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -16,6 +16,8 @@ Trunk (unreleased changes)\n \n     IMPROVEMENTS:\n \n+      BOOKKEEPER-555: Make BookieServer use Netty rather than a custom IO server (ivank)\n+\n       BOOKKEEPER-526: multiple threads for delivery manager (sijie via ivank)\n \n       BOOKKEEPER-544: Modify hedwig server tests to allow client testcases to start/stop them as part of their tests (mridul via ivank)"},{"sha":"3638430fb990938555fa38ccaa42c5a728937065","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"added","additions":189,"deletions":0,"changes":189,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -0,0 +1,189 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.zookeeper.KeeperException;\n+\n+import org.jboss.netty.bootstrap.ServerBootstrap;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.channel.ChannelPipelineFactory;\n+import org.jboss.netty.channel.Channels;\n+import org.jboss.netty.channel.group.ChannelGroup;\n+import org.jboss.netty.channel.group.ChannelGroupFuture;\n+import org.jboss.netty.channel.group.DefaultChannelGroup;\n+import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;\n+import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n+import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Netty server for serving bookie requests\n+ */\n+class BookieNettyServer {\n+    static Logger LOG = LoggerFactory.getLogger(BookieNettyServer.class);\n+\n+    final static int maxMessageSize = 0xfffff;\n+    final ServerConfiguration conf;\n+    final ChannelFactory serverChannelFactory;\n+    final Bookie bookie;\n+    final ChannelGroup allChannels = new CleanupChannelGroup();\n+    final AtomicBoolean isRunning = new AtomicBoolean(false);\n+    Object suspensionLock = new Object();\n+    boolean suspended = false;\n+\n+    InetSocketAddress localAddress = null;\n+\n+    BookieNettyServer(ServerConfiguration conf, Bookie bookie)\n+            throws IOException, KeeperException, InterruptedException, BookieException  {\n+        this.conf = conf;\n+        this.bookie = bookie;\n+\n+        ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n+        String base = \"bookie-\" + conf.getBookiePort() + \"-netty\";\n+        serverChannelFactory = new NioServerSocketChannelFactory(\n+                Executors.newCachedThreadPool(tfb.setNameFormat(base + \"-boss-%d\").build()),\n+                Executors.newCachedThreadPool(tfb.setNameFormat(base + \"-worker-%d\").build()));\n+\n+    }\n+\n+    boolean isRunning() {\n+        return isRunning.get();\n+    }\n+\n+    @VisibleForTesting\n+    void suspendProcessing() {\n+        synchronized (suspensionLock) {\n+            suspended = true;\n+            allChannels.setReadable(false).awaitUninterruptibly();\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    void resumeProcessing() {\n+        synchronized (suspensionLock) {\n+            suspended = false;\n+            allChannels.setReadable(true).awaitUninterruptibly();\n+            suspensionLock.notifyAll();\n+        }\n+    }\n+\n+    InetSocketAddress getLocalAddress() {\n+        if (localAddress != null) {\n+            return localAddress;\n+        } else {\n+            return new InetSocketAddress(conf.getBookiePort());\n+        }\n+    }\n+\n+    void start() {\n+        ServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n+        bootstrap.setPipelineFactory(new BookiePipelineFactory());\n+        bootstrap.setOption(\"child.tcpNoDelay\", conf.getServerTcpNoDelay());\n+        bootstrap.setOption(\"child.soLinger\", 2);\n+\n+        Channel listen = bootstrap.bind(new InetSocketAddress(conf.getBookiePort()));\n+\n+        assert(listen.getLocalAddress() instanceof InetSocketAddress);\n+        localAddress = (InetSocketAddress)listen.getLocalAddress();\n+        allChannels.add(listen);\n+        isRunning.set(true);\n+    }\n+\n+    void shutdown() {\n+        isRunning.set(false);\n+        allChannels.close().awaitUninterruptibly();\n+        serverChannelFactory.releaseExternalResources();\n+    }\n+\n+    private class BookiePipelineFactory implements ChannelPipelineFactory {\n+        public ChannelPipeline getPipeline() throws Exception {\n+            synchronized (suspensionLock) {\n+                while (suspended) {\n+                    suspensionLock.wait();\n+                }\n+            }\n+            ChannelPipeline pipeline = Channels.pipeline();\n+            pipeline.addLast(\"lengthbaseddecoder\",\n+                             new LengthFieldBasedFrameDecoder(maxMessageSize, 0, 4, 0, 4));\n+            pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+\n+            pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.Decoder());\n+            pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.Encoder());\n+            pipeline.addLast(\"bookieRequestHandler\", new BookieRequestHandler(conf, bookie,\n+                                                                              allChannels));\n+            return pipeline;\n+        }\n+    }\n+\n+    private static class CleanupChannelGroup extends DefaultChannelGroup {\n+        private AtomicBoolean closed = new AtomicBoolean(false);\n+\n+        CleanupChannelGroup() {\n+            super(\"BookieChannelGroup\");\n+        }\n+\n+        @Override\n+        public boolean add(Channel channel) {\n+            boolean ret = super.add(channel);\n+            if (closed.get()) {\n+                channel.close();\n+            }\n+            return ret;\n+        }\n+\n+        @Override\n+        public ChannelGroupFuture close() {\n+            closed.set(true);\n+            return super.close();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof CleanupChannelGroup)) {\n+                return false;\n+            }\n+            CleanupChannelGroup other = (CleanupChannelGroup)o;\n+            return other.closed.get() == closed.get()\n+                && super.equals(other);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode() * 17 + (closed.get() ? 1 : 0);\n+        }\n+    }\n+}"},{"sha":"2cc9b8f0bfa47ccb143f72a9d7487244ba9ab7ff","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -0,0 +1,118 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+\n+import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n+import org.jboss.netty.handler.codec.oneone.OneToOneEncoder;\n+import org.jboss.netty.handler.codec.oneone.OneToOneDecoder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BookieProtoEncoding {\n+    static Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n+\n+    public static class Decoder extends OneToOneDecoder {\n+        @Override\n+        public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (!(msg instanceof ChannelBuffer)) {\n+                return msg;\n+            }\n+            ChannelBuffer packet = (ChannelBuffer)msg;\n+\n+            PacketHeader h = PacketHeader.fromInt(packet.readInt());\n+\n+            // packet format is different between ADDENTRY and READENTRY\n+            long ledgerId = -1;\n+            long entryId = BookieProtocol.INVALID_ENTRY_ID;\n+            byte[] masterKey = null;\n+            short flags = h.getFlags();\n+\n+            ServerStats.getInstance().incrementPacketsReceived();\n+\n+            switch (h.getOpCode()) {\n+            case BookieProtocol.ADDENTRY:\n+                // first read master key\n+                masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n+                packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n+\n+                ChannelBuffer bb = packet.duplicate();\n+                ledgerId = bb.readLong();\n+                entryId = bb.readLong();\n+\n+                return new BookieProtocol.AddRequest(h.getVersion(), ledgerId, entryId,\n+                        flags, masterKey, packet.toByteBuffer().slice());\n+            case BookieProtocol.READENTRY:\n+                ledgerId = packet.readLong();\n+                entryId = packet.readLong();\n+\n+                if ((flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING\n+                    && h.getVersion() >= 2) {\n+                    masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n+                    packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n+                    return new BookieProtocol.ReadRequest(h.getVersion(), ledgerId, entryId, flags, masterKey);\n+                } else {\n+                    return new BookieProtocol.ReadRequest(h.getVersion(), ledgerId, entryId, flags);\n+                }\n+            }\n+            return msg;\n+        }\n+    }\n+\n+    public static class Encoder extends OneToOneEncoder {\n+        @Override\n+        public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (!(msg instanceof BookieProtocol.Response)) {\n+                return msg;\n+            }\n+            BookieProtocol.Response r = (BookieProtocol.Response)msg;\n+            ChannelBuffer buf = ctx.getChannel().getConfig().getBufferFactory()\n+                .getBuffer(24);\n+            buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n+                                          r.getOpCode(), (short)0).toInt());\n+            buf.writeInt(r.getErrorCode());\n+            buf.writeLong(r.getLedgerId());\n+            buf.writeLong(r.getEntryId());\n+\n+            ServerStats.getInstance().incrementPacketsSent();\n+\n+            if (msg instanceof BookieProtocol.ReadResponse) {\n+                BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse)r;\n+                return ChannelBuffers.wrappedBuffer(buf,\n+                        ChannelBuffers.wrappedBuffer(rr.getData()));\n+            } else if ((msg instanceof BookieProtocol.AddResponse)\n+                       || (msg instanceof BookieProtocol.ErrorResponse)) {\n+                return buf;\n+            } else {\n+                LOG.error(\"Cannot encode unknown response type {}\", msg.getClass().getName());\n+                return msg;\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"61bb80264090bb2c261a43f1ce2d8e40b73dac53","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -21,6 +21,8 @@\n  *\n  */\n \n+import java.nio.ByteBuffer;\n+\n /**\n  * The packets of the Bookie protocol all have a 4-byte integer indicating the\n  * type of request or response at the very beginning of the packet followed by a\n@@ -173,4 +175,160 @@ short getFlags() {\n     public static final short FLAG_NONE = 0x0;\n     public static final short FLAG_DO_FENCING = 0x0001;\n     public static final short FLAG_RECOVERY_ADD = 0x0002;\n+\n+    static class Request {\n+\n+        final byte protocolVersion;\n+        final byte opCode;\n+        final long ledgerId;\n+        final long entryId;\n+        final short flags;\n+        final byte[] masterKey;\n+\n+        protected Request(byte protocolVersion, byte opCode, long ledgerId,\n+                          long entryId, short flags) {\n+            this(protocolVersion, opCode, ledgerId, entryId, flags, null);\n+        }\n+\n+        protected Request(byte protocolVersion, byte opCode, long ledgerId,\n+                          long entryId, short flags, byte[] masterKey) {\n+            this.protocolVersion = protocolVersion;\n+            this.opCode = opCode;\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+            this.flags = flags;\n+            this.masterKey = masterKey;\n+        }\n+\n+        byte getProtocolVersion() {\n+            return protocolVersion;\n+        }\n+\n+        byte getOpCode() {\n+            return opCode;\n+        }\n+\n+        long getLedgerId() {\n+            return ledgerId;\n+        }\n+\n+        long getEntryId() {\n+            return entryId;\n+        }\n+\n+        boolean hasMasterKey() {\n+            return masterKey != null;\n+        }\n+\n+        byte[] getMasterKey() {\n+            assert hasMasterKey();\n+            return masterKey;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Op(%d)[Ledger:%d,Entry:%d]\", opCode, ledgerId, entryId);\n+        }\n+    }\n+\n+    static class AddRequest extends Request {\n+        final ByteBuffer data;\n+\n+        AddRequest(byte protocolVersion, long ledgerId, long entryId,\n+                   short flags, byte[] masterKey, ByteBuffer data) {\n+            super(protocolVersion, ADDENTRY, ledgerId, entryId, flags, masterKey);\n+            this.data = data;\n+        }\n+\n+        ByteBuffer getData() {\n+            return data;\n+        }\n+\n+        boolean isRecoveryAdd() {\n+            return (flags & FLAG_RECOVERY_ADD) == FLAG_RECOVERY_ADD;\n+        }\n+    }\n+\n+    static class ReadRequest extends Request {\n+        ReadRequest(byte protocolVersion, long ledgerId, long entryId, short flags) {\n+            super(protocolVersion, READENTRY, ledgerId, entryId, flags);\n+        }\n+\n+        ReadRequest(byte protocolVersion, long ledgerId, long entryId,\n+                    short flags, byte[] masterKey) {\n+            super(protocolVersion, READENTRY, ledgerId, entryId, flags, masterKey);\n+        }\n+\n+        boolean isFencingRequest() {\n+            return (flags & FLAG_DO_FENCING) == FLAG_DO_FENCING;\n+        }\n+    }\n+\n+    static class Response {\n+        final byte protocolVersion;\n+        final byte opCode;\n+        final int errorCode;\n+        final long ledgerId;\n+        final long entryId;\n+\n+        protected Response(byte protocolVersion, byte opCode,\n+                           int errorCode, long ledgerId, long entryId) {\n+            this.protocolVersion = protocolVersion;\n+            this.opCode = opCode;\n+            this.errorCode = errorCode;\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+        }\n+\n+        byte getProtocolVersion() {\n+            return protocolVersion;\n+        }\n+\n+        byte getOpCode() {\n+            return opCode;\n+        }\n+\n+        long getLedgerId() {\n+            return ledgerId;\n+        }\n+\n+        long getEntryId() {\n+            return entryId;\n+        }\n+\n+        int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Op(%d)[Ledger:%d,Entry:%d]\", opCode, ledgerId, entryId);\n+        }\n+    }\n+\n+    static class ReadResponse extends Response {\n+        final ByteBuffer data;\n+\n+        ReadResponse(byte protocolVersion, long ledgerId, long entryId, ByteBuffer data) {\n+            super(protocolVersion, READENTRY, EOK, ledgerId, entryId);\n+            this.data = data;\n+        }\n+\n+        ByteBuffer getData() {\n+            return data;\n+        }\n+    }\n+\n+    static class AddResponse extends Response {\n+        AddResponse(byte protocolVersion, long ledgerId, long entryId) {\n+            super(protocolVersion, ADDENTRY, EOK, ledgerId, entryId);\n+        }\n+    }\n+\n+    static class ErrorResponse extends Response {\n+        ErrorResponse(byte protocolVersion, byte opCode, int errorCode,\n+                      long ledgerId, long entryId) {\n+            super(protocolVersion, opCode, errorCode, ledgerId, entryId);\n+        }\n+    }\n }"},{"sha":"04ed8736ebd3942d75dfd87ad016f74b2a1eda13","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"added","additions":303,"deletions":0,"changes":303,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -0,0 +1,303 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.ExceptionEvent;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.channel.group.ChannelGroup;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Serverside handler for bookkeeper requests\n+ */\n+class BookieRequestHandler extends SimpleChannelHandler\n+    implements BookkeeperInternalCallbacks.WriteCallback {\n+\n+    static Logger LOG = LoggerFactory.getLogger(BookieRequestHandler.class);\n+    private final Bookie bookie;\n+    private final ChannelGroup allChannels;\n+\n+    private final BKStats bkStats = BKStats.getInstance();\n+    private final boolean statsEnabled;\n+\n+    BookieRequestHandler(ServerConfiguration conf, Bookie bookie, ChannelGroup allChannels) {\n+        this.bookie = bookie;\n+        this.allChannels = allChannels;\n+        this.statsEnabled = conf.isStatisticsEnabled();\n+    }\n+\n+    @Override\n+    public void channelOpen(ChannelHandlerContext ctx,\n+                            ChannelStateEvent e)\n+            throws Exception {\n+        allChannels.add(ctx.getChannel());\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n+        Throwable throwable = e.getCause();\n+        LOG.error(\"Unhandled exception occurred in I/O thread or handler\", throwable);\n+    }\n+\n+    @Override\n+    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n+            throws Exception {\n+        LOG.debug(\"Channel connected {}\", e);\n+    }\n+\n+    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n+            throws Exception {\n+        LOG.debug(\"Channel disconnected {}\", e);\n+    }\n+\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+        if (!(e.getMessage() instanceof BookieProtocol.Request)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n+        BookieProtocol.Request r = (BookieProtocol.Request)e.getMessage();\n+\n+        Channel c = ctx.getChannel();\n+\n+        if (r.getProtocolVersion() < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n+            || r.getProtocolVersion() > BookieProtocol.CURRENT_PROTOCOL_VERSION) {\n+            LOG.error(\"Invalid protocol version, expected something between \"\n+                      + BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n+                      + \" & \" + BookieProtocol.CURRENT_PROTOCOL_VERSION\n+                      + \". got \" + r.getProtocolVersion());\n+            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, r));\n+            return;\n+        }\n+\n+        switch (r.getOpCode()) {\n+        case BookieProtocol.ADDENTRY:\n+            handleAdd(r, c);\n+            break;\n+        case BookieProtocol.READENTRY:\n+            handleRead(r, c);\n+            break;\n+        default:\n+            LOG.error(\"Unknown op type {}, sending error\", r.getOpCode());\n+            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n+            }\n+            break;\n+        }\n+    }\n+\n+    class AddCtx {\n+        final Channel c;\n+        final BookieProtocol.AddRequest r;\n+        final long startTime;\n+\n+        AddCtx(Channel c, BookieProtocol.AddRequest r) {\n+            this.c = c;\n+            this.r = r;\n+\n+            if (statsEnabled) {\n+                startTime = MathUtils.now();\n+            } else {\n+                startTime = 0;\n+            }\n+        }\n+    }\n+\n+    private void handleAdd(BookieProtocol.Request r, Channel c) {\n+        assert (r instanceof BookieProtocol.AddRequest);\n+        BookieProtocol.AddRequest add = (BookieProtocol.AddRequest)r;\n+\n+        if (bookie.isReadOnly()) {\n+            LOG.warn(\"BookieServer is running as readonly mode,\"\n+                     + \" so rejecting the request from the client!\");\n+            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            }\n+            return;\n+        }\n+\n+        int rc = BookieProtocol.EOK;\n+        try {\n+            if (add.isRecoveryAdd()) {\n+                bookie.recoveryAddEntry(add.getData(), this, new AddCtx(c, add),\n+                                        add.getMasterKey());\n+            } else {\n+                bookie.addEntry(add.getData(), this, new AddCtx(c, add), add.getMasterKey());\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Error writing \" + add, e);\n+            rc = BookieProtocol.EIO;\n+        } catch (BookieException.LedgerFencedException lfe) {\n+            LOG.error(\"Attempt to write to fenced ledger\", lfe);\n+            rc = BookieProtocol.EFENCED;\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger \" + add.getLedgerId(), e);\n+            rc = BookieProtocol.EUA;\n+        }\n+        if (rc != BookieProtocol.EOK) {\n+            c.write(ResponseBuilder.buildErrorResponse(rc, add));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void writeComplete(int rc, long ledgerId, long entryId,\n+                              InetSocketAddress addr, Object ctx) {\n+        assert(ctx instanceof AddCtx);\n+        AddCtx addctx = (AddCtx)ctx;\n+        addctx.c.write(ResponseBuilder.buildAddResponse(addctx.r));\n+\n+        if (statsEnabled) {\n+            // compute the latency\n+            if (0 == rc) {\n+                // for add operations, we compute latency in writeComplete callbacks.\n+                long elapsedTime = MathUtils.now() - addctx.startTime;\n+                bkStats.getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n+            } else {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            }\n+        }\n+    }\n+\n+    private void handleRead(BookieProtocol.Request r, Channel c) {\n+        assert (r instanceof BookieProtocol.ReadRequest);\n+        BookieProtocol.ReadRequest read = (BookieProtocol.ReadRequest)r;\n+\n+        LOG.debug(\"Received new read request: {}\", r);\n+        int errorCode = BookieProtocol.EIO;\n+        long startTime = 0;\n+        if (statsEnabled) {\n+            startTime = MathUtils.now();\n+        }\n+        ByteBuffer data = null;\n+        try {\n+            Future<Boolean> fenceResult = null;\n+            if (read.isFencingRequest()) {\n+                LOG.warn(\"Ledger \" + r.getLedgerId() + \" fenced by \" + c.getRemoteAddress());\n+\n+                if (read.hasMasterKey()) {\n+                    fenceResult = bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n+                } else {\n+                    LOG.error(\"Password not provided, Not safe to fence {}\", read.getLedgerId());\n+                    if (statsEnabled) {\n+                        bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+                    }\n+                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+                }\n+            }\n+            data = bookie.readEntry(r.getLedgerId(), r.getEntryId());\n+            LOG.debug(\"##### Read entry ##### {}\", data.remaining());\n+            if (null != fenceResult) {\n+                // TODO:\n+                // currently we don't have readCallback to run in separated read\n+                // threads. after BOOKKEEPER-429 is complete, we could improve\n+                // following code to make it not wait here\n+                //\n+                // For now, since we only try to wait after read entry. so writing\n+                // to journal and read entry are executed in different thread\n+                // it would be fine.\n+                try {\n+                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n+                    if (null == fenced || !fenced) {\n+                        // if failed to fence, fail the read request to make it retry.\n+                        errorCode = BookieProtocol.EIO;\n+                        data = null;\n+                    } else {\n+                        errorCode = BookieProtocol.EOK;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupting fence read entry \" + read, ie);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                } catch (ExecutionException ee) {\n+                    LOG.error(\"Failed to fence read entry \" + read, ee);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                } catch (TimeoutException te) {\n+                    LOG.error(\"Timeout to fence read entry \" + read, te);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                }\n+            } else {\n+                errorCode = BookieProtocol.EOK;\n+            }\n+        } catch (Bookie.NoLedgerException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.ENOLEDGER;\n+        } catch (Bookie.NoEntryException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.ENOENTRY;\n+        } catch (IOException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.EIO;\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger \" + read.getLedgerId(), e);\n+            errorCode = BookieProtocol.EUA;\n+        }\n+\n+        LOG.trace(\"Read entry rc = {} for {}\",\n+                  new Object[] { errorCode, read});\n+        if (errorCode == BookieProtocol.EOK) {\n+            assert data != null;\n+\n+            c.write(ResponseBuilder.buildReadResponse(data, read));\n+            if (statsEnabled) {\n+                long elapsedTime = MathUtils.now() - startTime;\n+                bkStats.getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n+            }\n+        } else {\n+            c.write(ResponseBuilder.buildErrorResponse(errorCode, read));\n+           if (statsEnabled) {\n+               bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+           }\n+        }\n+    }\n+}"},{"sha":"f2e15515c9424015c92e870d01304901af359de8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":10,"deletions":283,"changes":293,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -25,11 +25,6 @@\n import java.net.InetSocketAddress;\n import java.net.MalformedURLException;\n import java.net.UnknownHostException;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n \n import org.apache.zookeeper.KeeperException;\n \n@@ -38,22 +33,18 @@\n import org.apache.bookkeeper.bookie.ExitCode;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n-import org.apache.bookkeeper.proto.NIOServerFactory.Cnxn;\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n-import org.apache.bookkeeper.util.MathUtils;\n \n import com.google.common.annotations.VisibleForTesting;\n \n-import static org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.cli.BasicParser;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.codec.binary.Hex;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -62,9 +53,9 @@\n  * Implements the server-side part of the BookKeeper protocol.\n  *\n  */\n-public class BookieServer implements NIOServerFactory.PacketProcessor, BookkeeperInternalCallbacks.WriteCallback {\n+public class BookieServer {\n     final ServerConfiguration conf;\n-    NIOServerFactory nioServerFactory;\n+    BookieNettyServer nettyServer;\n     private volatile boolean running = false;\n     Bookie bookie;\n     DeathWatcher deathWatcher;\n@@ -73,8 +64,6 @@\n     int exitCode = ExitCode.OK;\n \n     // operation stats\n-    final BKStats bkStats = BKStats.getInstance();\n-    final boolean isStatsEnabled;\n     protected BookieServerBean jmxBkServerBean;\n     private AutoRecoveryMain autoRecoveryMain = null;\n     private boolean isAutoRecoveryDaemonEnabled;\n@@ -84,11 +73,11 @@ public BookieServer(ServerConfiguration conf) throws IOException,\n             UnavailableException, CompatibilityException {\n         this.conf = conf;\n         this.bookie = newBookie(conf);\n+        this.nettyServer = new BookieNettyServer(this.conf, this.bookie);\n         isAutoRecoveryDaemonEnabled = conf.isAutoRecoveryDaemonEnabled();\n         if (isAutoRecoveryDaemonEnabled) {\n             this.autoRecoveryMain = new AutoRecoveryMain(conf);\n         }\n-        isStatsEnabled = conf.isStatisticsEnabled();\n     }\n \n     protected Bookie newBookie(ServerConfiguration conf)\n@@ -97,14 +86,12 @@ protected Bookie newBookie(ServerConfiguration conf)\n     }\n \n     public void start() throws IOException, UnavailableException {\n-        nioServerFactory = new NIOServerFactory(conf, this);\n-\n         this.bookie.start();\n         if (isAutoRecoveryDaemonEnabled && this.autoRecoveryMain != null) {\n             this.autoRecoveryMain.start();\n         }\n+        this.nettyServer.start();\n \n-        nioServerFactory.start();\n         running = true;\n         deathWatcher = new DeathWatcher(conf);\n         deathWatcher.start();\n@@ -117,7 +104,7 @@ public InetSocketAddress getLocalAddress() {\n         try {\n             return Bookie.getBookieAddress(conf);\n         } catch (UnknownHostException uhe) {\n-            return nioServerFactory.getLocalAddress();\n+            return nettyServer.getLocalAddress();\n         }\n     }\n \n@@ -131,22 +118,22 @@ public Bookie getBookie() {\n      */\n     @VisibleForTesting\n     public void suspendProcessing() {\n-        nioServerFactory.suspendProcessing();\n+        nettyServer.suspendProcessing();\n     }\n \n     /**\n      * Resume processing requests in the bookie (for testing)\n      */\n     @VisibleForTesting\n     public void resumeProcessing() {\n-        nioServerFactory.resumeProcessing();\n+        nettyServer.resumeProcessing();\n     }\n \n     public synchronized void shutdown() {\n         if (!running) {\n             return;\n         }\n-        nioServerFactory.shutdown();\n+        this.nettyServer.shutdown();\n         exitCode = bookie.shutdown();\n         if (isAutoRecoveryDaemonEnabled && this.autoRecoveryMain != null) {\n             this.autoRecoveryMain.shutdown();\n@@ -182,7 +169,7 @@ protected void unregisterJMX() {\n     }\n \n     public boolean isRunning() {\n-        return bookie.isRunning() && nioServerFactory.isRunning() && running;\n+        return bookie.isRunning() && nettyServer.isRunning() && running;\n     }\n \n     /**\n@@ -204,17 +191,8 @@ public boolean isAutoRecoveryRunning() {\n                 && this.autoRecoveryMain.isAutoRecoveryRunning();\n     }\n \n-    /**\n-     * Whether nio server is running?\n-     *\n-     * @return true if nio server is running, otherwise return false\n-     */\n-    public boolean isNioServerRunning() {\n-        return nioServerFactory.isRunning();\n-    }\n-\n     public void join() throws InterruptedException {\n-        nioServerFactory.join();\n+        bookie.join();\n     }\n \n     public int getExitCode() {\n@@ -242,7 +220,6 @@ public void run() {\n                     // do nothing\n                 }\n                 if (!isBookieRunning()\n-                        || !isNioServerRunning()\n                         || (isAutoRecoveryDaemonEnabled && !isAutoRecoveryRunning())) {\n                     shutdown();\n                     break;\n@@ -376,254 +353,4 @@ public void run() {\n             System.exit(ExitCode.SERVER_EXCEPTION);\n         }\n     }\n-\n-    public void processPacket(ByteBuffer packet, Cnxn src) {\n-        PacketHeader h = PacketHeader.fromInt(packet.getInt());\n-\n-        boolean success = false;\n-        int statType = BKStats.STATS_UNKNOWN;\n-        long startTime = 0;\n-        if (isStatsEnabled) {\n-            startTime = MathUtils.now();\n-        }\n-\n-        // packet format is different between ADDENTRY and READENTRY\n-        long ledgerId = -1;\n-        long entryId = BookieProtocol.INVALID_ENTRY_ID;\n-        byte[] masterKey = null;\n-        switch (h.getOpCode()) {\n-        case BookieProtocol.ADDENTRY:\n-            // first read master key\n-            masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n-            packet.get(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n-            ByteBuffer bb = packet.duplicate();\n-            ledgerId = bb.getLong();\n-            entryId = bb.getLong();\n-            break;\n-        case BookieProtocol.READENTRY:\n-            ledgerId = packet.getLong();\n-            entryId = packet.getLong();\n-            break;\n-        default:\n-            LOG.warn(\"Received bad request (opcode:{})\", h.getOpCode());\n-            src.sendResponse(buildResponse(BookieProtocol.EBADREQ, h.getVersion(),\n-                                           h.getOpCode(), ledgerId, entryId));\n-            break;\n-        }\n-\n-        if (h.getVersion() < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n-            || h.getVersion() > BookieProtocol.CURRENT_PROTOCOL_VERSION) {\n-            LOG.error(\"Invalid protocol version, expected something between \"\n-                      + BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION \n-                      + \" & \" + BookieProtocol.CURRENT_PROTOCOL_VERSION\n-                    + \". got \" + h.getVersion());\n-            src.sendResponse(buildResponse(BookieProtocol.EBADVERSION, \n-                                           h.getVersion(), h.getOpCode(), ledgerId, entryId));\n-            return;\n-        }\n-        short flags = h.getFlags();\n-        switch (h.getOpCode()) {\n-        case BookieProtocol.ADDENTRY:\n-            statType = BKStats.STATS_ADD;\n-\n-            if (bookie.isReadOnly()) {\n-                LOG.warn(\"BookieServer is running as readonly mode,\"\n-                        + \" so rejecting the request from the client!\");\n-                src.sendResponse(buildResponse(BookieProtocol.EREADONLY,\n-                        h.getVersion(), h.getOpCode(), ledgerId, entryId));\n-                break;\n-            }\n-\n-            try {\n-                TimedCnxn tsrc = new TimedCnxn(src, startTime);\n-                if ((flags & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n-                    bookie.recoveryAddEntry(packet.slice(), this, tsrc, masterKey);\n-                } else {\n-                    bookie.addEntry(packet.slice(), this, tsrc, masterKey);\n-                }\n-                success = true;\n-            } catch (IOException e) {\n-                LOG.error(\"Error writing \" + entryId + \"@\" + ledgerId, e);\n-                src.sendResponse(buildResponse(BookieProtocol.EIO, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n-            } catch (BookieException.LedgerFencedException lfe) {\n-                LOG.error(\"Attempt to write to fenced ledger\", lfe);\n-                src.sendResponse(buildResponse(BookieProtocol.EFENCED, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n-            } catch (BookieException e) {\n-                LOG.error(\"Unauthorized access to ledger \" + ledgerId, e);\n-                src.sendResponse(buildResponse(BookieProtocol.EUA, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n-            }\n-            break;\n-        case BookieProtocol.READENTRY:\n-            statType = BKStats.STATS_READ;\n-            ByteBuffer[] rsp = new ByteBuffer[2];\n-            LOG.debug(\"Received new read request: {}, {}\", ledgerId, entryId);\n-            int errorCode = BookieProtocol.EIO;\n-            try {\n-                Future<Boolean> fenceResult = null;\n-                if ((flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {\n-                    LOG.warn(\"Ledger \" + ledgerId + \" fenced by \" + src.getPeerName());\n-                    if (h.getVersion() >= 2) {\n-                        masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n-                        packet.get(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n-\n-                        fenceResult = bookie.fenceLedger(ledgerId, masterKey);\n-                    } else {\n-                        LOG.error(\"Password not provided, Not safe to fence {}\", ledgerId);\n-                        throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n-                    }\n-                }\n-                rsp[1] = bookie.readEntry(ledgerId, entryId);\n-                LOG.debug(\"##### Read entry ##### {}\", rsp[1].remaining());\n-                if (null != fenceResult) {\n-                    // TODO:\n-                    // currently we don't have readCallback to run in separated read\n-                    // threads. after BOOKKEEPER-429 is complete, we could improve\n-                    // following code to make it not wait here\n-                    //\n-                    // For now, since we only try to wait after read entry. so writing\n-                    // to journal and read entry are executed in different thread\n-                    // it would be fine.\n-                    try {\n-                        Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n-                        if (null == fenced || !fenced) {\n-                            // if failed to fence, fail the read request to make it retry.\n-                            errorCode = BookieProtocol.EIO;\n-                            success = false;\n-                            rsp[1] = null;\n-                        } else {\n-                            errorCode = BookieProtocol.EOK;\n-                            success = true;\n-                        }\n-                    } catch (InterruptedException ie) {\n-                        LOG.error(\"Interrupting fence read entry (lid:\" + ledgerId\n-                                  + \", eid:\" + entryId + \") :\", ie);\n-                        errorCode = BookieProtocol.EIO;\n-                        success = false;\n-                        rsp[1] = null;\n-                    } catch (ExecutionException ee) {\n-                        LOG.error(\"Failed to fence read entry (lid:\" + ledgerId\n-                                  + \", eid:\" + entryId + \") :\", ee);\n-                        errorCode = BookieProtocol.EIO;\n-                        success = false;\n-                        rsp[1] = null;\n-                    } catch (TimeoutException te) {\n-                        LOG.error(\"Timeout to fence read entry (lid:\" + ledgerId\n-                                  + \", eid:\" + entryId + \") :\", te);\n-                        errorCode = BookieProtocol.EIO;\n-                        success = false;\n-                        rsp[1] = null;\n-                    }\n-                } else {\n-                    errorCode = BookieProtocol.EOK;\n-                    success = true;\n-                }\n-            } catch (Bookie.NoLedgerException e) {\n-                if (LOG.isTraceEnabled()) {\n-                    LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n-                }\n-                errorCode = BookieProtocol.ENOLEDGER;\n-            } catch (Bookie.NoEntryException e) {\n-                if (LOG.isTraceEnabled()) {\n-                    LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n-                }\n-                errorCode = BookieProtocol.ENOENTRY;\n-            } catch (IOException e) {\n-                if (LOG.isTraceEnabled()) {\n-                    LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n-                }\n-                errorCode = BookieProtocol.EIO;\n-            } catch (BookieException e) {\n-                LOG.error(\"Unauthorized access to ledger \" + ledgerId, e);\n-                errorCode = BookieProtocol.EUA;\n-            }\n-            rsp[0] = buildResponse(errorCode, h.getVersion(), h.getOpCode(), ledgerId, entryId);\n-\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Read entry rc = \" + errorCode + \" for \" + entryId + \"@\" + ledgerId);\n-            }\n-            if (rsp[1] == null) {\n-                // We haven't filled in entry data, so we have to send back\n-                // the ledger and entry ids here\n-                rsp[1] = ByteBuffer.allocate(16);\n-                rsp[1].putLong(ledgerId);\n-                rsp[1].putLong(entryId);\n-                rsp[1].flip();\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                byte[] content = new byte[rsp[1].remaining()];\n-                rsp[1].duplicate().get(content);\n-                LOG.trace(\"Sending response for: {}, content: {}\", entryId, Hex.encodeHexString(content));\n-            } else {\n-                LOG.debug(\"Sending response for: {}, length: {}\", entryId, rsp[1].remaining());\n-            }\n-            src.sendResponse(rsp);\n-            break;\n-        default:\n-            src.sendResponse(buildResponse(BookieProtocol.EBADREQ, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n-        }\n-        if (isStatsEnabled) {\n-            if (success) {\n-                // for add operations, we compute latency in writeComplete callbacks.\n-                if (statType != BKStats.STATS_ADD) {\n-                    long elapsedTime = MathUtils.now() - startTime;\n-                    bkStats.getOpStats(statType).updateLatency(elapsedTime);\n-                }\n-            } else {\n-                bkStats.getOpStats(statType).incrementFailedOps();\n-            }\n-        }\n-    }\n-\n-    private ByteBuffer buildResponse(int errorCode, byte version, byte opCode, long ledgerId, long entryId) {\n-        ByteBuffer rsp = ByteBuffer.allocate(24);\n-        rsp.putInt(new PacketHeader(version, \n-                                    opCode, (short)0).toInt());\n-        rsp.putInt(errorCode);\n-        rsp.putLong(ledgerId);\n-        rsp.putLong(entryId);\n-\n-        rsp.flip();\n-        return rsp;\n-    }\n-\n-    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n-        TimedCnxn tcnxn = (TimedCnxn) ctx;\n-        Cnxn src = tcnxn.cnxn;\n-        long startTime = tcnxn.time;\n-        ByteBuffer bb = ByteBuffer.allocate(24);\n-        bb.putInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION, \n-                                   BookieProtocol.ADDENTRY, (short)0).toInt());\n-        bb.putInt(rc);\n-        bb.putLong(ledgerId);\n-        bb.putLong(entryId);\n-        bb.flip();\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Add entry rc = \" + rc + \" for \" + entryId + \"@\" + ledgerId);\n-        }\n-        src.sendResponse(new ByteBuffer[] { bb });\n-        if (isStatsEnabled) {\n-            // compute the latency\n-            if (0 == rc) {\n-                // for add operations, we compute latency in writeComplete callbacks.\n-                long elapsedTime = MathUtils.now() - startTime;\n-                bkStats.getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n-            } else {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();                \n-            }\n-        }\n-    }\n-\n-    /**\n-     * A cnxn wrapper for time\n-     */\n-    static class TimedCnxn {\n-        Cnxn cnxn;\n-        long time;\n-\n-        public TimedCnxn(Cnxn cnxn, long startTime) {\n-            this.cnxn = cnxn;\n-            this.time = startTime;\n-        }\n-    }\n-\n }"},{"sha":"73c3ee5443f799c7412385b4b7ee2b72f77f37b8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -18,15 +18,13 @@\n \n package org.apache.bookkeeper.proto;\n \n-import java.net.InetAddress;\n import java.net.UnknownHostException;\n \n import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.proto.BKStats;\n-import org.apache.bookkeeper.proto.BKStats.OpStats;\n import org.apache.bookkeeper.proto.BKStats.OpStatData;\n \n /**\n@@ -66,12 +64,12 @@ public long getNumPacketsSent() {\n \n     @Override\n     public OpStatData getAddStats() {\n-        return bks.bkStats.getOpStats(BKStats.STATS_ADD).toOpStatData();\n+        return BKStats.getInstance().getOpStats(BKStats.STATS_ADD).toOpStatData();\n     }\n \n     @Override\n     public OpStatData getReadStats() {\n-        return bks.bkStats.getOpStats(BKStats.STATS_READ).toOpStatData();\n+        return BKStats.getInstance().getOpStats(BKStats.STATS_READ).toOpStatData();\n     }\n \n     @Override"},{"sha":"8f205fe3c076ecd269b8e5b0077946044d020972","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","status":"removed","additions":0,"deletions":558,"changes":558,"blob_url":"https://github.com/apache/bookkeeper/blob/3bcabc5adb48e75dd041384ebcbb0017d56c3299/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/3bcabc5adb48e75dd041384ebcbb0017d56c3299/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java?ref=3bcabc5adb48e75dd041384ebcbb0017d56c3299","patch":"@@ -1,558 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.proto;\n-\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.CancelledKeyException;\n-import java.nio.channels.Channel;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.Selector;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.SocketChannel;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Set;\n-import java.util.concurrent.LinkedBlockingQueue;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-\n-/**\n- * This class handles communication with clients using NIO. There is one Cnxn\n- * per client, but only one thread doing the communication.\n- */\n-public class NIOServerFactory extends Thread {\n-\n-    public interface PacketProcessor {\n-        public void processPacket(ByteBuffer packet, Cnxn src);\n-    }\n-\n-    ServerStats stats = new ServerStats();\n-\n-    Logger LOG = LoggerFactory.getLogger(NIOServerFactory.class);\n-\n-    ServerSocketChannel ss;\n-\n-    Selector selector = Selector.open();\n-\n-    /**\n-     * We use this buffer to do efficient socket I/O. Since there is a single\n-     * sender thread per NIOServerCnxn instance, we can use a member variable to\n-     * only allocate it once.\n-     */\n-    ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);\n-\n-    HashSet<Cnxn> cnxns = new HashSet<Cnxn>();\n-\n-    int outstandingLimit = 2000;\n-\n-    PacketProcessor processor;\n-\n-    long minLatency = 99999999;\n-\n-    ServerConfiguration conf;\n-\n-    private Object suspensionLock = new Object();\n-    private boolean suspended = false;\n-\n-    public NIOServerFactory(ServerConfiguration conf, PacketProcessor processor) throws IOException {\n-        super(\"NIOServerFactory-\" + conf.getBookiePort());\n-        setDaemon(true);\n-        this.processor = processor;\n-        this.conf = conf;\n-        this.ss = ServerSocketChannel.open();\n-        ss.socket().bind(new InetSocketAddress(conf.getBookiePort()));\n-        ss.configureBlocking(false);\n-        ss.register(selector, SelectionKey.OP_ACCEPT);\n-    }\n-\n-    public InetSocketAddress getLocalAddress() {\n-        return (InetSocketAddress) ss.socket().getLocalSocketAddress();\n-    }\n-\n-    private void addCnxn(Cnxn cnxn) {\n-        synchronized (cnxns) {\n-            cnxns.add(cnxn);\n-        }\n-    }\n-\n-    public boolean isRunning() {\n-        return !ss.socket().isClosed();\n-    }\n-\n-    /**\n-     * Stop nio server from processing requests. (for testing)\n-     */\n-    @VisibleForTesting\n-    public void suspendProcessing() {\n-        synchronized(suspensionLock) {\n-            suspended = true;\n-        }\n-    }\n-\n-    /**\n-     * Resume processing requests in nio server. (for testing)\n-     */\n-    @VisibleForTesting\n-    public void resumeProcessing() {\n-        synchronized(suspensionLock) {\n-            suspended = false;\n-            suspensionLock.notify();\n-        }\n-    }\n-\n-    @Override\n-    public void run() {\n-        while (!ss.socket().isClosed()) {\n-            try {\n-                selector.select(1000);\n-                synchronized(suspensionLock) {\n-                    while (suspended) {\n-                        suspensionLock.wait();\n-                    }\n-                }\n-                Set<SelectionKey> selected;\n-                synchronized (this) {\n-                    selected = selector.selectedKeys();\n-                }\n-                ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(selected);\n-                Collections.shuffle(selectedList);\n-                for (SelectionKey k : selectedList) {\n-                    if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {\n-                        SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n-                        sc.configureBlocking(false);\n-                        SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);\n-                        Cnxn cnxn = new Cnxn(sc, sk);\n-                        sk.attach(cnxn);\n-                        addCnxn(cnxn);\n-                    } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {\n-                        Cnxn c = (Cnxn) k.attachment();\n-                        c.doIO(k);\n-                    }\n-                }\n-                selected.clear();\n-            } catch (Exception e) {\n-                LOG.warn(\"Exception in server socket loop: \" + ss.socket().getInetAddress(), e);\n-            }\n-        }\n-        LOG.info(\"NIOServerCnxn factory exitedloop.\");\n-        clear();\n-    }\n-\n-    /**\n-     * clear all the connections in the selector\n-     *\n-     */\n-    synchronized public void clear() {\n-        selector.wakeup();\n-        synchronized (cnxns) {\n-            // got to clear all the connections that we have in the selector\n-            for (Iterator<Cnxn> it = cnxns.iterator(); it.hasNext();) {\n-                Cnxn cnxn = it.next();\n-                it.remove();\n-                try {\n-                    cnxn.close();\n-                } catch (Exception e) {\n-                    // Do nothing.\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    public void shutdown() {\n-        try {\n-            ss.close();\n-            clear();\n-            this.interrupt();\n-            this.join();\n-        } catch (InterruptedException e) {\n-            LOG.warn(\"Interrupted\", e);\n-        } catch (Exception e) {\n-            LOG.error(\"Unexpected exception\", e);\n-        }\n-    }\n-\n-    /**\n-     * The buffer will cause the connection to be close when we do a send.\n-     */\n-    static final ByteBuffer closeConn = ByteBuffer.allocate(0);\n-\n-    public class Cnxn {\n-\n-        private SocketChannel sock;\n-\n-        private SelectionKey sk;\n-\n-        boolean initialized;\n-\n-        ByteBuffer lenBuffer = ByteBuffer.allocate(4);\n-\n-        ByteBuffer incomingBuffer = lenBuffer;\n-\n-        LinkedBlockingQueue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();\n-\n-        int sessionTimeout;\n-\n-        void doIO(SelectionKey k) throws InterruptedException {\n-            try {\n-                if (sock == null) {\n-                    return;\n-                }\n-                if (k.isReadable()) {\n-                    int rc = sock.read(incomingBuffer);\n-                    if (rc < 0) {\n-                        throw new IOException(\"Read error\");\n-                    }\n-                    if (incomingBuffer.remaining() == 0) {\n-                        incomingBuffer.flip();\n-                        if (incomingBuffer == lenBuffer) {\n-                            readLength(k);\n-                        } else {\n-                            cnxnStats.packetsReceived++;\n-                            ServerStats.getInstance().incrementPacketsReceived();\n-                            try {\n-                                readRequest();\n-                            } finally {\n-                                lenBuffer.clear();\n-                                incomingBuffer = lenBuffer;\n-                            }\n-                        }\n-                    }\n-                }\n-                if (k.isWritable()) {\n-                    if (outgoingBuffers.size() > 0) {\n-                        // ZooLog.logTraceMessage(LOG,\n-                        // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,\n-                        // \"sk \" + k + \" is valid: \" +\n-                        // k.isValid());\n-\n-                        /*\n-                         * This is going to reset the buffer position to 0 and\n-                         * the limit to the size of the buffer, so that we can\n-                         * fill it with data from the non-direct buffers that we\n-                         * need to send.\n-                         */\n-                        directBuffer.clear();\n-\n-                        for (ByteBuffer b : outgoingBuffers) {\n-                            if (directBuffer.remaining() < b.remaining()) {\n-                                /*\n-                                 * When we call put later, if the directBuffer\n-                                 * is to small to hold everything, nothing will\n-                                 * be copied, so we've got to slice the buffer\n-                                 * if it's too big.\n-                                 */\n-                                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n-                            }\n-                            /*\n-                             * put() is going to modify the positions of both\n-                             * buffers, put we don't want to change the position\n-                             * of the source buffers (we'll do that after the\n-                             * send, if needed), so we save and reset the\n-                             * position after the copy\n-                             */\n-                            int p = b.position();\n-                            directBuffer.put(b);\n-                            b.position(p);\n-                            if (directBuffer.remaining() == 0) {\n-                                break;\n-                            }\n-                        }\n-                        /*\n-                         * Do the flip: limit becomes position, position gets\n-                         * set to 0. This sets us up for the write.\n-                         */\n-                        directBuffer.flip();\n-\n-                        int sent = sock.write(directBuffer);\n-                        ByteBuffer bb;\n-\n-                        // Remove the buffers that we have sent\n-                        while (outgoingBuffers.size() > 0) {\n-                            bb = outgoingBuffers.peek();\n-                            if (bb == closeConn) {\n-                                throw new IOException(\"closing\");\n-                            }\n-                            int left = bb.remaining() - sent;\n-                            if (left > 0) {\n-                                /*\n-                                 * We only partially sent this buffer, so we\n-                                 * update the position and exit the loop.\n-                                 */\n-                                bb.position(bb.position() + sent);\n-                                break;\n-                            }\n-                            cnxnStats.packetsSent++;\n-                            /* We've sent the whole buffer, so drop the buffer */\n-                            sent -= bb.remaining();\n-                            ServerStats.getInstance().incrementPacketsSent();\n-                            outgoingBuffers.remove();\n-                        }\n-                        // ZooLog.logTraceMessage(LOG,\n-                        // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, \"after send,\n-                        // outgoingBuffers.size() = \" + outgoingBuffers.size());\n-                    }\n-                    synchronized (this) {\n-                        if (outgoingBuffers.size() == 0) {\n-                            if (!initialized && (sk.interestOps() & SelectionKey.OP_READ) == 0) {\n-                                throw new IOException(\"Responded to info probe\");\n-                            }\n-                            sk.interestOps(sk.interestOps() & (~SelectionKey.OP_WRITE));\n-                        } else {\n-                            sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);\n-                        }\n-                    }\n-                }\n-            } catch (CancelledKeyException e) {\n-                close();\n-            } catch (IOException e) {\n-                // LOG.error(\"FIXMSG\",e);\n-                close();\n-            }\n-        }\n-\n-        private void readRequest() throws IOException {\n-            incomingBuffer = incomingBuffer.slice();\n-            processor.processPacket(incomingBuffer, this);\n-        }\n-\n-        public void disableRecv() {\n-            sk.interestOps(sk.interestOps() & (~SelectionKey.OP_READ));\n-        }\n-\n-        public void enableRecv() {\n-            if (sk.isValid()) {\n-                int interest = sk.interestOps();\n-                if ((interest & SelectionKey.OP_READ) == 0) {\n-                    sk.interestOps(interest | SelectionKey.OP_READ);\n-                }\n-            }\n-        }\n-\n-        private void readLength(SelectionKey k) throws IOException {\n-            // Read the length, now get the buffer\n-            int len = lenBuffer.getInt();\n-            if (len < 0 || len > 0xfffff) {\n-                throw new IOException(\"Len error \" + len);\n-            }\n-            incomingBuffer = ByteBuffer.allocate(len);\n-        }\n-\n-        /**\n-         * The number of requests that have been submitted but not yet responded\n-         * to.\n-         */\n-        int outstandingRequests;\n-\n-        /*\n-         * (non-Javadoc)\n-         *\n-         * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n-         */\n-        public int getSessionTimeout() {\n-            return sessionTimeout;\n-        }\n-\n-        String peerName = null;\n-\n-        public Cnxn(SocketChannel sock, SelectionKey sk) throws IOException {\n-            this.sock = sock;\n-            this.sk = sk;\n-            sock.socket().setTcpNoDelay(conf.getServerTcpNoDelay());\n-            sock.socket().setSoLinger(true, 2);\n-            sk.interestOps(SelectionKey.OP_READ);\n-            if (LOG.isTraceEnabled()) {\n-                peerName = sock.socket().toString();\n-            }\n-\n-            lenBuffer.clear();\n-            incomingBuffer = lenBuffer;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"NIOServerCnxn object with sock = \" + sock + \" and sk = \" + sk;\n-        }\n-\n-        public String getPeerName() {\n-            if (peerName == null) {\n-                peerName = sock.socket().toString();\n-            }\n-            return peerName;\n-        }\n-\n-        boolean closed;\n-\n-        /*\n-         * (non-Javadoc)\n-         *\n-         * @see org.apache.zookeeper.server.ServerCnxnIface#close()\n-         */\n-        public void close() {\n-            if (closed) {\n-                return;\n-            }\n-            closed = true;\n-            synchronized (cnxns) {\n-                cnxns.remove(this);\n-            }\n-            LOG.debug(\"close NIOServerCnxn: {}\", sock);\n-            try {\n-                /*\n-                 * The following sequence of code is stupid! You would think\n-                 * that only sock.close() is needed, but alas, it doesn't work\n-                 * that way. If you just do sock.close() there are cases where\n-                 * the socket doesn't actually close...\n-                 */\n-                sock.socket().shutdownOutput();\n-            } catch (IOException e) {\n-                // This is a relatively common exception that we can't avoid\n-            }\n-            try {\n-                sock.socket().shutdownInput();\n-            } catch (IOException e) {\n-            }\n-            try {\n-                sock.socket().close();\n-            } catch (IOException e) {\n-                LOG.error(\"FIXMSG\", e);\n-            }\n-            try {\n-                sock.close();\n-                // XXX The next line doesn't seem to be needed, but some posts\n-                // to forums suggest that it is needed. Keep in mind if errors\n-                // in\n-                // this section arise.\n-                // factory.selector.wakeup();\n-            } catch (IOException e) {\n-                LOG.error(\"FIXMSG\", e);\n-            }\n-            sock = null;\n-            if (sk != null) {\n-                try {\n-                    // need to cancel this selection key from the selector\n-                    sk.cancel();\n-                } catch (Exception e) {\n-                }\n-            }\n-        }\n-\n-        private void makeWritable(SelectionKey sk) {\n-            try {\n-                selector.wakeup();\n-                if (sk.isValid()) {\n-                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);\n-                }\n-            } catch (RuntimeException e) {\n-                LOG.error(\"Problem setting writable\", e);\n-                throw e;\n-            }\n-        }\n-\n-        private void sendBuffers(ByteBuffer bb[]) {\n-            ByteBuffer len = ByteBuffer.allocate(4);\n-            int total = 0;\n-            for (int i = 0; i < bb.length; i++) {\n-                if (bb[i] != null) {\n-                    total += bb[i].remaining();\n-                }\n-            }\n-            LOG.debug(\"Sending response of size {} to {}\", total, peerName);\n-            len.putInt(total);\n-            len.flip();\n-            outgoingBuffers.add(len);\n-            for (int i = 0; i < bb.length; i++) {\n-                if (bb[i] != null) {\n-                    outgoingBuffers.add(bb[i]);\n-                }\n-            }\n-            makeWritable(sk);\n-        }\n-\n-        synchronized public void sendResponse(ByteBuffer... bb) {\n-            if (closed) {\n-                return;\n-            }\n-            sendBuffers(bb);\n-            synchronized (NIOServerFactory.this) {\n-                outstandingRequests--;\n-                // check throttling\n-                if (outstandingRequests < outstandingLimit) {\n-                    sk.selector().wakeup();\n-                    enableRecv();\n-                }\n-            }\n-        }\n-\n-        public InetSocketAddress getRemoteAddress() {\n-            return (InetSocketAddress) sock.socket().getRemoteSocketAddress();\n-        }\n-\n-        private class CnxnStats {\n-            long packetsSent = 0;\n-            long packetsReceived = 0;\n-\n-            /**\n-             * The number of requests that have been submitted but not yet\n-             * responded to.\n-             */\n-            public long getOutstandingRequests() {\n-                synchronized(Cnxn.this) {\n-                    return outstandingRequests;\n-                }\n-            }\n-\n-            public long getPacketsReceived() {\n-                return packetsReceived;\n-            }\n-\n-            public long getPacketsSent() {\n-                return packetsSent;\n-            }\n-\n-            @Override\n-            public String toString() {\n-                StringBuilder sb = new StringBuilder();\n-                Channel channel = sk.channel();\n-                if (channel instanceof SocketChannel) {\n-                    sb.append(\" \").append(((SocketChannel) channel).socket().getRemoteSocketAddress()).append(\"[\")\n-                    .append(Integer.toHexString(sk.interestOps())).append(\"](queued=\").append(\n-                        getOutstandingRequests()).append(\",recved=\").append(getPacketsReceived()).append(\n-                            \",sent=\").append(getPacketsSent()).append(\")\\n\");\n-                }\n-                return sb.toString();\n-            }\n-        }\n-\n-        private CnxnStats cnxnStats = new CnxnStats();\n-\n-        public CnxnStats getStats() {\n-            return cnxnStats;\n-        }\n-    }\n-}"},{"sha":"2cce5c15bbdf44c909928dbf479ddfdcdeb1e879","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -0,0 +1,40 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.nio.ByteBuffer;\n+\n+class ResponseBuilder {\n+    static BookieProtocol.Response buildErrorResponse(int errorCode, BookieProtocol.Request r) {\n+        return new BookieProtocol.ErrorResponse(r.getProtocolVersion(), r.getOpCode(),\n+                                                errorCode, r.getLedgerId(), r.getEntryId());\n+    }\n+\n+    static BookieProtocol.Response buildAddResponse(BookieProtocol.Request r) {\n+        return new BookieProtocol.AddResponse(r.getProtocolVersion(), r.getLedgerId(),\n+                                              r.getEntryId());\n+    }\n+\n+    static BookieProtocol.Response buildReadResponse(ByteBuffer data, BookieProtocol.Request r) {\n+        return new BookieProtocol.ReadResponse(r.getProtocolVersion(),\n+                                               r.getLedgerId(), r.getEntryId(), data);\n+    }\n+}"},{"sha":"4f76ea5e5036dccb2279f36ec514c2855d117381","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -29,6 +29,7 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n+import org.jboss.netty.channel.ChannelException;\n import junit.framework.Assert;\n \n import org.apache.bookkeeper.bookie.Bookie;\n@@ -229,9 +230,11 @@ public void testDuplicateBookieServerStartup() throws Exception {\n             BookieServer bs2 = new BookieServer(conf);\n             bs2.start();\n             fail(\"Should throw BindException, as the bk server is already running!\");\n-        } catch (BindException be) {\n-            Assert.assertTrue(\"BKServer allowed duplicate startups!\", be\n-                    .getMessage().contains(\"Address already in use\"));\n+        } catch (ChannelException ce) {\n+            Assert.assertTrue(\"Should be caused by a bind exception\",\n+                              ce.getCause() instanceof BindException);\n+            Assert.assertTrue(\"BKServer allowed duplicate startups!\",\n+                    ce.getCause().getMessage().contains(\"Address already in use\"));\n         }\n     }\n "},{"sha":"3d6e7aa175ff549d6e07e6d59901dac20b2170da","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/26731c770bf8e3cb54ec0466c027b6e313983bba/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java?ref=26731c770bf8e3cb54ec0466c027b6e313983bba","patch":"@@ -92,15 +92,13 @@ public void testBookieServerZKExpireBehaviour() throws Exception {\n             // allow watcher thread to run\n             secondsToWait = 20;\n             while (server.isBookieRunning()\n-                   || server.isNioServerRunning()\n                    || server.isRunning()) {\n                 Thread.sleep(1000);\n                 if (secondsToWait-- <= 0) {\n                     break;\n                 }\n             }\n             assertFalse(\"Bookie should have shutdown on losing zk session\", server.isBookieRunning());\n-            assertFalse(\"Nio Server should have shutdown on losing zk session\", server.isNioServerRunning());\n             assertFalse(\"Bookie Server should have shutdown on losing zk session\", server.isRunning());\n         } finally {\n             server.shutdown();"},{"sha":"b68d0554eed0f0d273438b54cffde1106a79aa67","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/3bcabc5adb48e75dd041384ebcbb0017d56c3299/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3bcabc5adb48e75dd041384ebcbb0017d56c3299/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java?ref=3bcabc5adb48e75dd041384ebcbb0017d56c3299","patch":"@@ -1,65 +0,0 @@\n-package org.apache.bookkeeper.test;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-import java.net.Socket;\n-import java.nio.ByteBuffer;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.proto.NIOServerFactory;\n-import org.apache.bookkeeper.proto.NIOServerFactory.Cnxn;\n-import org.apache.bookkeeper.proto.NIOServerFactory.PacketProcessor;\n-import org.junit.Test;\n-\n-import junit.framework.TestCase;\n-\n-public class NIOServerFactoryTest extends TestCase {\n-    PacketProcessor problemProcessor = new PacketProcessor() {\n-\n-        public void processPacket(ByteBuffer packet, Cnxn src) {\n-            if (packet.getInt() == 1) {\n-                throw new RuntimeException(\"Really bad thing happened\");\n-            }\n-            src.sendResponse(new ByteBuffer[] { ByteBuffer.allocate(4) });\n-        }\n-\n-    };\n-\n-    @Test(timeout=60000)\n-    public void testProblemProcessor() throws Exception {\n-        ServerConfiguration conf = new ServerConfiguration();\n-        int port = PortManager.nextFreePort();\n-        conf.setBookiePort(port);\n-        NIOServerFactory factory = new NIOServerFactory(conf, problemProcessor);\n-        factory.start();\n-        Socket s = new Socket(\"127.0.0.1\", port);\n-        s.setSoTimeout(5000);\n-        try {\n-            s.getOutputStream().write(\"\\0\\0\\0\\4\\0\\0\\0\\1\".getBytes());\n-            s.getOutputStream().write(\"\\0\\0\\0\\4\\0\\0\\0\\2\".getBytes());\n-            s.getInputStream().read();\n-        } finally {\n-            s.close();\n-            factory.shutdown();\n-        }\n-    }\n-}"}]}

