{"sha":"27421024f8899d4bbed706a82462140c124628a1","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyNzQyMTAyNGY4ODk5ZDRiYmVkNzA2YTgyNDYyMTQwYzEyNDYyOGEx","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-03-10T02:07:03Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-03-10T02:07:03Z"},"message":"BOOKKEEPER-714: Logging channel exceptions in PerChannelBookieClient (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1575793 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c5009dcd569b77d372cbd62dbd7ded67cd9f6f50","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c5009dcd569b77d372cbd62dbd7ded67cd9f6f50"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/27421024f8899d4bbed706a82462140c124628a1","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/27421024f8899d4bbed706a82462140c124628a1","html_url":"https://github.com/apache/bookkeeper/commit/27421024f8899d4bbed706a82462140c124628a1","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/27421024f8899d4bbed706a82462140c124628a1/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"728a82387596c823fa30fe7b391d289590b7eae1","url":"https://api.github.com/repos/apache/bookkeeper/commits/728a82387596c823fa30fe7b391d289590b7eae1","html_url":"https://github.com/apache/bookkeeper/commit/728a82387596c823fa30fe7b391d289590b7eae1"}],"stats":{"total":30,"additions":19,"deletions":11},"files":[{"sha":"f4e38a320a262df074601a2cd7e0924570a4b2f0","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/27421024f8899d4bbed706a82462140c124628a1/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/27421024f8899d4bbed706a82462140c124628a1/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=27421024f8899d4bbed706a82462140c124628a1","patch":"@@ -14,6 +14,8 @@ Release 4.2.3 - 2013-12-04\n \n         BOOKKEEPER-602: we should have request timeouts rather than channel timeout in PerChannelBookieClient (Aniruddha via sijie)\n \n+        BOOKKEEPER-714: Logging channel exceptions in PerChannelBookieClient (sijie)\n+\n Release 4.2.2 - 2013-10-02\n \n   Backward compatible changes:"},{"sha":"645eceeb98b3349893594c932bfe74cdb634d168","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":17,"deletions":11,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/27421024f8899d4bbed706a82462140c124628a1/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/27421024f8899d4bbed706a82462140c124628a1/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=27421024f8899d4bbed706a82462140c124628a1","patch":"@@ -19,16 +19,14 @@\n \n import java.io.IOException;\n import java.net.InetSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n-import java.util.Set;\n-import java.util.Collections;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import com.google.common.collect.ImmutableSet;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n@@ -57,10 +55,7 @@\n import org.jboss.netty.handler.codec.frame.CorruptedFrameException;\n import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n-import org.jboss.netty.handler.timeout.ReadTimeoutException;\n import org.jboss.netty.handler.timeout.ReadTimeoutHandler;\n-import org.jboss.netty.util.HashedWheelTimer;\n-import org.jboss.netty.util.Timer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -204,8 +199,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         closeChannel(future.getChannel());\n                         return; // pendingOps should have been completed when other channel connected\n                     } else {\n-                        LOG.error(\"Could not connect to bookie: {}, current state {}\",\n-                                  future.getChannel(), state);\n+                        LOG.error(\"Could not connect to bookie: {}, current state {} : \",\n+                                  new Object[] { future.getChannel(), state, future.getCause() });\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n                         closeChannel(future.getChannel());\n                         channel = null;\n@@ -280,11 +275,10 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n      * @param ledgerId\n      * @param masterKey\n      * @param entryId\n-     * @param lastConfirmed\n-     * @param macCode\n-     * @param data\n+     * @param toSend\n      * @param cb\n      * @param ctx\n+     * @param options\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n@@ -324,6 +318,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         }\n                         // totalBytesOutstanding.addAndGet(entrySize);\n                     } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing addEntry(lid={}, eid={}) to channel {} failed : \",\n+                                    new Object[] { ledgerId, entryId, c, future.getCause() });\n+                        }\n                         errorOutAddKey(completionKey);\n                     }\n                 }\n@@ -371,6 +369,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                                   + ledgerId + \" bookie: \" + c.getRemoteAddress());\n                     }\n                 } else {\n+                    if (!(future.getCause() instanceof ClosedChannelException)) {\n+                        LOG.warn(\"Writing readEntryAndFenceLedger(lid={}, eid={}) to channel {} failed : \",\n+                                new Object[] { ledgerId, entryId, c, future.getCause() });\n+                    }\n                     errorOutReadKey(key);\n                 }\n             }\n@@ -410,6 +412,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                                                             + ledgerId + \" bookie: \" + c.getRemoteAddress());\n                         }\n                     } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing readEntry(lid={}, eid={}) to channel {} failed : \",\n+                                    new Object[] { ledgerId, entryId, c, future.getCause() });\n+                        }\n                         errorOutReadKey(key);\n                     }\n                 }"}]}

