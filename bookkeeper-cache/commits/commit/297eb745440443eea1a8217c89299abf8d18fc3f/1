{"sha":"297eb745440443eea1a8217c89299abf8d18fc3f","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyOTdlYjc0NTQ0MDQ0M2VlYTFhODIxN2M4OTI5OWFiZjhkMThmYzNm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-06-19T10:39:37Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-06-19T10:39:37Z"},"message":"BOOKKEEPER-203: improve ledger manager interface to remove zookeeper dependency on metadata operations. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1351646 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8990efc2fb0ad267ba43cd5cf8c9856cf132ee52","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8990efc2fb0ad267ba43cd5cf8c9856cf132ee52"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/297eb745440443eea1a8217c89299abf8d18fc3f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/297eb745440443eea1a8217c89299abf8d18fc3f","html_url":"https://github.com/apache/bookkeeper/commit/297eb745440443eea1a8217c89299abf8d18fc3f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/297eb745440443eea1a8217c89299abf8d18fc3f/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"9472fae8739be41301847b1c8e31954f376997e6","url":"https://api.github.com/repos/apache/bookkeeper/commits/9472fae8739be41301847b1c8e31954f376997e6","html_url":"https://github.com/apache/bookkeeper/commit/9472fae8739be41301847b1c8e31954f376997e6"}],"stats":{"total":2267,"additions":1515,"deletions":752},"files":[{"sha":"a39cbcec61e4238c10b988a8570d0441c2aa9dad","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -6,6 +6,8 @@ Trunk (unreleased changes)\n \n     IMPROVEMENTS:\n \n+      BOOKKEEPER-203: improve ledger manager interface to remove zookeeper dependency on metadata operations. (sijie via ivank)\n+\n   Backward compatible changes:\n \n     BUGFIXES:"},{"sha":"130100b6872416d986860cc6bd2be1c24b0fd5bf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":13,"deletions":5,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -36,7 +36,7 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.ActiveLedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n@@ -66,9 +66,11 @@\n     final ServerConfiguration conf;\n \n     final SyncThread syncThread;\n-    final LedgerManager ledgerManager;\n+    final LedgerManagerFactory activeLedgerManagerFactory;\n+    final ActiveLedgerManager activeLedgerManager;\n     final LedgerStorage ledgerStorage;\n     final Journal journal;\n+\n     final HandleFactory handles;\n \n     static final long METAENTRY_ID_LEDGER_KEY = -0x1000;\n@@ -351,10 +353,11 @@ public Bookie(ServerConfiguration conf)\n         this.zk = instantiateZookeeperClient(conf);\n         checkEnvironment(this.zk);\n \n-        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, this.zk);\n+        activeLedgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n+        activeLedgerManager = activeLedgerManagerFactory.newActiveLedgerManager();\n \n         syncThread = new SyncThread(conf);\n-        ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager);\n+        ledgerStorage = new InterleavedLedgerStorage(conf, activeLedgerManager);\n         handles = new HandleFactoryImpl(ledgerStorage);\n         // instantiate the journal\n         journal = new Journal(conf);\n@@ -603,7 +606,12 @@ synchronized int shutdown(int exitCode) {\n                 syncThread.shutdown();\n \n                 // close Ledger Manager\n-                ledgerManager.close();\n+                try {\n+                    activeLedgerManager.close();\n+                    activeLedgerManagerFactory.uninitialize();\n+                } catch (IOException ie) {\n+                    LOG.error(\"Failed to close active ledger manager : \", ie);\n+                }\n                 // setting running to false here, so watch thread in bookie server know it only after bookie shut down\n                 running = false;\n             }"},{"sha":"0375499beba4a55c31b4c6931fb829887298eeba","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -36,7 +36,7 @@\n \n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.ActiveLedgerManager;\n import org.apache.zookeeper.ZooKeeper;\n \n /**\n@@ -73,7 +73,7 @@\n     // Ledger Cache Handle\n     final LedgerCache ledgerCache;\n \n-    final LedgerManager ledgerManager;\n+    final ActiveLedgerManager activeLedgerManager;\n \n     // flag to ensure gc thread will not be interrupted during compaction\n     // to reduce the risk getting entry log corrupted\n@@ -117,14 +117,14 @@ public void process(long ledgerId, long offset, ByteBuffer entry)\n     public GarbageCollectorThread(ServerConfiguration conf,\n                                   LedgerCache ledgerCache,\n                                   EntryLogger entryLogger,\n-                                  LedgerManager ledgerManager,\n+                                  ActiveLedgerManager activeLedgerManager,\n                                   EntryLogScanner scanner)\n         throws IOException {\n         super(\"GarbageCollectorThread\");\n \n         this.ledgerCache = ledgerCache;\n         this.entryLogger = entryLogger;\n-        this.ledgerManager = ledgerManager;\n+        this.activeLedgerManager = activeLedgerManager;\n         this.scanner = scanner;\n \n         this.gcWaitTime = conf.getGcWaitTime();\n@@ -224,8 +224,8 @@ public void run() {\n      * Do garbage collection ledger index files\n      */\n     private void doGcLedgers() {\n-        ledgerManager.garbageCollectLedgers(\n-        new LedgerManager.GarbageCollector() {\n+        activeLedgerManager.garbageCollectLedgers(\n+        new ActiveLedgerManager.GarbageCollector() {\n             @Override\n             public void gc(long ledgerId) {\n                 try {\n@@ -246,7 +246,7 @@ private void doGcEntryLogs() {\n             EntryLogMetadata meta = entryLogMetaMap.get(entryLogId);\n             for (Long entryLogLedger : meta.ledgersMap.keySet()) {\n                 // Remove the entry log ledger from the set if it isn't active.\n-                if (!ledgerManager.containsActiveLedger(entryLogLedger)) {\n+                if (!activeLedgerManager.containsActiveLedger(entryLogLedger)) {\n                     meta.removeLedger(entryLogLedger);\n                 }\n             }"},{"sha":"9aef9c5271735292ddafb7a42493b7f9c50a6586","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -26,7 +26,7 @@\n \n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.ActiveLedgerManager;\n import org.apache.bookkeeper.proto.BookieProtocol;\n \n import org.slf4j.Logger;\n@@ -50,12 +50,12 @@\n     // this indicates that a write has happened since the last flush\n     private volatile boolean somethingWritten = false;\n \n-    InterleavedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager)\n+    InterleavedLedgerStorage(ServerConfiguration conf, ActiveLedgerManager activeLedgerManager)\n             throws IOException {\n         entryLogger = new EntryLogger(conf);\n-        ledgerCache = new LedgerCacheImpl(conf, ledgerManager);\n+        ledgerCache = new LedgerCacheImpl(conf, activeLedgerManager);\n         gcThread = new GarbageCollectorThread(conf, ledgerCache, entryLogger,\n-                ledgerManager, new EntryLogCompactionScanner());\n+                activeLedgerManager, new EntryLogCompactionScanner());\n     }\n \n     @Override    "},{"sha":"d26410e0bb339514739d0ed4cdafa64bacb1ed90","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -35,7 +35,7 @@\n import java.util.Random;\n import java.util.Map.Entry;\n \n-import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.ActiveLedgerManager;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -49,7 +49,7 @@\n \n     final File ledgerDirectories[];\n \n-    public LedgerCacheImpl(ServerConfiguration conf, LedgerManager alm) {\n+    public LedgerCacheImpl(ServerConfiguration conf, ActiveLedgerManager alm) {\n         this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n         this.openFileLimit = conf.getOpenFileLimit();\n         this.pageSize = conf.getPageSize();\n@@ -83,7 +83,7 @@ public LedgerCacheImpl(ServerConfiguration conf, LedgerManager alm) {\n \n     // Manage all active ledgers in LedgerManager\n     // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n-    final LedgerManager activeLedgerManager;\n+    final ActiveLedgerManager activeLedgerManager;\n \n     final int openFileLimit;\n     final int pageSize;"},{"sha":"4d04e7f8d3ccd42b96f2cd642b13deb35d7857bd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -76,6 +76,8 @@ public static BKException create(int code) {\n             return new BKInterruptedException();\n         case Code.ProtocolVersionException:\n             return new BKProtocolVersionException();\n+        case Code.MetadataVersionException:\n+            return new BKMetadataVersionException();\n         case Code.LedgerFencedException:\n             return new BKLedgerFencedException();\n         case Code.UnauthorizedAccessException:\n@@ -107,6 +109,7 @@ public static BKException create(int code) {\n         int IncorrectParameterException = -14;\n         int InterruptedException = -15;\n         int ProtocolVersionException = -16;\n+        int MetadataVersionException = -17;\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n@@ -157,6 +160,8 @@ public static String getMessage(int code) {\n             return \"Interrupted while waiting for permit\";\n         case Code.ProtocolVersionException:\n             return \"Bookie protocol version on server is incompatible with client\";\n+        case Code.MetadataVersionException:\n+            return \"Bad ledger metadata version\";\n         case Code.LedgerFencedException:\n             return \"Ledger has been fenced off. Some other client must have opened it to read\";\n         case Code.UnauthorizedAccessException:\n@@ -226,6 +231,12 @@ public BKProtocolVersionException() {\n         }\n     }\n \n+    public static class BKMetadataVersionException extends BKException {\n+        public BKMetadataVersionException() {\n+            super(Code.MetadataVersionException);\n+        }\n+    }\n+\n     public static class BKNoSuchLedgerExistsException extends BKException {\n         public BKNoSuchLedgerExistsException() {\n             super(Code.NoSuchLedgerExistsException);"},{"sha":"15e288f76185ef556744644f8b53dc1b6fef8ad9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":13,"deletions":8,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -81,6 +81,7 @@\n     final OrderedSafeExecutor mainWorkerPool;\n \n     // Ledger manager responsible for how to store ledger meta data\n+    final LedgerManagerFactory ledgerManagerFactory;\n     final LedgerManager ledgerManager;\n \n     final ClientConfiguration conf;\n@@ -148,7 +149,8 @@ public void process(WatchedEvent event) {\n         bookieWatcher = new BookieWatcher(conf, this);\n         bookieWatcher.readBookiesBlocking();\n \n-        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n+        ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n+        ledgerManager = ledgerManagerFactory.newLedgerManager();\n \n         ownChannelFactory = true;\n         ownZKHandle = true;\n@@ -210,7 +212,8 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n         bookieWatcher = new BookieWatcher(conf, this);\n         bookieWatcher.readBookiesBlocking();\n \n-        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n+        ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n+        ledgerManager = ledgerManagerFactory.newLedgerManager();\n     }\n \n     LedgerManager getLedgerManager() {\n@@ -494,11 +497,8 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n         asyncDeleteLedger(lId, new SyncDeleteCallback(), counter);\n         // Wait\n         counter.block(0);\n-        if (counter.getrc() == KeeperException.Code.NONODE.intValue()) {\n-            LOG.warn(\"Ledger node does not exist in ZooKeeper: ledgerId={}\", lId);\n-            throw BKException.create(Code.NoSuchLedgerExistsException);\n-        } else if (counter.getrc() != KeeperException.Code.OK.intValue()) {\n-            LOG.error(\"ZooKeeper error deleting ledger node: \" + counter.getrc());\n+        if (counter.getrc() != BKException.Code.OK) {\n+            LOG.error(\"Error deleting ledger \" + lId + \" : \" + counter.getrc());\n             throw BKException.create(Code.ZKException);\n         }\n     }\n@@ -509,7 +509,12 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n      */\n     public void close() throws InterruptedException, BKException {\n         bookieClient.close();\n-        ledgerManager.close();\n+        try {\n+            ledgerManager.close();\n+            ledgerManagerFactory.uninitialize();\n+        } catch (IOException ie) {\n+            LOG.error(\"Failed to close ledger manager : \", ie);\n+        }\n         bookieWatcher.halt();\n         if (ownChannelFactory) {\n             channelFactory.releaseExternalResources();"},{"sha":"41a4fa4d253be7df4d3331f722e271fed802e445","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":8,"deletions":11,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -752,14 +752,13 @@ protected void writeLedgerConfig() {\n             int deadBookieIndex = ensemble.indexOf(oldBookie);\n             ensemble.remove(deadBookieIndex);\n             ensemble.add(deadBookieIndex, newBookie);\n-\n-            lh.writeLedgerConfig(new WriteCb(), null);\n+            lh.writeLedgerConfig(new WriteCb());\n         }\n         \n-        private class WriteCb implements AsyncCallback.StatCallback {\n+        private class WriteCb implements GenericCallback<Void> {\n             @Override\n-            public void processResult(int rc, final String path, Object ctx, Stat stat) {\n-                if (rc == Code.BADVERSION.intValue()) {\n+            public void operationComplete(int rc, Void result) {\n+                if (rc == BKException.Code.MetadataVersionException) {\n                     LOG.warn(\"Two fragments attempted update at once; ledger id: \" + lh.getId() \n                              + \" startid: \" + fragmentStartId);\n                     // try again, the previous success (with which this has conflicted)\n@@ -769,8 +768,7 @@ public void processResult(int rc, final String path, Object ctx, Stat stat) {\n                         @Override\n                         public void operationComplete(int rc, LedgerMetadata newMeta) {\n                             if (rc != BKException.Code.OK) {\n-                                LOG.error(\"Error reading updated ledger metadata for ledger \" + lh.getId(),\n-                                          KeeperException.create(KeeperException.Code.get(rc), path));\n+                                LOG.error(\"Error reading updated ledger metadata for ledger \" + lh.getId());\n                                 ledgerFragmentsMcb.processResult(rc, null, null);\n                             } else {\n                                 lh.metadata = newMeta;\n@@ -779,11 +777,10 @@ public void operationComplete(int rc, LedgerMetadata newMeta) {\n                         }\n                     });\n                     return;\n-                } else if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n-                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                } else if (rc != BKException.Code.OK) {\n+                    LOG.error(\"Error updating ledger config metadata for ledgerId \" + lh.getId() + \" : \"\n+                            + BKException.getMessage(rc));\n                 } else {\n-                    lh.getLedgerMetadata().updateZnodeStatus(stat);\n                     LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId() + \" : \" + fragmentStartId \n                              + \") to point ledger fragments from old dead bookie: (\" + oldBookie\n                              + \") to new bookie: (\" + newBookie + \")\");"},{"sha":"060a8aeddb8e23e4ed96eb0602548366aa678fe5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":9,"deletions":24,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -25,20 +25,20 @@\n import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n+\n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.data.Stat;\n \n /**\n  * Encapsulates asynchronous ledger create operation\n  *\n  */\n-class LedgerCreateOp implements GenericCallback<String> {\n+class LedgerCreateOp implements GenericCallback<Long> {\n \n     static final Logger LOG = LoggerFactory.getLogger(LedgerCreateOp.class);\n \n@@ -102,32 +102,17 @@ public void initiate() {\n          */\n         metadata.addEnsemble(0L, ensemble);\n \n-        // create a ledger path with metadata\n-        bk.getLedgerManager().newLedgerPath(this, metadata);\n+        // create a ledger with metadata\n+        bk.getLedgerManager().createLedger(metadata, this);\n     }\n \n     /**\n-     * Callback when created ledger path.\n+     * Callback when created ledger.\n      */\n     @Override\n-    public void operationComplete(int rc, String ledgerPath) {\n-\n-        if (rc != KeeperException.Code.OK.intValue()) {\n-            LOG.error(\"Could not create node for ledger\",\n-                      KeeperException.create(KeeperException.Code.get(rc), ledgerPath));\n-            cb.createComplete(BKException.Code.ZKException, null, this.ctx);\n-            return;\n-        }\n-\n-        /*\n-         * Extract ledger id.\n-         */\n-        long ledgerId;\n-        try {\n-            ledgerId = bk.getLedgerManager().getLedgerId(ledgerPath);\n-        } catch (IOException e) {\n-            LOG.error(\"Could not extract ledger-id from path:\" + ledgerPath, e);\n-            cb.createComplete(BKException.Code.ZKException, null, this.ctx);\n+    public void operationComplete(int rc, Long ledgerId) {\n+        if (BKException.Code.OK != rc) {\n+            cb.createComplete(rc, null, this.ctx);\n             return;\n         }\n "},{"sha":"eaaddeda34646a0c952a436bc140e61a8cc32cea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"modified","additions":6,"deletions":10,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -22,15 +22,15 @@\n package org.apache.bookkeeper.client;\n \n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.AsyncCallback.VoidCallback;\n \n /**\n  * Encapsulates asynchronous ledger delete operation\n  *\n  */\n-class LedgerDeleteOp implements VoidCallback {\n+class LedgerDeleteOp implements GenericCallback<Void> {\n \n     static final Logger LOG = LoggerFactory.getLogger(LedgerDeleteOp.class);\n \n@@ -62,19 +62,15 @@\n      * Initiates the operation\n      */\n     public void initiate() {\n-        // Asynchronously delete the ledger node in ZK.\n+        // Asynchronously delete the ledger from meta manager\n         // When this completes, it will invoke the callback method below.\n-\n-        bk.getZkHandle().delete(bk.getLedgerManager().getLedgerPath(ledgerId), -1, this, null);\n+        bk.getLedgerManager().deleteLedger(ledgerId, this);\n     }\n \n     /**\n-     * Implements ZooKeeper Void Callback.\n-     *\n-     * @see org.apache.zookeeper.AsyncCallback.VoidCallback#processResult(int,\n-     *      java.lang.String, java.lang.Object)\n+     * Implements Delete Callback.\n      */\n-    public void processResult(int rc, String path, Object ctx) {\n+    public void operationComplete(int rc, Void result) {\n         cb.deleteComplete(rc, this.ctx);\n     }\n "},{"sha":"051ae175537a3b50c2b8c411c4aaf25392f9c518","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":43,"deletions":77,"changes":120,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -46,10 +46,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.AsyncCallback.StatCallback;\n-import org.apache.zookeeper.AsyncCallback.DataCallback;\n-import org.apache.zookeeper.data.Stat;\n import org.jboss.netty.buffer.ChannelBuffer;\n \n /**\n@@ -205,14 +201,12 @@ DistributionSchedule getDistributionSchedule() {\n         return distributionSchedule;\n     }\n \n-    void writeLedgerConfig(StatCallback callback, Object ctx) {\n+    void writeLedgerConfig(GenericCallback<Void> writeCb) {\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Writing metadata to ZooKeeper: \" + this.ledgerId + \", \" + metadata.getZnodeVersion());\n+            LOG.debug(\"Writing metadata to ledger manager: \" + this.ledgerId + \", \" + metadata.getVersion());\n         }\n \n-        bk.getZkHandle().setData(bk.getLedgerManager().getLedgerPath(ledgerId),\n-                                 metadata.serialize(), metadata.getZnodeVersion(),\n-                                 callback, ctx);\n+        bk.getLedgerManager().writeLedgerMetadata(ledgerId, metadata, writeCb);\n     }\n \n     /**\n@@ -286,48 +280,44 @@ public void safeRun() {\n                               + metadata.close + \" with this many bytes: \" + metadata.length);\n                 }\n \n-                final class CloseCb implements StatCallback {\n+                final class CloseCb implements GenericCallback<Void> {\n                     @Override\n-                    public void processResult(final int rc, String path, Object subctx,\n-                                              final Stat stat) {\n-                        if (rc == KeeperException.Code.BadVersion) {\n+                    public void operationComplete(final int rc, Void result) {\n+                        if (rc == BKException.Code.MetadataVersionException) {\n                             rereadMetadata(new GenericCallback<LedgerMetadata>() {\n                                 @Override\n                                 public void operationComplete(int newrc, LedgerMetadata newMeta) {\n                                     if (newrc != BKException.Code.OK) {\n                                         LOG.error(\"Error reading new metadata from ledger \" + ledgerId\n                                                   + \" when closing, code=\" + newrc);\n-                                        cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this, ctx);\n+                                        cb.closeComplete(rc, LedgerHandle.this, ctx);\n                                     } else {\n                                         metadata.close(prevClose);\n                                         metadata.length = prevLength;\n                                         if (metadata.resolveConflict(newMeta)) {\n                                             metadata.length = length;\n                                             metadata.close(lastAddConfirmed);\n-                                            writeLedgerConfig(new CloseCb(), null);\n+                                            writeLedgerConfig(new CloseCb());\n                                             return;\n                                         } else {\n                                             metadata.length = length;\n                                             metadata.close(lastAddConfirmed);\n-                                            LOG.warn(\"Conditional write failed: \"\n-                                                     + KeeperException.Code.get(KeeperException.Code.BadVersion));\n-                                            cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this, ctx);\n+                                            LOG.warn(\"Conditional update ledger metadata for ledger \" + ledgerId + \" failed.\");\n+                                            cb.closeComplete(rc, LedgerHandle.this, ctx);\n                                         }\n                                     }\n                                 }\n                             });\n-                        } else if (rc != KeeperException.Code.OK.intValue()) {\n-                            LOG.warn(\"Conditional write failed: \" + KeeperException.Code.get(rc));\n-                            cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n-                                             ctx);\n+                        } else if (rc != BKException.Code.OK) {\n+                            LOG.error(\"Error update ledger metadata for ledger \" + ledgerId + \" : \" + rc);\n+                            cb.closeComplete(rc, LedgerHandle.this, ctx);\n                         } else {\n-                            metadata.updateZnodeStatus(stat);\n                             cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n                         }\n                     }\n                 };\n \n-                writeLedgerConfig(new CloseCb(), null);\n+                writeLedgerConfig(new CloseCb());\n \n             }\n         });\n@@ -687,48 +677,46 @@ void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n         final long newEnsembleStartEntry = lastAddConfirmed + 1;\n         metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n \n-        final class ChangeEnsembleCb implements StatCallback {\n+        final class ChangeEnsembleCb implements GenericCallback<Void> {\n             @Override\n-            public void processResult(final int rc, String path, Object ctx, final Stat stat) {\n+            public void operationComplete(final int rc, Void result) {\n \n                 bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n                     @Override\n                     public void safeRun() {\n-                        if (rc == KeeperException.Code.BadVersion) {\n+                        if (rc == BKException.Code.MetadataVersionException) {\n                             rereadMetadata(new GenericCallback<LedgerMetadata>() {\n                                 @Override\n                                 public void operationComplete(int newrc, LedgerMetadata newMeta) {\n                                     if (newrc != BKException.Code.OK) {\n                                         LOG.error(\"Error reading new metadata from ledger after changing ensemble, code=\" + newrc);\n-                                        handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                                        handleUnrecoverableErrorDuringAdd(rc);\n                                     } else {\n                                         // a new ensemble is added only when the start entry is larger than zero\n                                         if (newEnsembleStartEntry > 0) {\n                                             metadata.getEnsembles().remove(newEnsembleStartEntry);\n                                         }\n                                         if (metadata.resolveConflict(newMeta)) {\n                                             metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n-                                            writeLedgerConfig(new ChangeEnsembleCb(), null);\n+                                            writeLedgerConfig(new ChangeEnsembleCb());\n                                             return;\n                                         } else {\n                                             LOG.error(\"Could not resolve ledger metadata conflict while changing ensemble to: \"\n                                                       + newEnsemble + \", old meta data is \\n\" + new String(metadata.serialize())\n                                                       + \"\\n, new meta data is \\n\" + new String(newMeta.serialize()) + \"\\n ,closing ledger\");\n-                                            handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                                            handleUnrecoverableErrorDuringAdd(rc);\n                                         }\n                                     }\n                                 }\n                             });\n                             return;\n-                        } else if (rc != KeeperException.Code.OK.intValue()) {\n-                            LOG\n-                            .error(\"Could not persist ledger metadata while changing ensemble to: \"\n-                                   + newEnsemble + \" , closing ledger\");\n-                            handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                        } else if (rc != BKException.Code.OK) {\n+                            LOG.error(\"Could not persist ledger metadata while changing ensemble to: \"\n+                                    + newEnsemble + \" , closing ledger\");\n+                            handleUnrecoverableErrorDuringAdd(rc);\n                             return;\n                         }\n \n-                        metadata.updateZnodeStatus(stat);\n                         for (PendingAddOp pendingAddOp : pendingAddOps) {\n                             pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n                         }\n@@ -738,31 +726,11 @@ public void operationComplete(int newrc, LedgerMetadata newMeta) {\n             }\n         };\n \n-        writeLedgerConfig(new ChangeEnsembleCb(), null);\n-\n+        writeLedgerConfig(new ChangeEnsembleCb());\n     }\n \n     void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n-        bk.getZkHandle().getData(bk.getLedgerManager().getLedgerPath(ledgerId), false,\n-            new DataCallback() {\n-                public void processResult(int rc, String path,\n-                                          Object ctx, byte[] data, Stat stat) {\n-                    if (rc != KeeperException.Code.OK.intValue()) {\n-                        LOG.error(\"Error reading metadata from ledger, code =\" + rc);\n-                        cb.operationComplete(BKException.Code.ZKException, null);\n-                        return;\n-                    }\n-\n-                    try {\n-                        LedgerMetadata newMeta = LedgerMetadata.parseConfig(data, stat.getVersion());\n-                        cb.operationComplete(BKException.Code.OK, newMeta);\n-                    } catch (IOException e) {\n-                        LOG.error(\"Error parsing ledger metadata for ledger\", e);\n-                        cb.operationComplete(BKException.Code.ZKException, null);\n-                        return;\n-                    }\n-                }\n-        }, null);\n+        bk.getLedgerManager().readLedgerMetadata(ledgerId, cb);\n     }\n \n     synchronized void recover(final GenericCallback<Void> cb) {\n@@ -784,39 +752,37 @@ synchronized void recover(final GenericCallback<Void> cb) {\n \n         metadata.markLedgerInRecovery();\n \n-        writeLedgerConfig(new StatCallback() {\n+        writeLedgerConfig(new GenericCallback<Void>() {\n             @Override\n-            public void processResult(final int rc, String path, Object ctx, Stat stat) {\n-                if (rc == KeeperException.Code.BadVersion) {\n+            public void operationComplete(final int rc, Void result) {\n+                if (rc == BKException.Code.MetadataVersionException) {\n                     rereadMetadata(new GenericCallback<LedgerMetadata>() {\n-                            @Override\n-                            public void operationComplete(int rc, LedgerMetadata newMeta) {\n-                                if (rc != BKException.Code.OK) {\n-                                    cb.operationComplete(rc, null);\n-                                } else {\n-                                    metadata = newMeta;\n-                                    recover(cb);\n-                                }\n+                        @Override\n+                        public void operationComplete(int rc, LedgerMetadata newMeta) {\n+                            if (rc != BKException.Code.OK) {\n+                                cb.operationComplete(rc, null);\n+                            } else {\n+                                metadata = newMeta;\n+                                recover(cb);\n                             }\n-                        });\n-                } else if (rc == KeeperException.Code.OK.intValue()) {\n-                    metadata.znodeVersion = stat.getVersion();\n+                        }\n+                    });\n+                } else if (rc == BKException.Code.OK) {\n                     new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n                 } else {\n-                    LOG.error(\"Error writing ledger config \" +  rc \n-                              + \" path = \" + path);\n-                    cb.operationComplete(BKException.Code.ZKException, null);\n+                    LOG.error(\"Error writing ledger config \" + rc + \" of ledger \" + ledgerId);\n+                    cb.operationComplete(rc, null);\n                 }\n             }\n-        }, null);\n+        });\n     }\n \n     static class NoopCloseCallback implements CloseCallback {\n         static NoopCloseCallback instance = new NoopCloseCallback();\n \n         @Override\n         public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n-            if (rc != KeeperException.Code.OK.intValue()) {\n+            if (rc != BKException.Code.OK) {\n                 LOG.warn(\"Close failed: \" + BKException.getMessage(rc));\n             }\n             // noop"},{"sha":"0f0e90d0f9ccdb12f77d318f7ba5ac46454cb152","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":18,"deletions":25,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -26,6 +26,7 @@\n import java.util.SortedMap;\n import java.util.TreeMap;\n \n+import org.apache.bookkeeper.versioning.Version;\n import org.apache.bookkeeper.util.StringUtils;\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n@@ -60,8 +61,8 @@\n     long close;\n     private SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = new TreeMap<Long, ArrayList<InetSocketAddress>>();\n     ArrayList<InetSocketAddress> currentEnsemble;\n-    volatile int znodeVersion = -1;\n-    \n+    volatile Version version = null;\n+\n     public LedgerMetadata(int ensembleSize, int quorumSize) {\n         this.ensembleSize = ensembleSize;\n         this.quorumSize = quorumSize;\n@@ -171,12 +172,13 @@ long getNextEnsembleChange(long entryId) {\n      *\n      * @param array\n      *            byte array to parse\n+     * @param version\n+     *            version of the ledger metadata\n      * @return LedgerConfig\n      * @throws IOException\n      *             if the given byte[] cannot be parsed\n      */\n-\n-    static LedgerMetadata parseConfig(byte[] bytes, int version) throws IOException {\n+    public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws IOException {\n \n         LedgerMetadata lc = new LedgerMetadata();\n         String config = new String(bytes);\n@@ -207,7 +209,7 @@ static LedgerMetadata parseConfig(byte[] bytes, int version) throws IOException\n                 throw new IOException(\"Quorum size or ensemble size absent from config: \" + config);\n             }\n \n-            lc.znodeVersion = version;\n+            lc.version = version;\n             lc.quorumSize = new Integer(lines[i++]);\n             lc.ensembleSize = new Integer(lines[i++]);\n             lc.length = new Long(lines[i++]);\n@@ -234,31 +236,21 @@ static LedgerMetadata parseConfig(byte[] bytes, int version) throws IOException\n     \n \n     /**\n-     * Updates the status of this metadata in ZooKeeper.\n+     * Updates the version of this metadata.\n      * \n-     * @param stat\n-     */\n-    public void updateZnodeStatus(Stat stat) {\n-        this.znodeVersion = stat.getVersion();\n-    }\n-\n-    /**\n-     * Update the znode version of this metadata\n-     *\n-     * @param znodeVersion\n-     *        Znode version of this metadata\n+     * @param v Version\n      */\n-    public void updateZnodeStatus(int znodeVersion) {\n-        this.znodeVersion = znodeVersion;\n+    public void setVersion(Version v) {\n+        this.version = v;\n     }\n \n     /**\n-     * Returns the last znode version.\n+     * Returns the last version.\n      * \n-     * @return int znode version\n+     * @return version\n      */\n-    public int getZnodeVersion() {\n-        return this.znodeVersion;\n+    public Version getVersion() {\n+        return this.version;\n     }\n \n     /**\n@@ -282,7 +274,8 @@ boolean resolveConflict(LedgerMetadata newMeta) {\n             return false;\n         }\n         // new meta znode version should be larger than old one\n-        if (znodeVersion > newMeta.znodeVersion) {\n+        if (null != version &&\n+            Version.Occurred.AFTER == version.compare(newMeta.version)) {\n             return false;\n         }\n         // ensemble size should be same\n@@ -306,7 +299,7 @@ boolean resolveConflict(LedgerMetadata newMeta) {\n          *  ensemble and znode version\n          */\n         ensembles = newMeta.ensembles;\n-        znodeVersion = newMeta.znodeVersion;\n+        version = newMeta.version;\n         return true;\n     }\n }"},{"sha":"41cbdd6b987c8b24d1be86d59bf3720c35f26ed5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":11,"deletions":32,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -23,21 +23,20 @@\n \n import java.io.IOException;\n import java.security.GeneralSecurityException;\n+\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.AsyncCallback.DataCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.zookeeper.data.Stat;\n \n /**\n  * Encapsulates the ledger open operation\n  *\n  */\n-class LedgerOpenOp implements DataCallback {\n+class LedgerOpenOp implements GenericCallback<LedgerMetadata> {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerOpenOp.class);\n \n     final BookKeeper bk;\n@@ -78,8 +77,7 @@ public void initiate() {\n         /**\n          * Asynchronously read the ledger metadata node.\n          */\n-\n-        bk.getZkHandle().getData(bk.getLedgerManager().getLedgerPath(ledgerId), false, this, ctx);\n+        bk.getLedgerManager().readLedgerMetadata(ledgerId, this);\n     }\n \n     /**\n@@ -91,34 +89,15 @@ public void initiateWithoutRecovery() {\n     }\n \n     /**\n-     * Implements ZooKeeper data callback.\n-     * @see org.apache.zookeeper.AsyncCallback.DataCallback#processResult(int, String, Object, byte[], Stat)\n+     * Implements Open Ledger Callback.\n      */\n-    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n-\n-        if (rc == KeeperException.Code.NONODE.intValue()) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"No such ledger: \" + ledgerId, KeeperException.create(KeeperException.Code.get(rc), path));\n-            }\n-            cb.openComplete(BKException.Code.NoSuchLedgerExistsException, null, this.ctx);\n+    public void operationComplete(int rc, LedgerMetadata metadata) {\n+        if (BKException.Code.OK != rc) {\n+            // open ledger failed.\n+            cb.openComplete(rc, null, this.ctx);\n             return;\n         }\n-        if (rc != KeeperException.Code.OK.intValue()) {\n-            LOG.error(\"Could not read metadata for ledger: \" + ledgerId, KeeperException.create(KeeperException.Code\n-                      .get(rc), path));\n-            cb.openComplete(BKException.Code.ZKException, null, this.ctx);\n-            return;\n-        }\n-\n-        LedgerMetadata metadata;\n-        try {\n-            metadata = LedgerMetadata.parseConfig(data, stat.getVersion());\n-        } catch (IOException e) {\n-            LOG.error(\"Could not parse ledger metadata for ledger: \" + ledgerId, e);\n-            cb.openComplete(BKException.Code.ZKException, null, this.ctx);\n-            return;\n-        }\n-\n+        // get the ledger metadata back\n         try {\n             lh = new ReadOnlyLedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n         } catch (GeneralSecurityException e) {"},{"sha":"c3c427d1481a285a16ebbfd367ccd8caa8ab0745","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -26,14 +26,29 @@\n import org.apache.commons.configuration.SystemConfiguration;\n \n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Abstract configuration\n  */\n public abstract class AbstractConfiguration extends CompositeConfiguration {\n \n+    static final Logger LOG = LoggerFactory.getLogger(AbstractConfiguration.class);\n+\n+    private static ClassLoader defaultLoader;\n+    static {\n+        defaultLoader = Thread.currentThread().getContextClassLoader();\n+        if (null == defaultLoader) {\n+            defaultLoader = AbstractConfiguration.class.getClassLoader();\n+        }\n+    }\n+\n     // Ledger Manager\n     protected final static String LEDGER_MANAGER_TYPE = \"ledgerManagerType\";\n+    protected final static String LEDGER_MANAGER_FACTORY_CLASS = \"ledgerManagerFactoryClass\";\n     protected final static String ZK_LEDGERS_ROOT_PATH = \"zkLedgersRootPath\";\n     protected final static String AVAILABLE_NODE = \"available\";\n     protected AbstractConfiguration() {\n@@ -79,7 +94,10 @@ public void loadConf(Configuration otherConf) {\n      *\n      * @param lmType\n      *          Ledger Manager Type\n+     * @return void\n+     * @deprecated replaced by {@link #setLedgerManagerFactoryClass()}\n      */\n+    @Deprecated\n     public void setLedgerManagerType(String lmType) {\n         setProperty(LEDGER_MANAGER_TYPE, lmType); \n     }\n@@ -89,11 +107,47 @@ public void setLedgerManagerType(String lmType) {\n      *\n      * @return ledger manager type\n      * @throws ConfigurationException\n+     * @deprecated replaced by {@link #getLedgerManagerFactoryClass()}\n      */\n+    @Deprecated\n     public String getLedgerManagerType() {\n         return getString(LEDGER_MANAGER_TYPE);\n     }\n \n+    /**\n+     * Set Ledger Manager Factory Class Name.\n+     *\n+     * @param factoryClassName\n+     *          Ledger Manager Factory Class Name\n+     * @return void\n+     */\n+    public void setLedgerManagerFactoryClassName(String factoryClassName) {\n+        setProperty(LEDGER_MANAGER_FACTORY_CLASS, factoryClassName);\n+    }\n+\n+    /**\n+     * Set Ledger Manager Factory Class.\n+     *\n+     * @param factoryClass\n+     *          Ledger Manager Factory Class\n+     * @return void\n+     */\n+    public void setLedgerManagerFactoryClass(Class<? extends LedgerManagerFactory> factoryClass) {\n+        setProperty(LEDGER_MANAGER_FACTORY_CLASS, factoryClass.getName());\n+    }\n+\n+    /**\n+     * Get ledger manager factory class.\n+     *\n+     * @return ledger manager factory class\n+     */\n+    public Class<? extends LedgerManagerFactory> getLedgerManagerFactoryClass()\n+        throws ConfigurationException {\n+        return ReflectionUtils.getClass(this, LEDGER_MANAGER_FACTORY_CLASS,\n+                                        null, LedgerManagerFactory.class,\n+                                        defaultLoader);\n+    }\n+\n     /**\n      * Set Zk Ledgers Root Path.\n      *"},{"sha":"f97fd27fb52cf19f4b1af6c9a90024f5139040b8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"modified","additions":129,"deletions":6,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -25,22 +25,29 @@\n import java.util.Map;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.versioning.Version;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.AsyncCallback.DataCallback;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+import org.apache.zookeeper.AsyncCallback.StatCallback;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.KeeperException.Code;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n \n /**\n  * Abstract ledger manager based on zookeeper, which provides common methods such as query zk nodes.\n  */\n-abstract class AbstractZkLedgerManager implements LedgerManager {\n+abstract class AbstractZkLedgerManager implements LedgerManager, ActiveLedgerManager {\n \n     static Logger LOG = LoggerFactory.getLogger(AbstractZkLedgerManager.class);\n \n@@ -53,21 +60,122 @@\n     protected final ZooKeeper zk;\n     protected final String ledgerRootPath;\n \n+    // A sorted map to stored all active ledger ids\n+    protected final SnapshotMap<Long, Boolean> activeLedgers;\n+\n     /**\n      * ZooKeeper-based Ledger Manager Constructor\n      *\n      * @param conf\n      *          Configuration object\n      * @param zk\n      *          ZooKeeper Client Handle\n-     * @param ledgerRootPath\n-     *          ZooKeeper Path to store ledger metadata\n      */\n-    protected AbstractZkLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n-                                      String ledgerRootPath) {\n+    protected AbstractZkLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n         this.conf = conf;\n         this.zk = zk;\n-        this.ledgerRootPath = ledgerRootPath;\n+        this.ledgerRootPath = conf.getZkLedgersRootPath();\n+\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n+    }\n+\n+    /**\n+     * Get the znode path that is used to store ledger metadata\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     * @return ledger node path\n+     */\n+    protected abstract String getLedgerPath(long ledgerId);\n+\n+    /**\n+     * Get ledger id from its znode ledger path\n+     *\n+     * @param ledgerPath\n+     *          Ledger path to store metadata\n+     * @return ledger id\n+     * @throws IOException when the ledger path is invalid\n+     */\n+    protected abstract long getLedgerId(String ledgerPath) throws IOException;\n+\n+    @Override\n+    public void deleteLedger(final long ledgerId, final GenericCallback<Void> cb) {\n+        zk.delete(getLedgerPath(ledgerId), -1, new VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                int bkRc;\n+                if (rc == KeeperException.Code.NONODE.intValue()) {\n+                    LOG.warn(\"Ledger node does not exist in ZooKeeper: ledgerId={}\", ledgerId);\n+                    bkRc = BKException.Code.NoSuchLedgerExistsException;\n+                } else if (rc == KeeperException.Code.OK.intValue()) {\n+                    bkRc = BKException.Code.OK;\n+                } else {\n+                    bkRc = BKException.Code.ZKException;\n+                }\n+                cb.operationComplete(bkRc, (Void)null);\n+            }\n+        }, null);\n+    }\n+\n+    @Override\n+    public void readLedgerMetadata(final long ledgerId, final GenericCallback<LedgerMetadata> readCb) {\n+        zk.getData(getLedgerPath(ledgerId), false, new DataCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                if (rc == KeeperException.Code.NONODE.intValue()) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"No such ledger: \" + ledgerId,\n+                                  KeeperException.create(KeeperException.Code.get(rc), path));\n+                    }\n+                    readCb.operationComplete(BKException.Code.NoSuchLedgerExistsException, null);\n+                    return;\n+                }\n+                if (rc != KeeperException.Code.OK.intValue()) {\n+                    LOG.error(\"Could not read metadata for ledger: \" + ledgerId,\n+                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                    readCb.operationComplete(BKException.Code.ZKException, null);\n+                    return;\n+                }\n+\n+                LedgerMetadata metadata;\n+                try {\n+                    metadata = LedgerMetadata.parseConfig(data, new ZkVersion(stat.getVersion()));\n+                } catch (IOException e) {\n+                    LOG.error(\"Could not parse ledger metadata for ledger: \" + ledgerId, e);\n+                    readCb.operationComplete(BKException.Code.ZKException, null);\n+                    return;\n+                }\n+                readCb.operationComplete(BKException.Code.OK, metadata);\n+            }\n+        }, null);\n+    }\n+\n+    @Override\n+    public void writeLedgerMetadata(final long ledgerId, final LedgerMetadata metadata,\n+                                    final GenericCallback<Void> cb) {\n+        Version v = metadata.getVersion();\n+        if (null == v || !(v instanceof ZkVersion)) {\n+            cb.operationComplete(BKException.Code.MetadataVersionException, null);\n+            return;\n+        }\n+        final ZkVersion zv = (ZkVersion) v;\n+        zk.setData(getLedgerPath(ledgerId),\n+                   metadata.serialize(), zv.getZnodeVersion(),\n+                   new StatCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                if (KeeperException.Code.BadVersion == rc) {\n+                    cb.operationComplete(BKException.Code.MetadataVersionException, null);\n+                } else if (KeeperException.Code.OK.intValue() == rc) {\n+                    // update metadata version\n+                    metadata.setVersion(zv.setZnodeVersion(stat.getVersion()));\n+                    cb.operationComplete(BKException.Code.OK, null);\n+                } else {\n+                    LOG.warn(\"Conditional update ledger metadata failed: \", KeeperException.Code.get(rc));\n+                    cb.operationComplete(BKException.Code.ZKException, null);\n+                }\n+            }\n+        }, null);\n     }\n \n     /**\n@@ -260,6 +368,21 @@ protected boolean isSpecialZnode(String znode) {\n     public void close() {\n     }\n \n+    @Override\n+    public void addActiveLedger(long ledgerId, boolean active) {\n+        activeLedgers.put(ledgerId, active);\n+    }\n+\n+    @Override\n+    public void removeActiveLedger(long ledgerId) {\n+        activeLedgers.remove(ledgerId);\n+    }\n+\n+    @Override\n+    public boolean containsActiveLedger(long ledgerId) {\n+        return activeLedgers.containsKey(ledgerId);\n+    }\n+\n     /**\n      * Do garbage collecting comparing hosted ledgers and zk ledgers\n      *"},{"sha":"542b4986359391b88bbaa65e65db20fd9bf24da0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,84 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.Closeable;\n+\n+/**\n+ * ActiveLedgerManager takes responsibility of active ledger management in bookie side.\n+ *\n+ * <ul>\n+ * <li>How to manager active ledgers (so know how to do garbage collection)\n+ * <li>How to garbage collect inactive/deleted ledgers\n+ * </ul>\n+ */\n+public interface ActiveLedgerManager extends Closeable {\n+\n+    /**\n+     * Add active ledger\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     * @param active\n+     *          Status of ledger\n+     */\n+    public void addActiveLedger(long ledgerId, boolean active);\n+\n+    /**\n+     * Remove active ledger\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     */\n+    public void removeActiveLedger(long ledgerId);\n+\n+    /**\n+     * Is Ledger ledgerId in active ledgers set\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     * @return true if the ledger is in active ledgers set, otherwise return false\n+     */\n+    public boolean containsActiveLedger(long ledgerId);\n+\n+    /**\n+     * Garbage Collector which handles ledger deletion in server side\n+     */\n+    public static interface GarbageCollector {\n+        /**\n+         * garbage collecting a specific ledger\n+         *\n+         * @param ledgerId\n+         *          Ledger ID to be garbage collected\n+         */\n+        public void gc(long ledgerId);\n+    }\n+\n+    /**\n+     * Garbage collecting all inactive/deleted ledgers\n+     * <p>\n+     * GarbageCollector#gc is triggered each time we found a ledger could be garbage collected.\n+     * After method finished, all those inactive ledgers should be garbage collected.\n+     * </p>\n+     *\n+     * @param gc garbage collector\n+     */\n+    public void garbageCollectLedgers(GarbageCollector gc);\n+\n+}"},{"sha":"4fa3e83e803aa14c9c80c4efd802e524c43ee7f3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"modified","additions":15,"deletions":34,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -19,10 +19,10 @@\n  */\n \n import java.io.IOException;\n-import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -32,6 +32,7 @@\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.AsyncCallback.StringCallback;\n import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.KeeperException.Code;\n import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.ZooKeeper;\n@@ -61,13 +62,8 @@\n class FlatLedgerManager extends AbstractZkLedgerManager {\n \n     static final Logger LOG = LoggerFactory.getLogger(FlatLedgerManager.class);\n-    public static final String NAME = \"flat\";\n-    public static final int CUR_VERSION = 1;\n-\n     // path prefix to store ledger znodes\n     private final String ledgerPrefix;\n-    // hash map to store all active ledger ids\n-    private SnapshotMap<Long, Boolean> activeLedgers;\n \n     /**\n      * Constructor\n@@ -80,32 +76,32 @@\n      *          ZooKeeper Path to store ledger metadata\n      * @throws IOException when version is not compatible\n      */\n-    public FlatLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n-                             String ledgerRootPath, int layoutVersion)\n-        throws IOException {\n-        super(conf, zk, ledgerRootPath);\n-\n-        if (layoutVersion != CUR_VERSION) {\n-            throw new IOException(\"Incompatible layout version found : \" \n-                                  + layoutVersion);\n-        }\n+    public FlatLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n+        super(conf, zk);\n \n         ledgerPrefix = ledgerRootPath + \"/\" + LEDGER_NODE_PREFIX;\n-        activeLedgers = new SnapshotMap<Long, Boolean>();\n     }\n \n     @Override\n-    public void newLedgerPath(final GenericCallback<String> cb, final LedgerMetadata metadata) {\n+    public void createLedger(final LedgerMetadata metadata, final GenericCallback<Long> cb) {\n         StringCallback scb = new StringCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx,\n                     String name) {\n                 if (Code.OK.intValue() != rc) {\n+                    LOG.error(\"Could not create node for ledger\",\n+                              KeeperException.create(KeeperException.Code.get(rc), path));\n                     cb.operationComplete(rc, null);\n                 } else {\n                     // update znode status\n-                    metadata.updateZnodeStatus(0);\n-                    cb.operationComplete(rc, name);\n+                    metadata.setVersion(new ZkVersion(0));\n+                    try {\n+                        long ledgerId = getLedgerId(name);\n+                        cb.operationComplete(rc, ledgerId);\n+                    } catch (IOException ie) {\n+                        LOG.error(\"Could not extract ledger-id from path:\" + name, ie);\n+                        cb.operationComplete(BKException.Code.ZKException, null);\n+                    }\n                 }\n             }\n         };\n@@ -140,21 +136,6 @@ public void asyncProcessLedgers(final Processor<Long> processor,\n         asyncProcessLedgersInSingleNode(ledgerRootPath, processor, finalCb, ctx, successRc, failureRc);\n     }\n \n-    @Override\n-    public void addActiveLedger(long ledgerId, boolean active) {\n-        activeLedgers.put(ledgerId, active);\n-    }\n-\n-    @Override\n-    public void removeActiveLedger(long ledgerId) {\n-        activeLedgers.remove(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean containsActiveLedger(long ledgerId) {\n-        return activeLedgers.containsKey(ledgerId);\n-    }\n-\n     @Override\n     public void garbageCollectLedgers(GarbageCollector gc) {\n         try {"},{"sha":"806492cfed9fa639b6d8bac60b27148cfcb35c64","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,72 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Flat Ledger Manager Factory\n+ */\n+class FlatLedgerManagerFactory extends LedgerManagerFactory {\n+\n+    public static final String NAME = \"flat\";\n+    public static final int CUR_VERSION = 1;\n+\n+    AbstractConfiguration conf;\n+    ZooKeeper zk;\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public LedgerManagerFactory initialize(final AbstractConfiguration conf,\n+                                           final ZooKeeper zk,\n+                                           final int factoryVersion)\n+    throws IOException {\n+        if (CUR_VERSION != factoryVersion) {\n+            throw new IOException(\"Incompatible layout version found : \"\n+                                + factoryVersion);\n+        }\n+        this.conf = conf;\n+        this.zk = zk;\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitialize() throws IOException {\n+        // since zookeeper instance is passed from outside\n+        // we don't need to close it here\n+    }\n+\n+    @Override\n+    public LedgerManager newLedgerManager() {\n+        return new FlatLedgerManager(conf, zk);\n+    }\n+\n+    @Override\n+    public ActiveLedgerManager newActiveLedgerManager() {\n+        return new FlatLedgerManager(conf, zk);\n+    }\n+\n+}"},{"sha":"34172a80723d0651859d7b320d090d557a7f59f9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":10,"deletions":40,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -25,7 +25,6 @@\n import java.util.Set;\n import java.util.Map;\n import java.util.NavigableMap;\n-import java.util.HashSet;\n import java.util.List;\n \n import org.apache.bookkeeper.client.LedgerMetadata;\n@@ -81,9 +80,6 @@\n class HierarchicalLedgerManager extends AbstractZkLedgerManager {\n \n     static final Logger LOG = LoggerFactory.getLogger(HierarchicalLedgerManager.class);\n-    public static final String NAME = \"hierarchical\";\n-\n-    public static final int CUR_VERSION = 1;\n \n     static final String IDGEN_ZNODE = \"idgen\";\n     static final String IDGENERATION_PREFIX = \"/\" + IDGEN_ZNODE + \"/ID-\";\n@@ -92,8 +88,6 @@\n \n     // Path to generate global id\n     private final String idGenPath;\n-    // A sorted map to stored all active ledger ids\n-    private SnapshotMap<Long, Boolean> activeLedgers;\n \n     // we use this to prevent long stack chains from building up in callbacks\n     ScheduledExecutorService scheduler;\n@@ -105,23 +99,11 @@\n      *          Configuration object\n      * @param zk\n      *          ZooKeeper Client Handle\n-     * @param ledgerRootPath\n-     *          ZooKeeper Path to store ledger metadata\n-     * @throws IOException when version is not compatible\n      */\n-    public HierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n-                                     String ledgerRootPath, int layoutVersion)\n-        throws IOException {\n-        super(conf, zk, ledgerRootPath);\n-\n-        if (layoutVersion != CUR_VERSION) {\n-            throw new IOException(\"Incompatible layout version found : \" \n-                                  + layoutVersion);\n-        }\n+    public HierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n+        super(conf, zk);\n \n         this.idGenPath = ledgerRootPath + IDGENERATION_PREFIX;\n-        activeLedgers = new SnapshotMap<Long, Boolean>();\n-\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Using HierarchicalLedgerManager with root path : \" + ledgerRootPath);\n@@ -139,7 +121,7 @@ public void close() {\n     }\n \n     @Override\n-    public void newLedgerPath(final GenericCallback<String> ledgerCb, final LedgerMetadata metadata) {\n+    public void createLedger(final LedgerMetadata metadata, final GenericCallback<Long> ledgerCb) {\n         ZkUtils.createFullPathOptimistic(zk, idGenPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n             CreateMode.EPHEMERAL_SEQUENTIAL, new StringCallback() {\n             @Override\n@@ -161,20 +143,23 @@ public void processResult(int rc, String path, Object ctx, final String idPathNa\n                     ledgerCb.operationComplete(KeeperException.Code.SYSTEMERROR.intValue(), null);\n                     return;\n                 }\n+                String ledgerPath = getLedgerPath(ledgerId);\n+                final long lid = ledgerId;\n                 StringCallback scb = new StringCallback() {\n                     @Override\n                     public void processResult(int rc, String path,\n                             Object ctx, String name) {\n                         if (rc != KeeperException.Code.OK.intValue()) {\n+                            LOG.error(\"Could not create node for ledger\",\n+                                      KeeperException.create(KeeperException.Code.get(rc), path));\n                             ledgerCb.operationComplete(rc, null);\n                         } else {\n-                            // update znode status\n-                            metadata.updateZnodeStatus(0);\n-                            ledgerCb.operationComplete(rc, name);\n+                            // update version\n+                            metadata.setVersion(new ZkVersion(0));\n+                            ledgerCb.operationComplete(rc, lid);\n                         }\n                     }\n                 };\n-                String ledgerPath = getLedgerPath(ledgerId);\n                 ZkUtils.createFullPathOptimistic(zk, ledgerPath, metadata.serialize(),\n                     Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, scb, null);\n                 // delete the znode for id generation\n@@ -350,21 +335,6 @@ public void processResult(int rc, String path, Object ctx,\n         }, null);\n     }\n \n-    @Override\n-    public void addActiveLedger(long ledgerId, boolean active) {\n-        activeLedgers.put(ledgerId, active);\n-    }\n-\n-    @Override\n-    public void removeActiveLedger(long ledgerId) {\n-        activeLedgers.remove(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean containsActiveLedger(long ledgerId) {\n-        return activeLedgers.containsKey(ledgerId);\n-    }\n-\n     @Override\n     public void garbageCollectLedgers(GarbageCollector gc) {\n         // create a snapshot before garbage collection"},{"sha":"51fc23be5eb12edcf55c60daacd1716260c8a997","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,72 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Hierarchical Ledger Manager Factory\n+ */\n+class HierarchicalLedgerManagerFactory extends LedgerManagerFactory {\n+\n+    public static final String NAME = \"hierarchical\";\n+    public static final int CUR_VERSION = 1;\n+\n+    AbstractConfiguration conf;\n+    ZooKeeper zk;\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public LedgerManagerFactory initialize(final AbstractConfiguration conf,\n+                                           final ZooKeeper zk,\n+                                           final int factoryVersion)\n+    throws IOException {\n+        if (CUR_VERSION != factoryVersion) {\n+            throw new IOException(\"Incompatible layout version found : \"\n+                                + factoryVersion);\n+        }\n+        this.conf = conf;\n+        this.zk = zk;\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitialize() throws IOException {\n+        // since zookeeper instance is passed from outside\n+        // we don't need to close it here\n+    }\n+\n+    @Override\n+    public LedgerManager newLedgerManager() {\n+        return new HierarchicalLedgerManager(conf, zk);\n+    }\n+\n+    @Override\n+    public ActiveLedgerManager newActiveLedgerManager() {\n+        return new HierarchicalLedgerManager(conf, zk);\n+    }\n+\n+}"},{"sha":"de3f017a7a4d6d49f67bd4f1780fca04172f87b9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","status":"modified","additions":52,"deletions":17,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -44,8 +44,10 @@\n \n     // Znode name to store layout information\n     public static final String LAYOUT_ZNODE = \"LAYOUT\";\n+    // version of compability layout version\n+    public static final int LAYOUT_MIN_COMPAT_VERSION = 1;\n     // version of ledger layout metadata\n-    public static final int LAYOUT_FORMAT_VERSION = 1;\n+    public static final int LAYOUT_FORMAT_VERSION = 2;\n \n     /**\n      * Read ledger layout from zookeeper\n@@ -77,8 +79,8 @@ public static LedgerLayout readLayout(final ZooKeeper zk, final String ledgersRo\n     static final String splitter = \":\";\n     static final String lSplitter = \"\\n\";\n \n-    // ledger manager class\n-    private String managerType;\n+    // ledger manager factory class\n+    private String managerFactoryCls;\n     // ledger manager version\n     private int managerVersion;\n \n@@ -88,26 +90,58 @@ public static LedgerLayout readLayout(final ZooKeeper zk, final String ledgersRo\n     /**\n      * Ledger Layout Constructor\n      *\n-     * @param type\n-     *          Ledger Manager Type\n+     * @param managerFactoryCls\n+     *          Ledger Manager Factory Class\n      * @param managerVersion\n      *          Ledger Manager Version\n      * @param layoutFormatVersion\n      *          Ledger Layout Format Version\n      */\n-    public LedgerLayout(String managerType, int managerVersion) {\n-        this.managerType = managerType;\n+    public LedgerLayout(String managerFactoryCls, int managerVersion) {\n+        this(managerFactoryCls, managerVersion, LAYOUT_FORMAT_VERSION);\n+    }\n+\n+    LedgerLayout(String managerFactoryCls, int managerVersion,\n+                 int layoutVersion) {\n+        this.managerFactoryCls = managerFactoryCls;\n         this.managerVersion = managerVersion;\n+        this.layoutFormatVersion = layoutVersion;\n     }\n \n+    /**\n+     * Get Ledger Manager Type\n+     *\n+     * @return ledger manager type\n+     * @deprecated replaced by {@link #getManagerFactoryClass()}\n+     */\n+    @Deprecated\n     public String getManagerType() {\n-        return this.managerType;\n+        // pre V2 layout store as manager type\n+        return this.managerFactoryCls;\n+    }\n+\n+    /**\n+     * Get ledger manager factory class\n+     *\n+     * @return ledger manager factory class\n+     */\n+    public String getManagerFactoryClass() {\n+        return this.managerFactoryCls;\n     }\n \n     public int getManagerVersion() {\n         return this.managerVersion;\n     }\n \n+    /**\n+     * Return layout format version\n+     *\n+     * @return layout format version\n+     */\n+    public int getLayoutFormatVersion() {\n+        return this.layoutFormatVersion;\n+    }\n+\n     /**\n      * Store the ledger layout into zookeeper\n      */\n@@ -126,7 +160,7 @@ public void store(final ZooKeeper zk, String ledgersRoot)\n     private byte[] serialize() throws IOException {\n         StringBuilder sb = new StringBuilder();\n         sb.append(layoutFormatVersion).append(lSplitter)\n-            .append(managerType).append(splitter).append(managerVersion);\n+            .append(managerFactoryCls).append(splitter).append(managerVersion);\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Serialized layout info: \" + sb.toString());\n@@ -157,7 +191,8 @@ private static LedgerLayout parseLayout(byte[] bytes) throws IOException {\n \n         try {\n             int layoutFormatVersion = new Integer(lines[0]);\n-            if (LAYOUT_FORMAT_VERSION != layoutFormatVersion) {\n+            if (LAYOUT_FORMAT_VERSION < layoutFormatVersion ||\n+                LAYOUT_MIN_COMPAT_VERSION > layoutFormatVersion) {\n                 throw new IOException(\"Metadata version not compatible. Expected \" \n                         + LAYOUT_FORMAT_VERSION + \", but got \" + layoutFormatVersion);\n             }\n@@ -170,11 +205,11 @@ private static LedgerLayout parseLayout(byte[] bytes) throws IOException {\n             if (parts.length != 2) {\n                 throw new IOException(\"Invalid Ledger Manager defined in layout : \" + layout);\n             }\n-            // ledger manager class\n-            String managerType = parts[0];\n+            // ledger manager factory class\n+            String managerFactoryCls = parts[0];\n             // ledger manager version\n             int managerVersion = new Integer(parts[1]);\n-            return new LedgerLayout(managerType, managerVersion);\n+            return new LedgerLayout(managerFactoryCls, managerVersion, layoutFormatVersion);\n         } catch (NumberFormatException e) {\n             throw new IOException(e);\n         }\n@@ -189,20 +224,20 @@ public boolean equals(Object obj) {\n             return false;\n         }\n         LedgerLayout other = (LedgerLayout)obj;\n-        return managerType.equals(other.managerType) &&\n-            managerVersion == other.managerVersion;\n+        return managerFactoryCls.equals(other.managerFactoryCls)\n+            && managerVersion == other.managerVersion;\n     }\n \n     @Override\n     public int hashCode() {\n-        return (managerType + managerVersion).hashCode();\n+        return (managerFactoryCls + managerVersion).hashCode();\n     }\n \n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(\"LV\").append(layoutFormatVersion).append(\":\")\n-            .append(\",Type:\").append(managerType).append(\":\")\n+            .append(\",Type:\").append(managerFactoryCls).append(\":\")\n             .append(managerVersion);\n         return sb.toString();\n     }"},{"sha":"30e2b83264438b43c83823ab3c1f0eca022c87cf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","status":"modified","additions":31,"deletions":76,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -18,52 +18,63 @@\n  * limitations under the License.\n  */\n \n-import java.io.IOException;\n+import java.io.Closeable;\n \n import org.apache.zookeeper.AsyncCallback;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n \n /**\n- * LedgerManager takes responsibility of ledger management\n+ * LedgerManager takes responsibility of ledger management in client side.\n  *\n  * <ul>\n  * <li>How to store ledger meta (e.g. in ZooKeeper or other key/value store)\n- * <li>How to manager active ledgers (so know how to do garbage collection)\n- * <li>How to garbage collect inactive/deleted ledgers\n  * </ul>\n  */\n-public interface LedgerManager {\n+public interface LedgerManager extends Closeable {\n \n     /**\n-     * Get the path that is used to store ledger metadata\n+     * Create a new ledger with provided metadata\n+     *\n+     * @param metadata\n+     *        Metadata provided when creating a new ledger\n+     * @param cb\n+     *        Callback when creating a new ledger.\n+     */\n+    public abstract void createLedger(LedgerMetadata metadata, GenericCallback<Long> cb);\n+\n+    /**\n+     * Delete a specified ledger by ledgerId.\n      *\n      * @param ledgerId\n-     *          Ledger ID\n-     * @return ledger node path\n+     *          Ledger Id\n+     * @param cb\n+     *          Callback when deleted ledger.\n      */\n-    public String getLedgerPath(long ledgerId);\n+    public abstract void deleteLedger(long ledgerId, GenericCallback<Void> cb);\n \n     /**\n-     * Get ledger id from its ledger path\n+     * Read ledger metadata of a specified ledger.\n      *\n-     * @param ledgerPath\n-     *          Ledger path to store metadata\n-     * @return ledger id\n-     * @throws IOException when the ledger path is invalid\n+     * @param ledgerId\n+     *          Ledger Id\n+     * @param readCb\n+     *          Callback when read ledger metadata.\n      */\n-    public long getLedgerId(String ledgerPath) throws IOException;\n+    public abstract void readLedgerMetadata(long ledgerId, GenericCallback<LedgerMetadata> readCb);\n \n     /**\n-     * Create a new zk ledger path with provided metadata\n+     * Write ledger metadata.\n      *\n-     * @param cb\n-     *        Callback when getting new zk ledger path to create.\n+     * @param ledgerId\n+     *          Ledger Id\n      * @param metadata\n-     *        Metadata provided when creating a new ledger\n+     *          Ledger Metadata to write\n+     * @param cb\n+     *          Callback when finished writing ledger metadata.\n      */\n-    public abstract void newLedgerPath(GenericCallback<String> cb, LedgerMetadata metadata);\n+    public abstract void writeLedgerMetadata(long ledgerId, LedgerMetadata metadata, GenericCallback<Void> cb);\n \n     /**\n      * Loop to process all ledgers.\n@@ -88,60 +99,4 @@\n      */\n     public void asyncProcessLedgers(Processor<Long> processor, AsyncCallback.VoidCallback finalCb,\n                                     Object context, int successRc, int failureRc);\n-\n-    /**\n-     * Add active ledger\n-     *\n-     * @param ledgerId\n-     *          Ledger ID\n-     * @param active\n-     *          Status of ledger\n-     */\n-    public void addActiveLedger(long ledgerId, boolean active);\n-\n-    /**\n-     * Remove active ledger\n-     *\n-     * @param ledgerId\n-     *          Ledger ID\n-     */\n-    public void removeActiveLedger(long ledgerId);\n-\n-    /**\n-     * Is Ledger ledgerId in active ledgers set\n-     *\n-     * @param ledgerId\n-     *          Ledger ID\n-     * @return true if the ledger is in active ledgers set, otherwise return false\n-     */\n-    public boolean containsActiveLedger(long ledgerId);\n-\n-    /**\n-     * Garbage Collector which handles ledger deletion in server side\n-     */\n-    public static interface GarbageCollector {\n-        /**\n-         * garbage collecting a specific ledger\n-         *\n-         * @param ledgerId\n-         *          Ledger ID to be garbage collected\n-         */\n-        public void gc(long ledgerId);\n-    }\n-\n-    /**\n-     * Garbage collecting all inactive/deleted ledgers\n-     * <p>\n-     * GarbageCollector#gc is triggered each time we found a ledger could be garbage collected.\n-     * After method finished, all those inactive ledgers should be garbage collected.\n-     * </p>\n-     *\n-     * @param gc garbage collector\n-     */\n-    public void garbageCollectLedgers(GarbageCollector gc);\n-\n-    /**\n-     * Close ledger manager\n-     */\n-    public void close();\n }"},{"sha":"86b0e2a2a2ded5148daf3d6a1b475e13ff925c14","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"modified","additions":143,"deletions":34,"changes":177,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -20,54 +20,127 @@\n \n import java.io.IOException;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n-import org.apache.zookeeper.ZooKeeper;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+public abstract class LedgerManagerFactory {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(LedgerManagerFactory.class);\n+    // v1 layout\n+    static final int V1 = 1;\n+\n+    /**\n+     * Return current factory version.\n+     *\n+     * @return current version used by factory.\n+     */\n+    public abstract int getCurrentVersion();\n+\n+    /**\n+     * Initialize a factory.\n+     *\n+     * @param conf\n+     *          Configuration object used to initialize factory\n+     * @param zk\n+     *          Available zookeeper handle for ledger manager to use.\n+     * @param factoryVersion\n+     *          What version used to initialize factory.\n+     * @return ledger manager factory instance\n+     * @throws IOException when fail to initialize the factory.\n+     */\n+    public abstract LedgerManagerFactory initialize(final AbstractConfiguration conf,\n+                                                    final ZooKeeper zk,\n+                                                    final int factoryVersion)\n+    throws IOException;\n+\n+    /**\n+     * Uninitialize the factory.\n+     *\n+     * @throws IOException when fail to uninitialize the factory.\n+     */\n+    public abstract void uninitialize() throws IOException;\n+\n+    /**\n+     * return ledger manager for client-side to manage ledger metadata.\n+     *\n+     * @return ledger manager\n+     * @see LedgerManager\n+     */\n+    public abstract LedgerManager newLedgerManager();\n \n-/**\n- * <code>LedgerManagerFactory</code> takes responsibility of creating new ledger manager.\n- */\n-public class LedgerManagerFactory {\n     /**\n-     * Create new Ledger Manager.\n+     * return active ledger manager for server side to manage active ledgers.\n+     *\n+     * @return active ledger manager\n+     * @see ActiveLedgerManager\n+     */\n+    public abstract ActiveLedgerManager newActiveLedgerManager();\n+\n+    /**\n+     * Create new Ledger Manager Factory.\n      *\n      * @param conf\n      *          Configuration Object.\n      * @param zk\n      *          ZooKeeper Client Handle, talk to zk to know which ledger manager is used.\n-     * @return new ledger manager\n+     * @return new ledger manager factory\n      * @throws IOException\n      */\n-    public static LedgerManager newLedgerManager(\n+    public static LedgerManagerFactory newLedgerManagerFactory(\n         final AbstractConfiguration conf, final ZooKeeper zk)\n             throws IOException, KeeperException, InterruptedException {\n-        String lmType = conf.getLedgerManagerType();\n+        Class<? extends LedgerManagerFactory> factoryClass;\n+        try {\n+            factoryClass = conf.getLedgerManagerFactoryClass();\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get ledger manager factory class from configuration : \", e);\n+        }\n         String ledgerRootPath = conf.getZkLedgersRootPath();\n-            \n+\n         if (null == ledgerRootPath || ledgerRootPath.length() == 0) {\n             throw new IOException(\"Empty Ledger Root Path.\");\n         }\n-        \n+\n         // if zk is null, return the default ledger manager\n         if (zk == null) {\n-            return new FlatLedgerManager(conf, null,\n-                    ledgerRootPath, FlatLedgerManager.CUR_VERSION);\n+            return new FlatLedgerManagerFactory()\n+                   .initialize(conf, null, FlatLedgerManagerFactory.CUR_VERSION);\n         }\n \n+        LedgerManagerFactory lmFactory;\n+\n         // check that the configured ledger manager is\n         // compatible with the existing layout\n         LedgerLayout layout = LedgerLayout.readLayout(zk, ledgerRootPath);\n         if (layout == null) { // no existing layout\n-            if (lmType == null \n-                || lmType.equals(FlatLedgerManager.NAME)) {\n-                layout = new LedgerLayout(FlatLedgerManager.NAME, \n-                                          FlatLedgerManager.CUR_VERSION);\n-            } else if (lmType.equals(HierarchicalLedgerManager.NAME)) {\n-                layout = new LedgerLayout(HierarchicalLedgerManager.NAME, \n-                                          HierarchicalLedgerManager.CUR_VERSION);\n-            } else {\n-                throw new IOException(\"Unknown ledger manager type \" + lmType);\n+            // use default ledger manager factory if no one provided\n+            if (factoryClass == null) {\n+                // for backward compatibility, check manager type\n+                String lmType = conf.getLedgerManagerType();\n+                if (lmType == null) {\n+                    factoryClass = FlatLedgerManagerFactory.class;\n+                } else {\n+                    if (FlatLedgerManagerFactory.NAME.equals(lmType)) {\n+                        factoryClass = FlatLedgerManagerFactory.class;\n+                    } else if (HierarchicalLedgerManagerFactory.NAME.equals(lmType)) {\n+                        factoryClass = HierarchicalLedgerManagerFactory.class;\n+                    } else {\n+                        throw new IOException(\"Unknown ledger manager type: \" + lmType);\n+                    }\n+                }\n+            }\n+\n+            try {\n+                lmFactory = ReflectionUtils.newInstance(factoryClass);\n+            } catch (Throwable t) {\n+                throw new IOException(\"Fail to instantiate ledger manager factory class : \" + factoryClass, t);\n             }\n+            layout = new LedgerLayout(factoryClass.getName(), lmFactory.getCurrentVersion());\n             try {\n                 layout.store(zk, ledgerRootPath);\n             } catch (KeeperException.NodeExistsException nee) {\n@@ -78,21 +151,57 @@ public static LedgerManager newLedgerManager(\n                             + \"layout \" + layout);\n                 }\n             }\n-        } else if (lmType != null && !layout.getManagerType().equals(lmType)) {\n-            throw new IOException(\"Configured layout \" + lmType\n-                    + \" does not match existing layout \" + layout.getManagerType());\n+            return lmFactory.initialize(conf, zk, lmFactory.getCurrentVersion());\n         }\n+        LOG.debug(\"read ledger layout {}\", layout);\n \n-        // create the ledger manager\n-        if (FlatLedgerManager.NAME.equals(layout.getManagerType())) {\n-            return new FlatLedgerManager(conf, zk, ledgerRootPath, \n-                                         layout.getManagerVersion());\n-        } else if (HierarchicalLedgerManager.NAME.equals(layout.getManagerType())) {\n-            return new HierarchicalLedgerManager(conf, zk, ledgerRootPath,\n-                                                 layout.getManagerVersion());\n-        } else {\n-            throw new IOException(\"Unknown ledger manager type: \" + lmType);\n+        // there is existing layout, we need to look into the layout.\n+        // handle pre V2 layout\n+        if (layout.getLayoutFormatVersion() <= V1) {\n+            // pre V2 layout we use type of ledger manager\n+            String lmType = conf.getLedgerManagerType();\n+            if (lmType != null && !layout.getManagerType().equals(lmType)) {\n+                throw new IOException(\"Configured layout \" + lmType\n+                                    + \" does not match existing layout \"  + layout.getManagerType());\n+            }\n+\n+            // create the ledger manager\n+            if (FlatLedgerManagerFactory.NAME.equals(layout.getManagerType())) {\n+                lmFactory = new FlatLedgerManagerFactory();\n+            } else if (HierarchicalLedgerManagerFactory.NAME.equals(layout.getManagerType())) {\n+                lmFactory = new HierarchicalLedgerManagerFactory();\n+            } else {\n+                throw new IOException(\"Unknown ledger manager type: \" + lmType);\n+            }\n+            return lmFactory.initialize(conf, zk, layout.getManagerVersion());\n+        }\n+\n+        // handle V2 layout case\n+        if (factoryClass != null &&\n+            !layout.getManagerFactoryClass().equals(factoryClass.getName())) {\n+\n+            throw new IOException(\"Configured layout \" + factoryClass.getName()\n+                                + \" does not match existing layout \"  + layout.getManagerFactoryClass());\n+        }\n+        if (factoryClass == null) {\n+            // no factory specified in configuration\n+            try {\n+                Class<?> theCls = Class.forName(layout.getManagerFactoryClass());\n+                if (!LedgerManagerFactory.class.isAssignableFrom(theCls)) {\n+                    throw new IOException(\"Wrong ledger manager factory \" + layout.getManagerFactoryClass());\n+                }\n+                factoryClass = theCls.asSubclass(LedgerManagerFactory.class);\n+            } catch (ClassNotFoundException cnfe) {\n+                throw new IOException(\"Failed to instantiate ledger manager factory \" + layout.getManagerFactoryClass());\n+            }\n+        }\n+        // instantiate a factory\n+        try {\n+            lmFactory = ReflectionUtils.newInstance(factoryClass);\n+        } catch (Throwable t) {\n+            throw new IOException(\"Fail to instantiate ledger manager factory class : \" + factoryClass, t);\n         }\n+        return lmFactory.initialize(conf, zk, layout.getManagerVersion());\n     }\n \n }"},{"sha":"1c98077bba8f1da597ee08fbc9e4b3045bdeafbc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,65 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Version.Occurred;\n+\n+public class ZkVersion implements Version {\n+    int znodeVersion;\n+\n+    public ZkVersion(int version) {\n+        znodeVersion = version;\n+    }\n+\n+    @Override\n+    public Occurred compare(Version v) {\n+        if (v == null) {\n+            return Occurred.AFTER;\n+        }\n+        if (!(v instanceof ZkVersion)) {\n+            throw new IllegalArgumentException(\"Invalid version type\");\n+        }\n+        ZkVersion zv = (ZkVersion)v;\n+        int res = znodeVersion - zv.znodeVersion;\n+        if (res == 0) {\n+            return Occurred.CONCURRENTLY;\n+        } else if (res < 0) {\n+            return Occurred.BEFORE;\n+        } else {\n+            return Occurred.AFTER;\n+        }\n+    }\n+\n+    public int getZnodeVersion() {\n+        return znodeVersion;\n+    }\n+\n+    public ZkVersion setZnodeVersion(int znodeVersion) {\n+        this.znodeVersion = znodeVersion;\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Integer.toString(znodeVersion, 10);\n+    }\n+}"},{"sha":"afcc5b2ce5a2fb0982d204875acab8b053e54df4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,129 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.configuration.ConfigurationException;\n+\n+/**\n+ * General Class Reflection Utils\n+ */\n+public class ReflectionUtils {\n+\n+    private static final Map<Class<?>, Constructor<?>> constructorCache =\n+            new ConcurrentHashMap<Class<?>, Constructor<?>>();\n+\n+    /**\n+     * Get the value of the <code>name</code> property as a <code>Class</code>.\n+     * If no such property is specified, then <code>defaultCls</code> is returned.\n+     *\n+     * @param conf\n+     *          Configuration Object.\n+     * @param name\n+     *          Class Property Name.\n+     * @param defaultCls\n+     *          Default Class to be returned.\n+     * @param classLoader\n+     *          Class Loader to load class.\n+     * @return property value as a <code>Class</code>, or <code>defaultCls</code>.\n+     * @throws ConfigurationException\n+     */\n+    public static Class<?> getClass(Configuration conf, String name,\n+                                    Class<?> defaultCls, ClassLoader classLoader)\n+            throws ConfigurationException {\n+        String valueStr = conf.getString(name);\n+        if (null == valueStr) {\n+            return defaultCls;\n+        }\n+        try {\n+            return Class.forName(valueStr, true, classLoader);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new ConfigurationException(cnfe);\n+        }\n+    }\n+\n+    /**\n+     * Get the value of the <code>name</code> property as a <code>Class</code> implementing\n+     * the interface specified by <code>xface</code>.\n+     *\n+     * If no such property is specified, then <code>defaultValue</code> is returned.\n+     *\n+     * An exception is thrown if the returned class does not implement the named interface.\n+     *\n+     * @param conf\n+     *          Configuration Object.\n+     * @param name\n+     *          Class Property Name.\n+     * @param defaultValue\n+     *          Default Class to be returned.\n+     * @param xface\n+     *          The interface implemented by the named class.\n+     * @param classLoader\n+     *          Class Loader to load class.\n+     * @return property value as a <code>Class</code>, or <code>defaultValue</code>.\n+     * @throws ConfigurationException\n+     */\n+    public static <U> Class<? extends U> getClass(Configuration conf,\n+                                                  String name, Class<? extends U> defaultValue,\n+                                                  Class<U> xface, ClassLoader classLoader)\n+        throws ConfigurationException {\n+        try {\n+            Class<?> theCls = getClass(conf, name, defaultValue, classLoader);\n+            if (null != theCls && !xface.isAssignableFrom(theCls)) {\n+                throw new ConfigurationException(theCls + \" not \" + xface.getName());\n+            } else if (null != theCls) {\n+                return theCls.asSubclass(xface);\n+            } else {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            throw new ConfigurationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Create an object for the given class.\n+     *\n+     * @param theCls\n+     *          class of which an object is created.\n+     * @return a new object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T newInstance(Class<T> theCls) {\n+        T result;\n+        try {\n+            Constructor<T> meth = (Constructor<T>) constructorCache.get(theCls);\n+            if (null == meth) {\n+                meth = theCls.getDeclaredConstructor();\n+                meth.setAccessible(true);\n+                constructorCache.put(theCls, meth);\n+            }\n+            result = meth.newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return result;\n+    }\n+}"},{"sha":"ccaa6918aca78a07b0a370875e983d0fcf512d96","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java","status":"renamed","additions":6,"deletions":17,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.meta;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,24 +18,15 @@\n  * under the License.\n  *\n  */\n-\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n-import org.apache.bookkeeper.test.LedgerDeleteTest;\n-\n-import org.junit.Before;\n+package org.apache.bookkeeper.versioning;\n \n /**\n- * Test ledger delete using HierarchicalLedgerManager\n+ * An interface that allows us to determine if a given version happened before or after another version.\n  */\n-public class HierarchicalLedgerDeleteTest extends LedgerDeleteTest {\n-\n-    @Before\n-    @Override\n-    public void setUp() throws Exception {\n-        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        super.setUp();\n+public interface Version {\n+    public enum Occurred {\n+        BEFORE, AFTER, CONCURRENTLY\n     }\n \n+    public Occurred compare(Version v);\n }","previous_filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java"},{"sha":"7e8f1c96f4e8081d37c44508c577ed339be6a933","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.versioning;\n+\n+public class Versioned<T> {\n+    T value;\n+    Version version;\n+\n+    public Versioned(T value, Version version) {\n+        this.value = value;\n+        this.version = version;\n+    }\n+\n+    public void setValue(T value) {\n+        this.value = value;\n+    }\n+\n+    public T getValue() {\n+        return value;\n+    }\n+\n+    public void setVersion(Version version) {\n+        this.version = version;\n+    }\n+\n+    public Version getVersion() {\n+        return version;\n+    }\n+}"},{"sha":"04eee2a68c0400d8be901eb23236e88926d23075","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -26,7 +26,7 @@\n \n import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.ActiveLedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.commons.io.FileUtils;\n import org.junit.After;\n@@ -44,7 +44,8 @@\n public class LedgerCacheTest extends TestCase {\n     static Logger LOG = LoggerFactory.getLogger(LedgerCacheTest.class);\n \n-    LedgerManager ledgerManager;\n+    ActiveLedgerManager activeLedgerManager;\n+    LedgerManagerFactory ledgerManagerFactory;\n     LedgerCache ledgerCache;\n     ServerConfiguration conf;\n     File txnDir, ledgerDir;\n@@ -66,19 +67,22 @@ public void setUp() throws Exception {\n         conf.setJournalDirName(txnDir.getPath());\n         conf.setLedgerDirNames(new String[] { ledgerDir.getPath() });\n \n-        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, null);\n+        ledgerManagerFactory =\n+            LedgerManagerFactory.newLedgerManagerFactory(conf, null);\n+        activeLedgerManager = ledgerManagerFactory.newActiveLedgerManager();\n     }\n \n     @Override\n     @After\n     public void tearDown() throws Exception {\n-        ledgerManager.close();\n+        activeLedgerManager.close();\n+        ledgerManagerFactory.uninitialize();\n         FileUtils.deleteDirectory(txnDir);\n         FileUtils.deleteDirectory(ledgerDir);\n     }\n \n     private void newLedgerCache() {\n-        ledgerCache = new LedgerCacheImpl(conf, ledgerManager);\n+        ledgerCache = new LedgerCacheImpl(conf, activeLedgerManager);\n     }\n \n     @Test"},{"sha":"202141f7b62397f2a5e12d369f16c608268998c7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":62,"deletions":34,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -21,7 +21,6 @@\n  *\n  */\n \n-import java.io.File;\n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n@@ -39,33 +38,29 @@\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n-import org.apache.bookkeeper.test.BaseTestCase;\n+import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n-import org.apache.bookkeeper.bookie.BookieException;\n-import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.KeeperException.Code;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n /**\n  * This class tests the bookie recovery admin functionality.\n  */\n-public class BookieRecoveryTest extends BaseTestCase {\n+public class BookieRecoveryTest extends MultiLedgerManagerMultiDigestTestCase {\n     static Logger LOG = LoggerFactory.getLogger(BookieRecoveryTest.class);\n \n     // Object used for synchronizing async method calls\n@@ -84,7 +79,7 @@ public SyncObject() {\n         @Override\n         public void recoverComplete(int rc, Object ctx) {\n             LOG.info(\"Recovered bookie operation completed with rc: \" + rc);\n-            success = rc == Code.OK.intValue();\n+            success = rc == BKException.Code.OK;\n             SyncObject sync = (SyncObject) ctx;\n             synchronized (sync) {\n                 sync.value = true;\n@@ -100,9 +95,13 @@ public void recoverComplete(int rc, Object ctx) {\n     BookKeeperAdmin bkAdmin;\n \n     // Constructor\n-    public BookieRecoveryTest(DigestType digestType) {\n+    public BookieRecoveryTest(String ledgerManagerFactory, DigestType digestType) {\n         super(3);\n         this.digestType = digestType;\n+        LOG.info(\"Using ledger manager \" + ledgerManagerFactory);\n+        // set ledger manager\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n     }\n \n     @Before\n@@ -135,8 +134,8 @@ public void tearDown() throws Exception {\n      *            Number of ledgers to create\n      * @return List of LedgerHandles for each of the ledgers created\n      */\n-    private List<LedgerHandle> createLedgers(int numLedgers) \n-            throws BKException, KeeperException, IOException, InterruptedException \n+    private List<LedgerHandle> createLedgers(int numLedgers)\n+            throws BKException, IOException, InterruptedException\n     {\n         return createLedgers(numLedgers, 3, 2);\n     }\n@@ -150,12 +149,12 @@ public void tearDown() throws Exception {\n      * @param quorum Quorum size for ledgers\n      * @return List of LedgerHandles for each of the ledgers created\n      */\n-    private List<LedgerHandle> createLedgers(int numLedgers, int ensemble, int quorum) \n-            throws BKException, KeeperException, IOException,\n+    private List<LedgerHandle> createLedgers(int numLedgers, int ensemble, int quorum)\n+            throws BKException, IOException,\n         InterruptedException {\n         List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n         for (int i = 0; i < numLedgers; i++) {\n-            lhs.add(bkc.createLedger(ensemble, quorum, \n+            lhs.add(bkc.createLedger(ensemble, quorum,\n                                      digestType, baseClientConf.getBookieRecoveryPasswd()));\n         }\n         return lhs;\n@@ -433,6 +432,7 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n             numSuccess = new AtomicLong(0);\n         }\n \n+        @Override\n         public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n             if (LOG.isDebugEnabled()) {\n                 InetSocketAddress addr = (InetSocketAddress)ctx;\n@@ -455,11 +455,7 @@ long await() throws InterruptedException {\n     }\n \n     private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws Exception {\n-        String znodepath = bkc.getLedgerManager().getLedgerPath(lh.getId());\n-        Stat stat = bkc.getZkHandle().exists(znodepath, false);\n-        assertNotNull(stat);\n-        byte[] mdbytes = bkc.getZkHandle().getData(znodepath, false, stat); \n-        LedgerMetadata md = LedgerMetadata.parseConfig(mdbytes, stat.getVersion()); \n+        LedgerMetadata md = getLedgerMetadata(lh);\n \n         Map<Long, ArrayList<InetSocketAddress>> ensembles = md.getEnsembles();\n \n@@ -471,7 +467,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n             ranges.put(keyList.get(i), keyList.get(i+1));\n         }\n         ranges.put(keyList.get(keyList.size()-1), untilEntry);\n-        \n+\n         for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : ensembles.entrySet()) {\n             int quorum = md.quorumSize;\n             long startEntryId = e.getKey();\n@@ -490,7 +486,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n             if (numSuccess < expectedSuccess) {\n                 LOG.warn(\"Fragment not fully replicated ledgerId = \" + lh.getId()\n                          + \" startEntryId = \" + startEntryId\n-                         + \" endEntryId = \" + endEntryId \n+                         + \" endEntryId = \" + endEntryId\n                          + \" expectedSuccess = \" + expectedSuccess\n                          + \" gotSuccess = \" + numSuccess);\n                 return false;\n@@ -499,19 +495,51 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n         return true;\n     }\n \n+    // Object used for synchronizing async method calls\n+    class SyncLedgerMetaObject {\n+        boolean value;\n+        int rc;\n+        LedgerMetadata meta;\n+\n+        public SyncLedgerMetaObject() {\n+            value = false;\n+            meta = null;\n+        }\n+    }\n+\n+    private LedgerMetadata getLedgerMetadata(LedgerHandle lh) throws Exception {\n+        final SyncLedgerMetaObject syncObj = new SyncLedgerMetaObject();\n+        bkc.getLedgerManager().readLedgerMetadata(lh.getId(), new GenericCallback<LedgerMetadata>() {\n+\n+            @Override\n+            public void operationComplete(int rc, LedgerMetadata result) {\n+                synchronized (syncObj) {\n+                    syncObj.rc = rc;\n+                    syncObj.meta = result;\n+                    syncObj.value = true;\n+                    syncObj.notify();\n+                }\n+            }\n+\n+        });\n+\n+        synchronized (syncObj) {\n+            while (syncObj.value == false) {\n+                syncObj.wait();\n+            }\n+        }\n+        assertEquals(BKException.Code.OK, syncObj.rc);\n+        return syncObj.meta;\n+    }\n+\n     private boolean findDupesInEnsembles(List<LedgerHandle> lhs) throws Exception {\n         long numDupes = 0;\n         for (LedgerHandle lh : lhs) {\n-            String znodepath = bkc.getLedgerManager().getLedgerPath(lh.getId());\n-            Stat stat = bkc.getZkHandle().exists(znodepath, false);\n-            assertNotNull(stat);\n-            byte[] mdbytes = bkc.getZkHandle().getData(znodepath, false, stat); \n-            LedgerMetadata md = LedgerMetadata.parseConfig(mdbytes, stat.getVersion()); \n-            \n+            LedgerMetadata md = getLedgerMetadata(lh);\n             for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : md.getEnsembles().entrySet()) {\n                 HashSet<InetSocketAddress> set = new HashSet<InetSocketAddress>();\n                 long fragment = e.getKey();\n-                \n+\n                 for (InetSocketAddress addr : e.getValue()) {\n                     if (set.contains(addr)) {\n                         LOG.error(\"Dupe \" + addr + \" found in ensemble for fragment \" + fragment\n@@ -696,25 +724,25 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n             // Create the ledgers\n             int numLedgers = 3;\n             List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n-            \n+\n             // Write the entries for the ledgers with dummy values.\n             int numMsgs = 100;\n             writeEntriestoLedgers(numMsgs, 0, lhs);\n-            \n+\n             // Shutdown the first bookie server\n             LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n             int removeIndex = r.nextInt(bs.size());\n             InetSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n             bs.get(removeIndex).shutdown();\n             bs.remove(removeIndex);\n-            \n+\n             // Startup three new bookie servers\n             startNewBookie();\n-            \n+\n             // Write some more entries for the ledgers so a new ensemble will be\n             // created for them.\n             writeEntriestoLedgers(numMsgs, numMsgs, lhs);\n-            \n+\n             // Call the async recover bookie method.\n             LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n                      + \") and replicate it to a random available one\");"},{"sha":"6f16f44a96655afae580483eb41cd8a4f9900558","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -124,7 +124,7 @@ public void run() {\n                         lastConfirmedEntry = lh.getLastAddConfirmed();\n                         lh.close();\n                         break;\n-                    } catch (BKException.ZKException zke) {\n+                    } catch (BKException.BKMetadataVersionException zke) {\n                         LOG.info(\"Contention with someone else recovering\");\n                     } catch (BKException.BKLedgerRecoveryException bkre) {\n                         LOG.info(\"Contention with someone else recovering\");\n@@ -295,7 +295,7 @@ public void testFencingInteractionWithBookieRecovery() throws Exception {\n         try {\n             writelh.close();\n             fail(\"Should fail trying to update metadata\");\n-        } catch (BKException.ZKException e) {\n+        } catch (BKException.BKMetadataVersionException e) {\n             // correct behaviour\n         }\n     }\n@@ -342,7 +342,7 @@ public void testFencingInteractionWithBookieRecovery2() throws Exception {\n         try {\n             writelh.close();\n             fail(\"Should fail trying to update metadata\");\n-        } catch (BKException.ZKException e) {\n+        } catch (BKException.BKMetadataVersionException e) {\n             // correct behaviour\n         }\n     }"},{"sha":"42c458f6d89816a60e1125b83db91f1521e2a8ad","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":22,"deletions":16,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -33,7 +33,7 @@\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n-import org.apache.bookkeeper.meta.LedgerManager.GarbageCollector;\n+import org.apache.bookkeeper.meta.ActiveLedgerManager.GarbageCollector;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -46,8 +46,8 @@\n public class GcLedgersTest extends LedgerManagerTestCase {\n     static final Logger LOG = LoggerFactory.getLogger(GcLedgersTest.class);\n \n-    public GcLedgersTest(String ledgerManagerType) {\n-        super(ledgerManagerType);\n+    public GcLedgersTest(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n+        super(lmFactoryCls);\n     }\n \n     /**\n@@ -56,16 +56,12 @@ public GcLedgersTest(String ledgerManagerType) {\n     private void createLedgers(int numLedgers, final Set<Long> createdLedgers) {\n         final AtomicInteger expected = new AtomicInteger(numLedgers);\n         for (int i=0; i<numLedgers; i++) {\n-            ledgerManager.newLedgerPath(new GenericCallback<String>() {\n+            getLedgerManager().createLedger(new LedgerMetadata(1, 1), new GenericCallback<Long>() {\n                 @Override\n-                public void operationComplete(int rc, String ledgerPath) {\n+                public void operationComplete(int rc, Long ledgerId) {\n                     if (rc == BKException.Code.OK) {\n-                        try {\n-                            long ledgerId = ledgerManager.getLedgerId(ledgerPath);\n-                            ledgerManager.addActiveLedger(ledgerId, true);\n-                            createdLedgers.add(ledgerId);\n-                        } catch (IOException ie) {\n-                        }\n+                        getActiveLedgerManager().addActiveLedger(ledgerId, true);\n+                        createdLedgers.add(ledgerId);\n                     }\n                     synchronized (expected) {\n                         int num = expected.decrementAndGet();\n@@ -74,7 +70,7 @@ public void operationComplete(int rc, String ledgerPath) {\n                         }\n                     }\n                 }\n-            }, new LedgerMetadata(1, 1));\n+            });\n         }\n         synchronized (expected) {\n             try {\n@@ -104,7 +100,17 @@ public void testGarbageCollectLedgers() throws Exception {\n         // random remove several ledgers\n         for (int i=0; i<numRemovedLedgers; i++) {\n             long ledgerId = tmpList.get(i);\n-            zkc.delete(ledgerManager.getLedgerPath(ledgerId), -1);\n+            getLedgerManager().deleteLedger(ledgerId, new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(int rc, Void result) {\n+                    synchronized (removedLedgers) {\n+                        removedLedgers.notify();\n+                    }\n+                }\n+            });\n+            synchronized (removedLedgers) {\n+                removedLedgers.wait();\n+            }\n             removedLedgers.add(ledgerId);\n             createdLedgers.remove(ledgerId);\n         }\n@@ -115,7 +121,7 @@ public void testGarbageCollectLedgers() throws Exception {\n         Thread gcThread = new Thread() {\n             @Override\n             public void run() {\n-                ledgerManager.garbageCollectLedgers(new GarbageCollector() {\n+                getActiveLedgerManager().garbageCollectLedgers(new GarbageCollector() {\n                     boolean paused = false;\n                     @Override\n                     public void gc(long ledgerId) {\n@@ -158,10 +164,10 @@ public void run() {\n \n         // test ledgers\n         for (Long ledger : removedLedgers) {\n-            assertFalse(ledgerManager.containsActiveLedger(ledger));\n+            assertFalse(getActiveLedgerManager().containsActiveLedger(ledger));\n         }\n         for (Long ledger : createdLedgers) {\n-            assertTrue(ledgerManager.containsActiveLedger(ledger));\n+            assertTrue(getActiveLedgerManager().containsActiveLedger(ledger));\n         }\n     }\n }"},{"sha":"24b3c12cfb338b083845eceeb64b341d13edab77","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java?ref=9472fae8739be41301847b1c8e31954f376997e6","patch":"@@ -1,47 +0,0 @@\n-package org.apache.bookkeeper.meta;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n-import org.apache.bookkeeper.test.AsyncLedgerOpsTest;\n-\n-import org.junit.Before;\n-\n-/**\n- * Test ledger delete using HierarchicalLedgerManager\n- */\n-public class HierarchicalAsyncLedgerOpsTest extends AsyncLedgerOpsTest {\n-\n-    public HierarchicalAsyncLedgerOpsTest(DigestType digestType) {\n-        super(digestType);\n-    }\n-\n-    @Before\n-    @Override\n-    public void setUp() throws Exception {\n-        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        super.setUp();\n-    }\n-\n-}"},{"sha":"70a4ea913a9c8c2c7d25742a0f7d461a29404a78","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java?ref=9472fae8739be41301847b1c8e31954f376997e6","patch":"@@ -1,47 +0,0 @@\n-package org.apache.bookkeeper.meta;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n-import org.apache.bookkeeper.test.BookieFailureTest;\n-\n-import org.junit.Before;\n-\n-/**\n- * Test Bookie Failure using HierarchicalLedgerManager\n- */\n-public class HierarchicalBookieFailureTest extends BookieFailureTest {\n-\n-    public HierarchicalBookieFailureTest(DigestType digestType) {\n-        super(digestType);\n-    }\n-\n-    @Before\n-    @Override\n-    public void setUp() throws Exception {\n-        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        super.setUp();\n-    }\n-\n-}"},{"sha":"7d97fd4f753f00508710fa05dda24e2af216b9fb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java?ref=9472fae8739be41301847b1c8e31954f376997e6","patch":"@@ -1,47 +0,0 @@\n-package org.apache.bookkeeper.meta;\n-\n-/*\n-*\n-* Licensed to the Apache Software Foundation (ASF) under one\n-* or more contributor license agreements.  See the NOTICE file\n-* distributed with this work for additional information\n-* regarding copyright ownership.  The ASF licenses this file\n-* to you under the Apache License, Version 2.0 (the\n-* \"License\"); you may not use this file except in compliance\n-* with the License.  You may obtain a copy of the License at\n-*\n-*   http://www.apache.org/licenses/LICENSE-2.0\n-*\n-* Unless required by applicable law or agreed to in writing,\n-* software distributed under the License is distributed on an\n-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-* KIND, either express or implied.  See the License for the\n-* specific language governing permissions and limitations\n-* under the License.\n-*\n-*/\n-\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n-import org.apache.bookkeeper.test.BookieReadWriteTest;\n-\n-import org.junit.Before;\n-\n-/**\n-* Test read / write using HierarchicalLedgerManager\n-*/\n-public class HierarchicalBookieReadWriteTest extends BookieReadWriteTest {\n-\n-   public HierarchicalBookieReadWriteTest(DigestType digestType) {\n-       super(digestType);\n-   }\n-\n-   @Before\n-   @Override\n-   public void setUp() throws Exception {\n-       baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-       baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-       super.setUp();\n-   }\n-\n-}\n\\ No newline at end of file"},{"sha":"d99156e9bb7628b9f8e9e2f578319bf19918e9be","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9472fae8739be41301847b1c8e31954f376997e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java?ref=9472fae8739be41301847b1c8e31954f376997e6","patch":"@@ -1,46 +0,0 @@\n-package org.apache.bookkeeper.meta;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.client.BookieRecoveryTest;\n-\n-import org.junit.Before;\n-\n-/**\n- * Test Bookie Recovery using HierarchicalLedgerManager\n- */\n-public class HierarchicalBookieRecoveryTest extends BookieRecoveryTest {\n-\n-    public HierarchicalBookieRecoveryTest(DigestType digestType) {\n-        super(digestType);\n-    }\n-\n-    @Before\n-    @Override\n-    public void setUp() throws Exception {\n-        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n-        super.setUp();\n-    }\n-\n-}"},{"sha":"736717fb945910aa44bdf8b409bd4d92dccab078","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","status":"modified","additions":21,"deletions":4,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -45,7 +45,7 @@ public LedgerLayoutTest() {\n     @Test\n     public void testLedgerLayout() throws Exception {\n         ClientConfiguration conf = new ClientConfiguration();\n-        conf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);\n         String ledgerRootPath = \"/testLedgerLayout\";\n \n         zkc.create(ledgerRootPath, new byte[0], \n@@ -83,8 +83,10 @@ private void writeLedgerLayout(\n     public void testBadVersionLedgerLayout() throws Exception {\n         ClientConfiguration conf = new ClientConfiguration();\n         // write bad version ledger layout\n-        writeLedgerLayout(conf.getZkLedgersRootPath(), FlatLedgerManager.NAME,\n-                FlatLedgerManager.CUR_VERSION, LedgerLayout.LAYOUT_FORMAT_VERSION + 1);\n+        writeLedgerLayout(conf.getZkLedgersRootPath(),\n+                          FlatLedgerManagerFactory.class.getName(),\n+                          FlatLedgerManagerFactory.CUR_VERSION,\n+                          LedgerLayout.LAYOUT_FORMAT_VERSION + 1);\n         \n         try {\n             LedgerLayout.readLayout(zkc, conf.getZkLedgersRootPath());\n@@ -120,7 +122,7 @@ public void testBaseLedgerManagerLayout() throws Exception {\n         // write bad format ledger layout\n         StringBuilder sb = new StringBuilder();\n         sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append(\"\\n\")\n-          .append(FlatLedgerManager.NAME);\n+          .append(FlatLedgerManagerFactory.class.getName());\n         zkc.create(ledgersLayout, sb.toString().getBytes(),\n                                  Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n \n@@ -131,4 +133,19 @@ public void testBaseLedgerManagerLayout() throws Exception {\n             assertTrue(\"Invalid exception\", ie.getMessage().contains(\"Invalid Ledger Manager\"));\n         }\n     }\n+\n+    @Test\n+    public void testReadV1LedgerManagerLayout() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        // write v1 ledger layout\n+        writeLedgerLayout(conf.getZkLedgersRootPath(),\n+                          FlatLedgerManagerFactory.NAME,\n+                          FlatLedgerManagerFactory.CUR_VERSION, 1);\n+\n+        LedgerLayout layout = LedgerLayout.readLayout(zkc, conf.getZkLedgersRootPath());\n+        assertNotNull(\"Should not be null\", layout);\n+        assertEquals(FlatLedgerManagerFactory.NAME, layout.getManagerType());\n+        assertEquals(FlatLedgerManagerFactory.CUR_VERSION, layout.getManagerVersion());\n+        assertEquals(1, layout.getLayoutFormatVersion());\n+    }\n }"},{"sha":"cd0b91fc077868de498f1f3f1ae3090f444632c2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":29,"deletions":7,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -45,32 +45,54 @@\n public abstract class LedgerManagerTestCase extends BookKeeperClusterTestCase {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerManagerTestCase.class);\n \n-    LedgerManager ledgerManager;\n+    LedgerManagerFactory ledgerManagerFactory;\n+    LedgerManager ledgerManager = null;\n+    ActiveLedgerManager activeLedgerManager = null;\n \n-    public LedgerManagerTestCase(String ledgerManagerType) {\n+    public LedgerManagerTestCase(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n         super(0);\n-        baseConf.setLedgerManagerType(ledgerManagerType);\n+        baseConf.setLedgerManagerFactoryClass(lmFactoryCls);\n+    }\n+\n+    public LedgerManager getLedgerManager() {\n+        if (null == ledgerManager) {\n+            ledgerManager = ledgerManagerFactory.newLedgerManager();\n+        }\n+        return ledgerManager;\n+    }\n+\n+    public ActiveLedgerManager getActiveLedgerManager() {\n+        if (null == activeLedgerManager) {\n+            activeLedgerManager = ledgerManagerFactory.newActiveLedgerManager();\n+        }\n+        return activeLedgerManager;\n     }\n \n     @Parameters\n     public static Collection<Object[]> configs() {\n         return Arrays.asList(new Object[][] {\n-            { FlatLedgerManager.NAME },\n-            { HierarchicalLedgerManager.NAME }\n+            { FlatLedgerManagerFactory.class },\n+            { HierarchicalLedgerManagerFactory.class }\n         });\n     }\n \n     @Before\n     @Override\n     public void setUp() throws Exception {\n         super.setUp();\n-        ledgerManager = LedgerManagerFactory.newLedgerManager(baseConf, zkc);\n+        ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(baseConf, zkc);\n     }\n \n     @After\n     @Override\n     public void tearDown() throws Exception {\n-        ledgerManager.close();\n+        if (null != ledgerManager) {\n+            ledgerManager.close();\n+        }\n+        if (null != activeLedgerManager) {\n+            activeLedgerManager.close();\n+        }\n+        ledgerManagerFactory.uninitialize();\n         super.tearDown();\n     }\n "},{"sha":"aaf18e9ca0b3880bf5bc684bc6db91a2e30bf2f7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","status":"modified","additions":77,"deletions":20,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -29,9 +29,9 @@\n import org.apache.zookeeper.ZooDefs.Ids;\n import java.util.concurrent.CyclicBarrier;\n import java.util.concurrent.CountDownLatch;\n-\n import java.util.List;\n import java.util.ArrayList;\n+import java.lang.reflect.Field;\n \n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.After;\n@@ -49,6 +49,19 @@ public TestLedgerManager() {\n         super(0);\n     }\n \n+    private void writeLedgerLayout(String ledgersRootPath,\n+                                   String managerType,\n+                                   int managerVersion, int layoutVersion)\n+        throws Exception {\n+        LedgerLayout layout = new LedgerLayout(managerType, managerVersion);\n+\n+        Field f = LedgerLayout.class.getDeclaredField(\"layoutFormatVersion\");\n+        f.setAccessible(true);\n+        f.set(layout, layoutVersion);\n+\n+        layout.store(zkc, ledgersRootPath);\n+    }\n+\n     /** \n      * Test bad client configuration\n      */\n@@ -62,14 +75,15 @@ public void testBadConf() throws Exception {\n                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n         conf.setZkLedgersRootPath(root0);\n \n-        LedgerManager m = LedgerManagerFactory.newLedgerManager(conf, zkc);\n+        LedgerManagerFactory m = LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n         assertTrue(\"Ledger manager is unexpected type\", \n-                   (m instanceof FlatLedgerManager));\n+                   (m instanceof FlatLedgerManagerFactory));\n+        m.uninitialize();\n \n         // mismatching conf\n-        conf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);\n         try {\n-            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n             fail(\"Shouldn't reach here\");\n         } catch (Exception e) {\n             assertTrue(\"Invalid exception\", \n@@ -82,13 +96,53 @@ public void testBadConf() throws Exception {\n                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n         conf.setZkLedgersRootPath(root1);\n \n-        conf.setLedgerManagerType(\"DoesNotExist\");\n+        conf.setLedgerManagerFactoryClassName(\"DoesNotExist\");\n+        try {\n+            LedgerManagerFactory f = LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n+            fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            assertTrue(\"Invalid exception\",\n+                    e.getMessage().contains(\"Failed to get ledger manager factory class from configuration\"));\n+        }\n+    }\n+\n+    /**\n+     * Test bad client configuration\n+     */\n+    @Test\n+    public void testBadConfV1() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+\n+        String root0 = \"/goodconf0\";\n+        zkc.create(root0, new byte[0],\n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        conf.setZkLedgersRootPath(root0);\n+        // write v1 layout\n+        writeLedgerLayout(root0, FlatLedgerManagerFactory.NAME,\n+                          FlatLedgerManagerFactory.CUR_VERSION, 1);\n+\n+        conf.setLedgerManagerFactoryClass(FlatLedgerManagerFactory.class);\n+\n+        LedgerManagerFactory m = LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n+        assertTrue(\"Ledger manager is unexpected type\",\n+                   (m instanceof FlatLedgerManagerFactory));\n+        m.uninitialize();\n+\n+        // v2 setting doesn't effect v1\n+        conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);\n+        m = LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n+        assertTrue(\"Ledger manager is unexpected type\",\n+                   (m instanceof FlatLedgerManagerFactory));\n+        m.uninitialize();\n+\n+        // mismatching conf\n+        conf.setLedgerManagerType(HierarchicalLedgerManagerFactory.NAME);\n         try {\n-            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n             fail(\"Shouldn't reach here\");\n         } catch (Exception e) {\n             assertTrue(\"Invalid exception\", \n-                    e.getMessage().contains(\"Unknown ledger manager type \"));\n+                       e.getMessage().contains(\"does not match existing layout\"));\n         }\n     }\n \n@@ -109,11 +163,11 @@ public void testBadZkContents() throws Exception {\n                          0xdeadbeef).store(zkc, root0);\n         \n         try {\n-            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n             fail(\"Shouldn't reach here\");\n         } catch (Exception e) {\n             assertTrue(\"Invalid exception\", \n-                    e.getMessage().contains(\"Unknown ledger manager type\"));\n+                    e.getMessage().contains(\"Failed to instantiate ledger manager factory\"));\n         }\n \n         // bad version in zookeeper\n@@ -122,27 +176,28 @@ public void testBadZkContents() throws Exception {\n                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n         conf.setZkLedgersRootPath(root1);\n         \n-        new LedgerLayout(FlatLedgerManager.NAME,\n+        new LedgerLayout(FlatLedgerManagerFactory.class.getName(),\n                          0xdeadbeef).store(zkc, root1);\n         \n         try {\n-            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n             fail(\"Shouldn't reach here\");\n         } catch (Exception e) {\n+            System.out.println(e.getMessage());\n             assertTrue(\"Invalid exception\", \n                     e.getMessage().contains(\"Incompatible layout version found\"));\n         }\n     }\n \n     private static class CreateLMThread extends Thread {\n         private boolean success = false;\n-        private final String type;\n+        private final String factoryCls;\n         private final String root;\n         private final CyclicBarrier barrier;\n         private ZooKeeper zkc;\n         \n-        CreateLMThread(String root, String type, CyclicBarrier barrier) throws Exception {\n-            this.type = type;\n+        CreateLMThread(String root, String factoryCls, CyclicBarrier barrier) throws Exception {\n+            this.factoryCls = factoryCls;\n             this.barrier = barrier;\n             this.root = root;\n             final CountDownLatch latch = new CountDownLatch(1);\n@@ -156,11 +211,13 @@ public void process(WatchedEvent event) {\n \n         public void run() {\n             ClientConfiguration conf = new ClientConfiguration();\n-            conf.setLedgerManagerType(type);\n+            conf.setLedgerManagerFactoryClassName(factoryCls);\n \n             try {\n                 barrier.await();\n-                LedgerManagerFactory.newLedgerManager(conf, zkc);\n+                LedgerManagerFactory factory =\n+                    LedgerManagerFactory.newLedgerManagerFactory(conf, zkc);\n+                factory.uninitialize();\n                 \n                 success = true;\n             } catch (Exception e) {\n@@ -191,7 +248,7 @@ public void testConcurrent1() throws Exception {\n         CyclicBarrier barrier = new CyclicBarrier(numThreads+1);\n         List<CreateLMThread> threads = new ArrayList<CreateLMThread>(numThreads);\n         for (int i = 0; i < numThreads; i++) {\n-            CreateLMThread t = new CreateLMThread(root0, FlatLedgerManager.NAME, barrier);\n+            CreateLMThread t = new CreateLMThread(root0, FlatLedgerManagerFactory.class.getName(), barrier);\n             t.start();\n             threads.add(t);\n         }\n@@ -220,14 +277,14 @@ public void testConcurrent2() throws Exception {\n         CyclicBarrier barrier = new CyclicBarrier(numThreadsEach*2+1);\n         List<CreateLMThread> threadsA = new ArrayList<CreateLMThread>(numThreadsEach);\n         for (int i = 0; i < numThreadsEach; i++) {\n-            CreateLMThread t = new CreateLMThread(root0, FlatLedgerManager.NAME, barrier);\n+            CreateLMThread t = new CreateLMThread(root0, FlatLedgerManagerFactory.class.getName(), barrier);\n             t.start();\n             threadsA.add(t);\n         }\n         List<CreateLMThread> threadsB = new ArrayList<CreateLMThread>(numThreadsEach);\n         for (int i = 0; i < numThreadsEach; i++) {\n             CreateLMThread t = new CreateLMThread(root0, \n-                    HierarchicalLedgerManager.NAME, barrier);\n+                    HierarchicalLedgerManagerFactory.class.getName(), barrier);\n             t.start();\n             threadsB.add(t);\n         }"},{"sha":"b099abbcb46ebde55696bddfb0bc2f160d8a7770","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,59 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Version.Occurred;\n+\n+public class TestZkVersion {\n+\n+    @Test\n+    public void testNullZkVersion() {\n+        ZkVersion zkVersion = new ZkVersion(99);\n+        Assert.assertEquals(Version.Occurred.AFTER, zkVersion.compare(null));\n+    }\n+\n+    @Test\n+    public void testInvalidVersion() {\n+        ZkVersion zkVersion = new ZkVersion(99);\n+        try {\n+            zkVersion.compare(new Version() {\n+                @Override\n+                public Occurred compare(Version v) {\n+                    return Occurred.AFTER;\n+                }\n+            });\n+            Assert.fail(\"Should not reach here!\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+    }\n+\n+    @Test\n+    public void testCompare() {\n+        ZkVersion zv = new ZkVersion(99);\n+        Assert.assertEquals(Occurred.AFTER, zv.compare(new ZkVersion(98)));\n+        Assert.assertEquals(Occurred.BEFORE, zv.compare(new ZkVersion(100)));\n+        Assert.assertEquals(Occurred.CONCURRENTLY, zv.compare(new ZkVersion(99)));\n+    }\n+}"},{"sha":"d6a3591760bdcae3f3ffe266f614b17c1156f5d2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -24,8 +24,6 @@\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n import java.util.Enumeration;\n import java.util.Random;\n import java.util.Set;\n@@ -43,31 +41,28 @@\n import org.slf4j.LoggerFactory;\n import org.junit.Before;\n import org.junit.Test;\n-import org.junit.runners.Parameterized.Parameters;\n \n /**\n  * This test tests read and write, synchronous and asynchronous, strings and\n  * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n  * and three BookKeepers.\n  *\n  */\n-public class AsyncLedgerOpsTest extends BaseTestCase implements AddCallback, ReadCallback, CreateCallback,\n+public class AsyncLedgerOpsTest extends MultiLedgerManagerMultiDigestTestCase\n+    implements AddCallback, ReadCallback, CreateCallback,\n     CloseCallback, OpenCallback {\n-    static Logger LOG = LoggerFactory.getLogger(BookieClientTest.class);\n+    static Logger LOG = LoggerFactory.getLogger(AsyncLedgerOpsTest.class);\n \n     DigestType digestType;\n \n-    public AsyncLedgerOpsTest(DigestType digestType) {\n+    public AsyncLedgerOpsTest(String ledgerManagerFactory, DigestType digestType) {\n         super(3);\n         this.digestType = digestType;\n+        // set ledger manager type\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n     }\n \n-    @Parameters\n-    public static Collection<Object[]> configs() {\n-        return Arrays.asList(new Object[][] { {DigestType.MAC }, {DigestType.CRC32}});\n-    }\n-\n-\n     byte[] ledgerPassword = \"aaa\".getBytes();\n     LedgerHandle lh, lh2;\n     long ledgerId;\n@@ -199,6 +194,7 @@ public void testAsyncCreateClose() throws IOException, BKException {\n \n     }\n \n+    @Override\n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         SyncObj x = (SyncObj) ctx;\n         synchronized (x) {\n@@ -207,6 +203,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         }\n     }\n \n+    @Override\n     public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n         ls = seq;\n         synchronized (sync) {\n@@ -216,6 +213,7 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n \n     }\n \n+    @Override\n     public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n         synchronized (ctx) {\n             ControlObj cobj = (ControlObj) ctx;\n@@ -224,6 +222,7 @@ public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n         }\n     }\n \n+    @Override\n     public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n         synchronized (ctx) {\n             ControlObj cobj = (ControlObj) ctx;\n@@ -232,6 +231,7 @@ public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n         }\n     }\n \n+    @Override\n     public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n         synchronized (ctx) {\n             ControlObj cobj = (ControlObj) ctx;"},{"sha":"ddc920cd12fceb06fdd14a868c246a7ff51a1db8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -230,6 +230,7 @@ public void sleepBookie(InetSocketAddress addr, final int seconds,\n         for (final Thread t : allthreads) {\n             if (t.getName().equals(name)) {\n                 Thread sleeper = new Thread() {\n+                    @Override\n                     public void run() {\n                         try {\n                             t.suspend();"},{"sha":"f55336f6ec9b0e38af73ef7dce8bd992447a9cc6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"modified","additions":8,"deletions":6,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -21,15 +21,13 @@\n  *\n  */\n \n-import java.io.File;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.Random;\n import java.util.Set;\n \n-import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperTestClient;\n@@ -41,8 +39,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n import org.junit.Before;\n import org.junit.Test;\n \n@@ -53,7 +49,8 @@\n  *\n  */\n \n-public class BookieFailureTest extends BaseTestCase implements AddCallback, ReadCallback {\n+public class BookieFailureTest extends MultiLedgerManagerMultiDigestTestCase\n+    implements AddCallback, ReadCallback {\n \n     // Depending on the taste, select the amount of logging\n     // by decommenting one of the two lines below\n@@ -87,9 +84,12 @@ public SyncObj() {\n         }\n     }\n \n-    public BookieFailureTest(DigestType digestType) {\n+    public BookieFailureTest(String ledgerManagerFactory, DigestType digestType) {\n         super(4);\n         this.digestType = digestType;\n+        // set ledger manager\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n     }\n \n     /**\n@@ -244,6 +244,7 @@ void auxTestReadWriteAsyncSingleClient(BookieServer bs) throws IOException {\n \n     }\n \n+    @Override\n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if (rc != 0)\n             fail(\"Failed to write entry: \" + entryId);\n@@ -254,6 +255,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         }\n     }\n \n+    @Override\n     public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n         if (rc != 0)\n             fail(\"Failed to write entry\");"},{"sha":"dc5eefa024a5d6dedc144ed7e3ee8f4de7d42d69","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":33,"deletions":25,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -48,7 +48,6 @@\n import org.apache.bookkeeper.streaming.LedgerOutputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.junit.Assert;\n@@ -62,7 +61,7 @@\n  *\n  */\n \n-public class BookieReadWriteTest extends BaseTestCase\n+public class BookieReadWriteTest extends MultiLedgerManagerMultiDigestTestCase\n     implements AddCallback, ReadCallback, ReadLastConfirmedCallback {\n \n     // Depending on the taste, select the amount of logging\n@@ -84,9 +83,12 @@\n \n     DigestType digestType;\n \n-    public BookieReadWriteTest(DigestType digestType) {\n+    public BookieReadWriteTest(String ledgerManagerFactory, DigestType digestType) {\n         super(3);\n         this.digestType = digestType;\n+        // set ledger manager\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n     }\n     // Synchronization\n     SyncObj sync;\n@@ -105,7 +107,7 @@ public SyncObj() {\n     }\n \n     @Test\n-    public void testOpenException() throws KeeperException, IOException, InterruptedException {\n+    public void testOpenException() throws IOException, InterruptedException {\n         try {\n             lh = bkc.openLedger(0, digestType, ledgerPassword);\n             fail(\"Haven't thrown exception\");\n@@ -117,10 +119,10 @@ public void testOpenException() throws KeeperException, IOException, Interrupted\n     /**\n      * test the streaming api for reading and writing\n      *\n-     * @throws {@link IOException}, {@link KeeperException}\n+     * @throws {@link IOException}\n      */\n     @Test\n-    public void testStreamingClients() throws IOException, KeeperException, BKException, InterruptedException {\n+    public void testStreamingClients() throws IOException, BKException, InterruptedException {\n         lh = bkc.createLedger(digestType, ledgerPassword);\n         // write a string so that we cna\n         // create a buffer of a single bytes\n@@ -205,7 +207,7 @@ public void testReadWriteAsyncSingleClient() throws IOException {\n             assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n \n             // read entries\n-            lh.asyncReadEntries(0, numEntriesToWrite - 1, this, (Object) sync);\n+            lh.asyncReadEntries(0, numEntriesToWrite - 1, this, sync);\n \n             synchronized (sync) {\n                 while (sync.value == false) {\n@@ -319,7 +321,7 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n                        lh.getLastAddConfirmed() == (numEntries - 1));\n \n             // read entries\n-            lh.asyncReadEntries(0, numEntries - 1, this, (Object) sync);\n+            lh.asyncReadEntries(0, numEntries - 1, this, sync);\n \n             synchronized (sync) {\n                 while (sync.value == false) {\n@@ -378,6 +380,7 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n             this.throttle = threshold;\n         }\n \n+        @Override\n         public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n             if(rc != BKException.Code.OK) {\n                 fail(\"Return code is not OK: \" + rc);\n@@ -478,7 +481,7 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n             // read entries\n             sync.counter = 0;\n             for (int i = 0; i < numEntriesToWrite; i+=throttle) {\n-                lh.asyncReadEntries(i, i + throttle - 1, tcb, (Object) sync);\n+                lh.asyncReadEntries(i, i + throttle - 1, tcb, sync);\n                 int testValue = getAvailablePermits(lh);\n                 assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n             }\n@@ -814,7 +817,7 @@ public void testShutdown() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n+\n     @Test\n     public void testReadFromOpenLedger() throws IOException {\n         try {\n@@ -904,7 +907,7 @@ public void testReadFromOpenLedger() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n+\n     @Test\n     public void testReadFromOpenLedgerOpenOnce() throws Exception {\n         try {\n@@ -918,7 +921,7 @@ public void testReadFromOpenLedgerOpenOnce() throws Exception {\n                 ByteBuffer entry = ByteBuffer.allocate(4);\n                 entry.putInt(rng.nextInt(maxInt));\n                 entry.position(0);\n-                \n+\n                 entries.add(entry.array());\n                 entriesSize.add(entry.array().length);\n                 lh.addEntry(entry.array());\n@@ -927,7 +930,7 @@ public void testReadFromOpenLedgerOpenOnce() throws Exception {\n                     // less than written\n                     // and it just can read until (i-1)\n                     int toRead = i - 1;\n-                    \n+\n                     long readLastConfirmed = lhOpen.readLastConfirmed();\n                     assertTrue(readLastConfirmed != 0);\n                     Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n@@ -945,12 +948,12 @@ public void testReadFromOpenLedgerOpenOnce() throws Exception {\n                         LOG.error(\"Unexpected exception\", ex);\n                         fail(\"Unexpected exception\");\n                     }\n-                    \n+\n                 }\n             }\n             long last = lh.readLastConfirmed();\n             assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n-    \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n@@ -962,9 +965,9 @@ public void testReadFromOpenLedgerOpenOnce() throws Exception {\n         } catch (InterruptedException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to interruption\");\n-        } \n+        }\n     }\n-    \n+\n     @Test\n     public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n         try {\n@@ -974,23 +977,23 @@ public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n             LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n-            \n+\n             /*\n              * We haven't written anything, so it should be empty.\n              */\n             LOG.debug(\"Checking that it is empty\");\n             long readLastConfirmed = lhOpen.readLastConfirmed();\n             assertTrue(\"Last confirmed has the wrong value\",\n                        readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);\n-            \n+\n             /*\n              * Writing one entry.\n              */\n             LOG.debug(\"Going to write one entry\");\n             ByteBuffer entry = ByteBuffer.allocate(4);\n             entry.putInt(rng.nextInt(maxInt));\n             entry.position(0);\n-            \n+\n             entries.add(entry.array());\n             entriesSize.add(entry.array().length);\n             lh.addEntry(entry.array());\n@@ -1004,21 +1007,21 @@ public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n             assertTrue(readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);\n \n             /*\n-             * Adding one more, and this time we should expect to \n+             * Adding one more, and this time we should expect to\n              * see one entry.\n              */\n             entry = ByteBuffer.allocate(4);\n             entry.putInt(rng.nextInt(maxInt));\n             entry.position(0);\n-            \n+\n             entries.add(entry.array());\n             entriesSize.add(entry.array().length);\n             lh.addEntry(entry.array());\n \n             LOG.info(\"Checking that it has an entry\");\n             readLastConfirmed = lhOpen.readLastConfirmed();\n             assertTrue(readLastConfirmed == 0L);\n-                        \n+\n             // close ledger\n             lh.close();\n             // close read only ledger should not change metadata\n@@ -1029,9 +1032,9 @@ public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n         } catch (InterruptedException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to interruption\");\n-        } \n+        }\n     }\n-    \n+\n \n     @Test\n     public void testLastConfirmedAdd() throws IOException {\n@@ -1101,6 +1104,7 @@ public void testLastConfirmedAdd() throws IOException {\n     }\n \n \n+    @Override\n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n \n@@ -1112,6 +1116,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         }\n     }\n \n+    @Override\n     public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n         if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n \n@@ -1123,6 +1128,7 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         }\n     }\n \n+    @Override\n     public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n         SyncObj sync = (SyncObj) ctx;\n \n@@ -1132,6 +1138,7 @@ public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n         }\n     }\n \n+    @Override\n     @Before\n     public void setUp() throws Exception {\n         super.setUp();\n@@ -1160,6 +1167,7 @@ protected boolean cleanUpDir(File dir) {\n \n     /* User for testing purposes, void */\n     class emptyWatcher implements Watcher {\n+        @Override\n         public void process(WatchedEvent event) {\n         }\n     }"},{"sha":"6abd5660dc34b3647ad72b4e153043086537ce72","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -25,7 +25,6 @@\n \n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.proto.BookieServer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.junit.Before;\n@@ -35,13 +34,17 @@\n  * This class tests the ledger delete functionality both from the BookKeeper\n  * client and the server side.\n  */\n-public class LedgerDeleteTest extends BookKeeperClusterTestCase {\n+public class LedgerDeleteTest extends MultiLedgerManagerTestCase {\n     static Logger LOG = LoggerFactory.getLogger(LedgerDeleteTest.class);\n     DigestType digestType;\n \n-    public LedgerDeleteTest() {\n+    public LedgerDeleteTest(String ledgerManagerFactory) {\n         super(3);\n+        LOG.info(\"Running test case using ledger manager : \" + ledgerManagerFactory);\n         this.digestType = DigestType.CRC32;\n+        // set ledger manager name\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n     }\n \n     @Before"},{"sha":"9630d467a6a70501f45d57aa861a15de8af447fc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,63 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Running test case using different ledger managers.\n+ */\n+@RunWith(Parameterized.class)\n+public abstract class MultiLedgerManagerMultiDigestTestCase extends BookKeeperClusterTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(MultiLedgerManagerMultiDigestTestCase.class);\n+\n+    public MultiLedgerManagerMultiDigestTestCase(int numBookies) {\n+        super(numBookies);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        String[] ledgerManagers = {\n+            \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n+        };\n+        ArrayList<Object[]> cfgs = new ArrayList<Object[]>(ledgerManagers.length);\n+        DigestType[] digestTypes = new DigestType[] { DigestType.MAC, DigestType.CRC32 };\n+        for (String lm : ledgerManagers) {\n+            for (DigestType type : digestTypes) {\n+                cfgs.add(new Object[] { lm, type });\n+            }\n+        }\n+        return cfgs;\n+    }\n+\n+}"},{"sha":"dd3450c4e8d70c86fbd92feed3a46a45be4bac4c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/297eb745440443eea1a8217c89299abf8d18fc3f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java?ref=297eb745440443eea1a8217c89299abf8d18fc3f","patch":"@@ -0,0 +1,55 @@\n+package org.apache.bookkeeper.test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+\n+/**\n+ * Test Case run over different ledger manager.\n+ */\n+@RunWith(Parameterized.class)\n+public abstract class MultiLedgerManagerTestCase extends BookKeeperClusterTestCase {\n+\n+    public MultiLedgerManagerTestCase(int numBookies) {\n+        super(numBookies);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        String[] ledgerManagers = new String[] {\n+            \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n+        };\n+        ArrayList<Object[]> cfgs = new ArrayList<Object[]>(ledgerManagers.length);\n+        for (String lm : ledgerManagers) {\n+            cfgs.add(new Object[] { lm });\n+        }\n+        return cfgs;\n+    }\n+}"}]}

