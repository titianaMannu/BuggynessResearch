{"sha":"29a472598083e522645f918ec602dd91d800f0d5","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyOWE0NzI1OTgwODNlNTIyNjQ1ZjkxOGVjNjAyZGQ5MWQ4MDBmMGQ1","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-13T10:19:17Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-13T10:19:17Z"},"message":"BOOKKEEPER-162: LedgerHandle.readLastConfirmed does not work (fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1243462 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7d7b35a8f3edaf9b21b1c5b1b2cc1043664b13ab","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7d7b35a8f3edaf9b21b1c5b1b2cc1043664b13ab"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/29a472598083e522645f918ec602dd91d800f0d5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/29a472598083e522645f918ec602dd91d800f0d5","html_url":"https://github.com/apache/bookkeeper/commit/29a472598083e522645f918ec602dd91d800f0d5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/29a472598083e522645f918ec602dd91d800f0d5/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"c65d6ada34215ee3a5466c495d565d745857c435","url":"https://api.github.com/repos/apache/bookkeeper/commits/c65d6ada34215ee3a5466c495d565d745857c435","html_url":"https://github.com/apache/bookkeeper/commit/c65d6ada34215ee3a5466c495d565d745857c435"}],"stats":{"total":185,"additions":176,"deletions":9},"files":[{"sha":"9f0c576fb3cf22e5b95f2b0eacd8c42ff7dea33f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -32,6 +32,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-156: BookieJournalRollingTest failing (Sijie Guo via ivank)\n \n+\tBOOKKEEPER-162: LedgerHandle.readLastConfirmed does not work (fpj)\n+\n       hedwig-server/\n       \n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)"},{"sha":"d6ade83e6e7f96addc0950354008e97ddfbbdb5e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":35,"deletions":5,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -55,7 +55,6 @@\n  */\n public class LedgerHandle {\n     final static Logger LOG = LoggerFactory.getLogger(LedgerHandle.class);\n-    final static long LAST_ADD_CONFIRMED = -1;\n \n     final byte[] ledgerKey;\n     LedgerMetadata metadata;\n@@ -107,7 +106,14 @@ public long getId() {\n     }\n \n     /**\n-     * Get the last confirmed entry id on this ledger\n+     * Get the last confirmed entry id on this ledger. It reads\n+     * the local state of the ledger handle, which is different\n+     * from the readLastConfirmed call. In the case the ledger\n+     * is not closed and the client is a reader, it is necessary\n+     * to call readLastConfirmed to obtain an estimate of the\n+     * last add operation that has been confirmed.  \n+     * \n+     * @see #readLastConfirmed()\n      *\n      * @return the last confirmed entry id\n      */\n@@ -478,7 +484,15 @@ public void safeRun() {\n     }\n \n     /**\n-     * Obtains last confirmed write from a quorum of bookies.\n+     * Obtains asynchronously the last confirmed write from a quorum of bookies. This \n+     * call obtains the the last add confirmed each bookie has received for this ledger\n+     * and returns the maximum. If the ledger has been closed, the value returned by this\n+     * call may not correspond to the id of the last entry of the ledger, since it reads\n+     * the hint of bookies. Consequently, in the case the ledger has been closed, it may \n+     * return a different value than getLastAddConfirmed, which returns the local value \n+     * of the ledger handle.\n+     * \n+     * @see #getLastAddConfirmed()\n      *\n      * @param cb\n      * @param ctx\n@@ -497,7 +511,7 @@ public void asyncReadLastConfirmed(ReadLastConfirmedCallback cb, Object ctx) {\n         int rc;\n \n         LastConfirmedCtx() {\n-            this.response = -1;\n+            this.response = -10;\n         }\n \n         void setLastConfirmed(long lastConfirmed) {\n@@ -517,10 +531,26 @@ int getRC() {\n         }\n \n         boolean ready() {\n-            return (this.response != -1);\n+            return (this.response != -10);\n         }\n     }\n \n+    /**\n+     * Obtains synchronously the last confirmed write from a quorum of bookies. This call\n+     * obtains the the last add confirmed each bookie has received for this ledger\n+     * and returns the maximum. If the ledger has been closed, the value returned by this\n+     * call may not correspond to the id of the last entry of the ledger, since it reads\n+     * the hint of bookies. Consequently, in the case the ledger has been closed, it may \n+     * return a different value than getLastAddConfirmed, which returns the local value \n+     * of the ledger handle.\n+     * \n+     * @see #getLastAddConfirmed()\n+     * \n+     * @return\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    \n     public long readLastConfirmed()\n             throws InterruptedException, BKException {\n         LastConfirmedCtx ctx = new LastConfirmedCtx();"},{"sha":"db2f7828ad4af428a348f275fccba1cd7ed2f164","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -69,7 +69,7 @@ public void initiate() {\n         int flags = BookieProtocol.FLAG_DO_FENCING;\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n             lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, \n-                                         LedgerHandle.LAST_ADD_CONFIRMED, this, i, flags);\n+                                         BookieProtocol.LAST_ADD_CONFIRMED, this, i, flags);\n         }\n     }\n "},{"sha":"f5f05235ef21fe7a3562188dfaf840f649980d3c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -46,13 +46,15 @@ public ReadLastConfirmedOp(LedgerHandle lh, ReadLastConfirmedCallback cb, Object\n         this.cb = cb;\n         this.ctx = ctx;\n         this.lh = lh;\n+        this.maxAddConfirmed = -1L;\n         this.validResponses = 0;\n         this.numResponsesPending = lh.metadata.ensembleSize;\n     }\n \n     public void initiate() {\n+        LOG.info(\"### Initiate ###\");\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, \n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, \n                                          this, i, BookieProtocol.FLAG_NONE);\n         }\n     }\n@@ -81,13 +83,14 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n             validResponses++;\n         }\n \n-        // other return codes dont count as valid responses\n+        // other return codes don't count as valid responses\n         if ((validResponses >= lh.metadata.quorumSize) &&\n                 !completed) {\n             completed = true;\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Read Complete with enough validResponses\");\n             }\n+            if(maxAddConfirmed > lh.lastAddConfirmed) lh.lastAddConfirmed = maxAddConfirmed;\n             cb.readLastConfirmedComplete(BKException.Code.OK, maxAddConfirmed, this.ctx);\n             return;\n         }"},{"sha":"8598c089397628ab80f3ff1ada4400039a06ede3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -38,6 +38,11 @@\n      * Current version of the protocol, which client will use. \n      */\n     public static final byte CURRENT_PROTOCOL_VERSION = 1;\n+    \n+    /**\n+     * Entry identifier representing a request to obtain the last add entry confirmed\n+     */\n+    public static final long LAST_ADD_CONFIRMED = -1;\n \n     /** \n      * The first int of a packet is the header."},{"sha":"0064e243bfeb39a06ec7eb5ae9c528c62d0b2fb1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -553,7 +553,8 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n              * submits a read request with id -1, and receives a response with a\n              * different entry id.\n              */\n-            readCompletion = readCompletions.remove(new CompletionKey(ledgerId, -1));\n+            \n+            readCompletion = readCompletions.remove(new CompletionKey(ledgerId, BookieProtocol.LAST_ADD_CONFIRMED));\n         }\n \n         if (readCompletion == null) {"},{"sha":"3a3c8aff1e2a5e106c762c14dade1e44a4fb7d94","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/bookkeeper/blob/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/29a472598083e522645f918ec602dd91d800f0d5/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=29a472598083e522645f918ec602dd91d800f0d5","patch":"@@ -904,7 +904,133 @@ public void testReadFromOpenLedger() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n+    \n+    @Test\n+    public void testReadFromOpenLedgerOpenOnce() throws Exception {\n+        try {\n+            // Create a ledger\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+                \n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.addEntry(entry.array());\n+                if (i == numEntriesToWrite / 2) {\n+                    // no recovery opened ledger 's last confirmed entry id is\n+                    // less than written\n+                    // and it just can read until (i-1)\n+                    int toRead = i - 1;\n+                    \n+                    long readLastConfirmed = lhOpen.readLastConfirmed();\n+                    assertTrue(readLastConfirmed != 0);\n+                    Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n+                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n+                    LedgerEntry e = readEntry.nextElement();\n+                    assertEquals(toRead, e.getEntryId());\n+                    Assert.assertArrayEquals(entries.get(toRead), e.getEntry());\n+                    // should not written to a read only ledger\n+                    try {\n+                        lhOpen.addEntry(entry.array());\n+                        fail(\"Should have thrown an exception here\");\n+                    } catch (BKException.BKIllegalOpException bkioe) {\n+                        // this is the correct response\n+                    } catch (Exception ex) {\n+                        LOG.error(\"Unexpected exception\", ex);\n+                        fail(\"Unexpected exception\");\n+                    }\n+                    \n+                }\n+            }\n+            long last = lh.readLastConfirmed();\n+            assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n+    \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+            // close read only ledger should not change metadata\n+            lhOpen.close();\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        } \n+    }\n+    \n+    @Test\n+    public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n+        try {\n+            // Create a ledger\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n+            \n+            /*\n+             * We haven't written anything, so it should be empty.\n+             */\n+            LOG.debug(\"Checking that it is empty\");\n+            long readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(\"Last confirmed has the wrong value\", readLastConfirmed == -1L);\n+            \n+            /*\n+             * Writing one entry.\n+             */\n+            LOG.debug(\"Going to write one entry\");\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            \n+            entries.add(entry.array());\n+            entriesSize.add(entry.array().length);\n+            lh.addEntry(entry.array());\n+\n+            /*\n+             * The hint should still indicate that there is no confirmed\n+             * add.\n+             */\n+            LOG.debug(\"Checking that it is still empty even after writing one entry\");\n+            readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(readLastConfirmed == -1L);\n+\n+            /*\n+             * Adding one more, and this time we should expect to \n+             * see one entry.\n+             */\n+            entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            \n+            entries.add(entry.array());\n+            entriesSize.add(entry.array().length);\n+            lh.addEntry(entry.array());\n \n+            LOG.info(\"Checking that it has an entry\");\n+            readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(readLastConfirmed == 0L);\n+                        \n+            // close ledger\n+            lh.close();\n+            // close read only ledger should not change metadata\n+            lhOpen.close();\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        } \n+    }\n+    \n \n     @Test\n     public void testLastConfirmedAdd() throws IOException {"}]}

