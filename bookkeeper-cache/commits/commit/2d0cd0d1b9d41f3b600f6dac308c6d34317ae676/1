{"sha":"2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyZDBjZDBkMWI5ZDQxZjNiNjAwZjZkYWMzMDhjNmQzNDMxN2FlNjc2","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-10-29T04:14:18Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-10-29T04:14:18Z"},"message":"BOOKKEEPER-602: we should have request timeouts rather than channel timeout in PerChannelBookieClient (Aniruddha, ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1536584 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dbad826dbd34a3e9be25c2efdb4d51c4754f4d88","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dbad826dbd34a3e9be25c2efdb4d51c4754f4d88"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","html_url":"https://github.com/apache/bookkeeper/commit/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"bf5c1838b4b0d764aa9f24842643fd9339610b9c","url":"https://api.github.com/repos/apache/bookkeeper/commits/bf5c1838b4b0d764aa9f24842643fd9339610b9c","html_url":"https://github.com/apache/bookkeeper/commit/bf5c1838b4b0d764aa9f24842643fd9339610b9c"}],"stats":{"total":222,"additions":179,"deletions":43},"files":[{"sha":"96f4637515cd17385ef5121a713e01c48f0b004a","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -180,6 +180,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-664: Compaction increases latency on journal writes (ivank via sijie)\n \n+      BOOKKEEPER-602: we should have request timeouts rather than channel timeout in PerChannelBookieClient (Aniruddha, ivank via sijie)\n+\n     NEW FEATURE:\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)"},{"sha":"d5baaa400fa42feda40d91e3cff8de8b987eb0da","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -151,6 +151,7 @@ private static void usage(Options options) {\n         formatter.printHelp(\"BenchReadThroughputLatency <options>\", options);\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     public static void main(String[] args) throws Exception {\n         Options options = new Options();\n         options.addOption(\"ledger\", true, \"Ledger to read. If empty, read all ledgers which come available. \" "},{"sha":"4fbf678d7f7f834c590d248d0f70d7b0885e3f1e","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -230,6 +230,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         }\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     public static void main(String[] args)\n             throws KeeperException, IOException, InterruptedException, ParseException, BKException {\n         Options options = new Options();"},{"sha":"16d59220be5b1bb8307673236d4915e054e7c26e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":80,"deletions":1,"changes":81,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -17,15 +17,17 @@\n  */\n package org.apache.bookkeeper.conf;\n \n+import static com.google.common.base.Charsets.UTF_8;\n+\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n import org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy;\n import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.lang.StringUtils;\n-import static com.google.common.base.Charsets.UTF_8;\n \n /**\n  * Configuration settings for client side\n@@ -48,6 +50,10 @@\n     protected final static String CLIENT_TCP_NODELAY = \"clientTcpNoDelay\";\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n+    // Timeout Setting\n+    protected final static String ADD_ENTRY_TIMEOUT_SEC = \"addEntryTimeoutSec\";\n+    protected final static String READ_ENTRY_TIMEOUT_SEC = \"readEntryTimeoutSec\";\n+    protected final static String TIMEOUT_TASK_INTERVAL_MILLIS = \"timeoutTaskIntervalMillis\";\n \n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n@@ -241,7 +247,9 @@ public ClientConfiguration setZkTimeout(int zkTimeout) {\n      * The default is 5 seconds.\n      *\n      * @return the current read timeout in seconds\n+     * @deprecated use {@link getReadEntryTimeout()} or {@link getAddEntryTimeout()} instead\n      */\n+    @Deprecated\n     public int getReadTimeout() {\n         return getInt(READ_TIMEOUT, 5);\n     }\n@@ -251,12 +259,83 @@ public int getReadTimeout() {\n      * @see #getReadTimeout()\n      * @param timeout The new read timeout in seconds\n      * @return client configuration\n+     * @deprecated use {@link setReadEntryTimeout(int)} or {@link setAddEntryTimeout(int)} instead\n      */\n+    @Deprecated\n     public ClientConfiguration setReadTimeout(int timeout) {\n         setProperty(READ_TIMEOUT, Integer.toString(timeout));\n         return this;\n     }\n \n+    /**\n+     * Get the timeout for add request. This is the number of seconds we wait without hearing\n+     * a response for add request from a bookie before we consider it failed.\n+     *\n+     * The default value is 5 second for backwards compatibility.\n+     *\n+     * @return add entry timeout.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public int getAddEntryTimeout() {\n+        return getInt(ADD_ENTRY_TIMEOUT_SEC, getReadTimeout());\n+    }\n+\n+    /**\n+     * Set timeout for add entry request.\n+     * @see #getAddEntryTimeout()\n+     *\n+     * @param timeout\n+     *          The new add entry timeout in seconds.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setAddEntryTimeout(int timeout) {\n+        setProperty(ADD_ENTRY_TIMEOUT_SEC, timeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the timeout for read entry. This is the number of seconds we wait without hearing\n+     * a response for read entry request from a bookie before we consider it failed. By default,\n+     * we use socket timeout specified at {@link #getReadTimeout()}.\n+     *\n+     * @return read entry timeout.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public int getReadEntryTimeout() {\n+        return getInt(READ_ENTRY_TIMEOUT_SEC, getReadTimeout());\n+    }\n+\n+    /**\n+     * Set the timeout for read entry request.\n+     * @see #getReadEntryTimeout()\n+     *\n+     * @param timeout\n+     *          The new read entry timeout in seconds.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setReadEntryTimeout(int timeout) {\n+        setProperty(READ_ENTRY_TIMEOUT_SEC, timeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the interval between successive executions of the PerChannelBookieClient's\n+     * TimeoutTask. This value is in milliseconds. Every X milliseconds, the timeout task\n+     * will be executed and it will error out entries that have timed out.\n+     *\n+     * We do it more aggressive to not accumulate pending requests due to slow responses.\n+     * @return\n+     */\n+    public long getTimeoutTaskIntervalMillis() {\n+        return getLong(TIMEOUT_TASK_INTERVAL_MILLIS,\n+                TimeUnit.SECONDS.toMillis(Math.min(getAddEntryTimeout(), getReadEntryTimeout())));\n+    }\n+\n+    public ClientConfiguration setTimeoutTaskIntervalMillis(long timeoutMillis) {\n+        setProperty(TIMEOUT_TASK_INTERVAL_MILLIS, Long.toString(timeoutMillis));\n+        return this;\n+    }\n+\n     /**\n      * Get the number of worker threads. This is the number of\n      * worker threads used by bookkeeper client to submit operations."},{"sha":"114f4194fe0dcd5ada71b4a742e47b6419c5b554","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":20,"deletions":14,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -21,23 +21,25 @@\n  *\n  */\n \n-import java.util.Set;\n-import java.util.HashSet;\n+import static com.google.common.base.Charsets.UTF_8;\n+\n import java.io.IOException;\n import java.net.InetSocketAddress;\n+import java.util.HashSet;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.atomic.AtomicLong;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n@@ -48,6 +50,8 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import static com.google.common.base.Charsets.UTF_8;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Implements the client-side part of the BookKeeper protocol.\n@@ -57,15 +61,16 @@\n     static final Logger LOG = LoggerFactory.getLogger(BookieClient.class);\n \n     // This is global state that should be across all BookieClients\n-    AtomicLong totalBytesOutstanding = new AtomicLong();\n-\n-    OrderedSafeExecutor executor;\n-    ClientSocketChannelFactory channelFactory;\n-    ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient> channels = new ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient>();\n+    final AtomicLong totalBytesOutstanding = new AtomicLong();\n \n+    final OrderedSafeExecutor executor;\n+    final ClientSocketChannelFactory channelFactory;\n+    final ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient> channels =\n+        new ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient>();\n+    final ScheduledExecutorService timeoutExecutor = Executors.newSingleThreadScheduledExecutor();\n     private final ClientConfiguration conf;\n     private volatile boolean closed;\n-    private ReentrantReadWriteLock closeLock;\n+    private final ReentrantReadWriteLock closeLock;\n \n     public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n         this.conf = conf;\n@@ -84,7 +89,8 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n                 if (closed) {\n                     return null;\n                 }\n-                channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding);\n+                channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding,\n+                        timeoutExecutor);\n                 PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n                 if (prevChannel != null) {\n                     channel = prevChannel;"},{"sha":"f1641795aac7658f4be8ae4bcf16db65c311f5a6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":69,"deletions":28,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -24,13 +24,13 @@\n import java.util.Collections;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Semaphore;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n import com.google.common.collect.ImmutableSet;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -39,7 +39,6 @@\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.jboss.netty.bootstrap.ClientBootstrap;\n import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelFuture;\n import org.jboss.netty.channel.ChannelFutureListener;\n@@ -79,6 +78,7 @@\n     AtomicLong totalBytesOutstanding;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor;\n+    ScheduledExecutorService timeoutExecutor;\n \n     ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n     ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n@@ -90,26 +90,77 @@\n     Queue<GenericCallback<Void>> pendingOps = new ArrayDeque<GenericCallback<Void>>();\n     volatile Channel channel = null;\n \n+    private class TimeoutTask implements Runnable {\n+        @Override\n+        public void run() {\n+            errorOutTimedOutEntries();\n+        }\n+    }\n+\n     enum ConnectionState {\n         DISCONNECTED, CONNECTING, CONNECTED, CLOSED\n-            };\n+    };\n \n     volatile ConnectionState state;\n     private final ClientConfiguration conf;\n \n+    /**\n+     * Error out any entries that have timed out.\n+     */\n+    private void errorOutTimedOutEntries() {\n+        int numAdd = 0, numRead = 0;\n+        int total = 0;\n+        try {\n+            for (CompletionKey key : addCompletions.keySet()) {\n+                total++;\n+                if (key.shouldTimeout(conf.getAddEntryTimeout() * 1000)) {\n+                    errorOutAddKey(key);\n+                    numAdd++;\n+                }\n+            }\n+            for (CompletionKey key : readCompletions.keySet()) {\n+                total++;\n+                if (key.shouldTimeout(conf.getReadEntryTimeout() * 1000)) {\n+                    errorOutReadKey(key);\n+                    numRead++;\n+                }\n+            }\n+        } catch (Throwable t) {\n+            LOG.error(\"Caught RuntimeException while erroring out timed out entries : \", t);\n+        }\n+        if (numAdd + numRead > 0) {\n+            LOG.info(\"Timeout task iterated through a total of {} keys.\", total);\n+            LOG.info(\"Timeout Task errored out {} add entry requests.\", numAdd);\n+            LOG.info(\"Timeout Task errored out {} read entry requests.\", numRead);\n+        }\n+    }\n+\n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n-                                  InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding);\n+                                  InetSocketAddress addr, AtomicLong totalBytesOutstanding,\n+                                  ScheduledExecutorService timeoutExecutor) {\n+        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, timeoutExecutor);\n     }\n-            \n-    public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+\n+    public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n                                   InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n+        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, null);\n+    }\n+\n+    public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n+                                  ClientSocketChannelFactory channelFactory, InetSocketAddress addr,\n+                                  AtomicLong totalBytesOutstanding, ScheduledExecutorService timeoutExecutor) {\n         this.conf = conf;\n         this.addr = addr;\n         this.executor = executor;\n         this.totalBytesOutstanding = totalBytesOutstanding;\n         this.channelFactory = channelFactory;\n         this.state = ConnectionState.DISCONNECTED;\n+        this.timeoutExecutor = timeoutExecutor;\n+        // scheudle the timeout task\n+        if (null != this.timeoutExecutor) {\n+            this.timeoutExecutor.scheduleWithFixedDelay(new TimeoutTask(), conf.getTimeoutTaskIntervalMillis(),\n+                    conf.getTimeoutTaskIntervalMillis(), TimeUnit.MILLISECONDS);\n+        }\n     }\n \n     private void connect() {\n@@ -462,8 +513,6 @@ void errorOutOutstandingEntries() {\n     public ChannelPipeline getPipeline() throws Exception {\n         ChannelPipeline pipeline = Channels.pipeline();\n \n-        pipeline.addLast(\"readTimeout\", new ReadTimeoutHandler(new HashedWheelTimer(),\n-                                                               conf.getReadTimeout()));\n         pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));\n         pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n         pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder());\n@@ -510,19 +559,6 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n                       e.getChannel().getRemoteAddress());\n             return;\n         }\n-        if (t instanceof ReadTimeoutException) {\n-            for (CompletionKey key : addCompletions.keySet()) {\n-                if (key.shouldTimeout()) {\n-                    errorOutAddKey(key);\n-                }\n-            }\n-            for (CompletionKey key : readCompletions.keySet()) {\n-                if (key.shouldTimeout()) {\n-                    errorOutReadKey(key);\n-                }\n-            }\n-            return;\n-        }\n \n         if (t instanceof IOException) {\n             // these are thrown when a bookie fails, logging them just pollutes\n@@ -701,15 +737,15 @@ CompletionKey newCompletionKey(long ledgerId, long entryId) {\n     }\n \n     // visable for testing\n-    class CompletionKey {\n+    static class CompletionKey {\n         long ledgerId;\n         long entryId;\n-        final long timeoutAt;\n+        final long requestAt;\n \n         CompletionKey(long ledgerId, long entryId) {\n             this.ledgerId = ledgerId;\n             this.entryId = entryId;\n-            this.timeoutAt = MathUtils.now() + (conf.getReadTimeout()*1000);\n+            this.requestAt = MathUtils.nowInNano();\n         }\n \n         @Override\n@@ -726,12 +762,17 @@ public int hashCode() {\n             return ((int) ledgerId << 16) ^ ((int) entryId);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\"LedgerEntry(%d, %d)\", ledgerId, entryId);\n         }\n \n-        public boolean shouldTimeout() {\n-            return this.timeoutAt <= MathUtils.now();\n+        public boolean shouldTimeout(long timeout) {\n+            return elapsedTime() >= timeout;\n+        }\n+\n+        public long elapsedTime() {\n+            return MathUtils.elapsedMSec(requestAt);\n         }\n     }\n "},{"sha":"c758cffe5819a0e0005a4e83a035efd750384d10","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -41,6 +41,7 @@\n /**\n  * This class tests the ledger close logic.\n  */\n+@SuppressWarnings(\"deprecation\")\n public class LedgerCloseTest extends BookKeeperClusterTestCase {\n \n     private final static Logger LOG = LoggerFactory.getLogger(LedgerCloseTest.class);"},{"sha":"b9ddd13f664a5f65e1a856e8137fcc3993eea47f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -39,6 +39,7 @@\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n \n+@SuppressWarnings(\"deprecation\")\n public class SlowBookieTest extends BookKeeperClusterTestCase {\n     private final static Logger LOG = LoggerFactory.getLogger(SlowBookieTest.class);\n "},{"sha":"54e0df033d8cb24fc2c6b9f8778415d957e662fd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -57,6 +57,7 @@ public TestReadTimeout() {\n         this.digestType = DigestType.CRC32;\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     @Test(timeout=60000)\n     public void testReadTimeout() throws Exception {\n         final AtomicBoolean completed = new AtomicBoolean(false);"},{"sha":"bb5c893a6e7da377f68b4529e5d5695c71cf0e13","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -67,6 +67,7 @@ long getLedgerToRead(int ensemble, int quorum) throws Exception {\n         return l.getId();\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     BookKeeper createClient(int specTimeout) throws Exception {\n         ClientConfiguration conf = new ClientConfiguration()\n             .setSpeculativeReadTimeout(specTimeout)"},{"sha":"c69da18bb98d194154467821fd7b67b8979bd2fc","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -255,6 +255,7 @@ public TestBookKeeperPersistenceManager(boolean removeStartSeqId) {\n         });\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     private void startCluster(long delay) throws Exception {\n         bktb = new BookKeeperTestBase(numBookies, 0L);\n         bktb.setUp();"},{"sha":"1ea7c1bbb8e112f74916756d4000762fb30ac859","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","raw_url":"https://github.com/apache/bookkeeper/raw/2d0cd0d1b9d41f3b600f6dac308c6d34317ae676/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java?ref=2d0cd0d1b9d41f3b600f6dac308c6d34317ae676","patch":"@@ -200,6 +200,7 @@ public long getMaximumCacheSize() {\n         }\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     @Override\n     protected ServerConfiguration getServerConfiguration(int serverPort, int sslServerPort) {\n         ServerConfiguration serverConf = new TestServerConfiguration(serverPort, sslServerPort);"}]}

