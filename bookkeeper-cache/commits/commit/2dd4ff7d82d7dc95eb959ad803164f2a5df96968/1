{"sha":"2dd4ff7d82d7dc95eb959ad803164f2a5df96968","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyZGQ0ZmY3ZDgyZDdkYzk1ZWI5NTlhZDgwMzE2NGYyYTVkZjk2OTY4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-02T20:47:32Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-02T20:47:32Z"},"message":"BOOKKEEPER-370: implement multiplexing cpp client. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1405159 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ec7b1a9b8982a33779bdf9842126fa409b36da9a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ec7b1a9b8982a33779bdf9842126fa409b36da9a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/2dd4ff7d82d7dc95eb959ad803164f2a5df96968","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/2dd4ff7d82d7dc95eb959ad803164f2a5df96968","html_url":"https://github.com/apache/bookkeeper/commit/2dd4ff7d82d7dc95eb959ad803164f2a5df96968","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f633075dd0b0cae6c50db0f7284798089a9cf83b","url":"https://api.github.com/repos/apache/bookkeeper/commits/f633075dd0b0cae6c50db0f7284798089a9cf83b","html_url":"https://github.com/apache/bookkeeper/commit/f633075dd0b0cae6c50db0f7284798089a9cf83b"}],"stats":{"total":1623,"additions":1583,"deletions":40},"files":[{"sha":"b7ed707c411f5ba6960abd0f41dae2211986996a","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -226,6 +226,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-368: Implementing multiplexing java client. (sijie via ivank)\n \n+        BOOKKEEPER-370: implement multiplexing cpp client. (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"308407cf611e970d9160b3137214d0388872f81a","filename":"hedwig-client/src/main/cpp/Makefile.am","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/Makefile.am?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -31,8 +31,14 @@ EXTRA_DIST = $(DX_CONFIG) doc/html\n check:\n \tcd test; make check\n \n-sslcheck:\n-\tcd test; make sslcheck\n+simplesslcheck:\n+\tcd test; make simplesslcheck\n \n simplecheck:\n \tcd test; make simplecheck\n+\n+multiplexsslcheck:\n+\tcd test; make multiplexsslcheck\n+\n+multiplexcheck:\n+\tcd test; make multiplexcheck"},{"sha":"0600930a328e440c9f028ed92a5dd6c5b5adc432","filename":"hedwig-client/src/main/cpp/inc/hedwig/client.h","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/inc/hedwig/client.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/inc/hedwig/client.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/client.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -49,6 +49,7 @@ namespace Hedwig {\n     static const std::string NUM_DISPATCH_THREADS;\n     static const std::string SSL_ENABLED;\n     static const std::string SSL_PEM_FILE;\n+    static const std::string ENABLE_MULTIPLEXING;\n     /**\n      * The maximum number of messages the hub will queue for subscriptions\n      * created using this configuration. The hub will always queue the most"},{"sha":"f19a3da8339280f1f88095b7471b74151c81a1d5","filename":"hedwig-client/src/main/cpp/lib/Makefile.am","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/Makefile.am?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -19,7 +19,7 @@\n PROTODEF = ../../../../../hedwig-protocol/src/main/protobuf/PubSubProtocol.proto\n \n lib_LTLIBRARIES = libhedwig01.la\n-libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp filterablemessagehandler.cpp simplesubscriberimpl.cpp\n+libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp filterablemessagehandler.cpp simplesubscriberimpl.cpp multiplexsubscriberimpl.cpp\n libhedwig01_la_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS)\n libhedwig01_la_LIBADD = $(DEPS_LIBS) $(BOOST_CPPFLAGS) \n libhedwig01_la_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)"},{"sha":"c2c5d12711288f9d2e39ce873c873f5a3e36d604","filename":"hedwig-client/src/main/cpp/lib/client.cpp","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/client.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/client.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/client.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -41,6 +41,7 @@ const std::string Configuration::NUM_DISPATCH_THREADS = \"hedwig.cpp.num_dispatch\n const std::string Configuration::SUBSCRIPTION_MESSAGE_BOUND = \"hedwig.cpp.subscription_message_bound\";\n const std::string Configuration::SSL_ENABLED = \"hedwig.cpp.ssl_enabled\";\n const std::string Configuration::SSL_PEM_FILE = \"hedwig.cpp.ssl_pem\";\n+const std::string Configuration::ENABLE_MULTIPLEXING = \"hedwig.cpp.enable_multiplexing\";\n \n Client::Client(const Configuration& conf) {\n   LOG4CXX_DEBUG(logger, \"Client::Client (\" << this << \")\");"},{"sha":"9f97aa3000e5f858c152095d733e786e5f3d5a63","filename":"hedwig-client/src/main/cpp/lib/clientimpl.cpp","status":"modified","additions":18,"deletions":8,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/clientimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/clientimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -24,6 +24,7 @@\n #include \"publisherimpl.h\"\n #include \"subscriberimpl.h\"\n #include \"simplesubscriberimpl.h\"\n+#include \"multiplexsubscriberimpl.h\"\n #include <log4cxx/logger.h>\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n@@ -331,8 +332,14 @@ void SubscriptionEventEmitter::emitSubscriptionEvent(\n //\n \n DuplexChannelManagerPtr DuplexChannelManager::create(const Configuration& conf) {\n-  DuplexChannelManagerPtr manager(new SimpleDuplexChannelManager(conf));\n-  LOG4CXX_DEBUG(logger, \"Created DuplexChannelManager \" << manager);\n+  DuplexChannelManager * managerPtr;\n+  if (conf.getBool(Configuration::ENABLE_MULTIPLEXING, false)) {\n+    managerPtr = new MultiplexDuplexChannelManager(conf);\n+  } else {\n+    managerPtr = new SimpleDuplexChannelManager(conf);\n+  }\n+  DuplexChannelManagerPtr manager(managerPtr);\n+  LOG4CXX_DEBUG(logger, \"Created DuplexChannelManager \" << manager.get());\n   return manager;\n }\n \n@@ -572,11 +579,6 @@ void DuplexChannelManager::setHostForTopic(const std::string& topic, const HostA\n   LOG4CXX_DEBUG(logger, \"Set ownership of topic \" << topic << \" to \" << host << \".\");\n }\n \n-const HostAddress& DuplexChannelManager::getHostForTopic(const std::string& topic) {\n-  boost::shared_lock<boost::shared_mutex> t2hlock(topic2host_lock);\n-  return topic2host[topic];\n-}\n-\n void DuplexChannelManager::clearAllTopicsForHost(const HostAddress& addr) {\n   // remove topic mapping\n   boost::lock_guard<boost::shared_mutex> h2tlock(host2topics_lock);\n@@ -600,7 +602,15 @@ void DuplexChannelManager::clearHostForTopic(const std::string& topic,\n   if (iter != host2topics.end()) {\n     iter->second->erase(topic);\n   }\n-  topic2host.erase(topic);\n+  HostAddress existed = topic2host[topic];\n+  if (existed == addr) {\n+    topic2host.erase(topic);\n+  }\n+}\n+\n+const HostAddress& DuplexChannelManager::getHostForTopic(const std::string& topic) {\n+  boost::shared_lock<boost::shared_mutex> t2hlock(topic2host_lock);\n+  return topic2host[topic];\n }\n \n /**"},{"sha":"4cd74ceb0cfe8777096d2c1b9090550429faeb4d","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"modified","additions":23,"deletions":1,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -37,7 +37,8 @@ const char* OPERATION_TYPE_NAMES[] = {\n   stringify( CONSUME ),\n   stringify( UNSUBSCRIBE ),\n   stringify( START_DELIVERY ),\n-  stringify( STOP_DELIVERY )\n+  stringify( STOP_DELIVERY ),\n+  stringify( CLOSESUBSCRIPTION )\n };\n \n PubSubDataPtr PubSubData::forPublishRequest(long txnid, const std::string& topic, const Message& body,\n@@ -74,6 +75,18 @@ PubSubDataPtr PubSubData::forUnsubscribeRequest(long txnid, const std::string& s\n   return ptr;  \n }\n \n+PubSubDataPtr PubSubData::forCloseSubscriptionRequest(\n+  long txnid, const std::string& subscriberid, const std::string& topic,\n+  const ResponseCallbackPtr& callback) {\n+  PubSubDataPtr ptr(new PubSubData());\n+  ptr->type = CLOSESUBSCRIPTION;\n+  ptr->txnid = txnid;\n+  ptr->subscriberid = subscriberid;\n+  ptr->topic = topic;\n+  ptr->callback = callback;\n+  return ptr;  \n+}\n+\n PubSubDataPtr PubSubData::forConsumeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const MessageSeqId msgid) {\n   PubSubDataPtr ptr(new PubSubData());\n   ptr->type = CONSUME;\n@@ -122,6 +135,9 @@ void PubSubData::setPreferencesForSubRequest(SubscribeRequest * subreq,\n   if (options.has_options()) {\n     preferences->mutable_options()->CopyFrom(options.options());\n   }\n+  if (options.has_messagewindowsize()) {\n+    preferences->set_messagewindowsize(options.messagewindowsize());\n+  }\n }\n \n const PubSubRequestPtr PubSubData::getRequest() {\n@@ -159,6 +175,11 @@ const PubSubRequestPtr PubSubData::getRequest() {\n     \n     Hedwig::UnsubscribeRequest* unsubreq = request->mutable_unsubscriberequest();\n     unsubreq->set_subscriberid(subscriberid);    \n+  } else if (type == CLOSESUBSCRIPTION) {\n+    LOG4CXX_DEBUG(logger, \"Creating closeSubscription request\");\n+    \n+    Hedwig::CloseSubscriptionRequest* closesubreq = request->mutable_closesubscriptionrequest();\n+    closesubreq->set_subscriberid(subscriberid);    \n   } else {\n     LOG4CXX_ERROR(logger, \"Tried to create a request message for the wrong type [\" << type << \"]\");\n     throw UnknownRequestException();\n@@ -239,6 +260,7 @@ std::ostream& Hedwig::operator<<(std::ostream& os, const PubSubData& data) {\n   switch (type) {\n   case SUBSCRIBE:\n   case UNSUBSCRIBE:\n+  case CLOSESUBSCRIPTION:\n     os << \", subscriber:\" << data.getSubscriberId() << \")\";\n     break;\n   case CONSUME:"},{"sha":"0639f4a80fda82e09b8be1a855385089daf49bc7","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -75,6 +75,10 @@ namespace Hedwig {\n                                                const ResponseCallbackPtr& callback);\n     static PubSubDataPtr forConsumeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const MessageSeqId msgid);\n \n+    static PubSubDataPtr forCloseSubscriptionRequest(long txnid, const std::string& subscriberid,\n+                                                     const std::string& topic,\n+                                                     const ResponseCallbackPtr& callback);\n+\n     ~PubSubData();\n \n     OperationType getType() const;"},{"sha":"8c8767a8be5170f0922fbe481690af68f2a4d00f","filename":"hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp","status":"added","additions":566,"deletions":0,"changes":566,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -0,0 +1,566 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <log4cxx/logger.h>\n+\n+#include \"multiplexsubscriberimpl.h\"\n+#include \"util.h\"\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+RemoveSubscriptionCallback::RemoveSubscriptionCallback(\n+  const MultiplexDuplexChannelManagerPtr& channelManager,\n+  const MultiplexSubscriberClientChannelHandlerPtr& handler,\n+  const TopicSubscriber& ts, const OperationCallbackPtr& callback)\n+  : channelManager(channelManager), handler(handler),\n+    topicSubscriber(ts), callback(callback) {\n+}\n+\n+void RemoveSubscriptionCallback::operationComplete(const ResponseBody& resp) {\n+  handler->removeActiveSubscriber(topicSubscriber);\n+  channelManager->removeSubscriptionChannelHandler(topicSubscriber, handler);\n+  callback->operationComplete();\n+}\n+\n+void RemoveSubscriptionCallback::operationFailed(const std::exception& exception) {\n+  callback->operationFailed(exception);\n+}\n+\n+MultiplexSubscriberClientChannelHandler::MultiplexSubscriberClientChannelHandler(\n+    const MultiplexDuplexChannelManagerPtr& channelManager, ResponseHandlerMap& handlers)\n+    : SubscriberClientChannelHandler(boost::dynamic_pointer_cast<DuplexChannelManager>(channelManager), handlers),\n+      mChannelManager(channelManager) {\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::removeActiveSubscriber(\n+  const TopicSubscriber& ts) {\n+  ActiveSubscriberPtr as;\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(subscribers_lock);\n+    as = activeSubscribers[ts];\n+    activeSubscribers.erase(ts);\n+    LOG4CXX_DEBUG(logger, \"Removed \" << ts << \" from channel \" << channel.get() << \".\");\n+  }\n+  if (as.get()) {\n+    as->close();\n+  }\n+}\n+\n+bool MultiplexSubscriberClientChannelHandler::addActiveSubscriber(\n+  const PubSubDataPtr& op, const SubscriptionPreferencesPtr& preferences) {\n+  TopicSubscriber ts(op->getTopic(), op->getSubscriberId());\n+  boost::lock_guard<boost::shared_mutex> lock(subscribers_lock);\n+  ActiveSubscriberPtr subscriber = activeSubscribers[ts];\n+  if (subscriber.get()) {\n+    // NOTE: it should not happen here, since we had subscribers mapping to\n+    //       avoid two same topic subscribers alive in a client.\n+    LOG4CXX_WARN(logger, \"Duplicate \" << *subscriber << \" has been found alive on channel \"\n+                         << channel.get());\n+    return false;\n+  }\n+  subscriber = ActiveSubscriberPtr(new ActiveSubscriber(op, channel, preferences,\n+                                                        channelManager));\n+  activeSubscribers[ts] = subscriber;\n+  return true;\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::handleSubscriptionEvent(\n+  const TopicSubscriber& ts, const SubscriptionEvent event) {\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive for \" << ts\n+                          << \" on channel \" << channel.get() << \" receiving event \"\n+                          << event);\n+    return;\n+  }\n+  if (!as->isResubscribeRequired() &&\n+      (TOPIC_MOVED == event || SUBSCRIPTION_FORCED_CLOSED == event)) {\n+    // topic has moved\n+    if (TOPIC_MOVED == event) {\n+      // remove topic mapping\n+      channelManager->clearHostForTopic(as->getTopic(), getChannel()->getHostAddress());\n+    }\n+    // first remove the topic subscriber from current handler\n+    removeActiveSubscriber(ts);\n+    // second remove it from the mapping\n+    mChannelManager->removeSubscriptionChannelHandler(ts,\n+      boost::dynamic_pointer_cast<MultiplexSubscriberClientChannelHandler>(shared_from_this()));\n+  }\n+  as->processEvent(ts.first, ts.second, event);\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::deliverMessage(const TopicSubscriber& ts,\n+                                                             const PubSubResponsePtr& m) {\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive for \" << ts\n+                          << \" on channel \" << channel.get());\n+    return;\n+  }\n+  as->deliverMessage(m);\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::startDelivery(\n+  const TopicSubscriber& ts, const MessageHandlerCallbackPtr& handler,\n+  const ClientMessageFilterPtr& filter) {\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive for \" << ts\n+                          << \" on channel \" << channel.get());\n+    throw NotSubscribedException();\n+  }\n+  as->startDelivery(handler, filter);\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::stopDelivery(const TopicSubscriber& ts) {\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive for \" << ts\n+                          << \" on channel \" << channel.get());\n+    throw NotSubscribedException();\n+  }\n+  as->stopDelivery();\n+}\n+\n+bool MultiplexSubscriberClientChannelHandler::hasSubscription(const TopicSubscriber& ts) {\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    return false;\n+  }\n+  return ts.first == as->getTopic() && ts.second == as->getSubscriberId();\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::asyncCloseSubscription(\n+  const TopicSubscriber& ts, const OperationCallbackPtr& callback) {\n+  // just remove the active subscriber\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    LOG4CXX_DEBUG(logger, \"No Active Subscriber found for \" << ts\n+                          << \" when closing its subscription.\");\n+    mChannelManager->removeSubscriptionChannelHandler(ts,\n+      boost::dynamic_pointer_cast<MultiplexSubscriberClientChannelHandler>(shared_from_this()));\n+    callback->operationComplete();\n+    return;\n+  }\n+\n+  RemoveSubscriptionCallback * removeCb =\n+    new RemoveSubscriptionCallback(\n+      mChannelManager,\n+      boost::dynamic_pointer_cast<MultiplexSubscriberClientChannelHandler>(shared_from_this()),\n+      ts, callback);\n+  ResponseCallbackPtr respCallback(removeCb);\n+  PubSubDataPtr data =\n+    PubSubData::forCloseSubscriptionRequest(channelManager->nextTxnId(),\n+                                            ts.second, ts.first, respCallback);\n+  channelManager->submitOp(data);\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::consume(const TopicSubscriber& ts,\n+                                                      const MessageSeqId& messageSeqId) {\n+  ActiveSubscriberPtr as = getActiveSubscriber(ts);\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found for \" << ts\n+                          << \" alive on channel \" << channel.get());\n+    return;\n+  }\n+  as->consume(messageSeqId);\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::onChannelDisconnected(const DuplexChannelPtr& channel) {\n+  // Clear the subscription channel\n+  MultiplexSubscriberClientChannelHandlerPtr that =\n+    boost::dynamic_pointer_cast<MultiplexSubscriberClientChannelHandler>(shared_from_this());\n+  // remove the channel from channel manager\n+  mChannelManager->removeSubscriptionChannelHandler(\n+    getChannel()->getHostAddress(), that);\n+\n+  // disconnect all the subscribers alive on this channel\n+\n+  // make a copy of active subscribers to process event, the size is estimated\n+  std::vector<ActiveSubscriberPtr> copyofActiveSubscribers(activeSubscribers.size());\n+  copyofActiveSubscribers.clear();\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(subscribers_lock);\n+    ActiveSubscriberMap::iterator iter = activeSubscribers.begin();\n+    for (; iter != activeSubscribers.end(); ++iter) {\n+      ActiveSubscriberPtr as = iter->second;\n+      if (as.get()) {\n+        // clear topic ownership\n+        mChannelManager->clearHostForTopic(as->getTopic(), channel->getHostAddress());\n+\n+        if (!as->isResubscribeRequired()) {\n+          TopicSubscriber ts(as->getTopic(), as->getSubscriberId());\n+          // remove the subscription handler if no need to resubscribe\n+          mChannelManager->removeSubscriptionChannelHandler(ts, that);\n+        }\n+        // close the active subscriber\n+        as->close();\n+        copyofActiveSubscribers.push_back(as);\n+      }\n+    }\n+    activeSubscribers.clear();\n+  }\n+\n+  // processEvent would emit subscription event to user's callback\n+  // so it would be better to not put the logic under a lock.\n+  std::vector<ActiveSubscriberPtr>::iterator viter = copyofActiveSubscribers.begin();\n+  for (; viter != copyofActiveSubscribers.end(); ++viter) {\n+    ActiveSubscriberPtr as = *viter;\n+    if (as.get()) {\n+      LOG4CXX_INFO(logger, \"Tell \" << *as << \" his channel \" << channel.get()\n+                           << \" is disconnected.\");\n+      as->processEvent(as->getTopic(), as->getSubscriberId(), TOPIC_MOVED);\n+    }\n+  }\n+  copyofActiveSubscribers.clear();\n+}\n+\n+void MultiplexSubscriberClientChannelHandler::closeHandler() {\n+  boost::lock_guard<boost::shared_mutex> lock(subscribers_lock);\n+  ActiveSubscriberMap::iterator iter = activeSubscribers.begin();\n+  for (; iter != activeSubscribers.end(); ++iter) {\n+    ActiveSubscriberPtr as = iter->second;\n+    if (as.get()) {\n+      as->close();\n+      LOG4CXX_DEBUG(logger, \"Closed \" << *as << \".\");\n+    }\n+  }\n+}\n+\n+//\n+// Subscribe Response Handler\n+//\n+MultiplexSubscribeResponseHandler::MultiplexSubscribeResponseHandler(\n+  const MultiplexDuplexChannelManagerPtr& channelManager)\n+  : ResponseHandler(boost::dynamic_pointer_cast<DuplexChannelManager>(channelManager)),\n+    mChannelManager(channelManager) {\n+}\n+\n+void MultiplexSubscribeResponseHandler::handleSuccessResponse(\n+  const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+  const MultiplexSubscriberClientChannelHandlerPtr& handler) {\n+  // for subscribe request, check whether is any subscription preferences received\n+  SubscriptionPreferencesPtr preferences;\n+  if (m->has_responsebody()) {\n+    const ResponseBody& respBody = m->responsebody();\n+    if (respBody.has_subscriberesponse()) {\n+      const SubscribeResponse& resp = respBody.subscriberesponse();\n+      if (resp.has_preferences()) {\n+        preferences = SubscriptionPreferencesPtr(new SubscriptionPreferences(resp.preferences()));\n+      }\n+    }\n+  }\n+\n+  TopicSubscriber ts(txn->getTopic(), txn->getSubscriberId()); \n+  if (!mChannelManager->storeSubscriptionChannelHandler(ts, txn, handler)) {\n+    // found existed subscription channel handler\n+    if (txn->isResubscribeRequest()) {\n+      txn->getCallback()->operationFailed(ResubscribeException());\n+    } else {\n+      txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    }\n+    return;\n+  }\n+\n+  // If the subscriber has been alive on this channel\n+  if (!handler->addActiveSubscriber(txn, preferences)) {\n+    txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    return;\n+  }\n+  if (m->has_responsebody()) {\n+    txn->getCallback()->operationComplete(m->responsebody());\n+  } else {\n+    txn->getCallback()->operationComplete(ResponseBody());\n+  }\n+}\n+\n+void MultiplexSubscribeResponseHandler::handleResponse(\n+  const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+  const DuplexChannelPtr& channel) {\n+  if (!txn.get()) {\n+    LOG4CXX_ERROR(logger, \"Invalid transaction recevied from channel \" << channel.get());\n+    return;\n+  }\n+\n+  LOG4CXX_DEBUG(logger, \"message received with status \" << m->statuscode()\n+                        << \" from channel \" << channel.get());\n+\n+  MultiplexSubscriberClientChannelHandlerPtr handler =\n+    boost::dynamic_pointer_cast<MultiplexSubscriberClientChannelHandler>(channel->getChannelHandler());\n+  if (!handler.get()) {\n+    LOG4CXX_ERROR(logger, \"No simple subscriber client channel handler found for channel \"\n+                          << channel.get() << \".\");\n+    // No channel handler, but we still need to close the channel\n+    channel->close();\n+    txn->getCallback()->operationFailed(NoChannelHandlerException());\n+    return;\n+  }\n+\n+  // we don't close any subscription channel when encountering subscribe failures\n+\n+  switch (m->statuscode()) {\n+  case SUCCESS:\n+    handleSuccessResponse(m, txn, handler);\n+    break;\n+  case SERVICE_DOWN:\n+    txn->getCallback()->operationFailed(ServiceDownException());\n+    break;\n+  case CLIENT_ALREADY_SUBSCRIBED:\n+  case TOPIC_BUSY:\n+    txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    break;\n+  case CLIENT_NOT_SUBSCRIBED:\n+    txn->getCallback()->operationFailed(NotSubscribedException());\n+    break;\n+  case NOT_RESPONSIBLE_FOR_TOPIC:\n+    redirectRequest(m, txn, channel);\n+    break;\n+  default:\n+    LOG4CXX_ERROR(logger, \"Unexpected response \" << m->statuscode() << \" for \" << txn->getTxnId());\n+    txn->getCallback()->operationFailed(UnexpectedResponseException());\n+    break;\n+  }\n+}\n+\n+//\n+// Multiplex Duplex Channel Manager\n+//\n+MultiplexDuplexChannelManager::MultiplexDuplexChannelManager(const Configuration& conf)\n+  : DuplexChannelManager(conf) {\n+  LOG4CXX_DEBUG(logger, \"Created MultiplexDuplexChannelManager \" << this);\n+}\n+\n+MultiplexDuplexChannelManager::~MultiplexDuplexChannelManager() {\n+  LOG4CXX_DEBUG(logger, \"Destroyed MultiplexDuplexChannelManager \" << this);\n+}\n+\n+void MultiplexDuplexChannelManager::start() {\n+  // Add subscribe response handler\n+  subscriptionHandlers[SUBSCRIBE] =\n+    ResponseHandlerPtr(new MultiplexSubscribeResponseHandler(\n+      boost::dynamic_pointer_cast<MultiplexDuplexChannelManager>(shared_from_this())));\n+  subscriptionHandlers[CLOSESUBSCRIPTION] =\n+    ResponseHandlerPtr(new CloseSubscriptionResponseHandler(shared_from_this()));\n+  DuplexChannelManager::start();\n+}\n+\n+void MultiplexDuplexChannelManager::close() {\n+  DuplexChannelManager::close();\n+  subscriptionHandlers.clear();\n+}\n+\n+SubscriberClientChannelHandlerPtr\n+MultiplexDuplexChannelManager::getSubscriptionChannelHandler(const TopicSubscriber& ts) {\n+  boost::shared_lock<boost::shared_mutex> lock(subscribers_lock);\n+  return boost::dynamic_pointer_cast<SubscriberClientChannelHandler>(subscribers[ts]);\n+}\n+\n+DuplexChannelPtr MultiplexDuplexChannelManager::getSubscriptionChannel(\n+  const TopicSubscriber& ts, const bool /*isResubscribeRequest*/) {\n+  const HostAddress& addr = getHostForTopic(ts.first);\n+  if (addr.isNullHost()) {\n+    return DuplexChannelPtr();\n+  } else {\n+    // we had known which hub server owned the topic\n+    DuplexChannelPtr ch = getSubscriptionChannel(addr);\n+    if (ch.get()) {\n+      return ch;\n+    }\n+    ch = createSubscriptionChannel(addr);\n+    return storeSubscriptionChannel(ch, true);\n+  }\n+}\n+\n+DuplexChannelPtr MultiplexDuplexChannelManager::getSubscriptionChannel(const HostAddress& addr) {\n+  MultiplexSubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(subhandlers_lock);\n+    handler = subhandlers[addr];\n+  }\n+  if (handler.get()) {\n+    return boost::dynamic_pointer_cast<DuplexChannel>(handler->getChannel()); \n+  } else {\n+    return DuplexChannelPtr();\n+  }\n+}\n+\n+DuplexChannelPtr MultiplexDuplexChannelManager::createSubscriptionChannel(const HostAddress& addr) {\n+  // Create a multiplex subscriber channel handler\n+  MultiplexSubscriberClientChannelHandler * subscriberHandler =\n+    new MultiplexSubscriberClientChannelHandler(\n+      boost::dynamic_pointer_cast<MultiplexDuplexChannelManager>(shared_from_this()),\n+      subscriptionHandlers);\n+  ChannelHandlerPtr channelHandler(subscriberHandler);\n+  // Create a subscription channel\n+  DuplexChannelPtr channel = createChannel(dispatcher->getService(), addr, channelHandler);\n+  subscriberHandler->setChannel(boost::dynamic_pointer_cast<AbstractDuplexChannel>(channel));\n+  LOG4CXX_INFO(logger, \"New multiplex subscription channel \" << channel.get() << \" is created to host \"\n+                       << addr << \", whose channel handler is \" << subscriberHandler);\n+  return channel;\n+}\n+\n+DuplexChannelPtr MultiplexDuplexChannelManager::storeSubscriptionChannel(\n+  const DuplexChannelPtr& ch, bool doConnect) {\n+\n+  const HostAddress& host = ch->getHostAddress();\n+  MultiplexSubscriberClientChannelHandlerPtr handler =\n+    boost::dynamic_pointer_cast<MultiplexSubscriberClientChannelHandler>(ch->getChannelHandler());\n+\n+  bool useOldCh;\n+  MultiplexSubscriberClientChannelHandlerPtr oldHandler;\n+  DuplexChannelPtr oldChannel;\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(subhandlers_lock);\n+\n+    oldHandler = subhandlers[host];\n+    if (!oldHandler.get()) {\n+      subhandlers[host] = handler;\n+      useOldCh = false;\n+    } else {\n+      oldChannel = boost::dynamic_pointer_cast<DuplexChannel>(oldHandler->getChannel());\n+      useOldCh = true;\n+    }\n+  }\n+  if (useOldCh) {\n+    LOG4CXX_DEBUG(logger, \"Subscription channel \" << oldChannel.get() << \" with handler \"\n+                          << oldHandler.get() << \" was used to serve subscribe requests to host \"\n+                          << host << \" so close new channel \" << ch.get() << \" with handler \"\n+                          << handler.get() << \".\");\n+    handler->close();\n+    return oldChannel;\n+  } else {\n+    if (doConnect) {\n+      ch->connect();\n+    }\n+    LOG4CXX_DEBUG(logger, \"Storing channel \" << ch.get() << \" with handler \" << handler.get()\n+                          << \" for host \" << host << \".\");\n+    return ch;\n+  }\n+\n+}\n+\n+bool MultiplexDuplexChannelManager::removeSubscriptionChannelHandler(\n+  const TopicSubscriber& ts, const MultiplexSubscriberClientChannelHandlerPtr& handler) {\n+  boost::lock_guard<boost::shared_mutex> lock(subscribers_lock);\n+  MultiplexSubscriberClientChannelHandlerPtr existedHandler = subscribers[ts];\n+  if (existedHandler.get() == handler.get()) {\n+    subscribers.erase(ts);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool MultiplexDuplexChannelManager::removeSubscriptionChannelHandler(\n+  const HostAddress& addr, const MultiplexSubscriberClientChannelHandlerPtr& handler) {\n+  bool removed;\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(subhandlers_lock);\n+    MultiplexSubscriberClientChannelHandlerPtr existedHandler = subhandlers[addr];\n+    if (existedHandler.get() == handler.get()) {\n+      subhandlers.erase(addr);\n+      removed = true;\n+    } else {\n+      removed = false;\n+    }\n+  }\n+  if (removed && handler.get()) {\n+    handler->close();\n+  }\n+  return removed;\n+}\n+\n+bool MultiplexDuplexChannelManager::storeSubscriptionChannelHandler(\n+  const TopicSubscriber& ts, const PubSubDataPtr& txn,\n+  const MultiplexSubscriberClientChannelHandlerPtr& handler) {\n+  MultiplexSubscriberClientChannelHandlerPtr other;\n+  bool success = false;\n+  bool isResubscribeRequest = txn->isResubscribeRequest();\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(subscribers_lock);\n+    other = subscribers[ts];\n+    if (other.get()) {\n+      if (isResubscribeRequest) {\n+        DuplexChannelPtr& origChannel = txn->getOrigChannelForResubscribe();\n+        const AbstractDuplexChannelPtr& otherChannel = other->getChannel();\n+        if (origChannel.get() != otherChannel.get()) {\n+          // channel has been changed for a specific subscriber\n+          // which means the client closesub and subscribe again\n+          // when channel disconnect to resubscribe for it.\n+          // so we should not let the resubscribe succeed\n+          success = false;\n+        } else {\n+          subscribers[ts] = handler;\n+          success = true;\n+        }\n+      } else {\n+        success = false;\n+      }\n+    } else {\n+      if (isResubscribeRequest) {\n+        // if it is a resubscribe request and there is no handler found\n+        // which means a closesub has been called when resubscribing\n+        // so we should not let the resubscribe succeed\n+        success = false;\n+      } else {\n+        subscribers[ts] = handler;\n+        success = true;\n+      }\n+    }\n+  }\n+  return success;\n+}\n+\n+void MultiplexDuplexChannelManager::asyncCloseSubscription(\n+  const TopicSubscriber& ts, const OperationCallbackPtr& callback) {\n+  SubscriberClientChannelHandlerPtr handler =\n+    getSubscriptionChannelHandler(ts);\n+  if (!handler.get()) {\n+    LOG4CXX_DEBUG(logger, \"No subscription channel handler found for \" << ts << \".\");\n+    callback->operationComplete();\n+    return;\n+  }\n+  handler->asyncCloseSubscription(ts, callback);\n+}\n+\n+void MultiplexDuplexChannelManager::handoverDelivery(\n+  const TopicSubscriber& ts, const MessageHandlerCallbackPtr& msgHandler,\n+  const ClientMessageFilterPtr& filter) {\n+  SubscriberClientChannelHandlerPtr handler =\n+    getSubscriptionChannelHandler(ts);\n+  if (!handler.get()) {\n+    LOG4CXX_WARN(logger, \"No subscription channel handler found for \" << ts\n+                         << \" to handover delivery with handler \"\n+                         << msgHandler.get() << \", filter \" << filter.get() << \".\");\n+    return;\n+  }\n+  try {\n+    handler->startDelivery(ts, msgHandler, filter);\n+  } catch(const AlreadyStartDeliveryException& ase) {\n+    LOG4CXX_WARN(logger, \"Other one has started delivery for \" << ts << \" using brand new message handler. \"\n+                         << \"It is OK that we could give up handing over old message handler.\");\n+  } catch(const std::exception& e) {\n+    LOG4CXX_WARN(logger, \"Error when handing over old message handler for \" << ts\n+                         << \" : \" << e.what());\n+  }\n+}"},{"sha":"8e9711e794f403a9b449594f8e5a7fe8a5944a33","filename":"hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -0,0 +1,193 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef MULTIPLEX_SUBSCRIBE_IMPL_H\n+#define MULTIPLEX_SUBSCRIBE_IMPL_H\n+\n+#include <boost/thread/mutex.hpp>\n+\n+#include \"subscriberimpl.h\"\n+#include \"clientimpl.h\"\n+\n+namespace Hedwig {\n+\n+  class MultiplexDuplexChannelManager;\n+  typedef boost::shared_ptr<MultiplexDuplexChannelManager> MultiplexDuplexChannelManagerPtr;\n+\n+  // Multiplex Subscription Channel Handler : multiple subscription per channel\n+  class MultiplexSubscriberClientChannelHandler : public SubscriberClientChannelHandler {\n+  public:\n+    MultiplexSubscriberClientChannelHandler(const MultiplexDuplexChannelManagerPtr& channelManager,\n+                                            ResponseHandlerMap& handlers);\n+    virtual ~MultiplexSubscriberClientChannelHandler() {}\n+\n+    // remove a given topic subscriber\n+    void removeActiveSubscriber(const TopicSubscriber& ts);\n+\n+    // Add the subscriber serving on this channel\n+    bool addActiveSubscriber(const PubSubDataPtr& op,\n+                             const SubscriptionPreferencesPtr& preferences);\n+\n+    virtual void handleSubscriptionEvent(const TopicSubscriber& ts,\n+                                         const SubscriptionEvent event);\n+\n+    // Deliver a received message to given message handler\n+    virtual void deliverMessage(const TopicSubscriber& ts,\n+                                const PubSubResponsePtr& m);\n+\n+    // Start Delivery for a given topic subscriber\n+    virtual void startDelivery(const TopicSubscriber& ts,\n+                               const MessageHandlerCallbackPtr& handler,\n+                               const ClientMessageFilterPtr& filter);\n+\n+    // Stop Delivery for a given topic subscriber\n+    virtual void stopDelivery(const TopicSubscriber& ts);\n+\n+    // Has Subscription on the Channel\n+    virtual bool hasSubscription(const TopicSubscriber& ts);\n+\n+    // Close Subscription for a given topic subscriber\n+    virtual void asyncCloseSubscription(const TopicSubscriber& ts,\n+                                        const OperationCallbackPtr& callback);\n+\n+    // Consume message for a given topic subscriber\n+    virtual void consume(const TopicSubscriber& ts,\n+                         const MessageSeqId& messageSeqId);\n+\n+  protected:\n+    // Subscription channel disconnected: reconnect the subscription channel\n+    virtual void onChannelDisconnected(const DuplexChannelPtr& channel);\n+\n+    virtual void closeHandler();\n+\n+  private:\n+    inline const ActiveSubscriberPtr& getActiveSubscriber(const TopicSubscriber& ts) {\n+      boost::shared_lock<boost::shared_mutex> lock(subscribers_lock);\n+      return activeSubscribers[ts];\n+    }\n+\n+    typedef std::tr1::unordered_map<TopicSubscriber, ActiveSubscriberPtr, TopicSubscriberHash>\n+    ActiveSubscriberMap;\n+\n+    ActiveSubscriberMap activeSubscribers;\n+    boost::shared_mutex subscribers_lock;\n+\n+    const MultiplexDuplexChannelManagerPtr mChannelManager;\n+  };\n+\n+  typedef boost::shared_ptr<MultiplexSubscriberClientChannelHandler>\n+    MultiplexSubscriberClientChannelHandlerPtr;\n+\n+  //\n+  // Multiplex Duplex Channel Manager\n+  //\n+\n+  class MultiplexDuplexChannelManager : public DuplexChannelManager {\n+  public:\n+    explicit MultiplexDuplexChannelManager(const Configuration& conf);\n+    virtual ~MultiplexDuplexChannelManager();\n+\n+    bool storeSubscriptionChannelHandler(\n+      const TopicSubscriber& ts, const PubSubDataPtr& txn,\n+      const MultiplexSubscriberClientChannelHandlerPtr& handler);\n+\n+    bool removeSubscriptionChannelHandler(\n+      const TopicSubscriber& ts,\n+      const MultiplexSubscriberClientChannelHandlerPtr& handler);\n+\n+    bool removeSubscriptionChannelHandler(\n+      const HostAddress& addr,\n+      const MultiplexSubscriberClientChannelHandlerPtr& handler);\n+\n+    // Get the subscription channel handler for a given subscription\n+    virtual SubscriberClientChannelHandlerPtr\n+            getSubscriptionChannelHandler(const TopicSubscriber& ts);\n+\n+    // Close subscription for a given subscription\n+    virtual void asyncCloseSubscription(const TopicSubscriber& ts,\n+                                        const OperationCallbackPtr& callback);\n+\n+    virtual void handoverDelivery(const TopicSubscriber& ts,\n+                                  const MessageHandlerCallbackPtr& handler,\n+                                  const ClientMessageFilterPtr& filter);\n+\n+    // start the channel manager\n+    virtual void start();\n+    // close the channel manager\n+    virtual void close();\n+\n+  protected:\n+    virtual DuplexChannelPtr getSubscriptionChannel(const TopicSubscriber& ts,\n+                                                    const bool isResubscribeRequest);\n+\n+    virtual DuplexChannelPtr getSubscriptionChannel(const HostAddress& addr);\n+\n+    virtual DuplexChannelPtr createSubscriptionChannel(const HostAddress& addr);\n+\n+    virtual DuplexChannelPtr storeSubscriptionChannel(const DuplexChannelPtr& ch,\n+                                                      bool doConnect);\n+\n+  private:\n+    std::tr1::unordered_map<HostAddress, MultiplexSubscriberClientChannelHandlerPtr, HostAddressHash> subhandlers;\n+    boost::shared_mutex subhandlers_lock;\n+    // A inverse mapping for all available topic subscribers\n+    std::tr1::unordered_map<TopicSubscriber, MultiplexSubscriberClientChannelHandlerPtr, TopicSubscriberHash> subscribers;\n+    boost::shared_mutex subscribers_lock;\n+\n+    // Response Handlers for subscription requests\n+    ResponseHandlerMap subscriptionHandlers;\n+  };\n+\n+  // Subscribe Response Handler\n+\n+  class MultiplexSubscribeResponseHandler : public ResponseHandler {\n+  public:\n+    explicit MultiplexSubscribeResponseHandler(const MultiplexDuplexChannelManagerPtr& channelManager);\n+\n+    virtual ~MultiplexSubscribeResponseHandler() {}\n+\n+    virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                                const DuplexChannelPtr& channel);\n+\n+  private:\n+    void handleSuccessResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                               const MultiplexSubscriberClientChannelHandlerPtr& handler);\n+    const MultiplexDuplexChannelManagerPtr mChannelManager;\n+  };\n+\n+  // Callback delegation to remove subscription from a channel\n+\n+  class RemoveSubscriptionCallback : public ResponseCallback {\n+  public:\n+    explicit RemoveSubscriptionCallback(\n+      const MultiplexDuplexChannelManagerPtr& channelManager,\n+      const MultiplexSubscriberClientChannelHandlerPtr& handler,\n+      const TopicSubscriber& ts, const OperationCallbackPtr& callback);\n+\n+    virtual void operationComplete(const ResponseBody& response);\n+    virtual void operationFailed(const std::exception& exception);\n+  private:\n+    const MultiplexDuplexChannelManagerPtr channelManager;\n+    const MultiplexSubscriberClientChannelHandlerPtr handler;\n+    const TopicSubscriber topicSubscriber;\n+    const OperationCallbackPtr callback;\n+  };\n+\n+\n+} /* Namespace Hedwig */\n+\n+#endif"},{"sha":"3f59e1b1c01726e275070f1de06a702ae1bd2274","filename":"hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","status":"modified","additions":29,"deletions":4,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -61,8 +61,9 @@ void SimpleActiveSubscriber::queueMessage(const PubSubResponsePtr& m) {\n   }\n }\n \n-CloseSubscriptionCallback::CloseSubscriptionCallback(const ActiveSubscriberPtr& activeSubscriber)\n-  : activeSubscriber(activeSubscriber) {\n+CloseSubscriptionCallback::CloseSubscriptionCallback(const ActiveSubscriberPtr& activeSubscriber,\n+                                                     const SubscriptionEvent event)\n+  : activeSubscriber(activeSubscriber), event(event) {\n }\n \n void CloseSubscriptionCallback::operationComplete() {\n@@ -77,7 +78,7 @@ void CloseSubscriptionCallback::finish() {\n   // Process the disconnect logic after cleaning up\n   activeSubscriber->processEvent(activeSubscriber->getTopic(),\n                                  activeSubscriber->getSubscriberId(),\n-                                 TOPIC_MOVED);\n+                                 event);\n }\n \n SimpleSubscriberClientChannelHandler::SimpleSubscriberClientChannelHandler(\n@@ -97,6 +98,30 @@ bool SimpleSubscriberClientChannelHandler::setActiveSubscriber(\n   return true;\n }\n \n+void SimpleSubscriberClientChannelHandler::handleSubscriptionEvent(\n+  const TopicSubscriber& ts, const SubscriptionEvent event) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive on channel \" << channel.get()\n+                          << \" receiving subscription event \" << event);\n+    return;\n+  }\n+  if (!as->isResubscribeRequired() &&\n+      (TOPIC_MOVED == event || SUBSCRIPTION_FORCED_CLOSED == event)) {\n+    // topic has moved\n+    if (TOPIC_MOVED == event) {\n+      // remove topic mapping\n+      channelManager->clearHostForTopic(as->getTopic(), getChannel()->getHostAddress());\n+    }\n+    // close subscription to clean status\n+    OperationCallbackPtr closeCb(new CloseSubscriptionCallback(as, event));\n+    TopicSubscriber ts(as->getTopic(), as->getSubscriberId());\n+    channelManager->asyncCloseSubscription(ts, closeCb);\n+  } else {\n+    as->processEvent(ts.first, ts.second, event);\n+  }\n+}\n+\n void SimpleSubscriberClientChannelHandler::deliverMessage(const TopicSubscriber& ts,\n                                                           const PubSubResponsePtr& m) {\n   ActiveSubscriberPtr as = getActiveSubscriber();\n@@ -174,7 +199,7 @@ void SimpleSubscriberClientChannelHandler::onChannelDisconnected(\n   // Otherwise, we would cleanup the old channel then notify with a TOPIC_MOVED event\n   LOG4CXX_INFO(logger, \"Tell \" << *as << \" his channel \" << channel.get() << \" is disconnected.\");\n   if (!as->isResubscribeRequired()) {\n-    OperationCallbackPtr closeCb(new CloseSubscriptionCallback(as));\n+    OperationCallbackPtr closeCb(new CloseSubscriptionCallback(as, TOPIC_MOVED));\n     TopicSubscriber ts(as->getTopic(), as->getSubscriberId());\n     channelManager->asyncCloseSubscription(ts, closeCb);\n   } else {"},{"sha":"b73fa81ea703018e9996c200231aec0038658661","filename":"hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -48,13 +48,15 @@ namespace Hedwig {\n \n   class CloseSubscriptionCallback : public OperationCallback {\n   public:\n-    explicit CloseSubscriptionCallback(const ActiveSubscriberPtr& activeSubscriber);\n+    explicit CloseSubscriptionCallback(const ActiveSubscriberPtr& activeSubscriber,\n+                                       const SubscriptionEvent event);\n \n     virtual void operationComplete();\n     virtual void operationFailed(const std::exception& exception);\n   private:\n     void finish();\n     const ActiveSubscriberPtr activeSubscriber;\n+    const SubscriptionEvent event;\n   };\n \n   // Simple Subscription Channel Handler : One subscription per channel\n@@ -68,6 +70,9 @@ namespace Hedwig {\n     bool setActiveSubscriber(const PubSubDataPtr& op,\n                              const SubscriptionPreferencesPtr& preferences);\n \n+    virtual void handleSubscriptionEvent(const TopicSubscriber& ts,\n+                                         const SubscriptionEvent event);\n+\n     // Deliver a received message to given message handler\n     virtual void deliverMessage(const TopicSubscriber& ts,\n                                 const PubSubResponsePtr& m);"},{"sha":"dd71b66e475d8ff70012a86cd392569259be7306","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":64,"deletions":4,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -322,8 +322,15 @@ void ActiveSubscriber::processEvent(const std::string &topic, const std::string\n     return;\n   }\n   // resumbit the subscribe request\n-  if (TOPIC_MOVED == event) {\n+  switch (event) {\n+  case TOPIC_MOVED:\n+  case SUBSCRIPTION_FORCED_CLOSED:\n     resubscribe();\n+    break;\n+  default:\n+    LOG4CXX_ERROR(logger, \"Received unknown subscription event \" << event\n+                          << \" for (topic:\" << topic << \", subscriber:\" << subscriberId << \").\");\n+    break;\n   }\n }\n \n@@ -390,9 +397,21 @@ void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& cha\n     TopicSubscriber ts(m->topic(), m->subscriberid());\n     // dispatch the message to target topic subscriber.\n     deliverMessage(ts, m);\n-  } else {\n-    HedwigClientChannelHandler::messageReceived(channel, m);\n+    return;\n   }\n+  if (m->has_responsebody()) {\n+    const ResponseBody& respBody = m->responsebody();\n+    if (respBody.has_subscriptionevent()) {\n+      const SubscriptionEventResponse& eventResp =\n+        respBody.subscriptionevent(); \n+      // dispatch the event\n+      TopicSubscriber ts(m->topic(), m->subscriberid());\n+      handleSubscriptionEvent(ts, eventResp.event());\n+      return;\n+    }\n+  }\n+  \n+  HedwigClientChannelHandler::messageReceived(channel, m);\n }\n \n void SubscriberClientChannelHandler::doClose() {\n@@ -551,7 +570,10 @@ bool SubscriberImpl::hasSubscription(const std::string& topic, const std::string\n   // Get the subscriber channel handler\n   SubscriberClientChannelHandlerPtr handler =\n     channelManager->getSubscriptionChannelHandler(ts);\n-  return 0 != handler.get();\n+  if (!handler.get()) {\n+    return false;\n+  }\n+  return handler->hasSubscription(ts);\n }\n \n void SubscriberImpl::closeSubscription(const std::string& topic, const std::string& subscriberId) {\n@@ -620,6 +642,44 @@ void UnsubscribeResponseHandler::handleResponse(const PubSubResponsePtr& m,\n   }\n }\n \n+//\n+// CloseSubscription Response Handler\n+//\n+CloseSubscriptionResponseHandler::CloseSubscriptionResponseHandler(\n+  const DuplexChannelManagerPtr& channelManager) : ResponseHandler(channelManager) {}\n+\n+void CloseSubscriptionResponseHandler::handleResponse(\n+  const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+  const DuplexChannelPtr& channel) {\n+  switch (m->statuscode()) {\n+  case SUCCESS:\n+    if (m->has_responsebody()) {\n+      txn->getCallback()->operationComplete(m->responsebody());\n+    } else {\n+      txn->getCallback()->operationComplete(ResponseBody());\n+    }\n+    break;\n+  case SERVICE_DOWN:\n+    LOG4CXX_ERROR(logger, \"Server responsed with SERVICE_DOWN for \" << txn->getTxnId());\n+    txn->getCallback()->operationFailed(ServiceDownException());\n+    break;\n+  case CLIENT_ALREADY_SUBSCRIBED:\n+  case TOPIC_BUSY:\n+    txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    break;\n+  case CLIENT_NOT_SUBSCRIBED:\n+    txn->getCallback()->operationFailed(NotSubscribedException());\n+    break;\n+  case NOT_RESPONSIBLE_FOR_TOPIC:\n+    redirectRequest(m, txn, channel);\n+    break;\n+  default:\n+    LOG4CXX_ERROR(logger, \"Unexpected response \" << m->statuscode() << \" for \" << txn->getTxnId());\n+    txn->getCallback()->operationFailed(UnexpectedResponseException());\n+    break;\n+  }\n+}\n+\n std::ostream& Hedwig::operator<<(std::ostream& os, const ActiveSubscriber& subscriber) {\n   os << \"ActiveSubscriber(\" << &subscriber << \", topic:\" << subscriber.getTopic()\n      << \", subscriber:\" << subscriber.getSubscriberId() << \")\";"},{"sha":"0cdf5f17c295276f698b67734804c97f8e1b80ab","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -225,6 +225,9 @@ namespace Hedwig {\n                                    ResponseHandlerMap& handlers);\n     virtual ~SubscriberClientChannelHandler();\n \n+    virtual void handleSubscriptionEvent(const TopicSubscriber& ts,\n+                                         const SubscriptionEvent event) = 0;\n+\n     // Deliver a received message to given message handler\n     virtual void deliverMessage(const TopicSubscriber& ts,\n                                 const PubSubResponsePtr& m) = 0;\n@@ -319,6 +322,17 @@ namespace Hedwig {\n     virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n                                 const DuplexChannelPtr& channel);\n   };\n+\n+  // CloseSubscription Response Handler \n+\n+  class CloseSubscriptionResponseHandler : public ResponseHandler {\n+  public:\n+    explicit CloseSubscriptionResponseHandler(const DuplexChannelManagerPtr& channelManager);\n+    virtual ~CloseSubscriptionResponseHandler() {}\n+\n+    virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                                const DuplexChannelPtr& channel);\n+  };\n };\n \n #endif"},{"sha":"b5a7cc081b47b5c552e2ac21cf4282079efb6962","filename":"hedwig-client/src/main/cpp/lib/util.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/util.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/util.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -177,7 +177,7 @@ std::ostream& Hedwig::operator<<(std::ostream& os, const HostAddress& host) {\n   return os;\n }\n \n-std::ostream& Hedwig::operator<<(std::ostream& os, const TopicSubscriber& ts) {\n+std::ostream& std::operator<<(std::ostream& os, const TopicSubscriber& ts) {\n   os << \"(topic:\" << ts.first << \", subscriber:\" << ts.second << \")\";\n   return os;\n }"},{"sha":"a7741e2afc03a9d49c1da971c148841c672293a2","filename":"hedwig-client/src/main/cpp/lib/util.h","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/lib/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -38,8 +38,6 @@\n \n namespace Hedwig {\n   typedef std::pair<const std::string, const std::string> TopicSubscriber;\n-  // Help Function to print topicSubscriber\n-  std::ostream& operator<<(std::ostream& os, const TopicSubscriber& ts);\n \n   /**\n      Representation of a hosts address\n@@ -120,4 +118,11 @@ namespace Hedwig {\n   };\n };\n \n+// Since TopicSubscriber is an typedef of std::pair. so log4cxx would lookup 'operator<<'\n+// in std namespace.\n+namespace std {\n+  // Help Function to print topicSubscriber\n+  std::ostream& operator<<(std::ostream& os, const Hedwig::TopicSubscriber& ts);\n+};\n+\n #endif"},{"sha":"85e1f747fbd498e458a4186da1a3fceb67e6e665","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"modified","additions":25,"deletions":6,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -31,10 +31,17 @@ runtest() {\n \n     stop_cluster;\n     start_cluster;\n-    if [ \"z$1\" != \"z\" ]; then\n-      ../test/hedwigtest -s true\n+\n+    if [ \"z$2\" != \"z\" ]; then\n+      ../test/hedwigtest -s true -m true\n     else\n-      ../test/hedwigtest\n+      if [ \"z$1\" == \"zssl\" ]; then\n+        ../test/hedwigtest -s true\n+      elif [ \"z$1\" == \"zmultiplex\" ]; then\n+        ../test/hedwigtest -m true\n+      else\n+        ../test/hedwigtest\n+      fi\n     fi\n \n     RESULT=$?\n@@ -63,6 +70,13 @@ EOF\n     exit $RESULT\n }\n \n+runall() {\n+    runtest;\n+    runtest ssl;\n+    runtest multiplex;\n+    runtest ssl multiplex;\n+}\n+\n singletest() {\n     if [ \"z$HEDWIG_NETWORK_DELAY\" != \"z\" ]; then\n \tsetup_delays $HEDWIG_NETWORK_DELAY\n@@ -108,18 +122,23 @@ case \"$1\" in\n     simple-test)\n         runtest\n         ;;\n-    ssl-test)\n+    ssl-simple-test)\n         runtest ssl\n         ;;\n+    multiplex-test)\n+        runtest multiplex\n+        ;;\n+    ssl-multiplex-test)\n+        runtest ssl multiplex\n+        ;;\n     setup-delays)\n \tsetup_delays $2\n \t;;\n     clear-delays)\n \tclear_delays\n \t;;\n     all)\n-\truntest\n-\truntest ssl\n+        runall\n \t;;\n     singletest)\n \tsingletest $2"},{"sha":"d55100cc584e7752daa19330fc9e79a1405beb60","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -18,7 +18,7 @@\n \n if HAVE_GTEST\n bin_PROGRAMS = hedwigtest\n-hedwigtest_SOURCES = main.cpp utiltest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp messagefiltertest.cpp\n+hedwigtest_SOURCES = main.cpp utiltest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp messagefiltertest.cpp throttledeliverytest.cpp multiplextest.cpp\n hedwigtest_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS) $(GTEST_CPPFLAGS) $(BOOST_CPPFLAGS)\n hedwigtest_CXXFLAGS = $(GTEST_CXXFLAGS)\n hedwigtest_LDADD = $(DEPS_LIBS) $(GTEST_LIBS) -L$(top_builddir)/lib -lhedwig01\n@@ -27,12 +27,18 @@ hedwigtest_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_TH\n check: hedwigtest\n \tbash ../scripts/tester.sh all\n \n-sslcheck: hedwigtest\n-\tbash ../scripts/tester.sh ssl-test\n+simplesslcheck: hedwigtest\n+\tbash ../scripts/tester.sh ssl-simple-test\n \n simplecheck: hedwigtest\n \tbash ../scripts/tester.sh simple-test\n \n+multiplexsslcheck: hedwigtest\n+\tbash ../scripts/tester.sh ssl-multiplex-test\n+\n+multiplexcheck: hedwigtest\n+\tbash ../scripts/tester.sh multiplex-test\n+\n else\n check:\n \t@echo \"\\n\\nYou haven't configured with gtest. Run the ./configure command with --enable-gtest=<path_to_gtest>\""},{"sha":"7c08c9765b4058e53bb79e7cc9a763e070f07fa4","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -36,6 +36,7 @@\n \n bool TestServerConfiguration::isSSL = false;\n std::string TestServerConfiguration::certFile = \"\";\n+bool TestServerConfiguration::multiplexing = false;\n \n int main( int argc, char **argv)\n {\n@@ -54,7 +55,7 @@ int main( int argc, char **argv)\n \n   // Enable SSL for testing\n   int opt;\n-  while((opt = getopt(argc,argv,\"s:c:\")) > 0) {\n+  while((opt = getopt(argc,argv,\"s:c:m:\")) > 0) {\n     switch(opt) {\n     case 's':\n       if (std::string(optarg) == \"true\") {\n@@ -64,6 +65,14 @@ int main( int argc, char **argv)\n         TestServerConfiguration::isSSL = false;\n       }\n       break;\n+    case 'm':\n+      if (std::string(optarg) == \"true\") {\n+        std::cout << \"run in multiplexing mode ...\" << std::endl;\n+        TestServerConfiguration::multiplexing = true;\n+      } else {\n+        TestServerConfiguration::multiplexing = false;\n+      }\n+      break;\n     case 'c':\n       std::cout << \"use cert file :\" << optarg << std::endl;\n       TestServerConfiguration::certFile = std::string(optarg);"},{"sha":"9315e72a2fae3f6ec3f8bbe9983a487ced383223","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -74,7 +74,7 @@ class MessageBoundOrderCheckingMessageHandlerCallback : public Hedwig::MessageHa\n };\n \n void sendXExpectLastY(Hedwig::Publisher& pub, Hedwig::Subscriber& sub, const std::string& topic, \n-\t\t      const std::string& subid, int X, int Y) {\n+                      const std::string& subid, int X, int Y) {\n   for (int i = 0; i < X;) {\n     std::stringstream oss;\n     oss << i;"},{"sha":"80043174a3ca0483165744884ee02bdcf0d81753","filename":"hedwig-client/src/main/cpp/test/multiplextest.cpp","status":"added","additions":418,"deletions":0,"changes":418,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/multiplextest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/multiplextest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/multiplextest.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include \"gtest/gtest.h\"\n+\n+#include \"../lib/clientimpl.h\"\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <stdexcept>\n+#include <pthread.h>\n+\n+#include <log4cxx/logger.h>\n+\n+#include \"util.h\"\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+class MultiplexConfiguration : public TestServerConfiguration {\n+public:\n+  MultiplexConfiguration() : TestServerConfiguration() {}\n+  \n+  virtual bool getBool(const std::string& key, bool defaultVal) const {\n+    if (key == Configuration::SUBSCRIBER_AUTOCONSUME) {\n+      return false;\n+    } else if (key == Configuration::ENABLE_MULTIPLEXING) {    \n+      return true;\n+    } else {\n+      return TestServerConfiguration::getBool(key, defaultVal);\n+    }\n+  }\n+};\n+    \n+class MultiplexMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n+public:\n+  MultiplexMessageHandlerCallback(Hedwig::Subscriber& sub,\n+                                  const int start, const int numMsgsAtFirstRun,\n+                                  const bool receiveSecondRun,\n+                                  const int numMsgsAtSecondRun)\n+    : sub(sub), next(start), start(start), numMsgsAtFirstRun(numMsgsAtFirstRun),\n+      numMsgsAtSecondRun(numMsgsAtSecondRun), receiveSecondRun(receiveSecondRun) {\n+  }\n+\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    const int value = atoi(msg.body().c_str());\n+    LOG4CXX_DEBUG(logger, \"received message \" << value);\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    if (value == next) {\n+      ++next;\n+    } else {\n+      LOG4CXX_ERROR(logger, \"Did not receive expected value \" << next << \", got \" << value);\n+      next = 0;\n+      firstLatch.setSuccess(false);\n+      firstLatch.notify();\n+      secondLatch.setSuccess(false);\n+      secondLatch.notify();\n+    }\n+    if (numMsgsAtFirstRun + start == next) {\n+      firstLatch.setSuccess(true);\n+      firstLatch.notify();\n+    }\n+    if (receiveSecondRun) {\n+      if (numMsgsAtFirstRun + numMsgsAtSecondRun + start == next) {\n+        secondLatch.setSuccess(true);\n+        secondLatch.notify();\n+      }\n+    } else {\n+      if (numMsgsAtFirstRun + start + 1 == next) {\n+        secondLatch.setSuccess(true);\n+        secondLatch.notify();\n+      }\n+    }\n+    callback->operationComplete();\n+    sub.consume(topic, subscriberId, msg.msgid());\n+  }\n+\n+  void checkFirstRun() {\n+    firstLatch.timed_wait(10000);\n+    ASSERT_TRUE(firstLatch.wasSuccess());\n+    ASSERT_EQ(numMsgsAtFirstRun + start, next);\n+  }\n+\n+  void checkSecondRun() {\n+    if (receiveSecondRun) {\n+      secondLatch.timed_wait(10000);\n+      ASSERT_TRUE(secondLatch.wasSuccess());\n+      ASSERT_EQ(numMsgsAtFirstRun + numMsgsAtSecondRun + start, next);\n+    } else {\n+      secondLatch.timed_wait(3000);\n+      ASSERT_TRUE(!secondLatch.wasSuccess());\n+      ASSERT_EQ(numMsgsAtFirstRun + start, next);\n+    }\n+  }\n+\n+protected:\n+  Hedwig::Subscriber& sub;\n+  boost::mutex mutex;\n+  int next;\n+  const int start;\n+  const int numMsgsAtFirstRun;\n+  const int numMsgsAtSecondRun;\n+  SimpleWaitCondition firstLatch;\n+  SimpleWaitCondition secondLatch;\n+  const bool receiveSecondRun;\n+};\n+\n+class MultiplexThrottleDeliveryMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n+public:\n+  MultiplexThrottleDeliveryMessageHandlerCallback(Hedwig::Subscriber& sub,\n+                                         const int start, const int numMsgs,\n+                                         const bool enableThrottle,\n+                                         const int numMsgsThrottle)\n+    : sub(sub), next(start), start(start), numMsgs(numMsgs),\n+      numMsgsThrottle(numMsgsThrottle), enableThrottle(enableThrottle) {\n+  }\n+\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    const int value = atoi(msg.body().c_str());\n+    LOG4CXX_DEBUG(logger, \"received message \" << value);\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    if (value == next) {\n+      ++next;\n+    } else {\n+      LOG4CXX_ERROR(logger, \"Did not receive expected value \" << next << \", got \" << value);\n+      next = 0;\n+      throttleLatch.setSuccess(false);\n+      throttleLatch.notify();\n+      nonThrottleLatch.setSuccess(false);\n+      nonThrottleLatch.notify();\n+    }\n+    if (next == numMsgsThrottle + start + 1) {\n+      throttleLatch.setSuccess(true);\n+      throttleLatch.notify();\n+    } else if (next == numMsgs + 1) {\n+      nonThrottleLatch.setSuccess(true);\n+      nonThrottleLatch.notify();\n+    }\n+    callback->operationComplete();\n+    if (enableThrottle) {\n+      if (next > numMsgsThrottle + start) {\n+        sub.consume(topic, subscriberId, msg.msgid());\n+      }\n+    } else {\n+      sub.consume(topic, subscriberId, msg.msgid());\n+    }\n+  }\n+\n+  void checkThrottle() {\n+    if (enableThrottle) {\n+      throttleLatch.timed_wait(3000);\n+      ASSERT_TRUE(!throttleLatch.wasSuccess());\n+      ASSERT_EQ(numMsgsThrottle + start, next);\n+    } else {\n+      throttleLatch.timed_wait(10000);\n+      ASSERT_TRUE(throttleLatch.wasSuccess());\n+      nonThrottleLatch.timed_wait(10000);\n+      ASSERT_TRUE(nonThrottleLatch.wasSuccess());\n+      ASSERT_EQ(numMsgs + start, next);\n+    }\n+  }\n+\n+  void checkAfterThrottle() {\n+    if (enableThrottle) {\n+      nonThrottleLatch.timed_wait(10000);\n+      ASSERT_TRUE(nonThrottleLatch.wasSuccess());\n+      ASSERT_EQ(numMsgs + start, next);\n+    }\n+  }\n+\n+protected:\n+  Hedwig::Subscriber& sub;\n+  boost::mutex mutex;\n+  int next;\n+  const int start;\n+  const int numMsgs;\n+  const int numMsgsThrottle;\n+  const bool enableThrottle;\n+  SimpleWaitCondition throttleLatch;\n+  SimpleWaitCondition nonThrottleLatch;\n+};\n+\n+TEST(MultiplexTest, testStopDelivery) {\n+  Hedwig::Configuration* conf = new MultiplexConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  const int numMsgs = 20;\n+  std::string topic1 = \"testStopDelivery-1\";\n+  std::string subid1 = \"mysubid-1\";\n+  std::string topic2 = \"testStopDelivery-2\";\n+  std::string subid2 = \"mysubid-2\";\n+\n+  MultiplexMessageHandlerCallback * cb11 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, true, numMsgs);\n+  MultiplexMessageHandlerCallback * cb12 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, false, 0);\n+  MultiplexMessageHandlerCallback * cb21 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, false, 0);\n+  MultiplexMessageHandlerCallback * cb22 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, true, numMsgs);\n+\n+  Hedwig::MessageHandlerCallbackPtr handler11(cb11);\n+  Hedwig::MessageHandlerCallbackPtr handler12(cb12);\n+  Hedwig::MessageHandlerCallbackPtr handler21(cb21);\n+  Hedwig::MessageHandlerCallbackPtr handler22(cb22);\n+\n+  sub.subscribe(topic1, subid1, Hedwig::SubscribeRequest::CREATE);\n+  sub.subscribe(topic1, subid2, Hedwig::SubscribeRequest::CREATE);\n+  sub.subscribe(topic2, subid1, Hedwig::SubscribeRequest::CREATE);\n+  sub.subscribe(topic2, subid2, Hedwig::SubscribeRequest::CREATE);\n+\n+  // start deliveries\n+  sub.startDelivery(topic1, subid1, handler11);\n+  sub.startDelivery(topic1, subid2, handler12);\n+  sub.startDelivery(topic2, subid1, handler21);\n+  sub.startDelivery(topic2, subid2, handler22);\n+\n+  // first publish\n+  for (int i = 1; i <= numMsgs; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic1, oss.str());\n+    pub.publish(topic2, oss.str());\n+  }\n+\n+  // check first run\n+  cb11->checkFirstRun();\n+  cb12->checkFirstRun();\n+  cb21->checkFirstRun();\n+  cb22->checkFirstRun();\n+\n+  // stop delivery for <topic1, subscriber2> and <topic2, subscriber1>\n+  sub.stopDelivery(topic1, subid2);\n+  sub.stopDelivery(topic2, subid1);\n+\n+  // second publish\n+  for (int i = numMsgs+1; i <= 2*numMsgs; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic1, oss.str());\n+    pub.publish(topic2, oss.str());\n+  }\n+\n+  cb11->checkSecondRun();\n+  cb12->checkSecondRun();\n+  cb21->checkSecondRun();\n+  cb22->checkSecondRun();\n+}\n+\n+TEST(MultiplexTest, testCloseSubscription) {\n+  Hedwig::Configuration* conf = new MultiplexConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  const int numMsgs = 20;\n+  std::string topic1 = \"testCloseSubscription-1\";\n+  std::string subid1 = \"mysubid-1\";\n+  std::string topic2 = \"testCloseSubscription-2\";\n+  std::string subid2 = \"mysubid-2\";\n+\n+  MultiplexMessageHandlerCallback * cb11 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, true, numMsgs);\n+  MultiplexMessageHandlerCallback * cb12 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, false, 0);\n+  MultiplexMessageHandlerCallback * cb21 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, false, 0);\n+  MultiplexMessageHandlerCallback * cb22 =\n+    new MultiplexMessageHandlerCallback(sub, 1, numMsgs, true, numMsgs);\n+\n+  Hedwig::MessageHandlerCallbackPtr handler11(cb11);\n+  Hedwig::MessageHandlerCallbackPtr handler12(cb12);\n+  Hedwig::MessageHandlerCallbackPtr handler21(cb21);\n+  Hedwig::MessageHandlerCallbackPtr handler22(cb22);\n+\n+  sub.subscribe(topic1, subid1, Hedwig::SubscribeRequest::CREATE);\n+  sub.subscribe(topic1, subid2, Hedwig::SubscribeRequest::CREATE);\n+  sub.subscribe(topic2, subid1, Hedwig::SubscribeRequest::CREATE);\n+  sub.subscribe(topic2, subid2, Hedwig::SubscribeRequest::CREATE);\n+\n+  // start deliveries\n+  sub.startDelivery(topic1, subid1, handler11);\n+  sub.startDelivery(topic1, subid2, handler12);\n+  sub.startDelivery(topic2, subid1, handler21);\n+  sub.startDelivery(topic2, subid2, handler22);\n+\n+  // first publish\n+  for (int i = 1; i <= numMsgs; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic1, oss.str());\n+    pub.publish(topic2, oss.str());\n+  }\n+\n+  // check first run\n+  cb11->checkFirstRun();\n+  cb12->checkFirstRun();\n+  cb21->checkFirstRun();\n+  cb22->checkFirstRun();\n+\n+  // close subscription for <topic1, subscriber2> and <topic2, subscriber1>\n+  sub.closeSubscription(topic1, subid2);\n+  sub.closeSubscription(topic2, subid1);\n+\n+  // second publish\n+  for (int i = numMsgs+1; i <= 2*numMsgs; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic1, oss.str());\n+    pub.publish(topic2, oss.str());\n+  }\n+\n+  cb11->checkSecondRun();\n+  cb12->checkSecondRun();\n+  cb21->checkSecondRun();\n+  cb22->checkSecondRun();\n+}\n+\n+TEST(MultiplexTest, testThrottle) {\n+  Hedwig::Configuration* conf = new MultiplexConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  const int numMsgs = 10;\n+  std::string topic1 = \"testThrottle-1\";\n+  std::string subid1 = \"mysubid-1\";\n+  std::string topic2 = \"testThrottle-2\";\n+  std::string subid2 = \"mysubid-2\";\n+\n+  MultiplexThrottleDeliveryMessageHandlerCallback * cb11 =\n+    new MultiplexThrottleDeliveryMessageHandlerCallback(sub, 1, 3*numMsgs, false, numMsgs);\n+  MultiplexThrottleDeliveryMessageHandlerCallback * cb12 =\n+    new MultiplexThrottleDeliveryMessageHandlerCallback(sub, 1, 3*numMsgs, true, numMsgs);\n+  MultiplexThrottleDeliveryMessageHandlerCallback * cb21 =\n+    new MultiplexThrottleDeliveryMessageHandlerCallback(sub, 1, 3*numMsgs, true, numMsgs);\n+  MultiplexThrottleDeliveryMessageHandlerCallback * cb22 =\n+    new MultiplexThrottleDeliveryMessageHandlerCallback(sub, 1, 3*numMsgs, false, numMsgs);\n+\n+  Hedwig::MessageHandlerCallbackPtr handler11(cb11);\n+  Hedwig::MessageHandlerCallbackPtr handler12(cb12);\n+  Hedwig::MessageHandlerCallbackPtr handler21(cb21);\n+  Hedwig::MessageHandlerCallbackPtr handler22(cb22);\n+\n+  Hedwig::SubscriptionOptions options;\n+  options.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  options.set_messagewindowsize(numMsgs);\n+\n+  sub.subscribe(topic1, subid1, options);\n+  sub.subscribe(topic1, subid2, options);\n+  sub.subscribe(topic2, subid1, options);\n+  sub.subscribe(topic2, subid2, options);\n+\n+  // start deliveries\n+  sub.startDelivery(topic1, subid1, handler11);\n+  sub.startDelivery(topic1, subid2, handler12);\n+  sub.startDelivery(topic2, subid1, handler21);\n+  sub.startDelivery(topic2, subid2, handler22);\n+\n+  // first publish\n+  for (int i = 1; i <= 3*numMsgs; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic1, oss.str());\n+    pub.publish(topic2, oss.str());\n+  }\n+\n+  // check first run\n+  cb11->checkThrottle();\n+  cb12->checkThrottle();\n+  cb21->checkThrottle();\n+  cb22->checkThrottle();\n+\n+  // consume messages to not throttle them\n+  for (int i=1; i<=numMsgs; i++) {\n+    Hedwig::MessageSeqId msgid;\n+    msgid.set_localcomponent(i);\n+    sub.consume(topic1, subid2, msgid);\n+    sub.consume(topic2, subid1, msgid);\n+  }\n+\n+  cb11->checkAfterThrottle();\n+  cb12->checkAfterThrottle();\n+  cb21->checkAfterThrottle();\n+  cb22->checkAfterThrottle();\n+}"},{"sha":"3ee736a1a4cd0e1c9a1aecc29e78eb1e76b2a5f4","filename":"hedwig-client/src/main/cpp/test/subscribetest.cpp","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/subscribetest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/subscribetest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/subscribetest.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -216,7 +216,8 @@ TEST(SubscribeTest, testAsyncSubcribeForceAttach) {\n \n   SimpleWaitCondition* lcond1 = new SimpleWaitCondition();\n   std::auto_ptr<SimpleWaitCondition> lcond1ptr(lcond1);\n-  Hedwig::SubscriptionListenerPtr listener1(new TestSubscriptionListener(lcond1));\n+  Hedwig::SubscriptionListenerPtr listener1(\n+    new TestSubscriptionListener(lcond1, Hedwig::SUBSCRIPTION_FORCED_CLOSED));\n \n   Hedwig::SubscriptionOptions options;\n   options.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n@@ -235,7 +236,8 @@ TEST(SubscribeTest, testAsyncSubcribeForceAttach) {\n   std::auto_ptr<SimpleWaitCondition> cond2ptr(cond2);\n   Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n \n-  Hedwig::SubscriptionListenerPtr listener2(new TestSubscriptionListener(0));\n+  Hedwig::SubscriptionListenerPtr listener2(\n+    new TestSubscriptionListener(0, Hedwig::SUBSCRIPTION_FORCED_CLOSED));\n \n   sub2.addSubscriptionListener(listener2);\n "},{"sha":"9dd0d9ff91b6b8d88dc7d5eeb16aef5655e421a6","filename":"hedwig-client/src/main/cpp/test/throttledeliverytest.cpp","status":"added","additions":159,"deletions":0,"changes":159,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/throttledeliverytest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/throttledeliverytest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/throttledeliverytest.cpp?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -0,0 +1,159 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include \"gtest/gtest.h\"\n+\n+#include \"../lib/clientimpl.h\"\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <stdexcept>\n+#include <pthread.h>\n+\n+#include <log4cxx/logger.h>\n+\n+#include \"util.h\"\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+class ThrottleDeliveryConfiguration : public TestServerConfiguration {\n+public:\n+  ThrottleDeliveryConfiguration() : TestServerConfiguration() {}\n+  \n+  virtual bool getBool(const std::string& key, bool defaultVal) const {\n+    if (key == Configuration::SUBSCRIBER_AUTOCONSUME) {\n+      return false;\n+    } else {\n+      return TestServerConfiguration::getBool(key, defaultVal);\n+    }\n+  }\n+};\n+    \n+class ThrottleDeliveryMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n+public:\n+  ThrottleDeliveryMessageHandlerCallback(Hedwig::Subscriber& sub,\n+                                         const int start, const int end,\n+                                         const int expectedToThrottle,\n+                                         SimpleWaitCondition& throttleLatch,\n+                                         SimpleWaitCondition& nonThrottleLatch)\n+    : sub(sub), next(start), end(end), expectedToThrottle(expectedToThrottle),\n+      throttleLatch(throttleLatch), nonThrottleLatch(nonThrottleLatch) {\n+  }\n+\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    const int value = atoi(msg.body().c_str());\n+    LOG4CXX_DEBUG(logger, \"received message \" << value);\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    if (value == next) {\n+      ++next;\n+    } else {\n+      LOG4CXX_ERROR(logger, \"Did not receive expected value \" << next << \", got \" << value);\n+      next = 0;\n+      throttleLatch.setSuccess(false);\n+      throttleLatch.notify();\n+      nonThrottleLatch.setSuccess(false);\n+      nonThrottleLatch.notify();\n+    }\n+    if (next == expectedToThrottle + 2) {\n+      throttleLatch.setSuccess(true);\n+      throttleLatch.notify();\n+    } else if (next == end + 1) {\n+      nonThrottleLatch.setSuccess(true);\n+      nonThrottleLatch.notify();\n+    }\n+    callback->operationComplete();\n+    if (next > expectedToThrottle + 1) {\n+      sub.consume(topic, subscriberId, msg.msgid());\n+    }\n+  }\n+\n+  int nextExpected() {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    return next;\n+  }\n+\n+protected:\n+  Hedwig::Subscriber& sub;\n+  boost::mutex mutex;\n+  int next;\n+  const int end;\n+  const int expectedToThrottle;\n+  SimpleWaitCondition& throttleLatch;\n+  SimpleWaitCondition& nonThrottleLatch;\n+};\n+\n+void throttleX(Hedwig::Publisher& pub, Hedwig::Subscriber& sub,\n+               const std::string& topic, const std::string& subid, int X) {\n+  for (int i = 1; i <= 3*X; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic, oss.str());\n+  }\n+\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::ATTACH);\n+\n+  SimpleWaitCondition throttleLatch, nonThrottleLatch;\n+\n+  ThrottleDeliveryMessageHandlerCallback* cb =\n+    new ThrottleDeliveryMessageHandlerCallback(sub, 1, 3*X, X, throttleLatch,\n+                                               nonThrottleLatch);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  sub.startDelivery(topic, subid, handler);\n+\n+  throttleLatch.timed_wait(3000);\n+  ASSERT_TRUE(!throttleLatch.wasSuccess());\n+  ASSERT_EQ(X + 1, cb->nextExpected());\n+\n+  // consume messages to not throttle it\n+  for (int i=1; i<=X; i++) {\n+    Hedwig::MessageSeqId msgid;\n+    msgid.set_localcomponent(i);\n+    sub.consume(topic, subid, msgid);\n+  }\n+\n+  nonThrottleLatch.timed_wait(10000);\n+  ASSERT_TRUE(nonThrottleLatch.wasSuccess());\n+  ASSERT_EQ(3*X + 1, cb->nextExpected());\n+\n+  sub.stopDelivery(topic, subid);\n+  sub.closeSubscription(topic, subid);\n+}\n+\n+TEST(ThrottleDeliveryTest, testThrottleDelivery) {\n+  Hedwig::Configuration* conf = new ThrottleDeliveryConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  int throttleValue = 10;\n+  std::string topic = \"testThrottleDelivery\";\n+  std::string subid = \"testSubId\";\n+  Hedwig::SubscriptionOptions options;\n+  options.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  options.set_messagewindowsize(throttleValue);\n+  sub.subscribe(topic, subid, options);\n+  sub.closeSubscription(topic, subid);\n+  throttleX(pub, sub, topic, subid, throttleValue);\n+}"},{"sha":"f4436c3a9ae5ea53d30e603a7164ced262d8a6bf","filename":"hedwig-client/src/main/cpp/test/util.h","status":"modified","additions":19,"deletions":3,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/2dd4ff7d82d7dc95eb959ad803164f2a5df96968/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=2dd4ff7d82d7dc95eb959ad803164f2a5df96968","patch":"@@ -30,7 +30,7 @@ static log4cxx::LoggerPtr utillogger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE_\n class SimpleWaitCondition {\n public:\n  SimpleWaitCondition() : flag(false), success(false) {};\n-  ~SimpleWaitCondition() { wait(); }\n+  ~SimpleWaitCondition() {}\n \n   void wait() {\n     boost::unique_lock<boost::mutex> lock(mut);\n@@ -40,6 +40,16 @@ class SimpleWaitCondition {\n     }\n   }\n \n+  void timed_wait(uint64_t milliseconds) {\n+    boost::mutex::scoped_lock lock(mut);\n+    if (!flag) {\n+      LOG4CXX_DEBUG(utillogger, \"wait for \" << milliseconds << \" ms.\");\n+      if (!cond.timed_wait(lock, boost::posix_time::milliseconds(milliseconds))) {\n+        LOG4CXX_DEBUG(utillogger, \"Timeout wait for \" << milliseconds << \" ms.\");\n+      }\n+    }\n+  }\n+\n   void notify() {\n     {\n       boost::lock_guard<boost::mutex> lock(mut);\n@@ -115,7 +125,9 @@ class TestCallback : public Hedwig::OperationCallback {\n \n class TestSubscriptionListener : public Hedwig::SubscriptionListener {\n public:\n-  TestSubscriptionListener(SimpleWaitCondition* cond) : cond(cond) {\n+  TestSubscriptionListener(SimpleWaitCondition* cond,\n+                           const Hedwig::SubscriptionEvent event)\n+    : cond(cond), expectedEvent(event) {\n     LOG4CXX_DEBUG(utillogger, \"Created TestSubscriptionListener \" << this);\n   }\n \n@@ -125,7 +137,7 @@ class TestSubscriptionListener : public Hedwig::SubscriptionListener {\n                             const Hedwig::SubscriptionEvent event) {\n     LOG4CXX_DEBUG(utillogger, \"Received event \" << event << \" for (topic:\" << topic\n                               << \", subscriber:\" << subscriberId << \") from listener \" << this);\n-    if (Hedwig::TOPIC_MOVED == event) {\n+    if (expectedEvent == event) {\n       if (cond) {\n         cond->setSuccess(true);\n         cond->notify();\n@@ -135,6 +147,7 @@ class TestSubscriptionListener : public Hedwig::SubscriptionListener {\n \n private:\n   SimpleWaitCondition *cond;\n+  const Hedwig::SubscriptionEvent expectedEvent;\n };\n \n class TestServerConfiguration : public Hedwig::Configuration {\n@@ -170,13 +183,16 @@ class TestServerConfiguration : public Hedwig::Configuration {\n   virtual bool getBool(const std::string& key, bool defaultVal) const {\n     if (key == Configuration::SSL_ENABLED) {\n       return isSSL;\n+    } else if (key == Configuration::ENABLE_MULTIPLEXING) {    \n+      return multiplexing;\n     }\n     return defaultVal;\n   }\n public:\n   // for testing\n   static bool isSSL;\n   static std::string certFile;\n+  static bool multiplexing;\n private:\n   const std::string address;\n   const int syncTimeout;"}]}

