{"sha":"30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","node_id":"MDY6Q29tbWl0MTU3NTk1NjozMGM2OGIwYmViZmYxZTBhMDEyZGQ4MWU4ZjA1ZWJiZjgzYjRmZjVm","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T07:13:07Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T07:13:07Z"},"message":"BOOKKEEPER-193: Ledger is garbage collected by mistake. (sijie, ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1307725 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c05919c31a2d605ed4643776e4491811c4661705","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c05919c31a2d605ed4643776e4491811c4661705"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","html_url":"https://github.com/apache/bookkeeper/commit/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4b32e049dca4a1a8eea4bfb2325aee2de629b132","url":"https://api.github.com/repos/apache/bookkeeper/commits/4b32e049dca4a1a8eea4bfb2325aee2de629b132","html_url":"https://github.com/apache/bookkeeper/commit/4b32e049dca4a1a8eea4bfb2325aee2de629b132"}],"stats":{"total":482,"additions":423,"deletions":59},"files":[{"sha":"39d2a5568fce6796510c1355a57a0cbf1dc4ca6a","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -70,6 +70,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-166: Bookie will not recover its journal if the length prefix of an entry is truncated (ivank)\n \n+        BOOKKEEPER-193: Ledger is garbage collected by mistake. (sijie, ivank via sijie)\n+\n       hedwig-server/\n       \n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)"},{"sha":"8fd7df8568e5346a095bb27edbf66a3616cbda5c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"modified","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -21,6 +21,8 @@\n import java.io.IOException;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import java.util.Map;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager;\n@@ -252,4 +254,25 @@ protected boolean isSpecialZnode(String znode) {\n     @Override\n     public void close() {\n     }\n+\n+    /**\n+     * Do garbage collecting comparing hosted ledgers and zk ledgers\n+     *\n+     * @param gc\n+     *          Garbage collector to do garbage collection when found inactive/deleted ledgers\n+     * @param bkActiveLedgers\n+     *          Active ledgers hosted in bookie server\n+     * @param zkAllLedgers\n+     *          All ledgers stored in zookeeper\n+     */\n+    void doGc(GarbageCollector gc, Map<Long, Boolean> bkActiveLedgers, Set<Long> zkAllLedgers) {\n+        // remove any active ledgers that doesn't exist in zk\n+        for (Long bkLid : bkActiveLedgers.keySet()) {\n+            if (!zkAllLedgers.contains(bkLid)) {\n+                // remove it from current active ledger\n+                bkActiveLedgers.remove(bkLid);\n+                gc.gc(bkLid);\n+            }\n+        }\n+    }\n }"},{"sha":"1300974382d34066b8935cf399f0ad6a1455e008","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"modified","additions":7,"deletions":28,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -19,9 +19,9 @@\n  */\n \n import java.io.IOException;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n \n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n@@ -67,7 +67,7 @@\n     // path prefix to store ledger znodes\n     private final String ledgerPrefix;\n     // hash map to store all active ledger ids\n-    private ConcurrentMap<Long, Boolean> activeLedgers;\n+    private SnapshotMap<Long, Boolean> activeLedgers;\n \n     /**\n      * Constructor\n@@ -91,7 +91,7 @@ public FlatLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n         }\n \n         ledgerPrefix = ledgerRootPath + \"/\" + LEDGER_NODE_PREFIX;\n-        activeLedgers = new ConcurrentHashMap<Long, Boolean>();\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n     }\n \n     @Override\n@@ -158,8 +158,9 @@ public boolean containsActiveLedger(long ledgerId) {\n     @Override\n     public void garbageCollectLedgers(GarbageCollector gc) {\n         try {\n-            HashSet<Long> zkActiveLedgers = getLedgersInSingleNode(ledgerRootPath);\n-            ConcurrentMap<Long, Boolean> bkActiveLedgers = activeLedgers;\n+            // create a snapshot first\n+            Map<Long, Boolean> bkActiveLedgers = activeLedgers.snapshot();\n+            Set<Long> zkActiveLedgers = getLedgersInSingleNode(ledgerRootPath);\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"All active ledgers from ZK: \" + zkActiveLedgers);\n                 LOG.debug(\"Current active ledgers from Bookie: \" + bkActiveLedgers.keySet());\n@@ -171,26 +172,4 @@ public void garbageCollectLedgers(GarbageCollector gc) {\n             LOG.warn(\"Interrupted during garbage collecting ledgers from \" + ledgerRootPath, inte);\n         }\n     }\n-\n-    /**\n-     * Do garbage collecting comparing hosted ledgers and zk ledgers\n-     *\n-     * @param gc\n-     *          Garbage collector to do garbage collection when found inactive/deleted ledgers\n-     * @param bkActiveLedgers\n-     *          Active ledgers hosted in bookie server\n-     * @param zkAllLedgers\n-     *          All ledgers stored in zookeeper\n-     */\n-    void doGc(GarbageCollector gc, ConcurrentMap<Long, Boolean> bkActiveLedgers, HashSet<Long> zkAllLedgers) {\n-        // remove any active ledgers that doesn't exist in zk\n-        for (Long bkLid : bkActiveLedgers.keySet()) {\n-            if (!zkAllLedgers.contains(bkLid)) {\n-                // remove it from current active ledger\n-                bkActiveLedgers.remove(bkLid);\n-                gc.gc(bkLid);\n-            }\n-        }\n-    }\n-\n }"},{"sha":"b573181beb49c16b1879bfea469f3430869c908b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":15,"deletions":31,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -19,11 +19,12 @@\n  */\n \n import java.io.IOException;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentSkipListMap;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.Set;\n+import java.util.Map;\n+import java.util.NavigableMap;\n import java.util.HashSet;\n import java.util.List;\n \n@@ -92,7 +93,7 @@\n     // Path to generate global id\n     private final String idGenPath;\n     // A sorted map to stored all active ledger ids\n-    private ConcurrentSkipListMap<Long, Boolean> activeLedgers;\n+    private SnapshotMap<Long, Boolean> activeLedgers;\n \n     // we use this to prevent long stack chains from building up in callbacks\n     ScheduledExecutorService scheduler;\n@@ -119,7 +120,8 @@ public HierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n         }\n \n         this.idGenPath = ledgerRootPath + IDGENERATION_PREFIX;\n-        this.activeLedgers = new ConcurrentSkipListMap<Long, Boolean>();\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n+\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Using HierarchicalLedgerManager with root path : \" + ledgerRootPath);\n@@ -365,6 +367,8 @@ public boolean containsActiveLedger(long ledgerId) {\n \n     @Override\n     public void garbageCollectLedgers(GarbageCollector gc) {\n+        // create a snapshot before garbage collection\n+        NavigableMap<Long, Boolean> snapshot = activeLedgers.snapshot();\n         try {\n             List<String> l1Nodes = zk.getChildren(ledgerRootPath, null);\n             for (String l1Node : l1Nodes) {\n@@ -374,7 +378,7 @@ public void garbageCollectLedgers(GarbageCollector gc) {\n                 try {\n                     List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + l1Node, null);\n                     for (String l2Node : l2Nodes) {\n-                        doGcByLevel(gc, l1Node, l2Node);\n+                        doGcByLevel(gc, l1Node, l2Node, snapshot);\n                     }\n                 } catch (Exception e) {\n                     LOG.warn(\"Exception during garbage collecting ledgers for \" + l1Node\n@@ -395,23 +399,25 @@ public void garbageCollectLedgers(GarbageCollector gc) {\n      *          1st level node name\n      * @param level2\n      *          2nd level node name\n+     * @param snapshot\n+     *          Snapshot of the active ledgers map.\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    void doGcByLevel(GarbageCollector gc, final String level1, final String level2)\n+    void doGcByLevel(GarbageCollector gc, final String level1, final String level2,\n+                     NavigableMap snapshot)\n         throws IOException, InterruptedException {\n \n         StringBuilder nodeBuilder = new StringBuilder();\n         nodeBuilder.append(ledgerRootPath).append(\"/\")\n                    .append(level1).append(\"/\").append(level2);\n         String nodePath = nodeBuilder.toString();\n \n-        HashSet<Long> zkActiveLedgers = getLedgersInSingleNode(nodePath);\n+        Set<Long> zkActiveLedgers = getLedgersInSingleNode(nodePath);\n         // get hosted ledgers in /level1/level2\n         long startLedgerId = getStartLedgerIdByLevel(level1, level2);\n         long endLedgerId = getEndLedgerIdByLevel(level1, level2);\n-        ConcurrentMap<Long, Boolean> bkActiveLedgers =\n-            activeLedgers.subMap(startLedgerId, true, endLedgerId, true);\n+        Map<Long, Boolean> bkActiveLedgers = snapshot.subMap(startLedgerId, true, endLedgerId, true);\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"All active ledgers from ZK for hash node \"\n                       + level1 + \"/\" + level2 + \" : \" + zkActiveLedgers);\n@@ -422,28 +428,6 @@ void doGcByLevel(GarbageCollector gc, final String level1, final String level2)\n         doGc(gc, bkActiveLedgers, zkActiveLedgers);\n     }\n \n-    /**\n-     * Do garbage collecting comparing hosted ledgers and zk ledgers\n-     *\n-     * @param gc\n-     *          Garbage collector\n-     * @param bkActiveLedgers\n-     *          Active ledgers hosted in bookie server\n-     * @param zkAllLedgers\n-     *          All ledgers stored in zookeeper\n-     */\n-    void doGc(GarbageCollector gc, ConcurrentMap<Long, Boolean> bkActiveLedgers,\n-              HashSet<Long> zkAllLedgers) {\n-        // remove any active ledgers that doesn't exist in zk\n-        for (Long lid : bkActiveLedgers.keySet()) {\n-            if (!zkAllLedgers.contains(lid)) {\n-                // remove it from current active ledger\n-                bkActiveLedgers.remove(lid);\n-                gc.gc(lid);\n-            }\n-        }\n-    }\n-\n     /**\n      * Process list one by one in asynchronize way. Process will be stopped immediately\n      * when error occurred."},{"sha":"c222f0591666452cb27215b4bf6c6756b3e15f27","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -0,0 +1,132 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * A snapshotable map.\n+ */\n+class SnapshotMap<K, V> {\n+    // stores recent updates\n+    volatile Map<K, V> updates;\n+    volatile Map<K, V> updatesToMerge;\n+    // map stores all snapshot data\n+    volatile NavigableMap<K, V> snapshot;\n+\n+    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    public SnapshotMap() {\n+        updates = new ConcurrentHashMap<K, V>();\n+        updatesToMerge = new ConcurrentHashMap<K, V>();\n+        snapshot = new ConcurrentSkipListMap<K, V>();\n+    }\n+\n+    /**\n+     * Create a snapshot of current map.\n+     *\n+     * @return a snapshot of current map.\n+     */\n+    public NavigableMap<K, V> snapshot() {\n+        this.lock.writeLock().lock();\n+        try {\n+            if (updates.isEmpty()) {\n+                return snapshot;\n+            }\n+            // put updates for merge to snapshot\n+            updatesToMerge = updates;\n+            updates = new ConcurrentHashMap<K, V>();\n+        } finally {\n+            this.lock.writeLock().unlock();\n+        }\n+        // merging the updates to snapshot\n+        for (Map.Entry<K, V> entry : updatesToMerge.entrySet()) {\n+            snapshot.put(entry.getKey(), entry.getValue());\n+        }\n+        // clear updatesToMerge\n+        this.lock.writeLock().lock();\n+        try {\n+            updatesToMerge = new ConcurrentHashMap<K, V>();\n+        } finally {\n+            this.lock.writeLock().unlock();\n+        }\n+        return snapshot;\n+    }\n+\n+    /**\n+     * Associates the specified value with the specified key in this map.\n+     *\n+     * @param key\n+     *          Key with which the specified value is to be associated.\n+     * @param value\n+     *          Value to be associated with the specified key.\n+     */\n+    public void put(K key, V value) {\n+        this.lock.readLock().lock();\n+        try {\n+            updates.put(key, value);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+\n+    }\n+\n+    /**\n+     * Removes the mapping for the key from this map if it is present.\n+     *\n+     * @param key\n+     *          Key whose mapping is to be removed from this map.\n+     */\n+    public void remove(K key) {\n+        this.lock.readLock().lock();\n+        try {\n+            // first remove updates\n+            updates.remove(key);\n+            updatesToMerge.remove(key);\n+            // then remove snapshot\n+            snapshot.remove(key);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns true if this map contains a mapping for the specified key.\n+     *\n+     * @param key\n+     *          Key whose presence is in the map to be tested.\n+     * @return true if the map contains a mapping for the specified key.\n+     */\n+    public boolean containsKey(K key) {\n+        this.lock.readLock().lock();\n+        try {\n+            return updates.containsKey(key)\n+                 | updatesToMerge.containsKey(key)\n+                 | snapshot.containsKey(key);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+    }\n+}"},{"sha":"12c1b5a2abe22bf26cb52b24f66842d1b71f5582","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"added","additions":167,"deletions":0,"changes":167,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -0,0 +1,167 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.meta.LedgerManager.GarbageCollector;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test garbage collection ledgers in ledger manager\n+ */\n+public class GcLedgersTest extends LedgerManagerTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(GcLedgersTest.class);\n+\n+    public GcLedgersTest(String ledgerManagerType) {\n+        super(ledgerManagerType);\n+    }\n+\n+    /**\n+     * Create ledgers\n+     */\n+    private void createLedgers(int numLedgers, final Set<Long> createdLedgers) {\n+        final AtomicInteger expected = new AtomicInteger(numLedgers);\n+        for (int i=0; i<numLedgers; i++) {\n+            ledgerManager.newLedgerPath(new GenericCallback<String>() {\n+                @Override\n+                public void operationComplete(int rc, String ledgerPath) {\n+                    if (rc == BKException.Code.OK) {\n+                        try {\n+                            long ledgerId = ledgerManager.getLedgerId(ledgerPath);\n+                            ledgerManager.addActiveLedger(ledgerId, true);\n+                            createdLedgers.add(ledgerId);\n+                        } catch (IOException ie) {\n+                        }\n+                    }\n+                    synchronized (expected) {\n+                        int num = expected.decrementAndGet();\n+                        if (num == 0) {\n+                            expected.notify();\n+                        }\n+                    }\n+                }\n+            }, new LedgerMetadata(1, 1));\n+        }\n+        synchronized (expected) {\n+            try {\n+                while (expected.get() > 0) {\n+                    expected.wait(100);\n+                }\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGarbageCollectLedgers() throws Exception {\n+        int numLedgers = 100;\n+        int numRemovedLedgers = 10;\n+\n+        final Set<Long> createdLedgers = new HashSet<Long>();\n+        final Set<Long> removedLedgers = new HashSet<Long>();\n+\n+        // create 100 ledgers\n+        createLedgers(numLedgers, createdLedgers);\n+\n+        Random r = new Random(System.currentTimeMillis());\n+        final List<Long> tmpList = new ArrayList<Long>();\n+        tmpList.addAll(createdLedgers);\n+        Collections.shuffle(tmpList, r);\n+        // random remove several ledgers\n+        for (int i=0; i<numRemovedLedgers; i++) {\n+            long ledgerId = tmpList.get(i);\n+            zkc.delete(ledgerManager.getLedgerPath(ledgerId), -1);\n+            removedLedgers.add(ledgerId);\n+            createdLedgers.remove(ledgerId);\n+        }\n+        final CountDownLatch inGcProgress = new CountDownLatch(1);\n+        final CountDownLatch createLatch = new CountDownLatch(1);\n+        final CountDownLatch endLatch = new CountDownLatch(2);\n+\n+        Thread gcThread = new Thread() {\n+            @Override\n+            public void run() {\n+                ledgerManager.garbageCollectLedgers(new GarbageCollector() {\n+                    boolean paused = false;\n+                    @Override\n+                    public void gc(long ledgerId) {\n+                        if (!paused) {\n+                            inGcProgress.countDown();\n+                            try {\n+                                createLatch.await();\n+                            } catch (InterruptedException ie) {\n+                            }\n+                            paused = true;\n+                        }\n+                        LOG.info(\"Garbage Collected ledger {}\", ledgerId);\n+                    }\n+                });\n+                LOG.info(\"Gc Thread quits.\");\n+                endLatch.countDown();\n+            }\n+        };\n+\n+        Thread createThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    inGcProgress.await();\n+                    // create 10 more ledgers\n+                    createLedgers(10, createdLedgers);\n+                    LOG.info(\"Finished creating 10 more ledgers.\");\n+                    createLatch.countDown();\n+                } catch (Exception e) {\n+                }\n+                LOG.info(\"Create Thread quits.\");\n+                endLatch.countDown();\n+            }\n+        };\n+\n+        createThread.start();\n+        gcThread.start();\n+\n+        endLatch.await();\n+\n+        // test ledgers\n+        for (Long ledger : removedLedgers) {\n+            assertFalse(ledgerManager.containsActiveLedger(ledger));\n+        }\n+        for (Long ledger : createdLedgers) {\n+            assertTrue(ledgerManager.containsActiveLedger(ledger));\n+        }\n+    }\n+}"},{"sha":"b8a541b315c1490b246a7644c5fbf4c9161e6fe3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java?ref=30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","patch":"@@ -0,0 +1,77 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test case to run over serveral ledger managers\n+ */\n+@RunWith(Parameterized.class)\n+public abstract class LedgerManagerTestCase extends BookKeeperClusterTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(LedgerManagerTestCase.class);\n+\n+    LedgerManager ledgerManager;\n+\n+    public LedgerManagerTestCase(String ledgerManagerType) {\n+        super(0);\n+        baseConf.setLedgerManagerType(ledgerManagerType);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] {\n+            { FlatLedgerManager.NAME },\n+            { HierarchicalLedgerManager.NAME }\n+        });\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(baseConf, zkc);\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        ledgerManager.close();\n+        super.tearDown();\n+    }\n+\n+}"}]}

