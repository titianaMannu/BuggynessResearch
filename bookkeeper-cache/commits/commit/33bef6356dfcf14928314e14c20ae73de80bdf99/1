{"sha":"33bef6356dfcf14928314e14c20ae73de80bdf99","node_id":"MDY6Q29tbWl0MTU3NTk1NjozM2JlZjYzNTZkZmNmMTQ5MjgzMTRlMTRjMjBhZTczZGU4MGJkZjk5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-16T09:41:45Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-16T09:41:45Z"},"message":"BOOKKEEPER-182: Entry log file is overwritten when fail to read lastLogId. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1301395 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c7ac5f039aedf3c7f5a6f0a1af36d7df3202139e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c7ac5f039aedf3c7f5a6f0a1af36d7df3202139e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/33bef6356dfcf14928314e14c20ae73de80bdf99","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/33bef6356dfcf14928314e14c20ae73de80bdf99","html_url":"https://github.com/apache/bookkeeper/commit/33bef6356dfcf14928314e14c20ae73de80bdf99","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/33bef6356dfcf14928314e14c20ae73de80bdf99/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","url":"https://api.github.com/repos/apache/bookkeeper/commits/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","html_url":"https://github.com/apache/bookkeeper/commit/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7"}],"stats":{"total":139,"additions":124,"deletions":15},"files":[{"sha":"82402cf1969bd6e1bc5c999072a5a6b9f9ba53c9","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/33bef6356dfcf14928314e14c20ae73de80bdf99/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/33bef6356dfcf14928314e14c20ae73de80bdf99/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=33bef6356dfcf14928314e14c20ae73de80bdf99","patch":"@@ -56,6 +56,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-184: CompactionTest failing on Jenkins (sijie via ivank)\n \n+        BOOKKEEPER-182: Entry log file is overwritten when fail to read lastLogId. (sijie via ivank)\n+\n       hedwig-server/\n       \n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)"},{"sha":"8da372ecc1dfddabab61caf703aea1fe131a1987","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":61,"deletions":14,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/33bef6356dfcf14928314e14c20ae73de80bdf99/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/33bef6356dfcf14928314e14c20ae73de80bdf99/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=33bef6356dfcf14928314e14c20ae73de80bdf99","patch":"@@ -24,6 +24,7 @@\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n+import java.io.FileFilter;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n@@ -34,6 +35,7 @@\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -174,13 +176,14 @@ public EntryLogger(ServerConfiguration conf) throws IOException {\n         // this header buffer is cleared before writing it into the new logChannel.\n         LOGFILE_HEADER.put(\"BKLO\".getBytes());\n         // Find the largest logId\n+        logId = -1;\n         for(File f: dirs) {\n             long lastLogId = getLastLogId(f);\n-            if (lastLogId >= logId) {\n-                logId = lastLogId+1;\n+            if (lastLogId > logId) {\n+                logId = lastLogId;\n             }\n         }\n-        createLogId(logId);\n+        createNewLog();\n     }\n \n     /**\n@@ -189,16 +192,31 @@ public EntryLogger(ServerConfiguration conf) throws IOException {\n     private ConcurrentHashMap<Long, BufferedChannel> channels = new ConcurrentHashMap<Long, BufferedChannel>();\n \n     /**\n-     * Creates a new log file with the given id.\n+     * Creates a new log file\n      */\n-    private void createLogId(long logId) throws IOException {\n+    private void createNewLog() throws IOException {\n         List<File> list = Arrays.asList(dirs);\n         Collections.shuffle(list);\n-        File firstDir = list.get(0);\n         if (logChannel != null) {\n             logChannel.flush(true);\n         }\n-        logChannel = new BufferedChannel(new RandomAccessFile(new File(firstDir, Long.toHexString(logId)+\".log\"), \"rw\").getChannel(), 64*1024);\n+\n+        // It would better not to overwrite existing entry log files\n+        File newLogFile = null;\n+        do {\n+            String logFileName = Long.toHexString(++logId) + \".log\";\n+            for (File dir : list) {\n+                newLogFile = new File(dir, logFileName);\n+                if (newLogFile.exists()) {\n+                    LOG.warn(\"Found existed entry log \" + newLogFile\n+                           + \" when trying to create it as a new log.\");\n+                    newLogFile = null;\n+                    break;\n+                }\n+            }\n+        } while (newLogFile == null);\n+\n+        logChannel = new BufferedChannel(new RandomAccessFile(newLogFile, \"rw\").getChannel(), 64*1024);\n         logChannel.write((ByteBuffer) LOGFILE_HEADER.clear());\n         channels.put(logId, logChannel);\n         for(File f: dirs) {\n@@ -252,10 +270,41 @@ private void setLastLogId(File dir, long logId) throws IOException {\n         }\n     }\n \n+    private long getLastLogId(File dir) {\n+        long id = readLastLogId(dir);\n+        // read success\n+        if (id > 0) {\n+            return id;\n+        }\n+        // read failed, scan the ledger directories to find biggest log id\n+        File[] logFiles = dir.listFiles(new FileFilter() {\n+            @Override\n+            public boolean accept(File file) {\n+                return file.getName().endsWith(\".log\");\n+            }\n+        });\n+        List<Long> logs = new ArrayList<Long>();\n+        for (File lf : logFiles) {\n+            String idString = lf.getName().split(\"\\\\.\")[0];\n+            try {\n+                long lid = Long.parseLong(idString, 16);\n+                logs.add(lid);\n+            } catch (NumberFormatException nfe) {\n+            }\n+        }\n+        // no log file found in this directory\n+        if (0 == logs.size()) {\n+            return -1;\n+        }\n+        // order the collections\n+        Collections.sort(logs);\n+        return logs.get(logs.size() - 1);\n+    }\n+\n     /**\n      * reads id from the \"lastId\" file in the given directory.\n      */\n-    private long getLastLogId(File f) {\n+    private long readLastLogId(File f) {\n         FileInputStream fis;\n         try {\n             fis = new FileInputStream(new File(f, \"lastId\"));\n@@ -278,18 +327,14 @@ private long getLastLogId(File f) {\n         }\n     }\n \n-    private void openNewChannel() throws IOException {\n-        createLogId(++logId);\n-    }\n-\n     synchronized void flush() throws IOException {\n         if (logChannel != null) {\n             logChannel.flush(true);\n         }\n     }\n     synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         if (logChannel.position() + entry.remaining() + 4 > logSizeLimit) {\n-            openNewChannel();\n+            createNewLog();\n         }\n         ByteBuffer buff = ByteBuffer.allocate(4);\n         buff.putInt(entry.remaining());\n@@ -351,7 +396,9 @@ private BufferedChannel getChannelForLogId(long entryLogId) throws IOException {\n             return fc;\n         }\n         File file = findFile(entryLogId);\n-        FileChannel newFc = new RandomAccessFile(file, \"rw\").getChannel();\n+        // get channel is used to open an existing entry log file\n+        // it would be better to open using read mode\n+        FileChannel newFc = new RandomAccessFile(file, \"r\").getChannel();\n         // If the file already exists before creating a BufferedChannel layer above it,\n         // set the FileChannel's position to the end so the write buffer knows where to start.\n         newFc.position(newFc.size());"},{"sha":"96df89aa47d2207dd1fb49dd49470ab3a86f3258","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","status":"modified","additions":61,"deletions":1,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/33bef6356dfcf14928314e14c20ae73de80bdf99/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/33bef6356dfcf14928314e14c20ae73de80bdf99/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java?ref=33bef6356dfcf14928314e14c20ae73de80bdf99","patch":"@@ -83,10 +83,70 @@ private ByteBuffer generateEntry(long ledger, long entry) {\n         ByteBuffer bb = ByteBuffer.wrap(new byte[64]);\n         bb.putLong(ledger);\n         bb.putLong(entry);\n-        bb.put((\"ledger\"+ledger).getBytes());\n+        bb.put((\"ledger-\" + ledger + \"-\" + entry).getBytes());\n         bb.flip();\n         return bb;\n     }\n+\n+    @Test\n+    public void testMissingLogId() throws Exception {\n+        File tmpDir = File.createTempFile(\"entryLogTest\", \".dir\");\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+\n+        ServerConfiguration conf = new ServerConfiguration();\n+        conf.setLedgerDirNames(new String[] {tmpDir.toString()});\n+        // create some entries\n+        int numLogs = 3;\n+        int numEntries = 10;\n+        long[][] positions = new long[2*numLogs][];\n+        for (int i=0; i<numLogs; i++) {\n+            positions[i] = new long[numEntries];\n+\n+            EntryLogger logger = new EntryLogger(conf);\n+            for (int j=0; j<numEntries; j++) {\n+                positions[i][j] = logger.addEntry(i, generateEntry(i, j));\n+            }\n+            logger.flush();\n+        }\n+        // delete last log id\n+        File lastLogId = new File(curDir, \"lastId\");\n+        lastLogId.delete();\n+\n+        // write another entries\n+        for (int i=numLogs; i<2*numLogs; i++) {\n+            positions[i] = new long[numEntries];\n+\n+            EntryLogger logger = new EntryLogger(conf);\n+            for (int j=0; j<numEntries; j++) {\n+                positions[i][j] = logger.addEntry(i, generateEntry(i, j));\n+            }\n+            logger.flush();\n+        }\n+\n+        EntryLogger newLogger = new EntryLogger(conf);\n+        for (int i=0; i<(2*numLogs+1); i++) {\n+            File logFile = new File(curDir, Long.toHexString(i) + \".log\");\n+            assertTrue(logFile.exists());\n+        }\n+        for (int i=0; i<2*numLogs; i++) {\n+            for (int j=0; j<numEntries; j++) {\n+                String expectedValue = \"ledger-\" + i + \"-\" + j;\n+                byte[] value = newLogger.readEntry(i, j, positions[i][j]);\n+                ByteBuffer buf = ByteBuffer.wrap(value);\n+                long ledgerId = buf.getLong();\n+                long entryId = buf.getLong();\n+                byte[] data = new byte[buf.remaining()];\n+                buf.get(data);\n+                assertEquals(i, ledgerId);\n+                assertEquals(j, entryId);\n+                assertEquals(expectedValue, new String(data));\n+            }\n+        }\n+    }\n+\n     \n     @After\n     public void tearDown() throws Exception {"}]}

