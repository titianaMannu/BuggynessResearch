{"sha":"360174f12df9b853e4f3b65631c4063e150beb8f","node_id":"MDY6Q29tbWl0MTU3NTk1NjozNjAxNzRmMTJkZjliODUzZTRmM2I2NTYzMWM0MDYzZTE1MGJlYjhm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-08-30T10:13:51Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-08-30T10:13:51Z"},"message":"BOOKKEEPER-52: Message sequence confuse due to the subscribeMsgQueue@SubscribeResponseHandler (xulei via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1163161 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"24c1f3661384b1356cbe5965e84e2858a36c5b2c","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/24c1f3661384b1356cbe5965e84e2858a36c5b2c"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/360174f12df9b853e4f3b65631c4063e150beb8f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/360174f12df9b853e4f3b65631c4063e150beb8f","html_url":"https://github.com/apache/bookkeeper/commit/360174f12df9b853e4f3b65631c4063e150beb8f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/360174f12df9b853e4f3b65631c4063e150beb8f/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"675efc92fdb7c88ff9b871ba2ccf56974f769544","url":"https://api.github.com/repos/apache/bookkeeper/commits/675efc92fdb7c88ff9b871ba2ccf56974f769544","html_url":"https://github.com/apache/bookkeeper/commit/675efc92fdb7c88ff9b871ba2ccf56974f769544"}],"stats":{"total":77,"additions":42,"deletions":35},"files":[{"sha":"8f2e49777413700e0eacd9f84e7c6379861bf843","filename":"CHANGES.txt","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/360174f12df9b853e4f3b65631c4063e150beb8f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/360174f12df9b853e4f3b65631c4063e150beb8f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=360174f12df9b853e4f3b65631c4063e150beb8f","patch":"@@ -42,6 +42,10 @@ BUGFIXES:\n   \n   BOOKKEEPER-51: NullPointException at FIFODeliveryManager#deliveryPtrs (xulei via ivank)\n \n+ hedwig-client/\n+ \n+  BOOKKEEPER-52: Message sequence confuse due to the subscribeMsgQueue@SubscribeResponseHandler (xulei via ivank)\n+\n IMPROVEMENTS:\n \n  BOOKKEEPER-28: Create useful startup scripts for bookkeeper and hedwig (ivank)"},{"sha":"7d9d00892d088e582374329b54ec910e4109418a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"modified","additions":38,"deletions":35,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/360174f12df9b853e4f3b65631c4063e150beb8f/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/360174f12df9b853e4f3b65631c4063e150beb8f/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=360174f12df9b853e4f3b65631c4063e150beb8f","patch":"@@ -162,29 +162,30 @@ public void handleSubscribeMessage(PubSubResponse response) {\n             logger.debug(\"Handling a Subscribe message in response: \" + response + \", topic: \"\n                     + origSubData.topic.toStringUtf8() + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n         Message message = response.getMessage();\n-        // Consume the message asynchronously that the client is subscribed\n-        // to. Do this only if delivery for the subscription has started and\n-        // a MessageHandler has been registered for the TopicSubscriber.\n-        if (messageHandler != null) {\n-            asyncMessageConsume(message);\n-        } else {\n-            // MessageHandler has not yet been registered so queue up these\n-            // messages for the Topic Subscription. Make the initial lazy\n-            // creation of the message queue thread safe just so we don't\n-            // run into a race condition where two simultaneous threads process\n-            // a received message and both try to create a new instance of\n-            // the message queue. Performance overhead should be okay\n-            // because the delivery of the topic has not even started yet\n-            // so these messages are not consumed and just buffered up here.\n-            synchronized (this) {\n+\n+        synchronized (this) {\n+            // Consume the message asynchronously that the client is subscribed\n+            // to. Do this only if delivery for the subscription has started and\n+            // a MessageHandler has been registered for the TopicSubscriber.\n+            if (messageHandler != null) {\n+                asyncMessageConsume(message);\n+            } else {\n+                // MessageHandler has not yet been registered so queue up these\n+                // messages for the Topic Subscription. Make the initial lazy\n+                // creation of the message queue thread safe just so we don't\n+                // run into a race condition where two simultaneous threads process\n+                // a received message and both try to create a new instance of\n+                // the message queue. Performance overhead should be okay\n+                // because the delivery of the topic has not even started yet\n+                // so these messages are not consumed and just buffered up here.\n                 if (subscribeMsgQueue == null)\n                     subscribeMsgQueue = new LinkedList<Message>();\n-            }\n-            if (logger.isDebugEnabled())\n-                logger\n+                if (logger.isDebugEnabled())\n+                    logger\n                         .debug(\"Message has arrived but Subscribe channel does not have a registered MessageHandler yet so queueing up the message: \"\n                                 + message);\n-            subscribeMsgQueue.add(message);\n+                subscribeMsgQueue.add(message);\n+            }\n         }\n     }\n \n@@ -298,23 +299,25 @@ public void setMessageHandler(MessageHandler messageHandler) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Setting the messageHandler for topic: \" + origSubData.topic.toStringUtf8()\n                     + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n-        this.messageHandler = messageHandler;\n-        // Once the MessageHandler is registered, see if we have any queued up\n-        // subscription messages sent to us already from the server. If so,\n-        // consume those first. Do this only if the MessageHandler registered is\n-        // not null (since that would be the HedwigSubscriber.stopDelivery\n-        // call).\n-        if (messageHandler != null && subscribeMsgQueue != null && subscribeMsgQueue.size() > 0) {\n-            if (logger.isDebugEnabled())\n-                logger.debug(\"Consuming \" + subscribeMsgQueue.size() + \" queued up messages for topic: \"\n-                        + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                        + origSubData.subscriberId.toStringUtf8());\n-            for (Message message : subscribeMsgQueue) {\n-                asyncMessageConsume(message);\n+        synchronized (this) {\n+            this.messageHandler = messageHandler;\n+            // Once the MessageHandler is registered, see if we have any queued up\n+            // subscription messages sent to us already from the server. If so,\n+            // consume those first. Do this only if the MessageHandler registered is\n+            // not null (since that would be the HedwigSubscriber.stopDelivery\n+            // call).\n+            if (messageHandler != null && subscribeMsgQueue != null && subscribeMsgQueue.size() > 0) {\n+                if (logger.isDebugEnabled())\n+                    logger.debug(\"Consuming \" + subscribeMsgQueue.size() + \" queued up messages for topic: \"\n+                            + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                            + origSubData.subscriberId.toStringUtf8());\n+                for (Message message : subscribeMsgQueue) {\n+                    asyncMessageConsume(message);\n+                }\n+                // Now we can remove the queued up messages since they are all\n+                // consumed.\n+                subscribeMsgQueue.clear();\n             }\n-            // Now we can remove the queued up messages since they are all\n-            // consumed.\n-            subscribeMsgQueue.clear();\n         }\n     }\n "}]}

