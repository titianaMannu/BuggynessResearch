{"sha":"38a6fd30048c5fe165409a9ca536fb1ffbdbf537","node_id":"MDY6Q29tbWl0MTU3NTk1NjozOGE2ZmQzMDA0OGM1ZmUxNjU0MDlhOWNhNTM2ZmIxZmZiZGJmNTM3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-08-18T21:00:15Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-08-18T21:00:15Z"},"message":"BOOKKEEPER-704: reconnectable zookeeper client wrapper (sijie via ivank)\n\nChange-Id: I00c73788f4ed5911713906b4d7622ca6dcec79a5\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1618732 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3b362c62c00a7277182ac8d8feeec09d4ed5bd3b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3b362c62c00a7277182ac8d8feeec09d4ed5bd3b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/38a6fd30048c5fe165409a9ca536fb1ffbdbf537","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/38a6fd30048c5fe165409a9ca536fb1ffbdbf537","html_url":"https://github.com/apache/bookkeeper/commit/38a6fd30048c5fe165409a9ca536fb1ffbdbf537","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"b6f33e49d0671a5b982bcb3613c5c9844f6aec8b","url":"https://api.github.com/repos/apache/bookkeeper/commits/b6f33e49d0671a5b982bcb3613c5c9844f6aec8b","html_url":"https://github.com/apache/bookkeeper/commit/b6f33e49d0671a5b982bcb3613c5c9844f6aec8b"}],"stats":{"total":1409,"additions":1396,"deletions":13},"files":[{"sha":"2aa242e956e802cba3ae2c5ec0ab19617227e88d","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -212,6 +212,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-774: Flaky test org.apache.bookkeeper.test.ReadOnlyBookieTest.testBookieShouldTurnWritableFromReadOnly (sijie)\n \n+        BOOKKEEPER-704: reconnectable zookeeper client wrapper (sijie via ivank)\n+\n       bookkeeper-benchmark:\n \n         BOOKKEEPER-768: fix typo 'seconds' to milliseconds in benchmark output (jialin via sijie)"},{"sha":"7fe237a900a0c53b9387f23c214180e868301b36","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -0,0 +1,41 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.zookeeper;\n+\n+/**\n+ * Retry policy that retries a set number of times with an increasing (up to a\n+ * maximum bound) backoff time between retries.\n+ */\n+public class BoundExponentialBackoffRetryPolicy extends ExponentialBackoffRetryPolicy {\n+\n+    private final long maxBackoffTime;\n+\n+    public BoundExponentialBackoffRetryPolicy(long baseBackoffTime, long maxBackoffTime, int maxRetries) {\n+        super(baseBackoffTime, maxRetries);\n+        this.maxBackoffTime = maxBackoffTime;\n+    }\n+\n+    @Override\n+    public long nextRetryWaitTime(int retryCount, long elapsedRetryTime) {\n+        return Math.min(maxBackoffTime, super.nextRetryWaitTime(retryCount, elapsedRetryTime));\n+    }\n+\n+}"},{"sha":"dab7aa719325743ea8bfe54543cb5511c085943c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -0,0 +1,47 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.zookeeper;\n+\n+import java.util.Random;\n+\n+public class ExponentialBackoffRetryPolicy implements RetryPolicy {\n+\n+    private final Random random;\n+    private final int maxRetries;\n+    private final long baseBackoffTime;\n+\n+    public ExponentialBackoffRetryPolicy(long baseBackoffTime, int maxRetries) {\n+        this.maxRetries = maxRetries;\n+        this.baseBackoffTime = baseBackoffTime;\n+        this.random = new Random(System.currentTimeMillis());\n+    }\n+\n+    @Override\n+    public boolean allowRetry(int retryCount, long elapsedRetryTime) {\n+        return retryCount <= maxRetries;\n+    }\n+\n+    @Override\n+    public long nextRetryWaitTime(int retryCount, long elapsedRetryTime) {\n+        return baseBackoffTime * Math.max(1, random.nextInt(1 << (retryCount + 1)));\n+    }\n+\n+}"},{"sha":"a4269fbe7193aaa2ba3c957f3eaf89b6b6a99245","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -0,0 +1,55 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.zookeeper;\n+\n+/**\n+ * Interface of the policy to use when retrying operations.\n+ */\n+public interface RetryPolicy {\n+\n+    /**\n+     * Called when retrying an operation failed for some reason. Return true if\n+     * another attempt is allowed to make.\n+     * \n+     * @param retryCount\n+     *            The number of times retried so far (1 for the first time).\n+     * @param elapsedRetryTime\n+     *            The elapsed time since the operation attempted. (in\n+     *            milliseconds)\n+     * @return true if anther attempt is allowed to make. otherwise, false.\n+     */\n+    public boolean allowRetry(int retryCount, long elapsedRetryTime);\n+\n+    /**\n+     * Called before making an attempt to retry a failed operation. Return 0 if\n+     * an attempt needs to be made immediately.\n+     * \n+     * @param retryCount\n+     *            The number of times retried so far (0 for the first time).\n+     * @param elapsedRetryTime\n+     *            The elapsed time since the operation attempted. (in\n+     *            milliseconds)\n+     * @return the elapsed time that the attempt needs to wait before retrying.\n+     *         (in milliseconds)\n+     */\n+    public long nextRetryWaitTime(int retryCount, long elapsedRetryTime);\n+\n+}"},{"sha":"a479a369039f210afe1c1aa36c43b0ca6defd6e4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","status":"added","additions":1046,"deletions":0,"changes":1046,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -0,0 +1,1046 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.zookeeper;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.bookkeeper.zookeeper.ZooWorker.ZooCallable;\n+import org.apache.zookeeper.AsyncCallback.ACLCallback;\n+import org.apache.zookeeper.AsyncCallback.Children2Callback;\n+import org.apache.zookeeper.AsyncCallback.ChildrenCallback;\n+import org.apache.zookeeper.AsyncCallback.DataCallback;\n+import org.apache.zookeeper.AsyncCallback.StatCallback;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.Transaction;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provide a zookeeper client to handle session expire\n+ */\n+public class ZooKeeperClient extends ZooKeeper implements Watcher {\n+\n+    final static Logger logger = LoggerFactory.getLogger(ZooKeeperClient.class);\n+\n+    // ZooKeeper client connection variables\n+    private final String connectString;\n+    private final int sessionTimeoutMs;\n+\n+    // state for the zookeeper client\n+    private final AtomicReference<ZooKeeper> zk = new AtomicReference<ZooKeeper>();\n+    private final ZooKeeperWatcherBase watcherManager;\n+\n+    private final ScheduledExecutorService retryExecutor;\n+    private final ExecutorService connectExecutor;\n+\n+    // retry polices\n+    private final RetryPolicy connectRetryPolicy;\n+    private final RetryPolicy operationRetryPolicy;\n+\n+    private final Callable<ZooKeeper> clientCreator = new Callable<ZooKeeper>() {\n+\n+        @Override\n+        public ZooKeeper call() throws Exception {\n+            try {\n+                return ZooWorker.syncCallWithRetries(null, new ZooCallable<ZooKeeper>() {\n+\n+                    @Override\n+                    public ZooKeeper call() throws KeeperException, InterruptedException {\n+                        logger.info(\"Reconnecting zookeeper {}.\", connectString);\n+                        ZooKeeper newZk;\n+                        try {\n+                            newZk = createZooKeeper();\n+                        } catch (IOException ie) {\n+                            logger.error(\"Failed to create zookeeper instance to \" + connectString, ie);\n+                            throw KeeperException.create(KeeperException.Code.CONNECTIONLOSS);\n+                        }\n+                        // close the previous one\n+                        closeZkHandle();\n+                        zk.set(newZk);\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"ZooKeeper session {} is created to {}.\",\n+                                    Long.toHexString(newZk.getSessionId()), connectString);\n+                        }\n+                        return newZk;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        return String.format(\"ZooKeeper Client Creator (%s)\", connectString);\n+                    }\n+\n+                }, connectRetryPolicy);\n+            } catch (Exception e) {\n+                logger.error(\"Gave up reconnecting to ZooKeeper : \", e);\n+                Runtime.getRuntime().exit(-1);\n+                return null;\n+            }\n+        }\n+\n+    };\n+\n+    public static ZooKeeper createConnectedZooKeeper(String connectString, int sessionTimeoutMs)\n+                    throws KeeperException, InterruptedException, IOException {\n+        ZooKeeperWatcherBase watcher = new ZooKeeperWatcherBase(sessionTimeoutMs);\n+        ZooKeeper zk = new ZooKeeper(connectString, sessionTimeoutMs, watcher);\n+        try {\n+            watcher.waitForConnection();\n+        } catch (KeeperException ke) {\n+            zk.close();\n+            throw ke;\n+        } catch (InterruptedException ie) {\n+            zk.close();\n+            throw ie;\n+        }\n+        return zk;\n+    }\n+\n+    public static ZooKeeperClient createConnectedZooKeeperClient(String connectString, int sessionTimeoutMs)\n+                    throws KeeperException, InterruptedException, IOException {\n+        ZooKeeperWatcherBase watcherManager = new ZooKeeperWatcherBase(sessionTimeoutMs);\n+        ZooKeeperClient client = new ZooKeeperClient(connectString, sessionTimeoutMs, watcherManager,\n+                new BoundExponentialBackoffRetryPolicy(sessionTimeoutMs, sessionTimeoutMs, 0));\n+        try {\n+            watcherManager.waitForConnection();\n+        } catch (KeeperException ke) {\n+            client.close();\n+            throw ke;\n+        } catch (InterruptedException ie) {\n+            client.close();\n+            throw ie;\n+        }\n+        return client;\n+    }\n+\n+    public static ZooKeeperClient createConnectedZooKeeperClient(\n+            String connectString, int sessionTimeoutMs, RetryPolicy operationRetryPolicy)\n+                    throws KeeperException, InterruptedException, IOException {\n+        ZooKeeperWatcherBase watcherManager = new ZooKeeperWatcherBase(sessionTimeoutMs); \n+        ZooKeeperClient client = new ZooKeeperClient(connectString, sessionTimeoutMs, watcherManager,\n+                operationRetryPolicy);\n+        try {\n+            watcherManager.waitForConnection();\n+        } catch (KeeperException ke) {\n+            client.close();\n+            throw ke;\n+        } catch (InterruptedException ie) {\n+            client.close();\n+            throw ie;\n+        }\n+        return client;\n+    }\n+\n+    public static ZooKeeperClient createConnectedZooKeeperClient(\n+            String connectString, int sessionTimeoutMs, Set<Watcher> childWatchers,\n+            RetryPolicy operationRetryPolicy)\n+                    throws KeeperException, InterruptedException, IOException {\n+        ZooKeeperWatcherBase watcherManager =\n+                new ZooKeeperWatcherBase(sessionTimeoutMs, childWatchers);\n+        ZooKeeperClient client = new ZooKeeperClient(connectString, sessionTimeoutMs, watcherManager,\n+                operationRetryPolicy);\n+        try {\n+            watcherManager.waitForConnection();\n+        } catch (KeeperException ke) {\n+            client.close();\n+            throw ke;\n+        } catch (InterruptedException ie) {\n+            client.close();\n+            throw ie;\n+        }\n+        return client;\n+    }\n+\n+    ZooKeeperClient(String connectString, int sessionTimeoutMs, ZooKeeperWatcherBase watcherManager,\n+            RetryPolicy operationRetryPolicy) throws IOException {\n+        this(connectString, sessionTimeoutMs, watcherManager,\n+                new BoundExponentialBackoffRetryPolicy(6000, 60000, Integer.MAX_VALUE),\n+                operationRetryPolicy);\n+    }\n+\n+    private ZooKeeperClient(String connectString, int sessionTimeoutMs,\n+            ZooKeeperWatcherBase watcherManager,\n+            RetryPolicy connectRetryPolicy, RetryPolicy operationRetryPolicy) throws IOException {\n+        super(connectString, sessionTimeoutMs, watcherManager);\n+        this.connectString = connectString;\n+        this.sessionTimeoutMs = sessionTimeoutMs;\n+        this.watcherManager = watcherManager;\n+        this.connectRetryPolicy = connectRetryPolicy;\n+        this.operationRetryPolicy = operationRetryPolicy;\n+        this.retryExecutor =\n+                Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+        this.connectExecutor =\n+                Executors.newSingleThreadExecutor();\n+        // added itself to the watcher\n+        watcherManager.addChildWatcher(this);\n+    }\n+\n+    @Override\n+    public void close() throws InterruptedException {\n+        connectExecutor.shutdown();\n+        retryExecutor.shutdown();\n+        closeZkHandle();\n+    }\n+    \n+    private void closeZkHandle() throws InterruptedException {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            super.close();\n+        } else {\n+            zkHandle.close();\n+        }\n+    }\n+\n+    protected void waitForConnection() throws KeeperException, InterruptedException {\n+        watcherManager.waitForConnection();\n+    }\n+\n+    protected ZooKeeper createZooKeeper() throws IOException {\n+        return new ZooKeeper(connectString, sessionTimeoutMs, watcherManager);\n+    }\n+\n+    @Override\n+    public void process(WatchedEvent event) {\n+        if (event.getType() == EventType.None &&\n+                event.getState() == KeeperState.Expired) {\n+            onExpired();\n+        }\n+    }\n+\n+    private void onExpired() {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"ZooKeeper session {} is expired from {}.\",\n+                    Long.toHexString(getSessionId()), connectString);\n+        }\n+        try {\n+            connectExecutor.submit(clientCreator);\n+        } catch (RejectedExecutionException ree) {\n+            logger.error(\"ZooKeeper reconnect task is rejected : \", ree);\n+        }\n+    }\n+\n+\n+    static abstract class RetryRunnable implements Runnable {\n+\n+        final ZooWorker worker;\n+        final Runnable that;\n+\n+        RetryRunnable(RetryPolicy retryPolicy) {\n+            worker = new ZooWorker(retryPolicy);\n+            that = this;\n+        }\n+\n+    }\n+\n+    // inherits from ZooKeeper client for all operations\n+\n+    @Override\n+    public long getSessionId() {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            return super.getSessionId();\n+        }\n+        return zkHandle.getSessionId();\n+    }\n+\n+    @Override\n+    public byte[] getSessionPasswd() {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            return super.getSessionPasswd();\n+        }\n+        return zkHandle.getSessionPasswd();\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            return super.getSessionTimeout();\n+        }\n+        return zkHandle.getSessionTimeout();\n+    }\n+\n+    @Override\n+    public void addAuthInfo(String scheme, byte[] auth) {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            super.addAuthInfo(scheme, auth);\n+            return;\n+        }\n+        zkHandle.addAuthInfo(scheme, auth);\n+    }\n+\n+    @Override\n+    public synchronized void register(Watcher watcher) {\n+        watcherManager.addChildWatcher(watcher);\n+    }\n+\n+    @Override\n+    public List<OpResult> multi(final Iterable<Op> ops) throws InterruptedException, KeeperException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<List<OpResult>>() {\n+\n+            @Override\n+            public List<OpResult> call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.multi(ops);\n+                }\n+                return zkHandle.multi(ops);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public Transaction transaction() {\n+        // since there is no reference about which client that the transaction could use\n+        // so just use ZooKeeper instance directly.\n+        // you'd better to use {@link #multi}.\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            return super.transaction();\n+        }\n+        return zkHandle.transaction();\n+    }\n+\n+    @Override\n+    public List<ACL> getACL(final String path, final Stat stat) throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<List<ACL>>() {\n+\n+            @Override\n+            public List<ACL> call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getACL(path, stat);\n+                }\n+                return zkHandle.getACL(path, stat);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void getACL(final String path, final Stat stat, final ACLCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final ACLCallback aclCb = new ACLCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, acl, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getACL(path, stat, aclCb, worker);\n+                } else {\n+                    zkHandle.getACL(path, stat, aclCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public Stat setACL(final String path, final List<ACL> acl, final int version)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<Stat>() {\n+\n+            @Override\n+            public Stat call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.setACL(path, acl, version);\n+                }\n+                return zkHandle.setACL(path, acl, version);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void setACL(final String path, final List<ACL> acl, final int version,\n+            final StatCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final StatCallback stCb = new StatCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.setACL(path, acl, version, stCb, worker);\n+                } else {\n+                    zkHandle.setACL(path, acl, version, stCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public void sync(final String path, final VoidCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final VoidCallback vCb = new VoidCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.sync(path, vCb, worker);\n+                } else {\n+                    zkHandle.sync(path, vCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public States getState() {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            return ZooKeeperClient.super.getState();\n+        } else {\n+            return zkHandle.getState();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            return ZooKeeperClient.super.toString();\n+        } else {\n+            return zkHandle.toString();\n+        }\n+    }\n+\n+    @Override\n+    public String create(final String path, final byte[] data,\n+            final List<ACL> acl, final CreateMode createMode)\n+                    throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<String>() {\n+\n+            @Override\n+            public String call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.create(path, data, acl, createMode);\n+                }\n+                return zkHandle.create(path, data, acl, createMode);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void create(final String path, final byte[] data, final List<ACL> acl,\n+            final CreateMode createMode, final StringCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final StringCallback createCb = new StringCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, String name) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, name);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.create(path, data, acl, createMode, createCb, worker);\n+                } else {\n+                    zkHandle.create(path, data, acl, createMode, createCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public void delete(final String path, final int version) throws KeeperException, InterruptedException {\n+        ZooWorker.syncCallWithRetries(this, new ZooCallable<Void>() {\n+\n+            @Override\n+            public Void call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.delete(path, version);\n+                } else {\n+                    zkHandle.delete(path, version);\n+                }\n+                return null;\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void delete(final String path, final int version, final VoidCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final VoidCallback deleteCb = new VoidCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.delete(path, version, deleteCb, worker);\n+                } else {\n+                    zkHandle.delete(path, version, deleteCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public Stat exists(final String path, final Watcher watcher) throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<Stat>() {\n+\n+            @Override\n+            public Stat call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.exists(path, watcher);\n+                }\n+                return zkHandle.exists(path, watcher);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public Stat exists(final String path, final boolean watch) throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<Stat>() {\n+\n+            @Override\n+            public Stat call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.exists(path, watch);\n+                }\n+                return zkHandle.exists(path, watch);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void exists(final String path, final Watcher watcher, final StatCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final StatCallback stCb = new StatCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.exists(path, watcher, stCb, worker);\n+                } else {\n+                    zkHandle.exists(path, watcher, stCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public void exists(final String path, final boolean watch, final StatCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final StatCallback stCb = new StatCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.exists(path, watch, stCb, worker);\n+                } else {\n+                    zkHandle.exists(path, watch, stCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public byte[] getData(final String path, final Watcher watcher, final Stat stat)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<byte[]>() {\n+\n+            @Override\n+            public byte[] call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getData(path, watcher, stat);\n+                }\n+                return zkHandle.getData(path, watcher, stat);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public byte[] getData(final String path, final boolean watch, final Stat stat)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<byte[]>() {\n+\n+            @Override\n+            public byte[] call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getData(path, watch, stat);\n+                }\n+                return zkHandle.getData(path, watch, stat);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void getData(final String path, final Watcher watcher, final DataCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final DataCallback dataCb = new DataCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, data, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getData(path, watcher, dataCb, worker);\n+                } else {\n+                    zkHandle.getData(path, watcher, dataCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public void getData(final String path, final boolean watch, final DataCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final DataCallback dataCb = new DataCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, data, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getData(path, watch, dataCb, worker);\n+                } else {\n+                    zkHandle.getData(path, watch, dataCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public Stat setData(final String path, final byte[] data, final int version)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<Stat>() {\n+\n+            @Override\n+            public Stat call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.setData(path, data, version);\n+                }\n+                return zkHandle.setData(path, data, version);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void setData(final String path, final byte[] data, final int version,\n+            final StatCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final StatCallback stCb = new StatCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.setData(path, data, version, stCb, worker);\n+                } else {\n+                    zkHandle.setData(path, data, version, stCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public List<String> getChildren(final String path, final Watcher watcher, final Stat stat)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<List<String>>() {\n+\n+            @Override\n+            public List<String> call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getChildren(path, watcher, stat);\n+                }\n+                return zkHandle.getChildren(path, watcher, stat);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public List<String> getChildren(final String path, final boolean watch, final Stat stat)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<List<String>>() {\n+\n+            @Override\n+            public List<String> call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getChildren(path, watch, stat);\n+                }\n+                return zkHandle.getChildren(path, watch, stat);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void getChildren(final String path, final Watcher watcher,\n+            final Children2Callback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final Children2Callback childCb = new Children2Callback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx,\n+                        List<String> children, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, children, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getChildren(path, watcher, childCb, worker);\n+                } else {\n+                    zkHandle.getChildren(path, watcher, childCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public void getChildren(final String path, final boolean watch, final Children2Callback cb,\n+            final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final Children2Callback childCb = new Children2Callback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx,\n+                        List<String> children, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, children, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getChildren(path, watch, childCb, worker);\n+                } else {\n+                    zkHandle.getChildren(path, watch, childCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+\n+    @Override\n+    public List<String> getChildren(final String path, final Watcher watcher)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<List<String>>() {\n+\n+            @Override\n+            public List<String> call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getChildren(path, watcher);\n+                }\n+                return zkHandle.getChildren(path, watcher);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public List<String> getChildren(final String path, final boolean watch)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<List<String>>() {\n+\n+            @Override\n+            public List<String> call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.getChildren(path, watch);\n+                }\n+                return zkHandle.getChildren(path, watch);\n+            }\n+\n+        }, operationRetryPolicy);\n+    }\n+\n+    @Override\n+    public void getChildren(final String path, final Watcher watcher,\n+            final ChildrenCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final ChildrenCallback childCb = new ChildrenCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx,\n+                        List<String> children) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, children);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getChildren(path, watcher, childCb, worker);\n+                } else {\n+                    zkHandle.getChildren(path, watcher, childCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    public void getChildren(final String path, final boolean watch,\n+            final ChildrenCallback cb, final Object context) {\n+        final Runnable proc = new RetryRunnable(operationRetryPolicy) {\n+\n+            final ChildrenCallback childCb = new ChildrenCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx,\n+                        List<String> children) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (worker.allowRetry(rc)) {\n+                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    } else {\n+                        cb.processResult(rc, path, context, children);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            public void run() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.getChildren(path, watch, childCb, worker);\n+                } else {\n+                    zkHandle.getChildren(path, watch, childCb, worker);\n+                }\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+}"},{"sha":"707b8420cdd11fc1cf8a2b025d8bca090520d53b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java","status":"modified","additions":40,"deletions":4,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -20,6 +20,8 @@\n  */\n package org.apache.bookkeeper.zookeeper;\n \n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n@@ -39,17 +41,36 @@\n \n     private final int zkSessionTimeOut;\n     private CountDownLatch clientConnectLatch = new CountDownLatch(1);\n+    private final CopyOnWriteArraySet<Watcher> childWatchers =\n+            new CopyOnWriteArraySet<Watcher>();\n \n     public ZooKeeperWatcherBase(int zkSessionTimeOut) {\n         this.zkSessionTimeOut = zkSessionTimeOut;\n     }\n \n+    public ZooKeeperWatcherBase(int zkSessionTimeOut, Set<Watcher> childWatchers) {\n+        this.zkSessionTimeOut = zkSessionTimeOut;\n+        this.childWatchers.addAll(childWatchers);\n+    }\n+\n+    public ZooKeeperWatcherBase addChildWatcher(Watcher watcher) {\n+        this.childWatchers.add(watcher);\n+        return this;\n+    }\n+\n+    public ZooKeeperWatcherBase removeChildWatcher(Watcher watcher) {\n+        this.childWatchers.remove(watcher);\n+        return this;\n+    }\n+\n     @Override\n     public void process(WatchedEvent event) {\n         // If event type is NONE, this is a connection status change\n         if (event.getType() != EventType.None) {\n             LOG.debug(\"Recieved event: {}, path: {} from ZooKeeper server\",\n                     event.getType(), event.getPath());\n+            // notify the child watchers\n+            notifyEvent(event);\n             return;\n         }\n \n@@ -60,16 +81,19 @@ public void process(WatchedEvent event) {\n             clientConnectLatch.countDown();\n             break;\n         case Disconnected:\n+            clientConnectLatch = new CountDownLatch(1);\n             LOG.debug(\"Ignoring Disconnected event from ZooKeeper server\");\n             break;\n         case Expired:\n-            LOG.error(\"ZooKeeper client connection to the \"\n-                    + \"ZooKeeper server has expired!\");\n+            clientConnectLatch = new CountDownLatch(1);\n+            LOG.error(\"ZooKeeper client connection to the ZooKeeper server has expired!\");\n             break;\n         default:\n             // do nothing\n             break;\n         }\n+        // notify the child watchers\n+        notifyEvent(event);\n     }\n \n     /**\n@@ -80,8 +104,7 @@ public void process(WatchedEvent event) {\n      * @throws InterruptedException\n      *             interrupted while waiting for connection\n      */\n-    public void waitForConnection() throws KeeperException,\n-            InterruptedException {\n+    public void waitForConnection() throws KeeperException, InterruptedException {\n         if (!clientConnectLatch.await(zkSessionTimeOut, TimeUnit.MILLISECONDS)) {\n             throw KeeperException.create(KeeperException.Code.CONNECTIONLOSS);\n         }\n@@ -94,4 +117,17 @@ public int getZkSessionTimeOut() {\n         return zkSessionTimeOut;\n     }\n \n+    /**\n+     * Notify Event to child watchers.\n+     * \n+     * @param event\n+     *          Watched event received from ZooKeeper.\n+     */\n+    private void notifyEvent(WatchedEvent event) {\n+        // notify child watchers\n+        for (Watcher w : childWatchers) {\n+            w.process(event);\n+        }\n+    }\n+\n }"},{"sha":"871612ef5cade9c7088d300e93235a610973ffc5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java","status":"added","additions":147,"deletions":0,"changes":147,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -0,0 +1,147 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.zookeeper;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provide a mechanism to perform an operation on ZooKeeper that is safe on disconnections\n+ * and recoverable errors.\n+ */\n+class ZooWorker {\n+\n+    static final Logger logger = LoggerFactory.getLogger(ZooWorker.class);\n+\n+    int attempts = 0;\n+    long startTimeMs;\n+    long elapsedTimeMs = 0L;\n+    final RetryPolicy retryPolicy;\n+\n+    ZooWorker(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        this.startTimeMs = MathUtils.now();\n+    }\n+\n+    public boolean allowRetry(int rc) {\n+        if (!ZooWorker.isRecoverableException(rc)) {\n+            return false;\n+        }\n+        ++attempts;\n+        elapsedTimeMs = MathUtils.now() - startTimeMs;\n+        return retryPolicy.allowRetry(attempts, elapsedTimeMs);\n+    }\n+\n+    public long nextRetryWaitTime() {\n+        return retryPolicy.nextRetryWaitTime(attempts, elapsedTimeMs);\n+    }\n+\n+    /**\n+     * Check whether the given result code is recoverable by retry.\n+     * \n+     * @param rc result code\n+     * @return true if given result code is recoverable.\n+     */\n+    public static boolean isRecoverableException(int rc) {\n+        return KeeperException.Code.CONNECTIONLOSS.intValue() == rc ||\n+                KeeperException.Code.OPERATIONTIMEOUT.intValue() == rc ||\n+                KeeperException.Code.SESSIONMOVED.intValue() == rc ||\n+                KeeperException.Code.SESSIONEXPIRED.intValue() == rc;\n+    }\n+\n+    /**\n+     * Check whether the given exception is recoverable by retry.\n+     * \n+     * @param exception given exception\n+     * @return true if given exception is recoverable.\n+     */\n+    public static boolean isRecoverableException(KeeperException exception) {\n+        return isRecoverableException(exception.code().intValue());\n+    }\n+    \n+    static interface ZooCallable<T> {\n+        /**\n+         * Be compatible with ZooKeeper interface.\n+         *\n+         * @return value\n+         * @throws InterruptedException\n+         * @throws KeeperException\n+         */\n+        public T call() throws InterruptedException, KeeperException;\n+    }\n+\n+    /**\n+     * Execute a sync zookeeper operation with a given retry policy.\n+     * \n+     * @param client\n+     *          ZooKeeper client.\n+     * @param proc\n+     *          Synchronous zookeeper operation wrapped in a {@link Callable}.\n+     * @param retryPolicy\n+     *          Retry policy to execute the synchronous operation.\n+     * @return result of the zookeeper operation\n+     * @throws KeeperException any non-recoverable exception or recoverable exception exhausted all retires.\n+     * @throws InterruptedException the operation is interrupted.\n+     */\n+    public static<T> T syncCallWithRetries(\n+            ZooKeeperClient client, ZooCallable<T> proc, RetryPolicy retryPolicy)\n+    throws KeeperException, InterruptedException {\n+        T result = null;\n+        boolean isDone = false;\n+        int attempts = 0;\n+        long startTimeMs = MathUtils.now();\n+        while (!isDone) {\n+            try {\n+                if (null != client) {\n+                    client.waitForConnection();\n+                }\n+                logger.debug(\"Execute {} at {} retry attempt.\", proc, attempts);\n+                result = proc.call();\n+                isDone = true;\n+            } catch (KeeperException e) {\n+                ++attempts;\n+                boolean rethrow = true;\n+                long elapsedTime = MathUtils.now() - startTimeMs;\n+                if (((null != client && isRecoverableException(e)) || null == client) &&\n+                        retryPolicy.allowRetry(attempts, elapsedTime)) {\n+                    rethrow = false;\n+                }\n+                if (rethrow) {\n+                    logger.debug(\"Stopped executing {} after {} attempts.\", proc, attempts);\n+                    throw e;\n+                }\n+                TimeUnit.MILLISECONDS.sleep(retryPolicy.nextRetryWaitTime(attempts, elapsedTime));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    static<T> T syncCallWithRetries(\n+            ZooCallable<T> proc, RetryPolicy retryPolicy) throws KeeperException, InterruptedException {\n+        return syncCallWithRetries(null, proc, retryPolicy);\n+    }\n+\n+}"},{"sha":"fd61d2d0f18411920f52bbb1ad2671e66d0213de","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","status":"modified","additions":18,"deletions":9,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -80,25 +80,30 @@ public void startServer() throws Exception {\n         ZkTmpDir.delete();\n         ZkTmpDir.mkdir();\n \n+        // start the server and client.\n+        restartServer();\n+\n+        // initialize the zk client with values\n+        zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+    }\n+\n+    public void restartServer() throws Exception {\n         zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir,\n-                                  ZooKeeperServer.DEFAULT_TICK_TIME);\n+                ZooKeeperServer.DEFAULT_TICK_TIME);\n         serverFactory = new NIOServerCnxnFactory();\n         serverFactory.configure(zkaddr, 100);\n         serverFactory.startup(zks);\n \n         boolean b = ClientBase.waitForServerUp(getZooKeeperConnectString(),\n-                                               ClientBase.CONNECTION_TIMEOUT);\n+                ClientBase.CONNECTION_TIMEOUT);\n         LOG.debug(\"Server up: \" + b);\n \n         // create a zookeeper client\n         LOG.debug(\"Instantiate ZK Client\");\n         ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(10000);\n         zkc = ZkUtils.createConnectedZookeeperClient(\n                 getZooKeeperConnectString(), w);\n-\n-        // initialize the zk client with values\n-        zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n     }\n \n     public void sleepServer(final int seconds, final CountDownLatch l)\n@@ -137,7 +142,7 @@ public void expireSession(ZooKeeper zk) throws Exception {\n         zk2.close();\n     }\n \n-    public void killServer() throws Exception {\n+    public void stopServer() throws Exception {\n         if (zkc != null) {\n             zkc.close();\n         }\n@@ -146,12 +151,16 @@ public void killServer() throws Exception {\n         if (serverFactory != null) {\n             serverFactory.shutdown();\n             assertTrue(\"waiting for server down\",\n-                       ClientBase.waitForServerDown(getZooKeeperConnectString(),\n-                                                    ClientBase.CONNECTION_TIMEOUT));\n+                    ClientBase.waitForServerDown(getZooKeeperConnectString(),\n+                            ClientBase.CONNECTION_TIMEOUT));\n         }\n         if (zks != null) {\n             zks.getTxnLogFactory().close();\n         }\n+    }\n+\n+    public void killServer() throws Exception {\n+        stopServer();\n         // ServerStats.unregister();\n         FileUtils.deleteDirectory(ZkTmpDir);\n     }"}]}

