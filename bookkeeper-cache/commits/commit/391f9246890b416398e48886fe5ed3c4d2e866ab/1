{"sha":"391f9246890b416398e48886fe5ed3c4d2e866ab","node_id":"MDY6Q29tbWl0MTU3NTk1NjozOTFmOTI0Njg5MGI0MTYzOThlNDg4ODZmZTVlZDNjNGQyZTg2NmFi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-13T09:38:00Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-13T09:38:00Z"},"message":"BOOKKEEPER-326: DeadLock during ledger recovery (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1372343 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b88da420311f9414b2e88ae82c414c1c6e30a92a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b88da420311f9414b2e88ae82c414c1c6e30a92a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/391f9246890b416398e48886fe5ed3c4d2e866ab","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/391f9246890b416398e48886fe5ed3c4d2e866ab","html_url":"https://github.com/apache/bookkeeper/commit/391f9246890b416398e48886fe5ed3c4d2e866ab","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/391f9246890b416398e48886fe5ed3c4d2e866ab/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","url":"https://api.github.com/repos/apache/bookkeeper/commits/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","html_url":"https://github.com/apache/bookkeeper/commit/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20"}],"stats":{"total":82,"additions":59,"deletions":23},"files":[{"sha":"ed4ffb78ff2fdc36fc754a20a88f07379fca125b","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/391f9246890b416398e48886fe5ed3c4d2e866ab/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/391f9246890b416398e48886fe5ed3c4d2e866ab/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=391f9246890b416398e48886fe5ed3c4d2e866ab","patch":"@@ -50,6 +50,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-349: Entry logger should close all the chennels which are there in Map, instead of closing only current channel. (umamaheswararao via sijie)\n \n+        BOOKKEEPER-326: DeadLock during ledger recovery (rakeshr via ivank)\n+\n       hedwig-client:\n \n         BOOKKEEPER-274: Hedwig cpp client library should not link to cppunit which is just used for test. (sijie via ivank)"},{"sha":"3fd0e5ddbb0d4390060a8c5f5f4a10fc62bd1867","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":18,"deletions":23,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/391f9246890b416398e48886fe5ed3c4d2e866ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/391f9246890b416398e48886fe5ed3c4d2e866ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=391f9246890b416398e48886fe5ed3c4d2e866ab","patch":"@@ -114,13 +114,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.readTimeoutTimer = null;\n     }\n \n-    synchronized private void connect() {\n-        if (state == ConnectionState.CONNECTING) {\n-            return;\n-        } \n-        // Start the connection attempt to the input server host.\n-        state = ConnectionState.CONNECTING;\n-\n+    private void connect() {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\"Connecting to bookie: \" + addr);\n \n@@ -153,8 +147,6 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         state = ConnectionState.DISCONNECTED;\n                     }\n \n-                    PerChannelBookieClient.this.channel = channel;\n-\n                     // trick to not do operations under the lock, take the list\n                     // of pending ops and assign it to a new variable, while\n                     // emptying the pending ops by just assigning it to a new\n@@ -171,34 +163,37 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n-        boolean doOpNow;\n+        boolean doOpNow = false;\n \n         // common case without lock first\n         if (channel != null && state == ConnectionState.CONNECTED) {\n             doOpNow = true;\n         } else {\n \n             synchronized (this) {\n-                // check again under lock\n+                // check the channel status again under lock\n                 if (channel != null && state == ConnectionState.CONNECTED) {\n                     doOpNow = true;\n                 } else {\n-\n-                    // if reached here, channel is either null (first connection\n-                    // attempt),\n-                    // or the channel is disconnected\n-                    doOpNow = false;\n-\n-                    // connection attempt is still in progress, queue up this\n-                    // op. Op will be executed when connection attempt either\n-                    // fails\n-                    // or\n-                    // succeeds\n+                    // channel is either null (first connection attempt), or the\n+                    // channel is disconnected. Connection attempt is still in\n+                    // progress, queue up this op. Op will be executed when\n+                    // connection attempt either fails or succeeds\n                     pendingOps.add(op);\n \n-                    connect();\n+                    if (state == ConnectionState.CONNECTING) {\n+                        // just return as connection request has already send\n+                        // and waiting for the response.\n+                        return;\n+                    }\n+                    // switch state to connecting and do connection attempt\n+                    state = ConnectionState.CONNECTING;\n                 }\n             }\n+            if (!doOpNow) {\n+                // Start connection attempt to the input server host.\n+                connect();\n+            }\n         }\n \n         if (doOpNow) {"},{"sha":"8f6894d3d44a1fa3eb62643a8b77f42dfb8b4c7e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"modified","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/391f9246890b416398e48886fe5ed3c4d2e866ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/391f9246890b416398e48886fe5ed3c4d2e866ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=391f9246890b416398e48886fe5ed3c4d2e866ab","patch":"@@ -357,4 +357,43 @@ public void testLedgerOpenAfterBKCrashed() throws Exception {\n         }\n     }\n \n+    /**\n+     * Verify read last confirmed op, it shouldn't cause any deadlock as new\n+     * bookie connection is being established and returning the connection\n+     * notification in the same caller thread. It would be simulated by delaying\n+     * the future.addlistener() in PerChannelBookieClient after the connection\n+     * establishment. Now the future.addlistener() will notify back in the same\n+     * thread and simultaneously invoke the pendingOp.operationComplete() event.\n+     * \n+     * BOOKKEEPER-326\n+     */\n+    @Test\n+    public void testReadLastConfirmedOp() throws Exception {\n+        startNewBookie();\n+        startNewBookie();\n+        // Create a ledger\n+        LedgerHandle beforelh = bkc.createLedger(numBookies + 2,\n+                numBookies + 2, digestType, \"\".getBytes());\n+\n+        int numEntries = 10;\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i = 0; i < numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+        startNewBookie();\n+\n+        // create new bookie client, and forcing to establish new\n+        // PerChannelBookieClient connections for recovery flows.\n+        BookKeeperTestClient bkc1 = new BookKeeperTestClient(baseClientConf);\n+        // try to open ledger with recovery\n+        LedgerHandle afterlh = bkc1.openLedger(beforelh.getId(), digestType, \"\"\n+                .getBytes());\n+\n+        assertEquals(\"Entries got missed\", beforelh.getLastAddPushed(), afterlh\n+                .getLastAddConfirmed());\n+        bkc1.close();\n+    }\n }"}]}

