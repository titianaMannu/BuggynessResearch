{"sha":"3a950e6f7f5ca8b646e82c61c98a65991df8d88f","node_id":"MDY6Q29tbWl0MTU3NTk1NjozYTk1MGU2ZjdmNWNhOGI2NDZlODJjNjFjOThhNjU5OTFkZjhkODhm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-13T17:05:57Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-13T17:05:57Z"},"message":"BOOKKEEPER-262: Implement a meta store based hedwig metadata manager. (jiannan via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1421384 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8f89a82d2e7175ef3f30e0292bdca5112153e1f7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8f89a82d2e7175ef3f30e0292bdca5112153e1f7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3a950e6f7f5ca8b646e82c61c98a65991df8d88f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3a950e6f7f5ca8b646e82c61c98a65991df8d88f","html_url":"https://github.com/apache/bookkeeper/commit/3a950e6f7f5ca8b646e82c61c98a65991df8d88f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d932c9b2181cc9f9b6bb3b43abd5af04cda206b8","url":"https://api.github.com/repos/apache/bookkeeper/commits/d932c9b2181cc9f9b6bb3b43abd5af04cda206b8","html_url":"https://github.com/apache/bookkeeper/commit/d932c9b2181cc9f9b6bb3b43abd5af04cda206b8"}],"stats":{"total":1038,"additions":1036,"deletions":2},"files":[{"sha":"7136b2538443a49a558fca72cd34cd5c4f03d1c7","filename":"CHANGES.txt","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=3a950e6f7f5ca8b646e82c61c98a65991df8d88f","patch":"@@ -533,7 +533,9 @@ Release 4.1.0 - 2012-06-07\n         BOOKKEEPER-97: collect pub/sub/consume statistics on hub server (sijie via ivank)\n \n \tBOOKKEEPER-269: Review documentation for hedwig console client (sijie via fpj)\n-\t\n+\n+        BOOKKEEPER-262: Implement a meta store based hedwig metadata manager. (jiannan via ivank)\n+\n       hedwig-client/\n \n \tBOOKKEEPER-271: Review documentation for message bounding (ivank via fpj)"},{"sha":"ab577f1634dd5d320a1c9c581d40243189940b7d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/bookkeeper/blob/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java?ref=3a950e6f7f5ca8b646e82c61c98a65991df8d88f","patch":"@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.metastore.MSException.Code;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provides utilities for metastore.\n+ */\n+public class MetastoreUtils {\n+\n+    protected final static Logger logger = LoggerFactory.getLogger(MetastoreUtils.class);\n+\n+    static class MultiMetastoreCallback<T> implements MetastoreCallback<T> {\n+\n+        int rc = Code.OK.getCode();\n+        final int numOps;\n+        final AtomicInteger numFinished = new AtomicInteger(0);\n+        final CountDownLatch doneLatch = new CountDownLatch(1);\n+\n+        MultiMetastoreCallback(int numOps) {\n+            this.numOps = numOps;\n+        }\n+\n+        @Override\n+        public void complete(int rc, T value, Object ctx) {\n+            if (Code.OK.getCode() != rc) {\n+                this.rc = rc;\n+                doneLatch.countDown();\n+                return;\n+            }\n+            if (numFinished.incrementAndGet() == numOps) {\n+                doneLatch.countDown();\n+            }\n+        }\n+\n+        public void waitUntilAllFinished() throws MSException, InterruptedException {\n+            doneLatch.await();\n+            if (Code.OK.getCode() != rc) {\n+                throw MSException.create(Code.get(rc));\n+            }\n+        }\n+    }\n+\n+    static class SyncMetastoreCallback<T> implements MetastoreCallback<T> {\n+\n+        int rc;\n+        T result;\n+        final CountDownLatch doneLatch = new CountDownLatch(1);\n+\n+        @Override\n+        public void complete(int rc, T value, Object ctx) {\n+            this.rc = rc;\n+            result = value;\n+            doneLatch.countDown();\n+        }\n+\n+        public T getResult() throws MSException, InterruptedException {\n+            doneLatch.await();\n+\n+            if (Code.OK.getCode() != rc) {\n+                throw MSException.create(Code.get(rc));\n+            }\n+            return result;\n+        }\n+\n+    }\n+\n+    /**\n+     * Clean the given table.\n+     *\n+     * @param table\n+     *          Metastore Table.\n+     * @param numEntriesPerScan\n+     *          Num entries per scan.\n+     * @throws MSException\n+     * @throws InterruptedException\n+     */\n+    public static void cleanTable(MetastoreTable table, int numEntriesPerScan)\n+    throws MSException, InterruptedException {\n+        // open cursor\n+        SyncMetastoreCallback<MetastoreCursor> openCb = new SyncMetastoreCallback<MetastoreCursor>();\n+        table.openCursor(MetastoreTable.NON_FIELDS, openCb, null);\n+        MetastoreCursor cursor = openCb.getResult();\n+        logger.info(\"Open cursor for table {} to clean entries.\", table.getName());\n+\n+        List<String> keysToClean = new ArrayList<String>(numEntriesPerScan);\n+        int numEntriesRemoved = 0;\n+        while (cursor.hasMoreEntries()) {\n+            logger.info(\"Fetching next {} entries from table {} to clean.\",\n+                         numEntriesPerScan, table.getName());\n+            Iterator<MetastoreTableItem> iter = cursor.readEntries(numEntriesPerScan);\n+            keysToClean.clear();\n+            while (iter.hasNext()) {\n+                MetastoreTableItem item = iter.next();\n+                String key = item.getKey();\n+                keysToClean.add(key);\n+            }\n+            if (keysToClean.isEmpty()) {\n+                continue;\n+            }\n+\n+            logger.info(\"Issuing deletes to delete keys {}\", keysToClean);\n+            // issue deletes to delete batch of keys\n+            MultiMetastoreCallback<Void> mcb = new MultiMetastoreCallback<Void>(keysToClean.size());\n+            for (String key : keysToClean) {\n+                table.remove(key, Version.ANY, mcb, null);\n+            }\n+            mcb.waitUntilAllFinished();\n+            numEntriesRemoved += keysToClean.size();\n+            logger.info(\"Removed {} entries from table {}.\", numEntriesRemoved, table.getName());\n+        }\n+\n+        logger.info(\"Finished cleaning up table {}.\", table.getName());\n+    }\n+}"},{"sha":"4c7ebf4005b0f95ced9cd1941b98191a957ce2b9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=3a950e6f7f5ca8b646e82c61c98a65991df8d88f","patch":"@@ -74,6 +74,10 @@\n     protected final static String METADATA_MANAGER_BASED_TOPIC_MANAGER_ENABLED = \"metadata_manager_based_topic_manager_enabled\";\n     protected final static String METADATA_MANAGER_FACTORY_CLASS = \"metadata_manager_factory_class\";\n \n+    // metastore settings, only being used when METADATA_MANAGER_FACTORY_CLASS is MsMetadataManagerFactory\n+    protected final static String METASTORE_IMPL_CLASS = \"metastore_impl_class\";\n+    protected final static String METASTORE_MAX_ENTRIES_PER_SCAN = \"metastoreMaxEntriesPerScan\";\n+\n     private static ClassLoader defaultLoader;\n     static {\n         defaultLoader = Thread.currentThread().getContextClassLoader();\n@@ -542,4 +546,22 @@ public ServerConfiguration setMetadataManagerFactoryName(String managerClsName)\n         conf.setProperty(METADATA_MANAGER_FACTORY_CLASS, managerClsName);\n         return this;\n     }\n+\n+    /**\n+     * Get metastore implementation class.\n+     *\n+     * @return metastore implementation class name.\n+     */\n+    public String getMetastoreImplClass() {\n+        return conf.getString(METASTORE_IMPL_CLASS);\n+    }\n+\n+    /**\n+     * Get max entries per scan in metastore.\n+     *\n+     * @return max entries per scan in metastore.\n+     */\n+    public int getMetastoreMaxEntriesPerScan() {\n+        return conf.getInt(METASTORE_MAX_ENTRIES_PER_SCAN, 50);\n+    }\n }"},{"sha":"6605b1ee65897dc505bdf4a0e62e625d9895f034","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java","status":"added","additions":866,"deletions":0,"changes":866,"blob_url":"https://github.com/apache/bookkeeper/blob/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java?ref=3a950e6f7f5ca8b646e82c61c98a65991df8d88f","patch":"@@ -0,0 +1,866 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.TextFormat;\n+import com.google.protobuf.TextFormat.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.metastore.MetaStore;\n+import org.apache.bookkeeper.metastore.MetastoreCallback;\n+import org.apache.bookkeeper.metastore.MetastoreCursor;\n+import org.apache.bookkeeper.metastore.MetastoreCursor.ReadEntriesCallback;\n+import org.apache.bookkeeper.metastore.MetastoreException;\n+import org.apache.bookkeeper.metastore.MetastoreFactory;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n+import org.apache.bookkeeper.metastore.MetastoreTable;\n+import org.apache.bookkeeper.metastore.MetastoreUtils;\n+\n+import static org.apache.bookkeeper.metastore.MetastoreTable.*;\n+import org.apache.bookkeeper.metastore.MetastoreTableItem;\n+import org.apache.bookkeeper.metastore.MSException;\n+import org.apache.bookkeeper.metastore.Value;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.util.Callback;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * MetadataManagerFactory for plug-in metadata storage.\n+ */\n+public class MsMetadataManagerFactory extends MetadataManagerFactory {\n+    protected final static Logger logger = LoggerFactory.getLogger(MsMetadataManagerFactory.class);\n+\n+    static final String UTF8 = \"UTF-8\";\n+\n+    static final int CUR_VERSION = 1;\n+\n+    static final String OWNER_TABLE_NAME = \"owner\";\n+    static final String PERSIST_TABLE_NAME = \"persist\";\n+    static final String SUB_TABLE_NAME = \"sub\";\n+\n+    static class SyncResult<T> {\n+        T value;\n+        int rc;\n+        boolean finished = false;\n+\n+        public synchronized void complete(int rc, T value) {\n+            this.rc = rc;\n+            this.value = value;\n+            finished = true;\n+\n+            notify();\n+        }\n+\n+        public synchronized void block() throws InterruptedException {\n+            while (!finished) {\n+                wait();\n+            }\n+        }\n+\n+        public int getReturnCode() {\n+            return rc;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+    }\n+\n+    MetaStore metastore;\n+    MetastoreTable ownerTable;\n+    MetastoreTable persistTable;\n+    MetastoreScannableTable subTable;\n+    ServerConfiguration cfg;\n+\n+    @Override\n+    public MetadataManagerFactory initialize(ServerConfiguration cfg, ZooKeeper zk, int version) throws IOException {\n+        if (CUR_VERSION != version) {\n+            throw new IOException(\"Incompatible MsMetadataManagerFactory version \" + version\n+                    + \" found, expected version \" + CUR_VERSION);\n+        }\n+        this.cfg = cfg;\n+        try {\n+            metastore = MetastoreFactory.createMetaStore(cfg.getMetastoreImplClass());\n+            // TODO: need to store metastore class and version in some place.\n+            metastore.init(cfg.getConf(), metastore.getVersion());\n+        } catch (Exception e) {\n+            throw new IOException(\"Load metastore failed : \", e);\n+        }\n+\n+        try {\n+            ownerTable = metastore.createTable(OWNER_TABLE_NAME);\n+            if (ownerTable == null) {\n+                throw new IOException(\"create owner table failed\");\n+            }\n+\n+            persistTable = metastore.createTable(PERSIST_TABLE_NAME);\n+            if (persistTable == null) {\n+                throw new IOException(\"create persistence table failed\");\n+            }\n+\n+            subTable = metastore.createScannableTable(SUB_TABLE_NAME);\n+            if (subTable == null) {\n+                throw new IOException(\"create subscription table failed\");\n+            }\n+        } catch (MetastoreException me) {\n+            throw new IOException(\"Failed to create tables : \", me);\n+        }\n+\n+        return this;\n+    }\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        if (metastore == null) {\n+            return;\n+        }\n+\n+        if (ownerTable != null) {\n+            ownerTable.close();\n+            ownerTable = null;\n+        }\n+\n+        if (persistTable != null) {\n+            persistTable.close();\n+            persistTable = null;\n+        }\n+\n+        if (subTable != null) {\n+            subTable.close();\n+            subTable = null;\n+        }\n+\n+        metastore.close();\n+        metastore = null;\n+    }\n+\n+    @Override\n+    public Iterator<ByteString> getTopics() throws IOException {\n+        SyncResult<MetastoreCursor> syn = new SyncResult<MetastoreCursor>();\n+        persistTable.openCursor(NON_FIELDS, new MetastoreCallback<MetastoreCursor>() {\n+            public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n+                @SuppressWarnings(\"unchecked\")\n+                SyncResult<MetastoreCursor> syn = (SyncResult<MetastoreCursor>) ctx;\n+                syn.complete(rc, cursor);\n+            }\n+        }, syn);\n+        try {\n+            syn.block();\n+        } catch (Exception e) {\n+            throw new IOException(\"Interrupted on getting topics list : \", e);\n+        }\n+\n+        if (syn.getReturnCode() != MSException.Code.OK.getCode()) {\n+            throw new IOException(\"Failed to get topics : \", MSException.create(\n+                    MSException.Code.get(syn.getReturnCode()), \"\"));\n+        }\n+\n+        final MetastoreCursor cursor = syn.getValue();\n+        return new Iterator<ByteString>() {\n+            Iterator<MetastoreTableItem> itemIter = null;\n+\n+            @Override\n+            public boolean hasNext() {\n+                while (null == itemIter || !itemIter.hasNext()) {\n+                    if (!cursor.hasMoreEntries()) {\n+                        return false;\n+                    }\n+\n+                    try {\n+                        itemIter = cursor.readEntries(cfg.getMetastoreMaxEntriesPerScan());\n+                    } catch (MSException mse) {\n+                        logger.warn(\"Interrupted when iterating the topics list : \", mse);\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public ByteString next() {\n+                MetastoreTableItem t = itemIter.next();\n+                return ByteString.copyFromUtf8(t.getKey());\n+            }\n+\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException(\"Doesn't support remove topic from topic iterator.\");\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public TopicOwnershipManager newTopicOwnershipManager() {\n+        return new MsTopicOwnershipManagerImpl(ownerTable);\n+    }\n+\n+    static class MsTopicOwnershipManagerImpl implements TopicOwnershipManager {\n+\n+        static final String OWNER_FIELD = \"owner\";\n+\n+        final MetastoreTable ownerTable;\n+\n+        MsTopicOwnershipManagerImpl(MetastoreTable ownerTable) {\n+            this.ownerTable = ownerTable;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void readOwnerInfo(final ByteString topic, final Callback<Versioned<HubInfo>> callback, Object ctx) {\n+            ownerTable.get(topic.toStringUtf8(), new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (MSException.Code.NoKey.getCode() == rc) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    if (MSException.Code.OK.getCode() != rc) {\n+                        logErrorAndFinishOperation(\"Could not read ownership for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                        return;\n+                    }\n+\n+                    HubInfo owner = null;\n+                    try {\n+                        byte[] data = value.getValue().getField(OWNER_FIELD);\n+                        if (data != null) {\n+                            owner = HubInfo.parse(new String(data));\n+                        }\n+                    } catch (HubInfo.InvalidHubInfoException ihie) {\n+                        logger.warn(\"Failed to parse hub info for topic \" + topic.toStringUtf8(), ihie);\n+                    }\n+                    Version version = value.getVersion();\n+                    callback.operationFinished(ctx, new Versioned<HubInfo>(owner, version));\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void writeOwnerInfo(final ByteString topic, final HubInfo owner, final Version version,\n+                final Callback<Version> callback, Object ctx) {\n+            Value value = new Value();\n+            value.setField(OWNER_FIELD, owner.toString().getBytes());\n+\n+            ownerTable.put(topic.toStringUtf8(), value, version, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version ver, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        callback.operationFinished(ctx, ver);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(\n+                                ctx,\n+                                PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO, \"No owner info found for topic \"\n+                                        + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.KeyExists.getCode() == rc) {\n+                        // key exists\n+                        callback.operationFailed(\n+                                ctx,\n+                                PubSubException.create(StatusCode.TOPIC_OWNER_INFO_EXISTS, \"Owner info of topic \"\n+                                        + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to update owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to update ownership of topic \" + topic.toStringUtf8()\n+                                + \" to \" + owner, callback, ctx, rc);\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteOwnerInfo(final ByteString topic, Version version, final Callback<Void> callback,\n+                Object ctx) {\n+            ownerTable.remove(topic.toStringUtf8(), version, new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        logger.debug(\"Successfully deleted owner info for topic {}\", topic.toStringUtf8());\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(\n+                                ctx,\n+                                PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO, \"No owner info found for topic \"\n+                                        + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to delete owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to delete owner info for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    @Override\n+    public TopicPersistenceManager newTopicPersistenceManager() {\n+        return new MsTopicPersistenceManagerImpl(persistTable);\n+    }\n+\n+    static class MsTopicPersistenceManagerImpl implements TopicPersistenceManager {\n+\n+        static final String PERSIST_FIELD = \"prst\";\n+\n+        final MetastoreTable persistTable;\n+\n+        MsTopicPersistenceManagerImpl(MetastoreTable persistTable) {\n+            this.persistTable = persistTable;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void readTopicPersistenceInfo(final ByteString topic, final Callback<Versioned<LedgerRanges>> callback,\n+                Object ctx) {\n+            persistTable.get(topic.toStringUtf8(), new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        byte[] data = value.getValue().getField(PERSIST_FIELD);\n+                        if (data != null) {\n+                            parseAndReturnTopicLedgerRanges(topic, data, value.getVersion(), callback, ctx);\n+                        } else { // null data is same as NoKey\n+                            callback.operationFinished(ctx, null);\n+                        }\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        callback.operationFinished(ctx, null);\n+                    } else {\n+                        logErrorAndFinishOperation(\"Could not read ledgers node for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        /**\n+         * Parse ledger ranges data and return it thru callback.\n+         *\n+         * @param topic\n+         *            Topic name\n+         * @param data\n+         *            Topic Ledger Ranges data\n+         * @param version\n+         *            Version of the topic ledger ranges data\n+         * @param callback\n+         *            Callback to return ledger ranges\n+         * @param ctx\n+         *            Context of the callback\n+         */\n+        private void parseAndReturnTopicLedgerRanges(ByteString topic, byte[] data, Version version,\n+                Callback<Versioned<LedgerRanges>> callback, Object ctx) {\n+            try {\n+                LedgerRanges.Builder rangesBuilder = LedgerRanges.newBuilder();\n+                TextFormat.merge(new String(data, UTF8), rangesBuilder);\n+                LedgerRanges lr = rangesBuilder.build();\n+                Versioned<LedgerRanges> ranges = new Versioned<LedgerRanges>(lr, version);\n+                callback.operationFinished(ctx, ranges);\n+            } catch (ParseException e) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Ledger ranges for topic \").append(topic.toStringUtf8())\n+                        .append(\" could not be deserialized.\");\n+                String msg = sb.toString();\n+                logger.error(msg, e);\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+            } catch (UnsupportedEncodingException uee) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Ledger ranges for topic \").append(topic.toStringUtf8()).append(\" is not UTF-8 encoded.\");\n+                String msg = sb.toString();\n+                logger.error(msg, uee);\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+            }\n+        }\n+\n+        @Override\n+        public void writeTopicPersistenceInfo(final ByteString topic, LedgerRanges ranges, final Version version,\n+                final Callback<Version> callback, Object ctx) {\n+            Value value = new Value();\n+            value.setField(PERSIST_FIELD, TextFormat.printToString(ranges).getBytes());\n+\n+            persistTable.put(topic.toStringUtf8(), value, version, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version ver, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        callback.operationFinished(ctx, ver);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.KeyExists.getCode() == rc) {\n+                        // key exists\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS,\n+                                \"Persistence info of topic \" + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to update persistence info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Could not write ledgers node for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteTopicPersistenceInfo(final ByteString topic, final Version version,\n+                final Callback<Void> callback, Object ctx) {\n+            persistTable.remove(topic.toStringUtf8(), version, new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        logger.debug(\"Successfully deleted persistence info for topic {}.\", topic.toStringUtf8());\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to delete persistence info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to delete persistence info topic: \" + topic.toStringUtf8()\n+                                + \", version: \" + version, callback, ctx, rc, StatusCode.SERVICE_DOWN);\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    @Override\n+    public SubscriptionDataManager newSubscriptionDataManager() {\n+        return new MsSubscriptionDataManagerImpl(cfg, subTable);\n+    }\n+\n+    static class MsSubscriptionDataManagerImpl implements SubscriptionDataManager {\n+\n+        static final String SUB_STATE_FIELD = \"sub_state\";\n+        static final String SUB_PREFS_FIELD = \"sub_preferences\";\n+\n+        static final char TOPIC_SUB_FIRST_SEPARATOR = '\\001';\n+        static final char TOPIC_SUB_LAST_SEPARATOR = '\\002';\n+\n+        final ServerConfiguration cfg;\n+        final MetastoreScannableTable subTable;\n+\n+        MsSubscriptionDataManagerImpl(ServerConfiguration cfg, MetastoreScannableTable subTable) {\n+            this.cfg = cfg;\n+            this.subTable = subTable;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+\n+        private String getSubscriptionKey(ByteString topic, ByteString subscriberId) {\n+            return new StringBuilder(topic.toStringUtf8()).append(TOPIC_SUB_FIRST_SEPARATOR)\n+                    .append(subscriberId.toStringUtf8()).toString();\n+        }\n+\n+        private Value subscriptionData2Value(SubscriptionData subData) {\n+            Value value = new Value();\n+            if (subData.hasState()) {\n+                value.setField(SUB_STATE_FIELD, TextFormat.printToString(subData.getState()).getBytes());\n+            }\n+            if (subData.hasPreferences()) {\n+                value.setField(SUB_PREFS_FIELD, TextFormat.printToString(subData.getPreferences()).getBytes());\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public void createSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final SubscriptionData subData, final Callback<Version> callback, Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            Value value = subscriptionData2Value(subData);\n+\n+            subTable.put(key, value, Version.NEW, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version ver, Object ctx) {\n+                    if (rc == MSException.Code.OK.getCode()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully create subscription for topic: \" + topic.toStringUtf8()\n+                                    + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                    + SubscriptionStateUtils.toString(subData));\n+                        }\n+                        callback.operationFinished(ctx, ver);\n+                    } else if (rc == MSException.Code.KeyExists.getCode()) {\n+                        callback.operationFailed(ctx, PubSubException.create(\n+                                StatusCode.SUBSCRIPTION_STATE_EXISTS,\n+                                \"Subscription data for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                        + subscriberId.toStringUtf8() + \") existed.\"));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to create topic: \" + topic.toStringUtf8()\n+                                + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                + SubscriptionStateUtils.toString(subData), callback, ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public boolean isPartialUpdateSupported() {\n+            // TODO: Here we assume Metastore support partial update, but this\n+            // maybe incorrect.\n+            return true;\n+        }\n+\n+        @Override\n+        public void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final SubscriptionData subData, final Version version, final Callback<Version> callback,\n+                final Object ctx) {\n+            updateSubscriptionData(topic, subscriberId, subData, version, callback, ctx);\n+        }\n+\n+        @Override\n+        public void updateSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final SubscriptionData subData, final Version version, final Callback<Version> callback,\n+                final Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            Value value = subscriptionData2Value(subData);\n+\n+            subTable.put(key, value, version, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version version, Object ctx) {\n+                    if (rc == MSException.Code.OK.getCode()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully updated subscription data for topic: \" + topic.toStringUtf8()\n+                                    + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                    + SubscriptionStateUtils.toString(subData) + \", version: \" + version);\n+                        }\n+                        callback.operationFinished(ctx, version);\n+                    } else if (rc == MSException.Code.NoKey.getCode()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                \"No subscription data found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                        + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else if (rc == MSException.Code.BadVersion.getCode()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to update subscription data of topic \" + topic.toStringUtf8()\n+                                        + \" subscriberId \" + subscriberId));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\n+                                \"Failed to update subscription data for topic: \" + topic.toStringUtf8()\n+                                        + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                        + SubscriptionStateUtils.toString(subData) + \", version: \" + version, callback,\n+                                ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId, Version version,\n+                final Callback<Void> callback, Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            subTable.remove(key, version, new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    if (rc == MSException.Code.OK.getCode()) {\n+                        logger.debug(\"Successfully delete subscription for topic: {}, subscriberId: {}.\",\n+                                topic.toStringUtf8(), subscriberId.toStringUtf8());\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (rc == MSException.Code.BadVersion.getCode()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to delete subscriptoin data of topic \" + topic.toStringUtf8()\n+                                        + \" subscriberId \" + subscriberId));\n+                        return;\n+                    } else if (rc == MSException.Code.NoKey.getCode()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                \"No subscription data found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                        + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to delete subscription topic: \" + topic.toStringUtf8()\n+                                + \", subscriberId: \" + subscriberId.toStringUtf8(), callback, ctx, rc,\n+                                StatusCode.SERVICE_DOWN);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        private SubscriptionData value2SubscriptionData(Value value) throws ParseException,\n+                UnsupportedEncodingException {\n+            SubscriptionData.Builder builder = SubscriptionData.newBuilder();\n+\n+            byte[] stateData = value.getField(SUB_STATE_FIELD);\n+            if (null != stateData) {\n+                SubscriptionState.Builder stateBuilder = SubscriptionState.newBuilder();\n+                TextFormat.merge(new String(stateData, UTF8), stateBuilder);\n+                SubscriptionState state = stateBuilder.build();\n+                builder.setState(state);\n+            }\n+\n+            byte[] prefsData = value.getField(SUB_PREFS_FIELD);\n+            if (null != prefsData) {\n+                SubscriptionPreferences.Builder preferencesBuilder = SubscriptionPreferences.newBuilder();\n+                TextFormat.merge(new String(prefsData, UTF8), preferencesBuilder);\n+                SubscriptionPreferences preferences = preferencesBuilder.build();\n+                builder.setPreferences(preferences);\n+            }\n+\n+            return builder.build();\n+        }\n+\n+        @Override\n+        public void readSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final Callback<Versioned<SubscriptionData>> callback, Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            subTable.get(key, new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (rc == MSException.Code.NoKey.getCode()) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    if (rc != MSException.Code.OK.getCode()) {\n+                        logErrorAndFinishOperation(\n+                                \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                        + \", subscriberId: \" + subscriberId.toStringUtf8(), callback, ctx, rc);\n+                        return;\n+                    }\n+\n+                    try {\n+                        Versioned<SubscriptionData> subData = new Versioned<SubscriptionData>(\n+                                value2SubscriptionData(value.getValue()), value.getVersion());\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n+                                    + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                    + SubscriptionStateUtils.toString(subData.getValue()) + \", version: \"\n+                                    + subData.getVersion());\n+                        }\n+                        callback.operationFinished(ctx, subData);\n+                    } catch (ParseException e) {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(\"Failed to deserialize subscription data for topic:\").append(topic.toStringUtf8())\n+                                .append(\", subscriberId: \").append(subscriberId.toStringUtf8());\n+                        String msg = sb.toString();\n+                        logger.error(msg, e);\n+                        callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                    } catch (UnsupportedEncodingException uee) {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(\"Subscription data for topic: \").append(topic.toStringUtf8())\n+                                .append(\", subscriberId: \").append(subscriberId.toStringUtf8())\n+                                .append(\" is not UFT-8 encoded\");\n+                        String msg = sb.toString();\n+                        logger.error(msg, uee);\n+                        callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        private String getSubscriptionPrefix(ByteString topic, char sep) {\n+            return new StringBuilder(topic.toStringUtf8()).append(sep).toString();\n+        }\n+\n+        private void readSubscriptions(final ByteString topic, final int keyLength, final MetastoreCursor cursor,\n+                final Map<ByteString, Versioned<SubscriptionData>> topicSubs,\n+                final Callback<Map<ByteString, Versioned<SubscriptionData>>> callback, Object ctx) {\n+            if (!cursor.hasMoreEntries()) {\n+                callback.operationFinished(ctx, topicSubs);\n+                return;\n+            }\n+            ReadEntriesCallback readCb = new ReadEntriesCallback() {\n+                @Override\n+                public void complete(int rc, Iterator<MetastoreTableItem> items, Object ctx) {\n+                    if (rc != MSException.Code.OK.getCode()) {\n+                        logErrorAndFinishOperation(\"Could not read subscribers for cursor \" + cursor,\n+                                callback, ctx, rc);\n+                        return;\n+                    }\n+                    while (items.hasNext()) {\n+                        MetastoreTableItem item = items.next();\n+                        final ByteString subscriberId = ByteString.copyFromUtf8(item.getKey().substring(keyLength));\n+                        try {\n+                            Versioned<Value> vv = item.getValue();\n+                            Versioned<SubscriptionData> subData = new Versioned<SubscriptionData>(\n+                                    value2SubscriptionData(vv.getValue()), vv.getVersion());\n+                            topicSubs.put(subscriberId, subData);\n+                        } catch (ParseException e) {\n+                            StringBuilder sb = new StringBuilder();\n+                            sb.append(\"Failed to deserialize subscription data for topic: \")\n+                                    .append(topic.toStringUtf8()).append(\", subscriberId: \")\n+                                    .append(subscriberId.toStringUtf8());\n+                            String msg = sb.toString();\n+                            logger.error(msg, e);\n+                            callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                            return;\n+                        } catch (UnsupportedEncodingException e) {\n+                            StringBuilder sb = new StringBuilder();\n+                            sb.append(\"Subscription data for topic: \").append(topic.toStringUtf8())\n+                                    .append(\", subscriberId: \").append(subscriberId.toStringUtf8())\n+                                    .append(\" is not UTF-8 encoded.\");\n+                            String msg = sb.toString();\n+                            logger.error(msg, e);\n+                            callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                            return;\n+                        }\n+                    }\n+                    readSubscriptions(topic, keyLength, cursor, topicSubs, callback, ctx);\n+                }\n+            };\n+            cursor.asyncReadEntries(cfg.getMetastoreMaxEntriesPerScan(), readCb, ctx);\n+        }\n+\n+        @Override\n+        public void readSubscriptions(final ByteString topic,\n+                final Callback<Map<ByteString, Versioned<SubscriptionData>>> callback, Object ctx) {\n+            final String firstKey = getSubscriptionPrefix(topic, TOPIC_SUB_FIRST_SEPARATOR);\n+            String lastKey = getSubscriptionPrefix(topic, TOPIC_SUB_LAST_SEPARATOR);\n+            subTable.openCursor(firstKey, true, lastKey, true, Order.ASC, ALL_FIELDS,\n+                    new MetastoreCallback<MetastoreCursor>() {\n+                        @Override\n+                        public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n+                            if (rc != MSException.Code.OK.getCode()) {\n+                                logErrorAndFinishOperation(\n+                                        \"Could not read subscribers for topic \" + topic.toStringUtf8(), callback, ctx,\n+                                        rc);\n+                                return;\n+                            }\n+\n+                            final Map<ByteString, Versioned<SubscriptionData>> topicSubs =\n+                                    new ConcurrentHashMap<ByteString, Versioned<SubscriptionData>>();\n+                            readSubscriptions(topic, firstKey.length(), cursor, topicSubs, callback, ctx);\n+                        }\n+                    }, ctx);\n+        }\n+    }\n+\n+    /**\n+     * callback finish operation with exception specify by code, regardless of\n+     * the value of return code rc.\n+     */\n+    private static <T> void logErrorAndFinishOperation(String msg, Callback<T> callback, Object ctx, int rc,\n+            StatusCode code) {\n+        logger.error(msg, MSException.create(MSException.Code.get(rc), \"\"));\n+        callback.operationFailed(ctx, PubSubException.create(code, msg));\n+    }\n+\n+    /**\n+     * callback finish operation with corresponding PubSubException converted\n+     * from return code rc.\n+     */\n+    private static <T> void logErrorAndFinishOperation(String msg, Callback<T> callback, Object ctx, int rc) {\n+        StatusCode code;\n+\n+        if (rc == MSException.Code.NoKey.getCode()) {\n+            code = StatusCode.NO_SUCH_TOPIC;\n+        } else if (rc == MSException.Code.ServiceDown.getCode()) {\n+            code = StatusCode.SERVICE_DOWN;\n+        } else {\n+            code = StatusCode.UNEXPECTED_CONDITION;\n+        }\n+\n+        logErrorAndFinishOperation(msg, callback, ctx, rc, code);\n+    }\n+\n+    @Override\n+    public void format(ServerConfiguration cfg, ZooKeeper zk) throws IOException {\n+        try {\n+            int maxEntriesPerScan = cfg.getMetastoreMaxEntriesPerScan();\n+\n+            // clean topic ownership table.\n+            logger.info(\"Cleaning topic ownership table ...\");\n+            MetastoreUtils.cleanTable(ownerTable, maxEntriesPerScan);\n+            logger.info(\"Cleaned topic ownership table successfully.\");\n+\n+            // clean topic subscription table.\n+            logger.info(\"Cleaning topic subscription table ...\");\n+            MetastoreUtils.cleanTable(subTable, maxEntriesPerScan);\n+            logger.info(\"Cleaned topic subscription table successfully.\");\n+\n+            // clean topic persistence info table.\n+            logger.info(\"Cleaning topic persistence info table ...\");\n+            MetastoreUtils.cleanTable(persistTable, maxEntriesPerScan);\n+            logger.info(\"Cleaned topic persistence info table successfully.\");\n+        } catch (MSException mse) {\n+            throw new IOException(\"Exception when formatting hedwig metastore : \", mse);\n+        } catch (InterruptedException ie) {\n+            throw new IOException(\"Interrupted when formatting hedwig metastore : \", ie);\n+        }\n+    }\n+\n+}"},{"sha":"fb543ef7d008f29ed1d0af73a71deef4d1eccaac","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/3a950e6f7f5ca8b646e82c61c98a65991df8d88f/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java?ref=3a950e6f7f5ca8b646e82c61c98a65991df8d88f","patch":"@@ -23,6 +23,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n \n+import org.apache.bookkeeper.metastore.InMemoryMetaStore;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.meta.ZkMetadataManagerFactory;\n@@ -49,12 +50,15 @@ public MetadataManagerFactoryTestCase(String metadataManagerFactoryCls) {\n         super();\n         conf = new ServerConfiguration();\n         conf.setMetadataManagerFactoryName(metadataManagerFactoryCls);\n+        conf.getConf().setProperty(\"metastore_impl_class\", InMemoryMetaStore.class.getName());\n+        InMemoryMetaStore.reset();\n     }\n \n     @Parameters\n     public static Collection<Object[]> configs() {\n         return Arrays.asList(new Object[][] {\n-            { ZkMetadataManagerFactory.class.getName() }\n+            { ZkMetadataManagerFactory.class.getName() },\n+            { MsMetadataManagerFactory.class.getName() },\n         });\n     }\n "}]}

