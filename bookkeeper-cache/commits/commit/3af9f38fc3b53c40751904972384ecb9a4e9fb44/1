{"sha":"3af9f38fc3b53c40751904972384ecb9a4e9fb44","node_id":"MDY6Q29tbWl0MTU3NTk1NjozYWY5ZjM4ZmMzYjUzYzQwNzUxOTA0OTcyMzg0ZWNiOWE0ZTlmYjQ0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-28T18:25:18Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-28T18:25:18Z"},"message":"BOOKKEEPER-39: Bookie server failed to restart because of too many ledgers (more than ~50,000 ledgers) (Sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1207495 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5901519c151d210cb9b85e14c90c6a04ce19966d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/5901519c151d210cb9b85e14c90c6a04ce19966d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3af9f38fc3b53c40751904972384ecb9a4e9fb44","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3af9f38fc3b53c40751904972384ecb9a4e9fb44","html_url":"https://github.com/apache/bookkeeper/commit/3af9f38fc3b53c40751904972384ecb9a4e9fb44","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3af9f38fc3b53c40751904972384ecb9a4e9fb44/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d5d73a8591369458c075034b8111f0dfabc2916d","url":"https://api.github.com/repos/apache/bookkeeper/commits/d5d73a8591369458c075034b8111f0dfabc2916d","html_url":"https://github.com/apache/bookkeeper/commit/d5d73a8591369458c075034b8111f0dfabc2916d"}],"stats":{"total":2880,"additions":2533,"deletions":347},"files":[{"sha":"0b78b57017c77ec59b7e75a5ccb97a19315a3731","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -80,6 +80,8 @@ BUGFIXES:\n \n   BOOKKEEPER-114: add a shutdown hook to shut down bookie server safely. (Sijie via ivank)\n \n+  BOOKKEEPER-39: Bookie server failed to restart because of too many ledgers (more than ~50,000 ledgers) (Sijie via ivank)\n+\n  hedwig-server/\n \n   BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)"},{"sha":"ccae1958af8f7071524695920e75bac736e880c6","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bk_server.conf?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -38,6 +38,16 @@ journalDirectory=/tmp/bk-txn\n # It is possible to run with a single disk, but performance will be significantly lower.\n ledgerDirectories=/tmp/bk-data\n \n+# Ledger Manager Class\n+# What kind of ledger manager is used to manage how ledgers are stored, managed\n+# and garbage collected. Try to read 'BookKeeper Overview' for detail info.\n+# ledgerManagerType=flat\n+\n+# Root zookeeper path to store ledger metadata\n+# This parameter is used by zookeeper-based ledger manager as a root znode to\n+# store all ledgers.\n+# zkLedgersRootPath=/ledgers\n+\n # Max file size of entry logger, in bytes\n # A new entry log file will be created when the old one reaches the file size limitation\n # logSizeLimit=2147483648"},{"sha":"cb3bb26a2cfff6a681e3ce2784761422e5e16ed0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":39,"deletions":17,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -43,20 +43,20 @@\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.ZooDefs.Ids;\n \n-\n-\n /**\n  * Implements a bookie.\n  *\n@@ -78,6 +78,7 @@\n     final ServerConfiguration conf;\n \n     final SyncThread syncThread;\n+    final LedgerManager ledgerManager;\n \n     /**\n      * Current directory layout version. Increment this \n@@ -242,23 +243,28 @@ void shutdown() throws InterruptedException {\n         }\n     }\n \n-    public Bookie(ServerConfiguration conf) throws IOException {\n+    public Bookie(ServerConfiguration conf) \n+            throws IOException, KeeperException, InterruptedException {\n+        this.conf = conf;\n         this.journalDirectory = conf.getJournalDir();\n         this.ledgerDirectories = conf.getLedgerDirs();\n-        this.conf = conf;\n+        this.maxJournalSize = conf.getMaxJournalSize() * MB;\n+        this.maxBackupJournals = conf.getMaxBackupJournals();\n \n+        // check directory layouts\n         checkDirectoryLayoutVersion(journalDirectory);\n         for (File dir : ledgerDirectories) {\n             checkDirectoryLayoutVersion(dir);\n         }\n \n-        this.maxJournalSize = conf.getMaxJournalSize() * MB;\n-        this.maxBackupJournals = conf.getMaxBackupJournals();\n+        // instantiate zookeeper client to initialize ledger manager\n+        ZooKeeper newZk = instantiateZookeeperClient(conf.getZkServers());\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, newZk);\n \n         syncThread = new SyncThread(conf);\n         entryLogger = new EntryLogger(conf, this);\n-        ledgerCache = new LedgerCache(conf);\n-    \n+        ledgerCache = new LedgerCache(conf, ledgerManager);\n+\n         lastLogMark.readLog();\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Last Log Mark : \" + lastLogMark);\n@@ -332,7 +338,12 @@ public boolean accept(long journalId) {\n                 }\n             }\n         }\n-        instantiateZookeeperClient(conf.getBookiePort(), conf.getZkServers());\n+        // pass zookeeper instance here\n+        // since GarbageCollector thread should only start after journal\n+        // finished replay\n+        this.zk = newZk;\n+        // make the bookie available\n+        registerBookie(conf.getBookiePort());\n         setDaemon(true);\n         LOG.debug(\"I'm starting a bookie with journal directory \" + journalDirectory.getName());\n         start();\n@@ -375,20 +386,29 @@ public boolean accept(long journalId) {\n         Collections.sort(logs);\n         return logs;\n     }\n-    \n+\n     /**\n      * Instantiate the ZooKeeper client for the Bookie.\n      */\n-    private void instantiateZookeeperClient(int port, String zkServers) throws IOException {\n+    private ZooKeeper instantiateZookeeperClient(String zkServers) throws IOException {\n         if (zkServers == null) {\n             LOG.warn(\"No ZK servers passed to Bookie constructor so BookKeeper clients won't know about this server!\");\n-            zk = null;\n             isZkExpired = false;\n-            return;\n+            return null;\n         }\n         int zkTimeout = conf.getZkTimeout();\n         // Create the ZooKeeper client instance\n-        zk = newZookeeper(zkServers, zkTimeout);\n+        return newZookeeper(zkServers, zkTimeout);\n+    }\n+\n+    /**\n+     * Register as an available bookie\n+     */\n+    private void registerBookie(int port) throws IOException {\n+        if (null == zk) {\n+            // zookeeper instance is null, means not register itself to zk\n+            return;\n+        }\n         // Create the ZK ephemeral node for this Bookie.\n         try {\n             zk.create(BOOKIE_REGISTRATION_PATH + InetAddress.getLocalHost().getHostAddress() + \":\" + port, new byte[0],\n@@ -853,6 +873,8 @@ public synchronized void shutdown() throws InterruptedException {\n         }\n         // Shutdown the EntryLogger which has the GarbageCollector Thread running\n         entryLogger.shutdown();\n+        // close Ledger Manager\n+        ledgerManager.close();\n         // setting running to false here, so watch thread in bookie server know it only after bookie shut down\n         running = false;\n     }\n@@ -983,8 +1005,8 @@ synchronized public void waitZero() throws InterruptedException {\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    public static void main(String[] args) throws IOException,\n-        InterruptedException, BookieException {\n+    public static void main(String[] args) \n+            throws IOException, InterruptedException, BookieException, KeeperException {\n         Bookie b = new Bookie(new ServerConfiguration());\n         CounterCallback cb = new CounterCallback();\n         long start = System.currentTimeMillis();"},{"sha":"185619b7c47306f193f5fbe497343c62739c1054","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":64,"deletions":104,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -35,17 +35,14 @@\n import java.nio.channels.FileChannel;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.zookeeper.AsyncCallback;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.bookkeeper.meta.LedgerManager;\n \n /**\n  * This class manages the writing of the bookkeeper entries. All the new\n@@ -77,11 +74,6 @@\n     // this indicates that a write has happened since the last flush\n     private volatile boolean somethingWritten = false;\n \n-    // ZK ledgers related String constants\n-    static final String LEDGERS_PATH = \"/ledgers\";\n-    static final String LEDGER_NODE_PREFIX = \"L\";\n-    static final String AVAILABLE_NODE = \"available\";\n-\n     // Maps entry log files to the set of ledgers that comprise the file.\n     private ConcurrentMap<Long, ConcurrentHashMap<Long, Boolean>> entryLogs2LedgersMap = new ConcurrentHashMap<Long, ConcurrentHashMap<Long, Boolean>>();\n     // This is the thread that garbage collects the entry logs that do not\n@@ -146,105 +138,73 @@ public void run() {\n                     }\n                 }\n                 // Initialization check. No need to run any logic if we are still starting up.\n-                if (bookie.zk == null || entryLogs2LedgersMap.isEmpty() || bookie.ledgerCache == null\n-                        || bookie.ledgerCache.activeLedgers == null) {\n+                if (bookie.zk == null || entryLogs2LedgersMap.isEmpty() ||\n+                    bookie.ledgerCache == null) {\n                     continue;\n                 }\n-                // First sync ZK to make sure we're reading the latest active/available ledger nodes.\n-                bookie.zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n-                    @Override\n-                    public void processResult(int rc, String path, Object ctx) {\n-                        if (rc != Code.OK.intValue()) {\n-                            LOG.error(\"ZK error syncing the ledgers node when getting children: \", KeeperException\n-                                      .create(KeeperException.Code.get(rc), path));\n-                            return;\n-                        }\n-                        // Sync has completed successfully so now we can poll ZK\n-                        // and read in the latest set of active ledger nodes.\n-                        List<String> ledgerNodes;\n+\n+                // gc inactive/deleted ledgers\n+                doGcLedgers();\n+\n+                // gc entry logs\n+                doGcEntryLogs();\n+            }\n+        }\n+\n+        /**\n+         * Do garbage collection ledger index files\n+         */\n+        private void doGcLedgers() {\n+            bookie.ledgerCache.activeLedgerManager.garbageCollectLedgers(\n+            new LedgerManager.GarbageCollector() {\n+                @Override\n+                public void gc(long ledgerId) {\n+                    try {\n+                        bookie.ledgerCache.deleteLedger(ledgerId);\n+                    } catch (IOException e) {\n+                        LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n+                    }\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Garbage collect those entry loggers which are not associated with any active ledgers\n+         */\n+        private void doGcEntryLogs() {\n+            // Loop through all of the entry logs and remove the non-active ledgers.\n+            for (Long entryLogId : entryLogs2LedgersMap.keySet()) {\n+                ConcurrentHashMap<Long, Boolean> entryLogLedgers = entryLogs2LedgersMap.get(entryLogId);\n+                for (Long entryLogLedger : entryLogLedgers.keySet()) {\n+                    // Remove the entry log ledger from the set if it isn't active.\n+                    if (!bookie.ledgerCache.activeLedgerManager.containsActiveLedger(entryLogLedger)) {\n+                        entryLogLedgers.remove(entryLogLedger);\n+                    }\n+                }\n+                if (entryLogLedgers.isEmpty()) {\n+                    // This means the entry log is not associated with any active ledgers anymore.\n+                    // We can remove this entry log file now.\n+                    LOG.info(\"Deleting entryLogId \" + entryLogId + \" as it has no active ledgers!\");\n+                    BufferedChannel bc = channels.remove(entryLogId);\n+                    if (null != bc) {\n+                        // close its underlying file channel, so it could be deleted really\n                         try {\n-                            ledgerNodes = bookie.zk.getChildren(LEDGERS_PATH, null);\n-                        } catch (Exception e) {\n-                            LOG.error(\"Error polling ZK for the available ledger nodes: \", e);\n-                            // We should probably wait a certain amount of time before retrying in case of temporary issues.\n-                            return;\n-                        }\n-                        if (LOG.isDebugEnabled()) {\n-                            LOG.debug(\"Retrieved current set of ledger nodes: \" + ledgerNodes);\n-                        }\n-                        // Convert the ZK retrieved ledger nodes to a HashSet for easier comparisons.\n-                        HashSet<Long> allActiveLedgers = new HashSet<Long>(ledgerNodes.size(), 1.0f);\n-                        for (String ledgerNode : ledgerNodes) {\n-                            try {\n-                                // The available node is also stored in this path so ignore that.\n-                                // That node is the path for the set of available Bookie Servers.\n-                                if (ledgerNode.equals(AVAILABLE_NODE))\n-                                    continue;\n-                                String parts[] = ledgerNode.split(LEDGER_NODE_PREFIX);\n-                                allActiveLedgers.add(Long.parseLong(parts[parts.length - 1]));\n-                            } catch (NumberFormatException e) {\n-                                LOG.error(\"Error extracting ledgerId from ZK ledger node: \" + ledgerNode);\n-                                // This is a pretty bad error as it indicates a ledger node in ZK\n-                                // has an incorrect format. For now just continue and consider\n-                                // this as a non-existent ledger.\n-                                continue;\n-                            }\n-                        }\n-                        ConcurrentMap<Long, Boolean> curActiveLedgers = bookie.ledgerCache.activeLedgers;\n-                        if (LOG.isDebugEnabled()) {\n-                            LOG.debug(\"All active ledgers from ZK: \" + allActiveLedgers);\n-                            LOG.debug(\"Current active ledgers from Bookie: \" + curActiveLedgers.keySet());\n-                        }\n-                        // Remove any active ledgers that don't exist in ZK.\n-                        for (Long ledger : curActiveLedgers.keySet()) {\n-                            if (!allActiveLedgers.contains(ledger)) {\n-                                // Remove it from the current active ledgers set and also from all\n-                                // LedgerCache data references to the ledger, i.e. the physical ledger index file.\n-                                LOG.info(\"Removing a non-active/deleted ledger: \" + ledger);\n-                                curActiveLedgers.remove(ledger);\n-                                try {\n-                                    bookie.ledgerCache.deleteLedger(ledger);\n-                                } catch (IOException e) {\n-                                    LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n-                                }\n-                            }\n+                            bc.getFileChannel().close();\n+                        } catch (IOException ie) {\n+                            LOG.warn(\"Exception while closing garbage collected entryLog file : \", ie);\n                         }\n-                        // Loop through all of the entry logs and remove the non-active ledgers.\n-                        for (Long entryLogId : entryLogs2LedgersMap.keySet()) {\n-                            ConcurrentHashMap<Long, Boolean> entryLogLedgers = entryLogs2LedgersMap.get(entryLogId);\n-                            for (Long entryLogLedger : entryLogLedgers.keySet()) {\n-                                // Remove the entry log ledger from the set if it isn't active.\n-                                if (!bookie.ledgerCache.activeLedgers.containsKey(entryLogLedger)) {\n-                                    entryLogLedgers.remove(entryLogLedger);\n-                                }\n-                            }\n-                            if (entryLogLedgers.isEmpty()) {\n-                                // This means the entry log is not associated with any active ledgers anymore.\n-                                // We can remove this entry log file now.\n-                                LOG.info(\"Deleting entryLogId \" + entryLogId + \" as it has no active ledgers!\");\n-                                BufferedChannel bc = channels.remove(entryLogId);\n-                                if (null != bc) {\n-                                    // close its underlying file channel, so it could be deleted really\n-                                    try {\n-                                        bc.getFileChannel().close();\n-                                    } catch (IOException ie) {\n-                                        LOG.warn(\"Exception while closing garbage colected entryLog file : \", ie);\n-                                    }\n-                                }\n-                                File entryLogFile;\n-                                try {\n-                                    entryLogFile = findFile(entryLogId);\n-                                } catch (FileNotFoundException e) {\n-                                    LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n-                                              + entryLogId + \".log\");\n-                                    continue;\n-                                }\n-                                entryLogFile.delete();\n-                                entryLogs2LedgersMap.remove(entryLogId);\n-                            }\n-                        }\n-                    };\n-                }, null);\n+                    }\n+                    File entryLogFile;\n+                    try {\n+                        entryLogFile = findFile(entryLogId);\n+                    } catch (FileNotFoundException e) {\n+                        LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n+                                + entryLogId + \".log\");\n+                        continue;\n+                    }\n+                    entryLogFile.delete();\n+                    entryLogs2LedgersMap.remove(entryLogId);\n+                }\n             }\n         }\n     }"},{"sha":"d2f959b1eb0eb8a61e79f2f136c9cb552f852757","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":10,"deletions":13,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -33,11 +33,9 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Random;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n \n+import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -51,7 +49,7 @@\n \n     final File ledgerDirectories[];\n \n-    public LedgerCache(ServerConfiguration conf) {\n+    public LedgerCache(ServerConfiguration conf, LedgerManager alm) {\n         this.ledgerDirectories = conf.getLedgerDirs();\n         this.openFileLimit = conf.getOpenFileLimit();\n         this.pageSize = conf.getPageSize();\n@@ -65,6 +63,7 @@ public LedgerCache(ServerConfiguration conf) {\n         }\n         LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n         LOG.info(\"openFileLimit is \" + openFileLimit + \", pageSize is \" + pageSize + \", pageLimit is \" + pageLimit);\n+        activeLedgerManager = alm;\n         // Retrieve all of the active ledgers.\n         getActiveLedgers();\n     }\n@@ -82,8 +81,9 @@ public LedgerCache(ServerConfiguration conf) {\n \n     LinkedList<Long> openLedgers = new LinkedList<Long>();\n \n-    // Stores the set of active (non-deleted) ledgers.\n-    ConcurrentMap<Long, Boolean> activeLedgers = new ConcurrentHashMap<Long, Boolean>();\n+    // Manage all active ledgers in LedgerManager\n+    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n+    final LedgerManager activeLedgerManager;\n \n     final int openFileLimit;\n     final int pageSize;\n@@ -237,7 +237,7 @@ FileInfo getFileInfo(Long ledger, boolean create) throws IOException {\n                     if (LOG.isDebugEnabled()) {\n                         LOG.debug(\"New ledger index file created for ledgerId: \" + ledger);\n                     }\n-                    activeLedgers.put(ledger, true);\n+                    activeLedgerManager.addActiveLedger(ledger, true);\n                 }\n                 if (openLedgers.size() > openFileLimit) {\n                     fileInfoCache.remove(openLedgers.removeFirst()).close();\n@@ -505,16 +505,13 @@ private void getActiveLedgers() {\n                                 // We've found a ledger index file. The file name is the\n                                 // HexString representation of the ledgerId.\n                                 String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n-                                activeLedgers.put(Long.parseLong(ledgerIdInHex, 16), true);\n+                                activeLedgerManager.addActiveLedger(Long.parseLong(ledgerIdInHex, 16), true);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Active ledgers found: \" + activeLedgers);\n-        }\n     }\n \n     /**\n@@ -529,8 +526,8 @@ void deleteLedger(long ledgerId) throws IOException {\n         fi.getFile().delete();\n         fi.close();\n \n-        // Remove it from the activeLedgers set\n-        activeLedgers.remove(ledgerId);\n+        // Remove it from the active ledger manager\n+        activeLedgerManager.removeActiveLedger(ledgerId);\n \n         // Now remove it from all the other lists and maps.\n         // These data structures need to be synchronized first before removing entries."},{"sha":"04fbc05cb90f3a3cb49a6d17789285625031cbcf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":17,"deletions":6,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -23,16 +23,15 @@\n \n import java.io.IOException;\n import java.util.concurrent.Executors;\n-import java.util.EnumSet;\n-import java.util.Set;\n \n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.BKException.Code;\n import org.apache.bookkeeper.proto.BookieClient;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -78,9 +77,11 @@\n     OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime\n             .getRuntime().availableProcessors());\n \n+    // Ledger manager responsible for how to store ledger meta data\n+    final LedgerManager ledgerManager;\n+\n     ClientConfiguration conf;\n \n-    \n     /**\n      * Create a bookkeeper client. A zookeeper client and a client socket factory\n      * will be instantiated as part of this constructor.\n@@ -137,10 +138,12 @@ public void process(WatchedEvent event) {\n      * @param zk\n      *          Zookeeper client instance connected to the zookeeper with which\n      *          the bookies have registered\n+     * @throws IOException\n      * @throws InterruptedException\n      * @throws KeeperException\n      */\n-    public BookKeeper(ClientConfiguration conf, ZooKeeper zk) throws InterruptedException, KeeperException {\n+    public BookKeeper(ClientConfiguration conf, ZooKeeper zk)\n+        throws IOException, InterruptedException, KeeperException {\n         this(conf, zk, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n                 Executors.newCachedThreadPool()));\n         ownChannelFactory = true;\n@@ -158,11 +161,12 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk) throws InterruptedExce\n      *          the bookies have registered\n      * @param channelFactory\n      *          A factory that will be used to create connections to the bookies\n+     * @throws IOException\n      * @throws InterruptedException\n      * @throws KeeperException\n      */\n     public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n-            throws InterruptedException, KeeperException {\n+            throws IOException, InterruptedException, KeeperException {\n         if (zk == null || channelFactory == null) {\n             throw new NullPointerException();\n         }\n@@ -172,6 +176,12 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n         bookieWatcher = new BookieWatcher(this);\n         bookieWatcher.readBookiesBlocking();\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n+        // intialize ledger meta manager\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n+    }\n+\n+    LedgerManager getLedgerManager() {\n+        return ledgerManager;\n     }\n \n     /**\n@@ -463,6 +473,7 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n      */\n     public void close() throws InterruptedException, BKException {\n         bookieClient.close();\n+        ledgerManager.close();\n         bookieWatcher.halt();\n         if (ownChannelFactory) {\n             channelFactory.releaseExternalResources();"},{"sha":"37623dccf9e71a949d824b6089f8e01aee409f37","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":43,"deletions":120,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -21,9 +21,6 @@\n  *\n  */\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n@@ -33,14 +30,14 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Random;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.slf4j.Logger;\n@@ -65,10 +62,7 @@\n     // ZK client instance\n     private ZooKeeper zk;\n     // ZK ledgers related String constants\n-    static final String LEDGERS_PATH = \"/ledgers\";\n-    static final String LEDGER_NODE_PREFIX = \"L\";\n-    static final String AVAILABLE_NODE = \"available\";\n-    static final String BOOKIES_PATH = LEDGERS_PATH + \"/\" + AVAILABLE_NODE;\n+    static final String BOOKIES_PATH = BookieWatcher.BOOKIE_REGISTRATION_PATH;\n \n     // BookKeeper client instance\n     private BookKeeper bkc;\n@@ -160,52 +154,6 @@ public void close() throws InterruptedException, BKException {\n         zk.close();\n     }\n \n-    /**\n-     * This is a multi callback object for bookie recovery that waits for all of\n-     * the multiple async operations to complete. If any fail, then we invoke\n-     * the final callback with a BK LedgerRecoveryException.\n-     */\n-    class MultiCallback implements AsyncCallback.VoidCallback {\n-        // Number of expected callbacks\n-        final int expected;\n-        // Final callback and the corresponding context to invoke\n-        final AsyncCallback.VoidCallback cb;\n-        final Object context;\n-        // This keeps track of how many operations have completed\n-        final AtomicInteger done = new AtomicInteger();\n-        // List of the exceptions from operations that completed unsuccessfully\n-        final LinkedBlockingQueue<Integer> exceptions = new LinkedBlockingQueue<Integer>();\n-\n-        MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context) {\n-            this.expected = expected;\n-            this.cb = cb;\n-            this.context = context;\n-            if (expected == 0) {\n-                cb.processResult(Code.OK.intValue(), null, context);\n-            }\n-        }\n-\n-        private void tick() {\n-            if (done.incrementAndGet() == expected) {\n-                if (exceptions.isEmpty()) {\n-                    cb.processResult(Code.OK.intValue(), null, context);\n-                } else {\n-                    cb.processResult(BKException.Code.LedgerRecoveryException, null, context);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void processResult(int rc, String path, Object ctx) {\n-            if (rc != Code.OK.intValue()) {\n-                LOG.error(\"BK error recovering ledger data\", BKException.create(rc));\n-                exceptions.add(rc);\n-            }\n-            tick();\n-        }\n-\n-    }\n-\n     /**\n      * Method to get the input ledger's digest type. For now, this is just a\n      * placeholder function since there is no way we can get this information\n@@ -316,8 +264,8 @@ public void recoverComplete(int rc, Object ctx) {\n      */\n     public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n                                        final RecoverCallback cb, final Object context) {\n-        // Sync ZK to make sure we're reading the latest bookie/ledger data.\n-        zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n+        // Sync ZK to make sure we're reading the latest bookie data.\n+        zk.sync(BOOKIES_PATH, new AsyncCallback.VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 if (rc != Code.OK.intValue()) {\n@@ -407,36 +355,30 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      */\n     private void getActiveLedgers(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n                                   final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n-        zk.getChildren(LEDGERS_PATH, null, new AsyncCallback.ChildrenCallback() {\n-            @Override\n-            public void processResult(int rc, String path, Object ctx, List<String> children) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"ZK error getting ledger nodes: \", KeeperException.create(KeeperException.Code.get(rc),\n-                              path));\n-                    cb.recoverComplete(BKException.Code.ZKException, context);\n-                    return;\n-                }\n-                // Wrapper class around the RecoverCallback so it can be used\n-                // as the final VoidCallback to invoke within the MultiCallback.\n-                class RecoverCallbackWrapper implements AsyncCallback.VoidCallback {\n-                    final RecoverCallback cb;\n+        // Wrapper class around the RecoverCallback so it can be used\n+        // as the final VoidCallback to process ledgers\n+        class RecoverCallbackWrapper implements AsyncCallback.VoidCallback {\n+            final RecoverCallback cb;\n \n-                    RecoverCallbackWrapper(RecoverCallback cb) {\n-                        this.cb = cb;\n-                    }\n+            RecoverCallbackWrapper(RecoverCallback cb) {\n+                this.cb = cb;\n+            }\n \n-                    @Override\n-                    public void processResult(int rc, String path, Object ctx) {\n-                        cb.recoverComplete(rc, ctx);\n-                    }\n-                }\n-                // Recover each of the ledgers asynchronously\n-                MultiCallback ledgerMcb = new MultiCallback(children.size(), new RecoverCallbackWrapper(cb), context);\n-                for (final String ledgerNode : children) {\n-                    recoverLedger(bookieSrc, ledgerNode, ledgerMcb, availableBookies);\n-                }\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                cb.recoverComplete(rc, ctx);\n             }\n-        }, null);\n+        }\n+\n+        Processor<Long> ledgerProcessor = new Processor<Long>() {\n+            @Override\n+            public void process(Long ledgerId, AsyncCallback.VoidCallback iterCallback) {\n+                recoverLedger(bookieSrc, ledgerId, iterCallback, availableBookies);\n+            }\n+        };\n+        bkc.getLedgerManager().asyncProcessLedgers(\n+            ledgerProcessor, new RecoverCallbackWrapper(cb),\n+            context, BKException.Code.OK, BKException.Code.LedgerRecoveryException);\n     }\n \n     /**\n@@ -462,42 +404,21 @@ private InetSocketAddress getNewBookie(final List<InetSocketAddress> bookiesAlre\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n-     * @param ledgerNode\n-     *            Ledger Node name as retrieved from ZooKeeper we want to\n-     *            recover.\n-     * @param ledgerMcb\n-     *            MultiCallback to invoke once we've recovered the current\n+     * @param lId\n+     *            Ledger id we want to recover.\n+     * @param ledgerIterCb\n+     *            IterationCallback to invoke once we've recovered the current\n      *            ledger.\n      * @param availableBookies\n      *            List of Bookie Servers that are available to use for\n      *            replicating data on the failed bookie. This could contain a\n      *            single bookie server if the user explicitly chose a bookie\n      *            server to replicate data to.\n      */\n-    private void recoverLedger(final InetSocketAddress bookieSrc, final String ledgerNode,\n-                               final MultiCallback ledgerMcb, final List<InetSocketAddress> availableBookies) {\n-        /*\n-         * The available node is also stored in this path so ignore that. That\n-         * node is the path for the set of available Bookie Servers.\n-         */\n-        if (ledgerNode.equals(AVAILABLE_NODE)) {\n-            ledgerMcb.processResult(BKException.Code.OK, null, null);\n-            return;\n-        }\n-        // Parse out the ledgerId from the ZK ledger node.\n-        String parts[] = ledgerNode.split(LEDGER_NODE_PREFIX);\n-        if (parts.length < 2) {\n-            LOG.error(\"Ledger Node retrieved from ZK has invalid name format: \" + ledgerNode);\n-            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n-            return;\n-        }\n-        final long lId;\n-        try {\n-            lId = Long.parseLong(parts[parts.length - 1]);\n-        } catch (NumberFormatException e) {\n-            LOG.error(\"Error retrieving ledgerId from ledgerNode: \" + ledgerNode, e);\n-            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n-            return;\n+    private void recoverLedger(final InetSocketAddress bookieSrc, final long lId,\n+                               final AsyncCallback.VoidCallback ledgerIterCb, final List<InetSocketAddress> availableBookies) {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Recovering ledger : \" + lId);\n         }\n         /*\n          * For the current ledger, open it to retrieve the LedgerHandle. This\n@@ -512,7 +433,7 @@ private void recoverLedger(final InetSocketAddress bookieSrc, final String ledge\n             public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                 if (rc != Code.OK.intValue()) {\n                     LOG.error(\"BK error opening ledger: \" + lId, BKException.create(rc));\n-                    ledgerMcb.processResult(rc, null, null);\n+                    ledgerIterCb.processResult(rc, null, null);\n                     return;\n                 }\n                 /*\n@@ -550,17 +471,17 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                  * multiCallback and return.\n                  */\n                 if (ledgerFragmentsToRecover.size() == 0) {\n-                    ledgerMcb.processResult(BKException.Code.OK, null, null);\n+                    ledgerIterCb.processResult(BKException.Code.OK, null, null);\n                     return;\n                 }\n \n                 /*\n                  * Multicallback for ledger. Once all fragments for the ledger have been recovered\n-                 * trigger the ledgerMcb \n+                 * trigger the ledgerIterCb\n                  */\n-                MultiCallback ledgerFragmentsMcb \n-                    = new MultiCallback(ledgerFragmentsToRecover.size(), ledgerMcb, null);\n-\n+                MultiCallback ledgerFragmentsMcb\n+                    = new MultiCallback(ledgerFragmentsToRecover.size(), ledgerIterCb, null,\n+                                        BKException.Code.OK, BKException.Code.LedgerRecoveryException);\n                 /*\n                  * Now recover all of the necessary ledger fragments\n                  * asynchronously using a MultiCallback for every fragment.\n@@ -657,7 +578,9 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n          * Now asynchronously replicate all of the entries for the ledger\n          * fragment that were on the dead bookie.\n          */\n-        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(entriesToReplicate.size(), cb, null);\n+        MultiCallback ledgerFragmentEntryMcb =\n+            new MultiCallback(entriesToReplicate.size(), cb, null,\n+                              BKException.Code.OK, BKException.Code.LedgerRecoveryException);\n         for (final Long entryId : entriesToReplicate) {\n             recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb, newBookie);\n         }"},{"sha":"31751119c5cf08cf4e9a8f48fc3cab7d3e9a1f43","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":10,"deletions":22,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -28,21 +28,18 @@\n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.AsyncCallback.StatCallback;\n-import org.apache.zookeeper.AsyncCallback.StringCallback;\n-import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.data.Stat;\n \n /**\n  * Encapsulates asynchronous ledger create operation\n  *\n  */\n-class LedgerCreateOp implements StringCallback, StatCallback {\n+class LedgerCreateOp implements GenericCallback<String>, StatCallback {\n \n     static final Logger LOG = LoggerFactory.getLogger(LedgerCreateOp.class);\n \n@@ -86,27 +83,18 @@\n      * Initiates the operation\n      */\n     public void initiate() {\n-        /*\n-         * Create ledger node on ZK. We get the id from the sequence number on\n-         * the node.\n-         */\n-\n-        bk.getZkHandle().create(StringUtils.prefix, new byte[0], Ids.OPEN_ACL_UNSAFE,\n-                                CreateMode.PERSISTENT_SEQUENTIAL, this, null);\n-\n-        // calls the children callback method below\n+        bk.getLedgerManager().newLedgerPath(this);\n     }\n \n-\n     /**\n-     * Implements ZooKeeper string callback.\n-     *\n-     * @see org.apache.zookeeper.AsyncCallback.StringCallback#processResult(int, java.lang.String, java.lang.Object, java.lang.String)\n+     * Callback when created ledger path.\n      */\n-    public void processResult(int rc, String path, Object ctx, String name) {\n+    @Override\n+    public void operationComplete(int rc, String ledgerPath) {\n \n         if (rc != KeeperException.Code.OK.intValue()) {\n-            LOG.error(\"Could not create node for ledger\", KeeperException.create(KeeperException.Code.get(rc), path));\n+            LOG.error(\"Could not create node for ledger\",\n+                      KeeperException.create(KeeperException.Code.get(rc), ledgerPath));\n             cb.createComplete(BKException.Code.ZKException, null, this.ctx);\n             return;\n         }\n@@ -116,9 +104,9 @@ public void processResult(int rc, String path, Object ctx, String name) {\n          */\n         long ledgerId;\n         try {\n-            ledgerId = StringUtils.getLedgerId(name);\n+            ledgerId = bk.getLedgerManager().getLedgerId(ledgerPath);\n         } catch (IOException e) {\n-            LOG.error(\"Could not extract ledger-id from path:\" + path, e);\n+            LOG.error(\"Could not extract ledger-id from path:\" + ledgerPath, e);\n             cb.createComplete(BKException.Code.ZKException, null, this.ctx);\n             return;\n         }"},{"sha":"5b10a5b0eb395ad2394b37f0fb298e389f55c063","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -22,7 +22,6 @@\n package org.apache.bookkeeper.client;\n \n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.AsyncCallback.VoidCallback;\n@@ -65,7 +64,8 @@\n     public void initiate() {\n         // Asynchronously delete the ledger node in ZK.\n         // When this completes, it will invoke the callback method below.\n-        bk.getZkHandle().delete(StringUtils.getLedgerNodePath(ledgerId), -1, this, null);\n+\n+        bk.getZkHandle().delete(bk.getLedgerManager().getLedgerPath(ledgerId), -1, this, null);\n     }\n \n     /**"},{"sha":"6849002513443dac6c70d009766f540bdde148ea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":6,"deletions":8,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -29,7 +29,6 @@\n import java.util.Queue;\n import java.util.concurrent.Semaphore;\n \n-import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n@@ -40,7 +39,6 @@\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.apache.bookkeeper.util.StringUtils;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -196,9 +194,9 @@ void writeLedgerConfig(StatCallback callback, Object ctx) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Writing metadata to ZooKeeper: \" + this.ledgerId + \", \" + metadata.getZnodeVersion());\n         }\n-        \n-        bk.getZkHandle().setData(StringUtils.getLedgerNodePath(ledgerId),\n-                                 metadata.serialize(), metadata.getZnodeVersion(), \n+\n+        bk.getZkHandle().setData(bk.getLedgerManager().getLedgerPath(ledgerId),\n+                                 metadata.serialize(), metadata.getZnodeVersion(),\n                                  callback, ctx);\n     }\n \n@@ -609,11 +607,11 @@ public void safeRun() {\n         }, null);\n \n     }\n-    \n+\n     void rereadMetadata(final GenericCallback<Void> cb) {\n-        bk.getZkHandle().getData(StringUtils.getLedgerNodePath(ledgerId), false, \n+        bk.getZkHandle().getData(bk.getLedgerManager().getLedgerPath(ledgerId), false,\n                 new DataCallback() {\n-                    public void processResult(int rc, String path, \n+                    public void processResult(int rc, String path,\n                                               Object ctx, byte[] data, Stat stat) {\n                         if (rc != KeeperException.Code.OK.intValue()) {\n                             LOG.error(\"Error reading metadata from ledger, code =\" + rc);"},{"sha":"56186ab6a62d6ac8d6097238d84a0b083732c958","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -26,7 +26,6 @@\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.KeeperException;\n@@ -80,7 +79,7 @@ public void initiate() {\n          * Asynchronously read the ledger metadata node.\n          */\n \n-        bk.getZkHandle().getData(StringUtils.getLedgerNodePath(ledgerId), false, this, ctx);\n+        bk.getZkHandle().getData(bk.getLedgerManager().getLedgerPath(ledgerId), false, this, ctx);\n     }\n \n     /**"},{"sha":"e1bd1fff7aa6e8dee18efb44a74eb50c18a32e2b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":45,"deletions":1,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -25,10 +25,16 @@\n import org.apache.commons.configuration.PropertiesConfiguration;\n import org.apache.commons.configuration.SystemConfiguration;\n \n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+\n /**\n  * Abstract configuration\n  */\n-public abstract class AbstractConfiguration extends CompositeConfiguration { \n+public abstract class AbstractConfiguration extends CompositeConfiguration {\n+\n+    // Ledger Manager\n+    protected final static String LEDGER_MANAGER_TYPE = \"ledgerManagerType\";\n+    protected final static String ZK_LEDGERS_ROOT_PATH = \"zkLedgersRootPath\";\n \n     protected AbstractConfiguration() {\n         super();\n@@ -58,4 +64,42 @@ public void loadConf(AbstractConfiguration baseConf) {\n         addConfiguration(baseConf); \n     }\n \n+    /**\n+     * Set Ledger Manager Type.\n+     *\n+     * @param lmType\n+     *          Ledger Manager Type\n+     * @return void\n+     */\n+    public void setLedgerManagerType(String lmType) {\n+        setProperty(LEDGER_MANAGER_TYPE, lmType); \n+    }\n+\n+    /**\n+     * Get Ledger Manager Type.\n+     *\n+     * @return ledger manager type\n+     * @throws ConfigurationException\n+     */\n+    public String getLedgerManagerType() {\n+        return getString(LEDGER_MANAGER_TYPE);\n+    }\n+\n+    /**\n+     * Set Zk Ledgers Root Path.\n+     *\n+     * @param zkLedgersPath zk ledgers root path\n+     */\n+    public void setZkLedgersRootPath(String zkLedgersPath) {\n+        setProperty(ZK_LEDGERS_ROOT_PATH, zkLedgersPath);\n+    }\n+\n+    /**\n+     * Get Zk Ledgers Root Path.\n+     *\n+     * @return zk ledgers root path\n+     */\n+    public String getZkLedgersRootPath() {\n+        return getString(ZK_LEDGERS_ROOT_PATH, \"/ledgers\");\n+    }\n }"},{"sha":"e537942339484e975fe7e4d243e891632cdf18c4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"added","additions":251,"deletions":0,"changes":251,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,251 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Abstract ledger manager based on zookeeper, which provides common methods such as query zk nodes.\n+ */\n+abstract class AbstractZkLedgerManager implements LedgerManager {\n+\n+    static Logger LOG = Logger.getLogger(AbstractZkLedgerManager.class);\n+\n+    // Ledger Node Prefix\n+    static public final String LEDGER_NODE_PREFIX = \"L\";\n+    static final String AVAILABLE_NODE = \"available\";\n+\n+    protected final AbstractConfiguration conf;\n+    protected final ZooKeeper zk;\n+    protected final String ledgerRootPath;\n+\n+    /**\n+     * ZooKeeper-based Ledger Manager Constructor\n+     *\n+     * @param conf\n+     *          Configuration object\n+     * @param zk\n+     *          ZooKeeper Client Handle\n+     * @param ledgerRootPath\n+     *          ZooKeeper Path to store ledger metadata\n+     */\n+    protected AbstractZkLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n+                                      String ledgerRootPath) {\n+        this.conf = conf;\n+        this.zk = zk;\n+        this.ledgerRootPath = ledgerRootPath;\n+    }\n+\n+    /**\n+     * Get all the ledgers in a single zk node\n+     *\n+     * @param nodePath\n+     *          Zookeeper node path\n+     * @param getLedgersCallback\n+     *          callback function to process ledgers in a single node\n+     */\n+    protected void asyncGetLedgersInSingleNode(final String nodePath, final GenericCallback<HashSet<Long>> getLedgersCallback) {\n+        // First sync ZK to make sure we're reading the latest active/available ledger nodes.\n+        zk.sync(nodePath, new AsyncCallback.VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Sync node path \" + path + \" return : \" + rc);\n+                }\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error syncing the ledgers node when getting children: \", KeeperException\n+                            .create(KeeperException.Code.get(rc), path));\n+                    getLedgersCallback.operationComplete(rc, null);\n+                    return;\n+                }\n+                // Sync has completed successfully so now we can poll ZK\n+                // and read in the latest set of active ledger nodes.\n+                doAsyncGetLedgersInSingleNode(nodePath, getLedgersCallback);\n+            }\n+        }, null);\n+    }\n+\n+    private void doAsyncGetLedgersInSingleNode(final String nodePath,\n+                                               final GenericCallback<HashSet<Long>> getLedgersCallback) {\n+        zk.getChildren(nodePath, false, new AsyncCallback.ChildrenCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, List<String> ledgerNodes) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"Error polling ZK for the available ledger nodes: \", KeeperException\n+                            .create(KeeperException.Code.get(rc), path));\n+                    getLedgersCallback.operationComplete(rc, null);\n+                    return;\n+                }\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Retrieved current set of ledger nodes: \" + ledgerNodes);\n+                }\n+                // Convert the ZK retrieved ledger nodes to a HashSet for easier comparisons.\n+                HashSet<Long> allActiveLedgers = new HashSet<Long>(ledgerNodes.size(), 1.0f);\n+                for (String ledgerNode : ledgerNodes) {\n+                    if (isSpecialZnode(ledgerNode)) {\n+                        continue;\n+                    }\n+                    try {\n+                        // convert the node path to ledger id according to different ledger manager implementation\n+                        allActiveLedgers.add(getLedgerId(path + \"/\" + ledgerNode));\n+                    } catch (IOException ie) {\n+                        LOG.warn(\"Error extracting ledgerId from ZK ledger node: \" + ledgerNode);\n+                        // This is a pretty bad error as it indicates a ledger node in ZK\n+                        // has an incorrect format. For now just continue and consider\n+                        // this as a non-existent ledger.\n+                        continue;\n+                    }\n+                }\n+\n+                getLedgersCallback.operationComplete(rc, allActiveLedgers);\n+\n+            }\n+        }, null);\n+    }\n+\n+    private class GetLedgersCtx {\n+        int rc;\n+        HashSet<Long> ledgers = null;\n+    }\n+\n+    /**\n+     * Get all the ledgers in a single zk node\n+     *\n+     * @param nodePath\n+     *          Zookeeper node path\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    protected HashSet<Long> getLedgersInSingleNode(final String nodePath)\n+        throws IOException, InterruptedException {\n+        final GetLedgersCtx ctx = new GetLedgersCtx();\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Try to get ledgers of node : \" + nodePath);\n+        }\n+        synchronized (ctx) {\n+            asyncGetLedgersInSingleNode(nodePath, new GenericCallback<HashSet<Long>>() {\n+                @Override\n+                public void operationComplete(int rc, HashSet<Long> zkActiveLedgers) {\n+                    synchronized (ctx) {\n+                        if (Code.OK.intValue() == rc) {\n+                            ctx.ledgers = zkActiveLedgers;\n+                        }\n+                        ctx.rc = rc;\n+                        ctx.notifyAll();\n+                    }\n+                }\n+            });\n+            ctx.wait();\n+        }\n+        if (Code.OK.intValue() != ctx.rc && null != ctx.ledgers) {\n+            throw new IOException(\"Error on getting ledgers from node \" + nodePath);\n+        }\n+        return ctx.ledgers;\n+    }\n+\n+    /**\n+     * Process ledgers in a single zk node.\n+     *\n+     * <p>\n+     * for each ledger found in this zk node, processor#process(ledgerId) will be triggerred\n+     * to process a specific ledger. after all ledgers has been processed, the finalCb will\n+     * be called with provided context object. The RC passed to finalCb is decided by :\n+     * <ul>\n+     * <li> All ledgers are processed successfully, successRc will be passed.\n+     * <li> Either ledger is processed failed, failureRc will be passed.\n+     * </ul>\n+     * </p>\n+     *\n+     * @param path\n+     *          Zk node path to store ledgers\n+     * @param processor\n+     *          Processor provided to process ledger\n+     * @param finalCb\n+     *          Callback object when all ledgers are processed\n+     * @param ctx\n+     *          Context object passed to finalCb\n+     * @param successRc\n+     *          RC passed to finalCb when all ledgers are processed successfully\n+     * @param failureRc\n+     *          RC passed to finalCb when either ledger is processed failed\n+     */\n+    protected void asyncProcessLedgersInSingleNode(\n+            final String path, final Processor<Long> processor,\n+            final AsyncCallback.VoidCallback finalCb, final Object ctx,\n+            final int successRc, final int failureRc) {\n+        asyncGetLedgersInSingleNode(path, new GenericCallback<HashSet<Long>>() {\n+            @Override\n+            public void operationComplete(int rc, HashSet<Long> zkActiveLedgers) {\n+                if (Code.OK.intValue() != rc) {\n+                    finalCb.processResult(failureRc, null, ctx);\n+                    return;\n+                }\n+\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Processing ledgers : \" + zkActiveLedgers);\n+                }\n+\n+                // no ledgers found, return directly\n+                if (zkActiveLedgers.size() == 0) {\n+                    finalCb.processResult(successRc, null, ctx);\n+                    return;\n+                }\n+\n+                MultiCallback mcb = new MultiCallback(zkActiveLedgers.size(), finalCb, ctx,\n+                                                      successRc, failureRc);\n+                // start loop over all ledgers\n+                for (Long ledger : zkActiveLedgers) {\n+                    processor.process(ledger, mcb);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Whether the znode a special znode\n+     *\n+     * @param znode\n+     *          Znode Name\n+     * @return true  if the znode is a special znode otherwise false\n+     */\n+    protected boolean isSpecialZnode(String znode) {\n+        if (AVAILABLE_NODE.equals(znode) \n+            || LedgerLayout.LAYOUT_ZNODE.equals(znode)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+}"},{"sha":"5e67795e6a326bd2956fbf73832c3778bdad1475","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,193 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.HashSet;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all ledgers in a single zk node.\n+ *\n+ * <p>\n+ * All ledgers' metadata are put in a single zk node, created using zk sequential node.\n+ * Each ledger node is prefixed with 'L'.\n+ * </p>\n+ * <p>\n+ * All actived ledgers found in bookie server side is managed in a hash map.\n+ * </p>\n+ * <p>\n+ * Garbage collection in FlatLedgerManager is procssed as below:\n+ * <ul>\n+ * <li> fetch all existed ledgers from zookeeper, said <b>zkActiveLedgers</b>\n+ * <li> fetch all active ledgers from bookie server, said <b>bkActiveLedgers</b>\n+ * <li> loop over <b>bkActiveLedgers</b> to find those ledgers aren't existed in\n+ * <b>zkActiveLedgers</b>, do garbage collection on them.\n+ * </ul>\n+ * </p>\n+ */\n+class FlatLedgerManager extends AbstractZkLedgerManager {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(FlatLedgerManager.class);\n+    public static final String NAME = \"flat\";\n+    public static final int CUR_VERSION = 1;\n+\n+    // path prefix to store ledger znodes\n+    private final String ledgerPrefix;\n+    // hash map to store all active ledger ids\n+    private ConcurrentMap<Long, Boolean> activeLedgers;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param conf\n+     *          Configuration object\n+     * @param zk\n+     *          ZooKeeper Client Handle\n+     * @param ledgerRootPath\n+     *          ZooKeeper Path to store ledger metadata\n+     * @throws IOException when version is not compatible\n+     */\n+    public FlatLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n+                             String ledgerRootPath, int layoutVersion)\n+        throws IOException {\n+        super(conf, zk, ledgerRootPath);\n+\n+        if (layoutVersion != CUR_VERSION) {\n+            throw new IOException(\"Incompatible layout version found : \" \n+                                  + layoutVersion);\n+        }\n+\n+        ledgerPrefix = ledgerRootPath + \"/\" + LEDGER_NODE_PREFIX;\n+        activeLedgers = new ConcurrentHashMap<Long, Boolean>();\n+    }\n+\n+    @Override\n+    public void newLedgerPath(final GenericCallback<String> cb) {\n+        StringCallback scb = new StringCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx,\n+                    String name) {\n+                if (Code.OK.intValue() != rc) {\n+                    cb.operationComplete(rc, null);\n+                } else {\n+                    cb.operationComplete(rc, name);\n+                }\n+            }\n+        };\n+        ZkUtils.createFullPathOptimistic(zk, ledgerPrefix, new byte[0],\n+            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, scb, null);\n+    }\n+\n+    @Override\n+    public String getLedgerPath(long ledgerId) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(ledgerPrefix)\n+          .append(StringUtils.getZKStringId(ledgerId));\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public long getLedgerId(String nodeName) throws IOException {\n+        long ledgerId;\n+        try {\n+            String parts[] = nodeName.split(ledgerPrefix);\n+            ledgerId = Long.parseLong(parts[parts.length - 1]);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+        return ledgerId;\n+    }\n+\n+    @Override\n+    public void asyncProcessLedgers(final Processor<Long> processor,\n+                                    final AsyncCallback.VoidCallback finalCb, final Object ctx,\n+                                    final int successRc, final int failureRc) {\n+        asyncProcessLedgersInSingleNode(ledgerRootPath, processor, finalCb, ctx, successRc, failureRc);\n+    }\n+\n+    @Override\n+    public void addActiveLedger(long ledgerId, boolean active) {\n+        activeLedgers.put(ledgerId, active);\n+    }\n+\n+    @Override\n+    public void removeActiveLedger(long ledgerId) {\n+        activeLedgers.remove(ledgerId);\n+    }\n+\n+    @Override\n+    public boolean containsActiveLedger(long ledgerId) {\n+        return activeLedgers.containsKey(ledgerId);\n+    }\n+\n+    @Override\n+    public void garbageCollectLedgers(GarbageCollector gc) {\n+        try {\n+            HashSet<Long> zkActiveLedgers = getLedgersInSingleNode(ledgerRootPath);\n+            ConcurrentMap<Long, Boolean> bkActiveLedgers = activeLedgers;\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"All active ledgers from ZK: \" + zkActiveLedgers);\n+                LOG.debug(\"Current active ledgers from Bookie: \" + bkActiveLedgers.keySet());\n+            }\n+            doGc(gc, bkActiveLedgers, zkActiveLedgers);\n+        } catch (IOException ie) {\n+            LOG.warn(\"Error during garbage collecting ledgers from \" + ledgerRootPath, ie);\n+        } catch (InterruptedException inte) {\n+            LOG.warn(\"Interrupted during garbage collecting ledgers from \" + ledgerRootPath, inte);\n+        }\n+    }\n+\n+    /**\n+     * Do garbage collecting comparing hosted ledgers and zk ledgers\n+     *\n+     * @param gc\n+     *          Garbage collector to do garbage collection when found inactive/deleted ledgers\n+     * @param bkActiveLedgers\n+     *          Active ledgers hosted in bookie server\n+     * @param zkAllLedgers\n+     *          All ledgers stored in zookeeper\n+     */\n+    void doGc(GarbageCollector gc, ConcurrentMap<Long, Boolean> bkActiveLedgers, HashSet<Long> zkAllLedgers) {\n+        // remove any active ledgers that doesn't exist in zk\n+        for (Long bkLid : bkActiveLedgers.keySet()) {\n+            if (!zkAllLedgers.contains(bkLid)) {\n+                // remove it from current active ledger\n+                bkActiveLedgers.remove(bkLid);\n+                gc.gc(bkLid);\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"be965143be207a730852b7e926ab171d48eb02d6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"added","additions":514,"deletions":0,"changes":514,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,514 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Hierarchical Ledger Manager which manages ledger meta in zookeeper using 2-level hierarchical znodes.\n+ *\n+ * <p>\n+ * Hierarchical Ledger Manager first obtain a global unique id from zookeeper using a EPHEMERAL_SEQUENTIAL\n+ * znode <i>(ledgersRootPath)/ledgers/idgen/ID-</i>.\n+ * Since zookeeper sequential counter has a format of %10d -- that is 10 digits with 0 (zero) padding, i.e.\n+ * \"&lt;path&gt;0000000001\", HierarchicalLedgerManager splits the generated id into 3 parts (2-4-4):\n+ * <pre>&lt;level1 (2 digits)&gt;&lt;level2 (4 digits)&gt;&lt;level3 (4 digits)&gt;</pre>\n+ * These 3 parts are used to form the actual ledger node path used to store ledger metadata:\n+ * <pre>(ledgersRootPath)/level1/level2/L(level3)</pre>\n+ * E.g Ledger 0000000001 is split into 3 parts <i>00</i>, <i>0000</i>, <i>0001</i>, which is stored in\n+ * <i>(ledgersRootPath)/00/0000/L0001</i>. So each znode could have at most 10000 ledgers, which avoids\n+ * failed to get children list of a too big znode during garbage collection.\n+ * <p>\n+ * All actived ledgers found in bookie server is managed in a sorted map, which ease us to pick\n+ * up all actived ledgers belongs to (level1, level2).\n+ * </p>\n+ * <p>\n+ * Garbage collection in HierarchicalLedgerManager is processed node by node as below:\n+ * <ul>\n+ * fetching all level1 nodes, by calling zk#getChildren(ledgerRootPath).\n+ * <ul>\n+ * for each level1 node, fetching their level2 nodes, by calling zk#getChildren(ledgerRootPath + \"/\" + level1)\n+ * <li> fetch all existed ledgers from zookeeper in level1/level2 node, said <b>zkActiveLedgers</b>\n+ * <li> fetch all active ledgers from bookie server in level1/level2, said <b>bkActiveLedgers</b>\n+ * <li> loop over <b>bkActiveLedgers</b> to find those ledgers aren't existed in <b>zkActiveLedgers</b>, do garbage collection on them.\n+ * </ul>\n+ * </ul>\n+ * Since garbage collection is running in background, HierarchicalLedgerManager did gc on single hash\n+ * node at a time to avoid consuming too much resources.\n+ * </p>\n+ */\n+class HierarchicalLedgerManager extends AbstractZkLedgerManager {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(HierarchicalLedgerManager.class);\n+    public static final String NAME = \"hierarchical\";\n+\n+    public static final int CUR_VERSION = 1;\n+\n+    static final String IDGENERATION_PREFIX = \"/idgen/ID-\";\n+    private static final String MAX_ID_SUFFIX = \"9999\";\n+    private static final String MIN_ID_SUFFIX = \"0000\";\n+\n+    // Path to generate global id\n+    private final String idGenPath;\n+    // A sorted map to stored all active ledger ids\n+    private ConcurrentSkipListMap<Long, Boolean> activeLedgers;\n+\n+    // we use this to prevent long stack chains from building up in callbacks\n+    ScheduledExecutorService scheduler;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param conf\n+     *          Configuration object\n+     * @param zk\n+     *          ZooKeeper Client Handle\n+     * @param ledgerRootPath\n+     *          ZooKeeper Path to store ledger metadata\n+     * @throws IOException when version is not compatible\n+     */\n+    public HierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n+                                     String ledgerRootPath, int layoutVersion)\n+        throws IOException {\n+        super(conf, zk, ledgerRootPath);\n+\n+        if (layoutVersion != CUR_VERSION) {\n+            throw new IOException(\"Incompatible layout version found : \" \n+                                  + layoutVersion);\n+        }\n+\n+        this.idGenPath = ledgerRootPath + IDGENERATION_PREFIX;\n+        this.activeLedgers = new ConcurrentSkipListMap<Long, Boolean>();\n+        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Using HierarchicalLedgerManager with root path : \" + ledgerRootPath);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            scheduler.shutdown();\n+        } catch (Exception e) {\n+            LOG.warn(\"Error when closing HierarchicalLedgerManager : \", e);\n+        }\n+        super.close();\n+    }\n+\n+    @Override\n+    public void newLedgerPath(final GenericCallback<String> ledgerCb) {\n+        ZkUtils.createFullPathOptimistic(zk, idGenPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+            CreateMode.EPHEMERAL_SEQUENTIAL, new StringCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, final String idPathName) {\n+                if (rc != KeeperException.Code.OK.intValue()) {\n+                    LOG.error(\"Could not generate new ledger id\",\n+                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                    ledgerCb.operationComplete(rc, null);\n+                    return;\n+                }\n+                /*\n+                 * Extract ledger id from gen path\n+                 */\n+                long ledgerId;\n+                try {\n+                    ledgerId = getLedgerIdFromGenPath(idPathName);\n+                } catch (IOException e) {\n+                    LOG.error(\"Could not extract ledger-id from id gen path:\" + path, e);\n+                    ledgerCb.operationComplete(KeeperException.Code.SYSTEMERROR.intValue(), null);\n+                    return;\n+                }\n+                StringCallback scb = new StringCallback() {\n+                    @Override\n+                    public void processResult(int rc, String path,\n+                            Object ctx, String name) {\n+                        if (rc != KeeperException.Code.OK.intValue()) {\n+                            ledgerCb.operationComplete(rc, null);\n+                        } else {\n+                            ledgerCb.operationComplete(rc, name);\n+                        }\n+                    }\n+                };\n+                String ledgerPath = getLedgerPath(ledgerId);\n+                ZkUtils.createFullPathOptimistic(zk, ledgerPath, new byte[0],\n+                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, scb, null);\n+                // delete the znode for id generation\n+                scheduler.submit(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        zk.delete(idPathName, -1, new AsyncCallback.VoidCallback() {\n+                            @Override\n+                            public void processResult(int rc, String path, Object ctx) {\n+                                if (rc != KeeperException.Code.OK.intValue()) {\n+                                    LOG.warn(\"Exception during deleting znode for id generation : \",\n+                                             KeeperException.create(KeeperException.Code.get(rc), path));\n+                                } else {\n+                                    if (LOG.isDebugEnabled()) {\n+                                        LOG.debug(\"Deleting znode for id generation : \" + idPathName);\n+                                    }\n+                                }\n+                            }\n+                        }, null);\n+                    }\n+                });\n+            }\n+        }, null);\n+    }\n+\n+    // get ledger id from generation path\n+    private long getLedgerIdFromGenPath(String nodeName) throws IOException {\n+        long ledgerId;\n+        try {\n+            String parts[] = nodeName.split(IDGENERATION_PREFIX);\n+            ledgerId = Long.parseLong(parts[parts.length - 1]);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+        return ledgerId;\n+    }\n+\n+    @Override\n+    public String getLedgerPath(long ledgerId) {\n+        String ledgerIdStr = StringUtils.getZKStringId(ledgerId);\n+        // do 2-4-4 split\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(ledgerRootPath).append(\"/\")\n+          .append(ledgerIdStr.substring(0, 2)).append(\"/\")\n+          .append(ledgerIdStr.substring(2, 6)).append(\"/\")\n+          .append(LEDGER_NODE_PREFIX).append(ledgerIdStr.substring(6, 10));\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public long getLedgerId(String pathName) throws IOException {\n+        if (!pathName.startsWith(ledgerRootPath)) {\n+            throw new IOException(\"it is not a valid hashed path name : \" + pathName);\n+        }\n+        String hierarchicalPath = pathName.substring(ledgerRootPath.length() + 1);\n+        String[] hierarchicalParts = hierarchicalPath.split(\"/\");\n+        if (hierarchicalParts.length != 3) {\n+            throw new IOException(\"it is not a valid hierarchical path name : \" + pathName);\n+        }\n+        hierarchicalParts[2] =\n+            hierarchicalParts[2].substring(LEDGER_NODE_PREFIX.length());\n+        return getLedgerId(hierarchicalParts);\n+    }\n+\n+    // get ledger from all level nodes\n+    private long getLedgerId(String...levelNodes) throws IOException {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            for (String node : levelNodes) {\n+                sb.append(node);\n+            }\n+            return Long.parseLong(sb.toString());\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    //\n+    // Active Ledger Manager\n+    //\n+\n+    /**\n+     * Get the smallest cache id in a specified node /level1/level2\n+     *\n+     * @param level1\n+     *          1st level node name\n+     * @param level2\n+     *          2nd level node name\n+     * @return the smallest ledger id\n+     */\n+    private long getStartLedgerIdByLevel(String level1, String level2) throws IOException {\n+        return getLedgerId(level1, level2, MIN_ID_SUFFIX);\n+    }\n+\n+    /**\n+     * Get the largest cache id in a specified node /level1/level2\n+     *\n+     * @param level1\n+     *          1st level node name\n+     * @param level2\n+     *          2nd level node name\n+     * @return the largest ledger id\n+     */\n+    private long getEndLedgerIdByLevel(String level1, String level2) throws IOException {\n+        return getLedgerId(level1, level2, MAX_ID_SUFFIX);\n+    }\n+\n+    @Override\n+    public void asyncProcessLedgers(final Processor<Long> processor,\n+                                    final AsyncCallback.VoidCallback finalCb, final Object context,\n+                                    final int successRc, final int failureRc) {\n+        // process 1st level nodes\n+        asyncProcessLevelNodes(ledgerRootPath, new Processor<String>() {\n+            @Override\n+            public void process(final String l1Node, final AsyncCallback.VoidCallback cb1) {\n+                if (isSpecialZnode(l1Node)) {\n+                    cb1.processResult(successRc, null, context);\n+                    return;\n+                }\n+                final String l1NodePath = ledgerRootPath + \"/\" + l1Node;\n+                // process level1 path, after all children of level1 process\n+                // it callback to continue processing next level1 node\n+                asyncProcessLevelNodes(l1NodePath, new Processor<String>() {\n+                    @Override\n+                    public void process(String l2Node, AsyncCallback.VoidCallback cb2) {\n+                        // process level1/level2 path\n+                        String l2NodePath = ledgerRootPath + \"/\" + l1Node + \"/\" + l2Node;\n+                        // process each ledger\n+                        // after all ledger are processed, cb2 will be call to continue processing next level2 node\n+                        asyncProcessLedgersInSingleNode(l2NodePath, processor, cb2,\n+                                                        context, successRc, failureRc);\n+                    }\n+                }, cb1, context, successRc, failureRc);\n+            }\n+        }, finalCb, context, successRc, failureRc);\n+    }\n+\n+    /**\n+     * Process hash nodes in a given path\n+     */\n+    private void asyncProcessLevelNodes(\n+        final String path, final Processor<String> processor,\n+        final AsyncCallback.VoidCallback finalCb, final Object context,\n+        final int successRc, final int failureRc) {\n+        zk.sync(path, new AsyncCallback.VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"Error syncing path \" + path + \" when getting its chidren: \",\n+                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                    finalCb.processResult(failureRc, null, context);\n+                    return;\n+                }\n+\n+                zk.getChildren(path, false, new AsyncCallback.ChildrenCallback() {\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx,\n+                                              List<String> levelNodes) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"Error polling hash nodes of \" + path,\n+                                      KeeperException.create(KeeperException.Code.get(rc), path));\n+                            finalCb.processResult(failureRc, null, context);\n+                            return;\n+                        }\n+                        AsyncListProcessor<String> listProcessor =\n+                                new AsyncListProcessor<String>(scheduler);\n+                        // process its children\n+                        listProcessor.process(levelNodes, processor, finalCb,\n+                                              context, successRc, failureRc);\n+                    }\n+                }, null);\n+            }\n+        }, null);\n+    }\n+\n+    @Override\n+    public void addActiveLedger(long ledgerId, boolean active) {\n+        activeLedgers.put(ledgerId, active);\n+    }\n+\n+    @Override\n+    public void removeActiveLedger(long ledgerId) {\n+        activeLedgers.remove(ledgerId);\n+    }\n+\n+    @Override\n+    public boolean containsActiveLedger(long ledgerId) {\n+        return activeLedgers.containsKey(ledgerId);\n+    }\n+\n+    @Override\n+    public void garbageCollectLedgers(GarbageCollector gc) {\n+        try {\n+            List<String> l1Nodes = zk.getChildren(ledgerRootPath, null);\n+            for (String l1Node : l1Nodes) {\n+                if (isSpecialZnode(l1Node)) {\n+                    continue;\n+                }\n+                try {\n+                    List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + l1Node, null);\n+                    for (String l2Node : l2Nodes) {\n+                        doGcByLevel(gc, l1Node, l2Node);\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Exception during garbage collecting ledgers for \" + l1Node\n+                           + \" of \" + ledgerRootPath);\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"Exception during garbage collecting inactive/deleted ledgers\");\n+        }\n+    }\n+\n+    /**\n+     * Garbage collection a single node level1/level2\n+     *\n+     * @param gc\n+     *          Garbage collector\n+     * @param level1\n+     *          1st level node name\n+     * @param level2\n+     *          2nd level node name\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    void doGcByLevel(GarbageCollector gc, final String level1, final String level2)\n+        throws IOException, InterruptedException {\n+\n+        StringBuilder nodeBuilder = new StringBuilder();\n+        nodeBuilder.append(ledgerRootPath).append(\"/\")\n+                   .append(level1).append(\"/\").append(level2);\n+        String nodePath = nodeBuilder.toString();\n+\n+        HashSet<Long> zkActiveLedgers = getLedgersInSingleNode(nodePath);\n+        // get hosted ledgers in /level1/level2\n+        long startLedgerId = getStartLedgerIdByLevel(level1, level2);\n+        long endLedgerId = getEndLedgerIdByLevel(level1, level2);\n+        ConcurrentMap<Long, Boolean> bkActiveLedgers =\n+            activeLedgers.subMap(startLedgerId, true, endLedgerId, true);\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"All active ledgers from ZK for hash node \"\n+                      + level1 + \"/\" + level2 + \" : \" + zkActiveLedgers);\n+            LOG.debug(\"Current active ledgers from Bookie for hash node \"\n+                      + level1 + \"/\" + level2 + \" : \" + bkActiveLedgers);\n+        }\n+\n+        doGc(gc, bkActiveLedgers, zkActiveLedgers);\n+    }\n+\n+    /**\n+     * Do garbage collecting comparing hosted ledgers and zk ledgers\n+     *\n+     * @param gc\n+     *          Garbage collector\n+     * @param bkActiveLedgers\n+     *          Active ledgers hosted in bookie server\n+     * @param zkAllLedgers\n+     *          All ledgers stored in zookeeper\n+     */\n+    void doGc(GarbageCollector gc, ConcurrentMap<Long, Boolean> bkActiveLedgers,\n+              HashSet<Long> zkAllLedgers) {\n+        // remove any active ledgers that doesn't exist in zk\n+        for (Long lid : bkActiveLedgers.keySet()) {\n+            if (!zkAllLedgers.contains(lid)) {\n+                // remove it from current active ledger\n+                bkActiveLedgers.remove(lid);\n+                gc.gc(lid);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Process list one by one in asynchronize way. Process will be stopped immediately\n+     * when error occurred.\n+     */\n+    private static class AsyncListProcessor<T> {\n+        // use this to prevent long stack chains from building up in callbacks\n+        ScheduledExecutorService scheduler;\n+\n+        /**\n+         * Constructor\n+         *\n+         * @param scheduler\n+         *          Executor used to prevent long stack chains\n+         */\n+        public AsyncListProcessor(ScheduledExecutorService scheduler) {\n+            this.scheduler = scheduler;\n+        }\n+\n+        /**\n+         * Process list of items\n+         *\n+         * @param data\n+         *          List of data to process\n+         * @param processor\n+         *          Callback to process element of list when success\n+         * @param finalCb\n+         *          Final callback to be called after all elements in the list are processed\n+         * @param contxt\n+         *          Context of final callback\n+         * @param successRc\n+         *          RC passed to final callback on success\n+         * @param failureRc\n+         *          RC passed to final callback on failure\n+         */\n+        public void process(final List<T> data, final Processor<T> processor,\n+                            final AsyncCallback.VoidCallback finalCb, final Object context,\n+                            final int successRc, final int failureRc) {\n+            if (data == null || data.size() == 0) {\n+                finalCb.processResult(successRc, null, context);\n+                return;\n+            }\n+            final int size = data.size();\n+            final AtomicInteger current = new AtomicInteger(0);\n+            AsyncCallback.VoidCallback stubCallback = new AsyncCallback.VoidCallback() {\n+                @Override\n+                public void processResult(int rc, String path, Object ctx) {\n+                    if (rc != successRc) {\n+                        // terminal immediately\n+                        finalCb.processResult(failureRc, null, context);\n+                        return;\n+                    }\n+                    // process next element\n+                    int next = current.incrementAndGet();\n+                    if (next >= size) { // reach the end of list\n+                        finalCb.processResult(successRc, null, context);\n+                        return;\n+                    }\n+                    final T dataToProcess = data.get(next);\n+                    final AsyncCallback.VoidCallback stub = this;\n+                    scheduler.submit(new Runnable() {\n+                        @Override\n+                        public final void run() {\n+                            processor.process(dataToProcess, stub);\n+                        }\n+                    });\n+                }\n+            };\n+            T firstElement = data.get(0);\n+            processor.process(firstElement, stubCallback);\n+        }\n+    }\n+}"},{"sha":"3a3a81e300f618c3d89611fc38cbc5bbad7701dd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","status":"added","additions":204,"deletions":0,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,204 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.commons.configuration.ConfigurationException;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.meta.FlatLedgerManager;\n+\n+/**\n+ * This class encapsulates ledger layout information that is persistently stored\n+ * in zookeeper. It provides parsing and serialization methods of such information.\n+ *\n+ */\n+class LedgerLayout {\n+    static final Logger LOG = LoggerFactory.getLogger(LedgerLayout.class);\n+\n+    // Znode name to store layout information\n+    public static final String LAYOUT_ZNODE = \"LAYOUT\";\n+    // version of ledger layout metadata\n+    public static final int LAYOUT_FORMAT_VERSION = 1;\n+\n+    /**\n+     * Read ledger layout from zookeeper\n+     *\n+     * @param zk            ZooKeeper Client\n+     * @param ledgersRoot   Root of the ledger namespace to check\n+     * @return ledger layout, or null if none set in zookeeper\n+     */\n+    public static LedgerLayout readLayout(final ZooKeeper zk, final String ledgersRoot)\n+            throws IOException, KeeperException {\n+        String ledgersLayout = ledgersRoot + \"/\" + LAYOUT_ZNODE;\n+\n+        try {\n+            LedgerLayout layout;\n+\n+            try {\n+                byte[] layoutData = zk.getData(ledgersLayout, false, null);\n+                layout = parseLayout(layoutData);\n+            } catch (KeeperException.NoNodeException nne) {\n+                return null;\n+            }\n+            \n+            return layout;\n+        } catch (InterruptedException ie) {\n+            throw new IOException(ie);\n+        }\n+    }\n+\n+    static final String splitter = \":\";\n+    static final String lSplitter = \"\\n\";\n+\n+    // ledger manager class\n+    private String managerType;\n+    // ledger manager version\n+    private int managerVersion;\n+\n+    // layout version of how to store layout information\n+    private int layoutFormatVersion = LAYOUT_FORMAT_VERSION;\n+\n+    /**\n+     * Ledger Layout Constructor\n+     *\n+     * @param type\n+     *          Ledger Manager Type\n+     * @param managerVersion\n+     *          Ledger Manager Version\n+     * @param layoutFormatVersion\n+     *          Ledger Layout Format Version\n+     */\n+    public LedgerLayout(String managerType, int managerVersion) {\n+        this.managerType = managerType;\n+        this.managerVersion = managerVersion;\n+    }\n+\n+    public String getManagerType() {\n+        return this.managerType;\n+    }\n+\n+    public int getManagerVersion() {\n+        return this.managerVersion;\n+    }\n+\n+    /**\n+     * Store the ledger layout into zookeeper\n+     */\n+    public void store(final ZooKeeper zk, String ledgersRoot) \n+            throws IOException, KeeperException, InterruptedException {\n+        String ledgersLayout = ledgersRoot + \"/\" + LAYOUT_ZNODE;\n+        zk.create(ledgersLayout, serialize(), \n+                  Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+    }\n+\n+    /**\n+     * Generates a byte array based on the LedgerLayout object.\n+     *\n+     * @return byte[]\n+     */\n+    private byte[] serialize() throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(layoutFormatVersion).append(lSplitter)\n+            .append(managerType).append(splitter).append(managerVersion);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Serialized layout info: \" + sb.toString());\n+        }\n+\n+        return sb.toString().getBytes(\"UTF-8\");\n+    }\n+\n+    /**\n+     * Parses a given byte array and transforms into a LedgerLayout object\n+     *\n+     * @param bytes\n+     *          byte array to parse\n+     * @param znodeVersion\n+     *          version of znode\n+     * @return LedgerLayout\n+     * @throws IOException\n+     *             if the given byte[] cannot be parsed\n+     */\n+    private static LedgerLayout parseLayout(byte[] bytes) throws IOException {\n+        String layout = new String(bytes, \"UTF-8\");\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Parsing Layout: \" + layout);\n+        }\n+\n+        String lines[] = layout.split(lSplitter);\n+\n+        try {\n+            int layoutFormatVersion = new Integer(lines[0]);\n+            if (LAYOUT_FORMAT_VERSION != layoutFormatVersion) {\n+                throw new IOException(\"Metadata version not compatible. Expected \" \n+                        + LAYOUT_FORMAT_VERSION + \", but got \" + layoutFormatVersion);\n+            }\n+\n+            if (lines.length < 2) {\n+                throw new IOException(\"Ledger manager and its version absent from layout: \" + layout);\n+            }\n+\n+            String[] parts = lines[1].split(splitter);\n+            if (parts.length != 2) {\n+                throw new IOException(\"Invalid Ledger Manager defined in layout : \" + layout);\n+            }\n+            // ledger manager class\n+            String managerType = parts[0];\n+            // ledger manager version\n+            int managerVersion = new Integer(parts[1]);\n+            return new LedgerLayout(managerType, managerVersion);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (null == obj) {\n+            return false;\n+        }\n+        if (!(obj instanceof LedgerLayout)) {\n+            return false;\n+        }\n+        LedgerLayout other = (LedgerLayout)obj;\n+        return managerType.equals(other.managerType) &&\n+            managerVersion == other.managerVersion;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"LV\").append(layoutFormatVersion).append(\":\")\n+            .append(\",Type:\").append(managerType).append(\":\")\n+            .append(managerVersion);\n+        return sb.toString();\n+    }\n+}"},{"sha":"3cbbff1a60bb80b02140525d9003f3aae3f343ae","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","status":"added","additions":144,"deletions":0,"changes":144,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,144 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+\n+/**\n+ * LedgerManager takes responsibility of ledger management\n+ *\n+ * <ul>\n+ * <li>How to store ledger meta (e.g. in ZooKeeper or other key/value store)\n+ * <li>How to manager active ledgers (so know how to do garbage collection)\n+ * <li>How to garbage collect inactive/deleted ledgers\n+ * </ul>\n+ */\n+public interface LedgerManager {\n+\n+    /**\n+     * Get the path that is used to store ledger metadata\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     * @return ledger node path\n+     */\n+    public String getLedgerPath(long ledgerId);\n+\n+    /**\n+     * Get ledger id from its ledger path\n+     *\n+     * @param ledgerPath\n+     *          Ledger path to store metadata\n+     * @return ledger id\n+     * @throws IOException when the ledger path is invalid\n+     */\n+    public long getLedgerId(String ledgerPath) throws IOException;\n+\n+    /**\n+     * Create a new zk ledger path.\n+     *\n+     * @param cb\n+     *        Callback when getting new zk ledger path to create.\n+     */\n+    public abstract void newLedgerPath(GenericCallback<String> cb);\n+\n+    /**\n+     * Loop to process all ledgers.\n+     * <p>\n+     * <ul>\n+     * After all ledgers were processed, finalCb will be triggerred:\n+     * <li> if all ledgers are processed done with OK, success rc will be passed to finalCb.\n+     * <li> if some ledgers are prcoessed failed, failure rc will be passed to finalCb.\n+     * </ul>\n+     * </p>\n+     *\n+     * @param processor\n+     *          Ledger Processor to process a specific ledger\n+     * @param finalCb\n+     *          Callback triggered after all ledgers are processed\n+     * @param context\n+     *          Context of final callback\n+     * @param successRc\n+     *          Success RC code passed to finalCb when callback\n+     * @param failureRc\n+     *          Failure RC code passed to finalCb when exceptions occured.\n+     */\n+    public void asyncProcessLedgers(Processor<Long> processor, AsyncCallback.VoidCallback finalCb,\n+                                    Object context, int successRc, int failureRc);\n+\n+    /**\n+     * Add active ledger\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     * @param active\n+     *          Status of ledger\n+     */\n+    public void addActiveLedger(long ledgerId, boolean active);\n+\n+    /**\n+     * Remove active ledger\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     */\n+    public void removeActiveLedger(long ledgerId);\n+\n+    /**\n+     * Is Ledger ledgerId in active ledgers set\n+     *\n+     * @param ledgerId\n+     *          Ledger ID\n+     * @return true if the ledger is in active ledgers set, otherwise return false\n+     */\n+    public boolean containsActiveLedger(long ledgerId);\n+\n+    /**\n+     * Garbage Collector which handles ledger deletion in server side\n+     */\n+    public static interface GarbageCollector {\n+        /**\n+         * garbage collecting a specific ledger\n+         *\n+         * @param ledgerId\n+         *          Ledger ID to be garbage collected\n+         */\n+        public void gc(long ledgerId);\n+    }\n+\n+    /**\n+     * Garbage collecting all inactive/deleted ledgers\n+     * <p>\n+     * GarbageCollector#gc is triggered each time we found a ledger could be garbage collected.\n+     * After method finished, all those inactive ledgers should be garbage collected.\n+     * </p>\n+     *\n+     * @param gc garbage collector\n+     */\n+    public void garbageCollectLedgers(GarbageCollector gc);\n+\n+    /**\n+     * Close ledger manager\n+     */\n+    public void close();\n+}"},{"sha":"b62ad3a9c4acde0075a1301bd1b0995959831a98","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,98 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.KeeperException;\n+\n+/**\n+ * <code>LedgerManagerFactory</code> takes responsibility of creating new ledger manager.\n+ */\n+public class LedgerManagerFactory {\n+    /**\n+     * Create new Ledger Manager.\n+     *\n+     * @param conf\n+     *          Configuration Object.\n+     * @param zk\n+     *          ZooKeeper Client Handle, talk to zk to know which ledger manager is used.\n+     * @return new ledger manager\n+     * @throws IOException\n+     */\n+    public static LedgerManager newLedgerManager(\n+        final AbstractConfiguration conf, final ZooKeeper zk)\n+            throws IOException, KeeperException, InterruptedException {\n+        String lmType = conf.getLedgerManagerType();\n+        String ledgerRootPath = conf.getZkLedgersRootPath();\n+            \n+        if (null == ledgerRootPath || ledgerRootPath.length() == 0) {\n+            throw new IOException(\"Empty Ledger Root Path.\");\n+        }\n+        \n+        // if zk is null, return the default ledger manager\n+        if (zk == null) {\n+            return new FlatLedgerManager(conf, zk, \n+                    ledgerRootPath, FlatLedgerManager.CUR_VERSION);\n+        }\n+\n+        // check that the configured ledger manager is\n+        // compatible with the existing layout\n+        LedgerLayout layout = LedgerLayout.readLayout(zk, ledgerRootPath);\n+        if (layout == null) { // no existing layout\n+            if (lmType == null \n+                || lmType.equals(FlatLedgerManager.NAME)) {\n+                layout = new LedgerLayout(FlatLedgerManager.NAME, \n+                                          FlatLedgerManager.CUR_VERSION);\n+            } else if (lmType.equals(HierarchicalLedgerManager.NAME)) {\n+                layout = new LedgerLayout(HierarchicalLedgerManager.NAME, \n+                                          HierarchicalLedgerManager.CUR_VERSION);\n+            } else {\n+                throw new IOException(\"Unknown ledger manager type \" + lmType);\n+            }\n+            try {\n+                layout.store(zk, ledgerRootPath);\n+            } catch (KeeperException.NodeExistsException nee) {\n+                LedgerLayout layout2 = LedgerLayout.readLayout(zk, ledgerRootPath);\n+                if (!layout2.equals(layout)) {\n+                    throw new IOException(\"Contention writing to layout to zookeeper, \"\n+                            + \" other layout \" + layout2 + \" is incompatible with our \"\n+                            + \"layout \" + layout);\n+                }\n+            }\n+        } else if (lmType != null && !layout.getManagerType().equals(lmType)) {\n+            throw new IOException(\"Configured layout \" + lmType\n+                    + \" does not match existing layout \" + layout.getManagerType());\n+        }\n+\n+        // create the ledger manager\n+        if (FlatLedgerManager.NAME.equals(layout.getManagerType())) {\n+            return new FlatLedgerManager(conf, zk, ledgerRootPath, \n+                                         layout.getManagerVersion());\n+        } else if (HierarchicalLedgerManager.NAME.equals(layout.getManagerType())) {\n+            return new HierarchicalLedgerManager(conf, zk, ledgerRootPath,\n+                                                 layout.getManagerVersion());\n+        } else {\n+            throw new IOException(\"Unknown ledger manager type: \" + lmType);\n+        }\n+    }\n+\n+}"},{"sha":"beab5e842dcfbd2702cee23641cda03d45844dd8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -29,6 +29,8 @@\n import java.net.UnknownHostException;\n import java.nio.ByteBuffer;\n \n+import org.apache.zookeeper.KeeperException;\n+\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -56,7 +58,8 @@\n     DeathWatcher deathWatcher;\n     static Logger LOG = LoggerFactory.getLogger(BookieServer.class);\n \n-    public BookieServer(ServerConfiguration conf) throws IOException {\n+    public BookieServer(ServerConfiguration conf) \n+            throws IOException, KeeperException, InterruptedException {\n         this.conf = conf;\n         this.bookie = new Bookie(conf);\n     }\n@@ -217,8 +220,8 @@ private static ServerConfiguration parseArgs(String[] args)\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    public static void main(String[] args) throws IOException, InterruptedException,\n-                                                  IllegalArgumentException {\n+    public static void main(String[] args) \n+            throws IOException, KeeperException, InterruptedException {\n         ServerConfiguration conf = null;\n         try {\n             conf = parseArgs(args);"},{"sha":"9169d70a58e4d92fcf0b0bf6b6c8081c40368293","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -22,14 +22,23 @@\n package org.apache.bookkeeper.proto;\n \n import java.net.InetSocketAddress;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.zookeeper.AsyncCallback;\n import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Declaration of a callback interfaces used in bookkeeper client library but\n  * not exposed to the client application.\n  */\n \n public class BookkeeperInternalCallbacks {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(BookkeeperInternalCallbacks.class);\n+\n     /**\n      * Callback for calls from BookieClient objects. Such calls are for replies\n      * of write operations (operations to add an entry to a ledger).\n@@ -54,4 +63,70 @@\n     public interface ReadEntryCallback {\n         void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx);\n     }\n+\n+    /**\n+     * This is a multi callback object that waits for all of\n+     * the multiple async operations to complete. If any fail, then we invoke\n+     * the final callback with a provided failureRc\n+     */\n+    public static class MultiCallback implements AsyncCallback.VoidCallback {\n+        // Number of expected callbacks\n+        final int expected;\n+        final int failureRc;\n+        final int successRc;\n+        // Final callback and the corresponding context to invoke\n+        final AsyncCallback.VoidCallback cb;\n+        final Object context;\n+        // This keeps track of how many operations have completed\n+        final AtomicInteger done = new AtomicInteger();\n+        // List of the exceptions from operations that completed unsuccessfully\n+        final LinkedBlockingQueue<Integer> exceptions = new LinkedBlockingQueue<Integer>();\n+\n+        public MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context, int successRc, int failureRc) {\n+            this.expected = expected;\n+            this.cb = cb;\n+            this.context = context;\n+            this.failureRc = failureRc;\n+            this.successRc = successRc;\n+            if (expected == 0) {\n+                cb.processResult(successRc, null, context);\n+            }\n+        }\n+\n+        private void tick() {\n+            if (done.incrementAndGet() == expected) {\n+                if (exceptions.isEmpty()) {\n+                    cb.processResult(successRc, null, context);\n+                } else {\n+                    cb.processResult(failureRc, null, context);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void processResult(int rc, String path, Object ctx) {\n+            if (rc != successRc) {\n+                LOG.error(\"Error in mutil callback : \" + rc);\n+                exceptions.add(rc);\n+            }\n+            tick();\n+        }\n+\n+    }\n+\n+    /**\n+     * Processor to process a specific element\n+     */\n+    public static interface Processor<T> {\n+        /**\n+         * Process a specific element\n+         *\n+         * @param data\n+         *          data to process\n+         * @param iterationCallback\n+         *          Callback to invoke when process has been done.\n+         */\n+        public void process(T data, AsyncCallback.VoidCallback cb);\n+    }\n+\n }"},{"sha":"5706dd869d1987c6201d8451f887e29d5ad94123","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -122,7 +122,8 @@ private void initializeZookeper() {\n             LOG.error(\"Exception while creating znodes\", e);\n         }\n     }\n-    private void runBookies(ServerConfiguration baseConf) throws IOException {\n+    private void runBookies(ServerConfiguration baseConf) \n+            throws IOException, KeeperException, InterruptedException {\n         LOG.info(\"Starting Bookie(s)\");\n         // Create Bookie Servers (B1, B2, B3)\n \n@@ -148,7 +149,8 @@ private void runBookies(ServerConfiguration baseConf) throws IOException {\n         }\n     }\n \n-    public static void main(String[] args) throws IOException, InterruptedException {\n+    public static void main(String[] args)\n+            throws IOException, KeeperException, InterruptedException {\n         if(args.length < 1) {\n             usage();\n             System.exit(-1);"},{"sha":"b289bc4577c58dab1ee87c2d27a5a4a5a7327390","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -37,7 +37,7 @@ static void usage() {\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public static void main(String[] args) throws IOException, InterruptedException {\n+    public static void main(String[] args) throws Exception {\n         if (args.length < 1 || !(args[0].equals(\"client\") || args[0].equals(\"bookie\"))) {\n             usage();\n             return;"},{"sha":"5a563f6e451a87c5ec6ca044b5224f161a848850","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"modified","additions":0,"deletions":25,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -28,11 +28,6 @@\n  */\n public class StringUtils {\n \n-    /*\n-     * Path to ledger metadata. ZooKeeper appends a sequence number to L.\n-     */\n-    static public final String prefix = \"/ledgers/L\";\n-\n     /**\n      * Parses address into IP and port.\n      *\n@@ -71,24 +66,4 @@ public static String getZKStringId(long id) {\n         return String.format(\"%010d\", id);\n     }\n \n-    /**\n-     * Get the path for the ledger metadata node\n-     *\n-     * @return\n-     */\n-    public static String getLedgerNodePath(long ledgerId) {\n-        return prefix + StringUtils.getZKStringId(ledgerId);\n-    }\n-\n-    public static long getLedgerId(String nodeName) throws IOException {\n-        long ledgerId;\n-        try {\n-            String parts[] = nodeName.split(prefix);\n-            ledgerId = Long.parseLong(parts[parts.length - 1]);\n-        } catch (NumberFormatException e) {\n-            throw new IOException(e);\n-        }\n-        return ledgerId;\n-    }\n-\n }"},{"sha":"aa59441ef9ae6a84f40529231ced9c5a5e0d1e69","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,94 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.util;\n+\n+import java.io.File;\n+import java.util.List;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Provided utilites for zookeeper access, etc.\n+ */\n+public class ZkUtils {\n+\n+    /**\n+     * Create zookeeper path recursively\n+     *\n+     * @param zk\n+     *          Zookeeper client\n+     * @param originalPath\n+     *          Zookeeper full path\n+     * @param data\n+     *          Zookeeper data\n+     * @param acl\n+     *          Acl of the zk path\n+     * @param createMode\n+     *          Create mode of zk path\n+     * @param callback\n+     *          Callback\n+     * @param ctx\n+     *          Context object\n+     */\n+    public static void createFullPathOptimistic(\n+        final ZooKeeper zk, final String originalPath, final byte[] data,\n+        final List<ACL> acl, final CreateMode createMode,\n+        final AsyncCallback.StringCallback callback, final Object ctx) {\n+\n+        zk.create(originalPath, data, acl, createMode, new StringCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, String name) {\n+\n+                if (rc != Code.NONODE.intValue()) {\n+                    callback.processResult(rc, path, ctx, name);\n+                    return;\n+                }\n+\n+                // Since I got a nonode, it means that my parents don't exist\n+                // create mode is persistent since ephemeral nodes can't be\n+                // parents\n+                createFullPathOptimistic(zk, new File(originalPath).getParent().replace(\"\\\\\", \"/\"), new byte[0], acl,\n+                        CreateMode.PERSISTENT, new StringCallback() {\n+\n+                            @Override\n+                            public void processResult(int rc, String path, Object ctx, String name) {\n+                                if (rc == Code.OK.intValue() || rc == Code.NODEEXISTS.intValue()) {\n+                                    // succeeded in creating the parent, now\n+                                    // create the original path\n+                                    createFullPathOptimistic(zk, originalPath, data, acl, createMode, callback,\n+                                            ctx);\n+                                } else {\n+                                    callback.processResult(rc, path, ctx, name);\n+                                }\n+                            }\n+                        }, ctx);\n+            }\n+        }, ctx);\n+\n+    }\n+\n+}"},{"sha":"80e46b9684f97df38758dc914479a515e0d2691a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":11,"deletions":14,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -38,7 +38,6 @@\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.test.BaseTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -56,8 +55,6 @@\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.KeeperException.Code;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -214,21 +211,21 @@ private void startNewBookie(int port)\n     /**\n      * Helper method to verify that we can read the recovered ledger entries.\n      *\n-     * @param numLedgers\n-     *            Number of ledgers to verify\n+     * @param oldLhs\n+     *            Old Ledger Handles\n      * @param startEntryId\n      *            Start Entry Id to read\n      * @param endEntryId\n      *            End Entry Id to read\n      * @throws BKException\n      * @throws InterruptedException\n      */\n-    private void verifyRecoveredLedgers(int numLedgers, long startEntryId, long endEntryId) throws BKException,\n+    private void verifyRecoveredLedgers(List<LedgerHandle> oldLhs, long startEntryId, long endEntryId) throws BKException,\n         InterruptedException {\n         // Get a set of LedgerHandles for all of the ledgers to verify\n         List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n-        for (int i = 0; i < numLedgers; i++) {\n-            lhs.add(bkc.openLedger(i + 1, digestType, baseClientConf.getBookieRecoveryPasswd()));\n+        for (int i = 0; i < oldLhs.size(); i++) {\n+            lhs.add(bkc.openLedger(oldLhs.get(i).getId(), digestType, baseClientConf.getBookieRecoveryPasswd()));\n         }\n         // Read the ledger entries to verify that they are all present and\n         // correct in the new bookie.\n@@ -293,7 +290,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n         }\n \n         // Verify the recovered ledger entries are okay.\n-        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+        verifyRecoveredLedgers(lhs, 0, 2 * numMsgs - 1);\n     }\n \n     /**\n@@ -349,7 +346,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n         }\n \n         // Verify the recovered ledger entries are okay.\n-        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+        verifyRecoveredLedgers(lhs, 0, 2 * numMsgs - 1);\n     }\n \n     /**\n@@ -392,7 +389,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n \n         // Verify the recovered ledger entries are okay.\n-        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+        verifyRecoveredLedgers(lhs, 0, 2 * numMsgs - 1);\n     }\n \n     /**\n@@ -438,7 +435,7 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n         bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n \n         // Verify the recovered ledger entries are okay.\n-        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+        verifyRecoveredLedgers(lhs, 0, 2 * numMsgs - 1);\n     }\n \n     private static class ReplicationVerificationCallback implements ReadEntryCallback {\n@@ -472,7 +469,7 @@ long await() throws InterruptedException {\n     }\n \n     private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws Exception {\n-        String znodepath = StringUtils.getLedgerNodePath(lh.getId());\n+        String znodepath = bkc.getLedgerManager().getLedgerPath(lh.getId());\n         Stat stat = bkc.getZkHandle().exists(znodepath, false);\n         assertNotNull(stat);\n         byte[] mdbytes = bkc.getZkHandle().getData(znodepath, false, stat); \n@@ -519,7 +516,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n     private boolean findDupesInEnsembles(List<LedgerHandle> lhs) throws Exception {\n         long numDupes = 0;\n         for (LedgerHandle lh : lhs) {\n-            String znodepath = StringUtils.getLedgerNodePath(lh.getId());\n+            String znodepath = bkc.getLedgerManager().getLedgerPath(lh.getId());\n             Stat stat = bkc.getZkHandle().exists(znodepath, false);\n             assertNotNull(stat);\n             byte[] mdbytes = bkc.getZkHandle().getData(znodepath, false, stat); "},{"sha":"3a0e261b318c61f471141c51b97ca4169886d325","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -63,7 +63,7 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n \n     @Override\n     @Before\n-    public void setUp() throws IOException {\n+    public void setUp() throws Exception {\n         String txnDirName = System.getProperty(\"txnDir\");\n         if (txnDirName != null) {\n             txnDir = new File(txnDirName);"},{"sha":"24b3c12cfb338b083845eceeb64b341d13edab77","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalAsyncLedgerOpsTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,47 @@\n+package org.apache.bookkeeper.meta;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n+import org.apache.bookkeeper.test.AsyncLedgerOpsTest;\n+\n+import org.junit.Before;\n+\n+/**\n+ * Test ledger delete using HierarchicalLedgerManager\n+ */\n+public class HierarchicalAsyncLedgerOpsTest extends AsyncLedgerOpsTest {\n+\n+    public HierarchicalAsyncLedgerOpsTest(DigestType digestType) {\n+        super(digestType);\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        super.setUp();\n+    }\n+\n+}"},{"sha":"70a4ea913a9c8c2c7d25742a0f7d461a29404a78","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieFailureTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,47 @@\n+package org.apache.bookkeeper.meta;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n+import org.apache.bookkeeper.test.BookieFailureTest;\n+\n+import org.junit.Before;\n+\n+/**\n+ * Test Bookie Failure using HierarchicalLedgerManager\n+ */\n+public class HierarchicalBookieFailureTest extends BookieFailureTest {\n+\n+    public HierarchicalBookieFailureTest(DigestType digestType) {\n+        super(digestType);\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        super.setUp();\n+    }\n+\n+}"},{"sha":"7d97fd4f753f00508710fa05dda24e2af216b9fb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieReadWriteTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,47 @@\n+package org.apache.bookkeeper.meta;\n+\n+/*\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*   http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing,\n+* software distributed under the License is distributed on an\n+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+* KIND, either express or implied.  See the License for the\n+* specific language governing permissions and limitations\n+* under the License.\n+*\n+*/\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n+import org.apache.bookkeeper.test.BookieReadWriteTest;\n+\n+import org.junit.Before;\n+\n+/**\n+* Test read / write using HierarchicalLedgerManager\n+*/\n+public class HierarchicalBookieReadWriteTest extends BookieReadWriteTest {\n+\n+   public HierarchicalBookieReadWriteTest(DigestType digestType) {\n+       super(digestType);\n+   }\n+\n+   @Before\n+   @Override\n+   public void setUp() throws Exception {\n+       baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+       baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+       super.setUp();\n+   }\n+\n+}\n\\ No newline at end of file"},{"sha":"d99156e9bb7628b9f8e9e2f578319bf19918e9be","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalBookieRecoveryTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,46 @@\n+package org.apache.bookkeeper.meta;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.BookieRecoveryTest;\n+\n+import org.junit.Before;\n+\n+/**\n+ * Test Bookie Recovery using HierarchicalLedgerManager\n+ */\n+public class HierarchicalBookieRecoveryTest extends BookieRecoveryTest {\n+\n+    public HierarchicalBookieRecoveryTest(DigestType digestType) {\n+        super(digestType);\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        super.setUp();\n+    }\n+\n+}"},{"sha":"6fd1c5c2450fa13cfaf3c58422973fe20aab72e3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,47 @@\n+package org.apache.bookkeeper.meta;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.meta.HierarchicalLedgerManager;\n+import org.apache.bookkeeper.test.LedgerDeleteTest;\n+\n+import org.junit.Before;\n+\n+/**\n+ * Test ledger delete using HierarchicalLedgerManager\n+ */\n+public class HierarchicalLedgerDeleteTest extends LedgerDeleteTest {\n+\n+    public HierarchicalLedgerDeleteTest(DigestType digestType) {\n+        super(digestType);\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        baseConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        baseClientConf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        super.setUp();\n+    }\n+\n+}"},{"sha":"8235ce522d7be555819cc9a552561db7bead6bd4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","status":"added","additions":136,"deletions":0,"changes":136,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,136 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.Random;\n+import java.lang.reflect.Field;\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.bookkeeper.test.BaseTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.Assert.*;\n+\n+public class LedgerLayoutTest extends BaseTestCase {\n+    DigestType digestType;\n+\n+    public LedgerLayoutTest(DigestType digestType) {\n+        super(0);\n+        this.digestType = digestType;\n+    }\n+\n+    @Test\n+    public void testLedgerLayout() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        String ledgerRootPath = \"/testLedgerLayout\";\n+\n+        zkc.create(ledgerRootPath, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        LedgerLayout layout = LedgerLayout.readLayout(zkc, ledgerRootPath);\n+        assertTrue(\"Layout should be null\", layout == null);\n+\n+        String testName = \"foobar\";\n+        int testVersion = 0xdeadbeef;\n+        // use layout defined in configuration also create it in zookeeper\n+        LedgerLayout layout2 = new LedgerLayout(testName, testVersion);\n+        layout2.store(zkc, ledgerRootPath);\n+\n+        layout = LedgerLayout.readLayout(zkc, ledgerRootPath);\n+        assertEquals(testName, layout.getManagerType());\n+        assertEquals(testVersion, layout.getManagerVersion());\n+    }\n+\n+    private void writeLedgerLayout(\n+                                  String ledgersRootPath,\n+                                  String managerType,\n+                                  int managerVersion, int layoutVersion)\n+        throws Exception {\n+        LedgerLayout layout = new LedgerLayout(managerType, managerVersion);\n+\n+        Field f = LedgerLayout.class.getDeclaredField(\"layoutFormatVersion\");\n+        f.setAccessible(true);\n+        f.set(layout, layoutVersion);\n+\n+        layout.store(zkc, ledgersRootPath);\n+    }\n+\n+    @Test\n+    public void testBadVersionLedgerLayout() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        // write bad version ledger layout\n+        writeLedgerLayout(conf.getZkLedgersRootPath(), FlatLedgerManager.NAME,\n+                FlatLedgerManager.CUR_VERSION, LedgerLayout.LAYOUT_FORMAT_VERSION + 1);\n+        \n+        try {\n+            LedgerLayout.readLayout(zkc, conf.getZkLedgersRootPath());\n+            fail(\"Shouldn't reach here!\");\n+        } catch (IOException ie) {\n+            assertTrue(\"Invalid exception\", ie.getMessage().contains(\"version not compatible\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testAbsentLedgerManagerLayout() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        String ledgersLayout = conf.getZkLedgersRootPath() + \"/\" + LedgerLayout.LAYOUT_ZNODE;\n+        // write bad format ledger layout\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append(\"\\n\");\n+        zkc.create(ledgersLayout, sb.toString().getBytes(),\n+                                 Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        try {\n+            LedgerLayout.readLayout(zkc, conf.getZkLedgersRootPath());\n+            fail(\"Shouldn't reach here!\");\n+        } catch (IOException ie) {\n+            assertTrue(\"Invalid exception\", ie.getMessage().contains(\"version absent from\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testBaseLedgerManagerLayout() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        String rootPath = conf.getZkLedgersRootPath();\n+        String ledgersLayout = rootPath + \"/\" + LedgerLayout.LAYOUT_ZNODE;\n+        // write bad format ledger layout\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append(\"\\n\")\n+          .append(FlatLedgerManager.NAME);\n+        zkc.create(ledgersLayout, sb.toString().getBytes(),\n+                                 Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        try {\n+            LedgerLayout.readLayout(zkc, rootPath);\n+            fail(\"Shouldn't reach here!\");\n+        } catch (IOException ie) {\n+            assertTrue(\"Invalid exception\", ie.getMessage().contains(\"Invalid Ledger Manager\"));\n+        }\n+    }\n+}"},{"sha":"099eb7c0e125e15a0e4265c688662d898f4897d7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","status":"added","additions":261,"deletions":0,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.CountDownLatch;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.apache.bookkeeper.test.BaseTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.Assert.*;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestLedgerManager extends BaseTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(TestLedgerManager.class);\n+\n+    public TestLedgerManager(DigestType digestType) {\n+        super(0);\n+    }\n+\n+    /** \n+     * Test bad client configuration\n+     */\n+    @Test\n+    public void testBadConf() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        \n+        // success case\n+        String root0 = \"/goodconf0\";\n+        zkc.create(root0, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        conf.setZkLedgersRootPath(root0);\n+\n+        LedgerManager m = LedgerManagerFactory.newLedgerManager(conf, zkc);\n+        assertTrue(\"Ledger manager is unexpected type\", \n+                   (m instanceof FlatLedgerManager));\n+\n+        // mismatching conf\n+        conf.setLedgerManagerType(HierarchicalLedgerManager.NAME);\n+        try {\n+            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            assertTrue(\"Invalid exception\", \n+                       e.getMessage().contains(\"does not match existing layout\"));\n+        }\n+\n+        // invalid ledger manager\n+        String root1 = \"/badconf1\";\n+        zkc.create(root1, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        conf.setZkLedgersRootPath(root1);\n+\n+        conf.setLedgerManagerType(\"DoesNotExist\");\n+        try {\n+            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            assertTrue(\"Invalid exception\", \n+                    e.getMessage().contains(\"Unknown ledger manager type \"));\n+        }\n+    }\n+\n+    /**\n+     * Test bad zk configuration\n+     */\n+    @Test\n+    public void testBadZkContents() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        \n+        // bad type in zookeeper\n+        String root0 = \"/badzk0\";\n+        zkc.create(root0, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        conf.setZkLedgersRootPath(root0);\n+        \n+        new LedgerLayout(\"DoesNotExist\",\n+                         0xdeadbeef).store(zkc, root0);\n+        \n+        try {\n+            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            assertTrue(\"Invalid exception\", \n+                    e.getMessage().contains(\"Unknown ledger manager type\"));\n+        }\n+\n+        // bad version in zookeeper\n+        String root1 = \"/badzk1\";\n+        zkc.create(root1, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        conf.setZkLedgersRootPath(root1);\n+        \n+        new LedgerLayout(FlatLedgerManager.NAME,\n+                         0xdeadbeef).store(zkc, root1);\n+        \n+        try {\n+            LedgerManagerFactory.newLedgerManager(conf, zkc);\n+            fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            assertTrue(\"Invalid exception\", \n+                    e.getMessage().contains(\"Incompatible layout version found\"));\n+        }\n+    }\n+\n+    private static class CreateLMThread extends Thread {\n+        private boolean success = false;\n+        private final String type;\n+        private final String root;\n+        private final CyclicBarrier barrier;\n+        private ZooKeeper zkc;\n+        \n+        CreateLMThread(String root, String type, CyclicBarrier barrier) throws Exception {\n+            this.type = type;\n+            this.barrier = barrier;\n+            this.root = root;\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            zkc = new ZooKeeper(\"127.0.0.1\", 10000, new Watcher() {\n+                    public void process(WatchedEvent event) {\n+                        latch.countDown();\n+                    }\n+                });\n+            latch.await();\n+        }\n+\n+        public void run() {\n+            ClientConfiguration conf = new ClientConfiguration();\n+            conf.setLedgerManagerType(type);\n+\n+            try {\n+                barrier.await();\n+                LedgerManagerFactory.newLedgerManager(conf, zkc);\n+                \n+                success = true;\n+            } catch (Exception e) {\n+                LOG.error(\"Failed to create ledger manager\", e);\n+            }\n+        }\n+\n+        public boolean isSuccessful() {\n+            return success;\n+        }\n+        \n+        public void close() throws Exception {\n+            zkc.close();\n+        }\n+    }\n+\n+    // test concurrent\n+    @Test\n+    public void testConcurrent1() throws Exception {\n+        /// everyone creates the same\n+        int numThreads = 50;\n+        \n+        // bad version in zookeeper\n+        String root0 = \"/lmroot0\";\n+        zkc.create(root0, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(numThreads+1);\n+        List<CreateLMThread> threads = new ArrayList<CreateLMThread>(numThreads);\n+        for (int i = 0; i < numThreads; i++) {\n+            CreateLMThread t = new CreateLMThread(root0, FlatLedgerManager.NAME, barrier);\n+            t.start();\n+            threads.add(t);\n+        }\n+\n+        barrier.await();\n+\n+        boolean success = true;\n+        for (CreateLMThread t : threads) {\n+            t.join();\n+            t.close();\n+            success = t.isSuccessful() && success;\n+        }\n+        assertTrue(\"Not all ledger managers created\", success);\n+    }\n+\n+    @Test\n+    public void testConcurrent2() throws Exception {\n+        /// odd create different\n+        int numThreadsEach = 25;\n+        \n+        // bad version in zookeeper\n+        String root0 = \"/lmroot0\";\n+        zkc.create(root0, new byte[0], \n+                   Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(numThreadsEach*2+1);\n+        List<CreateLMThread> threadsA = new ArrayList<CreateLMThread>(numThreadsEach);\n+        for (int i = 0; i < numThreadsEach; i++) {\n+            CreateLMThread t = new CreateLMThread(root0, FlatLedgerManager.NAME, barrier);\n+            t.start();\n+            threadsA.add(t);\n+        }\n+        List<CreateLMThread> threadsB = new ArrayList<CreateLMThread>(numThreadsEach);\n+        for (int i = 0; i < numThreadsEach; i++) {\n+            CreateLMThread t = new CreateLMThread(root0, \n+                    HierarchicalLedgerManager.NAME, barrier);\n+            t.start();\n+            threadsB.add(t);\n+        }\n+\n+        barrier.await();\n+\n+        int numSuccess = 0;\n+        int numFails = 0;\n+        for (CreateLMThread t : threadsA) {\n+            t.join();\n+            t.close();\n+            if (t.isSuccessful()) {\n+                numSuccess++;\n+            } else {\n+                numFails++;\n+            }\n+        }\n+\n+        for (CreateLMThread t : threadsB) {\n+            t.join();\n+            t.close();\n+            if (t.isSuccessful()) {\n+                numSuccess++;\n+            } else {\n+                numFails++;\n+            }\n+        }\n+        assertEquals(\"Incorrect number of successes\", numThreadsEach, numSuccess);\n+        assertEquals(\"Incorrect number of failures\", numThreadsEach, numFails);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"3b1bacd286639d288cf22d59577bf6ec3fc47d13","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":13,"deletions":4,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -36,6 +36,7 @@\n import org.apache.bookkeeper.proto.BookieServer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n@@ -140,9 +141,11 @@ public void setUp() throws Exception {\n                 server.start();\n                 bs.add(server);\n             }\n-            zkc.close();\n+\n             baseClientConf.setZkServers(\"127.0.0.1\");\n-            bkc = new BookKeeperTestClient(baseClientConf);\n+            if (numBookies > 0) {\n+                bkc = new BookKeeperTestClient(baseClientConf);\n+            }\n         } catch(Exception e) {\n             LOG.error(\"Error setting up\", e);\n             throw e;\n@@ -168,14 +171,16 @@ public void killBookie(InetSocketAddress addr) throws InterruptedException {\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    protected void restartBookies() throws InterruptedException, IOException {\n+    protected void restartBookies() \n+            throws InterruptedException, IOException, KeeperException {\n         restartBookies(null);\n     }\n \n     /**\n      * Restart bookie servers add new configuration settings\n      */\n-    protected void restartBookies(ServerConfiguration newConf) throws InterruptedException, IOException {\n+    protected void restartBookies(ServerConfiguration newConf)\n+            throws InterruptedException, IOException, KeeperException {\n         // shut down bookie server\n         for (BookieServer server : bs) {\n             server.shutdown();\n@@ -209,6 +214,10 @@ public void tearDown() throws Exception {\n             server.shutdown();\n         }\n \n+        if (zkc != null) {\n+            zkc.close();\n+        }\n+\n         for (File f : tmpDirs) {\n             cleanUpDir(f);\n         }"},{"sha":"2bca4c9fce181fc4ad29b5a2e6a9d255c3fe28b4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -54,7 +54,7 @@\n \n     @Override\n     @Before\n-    public void setUp() throws IOException {\n+    public void setUp() throws Exception {\n         String txnDirName = System.getProperty(\"txnDir\");\n         if (txnDirName != null) {\n             txnDir = new File(txnDirName);"},{"sha":"c02e283bcfe4aaec71b0b139ed4c314eaa49ef7d","filename":"doc/bookkeeperConfig.textile","status":"modified","additions":43,"deletions":1,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/3af9f38fc3b53c40751904972384ecb9a4e9fb44/doc/bookkeeperConfig.textile","raw_url":"https://github.com/apache/bookkeeper/raw/3af9f38fc3b53c40751904972384ecb9a4e9fb44/doc/bookkeeperConfig.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperConfig.textile?ref=3af9f38fc3b53c40751904972384ecb9a4e9fb44","patch":"@@ -72,4 +72,46 @@ bq. NOTE: keeping number of old journal files would be useful for manually recov\n \n h1. ZooKeeper Metadata\n \n-p. For BookKeeper, we require a ZooKeeper installation to store metadata, and to pass the list of ZooKeeper servers as parameter to the constructor of the BookKeeper class ( @org.apache.bookkeeper.client,BookKeeper@ ). To setup ZooKeeper, please check the \"ZooKeeper documentation\":index.html. \n\\ No newline at end of file\n+p. For BookKeeper, we require a ZooKeeper installation to store metadata, and to pass the list of ZooKeeper servers as parameter to the constructor of the BookKeeper class ( @org.apache.bookkeeper.client,BookKeeper@ ). To setup ZooKeeper, please check the \"ZooKeeper documentation\":index.html. \n+\n+p. BookKeeper provides two mechnaisms to organize its metadata in ZooKeeper.\n+\n+* FlatLedgerManager : All ledger metadata are placed as children in a single zookeeper path.\n+* HierarchicalLedgerManager : All ledger metadata are partitioned into 2-level znodes.\n+\n+h2. Flat Ledger Manager\n+\n+p. All ledgers' metadata are put in a single zookeeper path, created using zookeeper sequential node, which can ensure uniqueness of ledger id. Each ledger node is prefixed with 'L'.\n+\n+p. Bookie server manages its owned active ledgers in a hash map. So it is easy for bookie server to find what ledgers are deleted from zookeeper and garbage collect them. And its garbage collection flow is described as below:\n+\n+* Fetch all existing ledgers from zookeeper (*zkActiveLedgers*).\n+* Fetch all ledgers currently active within the Bookie (*bkActiveLedgers*).\n+* Loop over *bkActiveLedgers* to find those ledgers which do not exist in *zkActiveLedgers* and garbage collect them.\n+\n+h2. Hierarchical Ledger Manager\n+\n+p. Hierarchical Ledger Manager first obtains a global unique id from ZooKeeper using a EPHEMERAL_SEQUENTIAL znode.\n+\n+p. Since ZooKeeper sequential counter has a format of %10d -- that is 10 digits with 0 (zero) padding, i.e. \"&lt;path&gt;0000000001\", HierarchicalLedgerManager splits the generated id into 3 parts :\n+\n+ @ {level1 (2 digits)}{level2 (4 digits)}{level3 (4 digits)}\n+\n+p. These 3 parts are used to form the actual ledger node path used to store ledger metadata:\n+\n+ @ {ledgers_root_path}/{level1}/{level2}/L{level3}\n+\n+p. E.g. Ledger 0000000001 is split into 3 parts 00, 0000, 00001, which is stored in znode /{ledgers_root_path}/00/0000/L0001. So each znode could have at most 10000 ledgers, which avoids the problem of the child list being larger than the maximum ZooKeeper packet size.\n+\n+p. Bookie server manages its active ledgers in a sorted map, which simplifies access to active ledgers in a particular (level1, level2) partition.\n+\n+p. Garbage collection in bookie server is processed node by node as follows:\n+\n+* Fetching all level1 nodes, by calling zk#getChildren(ledgerRootPath).\n+** For each level1 nodes, fetching their level2 nodes :\n+** For each partition (level1, level2) :\n+*** Fetch all existed ledgers from zookeeper belonging to partition (level1, level2) (*zkActiveLedgers*).\n+*** Fetch all ledgers currently active in the bookie which belong to partition (level1, level2) (*bkActiveLedgers*).\n+*** Loop over *bkActiveLedgers* to find those ledgers which do not exist in *zkActiveLedgers*, and garbage collect them.\n+\n+bq. NOTE: Hierarchical Ledger Manager is more suitable to manage large number of ledgers existed in BookKeeper."}]}

