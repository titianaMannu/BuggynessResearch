{"sha":"3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","node_id":"MDY6Q29tbWl0MTU3NTk1NjozZTIyNGM0YjZkNGEwZDkzMTcwNjBmN2ZlMGQzNTE5ZmNjYzY4ZjVh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T07:43:50Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T07:43:50Z"},"message":"BOOKKEEPER-215: Deadlock occurs under high load (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335958 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"89696a33e81e1d1a58b41949824bd8c5dae6dcf1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/89696a33e81e1d1a58b41949824bd8c5dae6dcf1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","html_url":"https://github.com/apache/bookkeeper/commit/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","url":"https://api.github.com/repos/apache/bookkeeper/commits/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","html_url":"https://github.com/apache/bookkeeper/commit/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf"}],"stats":{"total":365,"additions":353,"deletions":12},"files":[{"sha":"888e5da70eca9a3412421604f8eca338f8c7faac","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -114,6 +114,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-56: Race condition of message handler in connection recovery in Hedwig client (sijie & Gavin Li via ivank)\n \n+        BOOKKEEPER-215: Deadlock occurs under high load (sijie via ivank)\n+\n       bookkeeper-benchmark/\n \t\n \tBOOKKEEPER-207: BenchBookie doesn't run correctly (ivank via fpj)"},{"sha":"eb0955b50395288096348304e077745655677f89","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -78,8 +78,6 @@\n     final BookieClient bookieClient;\n     final BookieWatcher bookieWatcher;\n \n-    // used to call bookkeeper op in callback\n-    final OrderedSafeExecutor callbackWorker;\n     final OrderedSafeExecutor mainWorkerPool;\n \n     // Ledger manager responsible for how to store ledger meta data\n@@ -140,7 +138,6 @@ public void process(WatchedEvent event) {\n         bookieWatcher = new BookieWatcher(this);\n         bookieWatcher.readBookiesBlocking();\n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n-        callbackWorker = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n         // initialize ledger meta manager\n         ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n@@ -197,7 +194,6 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n         bookieWatcher = new BookieWatcher(this);\n         bookieWatcher.readBookiesBlocking();\n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n-        callbackWorker = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n         // initialize ledger meta manager\n         ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n@@ -553,7 +549,6 @@ public void close() throws InterruptedException, BKException {\n         if (ownZKHandle) {\n             zk.close();\n         }\n-        callbackWorker.shutdown();\n         mainWorkerPool.shutdown();\n     }\n "},{"sha":"e5fd5c2a29d1499527971299cdf4283590e97cf0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -72,11 +72,16 @@\n     public BookieServer(ServerConfiguration conf) \n             throws IOException, KeeperException, InterruptedException, BookieException {\n         this.conf = conf;\n-        this.bookie = new Bookie(conf);\n+        this.bookie = newBookie(conf);\n \n         isStatsEnabled = conf.isStatisticsEnabled();\n     }\n \n+    protected Bookie newBookie(ServerConfiguration conf)\n+        throws IOException, KeeperException, InterruptedException, BookieException {\n+        return new Bookie(conf);\n+    }\n+\n     public void start() throws IOException {\n         this.bookie.start();\n "},{"sha":"57232ba375d47db6d15dece98d6cd50dc77f0cad","filename":"hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -51,4 +51,13 @@ public void loadConf(URL confURL) throws ConfigurationException {\n         conf.addConfiguration(loadedConf);\n \n     }\n+\n+    /**\n+     * Add configuration object.\n+     *\n+     * @param conf configuration object\n+     */\n+    public void addConf(Configuration otherConf) throws ConfigurationException {\n+        conf.addConfiguration(otherConf);\n+    }\n }"},{"sha":"c8a936ac26bb3110e47a4716bcd102a9d4d7b65d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":15,"deletions":4,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -170,10 +170,16 @@ public BookkeeperPersistenceManager(BookKeeper bk, ZooKeeper zk, TopicManager tm\n         int numMessagesRead = 0;\n         long totalSizeRead = 0;\n         TopicInfo topicInfo;\n+        long startSeqIdToScan;\n \n         public RangeScanOp(RangeScanRequest request) {\n+            this(request, -1L);\n+        }\n+\n+        public RangeScanOp(RangeScanRequest request, long startSeqId) {\n             queuer.super(request.topic);\n             this.request = request;\n+            this.startSeqIdToScan = startSeqId;\n         }\n \n         @Override\n@@ -185,8 +191,9 @@ protected void runInternal() {\n                 return;\n             }\n \n-            startReadingFrom(request.startSeqId);\n-\n+            // if startSeqIdToScan is less than zero, which means it is an unfinished scan request\n+            // we continue the scan from the provided position\n+            startReadingFrom(startSeqIdToScan < 0 ? request.startSeqId : startSeqIdToScan);\n         }\n \n         protected void read(final InMemoryLedgerRange imlr, final long startSeqId, final long endSeqId) {\n@@ -275,8 +282,8 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                         }\n                     }\n \n-                    startReadingFrom(imlr.startSeqIdIncluded + entry.getEntryId() + 1);\n-\n+                    // continue scanning messages\n+                    scanMessages(request, imlr.startSeqIdIncluded + entry.getEntryId() + 1);\n                 }\n             }, request.ctx);\n         }\n@@ -310,6 +317,10 @@ public void scanMessages(RangeScanRequest request) {\n         queuer.pushAndMaybeRun(request.topic, new RangeScanOp(request));\n     }\n \n+    protected void scanMessages(RangeScanRequest request, long scanSeqId) {\n+        queuer.pushAndMaybeRun(request.topic, new RangeScanOp(request, scanSeqId));\n+    }\n+\n     public void deliveredUntil(ByteString topic, Long seqId) {\n         // Nothing to do here. this is just a hint that we cannot use.\n     }"},{"sha":"6b2e73151a566ba2dd378b80450bc73f656d934d","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -44,6 +44,7 @@\n     // Default number of bookie servers to setup. Extending classes can\n     // override this.\n     protected int numBookies = 3;\n+    protected long readDelay = 0L;\n     protected BookKeeperTestBase bktb;\n \n     // PubSubServer variables\n@@ -132,7 +133,7 @@ protected void stopHubServers() throws Exception {\n     @Before\n     public void setUp() throws Exception {\n         logger.info(\"STARTING \" + getName());\n-        bktb = new BookKeeperTestBase(numBookies);\n+        bktb = new BookKeeperTestBase(numBookies, readDelay);\n         bktb.setUp();\n         startHubServers();\n         logger.info(\"HedwigHub test setup finished\");"},{"sha":"6dddf47aa19eee1b6c2d714ec4c789aea7846b9b","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","status":"modified","additions":47,"deletions":1,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -18,11 +18,15 @@\n package org.apache.hedwig.server.persistence;\n \n import java.net.InetAddress;\n+import java.nio.ByteBuffer;\n import java.io.File;\n+import java.io.IOException;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Random;\n \n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -48,6 +52,40 @@\n public class BookKeeperTestBase extends ZooKeeperTestBase {\n     private static Logger LOG = LoggerFactory.getLogger(BookKeeperTestBase.class);\n \n+    class TestBookie extends Bookie {\n+        final long readDelay;\n+\n+        public TestBookie(ServerConfiguration conf, long readDelay)\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n+            super(conf);\n+            this.readDelay = readDelay;\n+        }\n+\n+        @Override\n+        public ByteBuffer readEntry(long ledgerId, long entryId)\n+            throws IOException, NoLedgerException {\n+            if (readDelay > 0) {\n+                try {\n+                    Thread.sleep(readDelay);\n+                } catch (InterruptedException ie) {\n+                }\n+            }\n+            return super.readEntry(ledgerId, entryId);\n+        }\n+    }\n+\n+    class TestBookieServer extends BookieServer {\n+        public TestBookieServer(ServerConfiguration conf)\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n+            super(conf);\n+        }\n+\n+        protected Bookie newBookie(ServerConfiguration conf)\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n+            return new TestBookie(conf, readDelay);\n+        }\n+    }\n+\n     // BookKeeper Server variables\n     private List<BookieServer> bookiesList;\n     private List<ServerConfiguration> bkConfsList;\n@@ -58,6 +96,9 @@\n     private static final String PREFIX = \"bookie\";\n     private static final String SUFFIX = \"test\";\n \n+    // readDelay\n+    protected long readDelay;\n+\n     // Variable to decide how many bookie servers to set up.\n     private final int numBookies;\n     // BookKeeper client instance\n@@ -68,7 +109,12 @@\n \n     // Constructor\n     public BookKeeperTestBase(int numBookies) {\n+        this(numBookies, 0L);\n+    }\n+\n+    public BookKeeperTestBase(int numBookies, long readDelay) {\n         this.numBookies = numBookies;\n+        this.readDelay = readDelay;\n     }\n \n     public BookKeeperTestBase() {\n@@ -168,7 +214,7 @@ public void startUpNewBookieServer() throws Exception {\n      *\n      */\n     private BookieServer startBookie(ServerConfiguration conf) throws Exception {\n-        BookieServer server = new BookieServer(conf);\n+        BookieServer server = new TestBookieServer(conf);\n         server.start();\n \n         int port = conf.getBookiePort();"},{"sha":"114e0c5970d7eb93bd4546c6076db60f89a01cf2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/bookkeeper/blob/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","raw_url":"https://github.com/apache/bookkeeper/raw/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java?ref=3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","patch":"@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.persistence;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.SynchronousQueue;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.HedwigClient;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.server.HedwigHubTestBase;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.ConcurrencyUtils;\n+\n+public class TestDeadlock extends HedwigHubTestBase {\n+\n+    protected static Logger logger = LoggerFactory.getLogger(TestDeadlock.class);\n+\n+    // Client side variables\n+    protected HedwigClient client;\n+    protected Publisher publisher;\n+    protected Subscriber subscriber;\n+\n+    ByteString topic = ByteString.copyFromUtf8(\"DeadLockTopic\");\n+    ByteString subscriberId = ByteString.copyFromUtf8(\"dl\");\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        numServers = 1;\n+        numBookies = 1;\n+        readDelay = 1000L; // 1s\n+        super.setUp();\n+        client = new HedwigClient(new ClientConfiguration());\n+        publisher = client.getPublisher();\n+        subscriber = client.getSubscriber();\n+    }\n+\n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        client.close();\n+        super.tearDown();\n+    }\n+\n+    // Test implementation of Callback for async client actions.\n+    static class TestCallback implements Callback<Void> {\n+        private final SynchronousQueue<Boolean> queue;\n+\n+        public TestCallback(SynchronousQueue<Boolean> queue) {\n+            this.queue = queue;\n+        }\n+\n+        @Override\n+        public void operationFinished(Object ctx, Void resultOfOperation) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (logger.isDebugEnabled())\n+                        logger.debug(\"Operation finished!\");\n+                    ConcurrencyUtils.put(queue, true);\n+                }\n+            }).start();\n+        }\n+\n+        @Override\n+        public void operationFailed(Object ctx, final PubSubException exception) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    logger.error(\"Operation failed!\", exception);\n+                    ConcurrencyUtils.put(queue, false);\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    // Test implementation of subscriber's message handler.\n+    class TestMessageHandler implements MessageHandler {\n+        private final SynchronousQueue<Boolean> consumeQueue;\n+        boolean doAdd = false;\n+\n+        public TestMessageHandler(SynchronousQueue<Boolean> consumeQueue) {\n+            this.consumeQueue = consumeQueue;\n+        }\n+\n+        public void deliver(ByteString t, ByteString sub, final Message msg, Callback<Void> callback,\n+                            Object context) {\n+            if (!doAdd) {\n+                // after receiving first message, we send a publish\n+                // to obtain permit of second ledger\n+                doAdd = true;\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        // publish messages again to obtain permits\n+                        logger.info(\"Start publishing message to obtain permit\");\n+                        // it obtains the permit and wait for a response,\n+                        // but the response is delayed and readEntries is called\n+                        // in the readComplete callback to read entries of the\n+                        // same ledger. since there is no permit, it blocks\n+                        try {\n+                            CountDownLatch latch = new CountDownLatch(1);\n+                            sleepBookie(8, latch);\n+                            latch.await();\n+                            SynchronousQueue<Boolean> queue = new SynchronousQueue<Boolean>();\n+                            for (int i=0; i<3; i++) {\n+                                publisher.asyncPublish(topic, getMsg(9999), new TestCallback(queue), null);\n+                            }\n+                            for (int i=0; i<3; i++) {\n+                                assertTrue(queue.take());\n+                            }\n+                        } catch (Exception e) {\n+                            logger.error(\"Failed to publish message to obtain permit.\");\n+                        }\n+                    }\n+                }).start();\n+            }\n+\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ConcurrencyUtils.put(consumeQueue, true);\n+                }\n+            }).start();\n+            callback.operationFinished(context, null);\n+        }\n+    }\n+\n+    // Helper function to generate Messages\n+    protected Message getMsg(int msgNum) {\n+        return Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message\" + msgNum)).build();\n+    }\n+\n+    // Helper function to generate Topics\n+    protected ByteString getTopic(int topicNum) {\n+        return ByteString.copyFromUtf8(\"DeadLockTopic\" + topicNum);\n+    }\n+\n+    class TestServerConfiguration extends HubServerConfiguration {\n+        public TestServerConfiguration(int serverPort, int sslServerPort) {\n+            super(serverPort, sslServerPort);\n+        }\n+        @Override\n+        public int getBkEnsembleSize() {\n+            return 1;\n+        }\n+        @Override\n+        public int getBkQuorumSize() {\n+            return 1;\n+        }\n+        @Override\n+        public int getReadAheadCount() {\n+            return 4;\n+        }\n+        @Override\n+        public long getMaximumCacheSize() {\n+            return 32;\n+        }\n+    }\n+\n+    @Override\n+    protected ServerConfiguration getServerConfiguration(int serverPort, int sslServerPort) {\n+        ServerConfiguration serverConf = new TestServerConfiguration(serverPort, sslServerPort);\n+\n+        org.apache.bookkeeper.conf.ClientConfiguration bkClientConf =\n+            new org.apache.bookkeeper.conf.ClientConfiguration();\n+        bkClientConf.setNumWorkerThreads(1).setReadTimeout(9999)\n+                    .setThrottleValue(3);\n+        try {\n+            serverConf.addConf(bkClientConf);\n+        } catch (Exception e) {\n+        }\n+        return serverConf;\n+    }\n+\n+    @Test\n+    public void testDeadlock() throws Exception {\n+        int numMessages = 5;\n+\n+        SynchronousQueue<Boolean> consumeQueue = new SynchronousQueue<Boolean>();\n+\n+        // subscribe to topic\n+        logger.info(\"Setup subscriptions\");\n+        subscriber.subscribe(topic, subscriberId, CreateOrAttach.CREATE_OR_ATTACH);\n+        subscriber.closeSubscription(topic, subscriberId);\n+\n+        // publish 5 messages to form first ledger\n+        for (int i=0; i<numMessages; i++) {\n+            logger.info(\"Start publishing message {}\", i);\n+            publisher.publish(topic, getMsg(i));\n+        }\n+\n+        stopHubServers();\n+        Thread.sleep(1000);\n+        startHubServers();\n+\n+        logger.info(\"Start publishing messages\");\n+        // publish enough messages to second ledger\n+        // so a scan request need to scan over two ledgers, which\n+        // cause readEntries executed in the previous readEntries\n+        for (int i=0; i<numMessages; i++) {\n+            logger.info(\"Start publishing message {}\", i+5);\n+            publisher.publish(topic, getMsg(i));\n+        }\n+\n+        logger.info(\"Start subscribe topics again and receive messages\");\n+        // subscribe to topic\n+        subscriber.subscribe(topic, subscriberId, CreateOrAttach.CREATE_OR_ATTACH);\n+        subscriber.startDelivery(topic, subscriberId,\n+                                 new TestMessageHandler(consumeQueue));\n+        for (int i=0; i<(2*numMessages+3); i++) {\n+            assertTrue(consumeQueue.take());\n+        }\n+    }\n+\n+    protected void sleepBookie(final int seconds, final CountDownLatch l)\n+    throws InterruptedException, IOException {\n+        final String prefix = \"Bookie-\";\n+        Thread[] allThreads = new Thread[Thread.activeCount()];\n+        Thread.enumerate(allThreads);\n+        for (final Thread t : allThreads) {\n+            if (t.getName().startsWith(prefix)) {\n+                Thread sleeper = new Thread() {\n+                    public void run() {\n+                        try {\n+                            t.suspend();\n+                            l.countDown();\n+                            Thread.sleep(seconds * 1000);\n+                            t.resume();\n+                        } catch (Exception e) {\n+                            logger.error(\"Error suspending thread\", e);\n+                        }\n+                    }\n+                };\n+                sleeper.start();\n+                return;\n+            }\n+        }\n+        throw new IOException(\"Bookie thread not found\");\n+    }\n+}"}]}

