{"sha":"420a6e5e6cab583929622d190d2cd3b360cbd102","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0MjBhNmU1ZTZjYWI1ODM5Mjk2MjJkMTkwZDJjZDNiMzYwY2JkMTAy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-12T18:34:11Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-12T18:34:11Z"},"message":"BOOKKEEPER-325: Delay the replication of a ledger if RW found that its last fragment is in underReplication. (umamahesh via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1384080 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9361df08800945b4c9e0ef8c7b9c339103cf467e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9361df08800945b4c9e0ef8c7b9c339103cf467e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/420a6e5e6cab583929622d190d2cd3b360cbd102","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/420a6e5e6cab583929622d190d2cd3b360cbd102","html_url":"https://github.com/apache/bookkeeper/commit/420a6e5e6cab583929622d190d2cd3b360cbd102","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/420a6e5e6cab583929622d190d2cd3b360cbd102/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","url":"https://api.github.com/repos/apache/bookkeeper/commits/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","html_url":"https://github.com/apache/bookkeeper/commit/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f"}],"stats":{"total":418,"additions":306,"deletions":112},"files":[{"sha":"cd1dbe49e5f6a8402294002780f7c08ad906b573","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/420a6e5e6cab583929622d190d2cd3b360cbd102/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/420a6e5e6cab583929622d190d2cd3b360cbd102/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=420a6e5e6cab583929622d190d2cd3b360cbd102","patch":"@@ -134,6 +134,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-208: Separate write quorum from ack quorum (ivank)\n \n+        BOOKKEEPER-325: Delay the replication of a ledger if RW found that its last fragment is in underReplication. (umamahesh via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"16ac71ee719f79f491866594671b5a0e45218fdd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","raw_url":"https://github.com/apache/bookkeeper/raw/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java?ref=420a6e5e6cab583929622d190d2cd3b360cbd102","patch":"@@ -63,7 +63,7 @@\n      * last fragment, then no one will modify this fragment.</li>\n      * </ol>\n      */\n-    boolean isClosed() {\n+    public boolean isClosed() {\n         return isLedgerClosed;\n     }\n "},{"sha":"4af5dec83cb3326648cbe699cf9d9c4adb424daa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=420a6e5e6cab583929622d190d2cd3b360cbd102","patch":"@@ -57,6 +57,7 @@\n     protected final static String ZK_SERVERS = \"zkServers\";\n     // Statistics Parameters\n     protected final static String ENABLE_STATISTICS = \"enableStatistics\";\n+    protected final static String OPEN_LEDGER_REREPLICATION_GRACE_PERIOD = \"openLedgerRereplicationGracePeriod\";\n \n     /**\n      * Construct a default configuration object\n@@ -546,4 +547,30 @@ public ServerConfiguration setMajorCompactionInterval(long interval) {\n         setProperty(MAJOR_COMPACTION_INTERVAL, interval);\n         return this;\n     }\n+    \n+    /**\n+     * Set the grace period which the rereplication worker will wait before\n+     * fencing and rereplicating a ledger fragment which is still being written\n+     * to, on bookie failure.\n+     * \n+     * The grace period allows the writer to detect the bookie failure, and and\n+     * start writing to another ledger fragment. If the writer writes nothing\n+     * during the grace period, the rereplication worker assumes that it has\n+     * crashed and therefore fences the ledger, preventing any further writes to\n+     * that ledger.\n+     * \n+     * @see LedgerHandle#openLedger\n+     */\n+    public void setOpenLedgerRereplicationGracePeriod(String waitTime) {\n+        setProperty(OPEN_LEDGER_REREPLICATION_GRACE_PERIOD, waitTime);\n+    }\n+\n+    /**\n+     * Get the grace period which the rereplication worker to wait before\n+     * fencing and rereplicating a ledger fragment which is still being written\n+     * to, on bookie failure.\n+     */\n+    public long getOpenLedgerRereplicationGracePeriod() {\n+        return getLong(OPEN_LEDGER_REREPLICATION_GRACE_PERIOD, 30000);\n+    }\n }"},{"sha":"5c8b97274ac755970ebd3829fd3a47d32eed7e34","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":135,"deletions":86,"changes":221,"blob_url":"https://github.com/apache/bookkeeper/blob/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=420a6e5e6cab583929622d190d2cd3b360cbd102","patch":"@@ -23,6 +23,8 @@\n import java.net.InetSocketAddress;\n import java.util.List;\n import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.client.BKException;\n@@ -36,6 +38,7 @@\n import org.apache.bookkeeper.client.BKException.BKReadException;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -53,15 +56,17 @@\n public class ReplicationWorker implements Runnable {\n     private static Logger LOG = LoggerFactory\n             .getLogger(ReplicationWorker.class);\n-    private LedgerUnderreplicationManager underreplicationManager;\n+    final private LedgerUnderreplicationManager underreplicationManager;\n     private AbstractConfiguration conf;\n     private ZooKeeper zkc;\n     private volatile boolean workerRunning = false;\n-    private BookKeeperAdmin admin;\n+    final private BookKeeperAdmin admin;\n     private LedgerChecker ledgerChecker;\n     private InetSocketAddress targetBookie;\n     private BookKeeper bkc;\n     private Thread workerThread;\n+    private long openLedgerRereplicationGracePeriod;\n+    private Timer pendingReplicationTimer;\n \n     /**\n      * Replication worker for replicating the ledger fragments from\n@@ -77,7 +82,7 @@\n      *            local Bookie address.\n      */\n     public ReplicationWorker(final ZooKeeper zkc,\n-            final AbstractConfiguration conf, InetSocketAddress targetBKAddr)\n+            final ServerConfiguration conf, InetSocketAddress targetBKAddr)\n             throws CompatibilityException, KeeperException,\n             InterruptedException, IOException {\n         this.zkc = zkc;\n@@ -91,6 +96,9 @@ public ReplicationWorker(final ZooKeeper zkc,\n         this.admin = new BookKeeperAdmin(bkc);\n         this.ledgerChecker = new LedgerChecker(bkc);\n         this.workerThread = new Thread(this);\n+        this.openLedgerRereplicationGracePeriod = conf\n+                .getOpenLedgerRereplicationGracePeriod();\n+        this.pendingReplicationTimer = new Timer(\"PendingReplicationTimer\");\n     }\n \n     /** Start the replication worker */\n@@ -103,54 +111,7 @@ public void run() {\n         workerRunning = true;\n         while (workerRunning) {\n             try {\n-                long ledgerIdToReplicate = underreplicationManager\n-                        .getLedgerToRereplicate();\n-                LOG.info(\"Going to replicate the fragments of the ledger: \"\n-                        + ledgerIdToReplicate);\n-                LedgerHandle lh;\n-                try {\n-                    lh = admin.openLedgerNoRecovery(ledgerIdToReplicate);\n-                } catch (BKNoSuchLedgerExistsException e) {\n-                    // Ledger might have been deleted by user\n-                    LOG.info(\"BKNoSuchLedgerExistsException while opening \"\n-                            + \"ledger for replication. Other clients \"\n-                            + \"might have deleted the ledger. \"\n-                            + \"So, no harm to continue\");\n-                    underreplicationManager\n-                            .markLedgerReplicated(ledgerIdToReplicate);\n-                    continue;\n-                } catch (BKReadException e) {\n-                    LOG.info(\"BKReadException while\"\n-                            + \" opening ledger for replication.\"\n-                            + \" Enough Bookies might not have available\"\n-                            + \"So, no harm to continue\");\n-                    underreplicationManager\n-                            .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n-                    continue;\n-                } catch (BKBookieHandleNotAvailableException e) {\n-                    LOG.info(\"BKBookieHandleNotAvailableException while\"\n-                            + \" opening ledger for replication.\"\n-                            + \" Enough Bookies might not have available\"\n-                            + \"So, no harm to continue\");\n-                    underreplicationManager\n-                            .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n-                    continue;\n-                }\n-\n-                boolean isAllFragmentsReplicated = doReplicateFragments(\n-                        ledgerIdToReplicate, lh);\n-                if (!isAllFragmentsReplicated) {\n-                    // Releasing the underReplication ledger lock and compete\n-                    // for the replication again for the pending fragments\n-                    underreplicationManager\n-                            .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n-                    continue;\n-                }\n-\n-                LOG.info(\"Ledger replicated successfully. ledger id is: \"\n-                        + ledgerIdToReplicate);\n-                underreplicationManager\n-                        .markLedgerReplicated(ledgerIdToReplicate);\n+                rereplicate();\n             } catch (InterruptedException e) {\n                 shutdown();\n                 Thread.currentThread().interrupt();\n@@ -173,65 +134,152 @@ public void run() {\n     /**\n      * Replicates the under replicated fragments from failed bookie ledger to\n      * targetBookie\n-     * \n-     * @return - false if the re-replication fails for any fragment. Also\n-     *         returns false if fragment ensemble contains the target bookie\n-     *         (since target bookie already present in the current fragment\n-     *         ensemble, it will skip replication for that particular\n-     *         fragments). Returns true if all fragments replicated\n-     *         successfully.\n-     * @throws BKException \n      */\n-    private boolean doReplicateFragments(long ledgerIdToReplicate,\n-            LedgerHandle lh) throws InterruptedException, BKException {\n-        CheckerCallback checkerCb = new CheckerCallback();\n-        ledgerChecker.checkLedger(lh, checkerCb);\n-        Set<LedgerFragment> fragments = checkerCb.waitAndGetResult();\n+    private void rereplicate() throws InterruptedException, BKException,\n+            UnavailableException {\n+        long ledgerIdToReplicate = underreplicationManager\n+                .getLedgerToRereplicate();\n+        LOG.info(\"Going to replicate the fragments of the ledger: \"\n+                + ledgerIdToReplicate);\n+        LedgerHandle lh;\n+        try {\n+            lh = admin.openLedgerNoRecovery(ledgerIdToReplicate);\n+        } catch (BKNoSuchLedgerExistsException e) {\n+            // Ledger might have been deleted by user\n+            LOG.info(\"BKNoSuchLedgerExistsException while opening \"\n+                    + \"ledger for replication. Other clients \"\n+                    + \"might have deleted the ledger. \"\n+                    + \"So, no harm to continue\");\n+            underreplicationManager.markLedgerReplicated(ledgerIdToReplicate);\n+            return;\n+        } catch (BKReadException e) {\n+            LOG.info(\"BKReadException while\"\n+                    + \" opening ledger for replication.\"\n+                    + \" Enough Bookies might not have available\"\n+                    + \"So, no harm to continue\");\n+            underreplicationManager\n+                    .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n+            return;\n+        } catch (BKBookieHandleNotAvailableException e) {\n+            LOG.info(\"BKBookieHandleNotAvailableException while\"\n+                    + \" opening ledger for replication.\"\n+                    + \" Enough Bookies might not have available\"\n+                    + \"So, no harm to continue\");\n+            underreplicationManager\n+                    .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n+            return;\n+        }\n+        Set<LedgerFragment> fragments = getUnderreplicatedFragments(lh);\n         LOG.info(\"Founds fragments \" + fragments\n                 + \" for replication from ledger: \" + ledgerIdToReplicate);\n-        boolean isTargetBookieExistsInFragmentEnsemble = false;\n-        boolean isAllFragmentsReplicated = true;\n+\n+        boolean foundOpenFragments = false;\n         for (LedgerFragment ledgerFragment : fragments) {\n-            if (isTargetBookieExistsInFragmentEnsemble(lh, ledgerFragment)) {\n+            if (!ledgerFragment.isClosed()) {\n+                foundOpenFragments = true;\n+                continue;\n+            } else if (isTargetBookieExistsInFragmentEnsemble(lh,\n+                    ledgerFragment)) {\n                 LOG.info(\"Target Bookie[\" + targetBookie\n                         + \"] found in the fragment ensemble:\"\n                         + ledgerFragment.getEnsemble());\n-                isTargetBookieExistsInFragmentEnsemble = true;\n                 continue;\n             }\n             try {\n                 admin.replicateLedgerFragment(lh, ledgerFragment, targetBookie);\n             } catch (BKException.BKBookieHandleNotAvailableException e) {\n                 LOG.warn(\"BKBookieHandleNotAvailableException \"\n                         + \"while replicating the fragment\", e);\n-                isAllFragmentsReplicated = false;\n             } catch (BKException.BKLedgerRecoveryException e) {\n                 LOG.warn(\"BKLedgerRecoveryException \"\n                         + \"while replicating the fragment\", e);\n-                isAllFragmentsReplicated = false;\n             }\n-\n-        }\n-        if (isTargetBookieExistsInFragmentEnsemble) {\n-            LOG.info(\"Releasing the lock, as target Bookie found\"\n-                    + \" in the fragments ensemble.\");\n-            return false;\n         }\n \n-        // There might be some connectivity issues while replicating,\n-        // so, still I am eligible to replicate it, lets retry.\n-        if (!isAllFragmentsReplicated) {\n-            LOG.info(\"Could not replicate all fragments.\"\n-                    + \"So, Releasing the lock. Let's compete \"\n-                    + \"for the replication again\");\n-            return false;\n+        if (foundOpenFragments) {\n+            deferLedgerLockRelease(ledgerIdToReplicate);\n+            return;\n         }\n+        \n+        fragments = getUnderreplicatedFragments(lh);\n+        if (fragments.size() == 0) {\n+            LOG.info(\"Ledger replicated successfully. ledger id is: \"\n+                    + ledgerIdToReplicate);\n+            underreplicationManager.markLedgerReplicated(ledgerIdToReplicate);\n+        } else {\n+            // Releasing the underReplication ledger lock and compete\n+            // for the replication again for the pending fragments\n+            underreplicationManager\n+                    .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n+        }\n+    }\n \n-        // Re-replication success\n-        return true;\n-\n+    /** Gets the under replicated fragments */\n+    private Set<LedgerFragment> getUnderreplicatedFragments(LedgerHandle lh)\n+            throws InterruptedException {\n+        CheckerCallback checkerCb = new CheckerCallback();\n+        ledgerChecker.checkLedger(lh, checkerCb);\n+        Set<LedgerFragment> fragments = checkerCb.waitAndGetResult();\n+        return fragments;\n     }\n \n+    /**\n+     * Schedules a timer task for releasing the lock which will be scheduled\n+     * after open ledger fragment replication time. Ledger will be fenced if it\n+     * is still in open state when timer task fired\n+     */\n+    private void deferLedgerLockRelease(final long ledgerId) {\n+        long gracePeriod = this.openLedgerRereplicationGracePeriod;\n+        TimerTask timerTask = new TimerTask() {\n+            @Override\n+            public void run() {\n+                LedgerHandle lh = null;\n+                try {\n+                    lh = admin.openLedgerNoRecovery(ledgerId);\n+                    Set<LedgerFragment> fragments = getUnderreplicatedFragments(lh);\n+                    for (LedgerFragment fragment : fragments) {\n+                        if (!fragment.isClosed()) {\n+                            lh = admin.openLedger(ledgerId);\n+                            break;\n+                        }\n+                    }\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    LOG.info(\"InterruptedException \"\n+                            + \"while replicating fragments\", e);\n+                } catch (BKException e) {\n+                    LOG.error(\"BKException while fencing the ledger\"\n+                            + \" for rereplication of postponed ledgers\", e);\n+                } finally {\n+                    try {\n+                        if (lh != null) {\n+                            lh.close();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        LOG.info(\"InterruptedException while closing \"\n+                                + \"ledger\", e);\n+                    } catch (BKException e) {\n+                        // Lets go ahead and release the lock. Catch actual\n+                        // exception in normal replication flow and take\n+                        // action.\n+                        LOG.warn(\"BKException while closing ledger \", e);\n+                    } finally {\n+                        try {\n+                            underreplicationManager\n+                                    .releaseUnderreplicatedLedger(ledgerId);\n+                        } catch (UnavailableException e) {\n+                            shutdown();\n+                            LOG.error(\"UnavailableException \"\n+                                    + \"while replicating fragments\", e);\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+        pendingReplicationTimer.schedule(timerTask, gracePeriod);\n+    }\n+    \n     /**\n      * Stop the replication worker service\n      */\n@@ -243,6 +291,7 @@ public void shutdown() {\n             LOG.warn(\"Exception while closing the \"\n                     + \"ZkLedgerUnderrepliationManager\", e);\n         }\n+        this.pendingReplicationTimer.cancel();\n         try {\n             bkc.close();\n         } catch (InterruptedException e) {"},{"sha":"93ce472a60a99a5dbf4cddd9bfc0a95a4737d2a3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java?ref=420a6e5e6cab583929622d190d2cd3b360cbd102","patch":"@@ -27,4 +27,10 @@ public static ChannelBuffer generatePacket(long ledgerId, long entryId, long las\n         return dm.computeDigestAndPackageForSending(entryId, lastAddConfirmed, length,\n                                                     data, 0, data.length);\n     }\n+    \n+    /** Returns that whether ledger is in open state */\n+    public static boolean isLedgerOpen(LedgerHandle handle) {\n+        return !handle.metadata.isClosed();\n+    }\n+\n }\n\\ No newline at end of file"},{"sha":"f84c403b1e8223c0ae20fcfcef6830ab846a7a71","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":135,"deletions":25,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/420a6e5e6cab583929622d190d2cd3b360cbd102/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=420a6e5e6cab583929622d190d2cd3b360cbd102","patch":"@@ -29,6 +29,7 @@\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.ClientUtil;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerHandleAdapter;\n@@ -50,11 +51,13 @@\n  */\n public class TestReplicationWorker extends MultiLedgerManagerTestCase {\n \n+    private static final byte[] TESTPASSWD = \"testpasswd\".getBytes();\n     private static final Logger LOG = LoggerFactory\n             .getLogger(TestReplicationWorker.class);\n     private String basePath = \"\";\n     private LedgerManagerFactory mFactory;\n     private LedgerUnderreplicationManager underReplicationManager;\n+    private static byte[] data = \"TestReplicationWorker\".getBytes();\n \n     public TestReplicationWorker(String ledgerManagerFactory) {\n         super(3);\n@@ -96,9 +99,8 @@ public void tearDown() throws Exception {\n      */\n     @Test(timeout = 30000)\n     public void testRWShouldReplicateFragmentsToTargetBookie() throws Exception {\n-        byte[] data = \"TestReplicationWorker\".getBytes();\n         LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+                TESTPASSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -118,8 +120,7 @@ public void testRWShouldReplicateFragmentsToTargetBookie() throws Exception {\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n-        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n-                newBkAddr);\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n \n         rw.start();\n         try {\n@@ -147,9 +148,8 @@ public void testRWShouldReplicateFragmentsToTargetBookie() throws Exception {\n     @Test(timeout = 60000)\n     public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication()\n             throws Exception {\n-        byte[] data = \"TestReplicationWorker\".getBytes();\n         LedgerHandle lh = bkc.createLedger(1, 1, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+                TESTPASSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -166,8 +166,7 @@ public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication()\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n         killAllBookies(lh, newBkAddr);\n-        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n-                newBkAddr);\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n \n         rw.start();\n         try {\n@@ -199,9 +198,8 @@ public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication()\n     @Test(timeout = 90000)\n     public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplication()\n             throws Exception {\n-        byte[] data = \"TestReplicationWorker\".getBytes();\n         LedgerHandle lh = bkc.createLedger(2, 2, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+                TESTPASSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -218,8 +216,7 @@ public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplicatio\n         InetSocketAddress newBkAddr1 = new InetSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie1);\n         LOG.info(\"New Bookie addr :\" + newBkAddr1);\n-        ReplicationWorker rw1 = new ReplicationWorker(zkc, baseClientConf,\n-                newBkAddr1);\n+        ReplicationWorker rw1 = new ReplicationWorker(zkc, baseConf, newBkAddr1);\n \n         // Starte RW2\n         int startNewBookie2 = startNewBookie();\n@@ -228,7 +225,7 @@ public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplicatio\n         LOG.info(\"New Bookie addr :\" + newBkAddr2);\n         ZooKeeper zkc1 = ZkUtils.createConnectedZookeeperClient(\n                 zkUtil.getZooKeeperConnectString(), 10000);\n-        ReplicationWorker rw2 = new ReplicationWorker(zkc1, baseClientConf,\n+        ReplicationWorker rw2 = new ReplicationWorker(zkc1, baseConf,\n                 newBkAddr2);\n         rw1.start();\n         rw2.start();\n@@ -264,9 +261,8 @@ public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplicatio\n     @Test(timeout = 3000)\n     public void testRWShouldCleanTheLedgerFromUnderReplicationIfLedgerAlreadyDeleted()\n             throws Exception {\n-        byte[] data = \"TestReplicationWorker\".getBytes();\n         LedgerHandle lh = bkc.createLedger(2, 2, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+                TESTPASSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -281,8 +277,7 @@ public void testRWShouldCleanTheLedgerFromUnderReplicationIfLedgerAlreadyDeleted\n         InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n-        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n-                newBkAddr);\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n         rw.start();\n \n         try {\n@@ -302,12 +297,9 @@ public void testRWShouldCleanTheLedgerFromUnderReplicationIfLedgerAlreadyDeleted\n     @Test(timeout = 60000)\n     public void testMultipleLedgerReplicationWithReplicationWorker()\n             throws Exception {\n-\n-        byte[] data = \"TestReplicationWorker\".getBytes();\n-\n         // Ledger1\n         LedgerHandle lh1 = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+                TESTPASSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh1.addEntry(data);\n@@ -319,7 +311,7 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n \n         // Ledger2\n         LedgerHandle lh2 = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+                TESTPASSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh2.addEntry(data);\n@@ -342,8 +334,7 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n-        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n-                newBkAddr);\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n \n         rw.start();\n         try {\n@@ -372,6 +363,125 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n         }\n \n     }\n+    \n+    /**\n+     * Tests that ReplicationWorker should fence the ledger and release ledger\n+     * lock after timeout. Then replication should happen normally.\n+     */\n+    @Test(timeout = 60000)\n+    public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsUR()\n+            throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                TESTPASSWD);\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        killBookie(replicaToKill);\n+\n+        int startNewBookie = startNewBookie();\n+\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+        rw.start();\n+        try {\n+\n+            underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n+                    replicaToKill.toString());\n+            while (isLedgerInUnderReplication(lh.getId(),\n+                    basePath)) {\n+                Thread.sleep(100);\n+            }\n+            killAllBookies(lh, newBkAddr);\n+            // Should be able to read the entries from 0-9\n+            verifyRecoveredLedgers(lh, 0, 9);\n+            lh = bkc.openLedgerNoRecovery(lh.getId(),\n+                    BookKeeper.DigestType.CRC32, TESTPASSWD);\n+            assertFalse(\"Ledger must have been closed by RW\", ClientUtil\n+                    .isLedgerOpen(lh));\n+        } finally {\n+            rw.shutdown();\n+            underReplicationManager.close();\n+        }\n+\n+    }\n+\n+    /**\n+     * Tests that ReplicationWorker should not have identified for postponing\n+     * the replication if ledger is in open state and lastFragment is not in\n+     * underReplication state. Note that RW should not fence such ledgers.\n+     */\n+    @Test(timeout = 30000)\n+    public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsNotUR()\n+            throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                TESTPASSWD);\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        killBookie(replicaToKill);\n+\n+        int startNewBookie = startNewBookie();\n+\n+        // Reform ensemble...Making sure that last fragment is not in\n+        // under-replication\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+\n+        rw.start();\n+        try {\n+\n+            underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n+                    replicaToKill.toString());\n+            while (isLedgerInUnderReplication(lh.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+\n+            killAllBookies(lh, newBkAddr);\n+\n+            // Should be able to read the entries from 0-9\n+            verifyRecoveredLedgers(lh, 0, 9);\n+            lh = bkc.openLedgerNoRecovery(lh.getId(),\n+                    BookKeeper.DigestType.CRC32, TESTPASSWD);\n+\n+            // Ledger should be still in open state\n+            assertTrue(\"Ledger must have been closed by RW\", ClientUtil\n+                    .isLedgerOpen(lh));\n+        } finally {\n+            rw.shutdown();\n+            underReplicationManager.close();\n+        }\n+\n+    }\n \n     private void killAllBookies(LedgerHandle lh, InetSocketAddress excludeBK)\n             throws InterruptedException {\n@@ -411,7 +521,7 @@ private boolean isLedgerInUnderReplication(long id, String basePath)\n     private void verifyRecoveredLedgers(LedgerHandle lh, long startEntryId,\n             long endEntryId) throws BKException, InterruptedException {\n         LedgerHandle lhs = bkc.openLedgerNoRecovery(lh.getId(),\n-                BookKeeper.DigestType.CRC32, \"testpasswd\".getBytes());\n+                BookKeeper.DigestType.CRC32, TESTPASSWD);\n         Enumeration<LedgerEntry> entries = lhs.readEntries(startEntryId,\n                 endEntryId);\n         assertTrue(\"Should have the elements\", entries.hasMoreElements());"}]}

