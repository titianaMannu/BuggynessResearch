{"sha":"4250c1f93962af30e6e40759e006035a7089613e","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0MjUwYzFmOTM5NjJhZjMwZTZlNDA3NTllMDA2MDM1YTcwODk2MTNl","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-01-10T18:13:58Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-01-10T18:13:58Z"},"message":"BOOKKEEPER-538: Race condition in BookKeeper#close (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1431536 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"07a4a2b1800333def202a1206992fb634a7ddceb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/07a4a2b1800333def202a1206992fb634a7ddceb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4250c1f93962af30e6e40759e006035a7089613e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4250c1f93962af30e6e40759e006035a7089613e","html_url":"https://github.com/apache/bookkeeper/commit/4250c1f93962af30e6e40759e006035a7089613e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4250c1f93962af30e6e40759e006035a7089613e/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"7c1793d2979b01062682b70687839a978bf65c4c","url":"https://api.github.com/repos/apache/bookkeeper/commits/7c1793d2979b01062682b70687839a978bf65c4c","html_url":"https://github.com/apache/bookkeeper/commit/7c1793d2979b01062682b70687839a978bf65c4c"}],"stats":{"total":210,"additions":166,"deletions":44},"files":[{"sha":"41e1cdab40f90b80c0469ac41e569608a24f748f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -170,6 +170,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-530: data might be lost during compaction. (ivank)\n \n+\tBOOKKEEPER-538: Race condition in BookKeeper#close (ivank via fpj)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"630ea6ca5cc95d5b47a0a37eeaa3b2a439a861b9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":11,"deletions":2,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -24,6 +24,7 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n@@ -560,21 +561,29 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n      *\n      */\n     public void close() throws InterruptedException, BKException {\n+        scheduler.shutdown();\n+        if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {\n+            LOG.warn(\"The scheduler did not shutdown cleanly\");\n+        }\n+        mainWorkerPool.shutdown();\n+        if (!mainWorkerPool.awaitTermination(10, TimeUnit.SECONDS)) {\n+            LOG.warn(\"The mainWorkerPool did not shutdown cleanly\");\n+        }\n+\n         bookieClient.close();\n         try {\n             ledgerManager.close();\n             ledgerManagerFactory.uninitialize();\n         } catch (IOException ie) {\n             LOG.error(\"Failed to close ledger manager : \", ie);\n         }\n-        scheduler.shutdown();\n+\n         if (ownChannelFactory) {\n             channelFactory.releaseExternalResources();\n         }\n         if (ownZKHandle) {\n             zk.close();\n         }\n-        mainWorkerPool.shutdown();\n     }\n \n     private static class SyncCreateCallback implements CreateCallback {"},{"sha":"13a69c186915fb24ff4facb1681ccdc24c8c6217","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":41,"deletions":7,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -42,6 +42,7 @@\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n  * Implements the client-side part of the BookKeeper protocol.\n@@ -58,21 +59,33 @@\n     ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient> channels = new ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient>();\n \n     private final ClientConfiguration conf;\n+    private volatile boolean closed;\n+    private ReentrantReadWriteLock closeLock;\n \n     public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n         this.conf = conf;\n         this.channelFactory = channelFactory;\n         this.executor = executor;\n+        this.closed = false;\n+        this.closeLock = new ReentrantReadWriteLock();\n     }\n \n     public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n         PerChannelBookieClient channel = channels.get(addr);\n \n         if (channel == null) {\n-            channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding);\n-            PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n-            if (prevChannel != null) {\n-                channel = prevChannel;\n+            closeLock.readLock().lock();\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding);\n+                PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n+                if (prevChannel != null) {\n+                    channel = prevChannel;\n+                }\n+            } finally {\n+                closeLock.readLock().unlock();\n             }\n         }\n \n@@ -95,7 +108,7 @@ public void closeClients(Set<InetSocketAddress> addrs) {\n                 @Override\n                 public void safeRun() {\n                     for (PerChannelBookieClient c : clients) {\n-                        c.close();\n+                        c.disconnect();\n                     }\n                 }\n             });\n@@ -104,6 +117,11 @@ public void safeRun() {\n     public void addEntry(final InetSocketAddress addr, final long ledgerId, final byte[] masterKey, final long entryId,\n             final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n         final PerChannelBookieClient client = lookupClient(addr);\n+        if (client == null) {\n+            cb.writeComplete(BKException.Code.BookieHandleNotAvailableException,\n+                             ledgerId, entryId, addr, ctx);\n+            return;\n+        }\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n             @Override\n@@ -129,6 +147,11 @@ public void readEntryAndFenceLedger(final InetSocketAddress addr,\n                                         final ReadEntryCallback cb,\n                                         final Object ctx) {\n         final PerChannelBookieClient client = lookupClient(addr);\n+        if (client == null) {\n+            cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n+                                 ledgerId, entryId, null, ctx);\n+            return;\n+        }\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n             @Override\n@@ -150,6 +173,11 @@ public void safeRun() {\n     public void readEntry(final InetSocketAddress addr, final long ledgerId, final long entryId,\n                           final ReadEntryCallback cb, final Object ctx) {\n         final PerChannelBookieClient client = lookupClient(addr);\n+        if (client == null) {\n+            cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n+                                 ledgerId, entryId, null, ctx);\n+            return;\n+        }\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n             @Override\n@@ -169,8 +197,14 @@ public void safeRun() {\n     }\n \n     public void close() {\n-        for (PerChannelBookieClient channel: channels.values()) {\n-            channel.close();\n+        closeLock.writeLock().lock();\n+        try {\n+            closed = true;\n+            for (PerChannelBookieClient channel: channels.values()) {\n+                channel.close();\n+            }\n+        } finally {\n+            closeLock.writeLock().unlock();\n         }\n     }\n "},{"sha":"296401c3147547b01620459d1cde7edf7ff9db3a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":43,"deletions":13,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -91,7 +91,7 @@\n     volatile Channel channel = null;\n \n     private enum ConnectionState {\n-        DISCONNECTED, CONNECTING, CONNECTED\n+        DISCONNECTED, CONNECTING, CONNECTED, CLOSED\n             };\n \n     private volatile ConnectionState state;\n@@ -138,7 +138,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         rc = BKException.Code.OK;\n                         channel = future.getChannel();\n                         state = ConnectionState.CONNECTED;\n-                    } else if (future.isSuccess() && state == ConnectionState.DISCONNECTED) {\n+                    } else if (future.isSuccess() && (state == ConnectionState.CLOSED\n+                                                      || state == ConnectionState.DISCONNECTED)) {\n                         LOG.error(\"Closed before connection completed, clean up: \" + addr);\n                         future.getChannel().close();\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n@@ -147,7 +148,9 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         LOG.error(\"Could not connect to bookie: \" + addr);\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n                         channel = null;\n-                        state = ConnectionState.DISCONNECTED;\n+                        if (state != ConnectionState.CLOSED) {\n+                            state = ConnectionState.DISCONNECTED;\n+                        }\n                     }\n \n                     // trick to not do operations under the lock, take the list\n@@ -166,17 +169,21 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n-        boolean doOpNow = false;\n-\n+        boolean completeOpNow = false;\n+        int opRc = BKException.Code.OK;\n         // common case without lock first\n         if (channel != null && state == ConnectionState.CONNECTED) {\n-            doOpNow = true;\n+            completeOpNow = true;\n         } else {\n \n             synchronized (this) {\n                 // check the channel status again under lock\n                 if (channel != null && state == ConnectionState.CONNECTED) {\n-                    doOpNow = true;\n+                    completeOpNow = true;\n+                    opRc = BKException.Code.OK;\n+                } else if (state == ConnectionState.CLOSED) {\n+                    completeOpNow = true;\n+                    opRc = BKException.Code.BookieHandleNotAvailableException;\n                 } else {\n                     // channel is either null (first connection attempt), or the\n                     // channel is disconnected. Connection attempt is still in\n@@ -193,14 +200,14 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n                     state = ConnectionState.CONNECTING;\n                 }\n             }\n-            if (!doOpNow) {\n+            if (!completeOpNow) {\n                 // Start connection attempt to the input server host.\n                 connect();\n             }\n         }\n \n-        if (doOpNow) {\n-            op.operationComplete(BKException.Code.OK, null);\n+        if (completeOpNow) {\n+            op.operationComplete(opRc, null);\n         }\n \n     }\n@@ -337,9 +344,27 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         }\n     }\n \n+    /**\n+     * Disconnects the bookie client. It can be reused.\n+     */\n+    public void disconnect() {\n+        closeInternal(false);\n+    }\n+\n+    /**\n+     * Closes the bookie client permanently. It cannot be reused.\n+     */\n     public void close() {\n+        closeInternal(true);\n+    }\n+\n+    private void closeInternal(boolean permanent) {\n         synchronized (this) {\n-            state = ConnectionState.DISCONNECTED;\n+            if (permanent) {\n+                state = ConnectionState.CLOSED;\n+            } else if (state != ConnectionState.CLOSED) {\n+                state = ConnectionState.DISCONNECTED;\n+            }\n         }\n         if (channel != null) {\n             channel.close().awaitUninterruptibly();\n@@ -446,9 +471,14 @@ public ChannelPipeline getPipeline() throws Exception {\n     public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n         LOG.info(\"Disconnected from bookie: \" + addr);\n         errorOutOutstandingEntries();\n-        channel.close();\n+        Channel c = this.channel;\n+        if (c != null) {\n+            c.close();\n+        }\n         synchronized (this) {\n-            state = ConnectionState.DISCONNECTED;\n+            if (state != ConnectionState.CLOSED) {\n+                state = ConnectionState.DISCONNECTED;\n+            }\n         }\n \n         // we don't want to reconnect right away. If someone sends a request to"},{"sha":"ffaced963d7d1ffccd5d0e5d4f6f3eb9cfd89b33","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -22,6 +22,7 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n \n@@ -97,6 +98,14 @@ public void shutdown() {\n         }\n     }\n \n+    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+        boolean ret = true;\n+        for (int i = 0; i < threads.length; i++) {\n+            ret = ret && threads[i].awaitTermination(timeout, unit);\n+        }\n+        return ret;\n+    }\n+\n     /**\n      * Generic callback implementation which will run the\n      * callback in the thread which matches the ordering key"},{"sha":"c66abd37d32a1275226eeb084b8aeabdba5df240","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"modified","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -22,7 +22,9 @@\n */\n \n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n@@ -177,4 +179,43 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         Assert.assertTrue(result.get() != 0);\n     }\n \n+    /**\n+     * Test that bookkeeper will close cleanly if close is issued\n+     * while another operation is in progress.\n+     */\n+    @Test(timeout=60000)\n+    public void testCloseDuringOp() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString());\n+        for (int i = 0; i < 100; i++) {\n+            final BookKeeper client = new BookKeeper(conf);\n+            final CountDownLatch l = new CountDownLatch(1);\n+            final AtomicBoolean success = new AtomicBoolean(false);\n+            Thread t = new Thread() {\n+                    public void run() {\n+                        try {\n+                            LedgerHandle lh = client.createLedger(3, 3, digestType, \"testPasswd\".getBytes());\n+                            startNewBookie();\n+                            killBookie(0);\n+                            lh.asyncAddEntry(\"test\".getBytes(), new AddCallback() {\n+                                    @Override\n+                                    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                                        // noop, we don't care if this completes\n+                                    }\n+                                }, null);\n+                            client.close();\n+                            success.set(true);\n+                            l.countDown();\n+                        } catch (Exception e) {\n+                            LOG.error(\"Error running test\", e);\n+                            success.set(false);\n+                            l.countDown();\n+                        }\n+                    }\n+                };\n+            t.start();\n+            assertTrue(\"Close never completed\", l.await(10, TimeUnit.SECONDS));\n+            assertTrue(\"Close was not successful\", success.get());\n+        }\n+    }\n }"},{"sha":"3e46c8ba72cd848462876026f5a9658e36f2736d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","status":"modified","additions":19,"deletions":22,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/4250c1f93962af30e6e40759e006035a7089613e/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java?ref=4250c1f93962af30e6e40759e006035a7089613e","patch":"@@ -233,11 +233,6 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n                     throws IOException, NoLedgerException {\n                 // we want to disable during checking\n                 numReads.incrementAndGet();\n-                try {\n-                    underReplicationManager.disableLedgerReplication();\n-                } catch (ReplicationException.UnavailableException ue) {\n-                    LOG.error(\"Couldn't disable ledger replication\", ue);\n-                }\n                 throw new IOException(\"Fake I/O exception\");\n             }\n         };\n@@ -247,30 +242,32 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n         Thread.sleep(CHECK_INTERVAL * 2);\n         assertEquals(\"Nothing should have tried to read\", 0, numReads.get());\n         underReplicationManager.enableLedgerReplication();\n+        Thread.sleep(CHECK_INTERVAL * 2); // give it time to run\n+\n+        underReplicationManager.disableLedgerReplication();\n+        // give it time to stop, from this point nothing new should be marked\n+        Thread.sleep(CHECK_INTERVAL * 2);\n \n         int numUnderreplicated = 0;\n         long underReplicatedLedger = -1;\n-        for (int i = 0; i < 10; i++) {\n-            underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n-            if (underReplicatedLedger != -1) {\n-                break;\n-            }\n-            Thread.sleep(CHECK_INTERVAL);\n-        }\n-        assertTrue(\"Some ledger should be under replicated\", -1 != underReplicatedLedger);\n-        numUnderreplicated++;\n-        underReplicationManager.markLedgerReplicated(underReplicatedLedger);\n-        while (underReplicatedLedger != -1) {\n+        do {\n             underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n             if (underReplicatedLedger == -1) {\n                 break;\n-            } else {\n-                numUnderreplicated++;\n             }\n+            numUnderreplicated++;\n+\n             underReplicationManager.markLedgerReplicated(underReplicatedLedger);\n-        }\n-        LOG.info(\"{} of {} ledgers underreplicated\", numUnderreplicated, numLedgers);\n-        assertTrue(\"Some but not all should be underreplicated\",\n-                   numUnderreplicated > 0 && numUnderreplicated < numLedgers);\n+        } while (underReplicatedLedger != -1);\n+\n+        Thread.sleep(CHECK_INTERVAL * 2); // give a chance to run again (it shouldn't, it's disabled)\n+\n+        // ensure that nothing is marked as underreplicated\n+        underReplicatedLedger = underReplicationManager.pollLedgerToRereplicate();\n+        assertEquals(\"There should be no underreplicated ledgers\", -1, underReplicatedLedger);\n+\n+        LOG.info(\"{} of {} ledgers underreplicated\", numUnderreplicated, numUnderreplicated);\n+        assertTrue(\"All should be underreplicated\",\n+                numUnderreplicated <= numLedgers && numUnderreplicated > 0);\n     }\n }"}]}

