{"sha":"496f442a7a68dd549355e845540c6c72c2fbb44c","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0OTZmNDQyYTdhNjhkZDU0OTM1NWU4NDU1NDBjNmM3MmMyZmJiNDRj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-13T12:07:52Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-13T12:07:52Z"},"message":"BOOKKEEPER-336: bookie readEntries is taking more time if the ensemble has failed bookie(s) (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1421242 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"97c5c6ee11870b9dc00a6d5cf64c1556f6eb418b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/97c5c6ee11870b9dc00a6d5cf64c1556f6eb418b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/496f442a7a68dd549355e845540c6c72c2fbb44c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/496f442a7a68dd549355e845540c6c72c2fbb44c","html_url":"https://github.com/apache/bookkeeper/commit/496f442a7a68dd549355e845540c6c72c2fbb44c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/496f442a7a68dd549355e845540c6c72c2fbb44c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d58a71dbd1f07a3edf65c4af80ae18a4d9a95755","url":"https://api.github.com/repos/apache/bookkeeper/commits/d58a71dbd1f07a3edf65c4af80ae18a4d9a95755","html_url":"https://github.com/apache/bookkeeper/commit/d58a71dbd1f07a3edf65c4af80ae18a4d9a95755"}],"stats":{"total":561,"additions":529,"deletions":32},"files":[{"sha":"f8b142318620e46f398f21426d7bd24e85473656","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -138,6 +138,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-365: Ledger will never recover if one of the quorum bookie is down forever and others dont have entry (sijie via ivank)\n \n+        BOOKKEEPER-336: bookie readEntries is taking more time if the ensemble has failed bookie(s) (ivank)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"20fb2e01a44a7b9553979f9d125563c18e08f27e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -23,6 +23,7 @@\n import java.io.IOException;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n \n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n@@ -75,6 +76,7 @@\n     final BookieWatcher bookieWatcher;\n \n     final OrderedSafeExecutor mainWorkerPool;\n+    final ScheduledExecutorService scheduler;\n \n     // Ledger manager responsible for how to store ledger meta data\n     final LedgerManagerFactory ledgerManagerFactory;\n@@ -125,9 +127,11 @@ public BookKeeper(final ClientConfiguration conf)\n \n         this.channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n                                                                 Executors.newCachedThreadPool());\n+        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+\n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n-        bookieWatcher = new BookieWatcher(conf, this);\n+        bookieWatcher = new BookieWatcher(conf, scheduler, this);\n         bookieWatcher.readBookiesBlocking();\n \n         ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n@@ -187,10 +191,11 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n         this.conf = conf;\n         this.zk = zk;\n         this.channelFactory = channelFactory;\n+        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n \n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n-        bookieWatcher = new BookieWatcher(conf, this);\n+        bookieWatcher = new BookieWatcher(conf, scheduler, this);\n         bookieWatcher.readBookiesBlocking();\n \n         ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n@@ -562,7 +567,7 @@ public void close() throws InterruptedException, BKException {\n         } catch (IOException ie) {\n             LOG.error(\"Failed to close ledger manager : \", ie);\n         }\n-        bookieWatcher.halt();\n+        scheduler.shutdown();\n         if (ownChannelFactory) {\n             channelFactory.releaseExternalResources();\n         }"},{"sha":"3ac082cde504554fe1fd77e1a4eebab54308c073","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":7,"deletions":9,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -25,7 +25,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n-import java.util.concurrent.Executors;\n+\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n@@ -61,10 +61,10 @@\n     static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n     public static int ZK_CONNECT_BACKOFF_SEC = 1;\n \n-    BookKeeper bk;\n-    ScheduledExecutorService scheduler;\n+    final BookKeeper bk;\n \n     HashSet<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n+    final ScheduledExecutorService scheduler;\n \n     SafeRunnable reReadTask = new SafeRunnable() {\n         @Override\n@@ -74,18 +74,16 @@ public void safeRun() {\n     };\n     private ReadOnlyBookieWatcher readOnlyBookieWatcher;\n \n-    public BookieWatcher(ClientConfiguration conf, BookKeeper bk) throws KeeperException, InterruptedException {\n+    public BookieWatcher(ClientConfiguration conf,\n+                         ScheduledExecutorService scheduler,\n+                         BookKeeper bk) throws KeeperException, InterruptedException  {\n         this.bk = bk;\n         // ZK bookie registration path\n         this.bookieRegistrationPath = conf.getZkAvailableBookiesPath();\n-        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+        this.scheduler = scheduler;\n         readOnlyBookieWatcher = new ReadOnlyBookieWatcher(conf, bk);\n     }\n \n-    public void halt() {\n-        scheduler.shutdown();\n-    }\n-\n     public void readBookies() {\n         readBookies(this);\n     }"},{"sha":"2e9ccfb9264de75cd0e0e6b901b850a9c657dcca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -382,7 +382,8 @@ public void asyncReadEntries(long firstEntry, long lastEntry,\n         }\n \n         try {\n-            new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();\n+            new PendingReadOp(this, bk.scheduler,\n+                              firstEntry, lastEntry, cb, ctx).initiate();\n         } catch (InterruptedException e) {\n             cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);\n         }"},{"sha":"7e1bb8f667e4309503845636e8c110bf594593e0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":139,"deletions":17,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -21,11 +21,19 @@\n  *\n  */\n import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.NoSuchElementException;\n import java.util.Queue;\n+import java.util.BitSet;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.List;\n+\n import java.util.concurrent.atomic.AtomicBoolean;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n@@ -45,7 +53,11 @@\n class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     Logger LOG = LoggerFactory.getLogger(PendingReadOp.class);\n \n+    final int speculativeReadTimeout;\n+    final private ScheduledExecutorService scheduler;\n+    private ScheduledFuture<?> speculativeTask = null;\n     Queue<LedgerEntryRequest> seq;\n+    Set<InetSocketAddress> heardFromHosts;\n     ReadCallback cb;\n     Object ctx;\n     LedgerHandle lh;\n@@ -54,22 +66,86 @@\n     long endEntryId;\n     final int maxMissedReadsAllowed;\n \n-    private class LedgerEntryRequest extends LedgerEntry {\n+    class LedgerEntryRequest extends LedgerEntry {\n+        final static int NOT_FOUND = -1;\n         int nextReplicaIndexToReadFrom = 0;\n         AtomicBoolean complete = new AtomicBoolean(false);\n \n         int firstError = BKException.Code.OK;\n         int numMissedEntryReads = 0;\n \n         final ArrayList<InetSocketAddress> ensemble;\n+        final List<Integer> writeSet;\n+        final BitSet sentReplicas;\n+        final BitSet erroredReplicas;\n \n         LedgerEntryRequest(ArrayList<InetSocketAddress> ensemble, long lId, long eId) {\n             super(lId, eId);\n \n             this.ensemble = ensemble;\n+            this.writeSet = lh.distributionSchedule.getWriteSet(entryId);\n+            this.sentReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n+            this.erroredReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n+        }\n+\n+        private int getReplicaIndex(InetSocketAddress host) {\n+            int bookieIndex = ensemble.indexOf(host);\n+            if (bookieIndex == -1) {\n+                return NOT_FOUND;\n+            }\n+            return writeSet.indexOf(bookieIndex);\n+        }\n+\n+        private BitSet getSentToBitSet() {\n+            BitSet b = new BitSet(ensemble.size());\n+\n+            for (int i = 0; i < sentReplicas.length(); i++) {\n+                if (sentReplicas.get(i)) {\n+                    b.set(writeSet.get(i));\n+                }\n+            }\n+            return b;\n         }\n \n-        void sendNextRead() {\n+        private BitSet getHeardFromBitSet(Set<InetSocketAddress> heardFromHosts) {\n+            BitSet b = new BitSet(ensemble.size());\n+            for (InetSocketAddress i : heardFromHosts) {\n+                int index = ensemble.indexOf(i);\n+                if (index != -1) {\n+                    b.set(index);\n+                }\n+            }\n+            return b;\n+        }\n+\n+        private boolean readsOutstanding() {\n+            return (sentReplicas.cardinality() - erroredReplicas.cardinality()) > 0;\n+        }\n+\n+        /**\n+         * Send to next replica speculatively, if required and possible.\n+         * This returns the host we may have sent to for unit testing.\n+         * @return host we sent to if we sent. null otherwise.\n+         */\n+        synchronized InetSocketAddress maybeSendSpeculativeRead(Set<InetSocketAddress> heardFromHosts) {\n+            if (nextReplicaIndexToReadFrom >= lh.getLedgerMetadata().getWriteQuorumSize()) {\n+                return null;\n+            }\n+\n+            BitSet sentTo = getSentToBitSet();\n+            BitSet heardFrom = getHeardFromBitSet(heardFromHosts);\n+            sentTo.and(heardFrom);\n+\n+            // only send another read, if we have had no response at all (even for other entries)\n+            // from any of the other bookies we have sent the request to\n+            if (sentTo.cardinality() == 0) {\n+                return sendNextRead();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        synchronized InetSocketAddress sendNextRead() {\n             if (nextReplicaIndexToReadFrom >= lh.metadata.getWriteQuorumSize()) {\n                 // we are done, the read has failed from all replicas, just fail the\n                 // read\n@@ -82,22 +158,27 @@ void sendNextRead() {\n                 }\n \n                 submitCallback(firstError);\n-                return;\n+                return null;\n             }\n \n+            int replica = nextReplicaIndexToReadFrom;\n             int bookieIndex = lh.distributionSchedule.getWriteSet(entryId).get(nextReplicaIndexToReadFrom);\n             nextReplicaIndexToReadFrom++;\n \n             try {\n-                sendReadTo(ensemble.get(bookieIndex), this);\n+                InetSocketAddress to = ensemble.get(bookieIndex);\n+                sendReadTo(to, this);\n+                sentReplicas.set(replica);\n+                return to;\n             } catch (InterruptedException ie) {\n                 LOG.error(\"Interrupted reading entry \" + this, ie);\n                 Thread.currentThread().interrupt();\n                 submitCallback(BKException.Code.ReadException);\n+                return null;\n             }\n         }\n \n-        void logErrorAndReattemptRead(String errMsg, int rc) {\n+        synchronized void logErrorAndReattemptRead(InetSocketAddress host, String errMsg, int rc) {\n             if (BKException.Code.OK == firstError ||\n                 BKException.Code.NoSuchEntryException == firstError) {\n                 firstError = rc;\n@@ -113,18 +194,27 @@ void logErrorAndReattemptRead(String errMsg, int rc) {\n \n             int bookieIndex = lh.distributionSchedule.getWriteSet(entryId).get(nextReplicaIndexToReadFrom - 1);\n             LOG.error(errMsg + \" while reading entry: \" + entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n-                      + ensemble.get(bookieIndex));\n+                      + host);\n \n-            sendNextRead();\n+            int replica = getReplicaIndex(host);\n+            if (replica == NOT_FOUND) {\n+                LOG.error(\"Received error from a host which is not in the ensemble {} {}.\", host, ensemble);\n+                return;\n+            }\n+            erroredReplicas.set(replica);\n+\n+            if (!readsOutstanding()) {\n+                sendNextRead();\n+            }\n         }\n \n         // return true if we managed to complete the entry\n-        boolean complete(final ChannelBuffer buffer) {\n+        boolean complete(InetSocketAddress host, final ChannelBuffer buffer) {\n             ChannelBufferInputStream is;\n             try {\n                 is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n             } catch (BKDigestMatchException e) {\n-                logErrorAndReattemptRead(\"Mac mismatch\", BKException.Code.DigestMatchException);\n+                logErrorAndReattemptRead(host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n                 return false;\n             }\n \n@@ -151,22 +241,38 @@ public String toString() {\n         }\n     }\n \n-    PendingReadOp(LedgerHandle lh, long startEntryId, long endEntryId, ReadCallback cb, Object ctx) {\n-\n-        seq = new ArrayDeque<LedgerEntryRequest>((int) (endEntryId - startEntryId));\n+    PendingReadOp(LedgerHandle lh, ScheduledExecutorService scheduler,\n+                  long startEntryId, long endEntryId, ReadCallback cb, Object ctx) {\n+        seq = new ArrayBlockingQueue<LedgerEntryRequest>((int) ((endEntryId + 1) - startEntryId));\n         this.cb = cb;\n         this.ctx = ctx;\n         this.lh = lh;\n         this.startEntryId = startEntryId;\n         this.endEntryId = endEntryId;\n+        this.scheduler = scheduler;\n         numPendingEntries = endEntryId - startEntryId + 1;\n         maxMissedReadsAllowed = lh.metadata.getWriteQuorumSize() - lh.metadata.getAckQuorumSize();\n+        speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n+        heardFromHosts = new HashSet<InetSocketAddress>();\n     }\n \n     public void initiate() throws InterruptedException {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n \n         ArrayList<InetSocketAddress> ensemble = null;\n+\n+        if (speculativeReadTimeout > 0) {\n+            speculativeTask = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                    public void run() {\n+                        for (LedgerEntryRequest r : seq) {\n+                            if (!r.isComplete()) {\n+                                r.maybeSendSpeculativeRead(heardFromHosts);\n+                            }\n+                        }\n+                    }\n+                }, speculativeReadTimeout, speculativeReadTimeout, TimeUnit.MILLISECONDS);\n+        }\n+\n         do {\n             LOG.debug(\"Acquiring lock: {}\", i);\n \n@@ -182,25 +288,38 @@ public void initiate() throws InterruptedException {\n         } while (i <= endEntryId);\n     }\n \n+    private static class ReadContext {\n+        final InetSocketAddress to;\n+        final LedgerEntryRequest entry;\n+\n+        ReadContext(InetSocketAddress to, LedgerEntryRequest entry) {\n+            this.to = to;\n+            this.entry = entry;\n+        }\n+    }\n+\n     void sendReadTo(InetSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n         lh.opCounterSem.acquire();\n \n         lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId, \n-                                     this, entry);\n+                                     this, new ReadContext(to, entry));\n     }\n \n     @Override\n     public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n-        final LedgerEntryRequest entry = (LedgerEntryRequest) ctx;\n+        final ReadContext rctx = (ReadContext)ctx;\n+        final LedgerEntryRequest entry = rctx.entry;\n \n         lh.opCounterSem.release();\n \n         if (rc != BKException.Code.OK) {\n-            entry.logErrorAndReattemptRead(\"Error: \" + BKException.getMessage(rc), rc);\n+            entry.logErrorAndReattemptRead(rctx.to, \"Error: \" + BKException.getMessage(rc), rc);\n             return;\n         }\n \n-        if (entry.complete(buffer)) {\n+        heardFromHosts.add(rctx.to);\n+\n+        if (entry.complete(rctx.to, buffer)) {\n             numPendingEntries--;\n         }\n \n@@ -213,6 +332,9 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n     }\n \n     private void submitCallback(int code) {\n+        if (speculativeTask != null) {\n+            speculativeTask.cancel(true);\n+        }\n         cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);\n     }\n     public boolean hasMoreElements() {"},{"sha":"0a9f9ac3e40cd22e37bc6dbe69dcb85c1641cc8a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -43,6 +43,7 @@\n     // NIO Parameters\n     protected final static String CLIENT_TCP_NODELAY = \"clientTcpNoDelay\";\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n+    protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n \n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n@@ -275,4 +276,39 @@ public ClientConfiguration setNumWorkerThreads(int numThreads) {\n         setProperty(NUM_WORKER_THREADS, numThreads);\n         return this;\n     }\n+\n+    /**\n+     * Get the period of time after which a speculative entry read should be triggered.\n+     * A speculative entry read is sent to the next replica bookie before\n+     * an error or response has been received for the previous entry read request.\n+     *\n+     * A speculative entry read is only sent if we have not heard from the current\n+     * replica bookie during the entire read operation which may comprise of many entries.\n+     *\n+     * Speculative reads allow the client to avoid having to wait for the connect timeout\n+     * in the case that a bookie has failed. It induces higher load on the network and on\n+     * bookies. This should be taken into account before changing this configuration value.\n+     *\n+     * @see org.apache.bookkeeper.client.LedgerHandle#asyncReadEntries\n+     * @return the speculative read timeout in milliseconds. Default 2000.\n+     */\n+    public int getSpeculativeReadTimeout() {\n+        return getInt(SPECULATIVE_READ_TIMEOUT, 2000);\n+    }\n+\n+    /**\n+     * Set the speculative read timeout. A lower timeout will reduce read latency in the\n+     * case of a failed bookie, while increasing the load on bookies and the network.\n+     *\n+     * The default is 2000 milliseconds. A value of 0 will disable speculative reads\n+     * completely.\n+     *\n+     * @see #getSpeculativeReadTimeout()\n+     * @param timeout the timeout value, in milliseconds\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setSpeculativeReadTimeout(int timeout) {\n+        setProperty(SPECULATIVE_READ_TIMEOUT, timeout);\n+        return this;\n+    }\n }"},{"sha":"1b4ce8fb54954a06f0ea953e7315c7ad8a0f3b12","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"added","additions":333,"deletions":0,"changes":333,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -0,0 +1,333 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.junit.*;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Enumeration;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.BaseTestCase;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This unit test tests ledger fencing;\n+ *\n+ */\n+public class TestSpeculativeRead extends BaseTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(TestSpeculativeRead.class);\n+\n+    DigestType digestType;\n+    byte[] passwd = \"specPW\".getBytes();\n+\n+    public TestSpeculativeRead(DigestType digestType) {\n+        super(10);\n+        this.digestType = digestType;\n+    }\n+\n+    long getLedgerToRead(int ensemble, int quorum) throws Exception {\n+        byte[] data = \"Data for test\".getBytes();\n+        LedgerHandle l = bkc.createLedger(ensemble, quorum, digestType, passwd);\n+        for (int i = 0; i < 10; i++) {\n+            l.addEntry(data);\n+        }\n+        l.close();\n+\n+        return l.getId();\n+    }\n+\n+    BookKeeper createClient(int specTimeout) throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setSpeculativeReadTimeout(specTimeout)\n+            .setReadTimeout(30000);\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        return new BookKeeper(conf);\n+    }\n+\n+    class LatchCallback implements ReadCallback {\n+        CountDownLatch l = new CountDownLatch(1);\n+        boolean success = false;\n+        long startMillis = System.currentTimeMillis();\n+        long endMillis = Long.MAX_VALUE;\n+\n+        public void readComplete(int rc,\n+                                 LedgerHandle lh,\n+                                 Enumeration<LedgerEntry> seq,\n+                                 Object ctx) {\n+            endMillis = System.currentTimeMillis();\n+            LOG.debug(\"Got response {} {}\", rc, getDuration());\n+            success = rc == BKException.Code.OK;\n+            l.countDown();\n+        }\n+\n+        long getDuration() {\n+            return endMillis - startMillis;\n+        }\n+\n+        void expectSuccess(int milliseconds) throws Exception {\n+            assertTrue(l.await(milliseconds, TimeUnit.MILLISECONDS));\n+            assertTrue(success);\n+        }\n+\n+        void expectFail(int milliseconds) throws Exception {\n+            assertTrue(l.await(milliseconds, TimeUnit.MILLISECONDS));\n+            assertFalse(success);\n+        }\n+\n+        void expectTimeout(int milliseconds) throws Exception {\n+            assertFalse(l.await(milliseconds, TimeUnit.MILLISECONDS));\n+        }\n+    }\n+\n+    /**\n+     * Test basic speculative functionality.\n+     * - Create 2 clients with read timeout disabled, one with spec\n+     *   read enabled, the other not.\n+     * - create ledger\n+     * - sleep second bookie in ensemble\n+     * - read first entry, both should find on first bookie.\n+     * - read second bookie, spec client should find on bookie three,\n+     *   non spec client should hang.\n+     */\n+    @Test\n+    public void testSpeculativeRead() throws Exception {\n+        long id = getLedgerToRead(3,2);\n+        BookKeeper bknospec = createClient(0); // disabled\n+        BookKeeper bkspec = createClient(2000);\n+\n+        LedgerHandle lnospec = bknospec.openLedger(id, digestType, passwd);\n+        LedgerHandle lspec = bkspec.openLedger(id, digestType, passwd);\n+\n+        // sleep second bookie\n+        CountDownLatch sleepLatch = new CountDownLatch(1);\n+        InetSocketAddress second = lnospec.getLedgerMetadata().getEnsembles().get(0L).get(1);\n+        sleepBookie(second, sleepLatch);\n+\n+        try {\n+            // read first entry, both go to first bookie, should be fine\n+            LatchCallback nospeccb = new LatchCallback();\n+            LatchCallback speccb = new LatchCallback();\n+            lnospec.asyncReadEntries(0, 0, nospeccb, null);\n+            lspec.asyncReadEntries(0, 0, speccb, null);\n+            nospeccb.expectSuccess(2000);\n+            speccb.expectSuccess(2000);\n+\n+            // read second entry, both look for second book, spec read client\n+            // tries third bookie, nonspec client hangs as read timeout is very long.\n+            nospeccb = new LatchCallback();\n+            speccb = new LatchCallback();\n+            lnospec.asyncReadEntries(1, 1, nospeccb, null);\n+            lspec.asyncReadEntries(1, 1, speccb, null);\n+            speccb.expectSuccess(4000);\n+            nospeccb.expectTimeout(4000);\n+        } finally {\n+            sleepLatch.countDown();\n+            lspec.close();\n+            lnospec.close();\n+            bkspec.close();\n+            bknospec.close();\n+        }\n+    }\n+\n+    /**\n+     * Test that if more than one replica is down, we can still read, as long as the quorum\n+     * size is larger than the number of down replicas.\n+     */\n+    @Test\n+    public void testSpeculativeReadMultipleReplicasDown() throws Exception {\n+        long id = getLedgerToRead(5,5);\n+        int timeout = 5000;\n+        BookKeeper bkspec = createClient(timeout);\n+\n+        LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n+\n+        // sleep bookie 1, 2 & 4\n+        CountDownLatch sleepLatch = new CountDownLatch(1);\n+        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(1), sleepLatch);\n+        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(2), sleepLatch);\n+        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(4), sleepLatch);\n+\n+        try {\n+            // read first entry, should complete faster than timeout\n+            // as bookie 0 has the entry\n+            LatchCallback latch0 = new LatchCallback();\n+            l.asyncReadEntries(0, 0, latch0, null);\n+            latch0.expectSuccess(timeout/2);\n+\n+            // second should have to hit two timeouts (bookie 1 & 2)\n+            // bookie 3 has the entry\n+            LatchCallback latch1 = new LatchCallback();\n+            l.asyncReadEntries(1, 1, latch1, null);\n+            latch1.expectTimeout(timeout);\n+            latch1.expectSuccess(timeout*2);\n+            LOG.info(\"Timeout {} latch1 duration {}\", timeout, latch1.getDuration());\n+            assertTrue(\"should have taken longer than two timeouts, but less than 3\",\n+                       latch1.getDuration() >= timeout*2\n+                       && latch1.getDuration() < timeout*3);\n+\n+            // third should have to hit one timeouts (bookie 2)\n+            // bookie 3 has the entry\n+            LatchCallback latch2 = new LatchCallback();\n+            l.asyncReadEntries(2, 2, latch2, null);\n+            latch2.expectTimeout(timeout/2);\n+            latch2.expectSuccess(timeout);\n+            LOG.info(\"Timeout {} latch2 duration {}\", timeout, latch2.getDuration());\n+            assertTrue(\"should have taken longer than one timeout, but less than 2\",\n+                       latch2.getDuration() >= timeout\n+                       && latch2.getDuration() < timeout*2);\n+\n+            // fourth should have no timeout\n+            // bookie 3 has the entry\n+            LatchCallback latch3 = new LatchCallback();\n+            l.asyncReadEntries(3, 3, latch3, null);\n+            latch3.expectSuccess(timeout/2);\n+\n+            // fifth should hit one timeout, (bookie 4)\n+            // bookie 0 has the entry\n+            LatchCallback latch4 = new LatchCallback();\n+            l.asyncReadEntries(4, 4, latch4, null);\n+            latch4.expectTimeout(timeout/2);\n+            latch4.expectSuccess(timeout);\n+            LOG.info(\"Timeout {} latch4 duration {}\", timeout, latch4.getDuration());\n+            assertTrue(\"should have taken longer than one timeout, but less than 2\",\n+                       latch4.getDuration() >= timeout\n+                       && latch4.getDuration() < timeout*2);\n+\n+        } finally {\n+            sleepLatch.countDown();\n+            l.close();\n+            bkspec.close();\n+        }\n+    }\n+\n+    /**\n+     * Test that if after a speculative read is kicked off, the original read completes\n+     * nothing bad happens.\n+     */\n+    @Test\n+    public void testSpeculativeReadFirstReadCompleteIsOk() throws Exception {\n+        long id = getLedgerToRead(2,2);\n+        int timeout = 1000;\n+        BookKeeper bkspec = createClient(timeout);\n+\n+        LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n+\n+        // sleep bookies\n+        CountDownLatch sleepLatch0 = new CountDownLatch(1);\n+        CountDownLatch sleepLatch1 = new CountDownLatch(1);\n+        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(0), sleepLatch0);\n+        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(1), sleepLatch1);\n+\n+        try {\n+            // read goes to first bookie, spec read timeout occurs,\n+            // goes to second\n+            LatchCallback latch0 = new LatchCallback();\n+            l.asyncReadEntries(0, 0, latch0, null);\n+            latch0.expectTimeout(timeout);\n+\n+            // wake up first bookie\n+            sleepLatch0.countDown();\n+            latch0.expectSuccess(timeout/2);\n+\n+            sleepLatch1.countDown();\n+\n+            // check we can read next entry without issue\n+            LatchCallback latch1 = new LatchCallback();\n+            l.asyncReadEntries(1, 1, latch1, null);\n+            latch1.expectSuccess(timeout/2);\n+\n+        } finally {\n+            sleepLatch0.countDown();\n+            sleepLatch1.countDown();\n+            l.close();\n+            bkspec.close();\n+        }\n+    }\n+\n+    /**\n+     * Unit test for the speculative read scheduling method\n+     */\n+    @Test\n+    public void testSpeculativeReadScheduling() throws Exception {\n+        long id = getLedgerToRead(3,2);\n+        int timeout = 1000;\n+        BookKeeper bkspec = createClient(timeout);\n+\n+        LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n+\n+        ArrayList<InetSocketAddress> ensemble = l.getLedgerMetadata().getEnsembles().get(0L);\n+        Set<InetSocketAddress> allHosts = new HashSet(ensemble);\n+        Set<InetSocketAddress> noHost = new HashSet();\n+        Set<InetSocketAddress> secondHostOnly = new HashSet();\n+        secondHostOnly.add(ensemble.get(1));\n+        try {\n+            LatchCallback latch0 = new LatchCallback();\n+            PendingReadOp op = new PendingReadOp(l, bkspec.scheduler,\n+                                                 0, 5, latch0, null);\n+\n+            // if we've already heard from all hosts,\n+            // we only send the initial read\n+            PendingReadOp.LedgerEntryRequest req0\n+                = op.new LedgerEntryRequest(ensemble, l.getId(), 0);\n+            assertTrue(\"Should have sent to first\",\n+                       req0.maybeSendSpeculativeRead(allHosts).equals(ensemble.get(0)));\n+            assertNull(\"Should not have sent another\",\n+                       req0.maybeSendSpeculativeRead(allHosts));\n+\n+            // if we have heard from some hosts, but not one we have sent to\n+            // send again\n+            PendingReadOp.LedgerEntryRequest req2\n+                = op.new LedgerEntryRequest(ensemble, l.getId(), 2);\n+            assertTrue(\"Should have sent to third\",\n+                       req2.maybeSendSpeculativeRead(noHost).equals(ensemble.get(2)));\n+            assertTrue(\"Should have sent to first\",\n+                       req2.maybeSendSpeculativeRead(secondHostOnly).equals(ensemble.get(0)));\n+\n+            // if we have heard from some hosts, which includes one we sent to\n+            // do not read again\n+            PendingReadOp.LedgerEntryRequest req4\n+                = op.new LedgerEntryRequest(ensemble, l.getId(), 4);\n+            assertTrue(\"Should have sent to second\",\n+                       req4.maybeSendSpeculativeRead(noHost).equals(ensemble.get(1)));\n+            assertNull(\"Should not have sent another\",\n+                       req4.maybeSendSpeculativeRead(secondHostOnly));\n+        } finally {\n+            // wait for all ops to complete\n+            l.opCounterSem.acquire(bkspec.getConf().getThrottleValue());\n+\n+            l.close();\n+            bkspec.close();\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"d6a4befefe91bc2de7364ce7c8e439fa7d645dd0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/496f442a7a68dd549355e845540c6c72c2fbb44c/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=496f442a7a68dd549355e845540c6c72c2fbb44c","patch":"@@ -241,7 +241,7 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n     public CountDownLatch sleepBookie(InetSocketAddress addr, final int seconds)\n             throws InterruptedException, IOException {\n         final CountDownLatch l = new CountDownLatch(1);\n-        final String name = \"BookieJournal-\" + addr.getPort();\n+        final String name = \"NIOServerFactory-\" + addr.getPort();\n         Thread[] allthreads = new Thread[Thread.activeCount()];\n         Thread.enumerate(allthreads);\n         for (final Thread t : allthreads) {\n@@ -278,7 +278,7 @@ public void run() {\n      */\n     public void sleepBookie(InetSocketAddress addr, final CountDownLatch l)\n             throws InterruptedException, IOException {\n-        final String name = \"BookieJournal-\" + addr.getPort();\n+        final String name = \"NIOServerFactory-\" + addr.getPort();\n         Thread[] allthreads = new Thread[Thread.activeCount()];\n         Thread.enumerate(allthreads);\n         for (final Thread t : allthreads) {"}]}

