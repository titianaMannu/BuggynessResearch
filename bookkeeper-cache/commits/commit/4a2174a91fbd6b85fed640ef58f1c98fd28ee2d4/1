{"sha":"4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0YTIxNzRhOTFmYmQ2Yjg1ZmVkNjQwZWY1OGYxYzk4ZmQyOGVlMmQ0","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-09-18T04:53:21Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-09-18T04:53:21Z"},"message":"BOOKKEEPER-784: BookKeeperCloseTest#testLedgerCheck is failing intermittently (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1625886 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f550195f97d1428d45776989b7298ff27889ad0f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/f550195f97d1428d45776989b7298ff27889ad0f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4","html_url":"https://github.com/apache/bookkeeper/commit/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4f0e52d027ed277576344ecbde1938ed3eeb7aae","url":"https://api.github.com/repos/apache/bookkeeper/commits/4f0e52d027ed277576344ecbde1938ed3eeb7aae","html_url":"https://github.com/apache/bookkeeper/commit/4f0e52d027ed277576344ecbde1938ed3eeb7aae"}],"stats":{"total":132,"additions":4,"deletions":128},"files":[{"sha":"c2f7de64e6d12fc68b356f393a816bef5a95cefa","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4","patch":"@@ -232,6 +232,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-785: Fix javadoc warnings in trunk (ivank via sijie)\n \n+        BOOKKEEPER-784: BookKeeperCloseTest#testLedgerCheck is failing intermittently (ivank via sijie)\n+\n       bookkeeper-benchmark:\n \n         BOOKKEEPER-768: fix typo 'seconds' to milliseconds in benchmark output (jialin via sijie)"},{"sha":"89790f66feca1e4098b7be717c8b37fc210fe274","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","status":"modified","additions":2,"deletions":128,"changes":130,"blob_url":"https://github.com/apache/bookkeeper/blob/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java?ref=4a2174a91fbd6b85fed640ef58f1c98fd28ee2d4","patch":"@@ -164,25 +164,8 @@ public void testFenceLedger() throws Exception {\n \n         restartBookieSlow();\n \n-        // using async, because this could trigger an assertion\n-        final AtomicInteger preCloseReturnCode = new AtomicInteger(0);\n-        final CountDownLatch preCloseOpenLatch = new CountDownLatch(1);\n-        AsyncCallback.OpenCallback preCloseCb = new AsyncCallback.OpenCallback() {\n-            public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n-                preCloseReturnCode.set(rc);\n-                preCloseOpenLatch.countDown();\n-            }\n-        };\n-        bk.asyncOpenLedger(lh.getId(), digestType, PASSWORD.getBytes(),\n-                           preCloseCb, null);\n         bk.close();\n \n-        LOG.info(\"Waiting to open the ledger asynchronously\");\n-        assertTrue(\"Open call should have completed\",\n-                   preCloseOpenLatch.await(20, TimeUnit.SECONDS));\n-        assertEquals(\"Open should not have succeeded through closed bkclient!\",\n-                     BKException.Code.ClientClosedException, preCloseReturnCode.get());\n-\n         try {\n             bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n             fail(\"should have failed, client is closed\");\n@@ -255,7 +238,7 @@ public void deleteComplete(int rc, Object ctx) {\n      * Test that adding entry to a ledger using bookkeeper client which is\n      * closed should throw ClientClosedException\n      */\n-    @Test//(timeout = 60000)\n+    @Test(timeout = 60000)\n     public void testAddLedgerEntry() throws Exception {\n         BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n         LOG.info(\"Create ledger and add entries to it\");\n@@ -264,26 +247,8 @@ public void testAddLedgerEntry() throws Exception {\n \n         restartBookieSlow();\n \n-        final CountDownLatch preCloseCompleteLatch = new CountDownLatch(1);\n-        final AtomicInteger preCloseRc = new AtomicInteger(BKException.Code.OK);\n-\n-        lh.asyncAddEntry(\"foobar\".getBytes(), new AddCallback() {\n-                public void addComplete(int rccb, LedgerHandle lh, long entryId,\n-                                        Object ctx) {\n-                    preCloseRc.set(rccb);\n-                    preCloseCompleteLatch.countDown();\n-                }\n-            }, null);\n-\n         bk.close();\n \n-        LOG.info(\"Waiting to finish adding another entry asynchronously\");\n-        assertTrue(\"Add entry to ledger call should have completed\",\n-                   preCloseCompleteLatch.await(20, TimeUnit.SECONDS));\n-        assertEquals(\n-                \"Add enrty to ledger should have succeeded through closed bkclient!\",\n-                BKException.Code.ClientClosedException, preCloseRc.get());\n-\n         try {\n             lh.addEntry(\"foobar\".getBytes());\n             fail(\"should have failed, client is closed\");\n@@ -360,26 +325,9 @@ public void testReadLedgerEntry() throws Exception {\n         LOG.info(\"Closing bookkeeper client\");\n \n         restartBookieSlow();\n-        final CountDownLatch preCloseReadLatch = new CountDownLatch(1);\n-        final AtomicInteger preCloseRc = new AtomicInteger(BKException.Code.OK);\n-        ReadCallback preCloseCb = new ReadCallback() {\n-            @Override\n-            public void readComplete(int rccb, LedgerHandle lh,\n-                    Enumeration<LedgerEntry> seq, Object ctx) {\n-                preCloseRc.set(rccb);\n-                preCloseReadLatch.countDown();\n-            }\n-        };\n-        lh.asyncReadEntries(0, numOfEntries - 1, preCloseCb, null);\n \n         bk.close();\n \n-        assertTrue(\"Read entry ledger call should have completed\",\n-                   preCloseReadLatch.await(20, TimeUnit.SECONDS));\n-        assertEquals(\n-                \"Read entry ledger should have succeeded through closed bkclient!\",\n-                BKException.Code.ClientClosedException, preCloseRc.get());\n-\n         try {\n             lh.readEntries(0, numOfEntries - 1);\n             fail(\"should have failed, client is closed\");\n@@ -423,28 +371,8 @@ public void testReadLastConfirmed() throws Exception {\n         restartBookieSlow();\n         restartBookieSlow();\n \n-        final CountDownLatch preCloseReadLatch = new CountDownLatch(1);\n-        final AtomicInteger preCloseRc = new AtomicInteger(BKException.Code.OK);\n-        AsyncCallback.ReadLastConfirmedCallback preCloseCb\n-            = new AsyncCallback.ReadLastConfirmedCallback() {\n-\n-            @Override\n-            public void readLastConfirmedComplete(int rccb, long lastConfirmed,\n-                    Object ctx) {\n-                preCloseRc.set(rccb);\n-                preCloseReadLatch.countDown();\n-            }\n-        };\n-        lh.asyncReadLastConfirmed(preCloseCb, null);\n-\n         bk.close();\n \n-        assertTrue(\"ReadLastConfirmed call should have completed\",\n-                   preCloseReadLatch.await(20, TimeUnit.SECONDS));\n-        assertEquals(\n-                \"ReadLastConfirmed should have succeeded through closed bkclient!\",\n-                BKException.Code.ClientClosedException, preCloseRc.get());\n-\n         final CountDownLatch readLatch = new CountDownLatch(1);\n         final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n         AsyncCallback.ReadLastConfirmedCallback cb = new AsyncCallback.ReadLastConfirmedCallback() {\n@@ -483,24 +411,11 @@ public void testLedgerCheck() throws Exception {\n         LOG.info(\"Create ledger and add entries to it\");\n         LedgerHandle lh = createLedgerWithEntries(bk, 100);\n         LOG.info(\"Closing bookkeeper client\");\n+        LedgerChecker lc = new LedgerChecker(bk);\n \n         restartBookieSlow();\n-        final CountDownLatch preLatch = new CountDownLatch(1);\n-        final AtomicInteger preRc = new AtomicInteger(BKException.Code.OK);\n-        LedgerChecker lc = new LedgerChecker(bk);\n-        lc.checkLedger(lh, new GenericCallback<Set<LedgerFragment>>() {\n-                @Override\n-                public void operationComplete(int rc, Set<LedgerFragment> result) {\n-                    preRc.set(rc);\n-                    preLatch.countDown();\n-                }\n-            });\n         bk.close();\n \n-        assertTrue(\"checkLedger should have finished\", preLatch.await(30, TimeUnit.SECONDS));\n-        assertEquals(\"Should have client closed exception\",\n-                     preRc.get(), BKException.Code.ClientClosedException);\n-\n         final CountDownLatch postLatch = new CountDownLatch(1);\n         final AtomicInteger postRc = new AtomicInteger(BKException.Code.OK);\n         lc.checkLedger(lh, new GenericCallback<Set<LedgerFragment>>() {\n@@ -575,49 +490,8 @@ public void testBookKeeperAdmin() throws Exception {\n         restartBookieSlow();\n         restartBookieSlow();\n \n-        final CountDownLatch latch1 = new CountDownLatch(1);\n-        final CountDownLatch latch2 = new CountDownLatch(1);\n-        final CountDownLatch latch3 = new CountDownLatch(1);\n-\n-        final AtomicInteger rc1 = new AtomicInteger(BKException.Code.OK);\n-        final AtomicInteger rc2 = new AtomicInteger(BKException.Code.OK);\n-        final AtomicInteger rc3 = new AtomicInteger(BKException.Code.OK);\n-\n-        bkadmin.asyncOpenLedger(lh1.getId(), new AsyncCallback.OpenCallback() {\n-                @Override\n-                public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n-                    rc1.set(rc);\n-                    latch1.countDown();\n-                }\n-            }, null);\n-        bkadmin.asyncOpenLedgerNoRecovery(lh2.getId(), new AsyncCallback.OpenCallback() {\n-                @Override\n-                public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n-                    rc2.set(rc);\n-                    latch2.countDown();\n-                }\n-            }, null);\n-\n-        bkadmin.asyncRecoverBookieData(bookieToKill, newBookie,\n-                new AsyncCallback.RecoverCallback() {\n-                    @Override\n-                    public void recoverComplete(int rc, Object ctx) {\n-                        rc3.set(rc);\n-                        latch3.countDown();\n-                    }\n-                }, null);\n         bk.close();\n \n-        assertTrue(\"Request1 should have completed\", latch1.await(10, TimeUnit.SECONDS));\n-        assertTrue(\"Request2 should have completed\", latch2.await(10, TimeUnit.SECONDS));\n-        assertTrue(\"Request3 should have completed\", latch3.await(10, TimeUnit.SECONDS));\n-        assertEquals(\"Should have noticed the handle was closed\",\n-                     BKException.Code.ClientClosedException, rc1.get());\n-        assertEquals(\"Should have noticed the handle was closed\",\n-                     BKException.Code.ClientClosedException, rc2.get());\n-        assertEquals(\"Should have noticed the handle was closed\",\n-                     BKException.Code.ClientClosedException, rc3.get());\n-\n         try {\n             bkadmin.openLedger(lh1.getId());\n             fail(\"Shouldn't be able to open with a closed client\");"}]}

