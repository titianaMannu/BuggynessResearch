{"sha":"4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0ZDlmMGMwZWJlODYxNGUwMTkwYzVkZjViYmQ2OGM2ZmExYzA1MTgw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-16T16:05:52Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-16T16:05:52Z"},"message":"BOOKKEEPER-101 : Add Fencing to Bookkeeper (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1202758 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"976230a9e589fcb66ef0f812255f368ec65c7a3a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/976230a9e589fcb66ef0f812255f368ec65c7a3a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","html_url":"https://github.com/apache/bookkeeper/commit/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"64411b9af4eede947f0cf0fd46da4d3170ec18e4","url":"https://api.github.com/repos/apache/bookkeeper/commits/64411b9af4eede947f0cf0fd46da4d3170ec18e4","html_url":"https://github.com/apache/bookkeeper/commit/64411b9af4eede947f0cf0fd46da4d3170ec18e4"}],"stats":{"total":991,"additions":862,"deletions":129},"files":[{"sha":"84ea2c7f6d4e4105b5933be87496790f914e3474","filename":"CHANGES.txt","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -64,6 +64,10 @@ BUGFIXES:\n \n   BOOKKEEPER-82: support journal rolling (Sijie Guo via fpj)\n \n+  BOOKKEEPER-106: recoveryBookieData can select a recovery bookie which is already in the ledgers ensemble (ivank via fpj)\n+\n+  BOOKKEEPER-101: Add Fencing to Bookkeeper (ivank)\n+\n  hedwig-server/\n \n   BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)\n@@ -86,7 +90,7 @@ BUGFIXES:\n  \n   BOOKKEEPER-80: subscription msg queue race condition in hedwig c++ client (Sijie Guo via ivank)\n \n-  BOOKKEEPER-106:\trecoveryBookieData can select a recovery bookie which is already in the ledgers ensemble (ivank via fpj)\n+  \n \n IMPROVEMENTS:\n "},{"sha":"6140ee0ebcd7c6d43da2a49451838c5130b2c0af","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":76,"deletions":10,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -752,24 +752,90 @@ public synchronized void shutdown() throws InterruptedException {\n         running = false;\n     }\n \n-    public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n+    /** \n+     * Retrieve the ledger descriptor for the ledger which entry should be added to.\n+     * The LedgerDescriptor returned from this method should be eventually freed with \n+     * #putHandle().\n+     *\n+     * @throws BookieException if masterKey does not match the master key of the ledger\n+     */\n+    private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey) \n             throws IOException, BookieException {\n         long ledgerId = entry.getLong();\n         LedgerDescriptor handle = getHandle(ledgerId, false, masterKey);\n \n         if(!handle.cmpMasterKey(ByteBuffer.wrap(masterKey))) {\n+            putHandle(handle);\n             throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n         }\n-        try {\n-            entry.rewind();\n-            long entryId = handle.addEntry(entry);\n-            entry.rewind();\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Adding \" + entryId + \"@\" + ledgerId);\n+        return handle;\n+    }\n+\n+    /**\n+     * Add an entry to a ledger as specified by handle. \n+     */\n+    private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCallback cb, Object ctx)\n+            throws IOException, BookieException {\n+        long ledgerId = handle.getLedgerId();\n+        entry.rewind();\n+        long entryId = handle.addEntry(entry);\n+\n+        entry.rewind();\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Adding \" + entryId + \"@\" + ledgerId);\n+        }\n+        queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n+    }\n+\n+    /**\n+     * Add entry to a ledger, even if the ledger has previous been fenced. This should only\n+     * happen in bookie recovery or ledger recovery cases, where entries are being replicates \n+     * so that they exist on a quorum of bookies. The corresponding client side call for this\n+     * is not exposed to users.\n+     */\n+    public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey) \n+            throws IOException, BookieException {\n+        LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n+        synchronized (handle) {\n+            try {\n+                addEntryInternal(handle, entry, cb, ctx);\n+            } finally {\n+                putHandle(handle);\n             }\n-            queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n-        } finally {\n-            putHandle(handle);\n+        }\n+    }\n+    \n+    /** \n+     * Add entry to a ledger.\n+     * @throws BookieException.LedgerFencedException if the ledger is fenced\n+     */\n+    public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n+            throws IOException, BookieException {\n+        LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n+        synchronized (handle) {\n+            try {\n+                if (handle.isFenced()) {\n+                    throw BookieException.create(BookieException.Code.LedgerFencedException);\n+                }\n+                \n+                addEntryInternal(handle, entry, cb, ctx);\n+            } finally {\n+                putHandle(handle);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Fences a ledger. From this point on, clients will be unable to \n+     * write to this ledger. Only recoveryAddEntry will be\n+     * able to add entries to the ledger.\n+     * This method is idempotent. Once a ledger is fenced, it can\n+     * never be unfenced. Fencing a fenced ledger has no effect.\n+     */\n+    public void fenceLedger(long ledgerId) throws IOException {\n+        LedgerDescriptor handle = getHandle(ledgerId, true);\n+        synchronized (handle) {\n+            handle.setFenced();\n         }\n     }\n "},{"sha":"1a5b3136f3bd58dfd24768486eddb7b1f5996547","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -36,6 +36,8 @@ public static BookieException create(int code) {\n         switch(code) {\n         case Code.UnauthorizedAccessException:\n             return new BookieUnauthorizedAccessException();\n+        case Code.LedgerFencedException:\n+            return new LedgerFencedException();\n         default:\n             return new BookieIllegalOpException();\n         }\n@@ -46,6 +48,7 @@ public static BookieException create(int code) {\n         int UnauthorizedAccessException = -1;\n \n         int IllegalOpException = -100;\n+        int LedgerFencedException = -101;\n     }\n \n     public void setCode(int code) {\n@@ -62,6 +65,8 @@ public String getMessage(int code) {\n             return \"No problem\";\n         case Code.UnauthorizedAccessException:\n             return \"Error while reading ledger\";\n+        case Code.LedgerFencedException:\n+            return \"Ledger has been fenced; No more entries can be added\";\n         default:\n             return \"Invalid operation\";\n         }\n@@ -78,4 +83,10 @@ public BookieIllegalOpException() {\n             super(Code.UnauthorizedAccessException);\n         }\n     }\n+\n+    public static class LedgerFencedException extends BookieException {\n+        public LedgerFencedException() {\n+            super(Code.LedgerFencedException);\n+        }\n+    }\n }"},{"sha":"037c0182cac8614edc41c13c8900a6e7e7317aa7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -43,6 +43,7 @@\n     }\n \n     private ByteBuffer masterKey = null;\n+    volatile private boolean fenced = false;\n \n     void setMasterKey(ByteBuffer masterKey) {\n         this.masterKey = masterKey;\n@@ -53,6 +54,10 @@ boolean cmpMasterKey(ByteBuffer masterKey) {\n     }\n \n     private long ledgerId;\n+    public long getLedgerId() {\n+        return ledgerId;\n+    }\n+\n     EntryLogger entryLogger;\n     private int refCnt;\n     synchronized public void incRef() {\n@@ -64,8 +69,18 @@ synchronized public void decRef() {\n     synchronized public int getRefCnt() {\n         return refCnt;\n     }\n+    \n+    void setFenced() {\n+        fenced = true;\n+    }\n+    \n+    boolean isFenced() {\n+        return fenced;\n+    }\n+\n     long addEntry(ByteBuffer entry) throws IOException {\n         long ledgerId = entry.getLong();\n+\n         if (ledgerId != this.ledgerId) {\n             throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n         }"},{"sha":"911c6603374e9542345dac90a1e075bacca61617","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -76,6 +76,8 @@ public static BKException create(int code) {\n             return new BKInterruptedException();\n         case Code.ProtocolVersionException:\n             return new BKProtocolVersionException();\n+        case Code.LedgerFencedException:\n+            return new BKLedgerFencedException();\n         default:\n             return new BKIllegalOpException();\n         }\n@@ -103,7 +105,9 @@ public static BKException create(int code) {\n         int IncorrectParameterException = -14;\n         int InterruptedException = -15;\n         int ProtocolVersionException = -16;\n+\n         int IllegalOpException = -100;\n+        int LedgerFencedException = -101;\n     }\n \n     public void setCode(int code) {\n@@ -150,6 +154,8 @@ public static String getMessage(int code) {\n             return \"Interrupted while waiting for permit\";\n         case Code.ProtocolVersionException:\n             return \"Bookie protocol version on server is incompatible with client\";\n+        case Code.LedgerFencedException:\n+            return \"Ledger has been fenced off. Some other client must have opened it to read\";\n         default:\n             return \"Invalid operation\";\n         }\n@@ -256,4 +262,10 @@ public BKInterruptedException() {\n             super(Code.InterruptedException);\n         }\n     }\n+\n+    public static class BKLedgerFencedException extends BKException {\n+        public BKLedgerFencedException() {\n+            super(Code.LedgerFencedException);\n+        }\n+    }\n }"},{"sha":"36c3bd105f118a5cb8e8dd8cc82d1276282e5e88","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":32,"deletions":8,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -23,12 +23,15 @@\n \n import java.io.IOException;\n import java.util.concurrent.Executors;\n+import java.util.EnumSet;\n+import java.util.Set;\n \n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.BKException.Code;\n import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.KeeperException;\n@@ -252,6 +255,20 @@ public LedgerHandle createLedger(int ensSize, int qSize,\n \n     /**\n      * Open existing ledger asynchronously for reading.\n+     * \n+     * Opening a ledger with this method invokes fencing and recovery on the ledger \n+     * if the ledger has not been closed. Fencing will block all other clients from \n+     * writing to the ledger. Recovery will make sure that the ledger is closed \n+     * before reading from it. \n+     *\n+     * Recovery also makes sure that any entries which reached one bookie, but not a \n+     * quorum, will be replicated to a quorum of bookies. This occurs in cases were\n+     * the writer of a ledger crashes after sending a write request to one bookie but\n+     * before being able to send it to the rest of the bookies in the quorum. \n+     *\n+     * If the ledger is already closed, neither fencing nor recovery will be applied.\n+     * \n+     * @see LedgerHandle#asyncClose\n      *\n      * @param lId\n      *          ledger identifier\n@@ -264,18 +281,26 @@ public LedgerHandle createLedger(int ensSize, int qSize,\n      */\n     public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n                                 OpenCallback cb, Object ctx) {\n-\n-        new LedgerOpenOp(this, lId, digestType, passwd, false, cb, ctx).initiate();\n-\n+        new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiate();\n     }\n \n     /**\n      * Open existing ledger asynchronously for reading, but it does not try to\n      * recover the ledger if it is not yet closed. The application needs to use\n-     * it carefully, since the writer might have crash and ledger will remain\n+     * it carefully, since the writer might have crashed and ledger will remain\n      * unsealed forever if there is no external mechanism to detect the failure\n      * of the writer and the ledger is not open in a safe manner, invoking the\n      * recovery procedure.\n+     * \n+     * Opening a ledger without recovery does not fence the ledger. As such, other\n+     * clients can continue to write to the ledger. \n+     *\n+     * This method returns a read only ledger handle. It will not be possible \n+     * to add entries to the ledger. Any attempt to add entries will throw an \n+     * exception.\n+     * \n+     * Reads from the returned ledger will only be able to read entries up until\n+     * the lastConfirmedEntry at the point in time at which the ledger was opened.\n      *\n      * @param lId\n      *          ledger identifier\n@@ -286,18 +311,16 @@ public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n      * @param ctx\n      *          optional control object\n      */\n-\n     public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte passwd[],\n                                           OpenCallback cb, Object ctx) {\n-\n-        new LedgerOpenOp(this, lId, digestType, passwd, true, cb, ctx).initiate();\n-\n+        new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiateWithoutRecovery();\n     }\n \n \n     /**\n      * Synchronous open ledger call\n      *\n+     * @see #asyncOpenLedger\n      * @param lId\n      *          ledger identifier\n      * @param digestType\n@@ -332,6 +355,7 @@ public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n     /**\n      * Synchronous, unsafe open ledger call\n      *\n+     * @see #asyncOpenLedgerNoRecovery\n      * @param lId\n      *          ledger identifier\n      * @param digestType"},{"sha":"883ccffec5c3bef0fb0e2fcdc53a3d951e66cb5b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":11,"deletions":8,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -40,6 +40,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n@@ -477,7 +478,7 @@ private void recoverLedger(final InetSocketAddress bookieSrc, final String ledge\n          */\n         DigestType digestType = getLedgerDigestType(lId);\n         byte[] passwd = getLedgerPasswd(lId);\n-        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n+        bkc.asyncOpenLedgerNoRecovery(lId, digestType, passwd, new OpenCallback() {\n             @Override\n             public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                 if (rc != Code.OK.intValue()) {\n@@ -502,7 +503,7 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                 Map<Long, Long> ledgerFragmentsRange = new HashMap<Long, Long>();\n                 Long curEntryId = null;\n                 for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n-                .entrySet()) {\n+                         .entrySet()) {\n                     if (curEntryId != null)\n                         ledgerFragmentsRange.put(curEntryId, entry.getKey() - 1);\n                     curEntryId = entry.getKey();\n@@ -528,7 +529,8 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                  * Multicallback for ledger. Once all fragments for the ledger have been recovered\n                  * trigger the ledgerMcb \n                  */\n-                MultiCallback ledgerFragmentsMcb = new MultiCallback(ledgerFragmentsToRecover.size(), ledgerMcb, null);\n+                MultiCallback ledgerFragmentsMcb \n+                    = new MultiCallback(ledgerFragmentsToRecover.size(), ledgerMcb, null);\n \n                 /*\n                  * Now recover all of the necessary ledger fragments\n@@ -541,7 +543,8 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                         newBookie = getNewBookie(lh.getLedgerMetadata().getEnsembles().get(startEntryId),\n                                                  availableBookies);\n                     } catch (BKException.BKNotEnoughBookiesException bke) {\n-                        ledgerFragmentsMcb.processResult(BKException.Code.NotEnoughBookiesException, null, null);\n+                        ledgerFragmentsMcb.processResult(BKException.Code.NotEnoughBookiesException, \n+                                                         null, null);\n                         continue;\n                     }\n                     \n@@ -552,16 +555,16 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                     }\n \n                     try {\n-                        SingleFragmentCallback cb = new SingleFragmentCallback(ledgerFragmentsMcb, lh, startEntryId, \n-                                                                               bookieSrc, newBookie);\n+                        SingleFragmentCallback cb = new SingleFragmentCallback(\n+                                                                               ledgerFragmentsMcb, lh, startEntryId, bookieSrc, newBookie);\n                         recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, cb, newBookie);\n                     } catch(InterruptedException e) {\n                         Thread.currentThread().interrupt();\n                         return;\n                     }\n                 }\n             }\n-        }, null);\n+            }, null);\n     }\n \n     /**\n@@ -691,7 +694,7 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n                          */\n                         ledgerFragmentEntryMcb.processResult(rc, null, null);\n                     }\n-                }, null);\n+                }, null, BookieProtocol.FLAG_RECOVERY_ADD);\n             }\n         }, null);\n     }"},{"sha":"56b7a8c928988037a13542385eb3f6875204f6d2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -140,7 +140,7 @@ public void processResult(int rc, String path, Object ctx, String name) {\n          */\n         metadata.addEnsemble(new Long(0), ensemble);\n         try {\n-            lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd, false);\n+            lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n         } catch (GeneralSecurityException e) {\n             LOG.error(\"Security exception while creating ledger: \" + ledgerId, e);\n             cb.createComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);"},{"sha":"9e0e95a9fc75a1f10a5a6c88c4b6bc0f7063abb9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":97,"deletions":28,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -20,7 +20,7 @@\n  * under the License.\n  *\n  */\n-\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n import java.util.ArrayDeque;\n@@ -45,6 +45,7 @@\n \n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.AsyncCallback.StatCallback;\n+import org.apache.zookeeper.AsyncCallback.DataCallback;\n import org.apache.zookeeper.data.Stat;\n import org.jboss.netty.buffer.ChannelBuffer;\n \n@@ -57,27 +58,26 @@\n     final static long LAST_ADD_CONFIRMED = -1;\n \n     final byte[] ledgerKey;\n-    final LedgerMetadata metadata;\n+    LedgerMetadata metadata;\n     final BookKeeper bk;\n     final long ledgerId;\n     long lastAddPushed;\n     long lastAddConfirmed;\n     long length;\n     final DigestManager macManager;\n     final DistributionSchedule distributionSchedule;\n-    final boolean readOnly;\n \n     final Semaphore opCounterSem;\n     private Integer throttling = 5000;\n \n     final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();\n \n     LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n-                 DigestType digestType, byte[] password, boolean readOnly)\n+                 DigestType digestType, byte[] password)\n             throws GeneralSecurityException, NumberFormatException {\n         this.bk = bk;\n         this.metadata = metadata;\n-        this.readOnly = readOnly;\n+\n         if (metadata.isClosed()) {\n             lastAddConfirmed = lastAddPushed = metadata.close;\n             length = metadata.length;\n@@ -205,7 +205,7 @@ void writeLedgerConfig(StatCallback callback, Object ctx) {\n \n     /**\n      * Close this ledger synchronously.\n-     *\n+     * @see #asyncClose\n      */\n     public void close() \n             throws InterruptedException, BKException {\n@@ -221,41 +221,41 @@ public void close()\n     }\n \n     /**\n-     * Asynchronous close, any adds in flight will return errors\n-     *\n+     * Asynchronous close, any adds in flight will return errors.\n+     * \n+     * Closing a ledger will ensure that all clients agree on what the last entry \n+     * of the ledger is. This ensures that, once the ledger has been closed, all \n+     * reads from the ledger will return the same set of entries. \n+     * \n      * @param cb\n      *          callback implementation\n      * @param ctx\n      *          control object\n      * @throws InterruptedException\n      */\n     public void asyncClose(CloseCallback cb, Object ctx) {\n-        asyncClose(cb, ctx, BKException.Code.LedgerClosedException);\n+        asyncCloseInternal(cb, ctx, BKException.Code.LedgerClosedException);\n     }\n \n     /**\n-     * Same as public version of asynClose except that this one takes an\n+     * Same as public version of asyncClose except that this one takes an\n      * additional parameter which is the return code to hand to all the pending\n      * add ops\n      *\n      * @param cb\n      * @param ctx\n      * @param rc\n      */\n-    private void asyncClose(final CloseCallback cb, final Object ctx, final int rc) {\n-        // in unsafe read mode, we should not close ledger, just callback\n-        if (readOnly) {\n-            cb.closeComplete(BKException.Code.OK, this, ctx);\n-            return;\n-        }\n-\n+    void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {\n+ \n         bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n \n             @Override\n             public void safeRun() {\n                 metadata.length = length;\n                 // Close operation is idempotent, so no need to check if we are\n                 // already closed\n+\n                 metadata.close(lastAddConfirmed);\n                 errorOutPendingAdds(rc);\n                 lastAddPushed = lastAddConfirmed;\n@@ -268,7 +268,7 @@ public void safeRun() {\n                 writeLedgerConfig(new StatCallback() {\n                     @Override\n                     public void processResult(int rc, String path, Object subctx,\n-                    Stat stat) {\n+                                              Stat stat) {\n                         if (rc != KeeperException.Code.OK.intValue()) {\n                             LOG.warn(\"Conditional write failed: \" + KeeperException.Code.get(rc));\n                             cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n@@ -331,7 +331,6 @@ public void asyncReadEntries(long firstEntry, long lastEntry,\n \n         try {\n             new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();\n-\n         } catch (InterruptedException e) {\n             cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);\n         }\n@@ -365,6 +364,10 @@ public void addEntry(byte[] data, int offset, int length)\n \n         asyncAddEntry(data, offset, length, new SyncAddCallback(), counter);\n         counter.block(0);\n+        \n+        if (counter.getrc() != BKException.Code.OK) {\n+            throw BKException.create(counter.getrc());\n+        }\n \n         if(counter.getrc() != BKException.Code.OK) {\n             throw BKException.create(counter.getrc());\n@@ -404,11 +407,27 @@ public void asyncAddEntry(final byte[] data, final AddCallback cb,\n      */\n     public void asyncAddEntry(final byte[] data, final int offset, final int length,\n                               final AddCallback cb, final Object ctx) {\n-        if (readOnly) {\n-            LOG.error(\"Tries to add entry on a Read-Only ledger handle\");\n-            cb.addComplete(BKException.Code.IllegalOpException, this, -1, ctx);\n-            return;\n-        }\n+        PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx);\n+        doAsyncAddEntry(op, data, offset, length, cb, ctx);\n+    }\n+\n+    /**\n+     * Make a recovery add entry request. Recovery adds can add to a ledger even if\n+     * it has been fenced.\n+     *\n+     * This is only valid for bookie and ledger recovery, which may need to replicate\n+     * entries to a quorum of bookies to ensure data safety.\n+     *\n+     * Normal client should never call this method.\n+     */\n+    void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length,\n+                               final AddCallback cb, final Object ctx) {\n+        PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx).enableRecoveryAdd();\n+        doAsyncAddEntry(op, data, offset, length, cb, ctx);\n+    }\n+\n+    private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset, final int length,\n+                                 final AddCallback cb, final Object ctx) {\n         if (offset < 0 || length < 0\n                 || (offset + length) > data.length) {\n             throw new ArrayIndexOutOfBoundsException(\n@@ -436,7 +455,7 @@ public void safeRun() {\n \n                     long entryId = ++lastAddPushed;\n                     long currentLength = addToLength(length);\n-                    PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);\n+                    op.setEntryId(entryId);\n                     pendingAddOps.add(op);\n                     ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n                                                entryId, lastAddConfirmed, currentLength, data, offset, length);\n@@ -509,7 +528,7 @@ public long readLastConfirmed()\n \n     // close the ledger and send fails to all the adds in the pipeline\n     void handleUnrecoverableErrorDuringAdd(int rc) {\n-        asyncClose(NoopCloseCallback.instance, null, rc);\n+        asyncCloseInternal(NoopCloseCallback.instance, null, rc);\n     }\n \n     void errorOutPendingAdds(int rc) {\n@@ -591,15 +610,65 @@ public void safeRun() {\n         }, null);\n \n     }\n+    \n+    void rereadMetadata(final GenericCallback<Void> cb) {\n+        bk.getZkHandle().getData(StringUtils.getLedgerNodePath(ledgerId), false, \n+                new DataCallback() {\n+                    public void processResult(int rc, String path, \n+                                              Object ctx, byte[] data, Stat stat) {\n+                        if (rc != KeeperException.Code.OK.intValue()) {\n+                            LOG.error(\"Error reading metadata from ledger, code =\" + rc);\n+                            cb.operationComplete(BKException.Code.ZKException, null);\n+                            return;\n+                        }\n+                        \n+                        try {\n+                            metadata = LedgerMetadata.parseConfig(data, stat.getVersion());\n+                        } catch (IOException e) {\n+                            LOG.error(\"Error parsing ledger metadata for ledger\", e);\n+                            cb.operationComplete(BKException.Code.ZKException, null);\n+                        }\n+                        cb.operationComplete(BKException.Code.OK, null);\n+                    }\n+                }, null);\n+    }\n \n-    void recover(GenericCallback<Void> cb) {\n+    void recover(final GenericCallback<Void> cb) {\n         if (metadata.isClosed()) {\n+            lastAddConfirmed = lastAddPushed = metadata.close;\n+            length = metadata.length;\n+\n             // We are already closed, nothing to do\n             cb.operationComplete(BKException.Code.OK, null);\n             return;\n         }\n \n-        new LedgerRecoveryOp(this, cb).initiate();\n+        metadata.markLedgerInRecovery();\n+\n+        writeLedgerConfig(new StatCallback() {\n+            @Override\n+            public void processResult(final int rc, String path, Object ctx, Stat stat) {\n+                if (rc == KeeperException.Code.BadVersion) {\n+                    rereadMetadata(new GenericCallback<Void>() {\n+                            @Override\n+                            public void operationComplete(int rc, Void result) {\n+                                if (rc != BKException.Code.OK) {\n+                                    cb.operationComplete(rc, null);\n+                                } else {\n+                                    recover(cb);\n+                                }\n+                            }\n+                        });\n+                } else if (rc == KeeperException.Code.OK.intValue()) {\n+                    metadata.znodeVersion = stat.getVersion();\n+                    new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n+                } else {\n+                    LOG.error(\"Error writing ledger config \" +  rc \n+                              + \" path = \" + path);\n+                    cb.operationComplete(BKException.Code.ZKException, null);\n+                }\n+            }\n+        }, null);\n     }\n \n     static class NoopCloseCallback implements CloseCallback {"},{"sha":"30584bf7b97d4a94bec91213252692fdffdc0759","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -44,6 +44,8 @@\n     // can't use -1 for NOTCLOSED because that is reserved for a closed, empty\n     // ledger\n     public static final int NOTCLOSED = -101;\n+    public static final int IN_RECOVERY = -102;\n+\n     public static final int LOWEST_COMPAT_METADATA_FORMAT_VERSION = 0;\n     public static final int CURRENT_METADATA_FORMAT_VERSION = 1;\n     public static final String VERSION_KEY = \"BookieMetadataFormatVersion\";\n@@ -87,7 +89,12 @@ private LedgerMetadata() {\n     }\n \n     boolean isClosed() {\n-        return close != NOTCLOSED;\n+        return close != NOTCLOSED \n+            && close != IN_RECOVERY;\n+    }\n+    \n+    void markLedgerInRecovery() {\n+        close = IN_RECOVERY;\n     }\n \n     void close(long entryId) {"},{"sha":"037e2e40272f77b67581ae053193d9d3a1dc28aa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":23,"deletions":15,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -47,7 +47,7 @@\n     LedgerHandle lh;\n     final byte[] passwd;\n     final DigestType digestType;\n-    final boolean unsafe;\n+    boolean doRecovery;\n \n     /**\n      * Constructor.\n@@ -59,15 +59,16 @@\n      * @param cb\n      * @param ctx\n      */\n-\n-    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, boolean unsafe, OpenCallback cb, Object ctx) {\n+    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, \n+                        OpenCallback cb, Object ctx) {\n         this.bk = bk;\n         this.ledgerId = ledgerId;\n         this.passwd = passwd;\n         this.cb = cb;\n         this.ctx = ctx;\n         this.digestType = digestType;\n-        this.unsafe = unsafe;\n+\n+        this.doRecovery = true;\n     }\n \n     /**\n@@ -79,7 +80,14 @@ public void initiate() {\n          */\n \n         bk.getZkHandle().getData(StringUtils.getLedgerNodePath(ledgerId), false, this, ctx);\n+    }\n \n+    /**\n+     * Inititates the ledger open operation without recovery\n+     */\n+    public void initiateWithoutRecovery() {\n+        this.doRecovery = false;\n+        initiate();\n     }\n \n     /**\n@@ -112,7 +120,7 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n         }\n \n         try {\n-            lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd, unsafe);\n+            lh = new ReadOnlyLedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n         } catch (GeneralSecurityException e) {\n             LOG.error(\"Security exception while opening ledger: \" + ledgerId, e);\n             cb.openComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);\n@@ -123,23 +131,23 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n             return;\n         }\n \n-        if (metadata.close != LedgerMetadata.NOTCLOSED) {\n+        if (metadata.isClosed()) {\n             // Ledger was closed properly\n             cb.openComplete(BKException.Code.OK, lh, this.ctx);\n             return;\n         }\n \n-        if(!unsafe) {\n+        if (doRecovery) {\n             lh.recover(new GenericCallback<Void>() {\n-                @Override\n-                public void operationComplete(int rc, Void result) {\n-                    if (rc != BKException.Code.OK) {\n-                        cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n-                    } else {\n-                        cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n+                    @Override\n+                    public void operationComplete(int rc, Void result) {\n+                        if (rc != BKException.Code.OK) {\n+                            cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n+                        } else {\n+                            cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n+                        }\n                     }\n-                }\n-            });\n+                });\n         } else {\n             lh.asyncReadLastConfirmed(new ReadLastConfirmedCallback() {\n "},{"sha":"5a898d95c6e29e9b3a4bf5e7bd10931eb11a5dfb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":12,"deletions":5,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -26,6 +26,7 @@\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n \n@@ -59,8 +60,15 @@ public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n     }\n \n     public void initiate() {\n+        /** \n+         * Enable fencing on this op. When the read request reaches the bookies\n+         * server it will fence off the ledger, stopping any subsequent operation\n+         * from writing to it.\n+         */\n+        int flags = BookieProtocol.FLAG_DO_FENCING;\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, this, i);\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, \n+                                         LedgerHandle.LAST_ADD_CONFIRMED, this, i, flags);\n         }\n     }\n \n@@ -140,13 +148,13 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n              * be added again when processing the call to add it.\n              */\n             lh.length = entry.getLength() - (long) data.length;\n-            lh.asyncAddEntry(data, this, null);\n+            lh.asyncRecoveryAddEntry(data, 0, data.length, this, null);\n \n             return;\n         }\n \n         if (rc == BKException.Code.NoSuchEntryException || rc == BKException.Code.NoSuchLedgerExistsException) {\n-            lh.asyncClose(new CloseCallback() {\n+            lh.asyncCloseInternal(new CloseCallback() {\n                 @Override\n                 public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                     if (rc != KeeperException.Code.OK.intValue()) {\n@@ -158,8 +166,7 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                     }\n                 } \n                 \n-            }, null);\n-            \n+                }, null, BKException.Code.LedgerClosedException);\n             return;\n         }\n "},{"sha":"bbe798618316a510ceced1101eb754fdeb6735c4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":30,"deletions":4,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -21,6 +21,7 @@\n import java.net.InetSocketAddress;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.log4j.Logger;\n import org.jboss.netty.buffer.ChannelBuffer;\n \n@@ -43,19 +44,36 @@\n     boolean[] successesSoFar;\n     int numResponsesPending;\n     LedgerHandle lh;\n+    boolean isRecoveryAdd = false;\n \n-    PendingAddOp(LedgerHandle lh, AddCallback cb, Object ctx, long entryId) {\n+    PendingAddOp(LedgerHandle lh, AddCallback cb, Object ctx) {\n         this.lh = lh;\n         this.cb = cb;\n         this.ctx = ctx;\n-        this.entryId = entryId;\n+        this.entryId = -1;\n+        \n         successesSoFar = new boolean[lh.metadata.quorumSize];\n         numResponsesPending = successesSoFar.length;\n     }\n \n+    /** \n+     * Enable the recovery add flag for this operation.\n+     * @see LedgerHandle#asyncRecoveryAddEntry\n+     */\n+    PendingAddOp enableRecoveryAdd() {\n+        isRecoveryAdd = true;\n+        return this;\n+    }\n+\n+    void setEntryId(long entryId) {\n+        this.entryId = entryId;\n+    }\n+\n     void sendWriteRequest(int bookieIndex, int arrayIndex) {\n+        int flags = isRecoveryAdd ? BookieProtocol.FLAG_RECOVERY_ADD : BookieProtocol.FLAG_NONE;\n+\n         lh.bk.bookieClient.addEntry(lh.metadata.currentEnsemble.get(bookieIndex), lh.ledgerId, lh.ledgerKey, entryId, toSend,\n-                                    this, arrayIndex);\n+                this, arrayIndex, flags);\n     }\n \n     void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n@@ -111,7 +129,15 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             return;\n         }\n \n-        if (rc != BKException.Code.OK) {\n+        switch (rc) {\n+        case BKException.Code.OK:\n+            // continue\n+            break;\n+        case BKException.Code.LedgerFencedException:\n+            LOG.warn(\"Fencing exception on write: \" + ledgerId + \", \" + entryId);\n+            lh.handleUnrecoverableErrorDuringAdd(rc);\n+            return;\n+        default:\n             LOG.warn(\"Write did not succeed: \" + ledgerId + \", \" + entryId);\n             lh.handleBookieFailure(addr, bookieIndex);\n             return;"},{"sha":"baa720970c68719ee9d15579e1aa15a72cd12222","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -30,6 +30,7 @@\n import java.util.Queue;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.log4j.Logger;\n import org.jboss.netty.buffer.ChannelBuffer;\n@@ -101,7 +102,8 @@ void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int last\n \n         int bookieIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom);\n         entry.nextReplicaIndexToReadFrom++;\n-        lh.bk.bookieClient.readEntry(ensemble.get(bookieIndex), lh.ledgerId, entry.entryId, this, entry);\n+        lh.bk.bookieClient.readEntry(ensemble.get(bookieIndex), lh.ledgerId, entry.entryId, \n+                                     this, entry, BookieProtocol.FLAG_NONE);\n     }\n \n     void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {"},{"sha":"c78bcf60c81fa1fe03bc799fd08dac7150b5ed4a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -16,10 +16,12 @@\n  * limitations under the License.\n  */\n \n+import java.util.EnumSet;\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.log4j.Logger;\n import org.jboss.netty.buffer.ChannelBuffer;\n \n@@ -49,7 +51,8 @@ public ReadLastConfirmedOp(LedgerHandle lh, ReadLastConfirmedCallback cb, Object\n \n     public void initiate() {\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, this, i);\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, \n+                                         this, i, BookieProtocol.FLAG_NONE);\n         }\n     }\n "},{"sha":"4728fb1e5d33a7e9f3a26cfa107d8f9a848aab6a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -0,0 +1,78 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import java.security.GeneralSecurityException;\n+\n+\n+/**\n+ * Read only ledger handle. This ledger handle allows you to \n+ * read from a ledger but not to write to it. It overrides all \n+ * the public write operations from LedgerHandle.\n+ * It should be returned for BookKeeper#openLedger operations.\n+ */\n+class ReadOnlyLedgerHandle extends LedgerHandle {\n+    ReadOnlyLedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n+                         DigestType digestType, byte[] password)\n+            throws GeneralSecurityException, NumberFormatException {\n+        super(bk, ledgerId, metadata, digestType, password);\n+    }\n+\n+    @Override\n+    public void close() \n+            throws InterruptedException, BKException {\n+        // noop\n+    }\n+\n+    @Override\n+    public void asyncClose(CloseCallback cb, Object ctx) {\n+        cb.closeComplete(BKException.Code.OK, this, ctx);\n+    }\n+    \n+    @Override\n+    public void addEntry(byte[] data) throws InterruptedException, BKException {\n+        addEntry(data, 0, data.length);\n+    }\n+    \n+    @Override\n+    public void addEntry(byte[] data, int offset, int length)\n+            throws InterruptedException, BKException {\n+        LOG.error(\"Tried to add entry on a Read-Only ledger handle, ledgerid=\" + ledgerId);        \n+        throw BKException.create(BKException.Code.IllegalOpException);\n+    }\n+\n+    @Override\n+    public void asyncAddEntry(final byte[] data, final AddCallback cb,\n+                              final Object ctx) {\n+        asyncAddEntry(data, 0, data.length, cb, ctx);\n+    }\n+\n+    @Override\n+    public void asyncAddEntry(final byte[] data, final int offset, final int length,\n+                              final AddCallback cb, final Object ctx) {\n+        LOG.error(\"Tried to add entry on a Read-Only ledger handle, ledgerid=\" + ledgerId);\n+        cb.addComplete(BKException.Code.IllegalOpException, this, -1, ctx);\n+    }\n+}"},{"sha":"d7b25c5fc5b7afb34f368ff529b115cbd78d5bd5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":5,"deletions":7,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -71,8 +71,7 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n     }\n \n     public void addEntry(final InetSocketAddress addr, final long ledgerId, final byte[] masterKey, final long entryId,\n-                         final ChannelBuffer toSend, final WriteCallback cb, final Object ctx) {\n-\n+            final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n         final PerChannelBookieClient client = lookupClient(addr);\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n@@ -82,14 +81,13 @@ public void operationComplete(int rc, Void result) {\n                     cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n                     return;\n                 }\n-                client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx);\n+                client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n             }\n         });\n     }\n \n     public void readEntry(final InetSocketAddress addr, final long ledgerId, final long entryId,\n-                          final ReadEntryCallback cb, final Object ctx) {\n-\n+                          final ReadEntryCallback cb, final Object ctx, final int options) {\n         final PerChannelBookieClient client = lookupClient(addr);\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n@@ -100,7 +98,7 @@ public void operationComplete(int rc, Void result) {\n                     cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n                     return;\n                 }\n-                client.readEntry(ledgerId, entryId, cb, ctx);\n+                client.readEntry(ledgerId, entryId, cb, ctx, options);\n             }\n         });\n     }\n@@ -168,7 +166,7 @@ public void writeComplete(int rc, long ledger, long entry, InetSocketAddress add\n \n         for (int i = 0; i < 100000; i++) {\n             counter.inc();\n-            bc.addEntry(addr, ledger, new byte[0], i, ChannelBuffers.wrappedBuffer(hello), cb, counter);\n+            bc.addEntry(addr, ledger, new byte[0], i, ChannelBuffers.wrappedBuffer(hello), cb, counter, 0);\n         }\n         counter.wait(0);\n         System.out.println(\"Total = \" + counter.total());"},{"sha":"bc1cfb0a46fc06bfe9f0370e700f718139e2499c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -136,8 +136,19 @@ short getFlags() {\n      * Unauthorized access to ledger\n      */\n     public static final int EUA = 102;\n+\n     /**\n      * The server version is incompatible with the client\n      */\n     public static final int EBADVERSION = 103;\n+\n+    /**\n+     * Attempt to write to fenced ledger\n+     */\n+    public static final int EFENCED = 104;\n+\n+\n+    public static final short FLAG_NONE = 0x0;\n+    public static final short FLAG_DO_FENCING = 0x0001;\n+    public static final short FLAG_RECOVERY_ADD = 0x0002;\n }"},{"sha":"7876eb4ae290a2a75a36b33bb8cf449f50532c90","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":14,"deletions":3,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -187,17 +187,24 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n                                            h.getVersion(), h.getOpCode(), ledgerId, entryId));\n             return;\n         }\n-\n+        short flags = h.getFlags();\n         switch (h.getOpCode()) {\n         case BookieProtocol.ADDENTRY:\n             try {\n                 // LOG.debug(\"Master key: \" + new String(masterKey));\n-                bookie.addEntry(packet.slice(), this, src, masterKey);\n+                if ((flags & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n+                    bookie.recoveryAddEntry(packet.slice(), this, src, masterKey);\n+                } else {\n+                    bookie.addEntry(packet.slice(), this, src, masterKey);\n+                }\n             } catch (IOException e) {\n                 LOG.error(\"Error writing \" + entryId + \"@\" + ledgerId, e);\n                 src.sendResponse(buildResponse(BookieProtocol.EIO, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n+            } catch (BookieException.LedgerFencedException lfe) {\n+                LOG.error(\"Attempt to write to fenced ledger\", lfe);\n+                src.sendResponse(buildResponse(BookieProtocol.EFENCED, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n             } catch (BookieException e) {\n-                LOG.error(\"Unauthorized access to ledger \" + ledgerId);\n+                LOG.error(\"Unauthorized access to ledger \" + ledgerId, e);\n                 src.sendResponse(buildResponse(BookieProtocol.EUA, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n             }\n             break;\n@@ -206,6 +213,10 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n             LOG.debug(\"Received new read request: \" + ledgerId + \", \" + entryId);\n             int errorCode = BookieProtocol.EIO;\n             try {\n+                if ((flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {\n+                    LOG.warn(\"Ledger \" + ledgerId + \" fenced by \" + src.getPeerName());\n+                    bookie.fenceLedger(ledgerId);\n+                }\n                 rsp[1] = bookie.readEntry(ledgerId, entryId);\n                 LOG.debug(\"##### Read entry ##### \" + rsp[1].remaining());\n                 errorCode = BookieProtocol.EOK;"},{"sha":"5395acf64a43c86430792dab39fd0b4464e0a216","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -346,7 +346,7 @@ public int getSessionTimeout() {\n             return sessionTimeout;\n         }\n \n-        String peerName;\n+        String peerName = null;\n \n         public Cnxn(SocketChannel sock, SelectionKey sk) throws IOException {\n             this.sock = sock;\n@@ -371,6 +371,13 @@ public String toString() {\n             return \"NIOServerCnxn object with sock = \" + sock + \" and sk = \" + sk;\n         }\n \n+        public String getPeerName() {\n+            if (peerName == null) {\n+                peerName = sock.socket().toString();\n+            }\n+            return peerName;\n+        }\n+\n         boolean closed;\n \n         /*"},{"sha":"8d060cbf4771f41bed0ca0ca4d563516f70cc1e1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":20,"deletions":11,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -211,8 +211,7 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n      * @param ctx\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n-                  Object ctx) {\n-\n+                  Object ctx, final int options) {\n         final int entrySize = toSend.readableBytes();\n \n         // if (totalBytesOutstanding.get() > maxMemory) {\n@@ -231,7 +230,7 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n         ChannelBuffer header = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n         header.writeInt(totalHeaderSize - 4 + entrySize);\n         header.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION, \n-                                         BookieProtocol.ADDENTRY, (short)0).toInt());\n+                                         BookieProtocol.ADDENTRY, (short)options).toInt());\n         header.writeBytes(masterKey);\n \n         ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer(header, toSend);\n@@ -254,8 +253,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \n     }\n \n-    public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n-\n+    public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx, final int options) {\n         final CompletionKey key = new CompletionKey(ledgerId, entryId);\n         readCompletions.put(key, new ReadCompletion(cb, ctx));\n \n@@ -266,8 +264,9 @@ public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback\n \n         ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n         tmpEntry.writeInt(totalHeaderSize - 4);\n+\n         tmpEntry.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION, \n-                                           BookieProtocol.READENTRY, (short)0).toInt());\n+                                           BookieProtocol.READENTRY, (short)options).toInt());\n         tmpEntry.writeLong(ledgerId);\n         tmpEntry.writeLong(entryId);\n \n@@ -466,14 +465,21 @@ void handleAddResponse(long ledgerId, long entryId, int rc) {\n         // convert to BKException code because thats what the uppper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n-        if (rc != BookieProtocol.EOK) {\n+        switch (rc) {\n+        case BookieProtocol.EOK:\n+            rc = BKException.Code.OK;\n+            break;\n+        case BookieProtocol.EBADVERSION:\n+            rc = BKException.Code.ProtocolVersionException;\n+            break;\n+        case BookieProtocol.EFENCED:\n+            rc = BKException.Code.LedgerFencedException;\n+            break;\n+        default: \n             LOG.error(\"Add for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n                       + \" with code: \" + rc);\n             rc = BKException.Code.WriteException;\n-        } else if (rc == BookieProtocol.EBADVERSION) {\n-            rc = BKException.Code.ProtocolVersionException;\n-        } else {\n-            rc = BKException.Code.OK;\n+            break;\n         }\n \n         AddCompletion ac;\n@@ -584,6 +590,9 @@ public int hashCode() {\n             return ((int) ledgerId << 16) ^ ((int) entryId);\n         }\n \n+        public String toString() {\n+            return String.format(\"LedgerEntry(%d, %d)\", ledgerId, entryId);\n+        }\n     }\n \n }"},{"sha":"1d498ee8b323379608505977ef3f0d1e3ff8b19b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -43,6 +43,7 @@\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -76,10 +77,11 @@ public SyncObject() {\n     // Object used for implementing the Bookie RecoverCallback for this jUnit\n     // test. This verifies that the operation completed successfully.\n     class BookieRecoverCallback implements RecoverCallback {\n+        boolean success = false;\n         @Override\n         public void recoverComplete(int rc, Object ctx) {\n             LOG.info(\"Recovered bookie operation completed with rc: \" + rc);\n-            assertTrue(rc == Code.OK.intValue());\n+            success = rc == Code.OK.intValue();\n             SyncObject sync = (SyncObject) ctx;\n             synchronized (sync) {\n                 sync.value = true;\n@@ -278,6 +280,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n             while (sync.value == false) {\n                 sync.wait();\n             }\n+            assertTrue(bookieRecoverCb.success);\n         }\n \n         // Verify the recovered ledger entries are okay.\n@@ -333,6 +336,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n             while (sync.value == false) {\n                 sync.wait();\n             }\n+            assertTrue(bookieRecoverCb.success);\n         }\n \n         // Verify the recovered ledger entries are okay.\n@@ -486,7 +490,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n             ReplicationVerificationCallback cb = new ReplicationVerificationCallback(numRequests);\n             for (long i = startEntryId; i < endEntryId; i++) {\n                 for (InetSocketAddress addr : e.getValue()) {\n-                    bkc.bookieClient.readEntry(addr, lh.getId(), i, cb, addr);\n+                    bkc.bookieClient.readEntry(addr, lh.getId(), i, cb, addr, BookieProtocol.FLAG_NONE);\n                 }\n             }\n "},{"sha":"ae8cab09059341625d9ca0368b0b0791b705971b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"added","additions":343,"deletions":0,"changes":343,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -0,0 +1,343 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.junit.*;\n+import java.net.InetSocketAddress;\n+import java.util.Enumeration;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.BaseTestCase;\n+\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * This unit test tests ledger fencing;\n+ *\n+ */\n+public class TestFencing extends BaseTestCase {\n+    static Logger LOG = Logger.getLogger(TestFencing.class);\n+\n+    DigestType digestType;\n+\n+    public TestFencing(DigestType digestType) {\n+        super(10);\n+        this.digestType = digestType;\n+    }\n+\n+    /**\n+     * Basic fencing test. Create ledger, write to it,\n+     * open ledger, write again (should fail).\n+     */\n+    @Test\n+    public void testBasicFencing() throws Exception {\n+        /*\n+         * Create ledger.\n+         */\n+        LedgerHandle writelh = null;\n+        writelh = bkc.createLedger(digestType, \"\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i = 0; i < 10; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        /*\n+         * Try to open ledger.\n+         */\n+        LedgerHandle readlh = bkc.openLedger(writelh.getId(), digestType, \"\".getBytes());\n+        // should have triggered recovery and fencing\n+        \n+        try {\n+            writelh.addEntry(tmp.getBytes());\n+            LOG.error(\"Should have thrown an exception\");\n+            fail(\"Should have thrown an exception when trying to write\");\n+        } catch (BKException.BKLedgerFencedException e) {\n+            // correct behaviour\n+        }\n+                \n+        /*\n+         * Check if has recovered properly.\n+         */\n+        assertTrue(\"Has not recovered correctly: \" + readlh.getLastAddConfirmed() \n+                   + \" original \" + writelh.getLastAddConfirmed(),\n+                   readlh.getLastAddConfirmed() == writelh.getLastAddConfirmed());\n+    }\n+\n+    private static int threadCount = 0;\n+\n+    class LedgerOpenThread extends Thread {\n+        private final long ledgerId;\n+        private long lastConfirmedEntry = 0;\n+\n+        \n+        private final DigestType digestType;\n+        private final CyclicBarrier barrier;\n+\n+        LedgerOpenThread (DigestType digestType, long ledgerId, CyclicBarrier barrier)\n+                throws Exception {\n+            super(\"TestFencing-LedgerOpenThread-\" + threadCount++);\n+            this.ledgerId = ledgerId;\n+            this.digestType = digestType;\n+            this.barrier = barrier;\n+        }\n+        \n+        @Override\n+        public void run() {\n+            LedgerHandle lh = null;\n+            BookKeeper bk = null;\n+            try {\n+                barrier.await();\n+                while(true) {\n+                    try {\n+                        bk = new BookKeeper(bkc.getZkHandle());\n+                        \n+                        lh = bk.openLedger(ledgerId, \n+                                           digestType, \"\".getBytes());\n+                        lastConfirmedEntry = lh.getLastAddConfirmed();\n+                        lh.close();\n+                        break;\n+                    } catch (BKException.ZKException zke) {\n+                        LOG.info(\"Contention with someone else recovering\");\n+                    } catch (BKException.BKLedgerRecoveryException bkre) {\n+                        LOG.info(\"Contention with someone else recovering\");\n+                    } finally {\n+                        if (lh != null) {\n+                            lh.close();\n+                        }\n+                        if (bk != null) {\n+                            bk.close();\n+                            bk = null;\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                // just exit, test should spot bad last add confirmed\n+                LOG.error(\"Exception occurred \", e);\n+            }\n+            LOG.info(\"Thread exiting, lastConfirmedEntry = \" + lastConfirmedEntry);\n+        }\n+\n+        long getLastConfirmedEntry() {\n+            return lastConfirmedEntry;\n+        }\n+    }\n+\n+    /**\n+     * Try to open a ledger many times in parallel.\n+     * All opens should result in a ledger with an equals number of \n+     * entries.\n+     */\n+    @Test\n+    public void testManyOpenParallel() throws Exception {\n+        /*\n+         * Create ledger.\n+         */\n+        final LedgerHandle writelh = bkc.createLedger(digestType, \"\".getBytes());\n+\n+        final String tmp = \"BookKeeper is cool!\";\n+        final CountDownLatch latch = new CountDownLatch(100);\n+        Thread writethread = new Thread() {\n+                public void run() {\n+                    try {\n+                        while (true) {\n+                            writelh.addEntry(tmp.getBytes());\n+                            latch.countDown();\n+                        }\n+                    } catch (Exception e) {\n+                        LOG.info(\"Exception adding entry\", e);\n+                    }\n+                }\n+            };\n+        writethread.start();\n+\n+        final int numRecovery = 100;\n+        CyclicBarrier barrier = new CyclicBarrier(numRecovery+1);\n+        LedgerOpenThread threads[] = new LedgerOpenThread[numRecovery];\n+        for (int i = 0; i < numRecovery; i++) {\n+            threads[i] = new LedgerOpenThread(digestType, writelh.getId(), barrier);\n+            threads[i].start();\n+        }\n+        latch.await();\n+        barrier.await(); // should trigger threads to go\n+\n+        writethread.join();\n+        long lastConfirmed = writelh.getLastAddConfirmed();\n+        \n+        for (int i = 0; i < numRecovery; i++) {\n+            threads[i].join();\n+            assertTrue(\"Added confirmed is incorrect\", \n+                       lastConfirmed <= threads[i].getLastConfirmedEntry());\n+        }\n+    }\n+\n+    /**\n+     * Test that opening a ledger in norecovery mode\n+     * doesn't fence off a ledger\n+     */\n+    @Test\n+    public void testNoRecoveryOpen() throws Exception {\n+        /*\n+         * Create ledger.\n+         */\n+        LedgerHandle writelh = null;\n+        writelh = bkc.createLedger(digestType, \"\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        /*\n+         * Try to open ledger.\n+         */\n+        LedgerHandle readlh = bkc.openLedgerNoRecovery(writelh.getId(), \n+                                                        digestType, \"\".getBytes());\n+        // should not have triggered recovery and fencing\n+        \n+        writelh.addEntry(tmp.getBytes());\n+        long numReadable = readlh.getLastAddConfirmed();\n+        LOG.error(\"numRead \" + numReadable);\n+        Enumeration<LedgerEntry> entries = readlh.readEntries(1, numReadable);\n+        try {\n+            readlh.readEntries(numReadable+1, numReadable+1);\n+            fail(\"Shouldn't have been able to read this far\");\n+        } catch (BKException.BKReadException e) {\n+            // all is good\n+        }\n+\n+        writelh.addEntry(tmp.getBytes());\n+        long numReadable2 = readlh.getLastAddConfirmed();\n+        assertEquals(\"Number of readable entries hasn't changed\", numReadable2, numReadable);\n+        readlh.close();\n+\n+        writelh.addEntry(tmp.getBytes());\n+        writelh.close();\n+    }\n+\n+    /**\n+     * create a ledger and write entries. \n+     * kill a bookie in the ensemble. Recover.\n+     * Fence the ledger. Kill another bookie. Recover.\n+     */\n+    @Test\n+    public void testFencingInteractionWithBookieRecovery() throws Exception {\n+        System.setProperty(\"digestType\", digestType.toString());\n+        System.setProperty(\"passwd\", \"testPasswd\");\n+\n+        BookKeeperAdmin admin = new BookKeeperAdmin(HOSTPORT);\n+\n+        LedgerHandle writelh = bkc.createLedger(digestType, \"testPasswd\".getBytes());\n+        \n+        String tmp = \"Foobar\";\n+        \n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        InetSocketAddress bookieToKill \n+            = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n+        killBookie(bookieToKill);\n+        admin.recoverBookieData(bookieToKill, null);\n+        \n+        /* TODO: uncomment this when BOOKKEEPER-112 is\n+           fixed\n+           \n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+        */\n+        \n+        LedgerHandle readlh = bkc.openLedger(writelh.getId(), \n+                                             digestType, \"testPasswd\".getBytes());\n+        try {\n+            writelh.addEntry(tmp.getBytes());\n+            LOG.error(\"Should have thrown an exception\");\n+            fail(\"Should have thrown an exception when trying to write\");\n+        } catch (BKException.BKLedgerFencedException e) {\n+            // correct behaviour\n+        }\n+\n+        readlh.close();\n+        try {\n+            writelh.close();\n+            fail(\"Should fail trying to update metadata\");\n+        } catch (BKException.ZKException e) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * create a ledger and write entries. \n+     * Fence the ledger. Kill a bookie. Recover.\n+     * Ensure that recover doesn't reallow adding\n+     */\n+    @Test\n+    public void testFencingInteractionWithBookieRecovery2() throws Exception {\n+        System.setProperty(\"digestType\", digestType.toString());\n+        System.setProperty(\"passwd\", \"testPasswd\");\n+\n+        BookKeeperAdmin admin = new BookKeeperAdmin(HOSTPORT);\n+\n+        LedgerHandle writelh = bkc.createLedger(digestType, \"testPasswd\".getBytes());\n+        \n+        String tmp = \"Foobar\";\n+        \n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        LedgerHandle readlh = bkc.openLedger(writelh.getId(), \n+                                             digestType, \"testPasswd\".getBytes());\n+        // should be fenced by now\n+        InetSocketAddress bookieToKill \n+            = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n+        killBookie(bookieToKill);\n+        admin.recoverBookieData(bookieToKill, null);\n+\n+        try {\n+            writelh.addEntry(tmp.getBytes());\n+            LOG.error(\"Should have thrown an exception\");\n+            fail(\"Should have thrown an exception when trying to write\");\n+        } catch (BKException.BKLedgerFencedException e) {\n+            // correct behaviour\n+        }\n+\n+        readlh.close();\n+\n+        try {\n+            writelh.close();\n+            fail(\"Should fail trying to update metadata\");\n+        } catch (BKException.ZKException e) {\n+            // correct behaviour\n+        }\n+    }\n+}"},{"sha":"717d99c7e60d86790b867db8064daaca4333234d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -72,7 +72,7 @@ public void operationComplete(int rc, Void result) {\n         connectLatch.await(5, TimeUnit.SECONDS);\n         \n         assertEquals(\"client not connected\", BKException.Code.OK, outerrc.get());\n-        outerrc.set(-1);\n+        outerrc.set(-1000);\n         final CountDownLatch readLatch = new CountDownLatch(1);\n         ReadEntryCallback cb = new ReadEntryCallback() {\n                 public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {"},{"sha":"728c35df5d7dcecdfcc18620e0162cbc2086406a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -125,6 +125,19 @@ public void setUp() throws Exception {\n         }\n     }\n \n+    public void killBookie(InetSocketAddress addr) throws InterruptedException {\n+        BookieServer toRemove = null;\n+        for (BookieServer server : bs) {\n+            if (server.getLocalAddress().equals(addr)) {\n+                server.shutdown();\n+                toRemove = server;\n+            }\n+        }\n+        if (toRemove != null) {\n+            bs.remove(toRemove);\n+        }\n+    }\n+\n     /**\n      * Restart bookie servers\n      *"},{"sha":"581f3ade5b2e436b0d8514b509a251b4c677d216","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":20,"deletions":19,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -34,6 +34,7 @@\n import org.junit.Test;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -125,84 +126,84 @@ public void testWriteGaps() throws Exception {\n         BookieClient bc = new BookieClient(channelFactory, executor);\n         ChannelBuffer bb;\n         bb = createByteBuffer(1, 1, 1);\n-        bc.addEntry(addr, 1, passwd, 1, bb, wrcb, null);\n+        bc.addEntry(addr, 1, passwd, 1, bb, wrcb, null, BookieProtocol.FLAG_NONE);\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 1, recb, arc);\n+            bc.readEntry(addr, 1, 1, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(1, arc.entry.getInt());\n         }\n         bb = createByteBuffer(2, 1, 2);\n-        bc.addEntry(addr, 1, passwd, 2, bb, wrcb, null);\n+        bc.addEntry(addr, 1, passwd, 2, bb, wrcb, null, BookieProtocol.FLAG_NONE);\n         bb = createByteBuffer(3, 1, 3);\n-        bc.addEntry(addr, 1, passwd, 3, bb, wrcb, null);\n+        bc.addEntry(addr, 1, passwd, 3, bb, wrcb, null, BookieProtocol.FLAG_NONE);\n         bb = createByteBuffer(5, 1, 5);\n-        bc.addEntry(addr, 1, passwd, 5, bb, wrcb, null);\n+        bc.addEntry(addr, 1, passwd, 5, bb, wrcb, null, BookieProtocol.FLAG_NONE);\n         bb = createByteBuffer(7, 1, 7);\n-        bc.addEntry(addr, 1, passwd, 7, bb, wrcb, null);\n+        bc.addEntry(addr, 1, passwd, 7, bb, wrcb, null, BookieProtocol.FLAG_NONE);\n         synchronized (notifyObject) {\n             bb = createByteBuffer(11, 1, 11);\n-            bc.addEntry(addr, 1, passwd, 11, bb, wrcb, notifyObject);\n+            bc.addEntry(addr, 1, passwd, 11, bb, wrcb, notifyObject, BookieProtocol.FLAG_NONE);\n             notifyObject.wait();\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 6, recb, arc);\n+            bc.readEntry(addr, 1, 6, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 7, recb, arc);\n+            bc.readEntry(addr, 1, 7, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(7, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 1, recb, arc);\n+            bc.readEntry(addr, 1, 1, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(1, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 2, recb, arc);\n+            bc.readEntry(addr, 1, 2, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(2, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 3, recb, arc);\n+            bc.readEntry(addr, 1, 3, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(3, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 4, recb, arc);\n+            bc.readEntry(addr, 1, 4, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 11, recb, arc);\n+            bc.readEntry(addr, 1, 11, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(11, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 5, recb, arc);\n+            bc.readEntry(addr, 1, 5, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(5, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 10, recb, arc);\n+            bc.readEntry(addr, 1, 10, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 12, recb, arc);\n+            bc.readEntry(addr, 1, 12, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 13, recb, arc);\n+            bc.readEntry(addr, 1, 13, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n@@ -224,7 +225,7 @@ public void testNoLedger() throws Exception {\n         InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", port);\n         BookieClient bc = new BookieClient(channelFactory, executor);\n         synchronized (arc) {\n-            bc.readEntry(addr, 2, 13, recb, arc);\n+            bc.readEntry(addr, 2, 13, recb, arc, BookieProtocol.FLAG_NONE);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }"},{"sha":"c12c041b675d765884118e6dcaca798e50ccd478","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -28,6 +28,7 @@\n import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.log4j.Logger;\n@@ -76,7 +77,7 @@ void write(long ledgerId, long entry, byte[] data, InetSocketAddress addr, Write\n         byte[] passwd = new byte[20];\n         Arrays.fill(passwd, (byte) 'a');\n \n-        client.addEntry(addr, ledgerId, passwd, entry, ChannelBuffers.wrappedBuffer(data), cb, ctx);\n+        client.addEntry(addr, ledgerId, passwd, entry, ChannelBuffers.wrappedBuffer(data), cb, ctx, BookieProtocol.FLAG_NONE);\n     }\n \n     public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {"},{"sha":"ff1462d8d62f41cbd22ce2473d8f7eb98b1d9a4c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java?ref=4d9f0c0ebe8614e0190c5df5bbd68c6fa1c05180","patch":"@@ -81,7 +81,7 @@ public void writeComplete(int rc, long ledgerId, long entryId,\n             buffer.put(passwd);\n             buffer.rewind();\n             ChannelBuffer toSend = ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer.slice()), ChannelBuffers.wrappedBuffer(data));\n-            bkc.addEntry(addr, ledgerId, passwd, i, toSend, callback, System.currentTimeMillis());\n+            bkc.addEntry(addr, ledgerId, passwd, i, toSend, callback, System.currentTimeMillis(), 0);\n         }\n \n     }"}]}

