{"sha":"4d9f3d32a063975303f42a7108cbd4892062ab89","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0ZDlmM2QzMmEwNjM5NzUzMDNmNDJhNzEwOGNiZDQ4OTIwNjJhYjg5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-06T11:01:36Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-06T11:01:36Z"},"message":"BOOKKEEPER-259: Create a topic manager using versioned write for leader election (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1369778 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"10409eea6826cd38c801bf544ef49be5db9ca295","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/10409eea6826cd38c801bf544ef49be5db9ca295"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4d9f3d32a063975303f42a7108cbd4892062ab89","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4d9f3d32a063975303f42a7108cbd4892062ab89","html_url":"https://github.com/apache/bookkeeper/commit/4d9f3d32a063975303f42a7108cbd4892062ab89","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4d9f3d32a063975303f42a7108cbd4892062ab89/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"41b399cd2a4c85fa0b077f0a7749f5cca4e9c423","url":"https://api.github.com/repos/apache/bookkeeper/commits/41b399cd2a4c85fa0b077f0a7749f5cca4e9c423","html_url":"https://github.com/apache/bookkeeper/commit/41b399cd2a4c85fa0b077f0a7749f5cca4e9c423"}],"stats":{"total":3085,"additions":2878,"deletions":207},"files":[{"sha":"9a6ac619eea10d3b0b078fc4ae9f14a19d532cd3","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -64,6 +64,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-343: Failed to register hedwig JMX beans in test cases (sijie via ivank)\n \n+        BOOKKEEPER-259: Create a topic manager using versioned write for leader election (sijie via ivank)\n+\n     IMPROVEMENTS:\n \n       bookkeeper-server:"},{"sha":"626d273bf2932b3d58a025dfbbc65486f86ec7ad","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -62,6 +62,10 @@ public static PubSubException create(StatusCode code, String msg) {\n             return new NoSubscriptionStateException(msg);\n         } else if (code == StatusCode.SUBSCRIPTION_STATE_EXISTS) {\n             return new SubscriptionStateExistsException(msg);\n+        } else if (code == StatusCode.NO_TOPIC_OWNER_INFO) {\n+            return new NoTopicOwnerInfoException(msg);\n+        } else if (code == StatusCode.TOPIC_OWNER_INFO_EXISTS) {\n+            return new TopicOwnerInfoExistsException(msg);\n         }\n         /*\n          * Insert new ones here\n@@ -162,6 +166,18 @@ public SubscriptionStateExistsException(String msg) {\n         }\n     }\n \n+    public static class NoTopicOwnerInfoException extends PubSubException {\n+        public NoTopicOwnerInfoException(String msg) {\n+            super(StatusCode.NO_TOPIC_OWNER_INFO, msg);\n+        }\n+    }\n+\n+    public static class TopicOwnerInfoExistsException extends PubSubException {\n+        public TopicOwnerInfoExistsException(String msg) {\n+            super(StatusCode.TOPIC_OWNER_INFO_EXISTS, msg);\n+        }\n+    }\n+\n     /*\n      * Insert new ones here\n      */"},{"sha":"53b197220b925889c4e2e50c93898bb7ef84e915","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":849,"deletions":20,"changes":869,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -172,8 +172,10 @@ private OperationType(int index, int value) {\n     TOPIC_PERSISTENCE_INFO_EXISTS(12, 522),\n     NO_SUBSCRIPTION_STATE(13, 523),\n     SUBSCRIPTION_STATE_EXISTS(14, 524),\n-    UNEXPECTED_CONDITION(15, 600),\n-    COMPOSITE(16, 700),\n+    NO_TOPIC_OWNER_INFO(15, 525),\n+    TOPIC_OWNER_INFO_EXISTS(16, 526),\n+    UNEXPECTED_CONDITION(17, 600),\n+    COMPOSITE(18, 700),\n     ;\n     \n     public static final int SUCCESS_VALUE = 0;\n@@ -191,6 +193,8 @@ private OperationType(int index, int value) {\n     public static final int TOPIC_PERSISTENCE_INFO_EXISTS_VALUE = 522;\n     public static final int NO_SUBSCRIPTION_STATE_VALUE = 523;\n     public static final int SUBSCRIPTION_STATE_EXISTS_VALUE = 524;\n+    public static final int NO_TOPIC_OWNER_INFO_VALUE = 525;\n+    public static final int TOPIC_OWNER_INFO_EXISTS_VALUE = 526;\n     public static final int UNEXPECTED_CONDITION_VALUE = 600;\n     public static final int COMPOSITE_VALUE = 700;\n     \n@@ -214,6 +218,8 @@ public static StatusCode valueOf(int value) {\n         case 522: return TOPIC_PERSISTENCE_INFO_EXISTS;\n         case 523: return NO_SUBSCRIPTION_STATE;\n         case 524: return SUBSCRIPTION_STATE_EXISTS;\n+        case 525: return NO_TOPIC_OWNER_INFO;\n+        case 526: return TOPIC_OWNER_INFO_EXISTS;\n         case 600: return UNEXPECTED_CONDITION;\n         case 700: return COMPOSITE;\n         default: return null;\n@@ -246,7 +252,7 @@ public StatusCode findValueByNumber(int number) {\n     }\n     \n     private static final StatusCode[] VALUES = {\n-      SUCCESS, MALFORMED_REQUEST, NO_SUCH_TOPIC, CLIENT_ALREADY_SUBSCRIBED, CLIENT_NOT_SUBSCRIBED, COULD_NOT_CONNECT, TOPIC_BUSY, NOT_RESPONSIBLE_FOR_TOPIC, SERVICE_DOWN, UNCERTAIN_STATE, BAD_VERSION, NO_TOPIC_PERSISTENCE_INFO, TOPIC_PERSISTENCE_INFO_EXISTS, NO_SUBSCRIPTION_STATE, SUBSCRIPTION_STATE_EXISTS, UNEXPECTED_CONDITION, COMPOSITE, \n+      SUCCESS, MALFORMED_REQUEST, NO_SUCH_TOPIC, CLIENT_ALREADY_SUBSCRIBED, CLIENT_NOT_SUBSCRIBED, COULD_NOT_CONNECT, TOPIC_BUSY, NOT_RESPONSIBLE_FOR_TOPIC, SERVICE_DOWN, UNCERTAIN_STATE, BAD_VERSION, NO_TOPIC_PERSISTENCE_INFO, TOPIC_PERSISTENCE_INFO_EXISTS, NO_SUBSCRIPTION_STATE, SUBSCRIPTION_STATE_EXISTS, NO_TOPIC_OWNER_INFO, TOPIC_OWNER_INFO_EXISTS, UNEXPECTED_CONDITION, COMPOSITE, \n     };\n     \n     public static StatusCode valueOf(\n@@ -10427,6 +10433,800 @@ public Builder clearManagerVersion() {\n     // @@protoc_insertion_point(class_scope:Hedwig.ManagerMeta)\n   }\n   \n+  public interface HubInfoDataOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required string hostname = 2;\n+    boolean hasHostname();\n+    String getHostname();\n+    \n+    // required uint64 czxid = 3;\n+    boolean hasCzxid();\n+    long getCzxid();\n+  }\n+  public static final class HubInfoData extends\n+      com.google.protobuf.GeneratedMessage\n+      implements HubInfoDataOrBuilder {\n+    // Use HubInfoData.newBuilder() to construct.\n+    private HubInfoData(Builder builder) {\n+      super(builder);\n+    }\n+    private HubInfoData(boolean noInit) {}\n+    \n+    private static final HubInfoData defaultInstance;\n+    public static HubInfoData getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public HubInfoData getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubInfoData_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubInfoData_fieldAccessorTable;\n+    }\n+    \n+    private int bitField0_;\n+    // required string hostname = 2;\n+    public static final int HOSTNAME_FIELD_NUMBER = 2;\n+    private java.lang.Object hostname_;\n+    public boolean hasHostname() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public String getHostname() {\n+      java.lang.Object ref = hostname_;\n+      if (ref instanceof String) {\n+        return (String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs = \n+            (com.google.protobuf.ByteString) ref;\n+        String s = bs.toStringUtf8();\n+        if (com.google.protobuf.Internal.isValidUtf8(bs)) {\n+          hostname_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    private com.google.protobuf.ByteString getHostnameBytes() {\n+      java.lang.Object ref = hostname_;\n+      if (ref instanceof String) {\n+        com.google.protobuf.ByteString b = \n+            com.google.protobuf.ByteString.copyFromUtf8((String) ref);\n+        hostname_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+    \n+    // required uint64 czxid = 3;\n+    public static final int CZXID_FIELD_NUMBER = 3;\n+    private long czxid_;\n+    public boolean hasCzxid() {\n+      return ((bitField0_ & 0x00000002) == 0x00000002);\n+    }\n+    public long getCzxid() {\n+      return czxid_;\n+    }\n+    \n+    private void initFields() {\n+      hostname_ = \"\";\n+      czxid_ = 0L;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasHostname()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!hasCzxid()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeBytes(2, getHostnameBytes());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        output.writeUInt64(3, czxid_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(2, getHostnameBytes());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeUInt64Size(3, czxid_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubInfoData parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.hedwig.protocol.PubSubProtocol.HubInfoData prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.hedwig.protocol.PubSubProtocol.HubInfoDataOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubInfoData_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubInfoData_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        hostname_ = \"\";\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        czxid_ = 0L;\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.getDescriptor();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.HubInfoData getDefaultInstanceForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.getDefaultInstance();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.HubInfoData build() {\n+        org.apache.hedwig.protocol.PubSubProtocol.HubInfoData result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.hedwig.protocol.PubSubProtocol.HubInfoData buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.hedwig.protocol.PubSubProtocol.HubInfoData result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.HubInfoData buildPartial() {\n+        org.apache.hedwig.protocol.PubSubProtocol.HubInfoData result = new org.apache.hedwig.protocol.PubSubProtocol.HubInfoData(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.hostname_ = hostname_;\n+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.czxid_ = czxid_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.hedwig.protocol.PubSubProtocol.HubInfoData) {\n+          return mergeFrom((org.apache.hedwig.protocol.PubSubProtocol.HubInfoData)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.HubInfoData other) {\n+        if (other == org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.getDefaultInstance()) return this;\n+        if (other.hasHostname()) {\n+          setHostname(other.getHostname());\n+        }\n+        if (other.hasCzxid()) {\n+          setCzxid(other.getCzxid());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasHostname()) {\n+          \n+          return false;\n+        }\n+        if (!hasCzxid()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 18: {\n+              bitField0_ |= 0x00000001;\n+              hostname_ = input.readBytes();\n+              break;\n+            }\n+            case 24: {\n+              bitField0_ |= 0x00000002;\n+              czxid_ = input.readUInt64();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required string hostname = 2;\n+      private java.lang.Object hostname_ = \"\";\n+      public boolean hasHostname() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public String getHostname() {\n+        java.lang.Object ref = hostname_;\n+        if (!(ref instanceof String)) {\n+          String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();\n+          hostname_ = s;\n+          return s;\n+        } else {\n+          return (String) ref;\n+        }\n+      }\n+      public Builder setHostname(String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000001;\n+        hostname_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearHostname() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        hostname_ = getDefaultInstance().getHostname();\n+        onChanged();\n+        return this;\n+      }\n+      void setHostname(com.google.protobuf.ByteString value) {\n+        bitField0_ |= 0x00000001;\n+        hostname_ = value;\n+        onChanged();\n+      }\n+      \n+      // required uint64 czxid = 3;\n+      private long czxid_ ;\n+      public boolean hasCzxid() {\n+        return ((bitField0_ & 0x00000002) == 0x00000002);\n+      }\n+      public long getCzxid() {\n+        return czxid_;\n+      }\n+      public Builder setCzxid(long value) {\n+        bitField0_ |= 0x00000002;\n+        czxid_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearCzxid() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        czxid_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:Hedwig.HubInfoData)\n+    }\n+    \n+    static {\n+      defaultInstance = new HubInfoData(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:Hedwig.HubInfoData)\n+  }\n+  \n+  public interface HubLoadDataOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required uint64 numTopics = 2;\n+    boolean hasNumTopics();\n+    long getNumTopics();\n+  }\n+  public static final class HubLoadData extends\n+      com.google.protobuf.GeneratedMessage\n+      implements HubLoadDataOrBuilder {\n+    // Use HubLoadData.newBuilder() to construct.\n+    private HubLoadData(Builder builder) {\n+      super(builder);\n+    }\n+    private HubLoadData(boolean noInit) {}\n+    \n+    private static final HubLoadData defaultInstance;\n+    public static HubLoadData getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public HubLoadData getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubLoadData_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubLoadData_fieldAccessorTable;\n+    }\n+    \n+    private int bitField0_;\n+    // required uint64 numTopics = 2;\n+    public static final int NUMTOPICS_FIELD_NUMBER = 2;\n+    private long numTopics_;\n+    public boolean hasNumTopics() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public long getNumTopics() {\n+      return numTopics_;\n+    }\n+    \n+    private void initFields() {\n+      numTopics_ = 0L;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasNumTopics()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeUInt64(2, numTopics_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeUInt64Size(2, numTopics_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.HubLoadData parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.hedwig.protocol.PubSubProtocol.HubLoadData prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.hedwig.protocol.PubSubProtocol.HubLoadDataOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubLoadData_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_HubLoadData_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.hedwig.protocol.PubSubProtocol.HubLoadData.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        numTopics_ = 0L;\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.HubLoadData.getDescriptor();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.HubLoadData getDefaultInstanceForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.HubLoadData.getDefaultInstance();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.HubLoadData build() {\n+        org.apache.hedwig.protocol.PubSubProtocol.HubLoadData result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.hedwig.protocol.PubSubProtocol.HubLoadData buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.hedwig.protocol.PubSubProtocol.HubLoadData result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.HubLoadData buildPartial() {\n+        org.apache.hedwig.protocol.PubSubProtocol.HubLoadData result = new org.apache.hedwig.protocol.PubSubProtocol.HubLoadData(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.numTopics_ = numTopics_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.hedwig.protocol.PubSubProtocol.HubLoadData) {\n+          return mergeFrom((org.apache.hedwig.protocol.PubSubProtocol.HubLoadData)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.HubLoadData other) {\n+        if (other == org.apache.hedwig.protocol.PubSubProtocol.HubLoadData.getDefaultInstance()) return this;\n+        if (other.hasNumTopics()) {\n+          setNumTopics(other.getNumTopics());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasNumTopics()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 16: {\n+              bitField0_ |= 0x00000001;\n+              numTopics_ = input.readUInt64();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required uint64 numTopics = 2;\n+      private long numTopics_ ;\n+      public boolean hasNumTopics() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public long getNumTopics() {\n+        return numTopics_;\n+      }\n+      public Builder setNumTopics(long value) {\n+        bitField0_ |= 0x00000001;\n+        numTopics_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearNumTopics() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        numTopics_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:Hedwig.HubLoadData)\n+    }\n+    \n+    static {\n+      defaultInstance = new HubLoadData(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:Hedwig.HubLoadData)\n+  }\n+  \n   private static com.google.protobuf.Descriptors.Descriptor\n     internal_static_Hedwig_Message_descriptor;\n   private static\n@@ -10517,6 +11317,16 @@ public Builder clearManagerVersion() {\n   private static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_Hedwig_ManagerMeta_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_Hedwig_HubInfoData_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_Hedwig_HubInfoData_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_Hedwig_HubLoadData_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_Hedwig_HubLoadData_fieldAccessorTable;\n   \n   public static com.google.protobuf.Descriptors.FileDescriptor\n       getDescriptor() {\n@@ -10577,23 +11387,26 @@ public Builder clearManagerVersion() {\n       \"eqIdIncluded\\030\\002 \\001(\\0132\\024.Hedwig.MessageSeqId\" +\n       \"\\\"3\\n\\014LedgerRanges\\022#\\n\\006ranges\\030\\001 \\003(\\0132\\023.Hedwi\",\n       \"g.LedgerRange\\\":\\n\\013ManagerMeta\\022\\023\\n\\013managerI\" +\n-      \"mpl\\030\\002 \\002(\\t\\022\\026\\n\\016managerVersion\\030\\003 \\002(\\r*\\\"\\n\\017Pro\" +\n-      \"tocolVersion\\022\\017\\n\\013VERSION_ONE\\020\\001*p\\n\\rOperati\" +\n-      \"onType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\\022\\013\\n\\007CO\" +\n-      \"NSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\\022\\022\\n\\016START_DELIVE\" +\n-      \"RY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005*\\260\\003\\n\\nStatusCode\\022\\013\" +\n-      \"\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\\n\\rN\" +\n-      \"O_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUBSCR\" +\n-      \"IBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\\n\\021C\" +\n-      \"OULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\\036\\n\\031\",\n-      \"NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVICE_\" +\n-      \"DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\020\\n\\013BAD_VER\" +\n-      \"SION\\020\\210\\004\\022\\036\\n\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\\004\\022\" +\n-      \"\\\"\\n\\035TOPIC_PERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025N\" +\n-      \"O_SUBSCRIPTION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_\" +\n-      \"STATE_EXISTS\\020\\214\\004\\022\\031\\n\\024UNEXPECTED_CONDITION\\020\" +\n-      \"\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apache.hedwig.\" +\n-      \"protocolH\\001\"\n+      \"mpl\\030\\002 \\002(\\t\\022\\026\\n\\016managerVersion\\030\\003 \\002(\\r\\\".\\n\\013Hub\" +\n+      \"InfoData\\022\\020\\n\\010hostname\\030\\002 \\002(\\t\\022\\r\\n\\005czxid\\030\\003 \\002(\" +\n+      \"\\004\\\" \\n\\013HubLoadData\\022\\021\\n\\tnumTopics\\030\\002 \\002(\\004*\\\"\\n\\017P\" +\n+      \"rotocolVersion\\022\\017\\n\\013VERSION_ONE\\020\\001*p\\n\\rOpera\" +\n+      \"tionType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\\022\\013\\n\\007\" +\n+      \"CONSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\\022\\022\\n\\016START_DELI\" +\n+      \"VERY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005*\\350\\003\\n\\nStatusCode\" +\n+      \"\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\\n\" +\n+      \"\\rNO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUBS\",\n+      \"CRIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\\n\" +\n+      \"\\021COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\\036\" +\n+      \"\\n\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVIC\" +\n+      \"E_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\020\\n\\013BAD_V\" +\n+      \"ERSION\\020\\210\\004\\022\\036\\n\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\" +\n+      \"\\004\\022\\\"\\n\\035TOPIC_PERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\" +\n+      \"\\025NO_SUBSCRIPTION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTIO\" +\n+      \"N_STATE_EXISTS\\020\\214\\004\\022\\030\\n\\023NO_TOPIC_OWNER_INFO\" +\n+      \"\\020\\215\\004\\022\\034\\n\\027TOPIC_OWNER_INFO_EXISTS\\020\\216\\004\\022\\031\\n\\024UNE\" +\n+      \"XPECTED_CONDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032\",\n+      \"org.apache.hedwig.protocolH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -10744,6 +11557,22 @@ public Builder clearManagerVersion() {\n               new java.lang.String[] { \"ManagerImpl\", \"ManagerVersion\", },\n               org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.class,\n               org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.Builder.class);\n+          internal_static_Hedwig_HubInfoData_descriptor =\n+            getDescriptor().getMessageTypes().get(18);\n+          internal_static_Hedwig_HubInfoData_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_Hedwig_HubInfoData_descriptor,\n+              new java.lang.String[] { \"Hostname\", \"Czxid\", },\n+              org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.class,\n+              org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.Builder.class);\n+          internal_static_Hedwig_HubLoadData_descriptor =\n+            getDescriptor().getMessageTypes().get(19);\n+          internal_static_Hedwig_HubLoadData_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_Hedwig_HubLoadData_descriptor,\n+              new java.lang.String[] { \"NumTopics\", },\n+              org.apache.hedwig.protocol.PubSubProtocol.HubLoadData.class,\n+              org.apache.hedwig.protocol.PubSubProtocol.HubLoadData.Builder.class);\n           return null;\n         }\n       };"},{"sha":"8c9f3e2da38ce2f6a662d09ab6b43a98313ce2ed","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -175,6 +175,8 @@ enum StatusCode{\n     TOPIC_PERSISTENCE_INFO_EXISTS = 522;\n     NO_SUBSCRIPTION_STATE = 523;\n     SUBSCRIPTION_STATE_EXISTS = 524;\n+    NO_TOPIC_OWNER_INFO = 525;\n+    TOPIC_OWNER_INFO_EXISTS = 526;\n \n     //For all unexpected error conditions\n     UNEXPECTED_CONDITION = 600;\n@@ -203,3 +205,12 @@ message ManagerMeta {\n     required string managerImpl = 2;\n     required uint32 managerVersion = 3;\n }\n+\n+message HubInfoData {\n+    required string hostname = 2;\n+    required uint64 czxid = 3;\n+}\n+\n+message HubLoadData {\n+    required uint64 numTopics = 2;\n+}"},{"sha":"c8c6610b2e7d04a5fca3b48ef350be6de58f9fd2","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -63,6 +63,7 @@\n     protected final static String RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL = \"retry_remote_subscribe_thread_run_interval\";\n \n     // manager related settings\n+    protected final static String METADATA_MANAGER_BASED_TOPIC_MANAGER_ENABLED = \"metadata_manager_based_topic_manager_enabled\";\n     protected final static String METADATA_MANAGER_FACTORY_CLASS = \"metadata_manager_factory_class\";\n \n     private static ClassLoader defaultLoader;\n@@ -321,6 +322,15 @@ public void validate() throws ConfigurationException {\n         // add other checks here\n     }\n \n+    /**\n+     * Whether enable metadata manager based topic manager.\n+     *\n+     * @return true if enabled metadata manager based topic manager.\n+     */\n+    public boolean isMetadataManagerBasedTopicManagerEnabled() {\n+        return conf.getBoolean(METADATA_MANAGER_BASED_TOPIC_MANAGER_ENABLED, false);\n+    }\n+\n     /**\n      * Get metadata manager factory class.\n      *"},{"sha":"8f99fce4630cbfd9082c3a7901493743ed8b11fa","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -80,6 +80,13 @@ protected abstract MetadataManagerFactory initialize(\n      */\n     public abstract SubscriptionDataManager newSubscriptionDataManager();\n \n+    /**\n+     * Create topic ownership manager.\n+     *\n+     * @return topic ownership manager.\n+     */\n+    public abstract TopicOwnershipManager newTopicOwnershipManager();\n+\n     /**\n      * Create new Metadata Manager Factory.\n      *"},{"sha":"52e9764e10df6eb9a1362945ed47aacd2a01dd00","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,100 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Manage topic ownership\n+ */\n+public interface TopicOwnershipManager extends Closeable {\n+\n+    /**\n+     * Read owner information of a topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param callback\n+     *          Callback to return hub info. If there is no owner info, return null;\n+     *          If there is data but not valid owner info, return a Versioned object with null hub info;\n+     *          If there is valid owner info, return versioned hub info.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void readOwnerInfo(ByteString topic, Callback<Versioned<HubInfo>> callback, Object ctx);\n+\n+    /**\n+     * Write owner info for a specified topic.\n+     * A new owner info would be created if there is no one existed before.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param owner\n+     *          Owner hub info\n+     * @param version\n+     *          Current version of owner info\n+     *          If <code>version</code> is null, create owner info.\n+     *          {@link PubSubException.TopicOwnerInfoExistsException} is returned when\n+     *          owner info existed before.\n+     *          If <code>version</code> is not null, the owner info is updated only when\n+     *          provided version equals to its current version.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoTopicOwnerInfoException} is returned when no owner info\n+     *          found to update.\n+     * @param callback\n+     *          Callback when owner info updated. New version would be returned if succeed to write.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void writeOwnerInfo(ByteString topic, HubInfo owner, Version version,\n+                               Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Delete owner info for a specified topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param version\n+     *          Current version of owner info\n+     *          If <code>version</code> is null, delete owner info no matter its current version.\n+     *          If <code>version</code> is not null, the owner info is deleted only when\n+     *          provided version equals to its current version.\n+     * @param callback\n+     *          Callback when owner info deleted.\n+     *          {@link PubSubException.NoTopicOwnerInfoException} is returned when no owner info.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match.\n+     * @param ctx\n+     *          Context of the callback.\n+     */\n+    public void deleteOwnerInfo(ByteString topic, Version version,\n+                                Callback<Void> callback, Object ctx);\n+}"},{"sha":"35426d30483d0cb097f5e55a3a44588d672e90a3","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","status":"modified","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -44,6 +44,7 @@\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n import org.apache.hedwig.zookeeper.ZkUtils;\n@@ -94,6 +95,11 @@ public SubscriptionDataManager newSubscriptionDataManager() {\n         return new ZkSubscriptionDataManagerImpl(cfg, zk);\n     }\n \n+    @Override\n+    public TopicOwnershipManager newTopicOwnershipManager() {\n+        return new ZkTopicOwnershipManagerImpl(cfg, zk);\n+    }\n+\n     /**\n      * ZooKeeper based topic persistence manager.\n      */\n@@ -556,4 +562,177 @@ private void reportFailure(PubSubException e) {\n             }, ctx);\n         }\n     }\n+\n+    /**\n+     * ZooKeeper base topic ownership manager.\n+     */\n+    static class ZkTopicOwnershipManagerImpl implements TopicOwnershipManager {\n+\n+        ZooKeeper zk;\n+        ServerConfiguration cfg;\n+\n+        ZkTopicOwnershipManagerImpl(ServerConfiguration conf, ZooKeeper zk) {\n+            this.cfg = conf;\n+            this.zk = zk;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing in zookeeper based impl\n+        }\n+\n+        /**\n+         * Return znode path to store topic owner.\n+         *\n+         * @param topic\n+         *          Topic Name\n+         * @return znode path to store topic owner.\n+         */\n+        String hubPath(ByteString topic) {\n+            return cfg.getZkTopicPath(new StringBuilder(), topic).append(\"/hub\").toString();\n+        }\n+\n+        @Override\n+        public void readOwnerInfo(final ByteString topic, final Callback<Versioned<HubInfo>> callback, Object ctx) {\n+            String ownerPath = hubPath(topic);\n+            zk.getData(ownerPath, false, new SafeAsyncZKCallback.DataCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    if (Code.NONODE.intValue() == rc) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    if (Code.OK.intValue() != rc) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read ownership for topic: \"\n+                                            + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                    HubInfo owner = null;\n+                    try {\n+                        owner = HubInfo.parse(new String(data));\n+                    } catch (HubInfo.InvalidHubInfoException ihie) {\n+                        logger.warn(\"Failed to parse hub info for topic \" + topic.toStringUtf8() + \" : \", ihie);\n+                    }\n+                    int version = stat.getVersion();\n+                    callback.operationFinished(ctx, new Versioned<HubInfo>(owner, new ZkVersion(version)));\n+                    return;\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void writeOwnerInfo(final ByteString topic, final HubInfo owner, final Version version,\n+                                   final Callback<Version> callback, Object ctx) {\n+            if (null == version) {\n+                createOwnerInfo(topic, owner, callback, ctx);\n+                return;\n+            }\n+\n+            if (!(version instanceof ZkVersion)) {\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                              \"Invalid version provided to update owner info for topic \" + topic.toStringUtf8()));\n+                return;\n+            }\n+\n+            int znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+            zk.setData(hubPath(topic), owner.toString().getBytes(), znodeVersion,\n+                       new SafeAsyncZKCallback.StatCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO,\n+                                                      \"No owner info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (rc == Code.BadVersion) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to update owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (Code.OK.intValue() == rc) {\n+                        callback.operationFinished(ctx, new ZkVersion(stat.getVersion()));\n+                        return;\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                            \"Failed to update ownership of topic \" + topic.toStringUtf8() +\n+                            \" to \" + owner, path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        protected void createOwnerInfo(final ByteString topic, final HubInfo owner,\n+                                       final Callback<Version> callback, Object ctx) {\n+            String ownerPath = hubPath(topic);\n+            ZkUtils.createFullPathOptimistic(zk, ownerPath, owner.toString().getBytes(), Ids.OPEN_ACL_UNSAFE,\n+                                             CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                    if (Code.OK.intValue() == rc) {\n+                        // assume the initial version is 0\n+                        callback.operationFinished(ctx, new ZkVersion(0));\n+                        return;\n+                    } else if (Code.NODEEXISTS.intValue() == rc) {\n+                        // node existed\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.TOPIC_OWNER_INFO_EXISTS,\n+                                                      \"Owner info of topic \" + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Failed to create znode for ownership of topic: \"\n+                                                + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteOwnerInfo(final ByteString topic, final Version version,\n+                                    final Callback<Void> callback, Object ctx) {\n+            int znodeVersion = -1;\n+            if (null != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to delete owner info for topic \" + topic.toStringUtf8()));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+\n+            zk.delete(hubPath(topic), znodeVersion, new SafeAsyncZKCallback.VoidCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx) {\n+                    if (Code.OK.intValue() == rc) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully deleted owner info for topic \" + topic.toStringUtf8() + \".\");\n+                        }\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (Code.NONODE.intValue() == rc) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO,\n+                                                      \"No owner info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (Code.BadVersion == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to delete owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Failed to delete owner info for topic \"\n+                                                + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n }"},{"sha":"7220e23670d54415c02371d57d56eede3d1d2146","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":13,"deletions":2,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -64,6 +64,7 @@\n import org.apache.hedwig.server.handlers.UnsubscribeHandler;\n import org.apache.hedwig.server.jmx.HedwigMBeanRegistry;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.ZkMetadataManagerFactory;\n import org.apache.hedwig.server.persistence.BookkeeperPersistenceManager;\n import org.apache.hedwig.server.persistence.LocalDBPersistenceManager;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n@@ -75,6 +76,7 @@\n import org.apache.hedwig.server.subscriptions.InMemorySubscriptionManager;\n import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n import org.apache.hedwig.server.subscriptions.MMSubscriptionManager;\n+import org.apache.hedwig.server.topics.MMTopicManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.server.topics.ZkTopicManager;\n@@ -195,9 +197,18 @@ protected TopicManager instantiateTopicManager() throws IOException {\n             tm = new TrivialOwnAllTopicManager(conf, scheduler);\n         } else {\n             try {\n-                tm = new ZkTopicManager(zk, conf, scheduler);\n+                if (conf.isMetadataManagerBasedTopicManagerEnabled()) {\n+                    tm = new MMTopicManager(conf, zk, mm, scheduler);\n+                } else {\n+                    if (!(mm instanceof ZkMetadataManagerFactory)) {\n+                        throw new IOException(\"Uses \" + mm.getClass().getName() + \" to store hedwig metadata, \"\n+                                            + \"but uses zookeeper ephemeral znodes to store topic ownership. \"\n+                                            + \"Check your configuration as this could lead to scalability issues.\");\n+                    }\n+                    tm = new ZkTopicManager(zk, conf, scheduler);\n+                }\n             } catch (PubSubException e) {\n-                logger.error(\"Could not instantiate zk-topic manager\", e);\n+                logger.error(\"Could not instantiate TopicOwnershipManager based topic manager\", e);\n                 throw new IOException(e);\n             }\n         }"},{"sha":"9a4cb3d6d32e77e5f22f9ff4b29e8c7efcd51b7a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,162 @@\n+package org.apache.hedwig.server.topics;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.HubInfoData;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.TextFormat;\n+\n+/**\n+ * Info identifies a hub server.\n+ */\n+public class HubInfo {\n+\n+    public static class InvalidHubInfoException extends Exception {\n+        public InvalidHubInfoException(String msg) {\n+            super(msg);\n+        }\n+\n+        public InvalidHubInfoException(String msg, Throwable t) {\n+            super(msg, t);\n+        }\n+    }\n+\n+    // address identify a hub server\n+    final HedwigSocketAddress addr;\n+    // its znode czxid\n+    final long czxid;\n+    // protobuf encoded hub info data to be serialized\n+    HubInfoData hubInfoData;\n+\n+    public HubInfo(HedwigSocketAddress addr, long czxid) {\n+        this(addr, czxid, null);\n+    }\n+\n+    protected HubInfo(HedwigSocketAddress addr, long czxid,\n+                      HubInfoData data) {\n+        this.addr = addr;\n+        this.czxid = czxid;\n+        this.hubInfoData = data;\n+    }\n+\n+    public HedwigSocketAddress getAddress() {\n+        return addr;\n+    }\n+\n+    public long getZxid() {\n+        return czxid;\n+    }\n+\n+    private synchronized HubInfoData getHubInfoData() {\n+        if (null == hubInfoData) {\n+            hubInfoData = HubInfoData.newBuilder().setHostname(addr.toString())\n+                                     .setCzxid(czxid).build();\n+        }\n+        return hubInfoData;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return TextFormat.printToString(getHubInfoData());\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (null == o) {\n+            return false;\n+        }\n+        if (!(o instanceof HubInfo)) {\n+            return false;\n+        }\n+        HubInfo other = (HubInfo)o;\n+        if (null == addr) {\n+            if (null == other.addr) {\n+                return true;\n+            } else {\n+                return czxid == other.czxid;\n+            }\n+        } else {\n+            if (addr.equals(other.addr)) {\n+                return czxid == other.czxid;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return addr.hashCode();\n+    }\n+\n+    /**\n+     * Parse hub info from a string.\n+     *\n+     * @param hubInfoStr\n+     *          String representation of hub info\n+     * @return hub info\n+     * @throws InvalidHubInfoException when <code>hubInfoStr</code> is not a valid\n+     *         string representation of hub info.\n+     */\n+    public static HubInfo parse(String hubInfoStr) throws InvalidHubInfoException {\n+        // it is not protobuf encoded hub info, it might be generated by ZkTopicManager\n+        if (!hubInfoStr.startsWith(\"hostname\")) {\n+            final HedwigSocketAddress owner;\n+            try {\n+                owner = new HedwigSocketAddress(hubInfoStr);\n+            } catch (Exception e) {\n+                throw new InvalidHubInfoException(\"Corrupted hub server address : \" + hubInfoStr, e);\n+            }\n+            return new HubInfo(owner, 0L);\n+        }\n+\n+        // it is a protobuf encoded hub info.\n+        HubInfoData hubInfoData;\n+\n+        try {\n+            BufferedReader reader = new BufferedReader(\n+                new StringReader(hubInfoStr));\n+            HubInfoData.Builder dataBuilder = HubInfoData.newBuilder();\n+            TextFormat.merge(reader, dataBuilder);\n+            hubInfoData = dataBuilder.build();\n+        } catch (InvalidProtocolBufferException ipbe) {\n+            throw new InvalidHubInfoException(\"Corrupted hub info : \" + hubInfoStr, ipbe);\n+        } catch (IOException ie) {\n+            throw new InvalidHubInfoException(\"Corrupted hub info : \" + hubInfoStr, ie);\n+        }\n+\n+        final HedwigSocketAddress owner;\n+        try {\n+            owner = new HedwigSocketAddress(hubInfoData.getHostname().trim());\n+        } catch (Exception e) {\n+            throw new InvalidHubInfoException(\"Corrupted hub server address : \" + hubInfoData.getHostname(), e);\n+        }\n+        long ownerZxid = hubInfoData.getCzxid();\n+        return new HubInfo(owner, ownerZxid, hubInfoData);\n+    }\n+}"},{"sha":"98e5687fbfe891876e725ab03589d489206f205f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java","status":"added","additions":130,"deletions":0,"changes":130,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,130 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.hedwig.server.topics;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.HubLoadData;\n+\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.TextFormat;\n+\n+/**\n+ * This class encapsulates metrics for determining the load on a hub server.\n+ */\n+class HubLoad implements Comparable<HubLoad> {\n+\n+    public static final HubLoad MAX_LOAD = new HubLoad(Long.MAX_VALUE);\n+    public static final HubLoad MIN_LOAD = new HubLoad(0);\n+\n+    public static class InvalidHubLoadException extends Exception {\n+        public InvalidHubLoadException(String msg) {\n+            super(msg);\n+        }\n+\n+        public InvalidHubLoadException(String msg, Throwable t) {\n+            super(msg, t);\n+        }\n+    }\n+\n+    // how many topics that a hub server serves\n+    long numTopics; \n+\n+    public HubLoad(long num) {\n+        this.numTopics = num;\n+    }\n+\n+    public HubLoad(HubLoadData data) {\n+        this.numTopics = data.getNumTopics();\n+    }\n+\n+    public HubLoad setNumTopics(long numTopics) {\n+        this.numTopics = numTopics;\n+        return this;\n+    }\n+\n+    public HubLoadData toHubLoadData() {\n+        return HubLoadData.newBuilder().setNumTopics(numTopics).build();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return TextFormat.printToString(toHubLoadData());\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (null == o ||\n+            !(o instanceof HubLoad)) {\n+            return false;\n+        }\n+        return 0 == compareTo((HubLoad)o);\n+    }\n+\n+    @Override\n+    public int compareTo(HubLoad other) {\n+        return numTopics > other.numTopics ?\n+               1 : (numTopics < other.numTopics ? -1 : 0);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return (int)numTopics;\n+    }\n+\n+    /**\n+     * Parse hub load from a string.\n+     *\n+     * @param hubLoadStr\n+     *          String representation of hub load\n+     * @return hub load\n+     * @throws InvalidHubLoadException when <code>hubLoadStr</code> is not a valid\n+     *         string representation of hub load.\n+     */\n+    public static HubLoad parse(String hubLoadStr) throws InvalidHubLoadException {\n+        // it is no protobuf encoded hub info, it might be generated by ZkTopicManager\n+        if (!hubLoadStr.startsWith(\"numTopics\")) {\n+            try {\n+                long numTopics = Long.parseLong(hubLoadStr, 10);\n+                return new HubLoad(numTopics);\n+            } catch (NumberFormatException nfe) {\n+                throw new InvalidHubLoadException(\"Corrupted hub load data : \" + hubLoadStr, nfe);\n+            }\n+        }\n+        // it it a protobuf encoded hub load data.\n+        HubLoadData hubLoadData;\n+        try {\n+            BufferedReader reader = new BufferedReader(\n+                new StringReader(hubLoadStr));\n+            HubLoadData.Builder dataBuilder = HubLoadData.newBuilder();\n+            TextFormat.merge(reader, dataBuilder);\n+            hubLoadData = dataBuilder.build();\n+        } catch (InvalidProtocolBufferException ipbe) {\n+            throw new InvalidHubLoadException(\"Corrupted hub load data : \" + hubLoadStr, ipbe);\n+        } catch (IOException ie) {\n+            throw new InvalidHubLoadException(\"Corrupted hub load data : \" + hubLoadStr, ie);\n+        }\n+\n+        return new HubLoad(hubLoadData);\n+    }\n+}"},{"sha":"83c0e86e3972dc601e7744efd299536427fbb8a1","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,108 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.topics;\n+\n+import java.io.IOException;\n+\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * The HubServerManager class manages info about hub servers.\n+ */\n+interface HubServerManager {\n+\n+    static interface ManagerListener {\n+\n+        /**\n+         * Server manager is suspended if encountering some transient errors.\n+         * {@link #onResume()} would be called if those errors could be fixed.\n+         * {@link #onShutdown()} would be called if those errors could not be fixed.\n+         */\n+        public void onSuspend();\n+\n+        /**\n+         * Server manager is resumed after fixing some transient errors.\n+         */\n+        public void onResume();\n+\n+        /**\n+         * Server manager had to shutdown due to unrecoverable errors.\n+         */\n+        public void onShutdown();\n+    }\n+\n+    /**\n+     * Register a listener to listen events of server manager\n+     *\n+     * @param listener\n+     *          Server Manager Listener\n+     */\n+    public void registerListener(ManagerListener listener);\n+\n+    /**\n+     * Register itself to the cluster.\n+     *\n+     * @param selfLoad\n+     *          Self load data\n+     * @param callback\n+     *          Callback when itself registered.\n+     * @param ctx\n+     *          Callback context.\n+     */\n+    public void registerSelf(HubLoad selfLoad, Callback<HubInfo> callback, Object ctx);\n+\n+    /**\n+     * Unregister itself from the cluster.\n+     */\n+    public void unregisterSelf() throws IOException;\n+\n+    /**\n+     * Uploading self server load data.\n+     *\n+     * It is an asynchrounous call which should not block other operations.\n+     * Currently we don't need to care about whether it succeed or not.\n+     *\n+     * @param selfLoad\n+     *          Hub server load data.\n+     */\n+    public void uploadSelfLoadData(HubLoad selfLoad);\n+\n+    /**\n+     * Check whether a hub server is alive as the id\n+     *\n+     * @param hub\n+     *          Hub id to identify a lifecycle of a hub server\n+     * @param callback\n+     *          Callback of check result. If the hub server is still\n+     *          alive as the provided id <code>hub</code>, return true.\n+     *          Otherwise return false.\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void isHubAlive(HubInfo hub, Callback<Boolean> callback, Object ctx);\n+\n+    /**\n+     * Choose a least loaded hub server from available hub servers.\n+     *\n+     * @param callback\n+     *          Callback to return least loaded hub server.\n+     * @param ctx\n+     *          Callback context.\n+     */\n+    public void chooseLeastLoadedHub(Callback<HubInfo> callback, Object ctx);\n+}"},{"sha":"0788b8c8ff2eb33ae9aef13a518d562010b3d000","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java","status":"added","additions":353,"deletions":0,"changes":353,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,353 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.hedwig.server.topics;\n+\n+import java.net.UnknownHostException;\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.TopicOwnershipManager;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.ConcurrencyUtils;\n+import org.apache.hedwig.util.Either;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+/**\n+ * TopicOwnershipManager based topic manager\n+ */\n+public class MMTopicManager extends AbstractTopicManager implements TopicManager {\n+\n+    static Logger logger = LoggerFactory.getLogger(MMTopicManager.class);\n+\n+    // topic ownership manager\n+    private final TopicOwnershipManager mm;\n+    // hub server manager\n+    private final HubServerManager hubManager;\n+\n+    private final HubInfo myHubInfo;\n+    private final HubLoad myHubLoad;\n+\n+    // Boolean flag indicating if we should suspend activity. If this is true,\n+    // all of the Ops put into the queuer will fail automatically.\n+    protected volatile boolean isSuspended = false;\n+\n+    public MMTopicManager(ServerConfiguration cfg, ZooKeeper zk, \n+                          MetadataManagerFactory mmFactory,\n+                          ScheduledExecutorService scheduler)\n+            throws UnknownHostException, PubSubException {\n+        super(cfg, scheduler);\n+        // initialize topic ownership manager\n+        this.mm = mmFactory.newTopicOwnershipManager();\n+        this.hubManager = new ZkHubServerManager(cfg, zk, addr);\n+\n+        final SynchronousQueue<Either<HubInfo, PubSubException>> queue =\n+            new SynchronousQueue<Either<HubInfo, PubSubException>>();\n+\n+        myHubLoad = new HubLoad(topics.size());\n+        this.hubManager.registerListener(new HubServerManager.ManagerListener() {\n+            @Override\n+            public void onSuspend() {\n+                isSuspended = true;\n+            }\n+            @Override\n+            public void onResume() {\n+                isSuspended = false;\n+            }\n+            @Override\n+            public void onShutdown() {\n+                // if hub server manager can't work, we had to quit\n+                Runtime.getRuntime().exit(1);\n+            }\n+        });\n+        this.hubManager.registerSelf(myHubLoad, new Callback<HubInfo>() {\n+            @Override\n+            public void operationFinished(final Object ctx, final HubInfo resultOfOperation) {\n+                logger.info(\"Successfully registered hub {} with zookeeper\", resultOfOperation);\n+                ConcurrencyUtils.put(queue, Either.of(resultOfOperation, (PubSubException) null));\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                logger.error(\"Failed to register hub with zookeeper\", exception);\n+                ConcurrencyUtils.put(queue, Either.of((HubInfo)null, exception));\n+            }\n+        }, null);\n+        Either<HubInfo, PubSubException> result = ConcurrencyUtils.take(queue);\n+        PubSubException pse = result.right();\n+        if (pse != null) {\n+            throw pse;\n+        }\n+        myHubInfo = result.left();\n+        logger.info(\"Start metadata manager based topic manager with hub id : \" + myHubInfo);\n+    }\n+\n+    @Override\n+    protected void realGetOwner(final ByteString topic, final boolean shouldClaim,\n+                                final Callback<HedwigSocketAddress> cb, final Object ctx) {\n+        // If operations are suspended due to a ZK client disconnect, just error\n+        // out this call and return.\n+        if (isSuspended) {\n+            cb.operationFailed(ctx, new PubSubException.ServiceDownException(\n+                                    \"MMTopicManager service is temporarily suspended!\"));\n+            return;\n+        }\n+\n+        if (topics.contains(topic)) {\n+            cb.operationFinished(ctx, addr);\n+            return;\n+        }\n+\n+        new MMGetOwnerOp(topic, cb, ctx).read();\n+    }\n+\n+    /**\n+     * MetadataManager do topic ledger election using versioned writes.\n+     */\n+    class MMGetOwnerOp {\n+        ByteString topic;\n+        Callback<HedwigSocketAddress> cb;\n+        Object ctx;\n+\n+        public MMGetOwnerOp(ByteString topic,\n+                            Callback<HedwigSocketAddress> cb, Object ctx) {\n+            this.topic = topic;\n+            this.cb = cb;\n+            this.ctx = ctx;\n+        }\n+\n+        protected void read() {\n+            mm.readOwnerInfo(topic, new Callback<Versioned<HubInfo>>() {\n+                @Override\n+                public void operationFinished(final Object ctx, final Versioned<HubInfo> owner) {\n+                    if (null == owner) {\n+                        logger.info(\"{} : No owner found for topic {}\",\n+                                    new Object[] { addr, topic.toStringUtf8() });\n+                        // no data found\n+                        choose(null);\n+                        return;\n+                    }\n+                    final Version ownerVersion = owner.getVersion();\n+                    if (null == owner.getValue()) {\n+                        logger.info(\"{} : Invalid owner found for topic {}\",\n+                                    new Object[] { addr, topic.toStringUtf8() });\n+                        choose(ownerVersion);\n+                        return;\n+                    }\n+                    final HubInfo hub = owner.getValue();\n+                    logger.info(\"{} : Read owner of topic {} : {}\",\n+                                new Object[] { addr, topic.toStringUtf8(), hub });\n+\n+                    logger.info(\"{}, {}\", new Object[] { hub, myHubInfo });\n+\n+                    if (hub.getAddress().equals(addr)) {\n+                        if (myHubInfo.getZxid() == hub.getZxid()) {\n+                            claimTopic(ctx);\n+                            return;\n+                        } else {\n+                            choose(ownerVersion);\n+                            return;\n+                        }\n+                    }\n+\n+                    logger.info(\"{} : Check whether owner {} for topic {} is still alive.\",\n+                                new Object[] { addr, hub, topic.toStringUtf8() });\n+                    hubManager.isHubAlive(hub, new Callback<Boolean>() {\n+                        @Override\n+                        public void operationFinished(Object ctx, Boolean isAlive) {\n+                            if (isAlive) {\n+                                cb.operationFinished(ctx, hub.getAddress());\n+                            } else {\n+                                choose(ownerVersion);\n+                            }\n+                        }\n+                        @Override\n+                        public void operationFailed(Object ctx, PubSubException pse) {\n+                            cb.operationFailed(ctx, pse);\n+                        }\n+                    }, ctx);\n+                }\n+\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(\n+                                       \"Could not read ownership for topic \" + topic.toStringUtf8() + \" : \"\n+                                       + exception.getMessage()));\n+                }\n+            }, ctx);\n+        }\n+\n+        public void claim(final Version prevOwnerVersion) {\n+            logger.info(\"{} : claiming topic {} 's owner to be {}\",\n+                        new Object[] { addr, topic.toStringUtf8(), myHubInfo });\n+            mm.writeOwnerInfo(topic, myHubInfo, prevOwnerVersion, new Callback<Version>() {\n+                @Override\n+                public void operationFinished(Object ctx, Version newVersion) {\n+                    claimTopic(ctx);\n+                }\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    if (exception instanceof PubSubException.NoTopicOwnerInfoException ||\n+                        exception instanceof PubSubException.BadVersionException) {\n+                        // some one has updated the owner\n+                        logger.info(\"{} : Some one has claimed topic {} 's owner. Try to read the owner again.\",\n+                                    new Object[] { addr, topic.toStringUtf8() });\n+                        read();\n+                        return;\n+                    }\n+                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(\n+                                       \"Exception when writing owner info to claim ownership of topic \"\n+                                       + topic.toStringUtf8() + \" : \" + exception.getMessage()));\n+                }\n+            }, ctx);\n+        }\n+\n+        protected void claimTopic(Object ctx) {\n+            logger.info(\"{} : claimed topic {} 's owner to be {}\",\n+                        new Object[] { addr, topic.toStringUtf8(), myHubInfo });\n+            notifyListenersAndAddToOwnedTopics(topic, cb, ctx);\n+            hubManager.uploadSelfLoadData(myHubLoad.setNumTopics(topics.size()));\n+        }\n+\n+        public void choose(final Version prevOwnerVersion) {\n+            hubManager.chooseLeastLoadedHub(new Callback<HubInfo>() {\n+                @Override\n+                public void operationFinished(Object ctx, HubInfo owner) {\n+                    logger.info(\"{} : Least loaded owner {} is chosen for topic {}\",\n+                                new Object[] { addr, owner, topic.toStringUtf8() });\n+                    if (owner.getAddress().equals(addr)) {\n+                        claim(prevOwnerVersion);\n+                    } else {\n+                        setOwner(owner, prevOwnerVersion);\n+                    }\n+                }\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException pse) {\n+                    logger.error(\"Failed to choose least loaded hub server for topic \"\n+                               + topic.toStringUtf8() + \" : \", pse);\n+                    cb.operationFailed(ctx, pse);\n+                }\n+            }, null);\n+        }\n+\n+        public void setOwner(final HubInfo ownerHubInfo, final Version prevOwnerVersion) {\n+            logger.info(\"{} : setting topic {} 's owner to be {}\",\n+                        new Object[] { addr, topic.toStringUtf8(), ownerHubInfo });\n+            mm.writeOwnerInfo(topic, ownerHubInfo, prevOwnerVersion, new Callback<Version>() {\n+                @Override\n+                public void operationFinished(Object ctx, Version newVersion) {\n+                    logger.info(\"{} : Set topic {} 's owner to be {}\",\n+                                new Object[] { addr, topic.toStringUtf8(), ownerHubInfo });\n+                    cb.operationFinished(ctx, ownerHubInfo.getAddress());\n+                }\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    if (exception instanceof PubSubException.NoTopicOwnerInfoException ||\n+                        exception instanceof PubSubException.BadVersionException) {\n+                        // some one has updated the owner\n+                        logger.info(\"{} : Some one has set topic {} 's owner. Try to read the owner again.\",\n+                                    new Object[] { addr, topic.toStringUtf8() });\n+                        read();\n+                        return;\n+                    }\n+                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(\n+                                       \"Exception when writing owner info to claim ownership of topic \"\n+                                       + topic.toStringUtf8() + \" : \" + exception.getMessage()));\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    @Override\n+    protected void postReleaseCleanup(final ByteString topic,\n+                                      final Callback<Void> cb, final Object ctx) {\n+        mm.readOwnerInfo(topic, new Callback<Versioned<HubInfo>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Versioned<HubInfo> owner) {\n+                if (null == owner) {\n+                    // Node has somehow disappeared from under us, live with it\n+                    logger.warn(\"No owner info found when cleaning up topic \" + topic.toStringUtf8());\n+                    cb.operationFinished(ctx, null);\n+                    return;\n+                }\n+                // no valid hub info found, just return\n+                if (null == owner.getValue()) {\n+                    logger.warn(\"No valid owner info found when cleaning up topic \" + topic.toStringUtf8());\n+                    cb.operationFinished(ctx, null);\n+                    return;\n+                }\n+                HedwigSocketAddress ownerAddr = owner.getValue().getAddress();\n+                if (!ownerAddr.equals(addr)) {\n+                    logger.warn(\"Wanted to clean up self owner info for topic \" + topic.toStringUtf8()\n+                                + \" but owner \" + owner + \" found, leaving untouched\");\n+                    // Not our node, someone else's, leave it alone\n+                    cb.operationFinished(ctx, null);\n+                    return;\n+                }\n+\n+                mm.deleteOwnerInfo(topic, owner.getVersion(), new Callback<Void>() {\n+                    @Override\n+                    public void operationFinished(Object ctx, Void result) {\n+                        cb.operationFinished(ctx, null);\n+                    }\n+                    @Override\n+                    public void operationFailed(Object ctx, PubSubException exception) {\n+                        if (exception instanceof PubSubException.NoTopicOwnerInfoException) {\n+                            logger.warn(\"Wanted to clean up self owner info for topic \" + topic.toStringUtf8()\n+                                      + \" but it has been removed.\");\n+                            cb.operationFinished(ctx, null);\n+                            return;\n+                        }\n+                        logger.error(\"Exception when deleting self-ownership metadata for topic \"\n+                                     + topic.toStringUtf8() + \" : \", exception);\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(exception));\n+                    }\n+                }, ctx);\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                logger.error(\"Exception when cleaning up owner info of topic \" + topic.toStringUtf8() + \" : \", exception);\n+                cb.operationFailed(ctx, new PubSubException.ServiceDownException(exception));\n+            }\n+        }, ctx);\n+    }\n+\n+    @Override\n+    public void stop() {\n+        // we just unregister it with zookeeper to make it unavailable from hub servers list\n+        try {\n+            hubManager.unregisterSelf();\n+        } catch (IOException e) {\n+            logger.error(\"Error unregistering hub server \" + myHubInfo + \" : \", e);\n+        }\n+        super.stop();\n+    }\n+\n+}"},{"sha":"7482d5a6890131490379eda3bb1cd1d00a416473","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java","status":"added","additions":310,"deletions":0,"changes":310,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,310 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.topics;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n+import org.apache.hedwig.zookeeper.SafeAsyncZKCallback.StatCallback;\n+import org.apache.hedwig.zookeeper.ZkUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * ZooKeeper based hub server manager.\n+ */\n+class ZkHubServerManager implements HubServerManager {\n+\n+    static Logger logger = LoggerFactory.getLogger(ZkHubServerManager.class);\n+\n+    final Random rand = new Random();\n+\n+    private final ServerConfiguration conf;\n+    private final ZooKeeper zk;\n+    private final HedwigSocketAddress addr;\n+    private final String ephemeralNodePath;\n+    private final String hubNodesPath;\n+\n+    // hub info structure represent itself\n+    protected HubInfo myHubInfo;\n+    protected volatile boolean isSuspended = false;\n+    protected ManagerListener listener = null;\n+\n+    // upload hub server load to zookeeper\n+    StatCallback loadReportingStatCallback = new StatCallback() {\n+        @Override\n+        public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+            if (rc != KeeperException.Code.OK.intValue()) {\n+                logger.warn(\"Failed to update load information of hub {} in zk\", myHubInfo);\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Watcher to monitor available hub server list.\n+     */\n+    class ZkHubsWatcher implements Watcher {\n+        @Override\n+        public void process(WatchedEvent event) {\n+            if (event.getType().equals(Watcher.Event.EventType.None)) {\n+                if (event.getState().equals(\n+                        Watcher.Event.KeeperState.Disconnected)) {\n+                    logger.warn(\"ZK client has been disconnected to the ZK server!\");\n+                    isSuspended = true;\n+                    if (null != listener) {\n+                        listener.onSuspend();\n+                    }\n+                } else if (event.getState().equals(\n+                        Watcher.Event.KeeperState.SyncConnected)) {\n+                    if (isSuspended) {\n+                        logger.info(\"ZK client has been reconnected to the ZK server!\");\n+                    }\n+                    isSuspended = false;\n+                    if (null != listener) {\n+                        listener.onResume();\n+                    }\n+                }\n+            }\n+            if (event.getState().equals(Watcher.Event.KeeperState.Expired)) {\n+                logger.error(\"ZK client connection to the ZK server has expired.!\");\n+                if (null != listener) {\n+                    listener.onShutdown();\n+                }\n+            }\n+        }\n+    }\n+\n+    public ZkHubServerManager(ServerConfiguration conf,\n+                              ZooKeeper zk,\n+                              HedwigSocketAddress addr) {\n+        this.conf = conf;\n+        this.zk = zk;\n+        this.addr = addr;\n+\n+        // znode path to store all available hub servers\n+        this.hubNodesPath = this.conf.getZkHostsPrefix(new StringBuilder()).toString();\n+        // the node's ephemeral node path\n+        this.ephemeralNodePath = getHubZkNodePath(addr);\n+        // register available hub servers list watcher\n+        zk.register(new ZkHubsWatcher());\n+    }\n+\n+    @Override\n+    public void registerListener(ManagerListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * Get the znode path identifying a hub server.\n+     *\n+     * @param node\n+     *          Hub Server Address\n+     * @return znode path identifying the hub server.\n+     */\n+    private String getHubZkNodePath(HedwigSocketAddress node) {\n+        String nodePath = this.conf.getZkHostsPrefix(new StringBuilder())\n+                          .append(\"/\").append(node).toString();\n+        return nodePath;\n+    }\n+\n+    @Override\n+    public void registerSelf(final HubLoad selfData, final Callback<HubInfo> callback, Object ctx) {\n+        byte[] loadDataBytes = selfData.toString().getBytes();\n+        ZkUtils.createFullPathOptimistic(zk, ephemeralNodePath, loadDataBytes, Ids.OPEN_ACL_UNSAFE,\n+                                         CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                if (rc == Code.OK.intValue()) {\n+                    // now we are here\n+                    zk.exists(ephemeralNodePath, false, new SafeAsyncZKCallback.StatCallback() {\n+                        @Override\n+                        public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                            if (rc == Code.OK.intValue()) {\n+                                myHubInfo = new HubInfo(addr, stat.getCzxid());\n+                                callback.operationFinished(ctx, myHubInfo);\n+                                return;\n+                            } else {\n+                                callback.operationFailed(ctx,\n+                                    new PubSubException.ServiceDownException(\n+                                        \"I can't state my hub node after I created it : \"\n+                                        + ephemeralNodePath));\n+                                return;\n+                            }\n+                        }\n+                    }, ctx);\n+                    return;\n+                }\n+                if (rc != Code.NODEEXISTS.intValue()) {\n+                    KeeperException ke = ZkUtils .logErrorAndCreateZKException(\n+                            \"Could not create ephemeral node to register hub\", ephemeralNodePath, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                    return;\n+                }\n+\n+                logger.info(\"Found stale ephemeral node while registering hub with ZK, deleting it\");\n+\n+                // Node exists, lets try to delete it and retry\n+                zk.delete(ephemeralNodePath, -1, new SafeAsyncZKCallback.VoidCallback() {\n+                    @Override\n+                    public void safeProcessResult(int rc, String path, Object ctx) {\n+                        if (rc == Code.OK.intValue() || rc == Code.NONODE.intValue()) {\n+                            registerSelf(selfData, callback, ctx);\n+                            return;\n+                        }\n+                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                \"Could not delete stale ephemeral node to register hub\", ephemeralNodePath, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                        return;\n+                    }\n+                }, ctx);\n+            }\n+        }, ctx);\n+    }\n+\n+    @Override\n+    public void unregisterSelf() throws IOException {\n+        try {\n+            zk.delete(ephemeralNodePath, -1);\n+        } catch (InterruptedException e) {\n+            throw new IOException(e);\n+        } catch (KeeperException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+\n+    @Override\n+    public void uploadSelfLoadData(HubLoad selfLoad) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Reporting hub load of {} : {}\", myHubInfo, selfLoad);\n+        }\n+        byte[] loadDataBytes = selfLoad.toString().getBytes();\n+        zk.setData(ephemeralNodePath, loadDataBytes, -1,\n+                   loadReportingStatCallback, null);\n+    }\n+\n+    @Override\n+    public void isHubAlive(final HubInfo hub, final Callback<Boolean> callback, Object ctx) {\n+        zk.exists(getHubZkNodePath(hub.getAddress()), false, new SafeAsyncZKCallback.StatCallback() {\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                if (rc == Code.NONODE.intValue()) {\n+                    callback.operationFinished(ctx, false);\n+                } else if (rc == Code.OK.intValue()) {\n+                    if (hub.getZxid() == stat.getCzxid()) {\n+                        callback.operationFinished(ctx, true);\n+                    } else {\n+                        callback.operationFinished(ctx, false);\n+                    }\n+                } else {\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(\n+                        \"Failed to check whether hub server \" + hub + \" is alive!\"));\n+                }\n+            }\n+        }, ctx);\n+    }\n+\n+    @Override\n+    public void chooseLeastLoadedHub(final Callback<HubInfo> callback, Object ctx) {\n+        // Get the list of existing hosts\n+        zk.getChildren(hubNodesPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx,\n+                                          List<String> children) {\n+                if (rc != Code.OK.intValue()) {\n+                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                        \"Could not get list of available hubs\", path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                    return;\n+                }\n+                chooseLeastLoadedNode(children, callback, ctx);\n+            }\n+        }, ctx);\n+    }\n+\n+    private void chooseLeastLoadedNode(final List<String> children,\n+                                       final Callback<HubInfo> callback, Object ctx) {\n+        SafeAsyncZKCallback.DataCallback dataCallback = new SafeAsyncZKCallback.DataCallback() {\n+            int numResponses = 0;\n+            HubLoad minLoad = HubLoad.MAX_LOAD;\n+            String leastLoaded = null;\n+            long leastLoadedCzxid = 0;\n+\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx,\n+                                          byte[] data, Stat stat) {\n+                synchronized (this) {\n+                    if (rc == KeeperException.Code.OK.intValue()) {\n+                        try {\n+                            HubLoad load = HubLoad.parse(new String(data));\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Found server \" + ctx + \" with load: \" + load);\n+                            }\n+                            int compareRes = load.compareTo(minLoad);\n+                            if (compareRes < 0 || (compareRes == 0 && rand.nextBoolean())) {\n+                                minLoad = load;\n+                                leastLoaded = (String) ctx;\n+                                leastLoadedCzxid = stat.getCzxid();\n+                            }\n+                        } catch (HubLoad.InvalidHubLoadException e) {\n+                            logger.warn(\"Corrupted load information from hub : \" + ctx);\n+                            // some corrupted data, we'll just ignore this hub\n+                        }\n+                    }\n+                    numResponses++;\n+\n+                    if (numResponses == children.size()) {\n+                        if (leastLoaded == null) {\n+                            callback.operationFailed(ctx, \n+                                new PubSubException.ServiceDownException(\"No hub available\"));\n+                            return;\n+                        }\n+                        try {\n+                            HedwigSocketAddress owner = new HedwigSocketAddress(leastLoaded);\n+                            callback.operationFinished(ctx, new HubInfo(owner, leastLoadedCzxid));\n+                        } catch (Throwable t) {\n+                            callback.operationFailed(ctx,\n+                                new PubSubException.ServiceDownException(\"Least loaded hub server \"\n+                                                                       + leastLoaded + \" is invalid.\"));\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        for (String child : children) {\n+            zk.getData(conf.getZkHostsPrefix(new StringBuilder()).append(\"/\").append(child).toString(), false,\n+                       dataCallback, child);\n+        }\n+    }\n+}"},{"sha":"128a1aaa13b378b939b9f80344f61968db8ee7b3","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","status":"modified","additions":76,"deletions":182,"changes":258,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -18,19 +18,16 @@\n package org.apache.hedwig.server.topics;\n \n import java.net.UnknownHostException;\n-import java.util.List;\n-import java.util.Random;\n+import java.io.IOException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.SynchronousQueue;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.data.Stat;\n \n@@ -53,22 +50,17 @@\n public class ZkTopicManager extends AbstractTopicManager implements TopicManager {\n \n     static Logger logger = LoggerFactory.getLogger(ZkTopicManager.class);\n-    Random rand = new Random();\n \n     /**\n      * Persistent storage for topic metadata.\n      */\n     private ZooKeeper zk;\n-    String ephemeralNodePath;\n \n-    StatCallback loadReportingStatCallback = new StatCallback() {\n-        @Override\n-        public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n-            if (rc != KeeperException.Code.OK.intValue()) {\n-                logger.warn(\"Failed to update load information in zk\");\n-            }\n-        }\n-    };\n+    // hub server manager\n+    private final HubServerManager hubManager;\n+\n+    private final HubInfo myHubInfo;\n+    private final HubLoad myHubLoad;\n \n     // Boolean flag indicating if we should suspend activity. If this is true,\n     // all of the Ops put into the queuer will fail automatically.\n@@ -84,94 +76,46 @@ public ZkTopicManager(final ZooKeeper zk, final ServerConfiguration cfg, Schedul\n \n         super(cfg, scheduler);\n         this.zk = zk;\n-        this.ephemeralNodePath = cfg.getZkHostsPrefix(new StringBuilder()).append(\"/\").append(addr).toString();\n+        this.hubManager = new ZkHubServerManager(cfg, zk, addr);\n \n-        zk.register(new Watcher() {\n+        myHubLoad = new HubLoad(topics.size());\n+        this.hubManager.registerListener(new HubServerManager.ManagerListener() {\n             @Override\n-            public void process(WatchedEvent event) {\n-                if (event.getType().equals(Watcher.Event.EventType.None)) {\n-                    if (event.getState().equals(Watcher.Event.KeeperState.Disconnected)) {\n-                        logger.warn(\"ZK client has been disconnected to the ZK server!\");\n-                        isSuspended = true;\n-                    } else if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n-                        if (isSuspended) {\n-                            logger.info(\"ZK client has been reconnected to the ZK server!\");\n-                        }\n-                        isSuspended = false;\n-                    }\n-                }\n-                // Check for expired connection.\n-                if (event.getState().equals(Watcher.Event.KeeperState.Expired)) {\n-                    logger.error(\"ZK client connection to the ZK server has expired!\");\n-                    Runtime.getRuntime().exit(1);\n-                }\n+            public void onSuspend() {\n+                isSuspended = true;\n             }\n-        });\n-        final SynchronousQueue<Either<Void, PubSubException>> queue = new SynchronousQueue<Either<Void, PubSubException>>();\n-\n-        registerWithZookeeper(new Callback<Void>() {\n             @Override\n-            public void operationFailed(Object ctx, PubSubException exception) {\n-                logger.error(\"Failed to register hub with zookeeper\", exception);\n-                ConcurrencyUtils.put(queue, Either.of((Void) null, exception));\n+            public void onResume() {\n+                isSuspended = false;\n             }\n+            @Override\n+            public void onShutdown() {\n+                // if hub server manager can't work, we had to quit\n+                Runtime.getRuntime().exit(1);\n+            }\n+        });\n \n+        final SynchronousQueue<Either<HubInfo, PubSubException>> queue =\n+            new SynchronousQueue<Either<HubInfo, PubSubException>>();\n+        this.hubManager.registerSelf(myHubLoad, new Callback<HubInfo>() {\n             @Override\n-            public void operationFinished(Object ctx, Void resultOfOperation) {\n-                logger.info(\"Successfully registered hub with zookeeper\");\n+            public void operationFinished(final Object ctx, final HubInfo resultOfOperation) {\n+                logger.info(\"Successfully registered hub {} with zookeeper\", resultOfOperation);\n                 ConcurrencyUtils.put(queue, Either.of(resultOfOperation, (PubSubException) null));\n             }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                logger.error(\"Failed to register hub with zookeeper\", exception);\n+                ConcurrencyUtils.put(queue, Either.of((HubInfo)null, exception));\n+            }\n         }, null);\n \n-        PubSubException pse = ConcurrencyUtils.take(queue).right();\n-\n+        Either<HubInfo, PubSubException> result = ConcurrencyUtils.take(queue);\n+        PubSubException pse = result.right();\n         if (pse != null) {\n             throw pse;\n         }\n-    }\n-\n-    void registerWithZookeeper(final Callback<Void> callback, Object ctx) {\n-\n-        ZkUtils.createFullPathOptimistic(zk, ephemeralNodePath, getCurrentLoadData(), Ids.OPEN_ACL_UNSAFE,\n-        CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n-\n-            @Override\n-            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                if (rc == Code.OK.intValue()) {\n-                    callback.operationFinished(ctx, null);\n-                    return;\n-                }\n-                if (rc != Code.NODEEXISTS.intValue()) {\n-                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                             \"Could not create ephemeral node to register hub\", ephemeralNodePath, rc);\n-                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                    return;\n-                }\n-\n-                logger.info(\"Found stale ephemeral node while registering hub with ZK, deleting it\");\n-\n-                // Node exists, lets try to delete it and retry\n-                zk.delete(ephemeralNodePath, -1, new SafeAsyncZKCallback.VoidCallback() {\n-                    @Override\n-                    public void safeProcessResult(int rc, String path, Object ctx) {\n-                        if (rc == Code.OK.intValue() || rc == Code.NONODE.intValue()) {\n-                            registerWithZookeeper(callback, ctx);\n-                            return;\n-                        }\n-                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                                 \"Could not delete stale ephemeral node to register hub\", ephemeralNodePath, rc);\n-                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                        return;\n-\n-                    }\n-                }, ctx);\n-\n-            }\n-        }, null);\n-    }\n-\n-    void unregisterWithZookeeper() throws InterruptedException, KeeperException {\n-        zk.delete(ephemeralNodePath, -1);\n+        myHubInfo = result.left();\n     }\n \n     String hubPath(ByteString topic) {\n@@ -215,71 +159,24 @@ public ZkGetOwnerOp(ByteString topic, boolean shouldClaim, Callback<HedwigSocket\n         }\n \n         public void choose() {\n-            // Get the list of existing hosts\n-            String registeredHostsPath = cfg.getZkHostsPrefix(new StringBuilder()).toString();\n-            zk.getChildren(registeredHostsPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n+            hubManager.chooseLeastLoadedHub(new Callback<HubInfo>() {\n                 @Override\n-                public void safeProcessResult(int rc, String path, Object ctx, List<String> children) {\n-                    if (rc != Code.OK.intValue()) {\n-                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                                                \"Could not get list of available hubs\", path, rc);\n-                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n-                        return;\n+                public void operationFinished(Object ctx, HubInfo owner) {\n+                    logger.info(\"{} : Least loaded owner {} is chosen for topic {}\",\n+                                new Object[] { addr, owner, topic.toStringUtf8() });\n+                    if (owner.getAddress().equals(addr)) {\n+                        claim();\n+                    } else {\n+                        cb.operationFinished(ZkGetOwnerOp.this.ctx, owner.getAddress());\n                     }\n-                    chooseLeastLoadedNode(children);\n                 }\n-            }, null);\n-        }\n-\n-        public void chooseLeastLoadedNode(final List<String> children) {\n-            DataCallback dataCallback = new DataCallback() {\n-                int numResponses = 0;\n-                int minLoad = Integer.MAX_VALUE;\n-                String leastLoaded = null;\n-\n                 @Override\n-                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n-                    synchronized (this) {\n-                        if (rc == KeeperException.Code.OK.intValue()) {\n-                            try {\n-                                int load = Integer.parseInt(new String(data));\n-                                if (logger.isDebugEnabled()) {\n-                                    logger.debug(\"Found server: \" + ctx + \" with load: \" + load);\n-                                }\n-                                if (load < minLoad  || (load == minLoad && rand.nextBoolean())) {\n-                                    minLoad = load;\n-                                    leastLoaded = (String) ctx;\n-                                }\n-                            } catch (NumberFormatException e) {\n-                                logger.warn(\"Corrupted load information from hub:\" + ctx);\n-                                // some corrupted data, we'll just ignore this\n-                                // hub\n-                            }\n-                        }\n-                        numResponses++;\n-\n-                        if (numResponses == children.size()) {\n-                            if (leastLoaded == null) {\n-                                cb.operationFailed(ZkGetOwnerOp.this.ctx, new PubSubException.ServiceDownException(\n-                                                       \"No hub available\"));\n-                                return;\n-                            }\n-                            HedwigSocketAddress owner = new HedwigSocketAddress(leastLoaded);\n-                            if (owner.equals(addr)) {\n-                                claim();\n-                            } else {\n-                                cb.operationFinished(ZkGetOwnerOp.this.ctx, owner);\n-                            }\n-                        }\n-                    }\n-\n+                public void operationFailed(Object ctx, PubSubException pse) {\n+                    logger.error(\"Failed to choose least loaded hub server for topic \"\n+                               + topic.toStringUtf8() + \" : \", pse);\n+                    cb.operationFailed(ctx, pse);\n                 }\n-            };\n-\n-            for (String child : children) {\n-                zk.getData(cfg.getZkHostsPrefix(new StringBuilder()).append(\"/\").append(child).toString(), false,\n-                           dataCallback, child);\n-            }\n+            }, null);\n         }\n \n         public void claimOrChoose() {\n@@ -307,17 +204,21 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                     }\n \n                     // successfully did a read\n-                    HedwigSocketAddress owner = new HedwigSocketAddress(new String(data));\n-                    if (!owner.equals(addr)) {\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"topic: \" + topic.toStringUtf8() + \" belongs to someone else: \" + owner);\n+                    try {\n+                        HubInfo ownerHubInfo = HubInfo.parse(new String(data));\n+                        HedwigSocketAddress owner = ownerHubInfo.getAddress();\n+                        if (!owner.equals(addr)) {\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"topic: \" + topic.toStringUtf8() + \" belongs to someone else: \" + owner);\n+                            }\n+                            cb.operationFinished(ctx, owner);\n+                            return;\n                         }\n-                        cb.operationFinished(ctx, owner);\n-                        return;\n+                        logger.info(\"Discovered stale self-node for topic: \" + topic.toStringUtf8() + \", will delete it\");\n+                    } catch (HubInfo.InvalidHubInfoException ihie) {\n+                        logger.info(\"Discovered invalid hub info for topic: \" + topic.toStringUtf8() + \", will delete it : \", ihie);\n                     }\n \n-                    logger.info(\"Discovered stale self-node for topic: \" + topic.toStringUtf8() + \", will delete it\");\n-\n                     // we must have previously failed and left a\n                     // residual ephemeral node here, so we must\n                     // delete it (clean it up) and then\n@@ -343,7 +244,7 @@ public void claim() {\n                 logger.debug(\"claiming topic: \" + topic.toStringUtf8());\n             }\n \n-            ZkUtils.createFullPathOptimistic(zk, hubPath, addr.toString().getBytes(), Ids.OPEN_ACL_UNSAFE,\n+            ZkUtils.createFullPathOptimistic(zk, hubPath, myHubInfo.toString().getBytes(), Ids.OPEN_ACL_UNSAFE,\n             CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n \n                 @Override\n@@ -353,7 +254,7 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n                             logger.debug(\"claimed topic: \" + topic.toStringUtf8());\n                         }\n                         notifyListenersAndAddToOwnedTopics(topic, cb, ctx);\n-                        updateLoadInformation();\n+                        hubManager.uploadSelfLoadData(myHubLoad.setNumTopics(topics.size()));\n                     } else if (rc == Code.NODEEXISTS.intValue()) {\n                         read();\n                     } else {\n@@ -368,20 +269,6 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n \n     }\n \n-    byte[] getCurrentLoadData() {\n-        // For now, using the number of topics as an indicator of load\n-        // information\n-        return (topics.size() + \"\").getBytes();\n-    }\n-\n-    void updateLoadInformation() {\n-        byte[] currentLoad = getCurrentLoadData();\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Reporting load of \" + new String(currentLoad));\n-        }\n-        zk.setData(ephemeralNodePath, currentLoad, -1, loadReportingStatCallback, null);\n-    }\n-\n     @Override\n     protected void postReleaseCleanup(final ByteString topic, final Callback<Void> cb, Object ctx) {\n \n@@ -403,11 +290,20 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                     return;\n                 }\n \n-                HedwigSocketAddress owner = new HedwigSocketAddress(new String(data));\n-                if (!owner.equals(addr)) {\n-                    logger.warn(\"Wanted to delete self-node for topic: \" + topic.toStringUtf8() + \" but node for \"\n-                                + owner + \" found, leaving untouched\");\n-                    // Not our node, someone else's, leave it alone\n+                String hubInfoStr = new String(data);\n+                try {\n+                    HubInfo ownerHubInfo = HubInfo.parse(hubInfoStr);\n+                    HedwigSocketAddress owner = ownerHubInfo.getAddress();\n+                    if (!owner.equals(addr)) {\n+                        logger.warn(\"Wanted to delete self-node for topic: \" + topic.toStringUtf8() + \" but node for \"\n+                                    + owner + \" found, leaving untouched\");\n+                        // Not our node, someone else's, leave it alone\n+                        cb.operationFinished(ctx, null);\n+                        return;\n+                    }\n+                } catch (HubInfo.InvalidHubInfoException ihie) {\n+                    logger.info(\"Invalid hub info \" + hubInfoStr + \" found when release topic \"\n+                              + topic.toStringUtf8() + \". Leaving untouched until next acquire action.\");\n                     cb.operationFinished(ctx, null);\n                     return;\n                 }\n@@ -434,10 +330,8 @@ public void safeProcessResult(int rc, String path, Object ctx) {\n     public void stop() {\n         // we just unregister it with zookeeper to make it unavailable from hub servers list\n         try {\n-            unregisterWithZookeeper();\n-        } catch (InterruptedException e) {\n-            logger.error(\"Error unregistering hub server :\", e);\n-        } catch (KeeperException e) {\n+            hubManager.unregisterSelf();\n+        } catch (IOException e) {\n             logger.error(\"Error unregistering hub server :\", e);\n         }\n         super.stop();"},{"sha":"82e4eba563b973837f396623f15479b0106c4830","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","status":"modified","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -34,8 +34,10 @@\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.util.Either;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n \n import org.junit.Test;\n import org.junit.Assert;\n@@ -46,6 +48,92 @@ public TestMetadataManager(String metadataManagerFactoryCls) {\n         super(metadataManagerFactoryCls);\n     }\n \n+    @Test\n+    public void testOwnerInfo() throws Exception {\n+        TopicOwnershipManager toManager = metadataManagerFactory.newTopicOwnershipManager();\n+\n+        ByteString topic = ByteString.copyFromUtf8(\"testOwnerInfo\");\n+        StubCallback<Versioned<HubInfo>> readCallback = new StubCallback<Versioned<HubInfo>>();\n+        StubCallback<Version> writeCallback = new StubCallback<Version>();\n+        StubCallback<Void> deleteCallback = new StubCallback<Void>();\n+\n+        Either<Version, PubSubException> res;\n+        HubInfo owner = new HubInfo(new HedwigSocketAddress(\"127.0.0.1\", 8008), 999);\n+\n+        // Write non-existed owner info\n+        toManager.writeOwnerInfo(topic, owner, null, writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertEquals(null, res.right());\n+        Version v1 = res.left();\n+\n+        // read owner info\n+        toManager.readOwnerInfo(topic, readCallback, null);\n+        Versioned<HubInfo> hubInfo = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v1.compare(hubInfo.getVersion()));\n+        Assert.assertEquals(owner, hubInfo.getValue());\n+\n+        HubInfo newOwner = new HubInfo(new HedwigSocketAddress(\"127.0.0.1\", 8008), 1000);\n+\n+        // write exsited owner info with null version\n+        toManager.writeOwnerInfo(topic, newOwner, null, writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertNotNull(res.right());\n+        Assert.assertTrue(res.right() instanceof PubSubException.TopicOwnerInfoExistsException);\n+\n+        // write existed owner info with right version\n+        toManager.writeOwnerInfo(topic, newOwner, v1, writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertEquals(null, res.right());\n+        Version v2 = res.left();\n+        Assert.assertEquals(Version.Occurred.AFTER, v2.compare(v1));\n+\n+        // read owner info\n+        toManager.readOwnerInfo(topic, readCallback, null);\n+        hubInfo = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(hubInfo.getVersion()));\n+        Assert.assertEquals(newOwner, hubInfo.getValue());\n+\n+        HubInfo newOwner2 = new HubInfo(new HedwigSocketAddress(\"127.0.0.1\", 8008), 1001);\n+\n+        // write existed owner info with bad version\n+        toManager.writeOwnerInfo(topic, newOwner2, v1,\n+                                 writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertNotNull(res.right());\n+        Assert.assertTrue(res.right() instanceof PubSubException.BadVersionException);\n+\n+        // read owner info\n+        toManager.readOwnerInfo(topic, readCallback, null);\n+        hubInfo = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(hubInfo.getVersion()));\n+        Assert.assertEquals(newOwner, hubInfo.getValue());\n+\n+        // delete existed owner info with bad version\n+        toManager.deleteOwnerInfo(topic, v1, deleteCallback, null);\n+        Assert.assertTrue(deleteCallback.queue.take().right() instanceof\n+                          PubSubException.BadVersionException);\n+\n+        // read owner info\n+        toManager.readOwnerInfo(topic, readCallback, null);\n+        hubInfo = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(hubInfo.getVersion()));\n+\n+        // delete existed owner info with right version\n+        toManager.deleteOwnerInfo(topic, v2, deleteCallback, null);\n+        Assert.assertEquals(null, deleteCallback.queue.take().right());\n+\n+        // Empty owner info\n+        toManager.readOwnerInfo(topic, readCallback, null);\n+        Assert.assertEquals(null, readCallback.queue.take().left());\n+\n+        // delete non-existed owner info\n+        toManager.deleteOwnerInfo(topic, null, deleteCallback, null);\n+        Assert.assertTrue(deleteCallback.queue.take().right() instanceof\n+                          PubSubException.NoTopicOwnerInfoException);\n+\n+        toManager.close();\n+    }\n+\n     @Test\n     public void testPersistenceInfo() throws Exception {\n         TopicPersistenceManager tpManager = metadataManagerFactory.newTopicPersistenceManager();"},{"sha":"4c621ae0a6aed9f4cb78c47e0a2c76396c6d3cdb","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -85,6 +85,10 @@ public TopicPersistenceManager newTopicPersistenceManager() {\n         public SubscriptionDataManager newSubscriptionDataManager() {\n             return null;\n         }\n+\n+        public TopicOwnershipManager newTopicOwnershipManager() {\n+            return null;\n+        }\n     }\n \n     private void writeFactoryLayout(ServerConfiguration conf,"},{"sha":"d87575d0953e6aac0c6668043a1f56a7d5132827","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,62 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.topics;\n+\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class TestHubInfo {\n+\n+    @Test\n+    public void testParseHubInfo() throws Exception {\n+        HedwigSocketAddress addr = new HedwigSocketAddress(\"localhost\", 9086, 9087);\n+        HubInfo hubInfo1 = new HubInfo(addr, 9999);\n+\n+        String strHubInfo1 = hubInfo1.toString();\n+        HubInfo parsedHubInfo1 = HubInfo.parse(strHubInfo1);\n+        Assert.assertEquals(\"Hub infos should be same\", hubInfo1, parsedHubInfo1);\n+\n+        HubInfo hubInfo2 = new HubInfo(addr, 0);\n+        HubInfo parsedHubInfo2 = HubInfo.parse(\"localhost:9086:9087\");\n+        Assert.assertEquals(\"Hub infos w/o zxid should be same\", hubInfo2, parsedHubInfo2);\n+\n+        // parse empty string\n+        try {\n+            HubInfo.parse(\"\");\n+            Assert.fail(\"Should throw InvalidHubInfoException parsing empty string.\");\n+        } catch (HubInfo.InvalidHubInfoException ihie) {\n+        }\n+\n+        // parse corrupted hostname\n+        try {\n+            HubInfo.parse(\"localhost,a,b,c\");\n+            Assert.fail(\"Should throw InvalidHubInfoException parsing corrupted hostname.\");\n+        } catch (HubInfo.InvalidHubInfoException ihie) {\n+        }\n+\n+        // parse corrupted string\n+        try {\n+            HubInfo.parse(\"hostname: localhost:9086:9087\");\n+            Assert.fail(\"Should throw InvalidHubInfoException parsing corrupted string.\");\n+        } catch (HubInfo.InvalidHubInfoException ihie) {\n+        }\n+    }\n+}"},{"sha":"eb267b4bf7fc2208f1ccc644475b0fd85387b995","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,60 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.topics;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class TestHubLoad {\n+\n+    @Test\n+    public void testParseHubLoad() throws Exception {\n+        HubLoad hubLoad1 = new HubLoad(9999);\n+\n+        String strHubLoad1 = hubLoad1.toString();\n+        HubLoad parsedHubLoad1 = HubLoad.parse(strHubLoad1);\n+        Assert.assertEquals(\"Hub load data should be same\", hubLoad1, parsedHubLoad1);\n+\n+        final int numTopics = 9998;\n+        HubLoad hubLoad2 = new HubLoad(numTopics);\n+        HubLoad parsedHubLoad2 = HubLoad.parse(numTopics + \"\");\n+        Assert.assertEquals(\"Hub load data not protobuf encoded should be same\", hubLoad2, parsedHubLoad2);\n+\n+        // parse empty string\n+        try {\n+            HubLoad.parse(\"\");\n+            Assert.fail(\"Should throw InvalidHubLoadException parsing empty string.\");\n+        } catch (HubLoad.InvalidHubLoadException ihie) {\n+        }\n+\n+        // parse corrupted numTopics\n+        try {\n+            HubLoad.parse(\"9998_x\");\n+            Assert.fail(\"Should throw InvalidHubLoadException parsing corrupted hub load data.\");\n+        } catch (HubLoad.InvalidHubLoadException ihie) {\n+        }\n+\n+        // parse corrupted string\n+        try {\n+            HubLoad.parse(\"hostname: 9998_x\");\n+            Assert.fail(\"Should throw InvalidHubLoadException parsing corrupted hub load data.\");\n+        } catch (HubLoad.InvalidHubLoadException ihie) {\n+        }\n+    }\n+}"},{"sha":"b85777c935a8bb7d7d2c022d0c490675b852b77f","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java","status":"added","additions":321,"deletions":0,"changes":321,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.topics;\n+\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.StubCallback;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.CompositeException;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactoryTestCase;\n+import org.apache.hedwig.server.meta.TopicOwnershipManager;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.ConcurrencyUtils;\n+import org.apache.hedwig.util.Either;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.hedwig.util.Pair;\n+import org.apache.hedwig.zookeeper.ZooKeeperTestBase;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestMMTopicManager extends MetadataManagerFactoryTestCase {\n+\n+    static Logger LOG = LoggerFactory.getLogger(TestMMTopicManager.class);\n+\n+    protected MMTopicManager tm;\n+    protected TopicOwnershipManager tom;\n+\n+    protected class CallbackQueue<T> implements Callback<T> {\n+        SynchronousQueue<Either<T, Exception>> q = new SynchronousQueue<Either<T, Exception>>();\n+\n+        public SynchronousQueue<Either<T, Exception>> getQueue() {\n+            return q;\n+        }\n+\n+        public Either<T, Exception> take() throws InterruptedException {\n+            return q.take();\n+        }\n+\n+        @Override\n+        public void operationFailed(Object ctx, final PubSubException exception) {\n+            LOG.error(\"got exception: \" + exception);\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ConcurrencyUtils.put(q, Either.of((T) null, (Exception) exception));\n+                }\n+            }).start();\n+        }\n+\n+        @Override\n+        public void operationFinished(Object ctx, final T resultOfOperation) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ConcurrencyUtils.put(q, Either.of(resultOfOperation, (Exception) null));\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    protected CallbackQueue<HedwigSocketAddress> addrCbq = new CallbackQueue<HedwigSocketAddress>();\n+    protected CallbackQueue<ByteString> bsCbq = new CallbackQueue<ByteString>();\n+    protected CallbackQueue<Void> voidCbq = new CallbackQueue<Void>();\n+\n+    protected ByteString topic = ByteString.copyFromUtf8(\"topic\");\n+    protected HedwigSocketAddress me;\n+    protected ScheduledExecutorService scheduler;\n+\n+    public TestMMTopicManager(String metaManagerCls) {\n+        super(metaManagerCls);\n+    }\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        me = conf.getServerAddr();\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n+        tom = metadataManagerFactory.newTopicOwnershipManager();\n+        tm = new MMTopicManager(conf, zk, metadataManagerFactory, scheduler);\n+    }\n+\n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        tom.close();\n+        tm.stop();\n+        super.tearDown();\n+    }\n+\n+    @Test\n+    public void testGetOwnerSingle() throws Exception {\n+        tm.getOwner(topic, false, addrCbq, null);\n+        Assert.assertEquals(me, check(addrCbq.take()));\n+    }\n+\n+    protected ByteString mkTopic(int i) {\n+        return ByteString.copyFromUtf8(topic.toStringUtf8() + i);\n+    }\n+\n+    protected <T> T check(Either<T, Exception> ex) throws Exception {\n+        if (ex.left() == null)\n+            throw ex.right();\n+        else\n+            return ex.left();\n+    }\n+\n+    public static class CustomServerConfiguration extends ServerConfiguration {\n+        int port;\n+\n+        public CustomServerConfiguration(int port) {\n+            this.port = port;\n+        }\n+\n+        @Override\n+        public int getServerPort() {\n+            return port;\n+        }\n+    }\n+\n+    @Test\n+    public void testGetOwnerMulti() throws Exception {\n+        ServerConfiguration conf1 = new CustomServerConfiguration(conf.getServerPort() + 1),\n+                            conf2 = new CustomServerConfiguration(conf.getServerPort() + 2);\n+        MMTopicManager tm1 = new MMTopicManager(conf1, zk, metadataManagerFactory, scheduler),\n+                       tm2 = new MMTopicManager(conf2, zk, metadataManagerFactory, scheduler);\n+\n+        tm.getOwner(topic, false, addrCbq, null);\n+        HedwigSocketAddress owner = check(addrCbq.take());\n+\n+        for (int i = 0; i < 100; ++i) {\n+            tm.getOwner(topic, false, addrCbq, null);\n+            Assert.assertEquals(owner, check(addrCbq.take()));\n+\n+            tm1.getOwner(topic, false, addrCbq, null);\n+            Assert.assertEquals(owner, check(addrCbq.take()));\n+\n+            tm2.getOwner(topic, false, addrCbq, null);\n+            Assert.assertEquals(owner, check(addrCbq.take()));\n+        }\n+\n+        for (int i = 0; i < 100; ++i) {\n+            if (!owner.equals(me))\n+                break;\n+            tm.getOwner(mkTopic(i), false, addrCbq, null);\n+            owner = check(addrCbq.take());\n+            if (i == 99)\n+                Assert.fail(\"Never chose another owner\");\n+        }\n+\n+        tm1.stop();\n+        tm2.stop();\n+    }\n+\n+    @Test\n+    public void testLoadBalancing() throws Exception {\n+        tm.getOwner(topic, false, addrCbq, null);\n+\n+        Assert.assertEquals(me, check(addrCbq.take()));\n+\n+        ServerConfiguration conf1 = new CustomServerConfiguration(conf.getServerPort() + 1);\n+        TopicManager tm1 = new MMTopicManager(conf1, zk, metadataManagerFactory, scheduler);\n+\n+        ByteString topic1 = mkTopic(1);\n+        tm.getOwner(topic1, false, addrCbq, null);\n+        Assert.assertEquals(conf1.getServerAddr(), check(addrCbq.take()));\n+\n+        tm1.stop();\n+    }\n+\n+    class StubOwnershipChangeListener implements TopicOwnershipChangeListener {\n+        boolean failure;\n+        SynchronousQueue<Pair<ByteString, Boolean>> bsQueue;\n+\n+        public StubOwnershipChangeListener(SynchronousQueue<Pair<ByteString, Boolean>> bsQueue) {\n+            this.bsQueue = bsQueue;\n+        }\n+\n+        public void setFailure(boolean failure) {\n+            this.failure = failure;\n+        }\n+\n+        @Override\n+        public void lostTopic(final ByteString topic) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ConcurrencyUtils.put(bsQueue, Pair.of(topic, false));\n+                }\n+            }).start();\n+        }\n+\n+        public void acquiredTopic(final ByteString topic, final Callback<Void> callback, final Object ctx) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ConcurrencyUtils.put(bsQueue, Pair.of(topic, true));\n+                    if (failure) {\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(\"Asked to fail\"));\n+                    } else {\n+                        callback.operationFinished(ctx, null);\n+                    }\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    @Test\n+    public void testOwnershipChange() throws Exception {\n+        SynchronousQueue<Pair<ByteString, Boolean>> bsQueue = new SynchronousQueue<Pair<ByteString, Boolean>>();\n+\n+        StubOwnershipChangeListener listener = new StubOwnershipChangeListener(bsQueue);\n+\n+        tm.addTopicOwnershipChangeListener(listener);\n+\n+        // regular acquire\n+        tm.getOwner(topic, true, addrCbq, null);\n+        Pair<ByteString, Boolean> pair = bsQueue.take();\n+        Assert.assertEquals(topic, pair.first());\n+        Assert.assertTrue(pair.second());\n+        Assert.assertEquals(me, check(addrCbq.take()));\n+        assertOwnershipNodeExists();\n+\n+        // topic that I already own\n+        tm.getOwner(topic, true, addrCbq, null);\n+        Assert.assertEquals(me, check(addrCbq.take()));\n+        Assert.assertTrue(bsQueue.isEmpty());\n+        assertOwnershipNodeExists();\n+\n+        // regular release\n+        tm.releaseTopic(topic, cb, null);\n+        pair = bsQueue.take();\n+        Assert.assertEquals(topic, pair.first());\n+        Assert.assertFalse(pair.second());\n+        Assert.assertTrue(queue.take());\n+        assertOwnershipNodeDoesntExist();\n+\n+        // releasing topic that I don't own\n+        tm.releaseTopic(mkTopic(0), cb, null);\n+        Assert.assertTrue(queue.take());\n+        Assert.assertTrue(bsQueue.isEmpty());\n+\n+        // set listener to return error\n+        listener.setFailure(true);\n+\n+        tm.getOwner(topic, true, addrCbq, null);\n+        pair = bsQueue.take();\n+        Assert.assertEquals(topic, pair.first());\n+        Assert.assertTrue(pair.second());\n+        Assert.assertEquals(PubSubException.ServiceDownException.class, ((CompositeException) addrCbq.take().right())\n+                            .getExceptions().iterator().next().getClass());\n+        Assert.assertFalse(tm.topics.contains(topic));\n+        Thread.sleep(100);\n+        assertOwnershipNodeDoesntExist();\n+\n+    }\n+\n+    public void assertOwnershipNodeExists() throws Exception {\n+        StubCallback<Versioned<HubInfo>> callback = new StubCallback<Versioned<HubInfo>>();\n+        tom.readOwnerInfo(topic, callback, null);\n+        Versioned<HubInfo> hubInfo = callback.queue.take().left();\n+        Assert.assertEquals(tm.addr, hubInfo.getValue().getAddress());\n+    }\n+\n+    public void assertOwnershipNodeDoesntExist() throws Exception {\n+        StubCallback<Versioned<HubInfo>> callback = new StubCallback<Versioned<HubInfo>>();\n+        tom.readOwnerInfo(topic, callback, null);\n+        Versioned<HubInfo> hubInfo = callback.queue.take().left();\n+        Assert.assertEquals(null, hubInfo);\n+    }\n+\n+    @Test\n+    public void testZKClientDisconnected() throws Exception {\n+        // First assert ownership of the topic\n+        tm.getOwner(topic, true, addrCbq, null);\n+        Assert.assertEquals(me, check(addrCbq.take()));\n+\n+        // Suspend the ZKTopicManager and make sure calls to getOwner error out\n+        tm.isSuspended = true;\n+        tm.getOwner(topic, true, addrCbq, null);\n+        Assert.assertEquals(PubSubException.ServiceDownException.class, addrCbq.take().right().getClass());\n+        // Release the topic. This should not error out even if suspended.\n+        tm.releaseTopic(topic, cb, null);\n+        Assert.assertTrue(queue.take());\n+        assertOwnershipNodeDoesntExist();\n+\n+        // Restart the ZKTopicManager and make sure calls to getOwner are okay\n+        tm.isSuspended = false;\n+        tm.getOwner(topic, true, addrCbq, null);\n+        Assert.assertEquals(me, check(addrCbq.take()));\n+        assertOwnershipNodeExists();\n+    }\n+\n+}"},{"sha":"9e4378b02fcc3fb730d8cac5959a574c2cea7de6","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","status":"modified","additions":17,"deletions":3,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/4d9f3d32a063975303f42a7108cbd4892062ab89/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java?ref=4d9f3d32a063975303f42a7108cbd4892062ab89","patch":"@@ -22,6 +22,7 @@\n import java.util.concurrent.SynchronousQueue;\n \n import org.apache.zookeeper.KeeperException;\n+import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -97,6 +98,13 @@ public void setUp() throws Exception {\n         tm = new ZkTopicManager(zk, cfg, scheduler);\n     }\n \n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        tm.stop();\n+        super.tearDown();\n+    }\n+\n     @Test\n     public void testGetOwnerSingle() throws Exception {\n         tm.getOwner(topic, false, addrCbq, null);\n@@ -132,7 +140,8 @@ public void testGetOwnerMulti() throws Exception {\n         ServerConfiguration cfg1 = new CustomServerConfiguration(cfg.getServerPort() + 1), cfg2 = new CustomServerConfiguration(\n             cfg.getServerPort() + 2);\n         // TODO change cfg1 cfg2 params\n-        ZkTopicManager tm1 = new ZkTopicManager(zk, cfg1, scheduler), tm2 = new ZkTopicManager(zk, cfg2, scheduler);\n+        ZkTopicManager tm1 = new ZkTopicManager(zk, cfg1, scheduler),\n+                       tm2 = new ZkTopicManager(zk, cfg2, scheduler);\n \n         tm.getOwner(topic, false, addrCbq, null);\n         HedwigSocketAddress owner = check(addrCbq.take());\n@@ -172,6 +181,9 @@ else if (owner.getPort() == cfg2.getServerPort())\n             tm.getOwner(mkTopic(100), true, addrCbq, null);\n             Assert.assertEquals(me, check(addrCbq.take()));\n         }\n+\n+        tm1.stop();\n+        tm2.stop();\n     }\n \n     @Test\n@@ -181,12 +193,13 @@ public void testLoadBalancing() throws Exception {\n         Assert.assertEquals(me, check(addrCbq.take()));\n \n         ServerConfiguration cfg1 = new CustomServerConfiguration(cfg.getServerPort() + 1);\n-        new ZkTopicManager(zk, cfg1, scheduler);\n+        TopicManager tm1 = new ZkTopicManager(zk, cfg1, scheduler);\n \n         ByteString topic1 = mkTopic(1);\n         tm.getOwner(topic1, false, addrCbq, null);\n         Assert.assertEquals(cfg1.getServerAddr(), check(addrCbq.take()));\n \n+        tm1.stop();\n     }\n \n     class StubOwnershipChangeListener implements TopicOwnershipChangeListener {\n@@ -278,7 +291,8 @@ public void testOwnershipChange() throws Exception {\n \n     public void assertOwnershipNodeExists() throws Exception {\n         byte[] data = zk.getData(tm.hubPath(topic), false, null);\n-        Assert.assertEquals(new HedwigSocketAddress(new String(data)), tm.addr);\n+        Assert.assertEquals(HubInfo.parse(new String(data)).getAddress(),\n+                            tm.addr);\n     }\n \n     public void assertOwnershipNodeDoesntExist() throws Exception {"}]}

