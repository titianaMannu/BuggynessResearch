{"sha":"51ca99b871ebf85738c82cb1f86eb7de223a44b2","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1MWNhOTliODcxZWJmODU3MzhjODJjYjFmODZlYjdkZTIyM2E0NGIy","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-07-16T10:35:19Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-07-16T10:35:19Z"},"message":"BOOKKEEPER-310: Changes in hedwig server to support JMS spec (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1361968 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cab4865ccf7c60296d041a54f32cff9dab516f82","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/cab4865ccf7c60296d041a54f32cff9dab516f82"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/51ca99b871ebf85738c82cb1f86eb7de223a44b2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/51ca99b871ebf85738c82cb1f86eb7de223a44b2","html_url":"https://github.com/apache/bookkeeper/commit/51ca99b871ebf85738c82cb1f86eb7de223a44b2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/51ca99b871ebf85738c82cb1f86eb7de223a44b2/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"0e06ddeb7e47bd8794fd378629602e41ea4a1fd9","url":"https://api.github.com/repos/apache/bookkeeper/commits/0e06ddeb7e47bd8794fd378629602e41ea4a1fd9","html_url":"https://github.com/apache/bookkeeper/commit/0e06ddeb7e47bd8794fd378629602e41ea4a1fd9"}],"stats":{"total":1998,"additions":928,"deletions":1070},"files":[{"sha":"5b9d9f0edff3f805f34108ed6e3c9b8bd0f1bae3","filename":"CHANGES.txt","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -60,6 +60,10 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-329: provide stop scripts for hub server (sijie via ivank)\n \n+      hedwig-client:\n+\n+        BOOKKEEPER-310: Changes in hedwig server to support JMS spec (ivank via sijie)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"f6fd377f8d847ea6234b229074ae02e5b6c00083","filename":"hedwig-client/src/main/cpp/README","status":"modified","additions":31,"deletions":3,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/README","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/README","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/README?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -1,10 +1,38 @@\n+= BUILDING =\n+\n To build:\n    $ libtoolize\n    $ autoreconf -fi\n    $ ./configure\n    $ make\n \n-The devel packages for protobuf, cppunit, log4cxx & boost are required.\n+The devel packages for protobuf, log4cxx & boost are required to build.\n+\n+= TESTING =\n+\n+To test, Google Test(http://code.google.com/p/googletest/) is required.\n+The project must be configured with the location of gtest. Making with\n+the target \"check\" will run all the tests.\n+\n+   $ ./configure --enable-gtest=/home/user/src/gtest-1.6.0\n+   $ make check\n+\n+To run individual tests, first start a test cluster. We provide a \n+convenience script to do this.\n+\n+   $ sh scripts/tester.sh start-cluster\n+\n+Once the cluster is running, you can run individual tests using the test\n+harness.\n+\n+   $ test/hedwigtest --gtest_filter=PublishTest.testAsyncPublish\n+\n+To get a list of tests:\n+\n+   $ test/hedwigtest --gtest_list_tests\n+\n+test/hedwigtest is a libtool wrapper, which cannot be used directly with\n+gdb. To run a test with gdb:\n \n-To test:\n-   $ make check\n\\ No newline at end of file\n+   $ libtool --mode=execute gdb test/hedwigtest\n+   (gdb) run --gtest_filter=PublishTest.testAsyncPublish"},{"sha":"8418f512120b1e49d7905d7f48449fa3a8293b5e","filename":"hedwig-client/src/main/cpp/configure.ac","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/configure.ac","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/configure.ac","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/configure.ac?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -27,7 +27,9 @@ AC_CONFIG_FILES([Makefile lib/Makefile test/Makefile hedwig-0.1.pc])\n AC_PROG_LIBTOOL\n AC_CONFIG_MACRO_DIR([m4])\n PKG_CHECK_MODULES([DEPS], [liblog4cxx protobuf])\n-PKG_CHECK_MODULES([TESTDEPS], [cppunit])\n+\n+GTEST_LIB_CHECK([1.5.0], [AC_MSG_RESULT([GoogleTest found, Tests Enabled])],\n+                         [AC_MSG_WARN([GoogleTest not found, Tests disabled])])\n \n AX_BOOST_BASE\n AX_BOOST_ASIO\t  "},{"sha":"648f43c4abcbf55e901c677013237bc54067f932","filename":"hedwig-client/src/main/cpp/m4/gtest.m4","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/m4/gtest.m4","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/m4/gtest.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/gtest.m4?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -0,0 +1,74 @@\n+dnl GTEST_LIB_CHECK([minimum version [,\n+dnl                  action if found [,action if not found]]])\n+dnl\n+dnl Check for the presence of the Google Test library, optionally at a minimum\n+dnl version, and indicate a viable version with the HAVE_GTEST flag. It defines\n+dnl standard variables for substitution including GTEST_CPPFLAGS,\n+dnl GTEST_CXXFLAGS, GTEST_LDFLAGS, and GTEST_LIBS. It also defines\n+dnl GTEST_VERSION as the version of Google Test found. Finally, it provides\n+dnl optional custom action slots in the event GTEST is found or not.\n+AC_DEFUN([GTEST_LIB_CHECK],\n+[\n+dnl Provide a flag to enable or disable Google Test usage.\n+AC_ARG_ENABLE([gtest],\n+  [AS_HELP_STRING([--enable-gtest],\n+                  [Enable tests using the Google C++ Testing Framework.\n+                  (Default is disabled.)])],\n+  [],\n+  [enable_gtest=no])\n+AC_ARG_VAR([GTEST_CONFIG],\n+           [The exact path of Google Test's 'gtest-config' script.])\n+AC_ARG_VAR([GTEST_CPPFLAGS],\n+           [C-like preprocessor flags for Google Test.])\n+AC_ARG_VAR([GTEST_CXXFLAGS],\n+           [C++ compile flags for Google Test.])\n+AC_ARG_VAR([GTEST_LDFLAGS],\n+           [Linker path and option flags for Google Test.])\n+AC_ARG_VAR([GTEST_LIBS],\n+           [Library linking flags for Google Test.])\n+AC_ARG_VAR([GTEST_VERSION],\n+           [The version of Google Test available.])\n+HAVE_GTEST=\"no\"\n+AS_IF([test \"x${enable_gtest}\" != \"xno\"],\n+  [AC_MSG_CHECKING([for 'gtest-config'])\n+   AS_IF([test \"x${enable_gtest}\" != \"xyes\"],\n+     [AS_IF([test -x \"${enable_gtest}/scripts/gtest-config\"],\n+        [GTEST_CONFIG=\"${enable_gtest}/scripts/gtest-config\"],\n+        [GTEST_CONFIG=\"${enable_gtest}/bin/gtest-config\"])\n+      AS_IF([test -x \"${GTEST_CONFIG}\"], [],\n+        [AC_MSG_RESULT([no])\n+         AC_MSG_ERROR([dnl\n+Unable to locate either a built or installed Google Test.\n+The specific location '${enable_gtest}' was provided for a built or installed\n+Google Test, but no 'gtest-config' script could be found at this location.])\n+         ])],\n+     [AC_PATH_PROG([GTEST_CONFIG], [gtest-config])])\n+   AS_IF([test -x \"${GTEST_CONFIG}\"],\n+     [AC_MSG_RESULT([${GTEST_CONFIG}])\n+      m4_ifval([$1],\n+        [_gtest_min_version=\"--min-version=$1\"\n+         AC_MSG_CHECKING([for Google Test at least version >= $1])],\n+        [_gtest_min_version=\"--min-version=0\"\n+         AC_MSG_CHECKING([for Google Test])])\n+      AS_IF([${GTEST_CONFIG} ${_gtest_min_version}],\n+        [AC_MSG_RESULT([yes])\n+         HAVE_GTEST='yes'],\n+        [AC_MSG_RESULT([no])])],\n+     [AC_MSG_RESULT([no])])\n+   AS_IF([test \"x${HAVE_GTEST}\" = \"xyes\"],\n+     [GTEST_CPPFLAGS=`${GTEST_CONFIG} --cppflags`\n+      GTEST_CXXFLAGS=`${GTEST_CONFIG} --cxxflags`\n+      GTEST_LDFLAGS=`${GTEST_CONFIG} --ldflags`\n+      GTEST_LIBS=`${GTEST_CONFIG} --libs`\n+      GTEST_VERSION=`${GTEST_CONFIG} --version`\n+      AC_DEFINE([HAVE_GTEST],[1],[Defined when Google Test is available.])],\n+     [AS_IF([test \"x${enable_gtest}\" = \"xyes\"],\n+        [AC_MSG_ERROR([dnl\n+Google Test was enabled, but no viable version could be found.])\n+         ])])])\n+AC_SUBST([HAVE_GTEST])\n+AM_CONDITIONAL([HAVE_GTEST],[test \"x$HAVE_GTEST\" = \"xyes\"])\n+AS_IF([test \"x$HAVE_GTEST\" = \"xyes\"],\n+  [m4_ifval([$2], [$2])],\n+  [m4_ifval([$3], [$3])])\n+])"},{"sha":"0cd3a868ba827aba4f280b6e16815e5c572f4bd7","filename":"hedwig-client/src/main/cpp/scripts/log4cxx.conf","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/scripts/log4cxx.conf","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/scripts/log4cxx.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/log4cxx.conf?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -26,24 +26,18 @@ log4j.appender.rootAppender.layout=org.apache.log4j.BasicLayout\n log4j.appender.hedwig=org.apache.log4j.ConsoleAppender\n #log4j.appender.hedwig.fileName=./testLog.log\n log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwig.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %c %p - %m%n\n-log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwig.layout.ConversionPattern=%.5m%n\n+log4j.appender.hedwig.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %p %c - %m%n\n \n log4j.appender.hedwigtest=org.apache.log4j.ConsoleAppender\n #log4j.appender.hedwig.fileName=./testLog.log\n log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwigtest.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %c %p - %m%n\n-log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwigtest.layout.ConversionPattern=%.5m%n\n+log4j.appender.hedwigtest.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %p %c - %m%n\n \n # category\n-log4j.category.hedwig=INFO, hedwig\n-log4j.rootCategory=INFO\n+log4j.category.hedwig=OFF, hedwig\n+log4j.category.hedwigtest=OFF, hedwigtest\n+\n+log4j.rootCategory=OFF\n \n #log4j.category.hedwig.channel=ERROR\n-log4j.category.hedwig.util=ERROR\n-log4j.category.hedwigtest.servercontrol=ERROR\n \n-log4j.category.hedwigtest=INFO, hedwigtest\n-log4j.rootCategory=INFO"},{"sha":"fd3b5198c50299c9d0e90c760b9cdd66fb996eed","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -67,7 +67,7 @@ singletest() {\n     stop_cluster;\n     start_cluster;\n \n-    ../test/hedwigtest $1\n+    ../test/hedwigtest --gtest_filter=$1\n     RESULT=$?\n     stop_cluster;\n "},{"sha":"e8663dcade91eef627f9ac918ce05aa77fa7c263","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"modified","additions":12,"deletions":4,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -16,11 +16,19 @@\n # limitations under the License.\n #\n \n+if HAVE_GTEST\n bin_PROGRAMS = hedwigtest\n-hedwigtest_SOURCES = main.cpp utiltest.cpp pubsubdatatest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp\n-hedwigtest_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS) $(TESTDEPS_CFLAGS) $(BOOST_CPPFLAGS) \n-hedwigtest_LDADD = $(DEPS_LIBS) $(TESTDEPS_LIBS) -L$(top_builddir)/lib -lhedwig01 \n-hedwigtest_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)\n+hedwigtest_SOURCES = main.cpp utiltest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp\n+hedwigtest_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS) $(GTEST_CPPFLAGS) $(BOOST_CPPFLAGS)\n+hedwigtest_CXXFLAGS = $(GTEST_CXXFLAGS)\n+hedwigtest_LDADD = $(DEPS_LIBS) $(GTEST_LIBS) -L$(top_builddir)/lib -lhedwig01\n+hedwigtest_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB) $(GTEST_LDFLAGS)\n \n check: hedwigtest\n \tbash ../scripts/tester.sh all\n+else\n+check:\n+\t@echo \"\\n\\nYou haven't configured with gtest. Run the ./configure command with --enable-gtest=<path_to_gtest>\"\n+\t@echo \"i.e. ./configure --enable-gtest=/home/user/src/gtest-1.6.0\"\n+\t@echo \"See the README for more info\\n\\n\\b\"\n+endif"},{"sha":"a0e37c3f0da79aa236b8032d44385287d8f76da2","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"modified","additions":5,"deletions":30,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -32,13 +32,7 @@\n \n #include \"util.h\"\n \n-#include <cppunit/extensions/TestFactoryRegistry.h>\n-#include <cppunit/ui/text/TextTestRunner.h>\n-\n-#include <cppunit/TextTestProgressListener.h>\n-#include <cppunit/TestResult.h>\n-\n-HedwigCppTextTestProgressListener gprogress;\n+#include \"gtest/gtest.h\"\n \n int main( int argc, char **argv)\n {\n@@ -54,29 +48,10 @@ int main( int argc, char **argv)\n   } catch (...) {\n     std::cerr << \"unknown exception while configuring log4cpp vi'.\" << std::endl;\n   }\n-  std::string testPath = (argc > 2) ? std::string(argv[2]) : \"\";\n-\n-  CppUnit::TextTestRunner runner;\n-\n-  if (argc > 1) {\n-    CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry(argv[1]);\n-    \n-    runner.addTest( registry.makeTest() );\n-  } else {\n-    CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry(\"*\");\n-    registry.addRegistry(\"Util\");\n-    registry.addRegistry(\"Subscribe\");\n-    registry.addRegistry(\"Publish\"); \n-    registry.addRegistry(\"PubSub\");\n-    registry.addRegistry(\"MessageBound\");\n-    \n-    runner.addTest( registry.makeTest() );\n-  }\n   \n-  runner.eventManager().addListener( &gprogress );\n-\n-  bool ret = runner.run(testPath);\n+  ::testing::InitGoogleTest(&argc, argv);\n+  int ret = RUN_ALL_TESTS();\n   google::protobuf::ShutdownProtobufLibrary();\n-  \n-  return (ret == true) ? 0 : 1;\n+\n+  return ret;\n }"},{"sha":"0aa2251592d37b0aba8e1f25e62c385d56465c79","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"modified","additions":111,"deletions":136,"changes":247,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -19,9 +19,7 @@\n #include <config.h>\n #endif\n \n-#include <cppunit/Test.h>\n-#include <cppunit/TestSuite.h>\n-#include <cppunit/extensions/HelperMacros.h>\n+#include \"gtest/gtest.h\"\n \n #include \"../lib/clientimpl.h\"\n #include <hedwig/exceptions.h>\n@@ -35,175 +33,152 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n-class MessageBoundTestSuite : public CppUnit::TestFixture {\n-  class MessageBoundConfiguration : public Hedwig::Configuration {\n-  public:\n-    MessageBoundConfiguration() : address(\"localhost:4081\") {}\n+\n+class MessageBoundConfiguration : public Hedwig::Configuration {\n+public:\n+  MessageBoundConfiguration() : address(\"localhost:4081\") {}\n     \n-    virtual int getInt(const std::string& key, int defaultVal) const {\n-      if (key == Configuration::SUBSCRIPTION_MESSAGE_BOUND) {\n-\treturn 5;\n-      }\n-      return defaultVal;\n+  virtual int getInt(const std::string& key, int defaultVal) const {\n+    if (key == Configuration::SUBSCRIPTION_MESSAGE_BOUND) {\n+      return 5;\n     }\n+    return defaultVal;\n+  }\n \n-    virtual const std::string get(const std::string& key, const std::string& defaultVal) const {\n-      if (key == Configuration::DEFAULT_SERVER) {\n-\treturn address;\n-      } else {\n-\treturn defaultVal;\n-      }\n-    }\n-    \n-    virtual bool getBool(const std::string& /*key*/, bool defaultVal) const {\n+  virtual const std::string get(const std::string& key, const std::string& defaultVal) const {\n+    if (key == Configuration::DEFAULT_SERVER) {\n+      return address;\n+    } else {\n       return defaultVal;\n     }\n-\n-    protected:\n-    const std::string address;\n-  };\n+  }\n     \n-private:\n-  CPPUNIT_TEST_SUITE( MessageBoundTestSuite );\n-  CPPUNIT_TEST(testMessageBound);\n-  CPPUNIT_TEST(testMultipleSubscribers);\n-  CPPUNIT_TEST_SUITE_END();\n+  virtual bool getBool(const std::string& /*key*/, bool defaultVal) const {\n+    return defaultVal;\n+  }\n \n+protected:\n+  const std::string address;\n+};\n+    \n+class MessageBoundOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n public:\n-  MessageBoundTestSuite() {    \n+  MessageBoundOrderCheckingMessageHandlerCallback(const int nextExpectedMsg)\n+    : nextExpectedMsg(nextExpectedMsg) {\n   }\n \n-  ~MessageBoundTestSuite() {\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+\t\t       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+      \n+    int thisMsg = atoi(msg.body().c_str());\n+    LOG4CXX_DEBUG(logger, \"received message \" << thisMsg);\n+    if (thisMsg == nextExpectedMsg) {\n+      nextExpectedMsg++;\n+    }\n+    // checking msgId\n+    callback->operationComplete();\n   }\n \n-  void setUp()\n-  {\n-  }\n-  \n-  void tearDown() \n-  {\n+  int nextExpected() {\n+    return nextExpectedMsg;\n   }\n \n-  class MyOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n-  public:\n-    MyOrderCheckingMessageHandlerCallback(const int nextExpectedMsg)\n-      : nextExpectedMsg(nextExpectedMsg) {\n-    }\n-\n-    virtual void consume(const std::string& topic, const std::string& subscriberId,\n-                         const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n-      boost::lock_guard<boost::mutex> lock(mutex);\n-      \n-      int thisMsg = atoi(msg.body().c_str());\n-      LOG4CXX_DEBUG(logger, \"received message \" << thisMsg);\n-      if (thisMsg == nextExpectedMsg) {\n-\tnextExpectedMsg++;\n-      }\n-      // checking msgId\n-      callback->operationComplete();\n-    }\n-\n-    int nextExpected() {\n-      return nextExpectedMsg;\n-    }\n+protected:\n+  boost::mutex mutex;\n+  int nextExpectedMsg;\n+};\n \n-  protected:\n-    boost::mutex mutex;\n-    int nextExpectedMsg;\n-  };\n-\n-  void sendXExpectLastY(Hedwig::Publisher& pub, Hedwig::Subscriber& sub, const std::string& topic, \n-\t\t\t  const std::string& subid, int X, int Y) {\n-    for (int i = 0; i < X; i++) {\n-      std::stringstream oss;\n-      oss << i;\n-      pub.publish(topic, oss.str());\n-    }\n+void sendXExpectLastY(Hedwig::Publisher& pub, Hedwig::Subscriber& sub, const std::string& topic, \n+\t\t      const std::string& subid, int X, int Y) {\n+  for (int i = 0; i < X; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic, oss.str());\n+  }\n \n-    sub.subscribe(topic, subid, Hedwig::SubscribeRequest::ATTACH);\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::ATTACH);\n \n-    MyOrderCheckingMessageHandlerCallback* cb =\n-      new MyOrderCheckingMessageHandlerCallback(X - Y);\n+  MessageBoundOrderCheckingMessageHandlerCallback* cb =\n+    new MessageBoundOrderCheckingMessageHandlerCallback(X - Y);\n \n-    Hedwig::MessageHandlerCallbackPtr handler(cb);\n-    sub.startDelivery(topic, subid, handler);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  sub.startDelivery(topic, subid, handler);\n \n-    for (int i = 0; i < 100; i++) {\n-      if (cb->nextExpected() == X) {\n-\tbreak;\n-      } else {\n-\tsleep(1);\n-      }\n+  for (int i = 0; i < 100; i++) {\n+    if (cb->nextExpected() == X) {\n+      break;\n+    } else {\n+      sleep(1);\n     }\n-    CPPUNIT_ASSERT(cb->nextExpected() == X);\n-\n-    sub.stopDelivery(topic, subid);\n-    sub.closeSubscription(topic, subid);\n   }\n+  ASSERT_TRUE(cb->nextExpected() == X);\n+\n+  sub.stopDelivery(topic, subid);\n+  sub.closeSubscription(topic, subid);\n+}\n \n-  void testMessageBound() {\n-    Hedwig::Configuration* conf = new MessageBoundConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+TEST(MessageBoundTest, testMessageBound) {\n+  Hedwig::Configuration* conf = new MessageBoundConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n \n-    std::string topic = \"testTopic\";\n-    std::string subid = \"testSubId\";\n-    sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.closeSubscription(topic, subid);\n+  std::string topic = \"testTopic\";\n+  std::string subid = \"testSubId\";\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.closeSubscription(topic, subid);\n \n-    sendXExpectLastY(pub, sub, topic, subid, 100, 5);\n-  }\n+  sendXExpectLastY(pub, sub, topic, subid, 100, 5);\n+}\n \n-  void testMultipleSubscribers() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+TEST(MessageBoundTest, testMultipleSubscribers) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n     \n-    Hedwig::SubscriptionOptions options5;\n-    options5.set_messagebound(5);\n-    options5.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    Hedwig::SubscriptionOptions options20;\n-    options20.set_messagebound(20);\n-    options20.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    Hedwig::SubscriptionOptions optionsUnlimited;\n-    optionsUnlimited.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  Hedwig::SubscriptionOptions options5;\n+  options5.set_messagebound(5);\n+  options5.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  Hedwig::SubscriptionOptions options20;\n+  options20.set_messagebound(20);\n+  options20.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  Hedwig::SubscriptionOptions optionsUnlimited;\n+  optionsUnlimited.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n \n-    std::string topic = \"testTopic\";\n-    std::string subid5 = \"testSubId5\";\n-    std::string subid20 = \"testSubId20\";\n-    std::string subidUnlimited = \"testSubIdUnlimited\";\n+  std::string topic = \"testTopic\";\n+  std::string subid5 = \"testSubId5\";\n+  std::string subid20 = \"testSubId20\";\n+  std::string subidUnlimited = \"testSubIdUnlimited\";\n \n-    sub.subscribe(topic, subid5, options5);\n-    sub.closeSubscription(topic, subid5);\n+  sub.subscribe(topic, subid5, options5);\n+  sub.closeSubscription(topic, subid5);\n \n-    sendXExpectLastY(pub, sub, topic, subid5, 1000, 5);\n+  sendXExpectLastY(pub, sub, topic, subid5, 1000, 5);\n \n-    sub.subscribe(topic, subid20, options20);\n-    sub.closeSubscription(topic, subid20);\n-    sendXExpectLastY(pub, sub, topic, subid20, 1000, 20);\n+  sub.subscribe(topic, subid20, options20);\n+  sub.closeSubscription(topic, subid20);\n+  sendXExpectLastY(pub, sub, topic, subid20, 1000, 20);\n \n-    sub.subscribe(topic, subidUnlimited, optionsUnlimited);\n-    sub.closeSubscription(topic, subidUnlimited);\n+  sub.subscribe(topic, subidUnlimited, optionsUnlimited);\n+  sub.closeSubscription(topic, subidUnlimited);\n \n-    sendXExpectLastY(pub, sub, topic, subidUnlimited, 1000, 1000);\n-    sub.unsubscribe(topic, subidUnlimited);\n+  sendXExpectLastY(pub, sub, topic, subidUnlimited, 1000, 1000);\n+  sub.unsubscribe(topic, subidUnlimited);\n \n-    sendXExpectLastY(pub, sub, topic, subid20, 1000, 20);\n-    sub.unsubscribe(topic, subid20);\n+  sendXExpectLastY(pub, sub, topic, subid20, 1000, 20);\n+  sub.unsubscribe(topic, subid20);\n \n-    sendXExpectLastY(pub, sub, topic, subid5, 1000, 5);\n-    sub.unsubscribe(topic, subid5);\n-  }\n-};\n+  sendXExpectLastY(pub, sub, topic, subid5, 1000, 5);\n+  sub.unsubscribe(topic, subid5);\n+}\n \n-CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( MessageBoundTestSuite, \"MessageBound\" );"},{"sha":"191cd063e67a459dc13bfcc7dd7ab8df256023ee","filename":"hedwig-client/src/main/cpp/test/publishtest.cpp","status":"modified","additions":67,"deletions":101,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/publishtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/publishtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/publishtest.cpp?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -19,9 +19,7 @@\n #include <config.h>\n #endif\n \n-#include <cppunit/Test.h>\n-#include <cppunit/TestSuite.h>\n-#include <cppunit/extensions/HelperMacros.h>\n+#include \"gtest/gtest.h\"\n \n #include \"../lib/clientimpl.h\"\n #include <hedwig/exceptions.h>\n@@ -35,116 +33,87 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n-using namespace CppUnit;\n-\n-class PublishTestSuite : public CppUnit::TestFixture {\n-private:\n-  CPPUNIT_TEST_SUITE( PublishTestSuite );\n-  CPPUNIT_TEST(testSyncPublish);\n-  CPPUNIT_TEST(testAsyncPublish);\n-  CPPUNIT_TEST(testPublishByMessage);\n-  CPPUNIT_TEST(testMultipleAsyncPublish);\n-  //  CPPUNIT_TEST(simplePublish);\n-  //CPPUNIT_TEST(simplePublishAndSubscribe);\n-  //CPPUNIT_TEST(publishAndSubscribeWithRedirect);\n-  CPPUNIT_TEST_SUITE_END();\n-\n-public:\n-  PublishTestSuite() {\n-  }\n-\n-  ~PublishTestSuite() {\n-  }\n-\n-  void setUp()\n-  {\n-  }\n-  \n-  void tearDown() \n-  {\n-  }\n-\n-  void testPublishByMessage() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    Hedwig::Message syncMsg;\n-    syncMsg.set_body(\"sync publish by Message\");\n-    pub.publish(\"testTopic\", syncMsg);\n-\n-    SimpleWaitCondition* cond = new SimpleWaitCondition();\n-    Hedwig::OperationCallbackPtr testcb(new TestCallback(cond));\n-    Hedwig::Message asyncMsg;\n-    asyncMsg.set_body(\"async publish by Message\");\n-    pub.asyncPublish(\"testTopic\", asyncMsg, testcb);\n-    cond->wait();\n-    CPPUNIT_ASSERT(cond->wasSuccess());\n-    delete cond;\n-\n-    delete client;\n-    delete conf;\n-  }\n-\n-  void testSyncPublish() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n+TEST(PublishTest, testPublishByMessage) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  Hedwig::Message syncMsg;\n+  syncMsg.set_body(\"sync publish by Message\");\n+  pub.publish(\"testTopic\", syncMsg);\n+\n+  SimpleWaitCondition* cond = new SimpleWaitCondition();\n+  Hedwig::OperationCallbackPtr testcb(new TestCallback(cond));\n+  Hedwig::Message asyncMsg;\n+  asyncMsg.set_body(\"async publish by Message\");\n+  pub.asyncPublish(\"testTopic\", asyncMsg, testcb);\n+  cond->wait();\n+  ASSERT_TRUE(cond->wasSuccess());\n+  delete cond;\n+\n+  delete client;\n+  delete conf;\n+}\n+\n+TEST(PublishTest, testSyncPublish) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    Hedwig::Publisher& pub = client->getPublisher();\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  Hedwig::Publisher& pub = client->getPublisher();\n     \n-    pub.publish(\"testTopic\", \"testMessage 1\");\n+  pub.publish(\"testTopic\", \"testMessage 1\");\n     \n-    delete client;\n-    delete conf;\n-  }\n+  delete client;\n+  delete conf;\n+}\n \n-  void testAsyncPublish() {\n-    SimpleWaitCondition* cond = new SimpleWaitCondition();\n+TEST(PublishTest, testAsyncPublish) {\n+  SimpleWaitCondition* cond = new SimpleWaitCondition();\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    Hedwig::Publisher& pub = client->getPublisher();\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  Hedwig::Publisher& pub = client->getPublisher();\n     \n-    Hedwig::OperationCallbackPtr testcb(new TestCallback(cond));\n-    pub.asyncPublish(\"testTopic\", \"async test message\", testcb);\n+  Hedwig::OperationCallbackPtr testcb(new TestCallback(cond));\n+  pub.asyncPublish(\"testTopic\", \"async test message\", testcb);\n     \n-    cond->wait();\n+  cond->wait();\n \n-    CPPUNIT_ASSERT(cond->wasSuccess());\n+  ASSERT_TRUE(cond->wasSuccess());\n \n-    delete cond;\n-    delete client;\n-    delete conf;\n-  }\n+  delete cond;\n+  delete client;\n+  delete conf;\n+}\n \n-  void testMultipleAsyncPublish() {\n-    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n-    SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n-    SimpleWaitCondition* cond3 = new SimpleWaitCondition();\n+TEST(PublishTest, testMultipleAsyncPublish) {\n+  SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+  SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+  SimpleWaitCondition* cond3 = new SimpleWaitCondition();\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    Hedwig::Publisher& pub = client->getPublisher();\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  Hedwig::Publisher& pub = client->getPublisher();\n    \n-    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n-    Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n-    Hedwig::OperationCallbackPtr testcb3(new TestCallback(cond3));\n+  Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+  Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n+  Hedwig::OperationCallbackPtr testcb3(new TestCallback(cond3));\n \n-    pub.asyncPublish(\"testTopic\", \"async test message #1\", testcb1);\n-    pub.asyncPublish(\"testTopic\", \"async test message #2\", testcb2);\n-    pub.asyncPublish(\"testTopic\", \"async test message #3\", testcb3);\n+  pub.asyncPublish(\"testTopic\", \"async test message #1\", testcb1);\n+  pub.asyncPublish(\"testTopic\", \"async test message #2\", testcb2);\n+  pub.asyncPublish(\"testTopic\", \"async test message #3\", testcb3);\n     \n-    cond3->wait();\n-    CPPUNIT_ASSERT(cond3->wasSuccess());\n-    cond2->wait();\n-    CPPUNIT_ASSERT(cond2->wasSuccess());\n-    cond1->wait();\n-    CPPUNIT_ASSERT(cond1->wasSuccess());\n+  cond3->wait();\n+  ASSERT_TRUE(cond3->wasSuccess());\n+  cond2->wait();\n+  ASSERT_TRUE(cond2->wasSuccess());\n+  cond1->wait();\n+  ASSERT_TRUE(cond1->wasSuccess());\n     \n-    delete cond3; delete cond2; delete cond1;\n-    delete client;\n-    delete conf;\n-  }\n+  delete cond3; delete cond2; delete cond1;\n+  delete client;\n+  delete conf;\n+}\n   /*  void simplePublish() {\n     LOG4CXX_DEBUG(logger, \">>> simplePublish\");\n     SimpleWaitCondition* cond = new SimpleWaitCondition();\n@@ -267,6 +236,3 @@ class PublishTestSuite : public CppUnit::TestFixture {\n     delete publishconf;\n     delete subscribeconf;\n     }*/\n-};\n-\n-CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( PublishTestSuite, \"Publish\");"},{"sha":"c1cc862a2248d230707e58b8cf830e918f4710a1","filename":"hedwig-client/src/main/cpp/test/pubsubdatatest.cpp","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/0e06ddeb7e47bd8794fd378629602e41ea4a1fd9/hedwig-client/src/main/cpp/test/pubsubdatatest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/0e06ddeb7e47bd8794fd378629602e41ea4a1fd9/hedwig-client/src/main/cpp/test/pubsubdatatest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubdatatest.cpp?ref=0e06ddeb7e47bd8794fd378629602e41ea4a1fd9","patch":"@@ -1,51 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-#ifdef HAVE_CONFIG_H\n-#include <config.h>\n-#endif\n-\n-#include <cppunit/Test.h>\n-#include <cppunit/TestSuite.h>\n-#include <cppunit/extensions/HelperMacros.h>\n-\n-#include \"../lib/clientimpl.h\"\n-#include <hedwig/exceptions.h>\n-#include <stdexcept>\n-\n-using namespace CppUnit;\n-\n-class PubSubDataTestSuite : public CppUnit::TestFixture {\n-  CPPUNIT_TEST_SUITE( PubSubDataTestSuite );\n-  CPPUNIT_TEST(createPubSubData);\n-  CPPUNIT_TEST_SUITE_END();\n-\n-public:\n-  void setUp()\n-  {\n-  }\n-\n-  void tearDown() \n-  {\n-  }\n-\n-  void createPubSubData() {\n-    \n-  }\n-};\n-\n-CPPUNIT_TEST_SUITE_REGISTRATION( PubSubDataTestSuite );"},{"sha":"c1cde3ef4b9aabe41cda4beba82e1a395018dcde","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"modified","additions":486,"deletions":520,"changes":1006,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -21,9 +21,7 @@\n \n #include <sstream>\n \n-#include <cppunit/Test.h>\n-#include <cppunit/TestSuite.h>\n-#include <cppunit/extensions/HelperMacros.h>\n+#include \"gtest/gtest.h\"\n #include <boost/thread/mutex.hpp>\n \n #include \"../lib/clientimpl.h\"\n@@ -38,572 +36,540 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n-class PubSubTestSuite : public CppUnit::TestFixture {\n-private:\n-  CPPUNIT_TEST_SUITE( PubSubTestSuite );\n-  CPPUNIT_TEST(testPubSubOrderChecking);\n-  CPPUNIT_TEST(testRandomDelivery);\n-  CPPUNIT_TEST(testPubSubContinuousOverClose);\n-  //  CPPUNIT_TEST(testPubSubContinuousOverServerDown);\n-  CPPUNIT_TEST(testMultiTopic);\n-  CPPUNIT_TEST(testBigMessage);\n-  CPPUNIT_TEST(testMultiTopicMultiSubscriber);\n-  CPPUNIT_TEST(testPubSubInMultiDispatchThreads);\n-  CPPUNIT_TEST_SUITE_END();\n-\n+class PubSubMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n public:\n-  PubSubTestSuite() {\n-  }\n-\n-  ~PubSubTestSuite() {\n-  }\n-\n-  void setUp()\n-  {\n-  }\n-  \n-  void tearDown() \n-  {\n+  PubSubMessageHandlerCallback(const std::string& topic, const std::string& subscriberId) : messagesReceived(0), topic(topic), subscriberId(subscriberId) {\n   }\n \n-  class MyMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n-  public:\n-    MyMessageHandlerCallback(const std::string& topic, const std::string& subscriberId) : messagesReceived(0), topic(topic), subscriberId(subscriberId) {\n-      \n-    }\n-\n-    virtual void consume(const std::string& topic, const std::string& subscriberId, const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n-      if (topic == this->topic && subscriberId == this->subscriberId) {\n-\tboost::lock_guard<boost::mutex> lock(mutex);\n-      \n-\tmessagesReceived++;\n-\tlastMessage = msg.body();\n-\tcallback->operationComplete();\n-      }\n-    }\n-    \n-    std::string getLastMessage() {\n-      boost::lock_guard<boost::mutex> lock(mutex);\n-      std::string s = lastMessage;\n-      return s;\n-    }\n-\n-    int numMessagesReceived() {\n-      boost::lock_guard<boost::mutex> lock(mutex);\n-      int i = messagesReceived;\n-      return i;\n-    }    \n-    \n-  protected:\n-    boost::mutex mutex;\n-    int messagesReceived;\n-    std::string lastMessage;\n-    std::string topic;\n-    std::string subscriberId;\n-  };\n-\n-  // order checking callback\n-  class MyOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n-  public:\n-    MyOrderCheckingMessageHandlerCallback(const std::string& topic, const std::string& subscriberId, const int startMsgId, const int sleepTimeInConsume)\n-      : messagesReceived(0), topic(topic), subscriberId(subscriberId), startMsgId(startMsgId), \n-        isInOrder(true), sleepTimeInConsume(sleepTimeInConsume) {\n-    }\n-\n-    virtual void consume(const std::string& topic, const std::string& subscriberId,\n-                         const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n-      if (topic == this->topic && subscriberId == this->subscriberId) {\n-        boost::lock_guard<boost::mutex> lock(mutex);\n-            \n-        messagesReceived++;\n-\n-        int newMsgId = atoi(msg.body().c_str());\n-        // checking msgId\n-        LOG4CXX_DEBUG(logger, \"received message \" << newMsgId);\n-        if (startMsgId >= 0) { // need to check ordering if start msg id is larger than 0\n-          if (isInOrder) {\n-            if (newMsgId != startMsgId + 1) {\n-              LOG4CXX_ERROR(logger, \"received out-of-order message : expected \" << (startMsgId + 1) << \", actual \" << newMsgId);\n-              isInOrder = false;\n-            } else {\n-              startMsgId = newMsgId;\n-            }\n-          }\n-        } else { // we set first msg id as startMsgId when startMsgId is -1\n-          startMsgId = newMsgId;\n-        }\n-        callback->operationComplete();\n-        sleep(sleepTimeInConsume);\n-      }\n-    }\n-    \n-    int numMessagesReceived() {\n+  virtual void consume(const std::string& topic, const std::string& subscriberId, const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    if (topic == this->topic && subscriberId == this->subscriberId) {\n       boost::lock_guard<boost::mutex> lock(mutex);\n-      int i = messagesReceived;\n-      return i;\n-    }    \n-\n-    bool inOrder() {\n-      boost::lock_guard<boost::mutex> lock(mutex);\n-      return isInOrder;\n-    }\n-    \n-  protected:\n-    boost::mutex mutex;\n-    int messagesReceived;\n-    std::string topic;\n-    std::string subscriberId;\n-    int startMsgId;\n-    bool isInOrder;\n-    int sleepTimeInConsume;\n-  };\n-\n-  // Publisher integer until finished\n-  class IntegerPublisher {\n-  public:\n-    IntegerPublisher(const std::string &topic, int startMsgId, int numMsgs, int sleepTime, Hedwig::Publisher &pub, long runTime)\n-      : topic(topic), startMsgId(startMsgId), numMsgs(numMsgs), sleepTime(sleepTime), pub(pub), running(true), runTime(runTime) {\n-    }\n-\n-    void operator()() {\n-      int i = 1;\n-      long beginTime = curTime();\n-      long elapsedTime = 0;\n-\n-      while (running) {\n-        try {\n-          int msg = startMsgId + i;\n-          std::stringstream ss;\n-          ss << msg;\n-          pub.publish(topic, ss.str());\n-          sleep(sleepTime);\n-          if (numMsgs > 0 && i >= numMsgs) {\n-            running = false;\n-          } else {\n-            if (i % 100 == 0 &&\n-                (elapsedTime = (curTime() - beginTime)) >= runTime) {\n-              LOG4CXX_DEBUG(logger, \"Elapsed time : \" << elapsedTime);\n-              running = false;\n-            }\n-          }\n-          ++i;\n-        } catch (std::exception &e) {\n-          LOG4CXX_WARN(logger, \"Exception when publishing messages : \" << e.what());\n-        }\n-      } \n-    }\n-\n-    long curTime() {\n-      struct timeval tv;\n-      long mtime;\n-      gettimeofday(&tv, NULL);\n-      mtime = tv.tv_sec * 1000 + tv.tv_usec / 1000.0 + 0.5;\n-      return mtime;\n-    }\n-\n-  private:\n-    std::string topic;\n-    int startMsgId;\n-    int numMsgs;\n-    int sleepTime;\n-    Hedwig::Publisher& pub;\n-    bool running;\n-    long runTime;\n-  };\n-\n-  // test startDelivery / stopDelivery randomly\n-  void testRandomDelivery() {\n-    std::string topic = \"randomDeliveryTopic\";\n-    std::string subscriber = \"mysub-randomDelivery\";\n-\n-    int nLoops = 300;\n-    int sleepTimePerLoop = 1;\n-    int syncTimeout = 10000;\n-\n-    Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout);\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n-\n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    // subscribe topic\n-    sub.subscribe(topic, subscriber, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-\n-    // start thread to publish message\n-    IntegerPublisher intPublisher = IntegerPublisher(topic, 0, 0, 0, pub, nLoops * sleepTimePerLoop * 1000);\n-    boost::thread pubThread(intPublisher);\n-\n-    // start random delivery\n-    MyOrderCheckingMessageHandlerCallback* cb =\n-      new MyOrderCheckingMessageHandlerCallback(topic, subscriber, 0, 0);\n-    Hedwig::MessageHandlerCallbackPtr handler(cb);\n-\n-    for (int i = 0; i < nLoops; i++) {\n-      LOG4CXX_DEBUG(logger, \"Randomly Delivery : \" << i);\n-      sub.startDelivery(topic, subscriber, handler);\n-      // sleep random time\n-      sleep(sleepTimePerLoop);\n-      sub.stopDelivery(topic, subscriber);\n-      CPPUNIT_ASSERT(cb->inOrder());\n+      \n+      messagesReceived++;\n+      lastMessage = msg.body();\n+      callback->operationComplete();\n     }\n-    \n-    pubThread.join();\n   }\n-\n-  // check message ordering\n-  void testPubSubOrderChecking() {\n-    std::string topic = \"orderCheckingTopic\";\n-    std::string sid = \"mysub-0\";\n-\n-    int numMessages = 5;\n-    int sleepTimeInConsume = 1;\n-    // sync timeout\n-    int syncTimeout = 10000;\n-\n-    // in order to guarantee message order, message queue should be locked\n-    // so message received in io thread would be blocked, which also block\n-    // sent operations (publish). because we have only one io thread now\n-    // so increase sync timeout to 10s, which is more than numMessages * sleepTimeInConsume\n-    Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout);\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n-\n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n     \n-    // we don't start delivery first, so the message will be queued\n-    // publish ${numMessages} messages, so the messages will be queued\n-    for (int i=1; i<=numMessages; i++) {\n-      std::stringstream ss;\n-      ss << i;\n-      pub.publish(topic, ss.str()); \n-    }\n-\n-    MyOrderCheckingMessageHandlerCallback* cb = new MyOrderCheckingMessageHandlerCallback(topic, sid, 0, sleepTimeInConsume);\n-    Hedwig::MessageHandlerCallbackPtr handler(cb);\n-\n-    // create a thread to publish another ${numMessages} messages\n-    boost::thread pubThread(IntegerPublisher(topic, numMessages, numMessages, sleepTimeInConsume, pub, 0));\n-\n-    // start delivery will consumed the queued messages\n-    // new message will recevied and the queued message should be consumed\n-    // hedwig should ensure the message are received in order\n-    sub.startDelivery(topic, sid, handler);\n-\n-    // wait until message are all published\n-    pubThread.join();\n-\n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cb->numMessagesReceived() == 2 * numMessages) {\n-        break;\n-      }\n-    }\n-    CPPUNIT_ASSERT(cb->inOrder());\n+  std::string getLastMessage() {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    std::string s = lastMessage;\n+    return s;\n   }\n \n-  // check message ordering\n-  void testPubSubInMultiDispatchThreads() {\n-    std::string topic = \"PubSubInMultiDispatchThreadsTopic-\";\n-    std::string sid = \"mysub-0\";\n-\n-    int syncTimeout = 10000;\n-    int numDispatchThreads = 4;\n-    int numMessages = 100;\n-    int numTopics = 20;\n-\n-    Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout, numDispatchThreads);\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n-\n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    std::vector<Hedwig::MessageHandlerCallbackPtr> callbacks;\n-\n-    for (int i=0; i<numTopics; i++) {\n-      std::stringstream ss;\n-      ss << topic << i;\n-      sub.subscribe(ss.str(), sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-\n-      MyOrderCheckingMessageHandlerCallback* cb = new MyOrderCheckingMessageHandlerCallback(ss.str(), sid, 0, 0);\n-      Hedwig::MessageHandlerCallbackPtr handler(cb);\n-      sub.startDelivery(ss.str(), sid, handler);\n-      callbacks.push_back(handler);\n-    }\n-\n-    std::vector<boost::shared_ptr<boost::thread> > threads;\n-\n-    for (int i=0; i<numTopics; i++) {\n-      std::stringstream ss;\n-      ss << topic << i;\n-      boost::shared_ptr<boost::thread> t = boost::shared_ptr<boost::thread>(\n-        new boost::thread(IntegerPublisher(ss.str(), 0, numMessages, 0, pub, 0)));\n-      threads.push_back(t);\n-    }\n+  int numMessagesReceived() {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    int i = messagesReceived;\n+    return i;\n+  }    \n+    \n+protected:\n+  boost::mutex mutex;\n+  int messagesReceived;\n+  std::string lastMessage;\n+  std::string topic;\n+  std::string subscriberId;\n+};\n \n-    for (int i=0; i<numTopics; i++) {\n-      threads[i]->join();\n-    }\n-    threads.clear();\n-\n-    for (int j=0; j<numTopics; j++) {\n-      MyOrderCheckingMessageHandlerCallback *cb =\n-        (MyOrderCheckingMessageHandlerCallback *)(callbacks[j].get());\n-      for (int i = 0; i < 10; i++) {\n-        if (cb->numMessagesReceived() == numMessages) {\n-          break;\n-        }\n-        sleep(3);\n-      }\n-      CPPUNIT_ASSERT(cb->inOrder());\n-    }\n-    callbacks.clear();\n+// order checking callback\n+class PubSubOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n+public:\n+  PubSubOrderCheckingMessageHandlerCallback(const std::string& topic, const std::string& subscriberId, const int startMsgId, const int sleepTimeInConsume)\n+    : messagesReceived(0), topic(topic), subscriberId(subscriberId), startMsgId(startMsgId), \n+      isInOrder(true), sleepTimeInConsume(sleepTimeInConsume) {\n   }\n \n-\n-  void testPubSubContinuousOverClose() {\n-    std::string topic = \"pubSubTopic\";\n-    std::string sid = \"MySubscriberid-1\";\n-\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n-    \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    MyMessageHandlerCallback* cb = new MyMessageHandlerCallback(topic, sid);\n-    Hedwig::MessageHandlerCallbackPtr handler(cb);\n-\n-    sub.startDelivery(topic, sid, handler);\n-    pub.publish(topic, \"Test Message 1\");\n-    bool pass = false;\n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cb->numMessagesReceived() > 0) {\n-\tif (cb->getLastMessage() == \"Test Message 1\") {\n-\t  pass = true;\n-\t  break;\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+\t\t       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    if (topic == this->topic && subscriberId == this->subscriberId) {\n+      boost::lock_guard<boost::mutex> lock(mutex);\n+            \n+      messagesReceived++;\n+\n+      int newMsgId = atoi(msg.body().c_str());\n+      // checking msgId\n+      LOG4CXX_DEBUG(logger, \"received message \" << newMsgId);\n+      if (startMsgId >= 0) { // need to check ordering if start msg id is larger than 0\n+\tif (isInOrder) {\n+\t  if (newMsgId != startMsgId + 1) {\n+\t    LOG4CXX_ERROR(logger, \"received out-of-order message : expected \" << (startMsgId + 1) << \", actual \" << newMsgId);\n+\t    isInOrder = false;\n+\t  } else {\n+\t    startMsgId = newMsgId;\n+\t  }\n \t}\n+      } else { // we set first msg id as startMsgId when startMsgId is -1\n+\tstartMsgId = newMsgId;\n       }\n+      callback->operationComplete();\n+      sleep(sleepTimeInConsume);\n     }\n-    CPPUNIT_ASSERT(pass);\n-    sub.closeSubscription(topic, sid);\n-\n-    pub.publish(topic, \"Test Message 2\");\n+  }\n     \n-    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.startDelivery(topic, sid, handler);\n-    pass = false;\n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cb->numMessagesReceived() > 0) {\n-\tif (cb->getLastMessage() == \"Test Message 2\") {\n-\t  pass = true;\n-\t  break;\n-\t}\n-      }\n-    }\n-    CPPUNIT_ASSERT(pass);\n+  int numMessagesReceived() {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    int i = messagesReceived;\n+    return i;\n+  }    \n+\n+  bool inOrder() {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    return isInOrder;\n   }\n-\n-\n-  /*  void testPubSubContinuousOverServerDown() {\n-    std::string topic = \"pubSubTopic\";\n-    std::string sid = \"MySubscriberid-1\";\n-\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    MyMessageHandlerCallback* cb = new MyMessageHandlerCallback(topic, sid);\n-    Hedwig::MessageHandlerCallbackPtr handler(cb);\n-\n-    sub.startDelivery(topic, sid, handler);\n-    pub.publish(topic, \"Test Message 1\");\n-    bool pass = false;\n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cb->numMessagesReceived() > 0) {\n-\tif (cb->getLastMessage() == \"Test Message 1\") {\n-\t  pass = true;\n-\t  break;\n-\t}\n-      }\n-    }\n-    CPPUNIT_ASSERT(pass);\n-    sub.closeSubscription(topic, sid);\n+protected:\n+  boost::mutex mutex;\n+  int messagesReceived;\n+  std::string topic;\n+  std::string subscriberId;\n+  int startMsgId;\n+  bool isInOrder;\n+  int sleepTimeInConsume;\n+};\n \n-    pub.publish(topic, \"Test Message 2\");\n-    \n-    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.startDelivery(topic, sid, handler);\n-    pass = false;\n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cb->numMessagesReceived() > 0) {\n-\tif (cb->getLastMessage() == \"Test Message 2\") {\n-\t  pass = true;\n-\t  break;\n+// Publisher integer until finished\n+class IntegerPublisher {\n+public:\n+  IntegerPublisher(const std::string &topic, int startMsgId, int numMsgs, int sleepTime, Hedwig::Publisher &pub, long runTime)\n+    : topic(topic), startMsgId(startMsgId), numMsgs(numMsgs), sleepTime(sleepTime), pub(pub), running(true), runTime(runTime) {\n+  }\n+\n+  void operator()() {\n+    int i = 1;\n+    long beginTime = curTime();\n+    long elapsedTime = 0;\n+\n+    while (running) {\n+      try {\n+\tint msg = startMsgId + i;\n+\tstd::stringstream ss;\n+\tss << msg;\n+\tpub.publish(topic, ss.str());\n+\tsleep(sleepTime);\n+\tif (numMsgs > 0 && i >= numMsgs) {\n+\t  running = false;\n+\t} else {\n+\t  if (i % 100 == 0 &&\n+\t      (elapsedTime = (curTime() - beginTime)) >= runTime) {\n+\t    LOG4CXX_DEBUG(logger, \"Elapsed time : \" << elapsedTime);\n+\t    running = false;\n+\t  }\n \t}\n+\t++i;\n+      } catch (std::exception &e) {\n+\tLOG4CXX_WARN(logger, \"Exception when publishing messages : \" << e.what());\n       }\n-    }\n-    CPPUNIT_ASSERT(pass);\n-    }*/\n-\n-  void testMultiTopic() {\n-    std::string topicA = \"pubSubTopicA\";\n-    std::string topicB = \"pubSubTopicB\";\n-    std::string sid = \"MySubscriberid-3\";\n+    } \n+  }\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n-    \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  long curTime() {\n+    struct timeval tv;\n+    long mtime;\n+    gettimeofday(&tv, NULL);\n+    mtime = tv.tv_sec * 1000 + tv.tv_usec / 1000.0 + 0.5;\n+    return mtime;\n+  }\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n+private:\n+  std::string topic;\n+  int startMsgId;\n+  int numMsgs;\n+  int sleepTime;\n+  Hedwig::Publisher& pub;\n+  bool running;\n+  long runTime;\n+};\n \n-    sub.subscribe(topicA, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.subscribe(topicB, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+// test startDelivery / stopDelivery randomly\n+TEST(PubSubTest, testRandomDelivery) {\n+   std::string topic = \"randomDeliveryTopic\";\n+   std::string subscriber = \"mysub-randomDelivery\";\n+\n+   int nLoops = 300;\n+   int sleepTimePerLoop = 1;\n+   int syncTimeout = 10000;\n+\n+   Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout);\n+   std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+   Hedwig::Client* client = new Hedwig::Client(*conf);\n+   std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+   Hedwig::Subscriber& sub = client->getSubscriber();\n+   Hedwig::Publisher& pub = client->getPublisher();\n+\n+   // subscribe topic\n+   sub.subscribe(topic, subscriber, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+   // start thread to publish message\n+   IntegerPublisher intPublisher = IntegerPublisher(topic, 0, 0, 0, pub, nLoops * sleepTimePerLoop * 1000);\n+   boost::thread pubThread(intPublisher);\n+\n+   // start random delivery\n+   PubSubOrderCheckingMessageHandlerCallback* cb =\n+     new PubSubOrderCheckingMessageHandlerCallback(topic, subscriber, 0, 0);\n+   Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+   for (int i = 0; i < nLoops; i++) {\n+     LOG4CXX_DEBUG(logger, \"Randomly Delivery : \" << i);\n+     sub.startDelivery(topic, subscriber, handler);\n+     // sleep random time\n+     usleep(rand()%1000000);\n+     sub.stopDelivery(topic, subscriber);\n+     ASSERT_TRUE(cb->inOrder());\n+   }\n+\n+   pubThread.join();\n+ }\n+\n+ // check message ordering\n+ TEST(PubSubTest, testPubSubOrderChecking) {\n+   std::string topic = \"orderCheckingTopic\";\n+   std::string sid = \"mysub-0\";\n+\n+   int numMessages = 5;\n+   int sleepTimeInConsume = 1;\n+   // sync timeout\n+   int syncTimeout = 10000;\n+\n+   // in order to guarantee message order, message queue should be locked\n+   // so message received in io thread would be blocked, which also block\n+   // sent operations (publish). because we have only one io thread now\n+   // so increase sync timeout to 10s, which is more than numMessages * sleepTimeInConsume\n+   Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout);\n+   std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+   Hedwig::Client* client = new Hedwig::Client(*conf);\n+   std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+   Hedwig::Subscriber& sub = client->getSubscriber();\n+   Hedwig::Publisher& pub = client->getPublisher();\n+\n+   sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+   // we don't start delivery first, so the message will be queued\n+   // publish ${numMessages} messages, so the messages will be queued\n+   for (int i=1; i<=numMessages; i++) {\n+     std::stringstream ss;\n+     ss << i;\n+     pub.publish(topic, ss.str()); \n+   }\n+\n+   PubSubOrderCheckingMessageHandlerCallback* cb = new PubSubOrderCheckingMessageHandlerCallback(topic, sid, 0, sleepTimeInConsume);\n+   Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+   // create a thread to publish another ${numMessages} messages\n+   boost::thread pubThread(IntegerPublisher(topic, numMessages, numMessages, sleepTimeInConsume, pub, 0));\n+\n+   // start delivery will consumed the queued messages\n+   // new message will recevied and the queued message should be consumed\n+   // hedwig should ensure the message are received in order\n+   sub.startDelivery(topic, sid, handler);\n+\n+   // wait until message are all published\n+   pubThread.join();\n+\n+   for (int i = 0; i < 10; i++) {\n+     sleep(3);\n+     if (cb->numMessagesReceived() == 2 * numMessages) {\n+       break;\n+     }\n+   }\n+   ASSERT_TRUE(cb->inOrder());\n+ }\n+\n+ // check message ordering\n+ TEST(PubSubTest, testPubSubInMultiDispatchThreads) {\n+   std::string topic = \"PubSubInMultiDispatchThreadsTopic-\";\n+   std::string sid = \"mysub-0\";\n+\n+   int syncTimeout = 10000;\n+   int numDispatchThreads = 4;\n+   int numMessages = 100;\n+   int numTopics = 20;\n+\n+   Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout, numDispatchThreads);\n+   std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+   Hedwig::Client* client = new Hedwig::Client(*conf);\n+   std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+   Hedwig::Subscriber& sub = client->getSubscriber();\n+   Hedwig::Publisher& pub = client->getPublisher();\n+\n+   std::vector<Hedwig::MessageHandlerCallbackPtr> callbacks;\n+\n+   for (int i=0; i<numTopics; i++) {\n+     std::stringstream ss;\n+     ss << topic << i;\n+     sub.subscribe(ss.str(), sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+     PubSubOrderCheckingMessageHandlerCallback* cb = new PubSubOrderCheckingMessageHandlerCallback(ss.str(), sid, 0, 0);\n+     Hedwig::MessageHandlerCallbackPtr handler(cb);\n+     sub.startDelivery(ss.str(), sid, handler);\n+     callbacks.push_back(handler);\n+   }\n+\n+   std::vector<boost::shared_ptr<boost::thread> > threads;\n+\n+   for (int i=0; i<numTopics; i++) {\n+     std::stringstream ss;\n+     ss << topic << i;\n+     boost::shared_ptr<boost::thread> t = boost::shared_ptr<boost::thread>(\n+\t\t\t\t\t\t\t\t\t   new boost::thread(IntegerPublisher(ss.str(), 0, numMessages, 0, pub, 0)));\n+     threads.push_back(t);\n+   }\n+\n+   for (int i=0; i<numTopics; i++) {\n+     threads[i]->join();\n+   }\n+   threads.clear();\n+\n+   for (int j=0; j<numTopics; j++) {\n+     PubSubOrderCheckingMessageHandlerCallback *cb =\n+       (PubSubOrderCheckingMessageHandlerCallback *)(callbacks[j].get());\n+     for (int i = 0; i < 10; i++) {\n+       if (cb->numMessagesReceived() == numMessages) {\n+\t break;\n+       }\n+       sleep(3);\n+     }\n+     ASSERT_TRUE(cb->inOrder());\n+   }\n+   callbacks.clear();\n+ }\n+\n+\n+ TEST(PubSubTest, testPubSubContinuousOverClose) {\n+   std::string topic = \"pubSubTopic\";\n+   std::string sid = \"MySubscriberid-1\";\n+\n+   Hedwig::Configuration* conf = new TestServerConfiguration();\n+   std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+   Hedwig::Client* client = new Hedwig::Client(*conf);\n+   std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+   Hedwig::Subscriber& sub = client->getSubscriber();\n+   Hedwig::Publisher& pub = client->getPublisher();\n+\n+   sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+   PubSubMessageHandlerCallback* cb = new PubSubMessageHandlerCallback(topic, sid);\n+   Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+   sub.startDelivery(topic, sid, handler);\n+   pub.publish(topic, \"Test Message 1\");\n+   bool pass = false;\n+   for (int i = 0; i < 10; i++) {\n+     sleep(3);\n+     if (cb->numMessagesReceived() > 0) {\n+       if (cb->getLastMessage() == \"Test Message 1\") {\n+\t pass = true;\n+\t break;\n+       }\n+     }\n+   }\n+   ASSERT_TRUE(pass);\n+   sub.closeSubscription(topic, sid);\n+\n+   pub.publish(topic, \"Test Message 2\");\n+\n+   sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+   sub.startDelivery(topic, sid, handler);\n+   pass = false;\n+   for (int i = 0; i < 10; i++) {\n+     sleep(3);\n+     if (cb->numMessagesReceived() > 0) {\n+       if (cb->getLastMessage() == \"Test Message 2\") {\n+\t pass = true;\n+\t break;\n+       }\n+     }\n+   }\n+   ASSERT_TRUE(pass);\n+ }\n+\n+\n+ /*  void testPubSubContinuousOverServerDown() {\n+     std::string topic = \"pubSubTopic\";\n+     std::string sid = \"MySubscriberid-1\";\n+\n+     Hedwig::Configuration* conf = new TestServerConfiguration();\n+     std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+     Hedwig::Client* client = new Hedwig::Client(*conf);\n+     std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+     Hedwig::Subscriber& sub = client->getSubscriber();\n+     Hedwig::Publisher& pub = client->getPublisher();\n+\n+     sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+     PubSubMessageHandlerCallback* cb = new PubSubMessageHandlerCallback(topic, sid);\n+     Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+     sub.startDelivery(topic, sid, handler);\n+     pub.publish(topic, \"Test Message 1\");\n+     bool pass = false;\n+     for (int i = 0; i < 10; i++) {\n+     sleep(3);\n+     if (cb->numMessagesReceived() > 0) {\n+     if (cb->getLastMessage() == \"Test Message 1\") {\n+     pass = true;\n+     break;\n+     }\n+     }\n+     }\n+     CPPUNIT_ASSERT(pass);\n+     sub.closeSubscription(topic, sid);\n+\n+     pub.publish(topic, \"Test Message 2\");\n+\n+     sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+     sub.startDelivery(topic, sid, handler);\n+     pass = false;\n+     for (int i = 0; i < 10; i++) {\n+     sleep(3);\n+     if (cb->numMessagesReceived() > 0) {\n+     if (cb->getLastMessage() == \"Test Message 2\") {\n+     pass = true;\n+     break;\n+     }\n+     }\n+     }\n+     CPPUNIT_ASSERT(pass);\n+     }*/\n+\n+ TEST(PubSubTest, testMultiTopic) {\n+   std::string topicA = \"pubSubTopicA\";\n+   std::string topicB = \"pubSubTopicB\";\n+   std::string sid = \"MySubscriberid-3\";\n+\n+   Hedwig::Configuration* conf = new TestServerConfiguration();\n+   std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+   Hedwig::Client* client = new Hedwig::Client(*conf);\n+   std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+   Hedwig::Subscriber& sub = client->getSubscriber();\n+   Hedwig::Publisher& pub = client->getPublisher();\n+\n+   sub.subscribe(topicA, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+   sub.subscribe(topicB, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n    \n-    MyMessageHandlerCallback* cbA = new MyMessageHandlerCallback(topicA, sid);\n-    Hedwig::MessageHandlerCallbackPtr handlerA(cbA);\n-    sub.startDelivery(topicA, sid, handlerA);\n+  PubSubMessageHandlerCallback* cbA = new PubSubMessageHandlerCallback(topicA, sid);\n+  Hedwig::MessageHandlerCallbackPtr handlerA(cbA);\n+  sub.startDelivery(topicA, sid, handlerA);\n \n-    MyMessageHandlerCallback* cbB = new MyMessageHandlerCallback(topicB, sid);\n-    Hedwig::MessageHandlerCallbackPtr handlerB(cbB);\n-    sub.startDelivery(topicB, sid, handlerB);\n+  PubSubMessageHandlerCallback* cbB = new PubSubMessageHandlerCallback(topicB, sid);\n+  Hedwig::MessageHandlerCallbackPtr handlerB(cbB);\n+  sub.startDelivery(topicB, sid, handlerB);\n \n-    pub.publish(topicA, \"Test Message A\");\n-    pub.publish(topicB, \"Test Message B\");\n-    int passA = false, passB = false;\n+  pub.publish(topicA, \"Test Message A\");\n+  pub.publish(topicB, \"Test Message B\");\n+  int passA = false, passB = false;\n     \n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cbA->numMessagesReceived() > 0) {\n-\tif (cbA->getLastMessage() == \"Test Message A\") {\n-\t  passA = true;\n-\t}\n-      }\n-      if (cbB->numMessagesReceived() > 0) {\n-\tif (cbB->getLastMessage() == \"Test Message B\") {\n-\t  passB = true;\n-\t}\n+  for (int i = 0; i < 10; i++) {\n+    sleep(3);\n+    if (cbA->numMessagesReceived() > 0) {\n+      if (cbA->getLastMessage() == \"Test Message A\") {\n+\tpassA = true;\n       }\n-      if (passA && passB) {\n-\tbreak;\n+    }\n+    if (cbB->numMessagesReceived() > 0) {\n+      if (cbB->getLastMessage() == \"Test Message B\") {\n+\tpassB = true;\n       }\n     }\n-    CPPUNIT_ASSERT(passA && passB);\n+    if (passA && passB) {\n+      break;\n+    }\n   }\n+  ASSERT_TRUE(passA && passB);\n+}\n \n-  void testMultiTopicMultiSubscriber() {\n-    std::string topicA = \"pubSubTopicA\";\n-    std::string topicB = \"pubSubTopicB\";\n-    std::string sidA = \"MySubscriberid-4\";\n-    std::string sidB = \"MySubscriberid-5\";\n+TEST(PubSubTest, testMultiTopicMultiSubscriber) {\n+  std::string topicA = \"pubSubTopicA\";\n+  std::string topicB = \"pubSubTopicB\";\n+  std::string sidA = \"MySubscriberid-4\";\n+  std::string sidB = \"MySubscriberid-5\";\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n \n-    sub.subscribe(topicA, sidA, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.subscribe(topicB, sidB, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.subscribe(topicA, sidA, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.subscribe(topicB, sidB, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n    \n-    MyMessageHandlerCallback* cbA = new MyMessageHandlerCallback(topicA, sidA);\n-    Hedwig::MessageHandlerCallbackPtr handlerA(cbA);\n-    sub.startDelivery(topicA, sidA, handlerA);\n+  PubSubMessageHandlerCallback* cbA = new PubSubMessageHandlerCallback(topicA, sidA);\n+  Hedwig::MessageHandlerCallbackPtr handlerA(cbA);\n+  sub.startDelivery(topicA, sidA, handlerA);\n \n-    MyMessageHandlerCallback* cbB = new MyMessageHandlerCallback(topicB, sidB);\n-    Hedwig::MessageHandlerCallbackPtr handlerB(cbB);\n-    sub.startDelivery(topicB, sidB, handlerB);\n+  PubSubMessageHandlerCallback* cbB = new PubSubMessageHandlerCallback(topicB, sidB);\n+  Hedwig::MessageHandlerCallbackPtr handlerB(cbB);\n+  sub.startDelivery(topicB, sidB, handlerB);\n \n-    pub.publish(topicA, \"Test Message A\");\n-    pub.publish(topicB, \"Test Message B\");\n-    int passA = false, passB = false;\n+  pub.publish(topicA, \"Test Message A\");\n+  pub.publish(topicB, \"Test Message B\");\n+  int passA = false, passB = false;\n     \n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cbA->numMessagesReceived() > 0) {\n-\tif (cbA->getLastMessage() == \"Test Message A\") {\n-\t  passA = true;\n-\t}\n-      }\n-      if (cbB->numMessagesReceived() > 0) {\n-\tif (cbB->getLastMessage() == \"Test Message B\") {\n-\t  passB = true;\n-\t}\n+  for (int i = 0; i < 10; i++) {\n+    sleep(3);\n+    if (cbA->numMessagesReceived() > 0) {\n+      if (cbA->getLastMessage() == \"Test Message A\") {\n+\tpassA = true;\n       }\n-      if (passA && passB) {\n-\tbreak;\n+    }\n+    if (cbB->numMessagesReceived() > 0) {\n+      if (cbB->getLastMessage() == \"Test Message B\") {\n+\tpassB = true;\n       }\n     }\n-    CPPUNIT_ASSERT(passA && passB);\n+    if (passA && passB) {\n+      break;\n+    }\n   }\n+  ASSERT_TRUE(passA && passB);\n+}\n \n-  static const int BIG_MESSAGE_SIZE = 16436*2; // MTU to lo0 is 16436 by default on linux\n+static const int BIG_MESSAGE_SIZE = 16436*2; // MTU to lo0 is 16436 by default on linux\n \n-  void testBigMessage() {\n-    std::string topic = \"pubSubTopic\";\n-    std::string sid = \"MySubscriberid-6\";\n+TEST(PubSubTest, testBigMessage) {\n+  std::string topic = \"pubSubTopic\";\n+  std::string sid = \"MySubscriberid-6\";\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n-    Hedwig::Publisher& pub = client->getPublisher();\n-\n-    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    MyMessageHandlerCallback* cb = new MyMessageHandlerCallback(topic, sid);\n-    Hedwig::MessageHandlerCallbackPtr handler(cb);\n-\n-    sub.startDelivery(topic, sid, handler);\n-\n-    char buf[BIG_MESSAGE_SIZE];\n-    std::string bigmessage(buf, BIG_MESSAGE_SIZE);\n-    pub.publish(topic, bigmessage);\n-    pub.publish(topic, \"Test Message 1\");\n-    bool pass = false;\n-    for (int i = 0; i < 10; i++) {\n-      sleep(3);\n-      if (cb->numMessagesReceived() > 0) {\n-\tif (cb->getLastMessage() == \"Test Message 1\") {\n-\t  pass = true;\n-\t  break;\n-\t}\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  PubSubMessageHandlerCallback* cb = new PubSubMessageHandlerCallback(topic, sid);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+  sub.startDelivery(topic, sid, handler);\n+\n+  char buf[BIG_MESSAGE_SIZE];\n+  std::string bigmessage(buf, BIG_MESSAGE_SIZE);\n+  pub.publish(topic, bigmessage);\n+  pub.publish(topic, \"Test Message 1\");\n+  bool pass = false;\n+  for (int i = 0; i < 10; i++) {\n+    sleep(3);\n+    if (cb->numMessagesReceived() > 0) {\n+      if (cb->getLastMessage() == \"Test Message 1\") {\n+\tpass = true;\n+\tbreak;\n       }\n     }\n-    CPPUNIT_ASSERT(pass);\n   }\n-};\n-\n-CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( PubSubTestSuite, \"PubSub\" );\n+  ASSERT_TRUE(pass);\n+}"},{"sha":"6883867f655a3335a9c40d9b75660a195c85d156","filename":"hedwig-client/src/main/cpp/test/subscribetest.cpp","status":"modified","additions":92,"deletions":125,"changes":217,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/subscribetest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/subscribetest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/subscribetest.cpp?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -19,9 +19,7 @@\n #include <config.h>\n #endif\n \n-#include <cppunit/Test.h>\n-#include <cppunit/TestSuite.h>\n-#include <cppunit/extensions/HelperMacros.h>\n+#include \"gtest/gtest.h\"\n \n #include \"../lib/clientimpl.h\"\n #include <hedwig/exceptions.h>\n@@ -35,165 +33,134 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n-class SubscribeTestSuite : public CppUnit::TestFixture {\n-private:\n-  CPPUNIT_TEST_SUITE( SubscribeTestSuite );\n-  CPPUNIT_TEST(testSyncSubscribe);\n-  CPPUNIT_TEST(testSyncSubscribeAttach);\n-  CPPUNIT_TEST(testAsyncSubscribe);\n-  CPPUNIT_TEST(testAsyncSubcribeAndUnsubscribe);\n-  CPPUNIT_TEST(testAsyncSubcribeAndSyncUnsubscribe);\n-  CPPUNIT_TEST(testAsyncSubcribeCloseSubscriptionAndThenResubscribe);\n-  CPPUNIT_TEST(testUnsubscribeWithoutSubscribe);\n-  CPPUNIT_TEST(testSubscribeTwice);      \n-  CPPUNIT_TEST_SUITE_END();\n-\n-public:\n-  SubscribeTestSuite() {\n+TEST(SubscribeTest, testSyncSubscribe) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-  }\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-  ~SubscribeTestSuite() {\n-  }\n-\n-  void setUp()\n-  {\n-  }\n-  \n-  void tearDown() \n-  {\n-  }\n-\n-  void testSyncSubscribe() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n-    \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n-\n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n     \n-    sub.subscribe(\"testTopic\", \"mySubscriberId-1\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-  }\n+  sub.subscribe(\"testTopic\", \"mySubscriberId-1\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+}\n \n-  void testSyncSubscribeAttach() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+TEST(SubscribeTest, testSyncSubscribeAttach) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n     \n-    CPPUNIT_ASSERT_THROW(sub.subscribe(\"iAmATopicWhoDoesNotExist\", \"mySubscriberId-2\", Hedwig::SubscribeRequest::ATTACH), Hedwig::ClientException);\n-  }\n+  ASSERT_THROW(sub.subscribe(\"iAmATopicWhoDoesNotExist\", \"mySubscriberId-2\", Hedwig::SubscribeRequest::ATTACH), Hedwig::ClientException);\n+}\n \n-  void testAsyncSubscribe() {\n-    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n-    std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n+TEST(SubscribeTest, testAsyncSubscribe) {\n+  SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n    \n-    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+  Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n \n-    sub.asyncSubscribe(\"testTopic\", \"mySubscriberId-3\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n+  sub.asyncSubscribe(\"testTopic\", \"mySubscriberId-3\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n     \n-    cond1->wait();\n-    CPPUNIT_ASSERT(cond1->wasSuccess());\n-  }\n+  cond1->wait();\n+  ASSERT_TRUE(cond1->wasSuccess());\n+}\n   \n-  void testAsyncSubcribeAndUnsubscribe() {\n-    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n-    std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n-    SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n-    std::auto_ptr<SimpleWaitCondition> cond2ptr(cond2);\n+TEST(SubscribeTest, testAsyncSubcribeAndUnsubscribe) {\n+  SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n+  SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond2ptr(cond2);\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n    \n-    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n-    Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n+  Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+  Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n \n-    sub.asyncSubscribe(\"testTopic\", \"mySubscriberId-4\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n-    cond1->wait();\n-    CPPUNIT_ASSERT(cond1->wasSuccess());\n+  sub.asyncSubscribe(\"testTopic\", \"mySubscriberId-4\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n+  cond1->wait();\n+  ASSERT_TRUE(cond1->wasSuccess());\n     \n-    sub.asyncUnsubscribe(\"testTopic\", \"mySubscriberId-4\", testcb2);\n-    cond2->wait();\n-    CPPUNIT_ASSERT(cond2->wasSuccess());\n-  }\n+  sub.asyncUnsubscribe(\"testTopic\", \"mySubscriberId-4\", testcb2);\n+  cond2->wait();\n+  ASSERT_TRUE(cond2->wasSuccess());\n+}\n \n-  void testAsyncSubcribeAndSyncUnsubscribe() {\n-    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n-    std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n+TEST(SubscribeTest, testAsyncSubcribeAndSyncUnsubscribe) {\n+  SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n \n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n    \n-    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+  Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n     \n-    sub.asyncSubscribe(\"testTopic\", \"mySubscriberId-5\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n-    cond1->wait();\n-    CPPUNIT_ASSERT(cond1->wasSuccess());\n+  sub.asyncSubscribe(\"testTopic\", \"mySubscriberId-5\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n+  cond1->wait();\n+  ASSERT_TRUE(cond1->wasSuccess());\n \n-    sub.unsubscribe(\"testTopic\", \"mySubscriberId-5\");\n-  }\n+  sub.unsubscribe(\"testTopic\", \"mySubscriberId-5\");\n+}\n \n-  void testAsyncSubcribeCloseSubscriptionAndThenResubscribe() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+TEST(SubscribeTest, testAsyncSubcribeCloseSubscriptionAndThenResubscribe) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n    \n-    sub.subscribe(\"testTopic\", \"mySubscriberId-6\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.closeSubscription(\"testTopic\", \"mySubscriberId-6\");\n-    sub.subscribe(\"testTopic\", \"mySubscriberId-6\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    sub.unsubscribe(\"testTopic\", \"mySubscriberId-6\");\n-  }\n-\n-  void testUnsubscribeWithoutSubscribe() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  sub.subscribe(\"testTopic\", \"mySubscriberId-6\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.closeSubscription(\"testTopic\", \"mySubscriberId-6\");\n+  sub.subscribe(\"testTopic\", \"mySubscriberId-6\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.unsubscribe(\"testTopic\", \"mySubscriberId-6\");\n+}\n+\n+TEST(SubscribeTest, testUnsubscribeWithoutSubscribe) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n     \n-    CPPUNIT_ASSERT_THROW(sub.unsubscribe(\"testTopic\", \"mySubscriberId-7\"), Hedwig::NotSubscribedException);\n-  }\n+  ASSERT_THROW(sub.unsubscribe(\"testTopic\", \"mySubscriberId-7\"), Hedwig::NotSubscribedException);\n+}\n \n-  void testSubscribeTwice() {\n-    Hedwig::Configuration* conf = new TestServerConfiguration();\n-    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+TEST(SubscribeTest, testSubscribeTwice) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n     \n-    Hedwig::Client* client = new Hedwig::Client(*conf);\n-    std::auto_ptr<Hedwig::Client> clientptr(client);\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n \n-    Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n     \n-    sub.subscribe(\"testTopic\", \"mySubscriberId-8\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n-    CPPUNIT_ASSERT_THROW(sub.subscribe(\"testTopic\", \"mySubscriberId-8\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH), Hedwig::AlreadySubscribedException);\n-  }\n-};\n+  sub.subscribe(\"testTopic\", \"mySubscriberId-8\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  ASSERT_THROW(sub.subscribe(\"testTopic\", \"mySubscriberId-8\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH), Hedwig::AlreadySubscribedException);\n+}\n \n-CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( SubscribeTestSuite, \"Subscribe\" );"},{"sha":"4372217570c302e47062a55b411e4204ffc48033","filename":"hedwig-client/src/main/cpp/test/util.h","status":"modified","additions":0,"deletions":30,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -23,11 +23,6 @@\n #include <boost/thread/mutex.hpp>\n #include <boost/thread/condition_variable.hpp>\n \n-\n-#include <cppunit/TextTestProgressListener.h>\n-#include <cppunit/TestResult.h>\n-#include <cppunit/Test.h>\n-\n #include <log4cxx/logger.h>\n \n static log4cxx::LoggerPtr utillogger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n@@ -126,28 +121,3 @@ class TestServerConfiguration : public Hedwig::Configuration {\n   const int numThreads;\n };\n \n-\n-class HedwigCppTextTestProgressListener : public CppUnit::TextTestProgressListener \n-{\n- public:\n-  void startTest( CppUnit::Test *test ) {\n-    std::cout << \"\\n****\\n\\nStarting \" << test->getName() << \"\\n\\n****\" << std::endl;\n-    current_test = test->getName();\n-  }\n-  \n-  void addFailure( const CppUnit::TestFailure &failure ) {\n-    std::cout << \"\\n!!!!!\\n\\nFailed\\n\\n!!!!!\" << std::endl;\n-\n-  }\n-\n-  void endTestRun( CppUnit::Test *test, \n-\t\t   CppUnit::TestResult *eventManager ) {\n-  }\n-\n-  std::string& getTestName() {\n-    return current_test;\n-  }\n-\n-private:\n-  std::string current_test;\n-};"},{"sha":"e5b6d75afb37288a9d338bd193b2a1ac1cfb34c5","filename":"hedwig-client/src/main/cpp/test/utiltest.cpp","status":"modified","additions":36,"deletions":56,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/utiltest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/51ca99b871ebf85738c82cb1f86eb7de223a44b2/hedwig-client/src/main/cpp/test/utiltest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/utiltest.cpp?ref=51ca99b871ebf85738c82cb1f86eb7de223a44b2","patch":"@@ -19,76 +19,56 @@\n #include <config.h>\n #endif\n \n-#include <cppunit/Test.h>\n-#include <cppunit/TestSuite.h>\n-#include <cppunit/extensions/HelperMacros.h>\n+#include \"gtest/gtest.h\"\n \n #include \"../lib/util.h\"\n #include <hedwig/exceptions.h>\n #include <stdexcept>\n \n-using namespace CppUnit;\n+TEST(UtilTest, testHostAddress) {\n+  // good address (no ports)\n+  Hedwig::HostAddress a1 = Hedwig::HostAddress::fromString(\"www.yahoo.com\");\n+  ASSERT_TRUE(a1.port() == 4080);\n \n-class UtilTestSuite : public CppUnit::TestFixture {\n-  CPPUNIT_TEST_SUITE( UtilTestSuite );\n-  CPPUNIT_TEST(testHostAddress);\n-  CPPUNIT_TEST_SUITE_END();\n+  // good address with ip (no ports)\n+  Hedwig::HostAddress a2 = Hedwig::HostAddress::fromString(\"127.0.0.1\");\n+  ASSERT_TRUE(a2.port() == 4080);\n+  ASSERT_TRUE(a2.ip() == ((127 << 24) | 1));\n \n-public:\n-  void setUp()\n-  {\n-  }\n+  // good address\n+  Hedwig::HostAddress a3 = Hedwig::HostAddress::fromString(\"www.yahoo.com:80\");\n+  ASSERT_TRUE(a3.port() == 80);\n \n-  void tearDown() \n-  {\n-  }\n+  // good address with ip\n+  Hedwig::HostAddress a4 = Hedwig::HostAddress::fromString(\"127.0.0.1:80\");\n+  ASSERT_TRUE(a4.port() == 80);\n+  ASSERT_TRUE(a4.ip() == ((127 << 24) | 1));\n \n-  void testHostAddress() {\n-    // good address (no ports)\n-    Hedwig::HostAddress a1 = Hedwig::HostAddress::fromString(\"www.yahoo.com\");\n-    CPPUNIT_ASSERT(a1.port() == 4080);\n+  // good address (with ssl)\n+  Hedwig::HostAddress a5 = Hedwig::HostAddress::fromString(\"www.yahoo.com:80:443\");\n+  ASSERT_TRUE(a5.port() == 80);\n \n-    // good address with ip (no ports)\n-    Hedwig::HostAddress a2 = Hedwig::HostAddress::fromString(\"127.0.0.1\");\n-    CPPUNIT_ASSERT(a2.port() == 4080);\n-    CPPUNIT_ASSERT(a2.ip() == ((127 << 24) | 1));\n+  // good address with ip\n+  Hedwig::HostAddress a6 = Hedwig::HostAddress::fromString(\"127.0.0.1:80:443\");\n+  ASSERT_TRUE(a6.port() == 80);\n+  ASSERT_TRUE(a6.ip() == ((127 << 24) | 1));\n \n-    // good address\n-    Hedwig::HostAddress a3 = Hedwig::HostAddress::fromString(\"www.yahoo.com:80\");\n-    CPPUNIT_ASSERT(a3.port() == 80);\n-\n-    // good address with ip\n-    Hedwig::HostAddress a4 = Hedwig::HostAddress::fromString(\"127.0.0.1:80\");\n-    CPPUNIT_ASSERT(a4.port() == 80);\n-    CPPUNIT_ASSERT(a4.ip() == ((127 << 24) | 1));\n-\n-    // good address (with ssl)\n-    Hedwig::HostAddress a5 = Hedwig::HostAddress::fromString(\"www.yahoo.com:80:443\");\n-    CPPUNIT_ASSERT(a5.port() == 80);\n-\n-    // good address with ip\n-    Hedwig::HostAddress a6 = Hedwig::HostAddress::fromString(\"127.0.0.1:80:443\");\n-    CPPUNIT_ASSERT(a6.port() == 80);\n-    CPPUNIT_ASSERT(a6.ip() == ((127 << 24) | 1));\n-\n-    // nothing\n-    CPPUNIT_ASSERT_THROW(Hedwig::HostAddress::fromString(\"\"), Hedwig::HostResolutionException);\n+  // nothing\n+  ASSERT_THROW(Hedwig::HostAddress::fromString(\"\"), Hedwig::HostResolutionException);\n     \n-    // nothing but colons\n-    CPPUNIT_ASSERT_THROW(Hedwig::HostAddress::fromString(\"::::::::::::::::\"), Hedwig::ConfigurationException);\n+  // nothing but colons\n+  ASSERT_THROW(Hedwig::HostAddress::fromString(\"::::::::::::::::\"), Hedwig::ConfigurationException);\n     \n-    // only port number\n-    CPPUNIT_ASSERT_THROW(Hedwig::HostAddress::fromString(\":80\"), Hedwig::HostResolutionException);\n+  // only port number\n+  ASSERT_THROW(Hedwig::HostAddress::fromString(\":80\"), Hedwig::HostResolutionException);\n  \n-    // text after colon (isn't supported)\n-    CPPUNIT_ASSERT_THROW(Hedwig::HostAddress::fromString(\"www.yahoo.com:http\"), Hedwig::ConfigurationException);\n+  // text after colon (isn't supported)\n+  ASSERT_THROW(Hedwig::HostAddress::fromString(\"www.yahoo.com:http\"), Hedwig::ConfigurationException);\n     \n-    // invalid hostname\n-    CPPUNIT_ASSERT_THROW(Hedwig::HostAddress::fromString(\"com.oohay.www:80\"), Hedwig::HostResolutionException);\n+  // invalid hostname\n+  ASSERT_THROW(Hedwig::HostAddress::fromString(\"com.oohay.www:80\"), Hedwig::HostResolutionException);\n     \n-    // null\n-    CPPUNIT_ASSERT_THROW(Hedwig::HostAddress::fromString(NULL), std::logic_error);\n-  }\n-};\n+  // null\n+  ASSERT_THROW(Hedwig::HostAddress::fromString(NULL), std::logic_error);\n+}\n \n-CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( UtilTestSuite, \"Util\" );"}]}

