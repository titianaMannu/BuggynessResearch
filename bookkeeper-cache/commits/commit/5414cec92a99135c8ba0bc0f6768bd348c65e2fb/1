{"sha":"5414cec92a99135c8ba0bc0f6768bd348c65e2fb","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1NDE0Y2VjOTJhOTkxMzVjOGJhMGJjMGY2NzY4YmQzNDhjNjVlMmZi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-12T10:20:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-12T10:20:38Z"},"message":"BOOKKEEPER-205: implement a MetaStore based ledger manager for bookkeeper client. (jiannan via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1420607 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c92156ce5b9ef531f98e1f2dbcc4a6ca8655bc46","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c92156ce5b9ef531f98e1f2dbcc4a6ca8655bc46"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5414cec92a99135c8ba0bc0f6768bd348c65e2fb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5414cec92a99135c8ba0bc0f6768bd348c65e2fb","html_url":"https://github.com/apache/bookkeeper/commit/5414cec92a99135c8ba0bc0f6768bd348c65e2fb","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"7fa41ff318a31f973d1de12afe8db0f9893ac653","url":"https://api.github.com/repos/apache/bookkeeper/commits/7fa41ff318a31f973d1de12afe8db0f9893ac653","html_url":"https://github.com/apache/bookkeeper/commit/7fa41ff318a31f973d1de12afe8db0f9893ac653"}],"stats":{"total":781,"additions":779,"deletions":2},"files":[{"sha":"5d95e3b4460bd10526e74f1119e529254cbb0f51","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -238,6 +238,8 @@ Trunk (unreleased changes)\n \n \tBOOKKEEPER-469: Remove System.out.println from TestLedgerManager (ivank via fpj)\n \n+        BOOKKEEPER-205: implement a MetaStore based ledger manager for bookkeeper client. (jiannan via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"8e1246f695741343795c5a98f8ffe20360e271ff","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -62,6 +62,8 @@ public static BKException create(int code) {\n             return new BKBookieHandleNotAvailableException();\n         case Code.ZKException:\n             return new ZKException();\n+        case Code.MetaStoreException:\n+            return new MetaStoreException();\n         case Code.LedgerRecoveryException:\n             return new BKLedgerRecoveryException();\n         case Code.LedgerClosedException:\n@@ -114,6 +116,7 @@ public static BKException create(int code) {\n         int InterruptedException = -15;\n         int ProtocolVersionException = -16;\n         int MetadataVersionException = -17;\n+        int MetaStoreException = -18;\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n@@ -152,6 +155,8 @@ public static String getMessage(int code) {\n             return \"Bookie handle is not available\";\n         case Code.ZKException:\n             return \"Error while using ZooKeeper\";\n+        case Code.MetaStoreException:\n+            return \"Error while using MetaStore\";\n         case Code.LedgerRecoveryException:\n             return \"Error while recovering ledger\";\n         case Code.LedgerClosedException:\n@@ -265,6 +270,12 @@ public ZKException() {\n         }\n     }\n \n+    public static class MetaStoreException extends BKException {\n+        public MetaStoreException() {\n+            super(Code.MetaStoreException);\n+        }\n+    }\n+\n     public static class BKLedgerRecoveryException extends BKException {\n         public BKLedgerRecoveryException() {\n             super(Code.LedgerRecoveryException);"},{"sha":"5c3a8f9f5faf41055de0be1b636120406a989783","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -53,6 +53,10 @@\n     protected final static String AVAILABLE_NODE = \"available\";\n     protected final static String REREPLICATION_ENTRY_BATCH_SIZE = \"rereplicationEntryBatchSize\";\n \n+    // Metastore settings, only being used when LEDGER_MANAGER_FACTORY_CLASS is MSLedgerManagerFactory\n+    protected final static String METASTORE_IMPL_CLASS = \"metastoreImplClass\";\n+    protected final static String METASTORE_MAX_ENTRIES_PER_SCAN = \"metastoreMaxEntriesPerScan\";\n+\n     protected AbstractConfiguration() {\n         super();\n         // add configuration for system properties\n@@ -191,4 +195,42 @@ public void setRereplicationEntryBatchSize(long rereplicationEntryBatchSize) {\n     public long getRereplicationEntryBatchSize() {\n         return getLong(REREPLICATION_ENTRY_BATCH_SIZE, 10);\n     }\n+\n+    /**\n+     * Get metastore implementation class.\n+     *\n+     * @return metastore implementation class name.\n+     */\n+    public String getMetastoreImplClass() {\n+        return getString(METASTORE_IMPL_CLASS);\n+    }\n+\n+    /**\n+     * Set metastore implementation class.\n+     *\n+     * @param metastoreImplClass\n+     *          Metastore implementation Class name.\n+     */\n+    public void setMetastoreImplClass(String metastoreImplClass) {\n+        setProperty(METASTORE_IMPL_CLASS, metastoreImplClass);\n+    }\n+\n+    /**\n+     * Get max entries per scan in metastore.\n+     *\n+     * @return max entries per scan in metastore.\n+     */\n+    public int getMetastoreMaxEntriesPerScan() {\n+        return getInt(METASTORE_MAX_ENTRIES_PER_SCAN, 50);\n+    }\n+\n+    /**\n+     * Set max entries per scan in metastore.\n+     *\n+     * @param maxEntries\n+     *          Max entries per scan in metastore.\n+     */\n+    public void setMetastoreMaxEntriesPerScan(int maxEntries) {\n+        setProperty(METASTORE_MAX_ENTRIES_PER_SCAN, maxEntries);\n+    }\n }"},{"sha":"59fa4572ca627f8425538f83455a69010109e83e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","status":"added","additions":691,"deletions":0,"changes":691,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -0,0 +1,691 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import static org.apache.bookkeeper.metastore.MetastoreScannableTable.EMPTY_END_KEY;\n+import static org.apache.bookkeeper.metastore.MetastoreTable.ALL_FIELDS;\n+import static org.apache.bookkeeper.metastore.MetastoreTable.NON_FIELDS;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.metastore.MSException;\n+import org.apache.bookkeeper.metastore.MetaStore;\n+import org.apache.bookkeeper.metastore.MetastoreCallback;\n+import org.apache.bookkeeper.metastore.MetastoreCursor;\n+import org.apache.bookkeeper.metastore.MetastoreCursor.ReadEntriesCallback;\n+import org.apache.bookkeeper.metastore.MetastoreException;\n+import org.apache.bookkeeper.metastore.MetastoreFactory;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n+import org.apache.bookkeeper.metastore.MetastoreTableItem;\n+import org.apache.bookkeeper.metastore.Value;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.replication.ReplicationException;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * MetaStore Based Ledger Manager Factory\n+ */\n+public class MSLedgerManagerFactory extends LedgerManagerFactory {\n+\n+    static Logger LOG = LoggerFactory.getLogger(MSLedgerManagerFactory.class);\n+\n+    public static final int CUR_VERSION = 1;\n+\n+    public static final String TABLE_NAME = \"LEDGER\";\n+    public static final String META_FIELD = \".META\";\n+\n+    AbstractConfiguration conf;\n+    ZooKeeper zk;\n+    MetaStore metastore;\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public LedgerManagerFactory initialize(final AbstractConfiguration conf, final ZooKeeper zk,\n+            final int factoryVersion) throws IOException {\n+        if (CUR_VERSION != factoryVersion) {\n+            throw new IOException(\"Incompatible layout version found : \" + factoryVersion);\n+        }\n+        this.conf = conf;\n+        this.zk = zk;\n+\n+        // load metadata store\n+        String msName = conf.getMetastoreImplClass();\n+        try {\n+            metastore = MetastoreFactory.createMetaStore(msName);\n+\n+            // TODO: should record version in somewhere. e.g. ZooKeeper\n+            int msVersion = metastore.getVersion();\n+            metastore.init(conf, msVersion);\n+        } catch (Throwable t) {\n+            throw new IOException(\"Failed to initialize metastore \" + msName + \" : \", t);\n+        }\n+\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitialize() throws IOException {\n+        metastore.close();\n+    }\n+\n+    static Long key2LedgerId(String key) {\n+        return null == key ? null : Long.parseLong(key, 10);\n+    }\n+\n+    static String ledgerId2Key(Long lid) {\n+        return null == lid ? null : StringUtils.getZKStringId(lid);\n+    }\n+\n+    static String rangeToString(Long firstLedger, boolean firstInclusive, Long lastLedger, boolean lastInclusive) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(firstInclusive ? \"[ \" : \"( \").append(firstLedger).append(\" ~ \").append(lastLedger)\n+                .append(lastInclusive ? \" ]\" : \" )\");\n+        return sb.toString();\n+    }\n+\n+    static SortedSet<Long> entries2Ledgers(Iterator<MetastoreTableItem> entries) {\n+        SortedSet<Long> ledgers = new TreeSet<Long>();\n+        while (entries.hasNext()) {\n+            MetastoreTableItem item = entries.next();\n+            try {\n+                ledgers.add(key2LedgerId(item.getKey()));\n+            } catch (NumberFormatException nfe) {\n+                LOG.warn(\"Found invalid ledger key {}\", item.getKey());\n+            }\n+        }\n+        return ledgers;\n+    }\n+\n+    static class SyncResult<T> {\n+        T value;\n+        int rc;\n+        boolean finished = false;\n+\n+        public synchronized void complete(int rc, T value) {\n+            this.rc = rc;\n+            this.value = value;\n+            finished = true;\n+\n+            notify();\n+        }\n+\n+        public synchronized void block() {\n+            try {\n+                while (!finished) {\n+                    wait();\n+                }\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+\n+        public synchronized int getRetCode() {\n+            return rc;\n+        }\n+\n+        public synchronized T getResult() {\n+            return value;\n+        }\n+    }\n+\n+    static abstract class AbstractMsLedgerManager implements Closeable {\n+\n+        final ZooKeeper zk;\n+        final AbstractConfiguration conf;\n+\n+        final MetaStore metastore;\n+        final MetastoreScannableTable ledgerTable;\n+        final int maxEntriesPerScan;\n+\n+        AbstractMsLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n+            this.conf = conf;\n+            this.zk = zk;\n+            this.metastore = metastore;\n+\n+            try {\n+                ledgerTable = metastore.createScannableTable(TABLE_NAME);\n+            } catch (MetastoreException mse) {\n+                LOG.error(\"Failed to instantiate table \" + TABLE_NAME + \" in metastore \" + metastore.getName());\n+                throw new RuntimeException(\"Failed to instantiate table \" + TABLE_NAME + \" in metastore \"\n+                        + metastore.getName());\n+            }\n+            // configuration settings\n+            maxEntriesPerScan = conf.getMetastoreMaxEntriesPerScan();\n+        }\n+\n+        @Override\n+        public void close() {\n+            ledgerTable.close();\n+        }\n+\n+    }\n+\n+    static class MsLedgerManager extends AbstractMsLedgerManager implements LedgerManager {\n+\n+        static final String IDGEN_ZNODE = \"ms-idgen\";\n+        static final String IDGENERATION_PREFIX = \"/\" + IDGEN_ZNODE + \"/ID-\";\n+\n+        // Path to generate global id\n+        private final String idGenPath;\n+\n+        // we use this to prevent long stack chains from building up in\n+        // callbacks\n+        ScheduledExecutorService scheduler;\n+\n+        MsLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n+            super(conf, zk, metastore);\n+            this.idGenPath = conf.getZkLedgersRootPath() + IDGENERATION_PREFIX;\n+            this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+        }\n+\n+        @Override\n+        public void close() {\n+            try {\n+                scheduler.shutdown();\n+            } catch (Exception e) {\n+                LOG.warn(\"Error when closing MsLedgerManager : \", e);\n+            }\n+            super.close();\n+        }\n+\n+        @Override\n+        public void createLedger(final LedgerMetadata metadata, final GenericCallback<Long> ledgerCb) {\n+            ZkUtils.createFullPathOptimistic(zk, idGenPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                    CreateMode.EPHEMERAL_SEQUENTIAL, new StringCallback() {\n+                        @Override\n+                        public void processResult(int rc, String path, Object ctx, final String idPathName) {\n+                            if (rc != KeeperException.Code.OK.intValue()) {\n+                                LOG.error(\"Could not generate new ledger id\",\n+                                        KeeperException.create(KeeperException.Code.get(rc), path));\n+                                ledgerCb.operationComplete(BKException.Code.ZKException, null);\n+                                return;\n+                            }\n+                            /*\n+                             * Extract ledger id from gen path\n+                             */\n+                            long ledgerId;\n+                            try {\n+                                ledgerId = getLedgerIdFromGenPath(idPathName);\n+                            } catch (IOException e) {\n+                                LOG.error(\"Could not extract ledger-id from id gen path:\" + path, e);\n+                                ledgerCb.operationComplete(BKException.Code.ZKException, null);\n+                                return;\n+                            }\n+\n+                            final long lid = ledgerId;\n+                            MetastoreCallback<Version> msCallback = new MetastoreCallback<Version>() {\n+                                @Override\n+                                public void complete(int rc, Version version, Object ctx) {\n+                                    if (MSException.Code.BadVersion.getCode() == rc) {\n+                                        ledgerCb.operationComplete(BKException.Code.MetadataVersionException, null);\n+                                        return;\n+                                    }\n+                                    if (MSException.Code.OK.getCode() != rc) {\n+                                        ledgerCb.operationComplete(BKException.Code.MetaStoreException, null);\n+                                        return;\n+                                    }\n+                                    LOG.debug(\"Create ledger {} with version {} successfuly.\", new Object[] { lid,\n+                                            version });\n+                                    // update version\n+                                    metadata.setVersion(version);\n+                                    ledgerCb.operationComplete(BKException.Code.OK, lid);\n+                                }\n+                            };\n+\n+                            ledgerTable.put(ledgerId2Key(lid), new Value().setField(META_FIELD, metadata.serialize()),\n+                                    Version.NEW, msCallback, null);\n+                            zk.delete(idPathName, -1, new AsyncCallback.VoidCallback() {\n+                                @Override\n+                                public void processResult(int rc, String path, Object ctx) {\n+                                    if (rc != KeeperException.Code.OK.intValue()) {\n+                                        LOG.warn(\"Exception during deleting znode for id generation : \",\n+                                                KeeperException.create(KeeperException.Code.get(rc), path));\n+                                    } else {\n+                                        LOG.debug(\"Deleting znode for id generation : {}\", idPathName);\n+                                    }\n+                                }\n+                            }, null);\n+                        }\n+                    }, null);\n+        }\n+\n+        // get ledger id from generation path\n+        private long getLedgerIdFromGenPath(String nodeName) throws IOException {\n+            long ledgerId;\n+            try {\n+                String parts[] = nodeName.split(IDGENERATION_PREFIX);\n+                ledgerId = Long.parseLong(parts[parts.length - 1]);\n+            } catch (NumberFormatException e) {\n+                throw new IOException(e);\n+            }\n+            return ledgerId;\n+        }\n+\n+        @Override\n+        public void deleteLedger(final long ledgerId, final GenericCallback<Void> cb) {\n+            MetastoreCallback<Void> msCallback = new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    int bkRc;\n+                    if (MSException.Code.NoKey.getCode() == rc) {\n+                        LOG.warn(\"Ledger entry does not exist in meta table: ledgerId={}\", ledgerId);\n+                        bkRc = BKException.Code.NoSuchLedgerExistsException;\n+                    } else if (MSException.Code.OK.getCode() == rc) {\n+                        bkRc = BKException.Code.OK;\n+                    } else {\n+                        bkRc = BKException.Code.MetaStoreException;\n+                    }\n+                    cb.operationComplete(bkRc, (Void) null);\n+                }\n+            };\n+            ledgerTable.remove(ledgerId2Key(ledgerId), Version.ANY, msCallback, null);\n+        }\n+\n+        @Override\n+        public void readLedgerMetadata(final long ledgerId, final GenericCallback<LedgerMetadata> readCb) {\n+            final String key = ledgerId2Key(ledgerId);\n+            MetastoreCallback<Versioned<Value>> msCallback = new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (MSException.Code.NoKey.getCode() == rc) {\n+                        LOG.error(\"No ledger metadata found for ledger \" + ledgerId + \" : \",\n+                                MSException.create(MSException.Code.get(rc), \"No key \" + key + \" found.\"));\n+                        readCb.operationComplete(BKException.Code.NoSuchLedgerExistsException, null);\n+                        return;\n+                    }\n+                    if (MSException.Code.OK.getCode() != rc) {\n+                        LOG.error(\"Could not read metadata for ledger \" + ledgerId + \" : \",\n+                                MSException.create(MSException.Code.get(rc), \"Failed to get key \" + key));\n+                        readCb.operationComplete(BKException.Code.MetaStoreException, null);\n+                        return;\n+                    }\n+                    LedgerMetadata metadata;\n+                    try {\n+                        metadata = LedgerMetadata\n+                                .parseConfig(value.getValue().getField(META_FIELD), value.getVersion());\n+                    } catch (IOException e) {\n+                        LOG.error(\"Could not parse ledger metadata for ledger \" + ledgerId + \" : \", e);\n+                        readCb.operationComplete(BKException.Code.MetaStoreException, null);\n+                        return;\n+                    }\n+                    readCb.operationComplete(BKException.Code.OK, metadata);\n+                }\n+            };\n+            ledgerTable.get(key, msCallback, ALL_FIELDS);\n+        }\n+\n+        @Override\n+        public void writeLedgerMetadata(final long ledgerId, final LedgerMetadata metadata,\n+                final GenericCallback<Void> cb) {\n+            Value data = new Value().setField(META_FIELD, metadata.serialize());\n+\n+            LOG.debug(\"Writing ledger {} metadata, version {}\", new Object[] { ledgerId, metadata.getVersion() });\n+\n+            final String key = ledgerId2Key(ledgerId);\n+            MetastoreCallback<Version> msCallback = new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version version, Object ctx) {\n+                    int bkRc;\n+                    if (MSException.Code.BadVersion.getCode() == rc) {\n+                        LOG.info(\"Bad version provided to updat metadata for ledger {}\", ledgerId);\n+                        bkRc = BKException.Code.MetadataVersionException;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        LOG.warn(\"Ledger {} doesn't exist when writing its ledger metadata.\", ledgerId);\n+                        bkRc = BKException.Code.NoSuchLedgerExistsException;\n+                    } else if (MSException.Code.OK.getCode() == rc) {\n+                        metadata.setVersion(version);\n+                        bkRc = BKException.Code.OK;\n+                    } else {\n+                        LOG.warn(\"Conditional update ledger metadata failed: \",\n+                                MSException.create(MSException.Code.get(rc), \"Failed to put key \" + key));\n+                        bkRc = BKException.Code.MetaStoreException;\n+                    }\n+\n+                    cb.operationComplete(bkRc, null);\n+                }\n+            };\n+            ledgerTable.put(key, data, metadata.getVersion(), msCallback, null);\n+        }\n+\n+        @Override\n+        public void asyncProcessLedgers(final Processor<Long> processor, final AsyncCallback.VoidCallback finalCb,\n+                final Object context, final int successRc, final int failureRc) {\n+            MetastoreCallback<MetastoreCursor> openCursorCb = new MetastoreCallback<MetastoreCursor>() {\n+                @Override\n+                public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n+                    if (MSException.Code.OK.getCode() != rc) {\n+                        finalCb.processResult(failureRc, null, context);\n+                        return;\n+                    }\n+                    if (!cursor.hasMoreEntries()) {\n+                        finalCb.processResult(successRc, null, context);\n+                        return;\n+                    }\n+                    asyncProcessLedgers(cursor, processor, finalCb, context, successRc, failureRc);\n+                }\n+            };\n+            ledgerTable.openCursor(NON_FIELDS, openCursorCb, null);\n+        }\n+\n+        void asyncProcessLedgers(final MetastoreCursor cursor, final Processor<Long> processor,\n+                                 final AsyncCallback.VoidCallback finalCb, final Object context,\n+                                 final int successRc, final int failureRc) {\n+            scheduler.submit(new Runnable() {\n+                @Override\n+                public void run() {\n+                    doAsyncProcessLedgers(cursor, processor, finalCb, context, successRc, failureRc);\n+                }\n+            });\n+        }\n+\n+        void doAsyncProcessLedgers(final MetastoreCursor cursor, final Processor<Long> processor,\n+                                   final AsyncCallback.VoidCallback finalCb, final Object context,\n+                                   final int successRc, final int failureRc) {\n+            // no entries now\n+            if (!cursor.hasMoreEntries()) {\n+                finalCb.processResult(successRc, null, context);\n+                return;\n+            }\n+            ReadEntriesCallback msCallback = new ReadEntriesCallback() {\n+                @Override\n+                public void complete(int rc, Iterator<MetastoreTableItem> entries, Object ctx) {\n+                    if (MSException.Code.OK.getCode() != rc) {\n+                        finalCb.processResult(failureRc, null, context);\n+                        return;\n+                    }\n+\n+                    SortedSet<Long> ledgers = new TreeSet<Long>();\n+                    while (entries.hasNext()) {\n+                        MetastoreTableItem item = entries.next();\n+                        try {\n+                            ledgers.add(key2LedgerId(item.getKey()));\n+                        } catch (NumberFormatException nfe) {\n+                            LOG.warn(\"Found invalid ledger key {}\", item.getKey());\n+                        }\n+                    }\n+\n+                    if (0 == ledgers.size()) {\n+                        // process next batch of ledgers\n+                        asyncProcessLedgers(cursor, processor, finalCb, context, successRc, failureRc);\n+                        return;\n+                    }\n+\n+                    final long startLedger = ledgers.first();\n+                    final long endLedger = ledgers.last();\n+\n+                    AsyncSetProcessor<Long> setProcessor = new AsyncSetProcessor<Long>(scheduler);\n+                    // process set\n+                    setProcessor.process(ledgers, processor, new AsyncCallback.VoidCallback() {\n+                        @Override\n+                        public void processResult(int rc, String path, Object ctx) {\n+                            if (successRc != rc) {\n+                                LOG.error(\"Failed when processing range \"\n+                                        + rangeToString(startLedger, true, endLedger, true));\n+                                finalCb.processResult(failureRc, null, context);\n+                                return;\n+                            }\n+                            // process next batch of ledgers\n+                            asyncProcessLedgers(cursor, processor, finalCb, context, successRc, failureRc);\n+                        }\n+                    }, context, successRc, failureRc);\n+                }\n+            };\n+            cursor.asyncReadEntries(maxEntriesPerScan, msCallback, null);\n+        }\n+    }\n+\n+    static class MsActiveLedgerManager extends AbstractMsLedgerManager implements ActiveLedgerManager {\n+\n+        // A sorted map to stored all active ledger ids\n+        protected final SnapshotMap<Long, Boolean> activeLedgers;\n+\n+        MsActiveLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n+            super(conf, zk, metastore);\n+            activeLedgers = new SnapshotMap<Long, Boolean>();\n+        }\n+\n+        @Override\n+        public void addActiveLedger(long ledgerId, boolean active) {\n+            activeLedgers.put(ledgerId, active);\n+        }\n+\n+        @Override\n+        public void removeActiveLedger(long ledgerId) {\n+            activeLedgers.remove(ledgerId);\n+        }\n+\n+        @Override\n+        public boolean containsActiveLedger(long ledgerId) {\n+            return activeLedgers.containsKey(ledgerId);\n+        }\n+\n+        @Override\n+        public void garbageCollectLedgers(GarbageCollector gc) {\n+            LOG.debug(\"Start garbage collect ledgers.\");\n+            NavigableMap<Long, Boolean> snapshot = activeLedgers.snapshot();\n+            Long nextLedger = 0L;\n+            int numRetries = 3;\n+            do {\n+                nextLedger = doGcLedgers(nextLedger, snapshot, gc);\n+            } while (null != nextLedger && --numRetries > 0);\n+            LOG.debug(\"End garbage collect ledgers.\");\n+        }\n+\n+        /**\n+         * Do garbage collection starting from <code>startLedger</code>.\n+         *\n+         * @param startLedgerId\n+         *            Start Ledger id\n+         * @param snapshot\n+         *            Current snapshot of active ledgers\n+         * @param gc\n+         *            Garbage collector\n+         * @return null if finished scanning all ledgers, the next ledger id to\n+         *         scan\n+         */\n+        private Long doGcLedgers(Long startLedgerId, NavigableMap<Long, Boolean> snapshot, GarbageCollector gc) {\n+            final SyncResult<MetastoreCursor> result = new SyncResult<MetastoreCursor>();\n+            MetastoreCallback<MetastoreCursor> openCursorCb = new MetastoreCallback<MetastoreCursor>() {\n+                @Override\n+                public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n+                    result.complete(rc, cursor);\n+                }\n+            };\n+            ledgerTable.openCursor(ledgerId2Key(startLedgerId), true, EMPTY_END_KEY, true, Order.ASC, NON_FIELDS,\n+                    openCursorCb, null);\n+            result.block();\n+            if (MSException.Code.OK.getCode() != result.getRetCode()) {\n+                LOG.warn(\"Failed to open metastore cursor to run garbage collection : \",\n+                        MSException.create(MSException.Code.get(result.getRetCode())));\n+                // failed to open a cursor, not continue until next gc\n+                return null;\n+            }\n+\n+            MetastoreCursor cursor = result.getResult();\n+\n+            while (cursor.hasMoreEntries()) {\n+                Iterator<MetastoreTableItem> entries;\n+                try {\n+                    entries = cursor.readEntries(maxEntriesPerScan);\n+                } catch (MSException mse) {\n+                    LOG.warn(\"Exception when garbage collecting deleted ledgers : \", mse);\n+                    return startLedgerId;\n+                }\n+\n+                if (!entries.hasNext()) {\n+                    continue;\n+                }\n+\n+                SortedSet<Long> msActiveLedgers = entries2Ledgers(entries);\n+\n+                Long endLedgerId = msActiveLedgers.last();\n+                Map<Long, Boolean> bkActiveLedgers = snapshot.subMap(startLedgerId, true, endLedgerId, true);\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"All active ledgers from Metastore between {} and {} : {}\", new Object[] { startLedgerId,\n+                            endLedgerId, msActiveLedgers });\n+                    LOG.debug(\"Current active ledgers from Bookie between {} and {} : {}\", new Object[] {\n+                            startLedgerId, endLedgerId, bkActiveLedgers });\n+                }\n+                doGc(gc, bkActiveLedgers, msActiveLedgers);\n+                // move the pointer\n+                startLedgerId = endLedgerId + 1;\n+            }\n+            doGc(gc, snapshot.tailMap(startLedgerId), new TreeSet<Long>());\n+            return null;\n+        }\n+\n+        /**\n+         * Do garbage collecting comparing hosted ledgers and metastore ledgers\n+         *\n+         * @param gc\n+         *            Garbage collector to do garbage collection when found\n+         *            inactive/deleted ledgers\n+         * @param bkActiveLedgers\n+         *            Active ledgers hosted in bookie server\n+         * @param msAllLedgers\n+         *            All ledgers stored in metastore\n+         */\n+        void doGc(GarbageCollector gc, Map<Long, Boolean> bkActiveLedgers, Set<Long> msAllLedgers) {\n+            // remove any active ledgers that doesn't exist in zk\n+            for (Long bkLid : bkActiveLedgers.keySet()) {\n+                if (!msAllLedgers.contains(bkLid)) {\n+                    // remove it from current active ledger\n+                    LOG.debug(\"gc ledger: {}\", bkLid);\n+                    bkActiveLedgers.remove(bkLid);\n+                    gc.gc(bkLid);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public LedgerManager newLedgerManager() {\n+        return new MsLedgerManager(conf, zk, metastore);\n+    }\n+\n+    @Override\n+    public ActiveLedgerManager newActiveLedgerManager() {\n+        return new MsActiveLedgerManager(conf, zk, metastore);\n+    }\n+\n+    @Override\n+    public LedgerUnderreplicationManager newLedgerUnderreplicationManager() throws KeeperException,\n+            InterruptedException, ReplicationException.CompatibilityException {\n+        // TODO: currently just use zk ledger underreplication manager\n+        return new ZkLedgerUnderreplicationManager(conf, zk);\n+    }\n+\n+    /**\n+     * Process set one by one in asynchronize way. Process will be stopped\n+     * immediately when error occurred.\n+     */\n+    private static class AsyncSetProcessor<T> {\n+        // use this to prevent long stack chains from building up in callbacks\n+        ScheduledExecutorService scheduler;\n+\n+        /**\n+         * Constructor\n+         *\n+         * @param scheduler\n+         *            Executor used to prevent long stack chains\n+         */\n+        public AsyncSetProcessor(ScheduledExecutorService scheduler) {\n+            this.scheduler = scheduler;\n+        }\n+\n+        /**\n+         * Process set of items\n+         *\n+         * @param data\n+         *            Set of data to process\n+         * @param processor\n+         *            Callback to process element of list when success\n+         * @param finalCb\n+         *            Final callback to be called after all elements in the list\n+         *            are processed\n+         * @param contxt\n+         *            Context of final callback\n+         * @param successRc\n+         *            RC passed to final callback on success\n+         * @param failureRc\n+         *            RC passed to final callback on failure\n+         */\n+        public void process(final Set<T> data, final Processor<T> processor, final AsyncCallback.VoidCallback finalCb,\n+                final Object context, final int successRc, final int failureRc) {\n+            if (data == null || data.size() == 0) {\n+                finalCb.processResult(successRc, null, context);\n+                return;\n+            }\n+            final Iterator<T> iter = data.iterator();\n+            AsyncCallback.VoidCallback stubCallback = new AsyncCallback.VoidCallback() {\n+                @Override\n+                public void processResult(int rc, String path, Object ctx) {\n+                    if (rc != successRc) {\n+                        // terminal immediately\n+                        finalCb.processResult(failureRc, null, context);\n+                        return;\n+                    }\n+                    if (!iter.hasNext()) { // reach the end of list\n+                        finalCb.processResult(successRc, null, context);\n+                        return;\n+                    }\n+                    // process next element\n+                    final T dataToProcess = iter.next();\n+                    final AsyncCallback.VoidCallback stub = this;\n+                    scheduler.submit(new Runnable() {\n+                        @Override\n+                        public final void run() {\n+                            processor.process(dataToProcess, stub);\n+                        }\n+                    });\n+                }\n+            };\n+            T firstElement = iter.next();\n+            processor.process(firstElement, stubCallback);\n+        }\n+    }\n+\n+}"},{"sha":"07d2a137596339842dfdf0bfd037b57df20c918f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -40,6 +40,7 @@\n import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.MSLedgerManagerFactory;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n@@ -794,6 +795,7 @@ public void recoverWithoutPasswordInConf() throws Exception {\n         adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n         adminConf.setBookieRecoveryDigestType(digestCorrect);\n         adminConf.setBookieRecoveryPasswd(passwdBad);\n+        setMetastoreImplClass(adminConf);\n \n         BookKeeperAdmin bka = new BookKeeperAdmin(adminConf);\n         bka.recoverBookieData(bookieSrc, null);\n@@ -816,6 +818,7 @@ public void recoverWithoutPasswordInConf() throws Exception {\n         // Try to recover with no password in conf\n         adminConf = new ClientConfiguration();\n         adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        setMetastoreImplClass(adminConf);\n \n         bka = new BookKeeperAdmin(adminConf);\n         bka.recoverBookieData(bookieSrc, null);\n@@ -832,6 +835,13 @@ public void recoverWithoutPasswordInConf() throws Exception {\n      */\n     @Test\n     public void ensurePasswordUsedForOldLedgers() throws Exception {\n+        // This test bases on creating old ledgers in version 4.1.0, which only\n+        // supports ZooKeeper based flat and hierarchical LedgerManagerFactory.\n+        // So we ignore it for MSLedgerManagerFactory.\n+        if (MSLedgerManagerFactory.class.getName().equals(ledgerManagerFactory)) {\n+            return;\n+        }\n+\n         // stop all bookies\n         // and wipe the ledger layout so we can use an old client\n         zkUtil.getZooKeeperClient().delete(\"/ledgers/LAYOUT\", -1);"},{"sha":"1652771d0e31a59c82677bd7b06d4e5e33a6bf40","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -221,7 +221,7 @@ void checkExpectedValue(Versioned<Value> vv, String expectedName,\n     }\n \n     protected Integer getRandom() {\n-        return (int)Math.random()*65536;\n+        return (int)(Math.random()*65536);\n     }\n \n     protected Versioned<Value> getRecord(String recordId) throws Exception {"},{"sha":"b9dc9457e0f7496891e57c958655e3e1c95284f0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","status":"modified","additions":9,"deletions":1,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -32,6 +32,7 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.MSLedgerManagerFactory;\n import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n import org.apache.commons.io.FileUtils;\n@@ -132,6 +133,13 @@ public void testSimpleBookieLedgerMapping() throws Exception {\n      */\n     @Test\n     public void testWithoutZookeeper() throws Exception {\n+        // This test case is for ledger metadata that stored in ZooKeeper. As\n+        // far as MSLedgerManagerFactory, ledger metadata are stored in other\n+        // storage. So this test is not suitable for MSLedgerManagerFactory.\n+        if (newLedgerManagerFactory instanceof MSLedgerManagerFactory) {\n+            return;\n+        }\n+\n         for (int i = 0; i < numberOfLedgers; i++) {\n             createAndAddEntriesToLedger().close();\n         }\n@@ -141,7 +149,7 @@ public void testWithoutZookeeper() throws Exception {\n         stopZKCluster();\n         try {\n             bookieLedgerIndex.getBookieToLedgerIndex();\n-            fail(\"Must throw exception as bookies are not running!\");\n+            fail(\"Must throw exception as zookeeper are not running!\");\n         } catch (BKAuditException bkAuditException) {\n             // expected behaviour\n         }"},{"sha":"6a1f715da672bb9246e8852c231f21675815b3a6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -30,8 +30,10 @@\n import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.client.BookKeeperTestClient;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.metastore.InMemoryMetaStore;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.commons.io.FileUtils;\n@@ -74,6 +76,10 @@ public BookKeeperClusterTestCase(int numBookies) {\n     @Override\n     public void setUp() throws Exception {\n         LOG.info(\"Setting up test {}\", getName());\n+        InMemoryMetaStore.reset();\n+        setMetastoreImplClass(baseConf);\n+        setMetastoreImplClass(baseClientConf);\n+\n         try {\n             // start zookeeper service\n             startZKCluster();\n@@ -382,4 +388,9 @@ protected BookieServer startBookie(ServerConfiguration conf)\n \n         return server;\n     }\n+\n+    public void setMetastoreImplClass(AbstractConfiguration conf) {\n+        conf.setMetastoreImplClass(InMemoryMetaStore.class.getName());\n+    }\n+\n }"},{"sha":"b4026b40d44b6668d5161b82fe7c9bab20402af4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -49,6 +49,7 @@ public MultiLedgerManagerMultiDigestTestCase(int numBookies) {\n         String[] ledgerManagers = {\n             \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.MSLedgerManagerFactory\",\n         };\n         ArrayList<Object[]> cfgs = new ArrayList<Object[]>(ledgerManagers.length);\n         DigestType[] digestTypes = new DigestType[] { DigestType.MAC, DigestType.CRC32 };"},{"sha":"cba8be4cccde1ec461fd19231179e9ef5f3bf76c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/5414cec92a99135c8ba0bc0f6768bd348c65e2fb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java?ref=5414cec92a99135c8ba0bc0f6768bd348c65e2fb","patch":"@@ -45,6 +45,7 @@ public MultiLedgerManagerTestCase(int numBookies) {\n         String[] ledgerManagers = new String[] {\n             \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.MSLedgerManagerFactory\",\n         };\n         ArrayList<Object[]> cfgs = new ArrayList<Object[]>(ledgerManagers.length);\n         for (String lm : ledgerManagers) {"}]}

