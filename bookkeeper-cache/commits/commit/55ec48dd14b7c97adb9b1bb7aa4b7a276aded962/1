{"sha":"55ec48dd14b7c97adb9b1bb7aa4b7a276aded962","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1NWVjNDhkZDE0YjdjOTdhZGI5YjFiYjdhYTRiN2EyNzZhZGVkOTYy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-05-30T15:41:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-05-30T15:41:38Z"},"message":"BOOKKEEPER-751: Ensure all the bookkeeper callbacks not run under ledger handle lock (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1598644 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4b59927270fe939c01088a16c283c16b64e178f4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4b59927270fe939c01088a16c283c16b64e178f4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962","html_url":"https://github.com/apache/bookkeeper/commit/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c7a0c1c43e7beea9969b149cd796a712a0c6330d","url":"https://api.github.com/repos/apache/bookkeeper/commits/c7a0c1c43e7beea9969b149cd796a712a0c6330d","html_url":"https://github.com/apache/bookkeeper/commit/c7a0c1c43e7beea9969b149cd796a712a0c6330d"}],"stats":{"total":81,"additions":61,"deletions":20},"files":[{"sha":"b59ff2a5968e997ce5206d6ea699633f7447cb18","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=55ec48dd14b7c97adb9b1bb7aa4b7a276aded962","patch":"@@ -32,6 +32,8 @@ Release 4.2.3 - 2013-12-04\n \n         BOOKKEEPER-673: Ledger length can be inaccurate in failure case (sijie via ivank)\n \n+        BOOKKEEPER-751: Ensure all the bookkeeper callbacks not run under ledger handle lock (sijie via ivank)\n+\n     IMPROVEMENT:\n \n         BOOKKEEPER-747: Implement register/unregister LedgerMetadataListener in MSLedgerManagerFactory (fpj via sijie)"},{"sha":"5a9c75217ab8aed5c65ad2173bc6ff95e23e564d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":59,"deletions":20,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/55ec48dd14b7c97adb9b1bb7aa4b7a276aded962/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=55ec48dd14b7c97adb9b1bb7aa4b7a276aded962","patch":"@@ -26,6 +26,7 @@\n import java.util.Arrays;\n import java.util.ArrayList;\n import java.util.Enumeration;\n+import java.util.List;\n import java.util.Queue;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -250,6 +251,7 @@ public void safeRun() {\n                 final long prevLastEntryId;\n                 final long prevLength;\n                 final State prevState;\n+                List<PendingAddOp> pendingAdds;\n \n                 synchronized(LedgerHandle.this) {\n                     // if the metadata is already closed, we don't need to proceed the process\n@@ -262,8 +264,8 @@ public void safeRun() {\n                     prevLastEntryId = metadata.getLastEntryId();\n                     prevLength = metadata.getLength();\n \n-                    // error out pending adds first\n-                    errorOutPendingAdds(rc);\n+                    // drain pending adds first\n+                    pendingAdds = drainPendingAddsToErrorOut();\n \n                     // synchronized on LedgerHandle.this to ensure that \n                     // lastAddPushed can not be updated after the metadata \n@@ -273,6 +275,10 @@ public void safeRun() {\n                     lastAddPushed = lastAddConfirmed;\n                 }\n \n+                // error out all pending adds during closing, the callbacks shouldn't be\n+                // running under any bk locks.\n+                errorOutPendingAdds(rc, pendingAdds);\n+\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n                               + metadata.getLastEntryId() + \" with this many bytes: \" + metadata.getLength());\n@@ -492,21 +498,28 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n \n         final long entryId;\n         final long currentLength;\n+        boolean wasClosed = false;\n         synchronized(this) {\n             // synchronized on this to ensure that\n             // the ledger isn't closed between checking and\n             // updating lastAddPushed\n             if (metadata.isClosed()) {\n-                LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                cb.addComplete(BKException.Code.LedgerClosedException,\n-                               LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n-                return;\n+                wasClosed = true;\n+                entryId = -1;\n+                currentLength = 0;\n+            } else {\n+                entryId = ++lastAddPushed;\n+                currentLength = addToLength(length);\n+                op.setEntryId(entryId);\n+                pendingAddOps.add(op);\n             }\n+        }\n \n-            entryId = ++lastAddPushed;\n-            currentLength = addToLength(length);\n-            op.setEntryId(entryId);\n-            pendingAddOps.add(op);\n+        if (wasClosed) {\n+            LOG.warn(\"Attempt to add to closed ledger: {}\", ledgerId);\n+            cb.addComplete(BKException.Code.LedgerClosedException,\n+                           LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+            return;\n         }\n \n         try {\n@@ -644,10 +657,22 @@ void handleUnrecoverableErrorDuringAdd(int rc) {\n     }\n \n     void errorOutPendingAdds(int rc) {\n+        errorOutPendingAdds(rc, drainPendingAddsToErrorOut());\n+    }\n+\n+    synchronized List<PendingAddOp> drainPendingAddsToErrorOut() {\n         PendingAddOp pendingAddOp;\n+        List<PendingAddOp> opsDrained = new ArrayList<PendingAddOp>(pendingAddOps.size());\n         while ((pendingAddOp = pendingAddOps.poll()) != null) {\n             addToLength(-pendingAddOp.entryLength);\n-            pendingAddOp.submitCallback(rc);\n+            opsDrained.add(pendingAddOp);\n+        }\n+        return opsDrained;\n+    }\n+\n+    void errorOutPendingAdds(int rc, List<PendingAddOp> ops) {\n+        for (PendingAddOp op : ops) {\n+            op.submitCallback(rc);\n         }\n     }\n \n@@ -896,25 +921,39 @@ void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n         bk.getLedgerManager().readLedgerMetadata(ledgerId, cb);\n     }\n \n-    synchronized void recover(final GenericCallback<Void> cb) {\n-        if (metadata.isClosed()) {\n-            lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n-            length = metadata.getLength();\n+    void recover(final GenericCallback<Void> cb) {\n+        boolean wasClosed = false;\n+        boolean wasInRecovery = false;\n \n+        synchronized (this) {\n+            if (metadata.isClosed()) {\n+                lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n+                length = metadata.getLength();\n+                wasClosed = true;\n+            } else {\n+                wasClosed = false;\n+                if (metadata.isInRecovery()) {\n+                    wasInRecovery = true;\n+                } else {\n+                    wasInRecovery = false;\n+                    metadata.markLedgerInRecovery();\n+                }\n+            }\n+        }\n+\n+        if (wasClosed) {\n             // We are already closed, nothing to do\n             cb.operationComplete(BKException.Code.OK, null);\n             return;\n         }\n \n-        // if metadata is already in recover, dont try to write again,\n-        // just do the recovery from the starting point\n-        if (metadata.isInRecovery()) {\n+        if (wasInRecovery) {\n+            // if metadata is already in recover, dont try to write again,\n+            // just do the recovery from the starting point\n             new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n             return;\n         }\n \n-        metadata.markLedgerInRecovery();\n-\n         writeLedgerConfig(new OrderedSafeGenericCallback<Void>(bk.mainWorkerPool, ledgerId) {\n             @Override\n             public void safeOperationComplete(final int rc, Void result) {"}]}

