{"sha":"5a3b29d05abd71c6e5d1b3045abafd434db15f24","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1YTNiMjlkMDVhYmQ3MWM2ZTVkMWIzMDQ1YWJhZmQ0MzRkYjE1ZjI0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-13T14:46:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-13T14:46:38Z"},"message":"BOOKKEEPER-152: Can't recover a ledger whose current ensemble contain failed bookie. (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1243539 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e8099ca4f7243d4f58df205cc8f3ad0546f84763","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e8099ca4f7243d4f58df205cc8f3ad0546f84763"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24","html_url":"https://github.com/apache/bookkeeper/commit/5a3b29d05abd71c6e5d1b3045abafd434db15f24","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"29a472598083e522645f918ec602dd91d800f0d5","url":"https://api.github.com/repos/apache/bookkeeper/commits/29a472598083e522645f918ec602dd91d800f0d5","html_url":"https://github.com/apache/bookkeeper/commit/29a472598083e522645f918ec602dd91d800f0d5"}],"stats":{"total":354,"additions":217,"deletions":137},"files":[{"sha":"645d7df4576c34c443fb15cb25c5b80ef7aac9ed","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -34,6 +34,8 @@ Trunk (unreleased changes)\n \n \tBOOKKEEPER-162: LedgerHandle.readLastConfirmed does not work (fpj)\n \n+        BOOKKEEPER-152: Can't recover a ledger whose current ensemble contain failed bookie. (ivank)\n+\n       hedwig-server/\n       \n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)"},{"sha":"a5bb426f381a2a07b81a4e9d9f4beb6f6cb6a1bf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -164,10 +164,12 @@ ChannelBufferInputStream verifyDigestAndReturnData(long entryId, ChannelBuffer d\n     static class RecoveryData {\n         long lastAddConfirmed;\n         long entryId;\n+        long length;\n \n-        public RecoveryData(long lastAddConfirmed, long entryId) {\n+        public RecoveryData(long lastAddConfirmed, long entryId, long length) {\n             this.lastAddConfirmed = lastAddConfirmed;\n             this.entryId = entryId;\n+            this.length = length;\n         }\n \n     }\n@@ -179,7 +181,6 @@ RecoveryData verifyDigestAndReturnLastConfirmed(ChannelBuffer dataReceived) thro\n         long entryId = dataReceived.readLong();\n         long lastAddConfirmed = dataReceived.readLong();\n         long length = dataReceived.readLong();\n-        return new RecoveryData(lastAddConfirmed, entryId);\n-\n+        return new RecoveryData(lastAddConfirmed, entryId, length);\n     }\n }"},{"sha":"833f5014fd486906b3af32a4e897d7252ecffb5c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -48,14 +48,18 @@\n     public int getReplicaIndex(long entryId, int bookieIndex);\n \n     /**\n-     * Specifies whether its ok to proceed with recovery given that we have\n-     * heard back from the given bookie index. These calls will be a made in a\n-     * sequence and an implementation of this interface should accumulate\n-     * history about which bookie indexes we have heard from. Once this method\n-     * has returned true, it wont be called again on the same instance\n-     *\n-     * @param bookieIndexHeardFrom\n-     * @return true if its ok to proceed with recovery\n+     * Interface to keep track of which bookies in an ensemble, an action\n+     * has been performed for.\n      */\n-    public boolean canProceedWithRecovery(int bookieIndexHeardFrom);\n+    public interface QuorumCoverageSet {\n+        /**\n+         * Add a bookie to the set, and check if all quorum in the set\n+         * have had the action performed for it.\n+         * @param bookieIndexHeardFrom Bookie we've just heard from\n+         * @return whether all quorums have been covered\n+         */\n+        public boolean addBookieAndCheckCovered(int bookieIndexHeardFrom);\n+    }\n+\n+    public QuorumCoverageSet getCoverageSet();\n }"},{"sha":"a94a0e520e5b4061229fcf516946731712ceb636","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":21,"deletions":2,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -498,8 +498,20 @@ public void safeRun() {\n      * @param ctx\n      */\n \n-    public void asyncReadLastConfirmed(ReadLastConfirmedCallback cb, Object ctx) {\n-        new ReadLastConfirmedOp(this, cb, ctx).initiate();\n+    public void asyncReadLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {\n+        ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n+                public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {\n+                    if (rc == BKException.Code.OK) {\n+                        lastAddConfirmed = Math.max(lastAddConfirmed, data.lastAddConfirmed);\n+                        lastAddPushed = Math.max(lastAddPushed, data.lastAddConfirmed);\n+                        length = Math.max(length, data.length);\n+                        cb.readLastConfirmedComplete(rc, data.lastAddConfirmed, ctx);\n+                    } else {\n+                        cb.readLastConfirmedComplete(rc, -1, ctx);\n+                    }\n+                }\n+            };\n+        new ReadLastConfirmedOp(this, innercb).initiate();\n     }\n \n \n@@ -688,6 +700,13 @@ void recover(final GenericCallback<Void> cb) {\n             return;\n         }\n \n+        // if metadata is already in recover, dont try to write again,\n+        // just do the recovery from the starting point\n+        if (metadata.isInRecovery()) {\n+            new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n+            return;\n+        }\n+\n         metadata.markLedgerInRecovery();\n \n         writeLedgerConfig(new StatCallback() {"},{"sha":"c67a79cb46e2f21fa175e1194406ea2ffe606920","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":19,"deletions":65,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -23,11 +23,11 @@\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n \n import org.apache.zookeeper.KeeperException;\n@@ -43,7 +43,7 @@\n  * the ledger at that entry.\n  *\n  */\n-class LedgerRecoveryOp implements ReadEntryCallback, ReadCallback, AddCallback {\n+class LedgerRecoveryOp implements ReadCallback, AddCallback {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerRecoveryOp.class);\n     LedgerHandle lh;\n     int numResponsesPending;\n@@ -61,70 +61,25 @@ public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n     }\n \n     public void initiate() {\n-        /** \n+        ReadLastConfirmedOp rlcop = new ReadLastConfirmedOp(lh,\n+                new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n+                public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n+                    if (rc == BKException.Code.OK) {\n+                        lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n+                        lh.length = data.length;\n+                        doRecoveryRead();\n+                    } else {\n+                        cb.operationComplete(BKException.Code.ReadException, null);\n+                    }\n+                }\n+                });\n+\n+        /**\n          * Enable fencing on this op. When the read request reaches the bookies\n          * server it will fence off the ledger, stopping any subsequent operation\n          * from writing to it.\n          */\n-        int flags = BookieProtocol.FLAG_DO_FENCING;\n-        for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, \n-                                         BookieProtocol.LAST_ADD_CONFIRMED, this, i, flags);\n-        }\n-    }\n-\n-    public synchronized void readEntryComplete(final int rc, final long ledgerId, final long entryId,\n-            final ChannelBuffer buffer, final Object ctx) {\n-\n-        // Already proceeding with recovery, nothing to do\n-        if (proceedingWithRecovery) {\n-            return;\n-        }\n-\n-        int bookieIndex = (Integer) ctx;\n-\n-        numResponsesPending--;\n-\n-        boolean heardValidResponse = false;\n-\n-        if (rc == BKException.Code.OK) {\n-            try {\n-                RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n-                maxAddConfirmed = Math.max(maxAddConfirmed, recoveryData.lastAddConfirmed);\n-                maxAddPushed = Math.max(maxAddPushed, recoveryData.entryId);\n-                heardValidResponse = true;\n-            } catch (BKDigestMatchException e) {\n-                // Too bad, this bookie didnt give us a valid answer, we\n-                // still might be able to recover though so continue\n-                LOG.error(\"Mac mismatch while reading last entry from bookie: \"\n-                          + lh.metadata.currentEnsemble.get(bookieIndex));\n-            }\n-        }\n-\n-        if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n-            // this still counts as a valid response, e.g., if the\n-            // client\n-            // crashed without writing any entry\n-            heardValidResponse = true;\n-        }\n-\n-        // other return codes dont count as valid responses\n-        if (heardValidResponse && lh.distributionSchedule.canProceedWithRecovery(bookieIndex)) {\n-            proceedingWithRecovery = true;\n-            lh.lastAddPushed = lh.lastAddConfirmed = maxAddConfirmed;\n-            lh.length = maxLength;\n-            doRecoveryRead();\n-            return;\n-        }\n-\n-        if (numResponsesPending == 0) {\n-            // Have got all responses back but was still not enough to\n-            // start\n-            // recovery, just fail the operation\n-            LOG.error(\"While recovering ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n-            cb.operationComplete(BKException.Code.LedgerRecoveryException, null);\n-        }\n-\n+        rlcop.initiateWithFencing();\n     }\n \n     /**\n@@ -163,10 +118,9 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                         cb.operationComplete(BKException.Code.ZKException, null);\n                     } else {\n                         cb.operationComplete(BKException.Code.OK, null);\n-                        LOG.debug(\"After closing length is: \" + lh.getLength()); \n+                        LOG.debug(\"After closing length is: \" + lh.getLength());\n                     }\n-                } \n-                \n+                }\n                 }, null, BKException.Code.LedgerClosedException);\n             return;\n         }"},{"sha":"7dd5363540ed3c0224c37fb1067e3a0e105cf1fb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":37,"deletions":23,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -33,29 +33,41 @@\n class ReadLastConfirmedOp implements ReadEntryCallback {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerRecoveryOp.class);\n     LedgerHandle lh;\n-    Object ctx;\n     int numResponsesPending;\n-    int validResponses;\n-    long maxAddConfirmed;\n-    long maxLength = 0;\n+    RecoveryData maxRecoveredData;\n     volatile boolean completed = false;\n \n-    ReadLastConfirmedCallback cb;\n+    LastConfirmedDataCallback cb;\n+    final DistributionSchedule.QuorumCoverageSet coverageSet;\n \n-    public ReadLastConfirmedOp(LedgerHandle lh, ReadLastConfirmedCallback cb, Object ctx) {\n+    /**\n+     * Wrapper to get all recovered data from the request\n+     */\n+    interface LastConfirmedDataCallback {\n+        public void readLastConfirmedDataComplete(int rc, RecoveryData data);\n+    }\n+\n+    public ReadLastConfirmedOp(LedgerHandle lh, LastConfirmedDataCallback cb) {\n         this.cb = cb;\n-        this.ctx = ctx;\n+        this.maxRecoveredData = new RecoveryData(-1,-1,0);\n         this.lh = lh;\n-        this.maxAddConfirmed = -1L;\n-        this.validResponses = 0;\n         this.numResponsesPending = lh.metadata.ensembleSize;\n+        this.coverageSet = lh.distributionSchedule.getCoverageSet();\n     }\n \n     public void initiate() {\n-        LOG.info(\"### Initiate ###\");\n+        initiate(BookieProtocol.FLAG_NONE);\n+    }\n+\n+    public void initiateWithFencing() {\n+        initiate(BookieProtocol.FLAG_DO_FENCING);\n+    }\n+\n+    private void initiate(short flags) {\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, \n-                                         this, i, BookieProtocol.FLAG_NONE);\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId,\n+                                         BookieProtocol.LAST_ADD_CONFIRMED,\n+                                         this, i, flags);\n         }\n     }\n \n@@ -64,12 +76,14 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n         int bookieIndex = (Integer) ctx;\n \n         numResponsesPending--;\n-\n+        boolean heardValidResponse = false;\n         if (rc == BKException.Code.OK) {\n             try {\n                 RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n-                maxAddConfirmed = Math.max(maxAddConfirmed, recoveryData.lastAddConfirmed);\n-                validResponses++;\n+                if (recoveryData.lastAddConfirmed > maxRecoveredData.lastAddConfirmed) {\n+                    maxRecoveredData = recoveryData;\n+                }\n+                heardValidResponse = true;\n             } catch (BKDigestMatchException e) {\n                 // Too bad, this bookie didn't give us a valid answer, we\n                 // still might be able to recover though so continue\n@@ -80,26 +94,26 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n \n         if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n             // this still counts as a valid response, e.g., if the client crashed without writing any entry\n-            validResponses++;\n+            heardValidResponse = true;\n         }\n \n-        // other return codes don't count as valid responses\n-        if ((validResponses >= lh.metadata.quorumSize) &&\n-                !completed) {\n+        // other return codes dont count as valid responses\n+        if (heardValidResponse\n+            && coverageSet.addBookieAndCheckCovered(bookieIndex)\n+            && !completed) {\n             completed = true;\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Read Complete with enough validResponses\");\n             }\n-            if(maxAddConfirmed > lh.lastAddConfirmed) lh.lastAddConfirmed = maxAddConfirmed;\n-            cb.readLastConfirmedComplete(BKException.Code.OK, maxAddConfirmed, this.ctx);\n+\n+            cb.readLastConfirmedDataComplete(BKException.Code.OK, maxRecoveredData);\n             return;\n         }\n \n         if (numResponsesPending == 0 && !completed) {\n-            completed = true;\n             // Have got all responses back but was still not enough, just fail the operation\n             LOG.error(\"While readLastConfirmed ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n-            cb.readLastConfirmedComplete(BKException.Code.LedgerRecoveryException, maxAddConfirmed, this.ctx);\n+            cb.readLastConfirmedDataComplete(BKException.Code.LedgerRecoveryException, maxRecoveredData);\n         }\n \n     }"},{"sha":"9c989d8dfa2f1c7b9d2724872addff48e9cd6ac6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":23,"deletions":20,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -31,10 +31,6 @@\n     int quorumSize;\n     int ensembleSize;\n \n-    // covered[i] is true if the quorum starting at bookie index i has been\n-    // covered by a recovery reply\n-    boolean[] covered = null;\n-    int numQuorumsUncovered;\n \n     public RoundRobinDistributionSchedule(int quorumSize, int ensembleSize) {\n         this.quorumSize = quorumSize;\n@@ -57,31 +53,38 @@ public int getReplicaIndex(long entryId, int bookieIndex) {\n \n     }\n \n-    public synchronized boolean canProceedWithRecovery(int bookieIndexHeardFrom) {\n-        if (covered == null) {\n+    private class RRQuorumCoverageSet implements QuorumCoverageSet {\n+        // covered[i] is true if the quorum starting at bookie index i has been\n+        // covered by a recovery reply\n+        private boolean[] covered = null;\n+        private int numQuorumsUncovered;\n+\n+        private RRQuorumCoverageSet() {\n             covered = new boolean[ensembleSize];\n             numQuorumsUncovered = ensembleSize;\n         }\n \n-        if (numQuorumsUncovered == 0) {\n-            return true;\n-        }\n+        public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n+            if (numQuorumsUncovered == 0) {\n+                return true;\n+            }\n \n-        for (int i = 0; i < quorumSize; i++) {\n-            int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n-            if (!covered[quorumStartIndex]) {\n-                covered[quorumStartIndex] = true;\n-                numQuorumsUncovered--;\n+            for (int i = 0; i < quorumSize; i++) {\n+                int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n+                if (!covered[quorumStartIndex]) {\n+                    covered[quorumStartIndex] = true;\n+                    numQuorumsUncovered--;\n \n-                if (numQuorumsUncovered == 0) {\n-                    return true;\n+                    if (numQuorumsUncovered == 0) {\n+                        return true;\n+                    }\n                 }\n             }\n-\n+            return false;\n         }\n-\n-        return false;\n-\n     }\n \n+    public QuorumCoverageSet getCoverageSet() {\n+        return new RRQuorumCoverageSet();\n+    }\n }"},{"sha":"ca055e86b3b27b9d0662bc0595f7a177cd69e6ef","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -405,7 +405,6 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n         LOG.info(\"Disconnected from bookie: \" + addr);\n         errorOutOutstandingEntries();\n         channel.close();\n-\n         state = ConnectionState.DISCONNECTED;\n \n         // we don't want to reconnect right away. If someone sends a request to"},{"sha":"99258aca7cd6db9bd5bb922375931532663d5a25","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -237,8 +237,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n         bs.remove(0);\n \n         // Startup a new bookie server\n-        int newBookiePort = initialPort + numBookies;\n-        startNewBookie(newBookiePort);\n+        int newBookiePort = startNewBookie();\n \n         // Write some more entries for the ledgers so a new ensemble will be\n         // created for them.\n@@ -292,8 +291,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n \n         // Startup three new bookie servers\n         for (int i = 0; i < 3; i++) {\n-            int newBookiePort = initialPort + numBookies + i;\n-            startNewBookie(newBookiePort);\n+            startNewBookie();\n         }\n \n         // Write some more entries for the ledgers so a new ensemble will be\n@@ -346,8 +344,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         bs.remove(0);\n \n         // Startup a new bookie server\n-        int newBookiePort = initialPort + numBookies;\n-        startNewBookie(newBookiePort);\n+        int newBookiePort = startNewBookie();\n \n         // Write some more entries for the ledgers so a new ensemble will be\n         // created for them.\n@@ -391,8 +388,7 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n \n         // Startup three new bookie servers\n         for (int i = 0; i < 3; i++) {\n-            int newBookiePort = initialPort + numBookies + i;\n-            startNewBookie(newBookiePort);\n+            startNewBookie();\n         }\n \n         // Write some more entries for the ledgers so a new ensemble will be\n@@ -561,8 +557,7 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n             bs.remove(removeIndex);\n             \n             // Startup three new bookie servers\n-            int newBookiePort = initialPort + numBookies + i;\n-            startNewBookie(newBookiePort);\n+            startNewBookie();\n             \n             // Write some more entries for the ledgers so a new ensemble will be\n             // created for them."},{"sha":"dada67a969c695a76a8288be145fe67e0799593b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":16,"deletions":2,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -72,6 +72,7 @@\n     protected List<BookieServer> bs = new ArrayList<BookieServer>();\n     protected List<ServerConfiguration> bsConfs = new ArrayList<ServerConfiguration>();\n     protected Integer initialPort = 5000;\n+    private Integer nextPort = initialPort;\n     protected int numBookies;\n     protected BookKeeperTestClient bkc;\n \n@@ -142,7 +143,7 @@ public void setUp() throws Exception {\n                 f.mkdir();\n \n                 ServerConfiguration conf = newServerConfiguration(\n-                    initialPort + i, HOSTPORT, f, new File[] { f });\n+                    nextPort++, HOSTPORT, f, new File[] { f });\n                 bsConfs.add(conf);\n \n                 bs.add(startBookie(conf));\n@@ -166,6 +167,15 @@ public void killBookie(InetSocketAddress addr) throws InterruptedException {\n         }\n     }\n \n+    public void killBookie(int index) throws InterruptedException, IOException {\n+        if (index >= bs.size()) {\n+            throw new IOException(\"Bookie does not exist\");\n+        }\n+        BookieServer server = bs.get(index);\n+        server.shutdown();\n+        bs.remove(server);\n+    }\n+\n     public void sleepBookie(InetSocketAddress addr, final int seconds,\n                             final CountDownLatch l)\n             throws InterruptedException, IOException {\n@@ -235,16 +245,19 @@ protected void restartBookies(ServerConfiguration newConf)\n      *            Port to start the new bookie server on\n      * @throws IOException\n      */\n-    protected void startNewBookie(int port)\n+    protected int startNewBookie()\n             throws IOException, InterruptedException, KeeperException, BookieException {\n         File f = File.createTempFile(\"bookie\", \"test\");\n         tmpDirs.add(f);\n         f.delete();\n         f.mkdir();\n \n+        int port = nextPort++;\n         ServerConfiguration conf = newServerConfiguration(port, HOSTPORT, f, new File[] { f });\n \n         bs.add(startBookie(conf));\n+\n+        return port;\n     }\n \n     /**\n@@ -266,6 +279,7 @@ private BookieServer startBookie(ServerConfiguration conf)\n \n         bkc.readBookiesBlocking();\n         LOG.info(\"New bookie on port \" + port + \" has been created.\");\n+\n         return server;\n     }\n "},{"sha":"ea51118d855387d25a6267464dc097ad7ca77ee8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"modified","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -302,4 +302,80 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n+    @Test\n+    public void testLedgerNoRecoveryOpenAfterBKCrashed() throws Exception {\n+        // Create a ledger\n+        LedgerHandle beforelh = bkc.createLedger(numBookies, numBookies, digestType, \"\".getBytes());\n+\n+        int numEntries = 10;\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+\n+        // try to open ledger no recovery\n+        LedgerHandle afterlh = bkc.openLedgerNoRecovery(beforelh.getId(), digestType, \"\".getBytes());\n+\n+        assertEquals(numEntries - 2, afterlh.getLastAddConfirmed());\n+\n+        startNewBookie();\n+        LedgerHandle beforelh2 = bkc.createLedger(numBookies, 1, digestType, \"\".getBytes());\n+\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh2.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+\n+        // try to open ledger no recovery\n+        try {\n+            bkc.openLedgerNoRecovery(beforelh2.getId(), digestType, \"\".getBytes());\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKReadException e) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    @Test\n+    public void testLedgerOpenAfterBKCrashed() throws Exception {\n+        // Create a ledger\n+        LedgerHandle beforelh = bkc.createLedger(numBookies, numBookies, digestType, \"\".getBytes());\n+\n+        int numEntries = 10;\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+        startNewBookie();\n+\n+        // try to open ledger no recovery\n+        LedgerHandle afterlh = bkc.openLedger(beforelh.getId(), digestType, \"\".getBytes());\n+\n+        assertEquals(beforelh.getLastAddPushed(), afterlh.getLastAddConfirmed());\n+\n+        LedgerHandle beforelh2 = bkc.createLedger(numBookies, 1, digestType, \"\".getBytes());\n+\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh2.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+\n+        // try to open ledger no recovery\n+        try {\n+            bkc.openLedger(beforelh2.getId(), digestType, \"\".getBytes());\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKLedgerRecoveryException e) {\n+            // correct behaviour\n+        }\n+    }\n+\n }"},{"sha":"22e494e40acb6e8c628cdfcb4773e62bcfbff3b7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5a3b29d05abd71c6e5d1b3045abafd434db15f24/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java?ref=5a3b29d05abd71c6e5d1b3045abafd434db15f24","patch":"@@ -139,8 +139,7 @@ public void testLedgerRecoveryWithNotEnoughBookies() throws Exception {\n         }\n \n         // start a new bookie server\n-        int newBookiePort = initialPort + numBookies;\n-        startNewBookie(newBookiePort);\n+        startNewBookie();\n \n         LedgerHandle afterlh = bkc.openLedger(beforelh.getId(), digestType, \"\".getBytes());\n "}]}

