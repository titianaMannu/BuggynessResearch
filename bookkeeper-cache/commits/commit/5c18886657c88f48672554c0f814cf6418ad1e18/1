{"sha":"5c18886657c88f48672554c0f814cf6418ad1e18","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1YzE4ODg2NjU3Yzg4ZjQ4NjcyNTU0YzBmODE0Y2Y2NDE4YWQxZTE4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-04-29T20:07:12Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-04-29T20:07:12Z"},"message":"BOOKKEEPER-716: padding writes for bookie journal (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1591079 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"16d9381f583def0d10809b7f56feafe103be85b3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/16d9381f583def0d10809b7f56feafe103be85b3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5c18886657c88f48672554c0f814cf6418ad1e18","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5c18886657c88f48672554c0f814cf6418ad1e18","html_url":"https://github.com/apache/bookkeeper/commit/5c18886657c88f48672554c0f814cf6418ad1e18","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5c18886657c88f48672554c0f814cf6418ad1e18/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"54c54f71a5fad10838c66c6a6b28ef13d9388931","url":"https://api.github.com/repos/apache/bookkeeper/commits/54c54f71a5fad10838c66c6a6b28ef13d9388931","html_url":"https://github.com/apache/bookkeeper/commit/54c54f71a5fad10838c66c6a6b28ef13d9388931"}],"stats":{"total":500,"additions":438,"deletions":62},"files":[{"sha":"bf644a7b68f845c9f36cd5fe4aaab486292ddd29","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -182,6 +182,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-743: Periodic ledger check running too often as doc doesn't match implementation. (ivank)\n \n+        BOOKKEEPER-716: padding writes for bookie journal (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"5d5d4e1cf6f84b6d30ec1f335b3d0d1360590735","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -471,7 +471,7 @@ public void process(int journalVersion, long offset, ByteBuffer recBuff) throws\n                 try {\n                     LOG.debug(\"Replay journal - ledger id : {}, entry id : {}.\", ledgerId, entryId);\n                     if (entryId == METAENTRY_ID_LEDGER_KEY) {\n-                        if (journalVersion >= 3) {\n+                        if (journalVersion >= JournalChannel.V3) {\n                             int masterKeyLen = recBuff.getInt();\n                             byte[] masterKey = new byte[masterKeyLen];\n \n@@ -483,7 +483,7 @@ public void process(int journalVersion, long offset, ByteBuffer recBuff) throws\n                                     + \") is too old to hold this\");\n                         }\n                     } else if (entryId == METAENTRY_ID_FENCE_KEY) {\n-                        if (journalVersion >= 4) {\n+                        if (journalVersion >= JournalChannel.V4) {\n                             byte[] key = masterKeyCache.get(ledgerId);\n                             if (key == null) {\n                                 key = ledgerStorage.readMasterKey(ledgerId);"},{"sha":"5034013eb9d0e20243973c96c8ea22eabf8528d0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":66,"deletions":9,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -41,6 +41,7 @@\n import org.apache.bookkeeper.util.DaemonThreadFactory;\n import org.apache.bookkeeper.util.IOUtils;\n import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.bookkeeper.util.ZeroBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -439,6 +440,33 @@ void shutdown() throws InterruptedException {\n         }\n     }\n \n+    final static int PADDING_MASK = -0x100;\n+\n+    static void writePaddingBytes(JournalChannel jc, ByteBuffer paddingBuffer, int journalAlignSize)\n+            throws IOException {\n+        int bytesToAlign = (int) (jc.bc.position() % journalAlignSize);\n+        if (0 != bytesToAlign) {\n+            int paddingBytes = journalAlignSize - bytesToAlign;\n+            if (paddingBytes < 8) {\n+                paddingBytes = journalAlignSize - (8 - paddingBytes);\n+            } else {\n+                paddingBytes -= 8;\n+            }\n+            paddingBuffer.clear();\n+            // padding mask\n+            paddingBuffer.putInt(PADDING_MASK);\n+            // padding len\n+            paddingBuffer.putInt(paddingBytes);\n+            // padding bytes\n+            paddingBuffer.position(8 + paddingBytes);\n+\n+            paddingBuffer.flip();\n+            jc.preAllocIfNeeded(paddingBuffer.limit());\n+            // write padding bytes\n+            jc.bc.write(paddingBuffer);\n+        }\n+    }\n+\n     final static long MB = 1024 * 1024L;\n     final static int KB = 1024;\n     // max journal file size\n@@ -590,6 +618,25 @@ public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n                 if (len == 0) {\n                     break;\n                 }\n+                boolean isPaddingRecord = false;\n+                if (len == PADDING_MASK) {\n+                    if (journalVersion >= JournalChannel.V5) {\n+                        // skip padding bytes\n+                        lenBuff.clear();\n+                        fullRead(recLog, lenBuff);\n+                        if (lenBuff.remaining() != 0) {\n+                            break;\n+                        }\n+                        lenBuff.flip();\n+                        len = lenBuff.getInt();\n+                        if (len == 0) {\n+                            continue;\n+                        }\n+                        isPaddingRecord = true;\n+                    } else {\n+                        throw new IOException(\"Invalid record found with negative length : \" + len);\n+                    }\n+                }\n                 recBuff.clear();\n                 if (recBuff.remaining() < len) {\n                     recBuff = ByteBuffer.allocate(len);\n@@ -601,7 +648,9 @@ public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n                     break;\n                 }\n                 recBuff.flip();\n-                scanner.process(journalVersion, offset, recBuff);\n+                if (!isPaddingRecord) {\n+                    scanner.process(journalVersion, offset, recBuff);\n+                }\n             }\n         } finally {\n             recLog.close();\n@@ -685,6 +734,8 @@ public int getJournalQueueLength() {\n     public void run() {\n         LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n         ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+        ByteBuffer paddingBuff = ByteBuffer.allocate(2 * conf.getJournalAlignmentSize());\n+        ZeroBuffer.put(paddingBuff);\n         JournalChannel logFile = null;\n         forceWriteThread.start();\n         try {\n@@ -706,10 +757,12 @@ public void run() {\n                                         logId,\n                                         journalPreAllocSize,\n                                         journalWriteBufferSize,\n-                                        removePagesFromCache);\n+                                        conf.getJournalAlignmentSize(),\n+                                        removePagesFromCache,\n+                                        conf.getJournalFormatVersionToWrite());\n                     bc = logFile.getBufferedChannel();\n \n-                    lastFlushPosition = 0;\n+                    lastFlushPosition = bc.position();\n                 }\n \n                 if (qe == null) {\n@@ -734,8 +787,9 @@ public void run() {\n                             // b) limit the number of entries to group\n                             groupWhenTimeout = false;\n                             shouldFlush = true;\n-                        } else if ((bufferedEntriesThreshold > 0 && toFlush.size() > bufferedEntriesThreshold) ||\n-                                (bc.position() > lastFlushPosition + bufferedWritesThreshold)) {\n+                        } else if (qe != null &&\n+                                ((bufferedEntriesThreshold > 0 && toFlush.size() > bufferedEntriesThreshold) ||\n+                                 (bc.position() > lastFlushPosition + bufferedWritesThreshold))) {\n                             // 2. If we have buffered more than the buffWriteThreshold or bufferedEntriesThreshold\n                             shouldFlush = true;\n                         } else if (qe == null) {\n@@ -748,6 +802,9 @@ public void run() {\n \n                         // toFlush is non null and not empty so should be safe to access getFirst\n                         if (shouldFlush) {\n+                            if (conf.getJournalFormatVersionToWrite() >= JournalChannel.V5) {\n+                                writePaddingBytes(logFile, paddingBuff, conf.getJournalAlignmentSize());\n+                            }\n                             bc.flush(false);\n                             lastFlushPosition = bc.position();\n \n@@ -781,17 +838,17 @@ public void run() {\n                 lenBuff.clear();\n                 lenBuff.putInt(qe.entry.remaining());\n                 lenBuff.flip();\n+\n+                // preAlloc based on size\n+                logFile.preAllocIfNeeded(4 + qe.entry.remaining());\n+\n                 //\n                 // we should be doing the following, but then we run out of\n                 // direct byte buffers\n                 // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n                 bc.write(lenBuff);\n                 bc.write(qe.entry);\n \n-                // NOTE: preAlloc depends on the fact that we don't change file size while this is\n-                // called or useful parts of the file will be zeroed out - in other words\n-                // it depends on single threaded flushes to the JournalChannel\n-                logFile.preAllocIfNeeded();\n                 toFlush.add(qe);\n                 qe = null;\n             }"},{"sha":"ad46e5cf3a826d9718ce9382d1c028ce7848fb70","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","status":"modified","additions":85,"deletions":32,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -21,22 +21,21 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.util.Arrays;\n-\n import java.io.Closeable;\n import java.io.File;\n import java.io.RandomAccessFile;\n import java.io.IOException;\n import java.nio.channels.FileChannel;\n import java.nio.ByteBuffer;\n-import org.apache.bookkeeper.util.NativeIO;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n+import java.util.Arrays;\n \n import org.apache.bookkeeper.util.NativeIO;\n+import org.apache.bookkeeper.util.ZeroBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static com.google.common.base.Charsets.UTF_8;\n+\n /**\n  * Simple wrapper around FileChannel to add versioning\n  * information to the file.\n@@ -53,45 +52,94 @@\n \n     final byte[] MAGIC_WORD = \"BKLG\".getBytes(UTF_8);\n \n+    final static int SECTOR_SIZE = 512;\n     private final static int START_OF_FILE = -12345;\n     private static long CACHE_DROP_LAG_BYTES = 8 * 1024 * 1024;\n \n-    int HEADER_SIZE = 8; // 4byte magic word, 4 byte version\n-    int MIN_COMPAT_JOURNAL_FORMAT_VERSION = 1;\n-    int CURRENT_JOURNAL_FORMAT_VERSION = 4;\n+    // No header\n+    static final int V1 = 1;\n+    // Adding header\n+    static final int V2 = 2;\n+    // Adding ledger key\n+    static final int V3 = 3;\n+    // Adding fencing key\n+    static final int V4 = 4;\n+    // 1) expanding header to 512\n+    // 2) Padding writes to align sector size\n+    static final int V5 = 5;\n+\n+    static final int HEADER_SIZE = SECTOR_SIZE; // align header to sector size\n+    static final int VERSION_HEADER_SIZE = 8; // 4byte magic word, 4 byte version\n+    static final int MIN_COMPAT_JOURNAL_FORMAT_VERSION = V1;\n+    static final int CURRENT_JOURNAL_FORMAT_VERSION = V5;\n \n-    private long preAllocSize;\n-    private boolean fRemoveFromPageCache;\n-    public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n+    private final long preAllocSize;\n+    private final int journalAlignSize;\n+    private final boolean fRemoveFromPageCache;\n+    public final ByteBuffer zeros;\n \n     // The position of the file channel's last drop position\n     private long lastDropPosition = 0L;\n \n     // Mostly used by tests\n     JournalChannel(File journalDirectory, long logId) throws IOException {\n-        this(journalDirectory, logId, 4*1024*1024, 65536, START_OF_FILE);\n+        this(journalDirectory, logId, 4 * 1024 * 1024, 65536, START_OF_FILE);\n     }\n \n+    // Open journal for scanning starting from the first record in journal.\n     JournalChannel(File journalDirectory, long logId, long preAllocSize, int writeBufferSize) throws IOException {\n         this(journalDirectory, logId, preAllocSize, writeBufferSize, START_OF_FILE);\n     }\n \n+    // Open journal for scanning starting from given position.\n     JournalChannel(File journalDirectory, long logId,\n                    long preAllocSize, int writeBufferSize, long position) throws IOException {\n-         this(journalDirectory, logId, preAllocSize, writeBufferSize, position, false);\n+         this(journalDirectory, logId, preAllocSize, writeBufferSize, SECTOR_SIZE, position, false, V5);\n     }\n \n+    // Open journal to write\n     JournalChannel(File journalDirectory, long logId,\n-                   long preAllocSize, int writeBufferSize, boolean fRemoveFromPageCache) throws IOException {\n-        this(journalDirectory, logId, preAllocSize, writeBufferSize, START_OF_FILE, fRemoveFromPageCache);\n+                   long preAllocSize, int writeBufferSize, int journalAlignSize,\n+                   boolean fRemoveFromPageCache, int formatVersionToWrite) throws IOException {\n+        this(journalDirectory, logId, preAllocSize, writeBufferSize, journalAlignSize,\n+             START_OF_FILE, fRemoveFromPageCache, formatVersionToWrite);\n     }\n \n-    JournalChannel(File journalDirectory, long logId,\n-                   long preAllocSize, int writeBufferSize, long position, boolean fRemoveFromPageCache) throws IOException {\n-        this.preAllocSize = preAllocSize;\n+    /**\n+     * Create a journal file.\n+     *\n+     * @param journalDirectory\n+     *          directory to store the journal file.\n+     * @param logId\n+     *          log id for the journal file.\n+     * @param preAllocSize\n+     *          pre allocation size.\n+     * @param writeBufferSize\n+     *          write buffer size.\n+     * @param journalAlignSize\n+     *          size to align journal writes.\n+     * @param position\n+     *          position to start read/write\n+     * @param fRemoveFromPageCache\n+     *          whether to remove cached pages from page cache.\n+     * @param formatVersionToWrite\n+     *          format version to write\n+     * @throws IOException\n+     */\n+    private JournalChannel(File journalDirectory, long logId,\n+                           long preAllocSize, int writeBufferSize, int journalAlignSize,\n+                           long position, boolean fRemoveFromPageCache,\n+                           int formatVersionToWrite) throws IOException {\n+        this.journalAlignSize = journalAlignSize;\n+        this.zeros = ByteBuffer.allocate(journalAlignSize);\n+        this.preAllocSize = preAllocSize - preAllocSize % journalAlignSize;\n         this.fRemoveFromPageCache = fRemoveFromPageCache;\n         File fn = new File(journalDirectory, Long.toHexString(logId) + \".txn\");\n \n+        if (formatVersionToWrite < V4) {\n+            throw new IOException(\"Invalid journal format to write : version = \" + formatVersionToWrite);\n+        }\n+\n         LOG.info(\"Opening journal {}\", fn);\n         if (!fn.exists()) { // new file, write version\n             if (!fn.createNewFile()) {\n@@ -102,40 +150,43 @@\n             }\n             randomAccessFile = new RandomAccessFile(fn, \"rw\");\n             fc = randomAccessFile.getChannel();\n-            formatVersion = CURRENT_JOURNAL_FORMAT_VERSION;\n+            formatVersion = formatVersionToWrite;\n \n-            ByteBuffer bb = ByteBuffer.allocate(HEADER_SIZE);\n+            int headerSize = (V4 == formatVersion) ? VERSION_HEADER_SIZE : HEADER_SIZE;\n+            ByteBuffer bb = ByteBuffer.allocate(headerSize);\n+            ZeroBuffer.put(bb);\n+            bb.clear();\n             bb.put(MAGIC_WORD);\n             bb.putInt(formatVersion);\n-            bb.flip();\n+            bb.clear();\n             fc.write(bb);\n \n             bc = new BufferedChannel(fc, writeBufferSize);\n             forceWrite(true);\n-            nextPrealloc = preAllocSize;\n-            fc.write(zeros, nextPrealloc);\n+            nextPrealloc = this.preAllocSize;\n+            fc.write(zeros, nextPrealloc - journalAlignSize);\n         } else {  // open an existing file\n             randomAccessFile = new RandomAccessFile(fn, \"r\");\n             fc = randomAccessFile.getChannel();\n             bc = null; // readonly\n \n-            ByteBuffer bb = ByteBuffer.allocate(HEADER_SIZE);\n+            ByteBuffer bb = ByteBuffer.allocate(VERSION_HEADER_SIZE);\n             int c = fc.read(bb);\n             bb.flip();\n \n-            if (c == HEADER_SIZE) {\n+            if (c == VERSION_HEADER_SIZE) {\n                 byte[] first4 = new byte[4];\n                 bb.get(first4);\n \n                 if (Arrays.equals(first4, MAGIC_WORD)) {\n                     formatVersion = bb.getInt();\n                 } else {\n                     // pre magic word journal, reset to 0;\n-                    formatVersion = 1;\n+                    formatVersion = V1;\n                 }\n             } else {\n                 // no header, must be old version\n-                formatVersion = 1;\n+                formatVersion = V1;\n             }\n \n             if (formatVersion < MIN_COMPAT_JOURNAL_FORMAT_VERSION\n@@ -150,8 +201,10 @@\n \n             try {\n                 if (position == START_OF_FILE) {\n-                    if (formatVersion >= 2) {\n+                    if (formatVersion >= V5) {\n                         fc.position(HEADER_SIZE);\n+                    } else if (formatVersion >= V2) {\n+                        fc.position(VERSION_HEADER_SIZE);\n                     } else {\n                         fc.position(0);\n                     }\n@@ -176,11 +229,11 @@ BufferedChannel getBufferedChannel() throws IOException {\n         return bc;\n     }\n \n-    void preAllocIfNeeded() throws IOException {\n-        if (bc.position() > nextPrealloc) {\n-            nextPrealloc = ((fc.size() + HEADER_SIZE) / preAllocSize + 1) * preAllocSize;\n+    void preAllocIfNeeded(long size) throws IOException {\n+        if (bc.position() + size > nextPrealloc) {\n+            nextPrealloc += preAllocSize;\n             zeros.clear();\n-            fc.write(zeros, nextPrealloc);\n+            fc.write(zeros, nextPrealloc - journalAlignSize);\n         }\n     }\n "},{"sha":"fae37b7a4365de11ca66138b943be342cbafa236","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -60,7 +60,9 @@\n     protected final static String JOURNAL_REMOVE_FROM_PAGE_CACHE = \"journalRemoveFromPageCache\";\n     protected final static String JOURNAL_PRE_ALLOC_SIZE = \"journalPreAllocSizeMB\";\n     protected final static String JOURNAL_WRITE_BUFFER_SIZE = \"journalWriteBufferSizeKB\";\n+    protected final static String JOURNAL_ALIGNMENT_SIZE = \"journalAlignmentSize\";\n     protected final static String NUM_JOURNAL_CALLBACK_THREADS = \"numJournalCallbackThreads\";\n+    protected final static String JOURNAL_FORMAT_VERSION_TO_WRITE = \"journalFormatVersionToWrite\";\n     // Bookie Parameters\n     protected final static String BOOKIE_PORT = \"bookiePort\";\n     protected final static String LISTENING_INTERFACE = \"listeningInterface\";\n@@ -333,6 +335,49 @@ public ServerConfiguration setMaxBackupJournals(int maxBackupJournals) {\n         return this;\n     }\n \n+    /**\n+     * All the journal writes and commits should be aligned to given size. If not,\n+     * zeros will be padded to align to given size.\n+     *\n+     * @return journal alignment size\n+     */\n+    public int getJournalAlignmentSize() {\n+        return this.getInt(JOURNAL_ALIGNMENT_SIZE, 512);\n+    }\n+\n+    /**\n+     * Set journal alignment size.\n+     *\n+     * @param size\n+     *          journal alignment size.\n+     * @return server configuration.\n+     */\n+    public ServerConfiguration setJournalAlignmentSize(int size) {\n+        this.setProperty(JOURNAL_ALIGNMENT_SIZE, size);\n+        return this;\n+    }\n+\n+    /**\n+     * Get journal format version to write.\n+     *\n+     * @return journal format version to write.\n+     */\n+    public int getJournalFormatVersionToWrite() {\n+        return this.getInt(JOURNAL_FORMAT_VERSION_TO_WRITE, 4);\n+    }\n+\n+    /**\n+     * Set journal format version to write.\n+     *\n+     * @param version\n+     *          journal format version to write.\n+     * @return server configuration.\n+     */\n+    public ServerConfiguration setJournalFormatVersionToWrite(int version) {\n+        this.setProperty(JOURNAL_FORMAT_VERSION_TO_WRITE, version);\n+        return this;\n+    }\n+\n     /**\n      * Get bookie port that bookie server listen on\n      *\n@@ -1222,5 +1267,11 @@ public void validate() throws ConfigurationException {\n         if (getSkipListArenaChunkSize() < getSkipListArenaMaxAllocSize()) {\n             throw new ConfigurationException(\"Arena max allocation size should be smaller than the chunk size.\");\n         }\n+        if (getJournalAlignmentSize() < 512 || getJournalAlignmentSize() % 512 != 0) {\n+            throw new ConfigurationException(\"Invalid journal alignment size : \" + getJournalAlignmentSize());\n+        }\n+        if (getJournalAlignmentSize() > getJournalPreAllocSizeMB() * 1024 * 1024) {\n+            throw new ConfigurationException(\"Invalid preallocation size : \" + getJournalPreAllocSizeMB() + \" MB\");\n+        }\n     }\n }"},{"sha":"5e8559461e33f733701e8482b5403e8d3c0c7a57","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","status":"modified","additions":18,"deletions":2,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -21,6 +21,8 @@\n package org.apache.bookkeeper.util;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n \n import org.slf4j.Logger;\n \n@@ -32,7 +34,7 @@\n     /**\n      * Close the Closeable objects and <b>ignore</b> any {@link IOException} or\n      * null pointers. Must only be used for cleanup in exception handlers.\n-     * \n+     *\n      * @param log\n      *            the log to record problems to at debug level. Can be null.\n      * @param closeables\n@@ -54,7 +56,7 @@ public static void close(Logger log, java.io.Closeable... closeables) {\n \n     /**\n      * Confirm prompt for the console operations.\n-     * \n+     *\n      * @param prompt\n      *            Prompt message to be displayed on console\n      * @return Returns true if confirmed as 'Y', returns false if confirmed as\n@@ -85,4 +87,18 @@ public static boolean confirmPrompt(String prompt) throws IOException {\n             // else ask them again\n         }\n     }\n+\n+    /**\n+     * Write a ByteBuffer to a WritableByteChannel, handling short writes.\n+     *\n+     * @param bc               The WritableByteChannel to write to\n+     * @param buf              The input buffer\n+     * @throws IOException     On I/O error\n+     */\n+    public static void writeFully(WritableByteChannel bc, ByteBuffer buf)\n+            throws IOException {\n+        do {\n+            bc.write(buf);\n+        } while (buf.remaining() > 0);\n+    }\n }"},{"sha":"0d6e592b629b96764255df74e3e4097d741e01fd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","status":"modified","additions":201,"deletions":10,"changes":211,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.bookie;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,6 +18,7 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.bookie;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n@@ -37,9 +36,12 @@\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n-import org.junit.Test;\n+import org.apache.bookkeeper.util.IOUtils;\n+import org.apache.bookkeeper.util.ZeroBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n \n public class BookieJournalTest {\n     private final static Logger LOG = LoggerFactory.getLogger(BookieJournalTest.class);\n@@ -80,6 +82,17 @@ private void writePartialIndexFileForLedger(File indexDir, long ledgerId,\n         fc.close();\n     }\n \n+    /**\n+     * Generate fence entry\n+     */\n+    private ByteBuffer generateFenceEntry(long ledgerId) {\n+        ByteBuffer bb = ByteBuffer.allocate(8 + 8);\n+        bb.putLong(ledgerId);\n+        bb.putLong(Bookie.METAENTRY_ID_FENCE_KEY);\n+        bb.flip();\n+        return bb;\n+    }\n+\n     /**\n      * Generate meta entry with given master key\n      */\n@@ -132,10 +145,32 @@ private void writePreV2Journal(File journalDir, int numEntries) throws Exception\n         }\n     }\n \n-    private JournalChannel writePostV2Journal(File journalDir, int numEntries) throws Exception {\n+    private static void moveToPosition(JournalChannel jc, long pos) throws IOException {\n+        jc.fc.position(pos);\n+        jc.bc.position = pos;\n+        jc.bc.writeBufferStartPosition.set(pos);\n+    }\n+\n+    private static void updateJournalVersion(JournalChannel jc, int journalVersion) throws IOException {\n+        long prevPos = jc.fc.position();\n+        try {\n+            ByteBuffer versionBuffer = ByteBuffer.allocate(4);\n+            versionBuffer.putInt(journalVersion);\n+            versionBuffer.flip();\n+            jc.fc.position(4);\n+            IOUtils.writeFully(jc.fc, versionBuffer);\n+            jc.fc.force(true);\n+        } finally {\n+            jc.fc.position(prevPos);\n+        }\n+    }\n+\n+    private JournalChannel writeV2Journal(File journalDir, int numEntries) throws Exception {\n         long logId = System.currentTimeMillis();\n         JournalChannel jc = new JournalChannel(journalDir, logId);\n \n+        moveToPosition(jc, JournalChannel.VERSION_HEADER_SIZE);\n+\n         BufferedChannel bc = jc.getBufferedChannel();\n \n         byte[] data = new byte[1024];\n@@ -153,13 +188,17 @@ private JournalChannel writePostV2Journal(File journalDir, int numEntries) throw\n         }\n         bc.flush(true);\n \n+        updateJournalVersion(jc, JournalChannel.V2);\n+\n         return jc;\n     }\n \n-    private JournalChannel writePostV3Journal(File journalDir, int numEntries, byte[] masterKey) throws Exception {\n+    private JournalChannel writeV3Journal(File journalDir, int numEntries, byte[] masterKey) throws Exception {\n         long logId = System.currentTimeMillis();\n         JournalChannel jc = new JournalChannel(journalDir, logId);\n \n+        moveToPosition(jc, JournalChannel.VERSION_HEADER_SIZE);\n+\n         BufferedChannel bc = jc.getBufferedChannel();\n \n         byte[] data = new byte[1024];\n@@ -182,6 +221,87 @@ private JournalChannel writePostV3Journal(File journalDir, int numEntries, byte[\n         }\n         bc.flush(true);\n \n+        updateJournalVersion(jc, JournalChannel.V3);\n+\n+        return jc;\n+    }\n+\n+    private JournalChannel writeV4Journal(File journalDir, int numEntries, byte[] masterKey) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        JournalChannel jc = new JournalChannel(journalDir, logId);\n+\n+        moveToPosition(jc, JournalChannel.VERSION_HEADER_SIZE);\n+\n+        BufferedChannel bc = jc.getBufferedChannel();\n+\n+        byte[] data = new byte[1024];\n+        Arrays.fill(data, (byte)'X');\n+        long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n+        for (int i = 0; i <= numEntries; i++) {\n+            ByteBuffer packet;\n+            if (i == 0) {\n+                packet = generateMetaEntry(1, masterKey);\n+            } else {\n+                packet = ClientUtil.generatePacket(1, i, lastConfirmed, i * data.length, data).toByteBuffer();\n+            }\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+            bc.write(lenBuff);\n+            bc.write(packet);\n+        }\n+        // write fence key\n+        ByteBuffer packet = generateFenceEntry(1);\n+        ByteBuffer lenBuf = ByteBuffer.allocate(4);\n+        lenBuf.putInt(packet.remaining());\n+        lenBuf.flip();\n+        bc.write(lenBuf);\n+        bc.write(packet);\n+        bc.flush(true);\n+        updateJournalVersion(jc, JournalChannel.V4);\n+        return jc;\n+    }\n+\n+    private JournalChannel writeV5Journal(File journalDir, int numEntries, byte[] masterKey) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        JournalChannel jc = new JournalChannel(journalDir, logId);\n+\n+        BufferedChannel bc = jc.getBufferedChannel();\n+\n+        ByteBuffer paddingBuff = ByteBuffer.allocateDirect(2 * JournalChannel.SECTOR_SIZE);\n+        ZeroBuffer.put(paddingBuff);\n+        byte[] data = new byte[4 * 1024 * 1024];\n+        Arrays.fill(data, (byte)'X');\n+        long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n+        long length = 0;\n+        for (int i = 0; i <= numEntries; i++) {\n+            ByteBuffer packet;\n+            if (i == 0) {\n+                packet = generateMetaEntry(1, masterKey);\n+            } else {\n+                packet = ClientUtil.generatePacket(1, i, lastConfirmed,\n+                        length, data, 0, i).toByteBuffer();\n+            }\n+            lastConfirmed = i;\n+            length += i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+            bc.write(lenBuff);\n+            bc.write(packet);\n+            Journal.writePaddingBytes(jc, paddingBuff, JournalChannel.SECTOR_SIZE);\n+        }\n+        // write fence key\n+        ByteBuffer packet = generateFenceEntry(1);\n+        ByteBuffer lenBuf = ByteBuffer.allocate(4);\n+        lenBuf.putInt(packet.remaining());\n+        lenBuf.flip();\n+        bc.write(lenBuf);\n+        bc.write(packet);\n+        Journal.writePaddingBytes(jc, paddingBuff, JournalChannel.SECTOR_SIZE);\n+        bc.flush(true);\n+        updateJournalVersion(jc, JournalChannel.V5);\n         return jc;\n     }\n \n@@ -224,6 +344,77 @@ public void testPreV2Journal() throws Exception {\n         b.shutdown();\n     }\n \n+    @Test\n+    public void testV4Journal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        writeV4Journal(Bookie.getCurrentDirectory(journalDir), 100, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = TestBKConfiguration.newServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.readJournal();\n+\n+        b.readEntry(1, 100);\n+        try {\n+            b.readEntry(1, 101);\n+            fail(\"Shouldn't have found entry 101\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+        assertTrue(b.handles.getHandle(1, \"testPasswd\".getBytes()).isFenced());\n+\n+        b.shutdown();\n+    }\n+\n+    @Test\n+    public void testV5Journal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        writeV5Journal(Bookie.getCurrentDirectory(journalDir), 2 * JournalChannel.SECTOR_SIZE,\n+                \"testV5Journal\".getBytes());\n+\n+        ServerConfiguration conf = TestBKConfiguration.newServerConfiguration()\n+                .setZkServers(null)\n+                .setJournalDirName(journalDir.getPath())\n+                .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.readJournal();\n+\n+        for (int i = 1; i <= 2 * JournalChannel.SECTOR_SIZE; i++) {\n+            b.readEntry(1, i);\n+        }\n+        try {\n+            b.readEntry(1, 2 * JournalChannel.SECTOR_SIZE + 1);\n+            fail(\"Shouldn't have found entry \" + (2 * JournalChannel.SECTOR_SIZE + 1));\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behavior\n+        }\n+        assertTrue(b.handles.getHandle(1, \"testV5Journal\".getBytes()).isFenced());\n+\n+        b.shutdown();\n+    }\n+\n     /**\n      * Test that if the journal is all journal, we can not\n      * start the bookie. An admin should look to see what has\n@@ -305,7 +496,7 @@ public void testHeaderOnlyJournal() throws Exception {\n         ledgerDir.mkdir();\n         Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n \n-        writePostV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n+        writeV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n \n         ServerConfiguration conf = TestBKConfiguration.newServerConfiguration()\n             .setZkServers(null)\n@@ -331,7 +522,7 @@ public void testJunkEndedJournal() throws Exception {\n         ledgerDir.mkdir();\n         Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n \n-        JournalChannel jc = writePostV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n+        JournalChannel jc = writeV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n         jc.getBufferedChannel().write(ByteBuffer.wrap(\"JunkJunkJunk\".getBytes()));\n         jc.getBufferedChannel().flush(true);\n \n@@ -370,7 +561,7 @@ public void testTruncatedInLenJournal() throws Exception {\n         ledgerDir.mkdir();\n         Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n \n-        JournalChannel jc = writePostV2Journal(\n+        JournalChannel jc = writeV2Journal(\n                 Bookie.getCurrentDirectory(journalDir), 100);\n         ByteBuffer zeros = ByteBuffer.allocate(2048);\n \n@@ -418,7 +609,7 @@ public void testTruncatedInEntryJournal() throws Exception {\n         ledgerDir.mkdir();\n         Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n \n-        JournalChannel jc = writePostV2Journal(\n+        JournalChannel jc = writeV2Journal(\n                 Bookie.getCurrentDirectory(journalDir), 100);\n         ByteBuffer zeros = ByteBuffer.allocate(2048);\n \n@@ -553,7 +744,7 @@ private void testPartialFileInfoPostV3Journal(boolean truncateMasterKey)\n \n         byte[] masterKey = \"testPasswd\".getBytes();\n \n-        writePostV3Journal(Bookie.getCurrentDirectory(journalDir), 100, masterKey);\n+        writeV3Journal(Bookie.getCurrentDirectory(journalDir), 100, masterKey);\n         writePartialIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir), 1, masterKey,\n                                        truncateMasterKey);\n "},{"sha":"dc43b2c37cdb756d39b9a9c32c9dff731912053d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"modified","additions":11,"deletions":7,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,20 +15,26 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.client;\n \n import org.jboss.netty.buffer.ChannelBuffer;\n \n public class ClientUtil {\n-    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed, \n-                                        long length, byte[] data) {\n+    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n+                                               long length, byte[] data) {\n+        return generatePacket(ledgerId, entryId, lastAddConfirmed, length, data, 0, data.length);\n+    }\n+\n+    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n+                                               long length, byte[] data, int offset, int len) {\n         CRC32DigestManager dm = new CRC32DigestManager(ledgerId);\n         return dm.computeDigestAndPackageForSending(entryId, lastAddConfirmed, length,\n-                                                    data, 0, data.length);\n+                                                    data, offset, len);\n     }\n-    \n+\n     /** Returns that whether ledger is in open state */\n     public static boolean isLedgerOpen(LedgerHandle handle) {\n         return !handle.metadata.isClosed();\n     }\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"719ae2e80d3b7aff9ea70411985cf6c7dd4c4f5b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/5c18886657c88f48672554c0f814cf6418ad1e18/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java?ref=5c18886657c88f48672554c0f814cf6418ad1e18","patch":"@@ -26,6 +26,8 @@\n     public static ServerConfiguration newServerConfiguration() {\n         ServerConfiguration confReturn = new ServerConfiguration();\n         confReturn.setJournalFlushWhenQueueEmpty(true);\n+        // enable journal format version\n+        confReturn.setJournalFormatVersionToWrite(5);\n         return confReturn;\n     }\n "}]}

