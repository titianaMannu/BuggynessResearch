{"sha":"5d44cd84f0e0fdd9895ebd1bf7343c83bc4890cb","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1ZDQ0Y2Q4NGYwZTBmZGQ5ODk1ZWJkMWJmNzM0M2M4M2JjNDg5MGNi","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-10-08T09:27:14Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-10-08T09:27:14Z"},"message":"undo bad copy\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/tags/release-4.3.0@1630040 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"80cab6f26bf2ac6382fe97f335bfd8427516aaf7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/80cab6f26bf2ac6382fe97f335bfd8427516aaf7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5d44cd84f0e0fdd9895ebd1bf7343c83bc4890cb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5d44cd84f0e0fdd9895ebd1bf7343c83bc4890cb","html_url":"https://github.com/apache/bookkeeper/commit/5d44cd84f0e0fdd9895ebd1bf7343c83bc4890cb","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5d44cd84f0e0fdd9895ebd1bf7343c83bc4890cb/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"d6c94da5751258c7868c7fd3232bafaf55090af9","url":"https://api.github.com/repos/apache/bookkeeper/commits/d6c94da5751258c7868c7fd3232bafaf55090af9","html_url":"https://github.com/apache/bookkeeper/commit/d6c94da5751258c7868c7fd3232bafaf55090af9"}],"stats":{"total":189200,"additions":0,"deletions":189200},"files":[{"sha":"43c4c7c77ca1677cb91de961db2582d79d5ca5b7","filename":"branch-4.3/CHANGES.txt","status":"removed","additions":0,"deletions":1166,"changes":1166,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/CHANGES.txt?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,1166 +0,0 @@\n-Release 4.3.0 - 2014-10-03\n-\n-  Non-backward compatible changes:\n-\n-    BUGFIXES:\n-\n-    IMPROVEMENTS:\n-\n-  Backward compatible changes:\n-\n-    BUGFIXES:\n-\n-      BOOKKEEPER-564: Better checkpoint mechanism (sijie & ivank)\n-\n-      BOOKKEEPER-596: Ledgers are gc'ed by mistake in MSLedgerManagerFactory. (sijie & ivank)\n-\n-      BOOKKEEPER-595: Crash of inprocess autorecovery daemon should not take down the bookie (ivank)\n-\n-      BOOKKEEPER-597: Add flag to output test logs to stdout (ivank)\n-\n-      BOOKKEEPER-579: TestSubAfterCloseSub was put in a wrong package (sijie via ivank)\n-\n-      BOOKKEEPER-586: Remove recursive call in delivery manager (sijie via ivank)\n-\n-      BOOKKEEPER-506: Provide better topic release algorithm (sijie via ivank)\n-\n-      BOOKKEEPER-581: Ledger recovery doesn't work correctly when recovery adds force changing ensembles. (sijie via ivank)\n-\n-      BOOKKEEPER-584: Data loss when ledger metadata is overwritten (sijie via ivank)\n-\n-      BOOKKEEPER-617: BOOKKEEPER-544 breaks hedwig-server/bin/hedwig script (ivank)\n-\n-      BOOKKEEPER-619: Bookie should not create local cookie files if zookeeper is uninitialized (ivank)\n-\n-      BOOKKEEPER-313: Bookkeeper shutdown call from Bookie thread is not shutting down server (vinay via ivank)\n-\n-      BOOKKEEPER-620: PerChannelBookieClient race during channel disconnect (ivank)\n-\n-      BOOKKEEPER-637: NoSuchEntry exception when reading an entry from a bookie should not print ERROR level message (mmerli via ivank)\n-\n-      BOOKKEEPER-641: DeathWatcher thread is unnecessarily running even after bookie shutdown (rakeshr via ivank)\n-\n-      BOOKKEEPER-636: Latest txn logs might be deleted in a race condition which is not recoverable if BK goes down before next txn log created. (vinay via ivank)\n-\n-      BOOKKEEPER-635: jenkins build should highlight which lines of the patch cause raw analysis errors (ivank via sijie)\n-\n-      BOOKKEEPER-653: Timeout option is missing in few testcases (Rakesh via ivank)\n-\n-      BOOKKEEPER-686: Bookie startup will fail if one of the configured ledgerDir is full and the same is used for replaying the journal (Rakesh via sijie)\n-\n-      BOOKKEEPER-605: Use static Logger objects everywhere for bookkeeper (sijie via ivank)\n-\n-      BOOKKEEPER-614: Generic stats interface, which multiple providers can be plugged into (sijie & ivank via ivank)\n-\n-      BOOKKEEPER-615: Twitter stats implementation of stats interface (sijie via ivank)\n-\n-      BOOKKEEPER-719: Inconsistent synchronization of org.apache.bookkeeper.stats.CodahaleMetricsProvider.metrics (sijie via ivank)\n-\n-      BOOKKEEPER-644: Provide a bookie address wrapper (sijie via fpj)\n-\n-      BOOKKEEPER-763: findbugs fails to run on jenkins (ivank)\n-\n-      BOOKKEEPER-766: Update notice.txt files to include 2014 (ivank via fpj)\n-      \n-      BOOKKEEPER-767: Allow loopback in tests (ivank via fpj)\n-\n-      BOOKKEEPER-765: bookkeeper script should fall back to java in path if JAVA_HOME is not set (ivank)\n-\n-      BOOKKEEPER-776: Flaky test BookieRecoveryTest (ivank via fpj)\n-\n-      BOOKKEEPER-790: Add JNA license in NOTICE files (sijie)\n-\n-      BOOKKEEPER-789: Update README to reflect bookkeeper modules (sijie)\n-\n-      bookkeeper-server:\n-\n-        BOOKKEEPER-567: ReadOnlyBookieTest hangs on shutdown (sijie via ivank)\n-\n-        BOOKKEEPER-549: Documentation missed for readOnlyMode support (ivank)\n-\n-        BOOKKEEPER-548: Document about periodic ledger checker configuration (ivank)\n-\n-        BOOKKEEPER-561: Findbugs report errors with openjdk (ivank via umamahesh)\n-\n-        BOOKKEEPER-554: fd leaking when move ledger index file (sijie, ivank via sijie)\n-\n-        BOOKKEEPER-568: NPE during GC with HierarchicalLedgerManager (Matteo via sijie)\n-\n-        BOOKKEEPER-569: Critical performance bug in InterleavedLedgerStorage (ivank via fpj)\n-\n-        BOOKKEEPER-559: Fix occasional failure in AuditorBookieTest (ivank via umamahesh)\n-\n-        BOOKKEEPER-599: NPE in PerChannelBookieClient (jiannan via sijie)\n-\n-\tBOOKKEEPER-577: BookieFailureTest uses sync/wait()/notify() incorrectly (ivank via fpj) \n-\t\n-\tBOOKKEEPER-626: BOOKIE_EXTRA_OPTS are added twice (vinay via fpj)\n-\n-        BOOKKEEPER-623: LedgerChecker should avoid segments of closed ledger with higher start entryId than closed entry. (vinay via sijie)\n-\n-        BOOKKEEPER-633: ConcurrentModificationException in RackawareEnsemblePlacementPolicy when a bookie is removed from available list (vinay via sijie)\n-\n-        BOOKKEEPER-563: Avoid Journal polluting page cache (Robin Dhamankar via sijie)\n-\n-        BOOKKEEPER-646: BookieShell readjournal command is throwing BufferUnderflowException (Rakesh via sijie)\n-\n-        BOOKKEEPER-652: Logger class name is wrong in LedgerCacheImpl.java (Rakesh via sijie)\n-\n-        BOOKKEEPER-642: Bookie returns incorrect exitcode, ExitCode.ZK_REG_FAIL is getting overridden (Rakesh via ivank)\n-\n-        BOOKKEEPER-663: HierarchicalLedgerManager iterator is missing some ranges and the last ledger in the range (mmerli via ivank)\n-\n-        BOOKKEEPER-604: Ledger storage can log an exception if GC happens concurrently. (sijie & ivank via ivank)\n-\n-        BOOKKEEPER-667: Client write will fail with BadMetadataVersion in case of multiple Bookie failures with AutoRecovery enabled (sijie via ivank)\n-\n-        BOOKKEEPER-668: Race between PerChannelBookieClient#channelDisconnected() and disconnect() calls can make clients hang while add/reading entries in case of multiple bookie failures (sijie & ivank via ivank)\n-\n-        BOOKKEEPER-624: Reduce logs generated by ReplicationWorker (vinay via ivank)\n-\n-        BOOKKEEPER-632: AutoRecovery should consider read only bookies (vinay via ivank)\n-\n-        BOOKKEEPER-649: Race condition in sync ZKUtils.createFullPathOptimistic() (ivank)\n-\n-        BOOKKEEPER-580: improve close logic (sijie & ivank via ivank)\n-\n-        BOOKKEEPER-446: BookKeeper.createLedger(..) should not mask the error with ZKException (sijie via ivank)\n-\n-        BOOKKEEPER-675: Log noise fixup before cutting 4.2.2 (ivank)\n-\n-        BOOKKEEPER-638: Two bookies could start at the same time to access bookie data. (sijie via ivank)\n-\n-        BOOKKEEPER-676: Make add asynchrounous in ledger recovery (aniruddha via ivank)\n-\n-        BOOKKEEPER-673: Ledger length can be inaccurate in failure case (sijie via ivank)\n-\n-        BOOKKEEPER-688: NPE exception in PerChannelBookieClient (ivank via sijie)\n-\n-        BOOKKEEPER-659: LRU page management in ledger cache. (Aniruddha, Robin Dhamankar & sijie via ivank)\n-\n-        BOOKKEEPER-700: GarbageCollectorThread exsiting with ArrayIndexOutOfBoundsException (rakeshr via ivank)\n-\n-        BOOKKEEPER-678: BookieServer shutdown hangs indefinitely at NioServerSocketChannelFactory.releaseExternalResources (rakeshr via ivank)\n-\n-        BOOKKEEPER-565: Make an option to separate storing entry log files from index files. (sijie via ivank)\n-\n-        BOOKKEEPER-711: bookkeeper-daemon.sh will not remove the pid file one successful stop (vinay via sijie)\n-\n-        BOOKKEEPER-712: bookkeeper script should use 'java' from JAVA_HOME (vinay via sijie)\n-\n-\tBOOKKEEPER-709: SlowBookieTest#testSlowBookie fails intermittently (Rakesh R via fpj)\n-\n-        BOOKKEEPER-714: Logging channel exceptions in PerChannelBookieClient (sijie)\n-\n-        BOOKKEEPER-662: Major GC should kick in immediately if remaining space reaches a warning threshold (sijie via ivank)\n-\n-        BOOKKEEPER-710: OpenLedgerNoRecovery should watch ensemble change. (sijie via ivank)\n-\n-        BOOKKEEPER-429: Provide separate read and write threads in the bookkeeper server (Aniruddha via sijie)\n-\n-        BOOKKEEPER-696: stats collection on bookkeeper client (Aniruddha, ivank via sijie)\n-\n-        BOOKKEEPER-661: Turn readonly back to writable if spaces are reclaimed. (sijie via ivank)\n-\n-        BOOKKEEPER-720: CheckpointSource.MIN#compareTo does exactly the opposite of what it should (ivank via sijie)\n-\n-        BOOKKEEPER-643: Improve concurrency of entry logger (sijie & Aniruddha via ivank)\n-\n-        BOOKKEEPER-703: Document all the settings added in BOOKKEEPER-656 (sijie)\n-\n-        BOOKKEEPER-727: Names of bookie write/read threads are backwards (ivank via fpj)\n-\n-        BOOKKEEPER-728: Bookkeeper#Builder is not public, so can't be used outside of client package (ivank via fpj)\n-\n-        BOOKKEEPER-729: Bookie shouldn't exit with 0, if exiting from deathwatcher and thread death was caused by OOM (ivank via fpj)\n-\n-        BOOKKEEPER-725: AutoRecoveryMain should exit with error code if deathwatcher finds dead thread (ivank via sijie)\n-\n-        BOOKKEEPER-726: PerChannelBookieClient should print address that it failed to connect to when it fails to correct (ivank via sijie)\n-\n-        BOOKKEEPER-724: Shade introduces RAT error (sijie via fpj)\n-\n-        BOOKKEEPER-654: Bookkeeper client operations are allowed even after its closure, bk#close() (sijie via ivank)\n-\n-        BOOKKEEPER-717: journal should look forward to group time-out entries (sijie via ivank)\n-\n-        BOOKKEEPER-715: bookie: delay dropping journal cached pages (sijie via ivank)\n-\n-        BOOKKEEPER-730: Shade pom file missing apache license header (ivank)\n-\n-        BOOKKEEPER-740: AutoRecoveryMainTest#testAutoRecoverySessionLoss is failing (Rakesh via sijie)\n-\n-        BOOKKEEPER-432: Improve performance of entry log range read per ledger entries (yixue, sijie via ivank)\n-\n-        BOOKKEEPER-742: Fix for empty ledgers losing quorum. (ivank)\n-\n-        BOOKKEEPER-743: Periodic ledger check running too often as doc doesn't match implementation. (ivank)\n-\n-        BOOKKEEPER-716: padding writes for bookie journal (sijie via ivank)\n-\n-        BOOKKEEPER-744: Run the auditor bookie check periodically (ivank)\n-\n-        BOOKKEEPER-629: Support hostname based ledger metadata to help users to change IP with existing installation (rakeshr via ivank)\n-\n-\tBOOKKEEPER-755: Incorrect number of seconds specified in a day (Joseph Redfern via fpj)\n-\t\n-\tBOOKKEEPER-750: Flake in BookieAutoRecoveryTest#testEmptyLedgerLosesQuorumEventually (ivank via fpj)\n-\n-        BOOKKEEPER-756: Use HashedwheelTimer for request timeouts for PCBC (sijie via ivank)\n-\n-        BOOKKEEPER-758: Add TryReadLastAddConfirmed API (sijie via ivank)\n-\n-        BOOKKEEPER-751: Ensure all the bookkeeper callbacks not run under ledger handle lock (sijie via ivank)\n-\n-        BOOKKEEPER-745: Fix for false reports of ledger unreplication during rolling restarts. (ivank)\n-\n-        BOOKKEEPER-746: 5 new shell commands. List ledgers, list metadata, list underreplicated, show auditor and simpletest (ivank)\n-\n-        BOOKKEEPER-774: Flaky test org.apache.bookkeeper.test.ReadOnlyBookieTest.testBookieShouldTurnWritableFromReadOnly (sijie)\n-\n-        BOOKKEEPER-704: reconnectable zookeeper client wrapper (sijie via ivank)\n-\n-        BOOKKEEPER-630: Add tag to o.a.b.net.* to indict which release of hadoop they came from, move DNS to o.a.b.net.* and indent (sijie via ivank)\n-\n-\tBOOKKEEPER-780: Findbug issue in trunk (ivank via fpj)\n-\n-        BOOKKEEPER-777: Flake in LedgerCloseTest (ivank via fpj)\n-\n-        BOOKKEEPER-718: AuditorLedgerCheckerTest is flakey (ivank via sijie)\n-\n-        BOOKKEEPER-736: Stats for AutoRecovery (sijie)\n-\n-\tBOOKKEEPER-775: Improve MultipleThreadReadTest to reduce flakiness (sijie via fpj)\n-\n-        BOOKKEEPER-783: Avoid running out of fds in MutlipleThreadReadTest (sijie via ivank)\n-\n-        BOOKKEEPER-785: Fix javadoc warnings in trunk (ivank via sijie)\n-\n-        BOOKKEEPER-784: BookKeeperCloseTest#testLedgerCheck is failing intermittently (ivank via sijie)\n-\n-        BOOKKEEPER-782: Use builder pattern for Cookie (rakeshr via sijie)\n-\n-        BOOKKEEPER-787: Modify Cookie by removing 'znodeVersion' state/field (rakeshr via ivank)\n-\n-        BOOKKEEPER-773: Provide admin tool to rename bookie identifier in Cookies (rakeshr via ivank)\n-\n-      bookkeeper-benchmark:\n-\n-        BOOKKEEPER-768: fix typo 'seconds' to milliseconds in benchmark output (jialin via sijie)\n-\n-        BOOKKEEPER-778: Flake in TestTryReadLastConfirmed (ivank via sijie)\n-\n-      bookkeeper-stats-providers:\n-\n-        BOOKKEEPER-779: jmx reporter for codahale metrics provider (ivank via sijie)\n-\n-\tBOOKKEEPER-786: Fix Findbugs Error In Codahale Stats Provider (sijie via fpj)\n-\n-      hedwig-server:\n-\n-        BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)\n-\n-        BOOKKEEPER-607: Filtered Messages Require ACK from Client Causes User Being Throttled Incorrectly Forever (sijie via ivank)\n-\n-        BOOKKEEPER-683: TestSubAfterCloseSub fails on 4.2 (jiannan via ivank)\n-\n-        BOOKKEEPER-363: Re-distributing topics among newly added hubs. (aniruddha via ivank)\n-\n-      hedwig-client:\n-\n-        BOOKKEEPER-598: Fails to compile - RESUBSCRIBE_EXCEPTION conflict (Matthew Farrellee via sijie)\n-\n-\tBOOKKEEPER-600: shouldClaim flag isn't cleared for hedwig multiplex java client (sijie via fpj)\n-\n-    IMPROVEMENTS:\n-\n-      BOOKKEEPER-608: Make SyncThread a reusable component (ivank)\n-\n-      BOOKKEEPER-555: Make BookieServer use Netty rather than a custom IO server (ivank)\n-\n-      BOOKKEEPER-526: multiple threads for delivery manager (sijie via ivank)\n-\n-      BOOKKEEPER-544: Modify hedwig server tests to allow client testcases to start/stop them as part of their tests (mridul via ivank)\n-\n-      BOOKKEEPER-312: Implementation of JMS provider (mridul via ivank)\n-\n-      BOOKKEEPER-556: BookieServerMXBean#getServerState makes no sense (ivank via sijie)\n-\n-      BOOKKEEPER-574: Extend the bookkeeper shell to get a list of available bookies (ivank via umamahesh)\n-\n-      BOOKKEEPER-576: Bookie client should use netty Decoder/Encoder (ivank via sijie)\n-\n-      BOOKKEEPER-585: Auditor logs noisily when a ledger has been deleted (ivank via sijie)\n-\n-      BOOKKEEPER-573: Script to start a bookkeeper cluster (ivank via sijie)\n-\n-      BOOKKEEPER-557: Compiler error showing up badly with jdk 7 (ivank via sijie)\n-\n-      BOOKKEEPER-583: Read from a ReadOnlyBookie fails if index fileinfo is not in ledger cache (vinay via sijie)\n-\n-      BOOKKEEPER-611: Speed up bookkeeper tests (ivank via fpj)\n-\n-      BOOKKEEPER-603: Support Boost 1.53 for Hedwig Cpp Client (jiannan via ivank)\n-\n-      BOOKKEEPER-592: allow application to recommend ledger data locality (sijie via ivank)\n-\n-      BOOKKEEPER-627: LedgerDirsMonitor is missing thread name (rakesh via fpj)\n-\n-      BOOKKEEPER-618: Better resolution of bookie address (ivank via fpj)\n-\n-      BOOKKEEPER-610: Make SyncThread use an executor (ivank via sijie)\n-\n-      BOOKKEEPER-640: Log improvement - add shutdown/exit log message for the bookie services (rakesh via sijie)\n-\n-      BOOKKEEPER-666: Naming threads of ExecutorService (rakesh via sijie)\n-\n-      BOOKKEEPER-645: Bookkeeper shell command to get a list of readonly bookies (rakesh via sijie)\n-\n-      BOOKKEEPER-658: ledger cache refactor (Robin Dhamankar via sijie)\n-\n-      BOOKKEEPER-657: Journal Improvement (Robin Dhamankar via sijie)\n-\n-      BOOKKEEPER-664: Compaction increases latency on journal writes (ivank via sijie)\n-\n-      BOOKKEEPER-602: we should have request timeouts rather than channel timeout in PerChannelBookieClient (Aniruddha, ivank via sijie)\n-\n-      BOOKKEEPER-698: Bookie client closure is not considering timeoutExecutor (rakesh via sijie)\n-\n-      BOOKKEEPER-699: Codahale metrics implementation of stats API (ivank via sijie)\n-\n-      BOOKKEEPER-701: Improve exception handling of Bookkeeper threads (rakesh via sijie)\n-\n-      BOOKKEEPER-708: Shade protobuf library to avoid incompatible versions (rakesh, ivank via sijie)\n-\n-      BOOKKEEPER-732: Add env variable ENTRY_FORMATTER_CLASS to the bkenv.sh (rakesh via sijie)\n-\n-      BOOKKEEPER-731: Missing BOOKIE_PID_DIR and BOOKIE_STOP_TIMEOUT in env variables list (rakesh via sijie)\n-\n-      BOOKKEEPER-747: Implement register/unregister LedgerMetadataListener in MSLedgerManagerFactory (fpj via sijie)\n-\n-      BOOKKEEPER-739: Test timeouts mostly ignored (sijie via fpj)\n-\n-      BOOKKEEPER-697: stats collection on bookkeeper server (sijie via fpj)\n-\n-      BOOKKEEPER-781: Fix OOM on Hedwig Tests (sijie via fpj)\n-\n-    NEW FEATURE:\n-\n-      BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)\n-\n-      BOOKKEEPER-257: Ability to list all ledgers (fpj via ivank)\n-  \n-      BOOKKEEPER-582: Make bookie and client use protobuf for requests (non-wire part)\n-      (sijie via fpj)\n-\n-Release 4.2.0 - 2013-01-14\n-\n-  Non-backward compatible changes:\n-\n-    BUGFIXES:\n-\n-    IMPROVEMENTS:\n-\n-      bookkeeper-server:\n-\n-        BOOKKEEPER-203: improve ledger manager interface to remove zookeeper dependency on metadata operations. (sijie via ivank)\n-\n-        BOOKKEEPER-303: LedgerMetadata should serialized using protobufs (ivank)\n-\n-      hedwig-client:\n-\n-        BOOKKEEPER-339: Let hedwig cpp client support returning message seq id for publish requests. (sijie via ivank)\n-\n-  Backward compatible changes:\n-\n-    BUGFIXES:\n-\n-      BOOKKEEPER-289: mvn clean doesn't remove test output files (sijie via ivank)\n-\n-      BOOKKEEPER-298: We run with preferIPv4Stack in the scripts but not in the tests (ivank)\n-\n-      BOOKKEEPER-292: Test backward compatibility automatically between versions. (ivank)\n-\n-      BOOKKEEPER-352: Should not use static ServerStats/BKStats instance in TestServerStats/TestBKStats (sijie via fpj)\n-\n-      BOOKKEEPER-338: Create Version.NEW and Version.ANY static instances of Version so that were not passing around nulls (sijie via ivank)\n-\n-      BOOKKEEPER-32: Clean up LOG.debug statements (Stu Hood via sijie)\n-\n-      BOOKKEEPER-484: Misc fixes for test scripts (ivank via fpj)\n-\n-      BOOKKEEPER-483: precommit tests only check toplevel rat file, not the one for submodules. (ivank via fpj)\n-\n-      BOOKKEEPER-533: TestSubAfterCloseSub fails strangely in tests (ivank via fpj)\n-\n-      BOOKKEEPER-480: Fix javac warnings (ivank via sijie)\n-\n-      BOOKKEEPER-481: Fix javadoc warnings (ivank via sijie)\n-\n-      bookkeeper-server:\n-\n-        BOOKKEEPER-183: Provide tools to read/check data files in bookie server (sijie via ivank)\n-\n-        BOOKKEEPER-307: BookieShell introduces 4 findbugs warnings (ivank via sijie)\n-\n-        BOOKKEEPER-322: New protobufs generates findbugs errors (ivank)\n-\n-        BOOKKEEPER-280: LedgerHandle.addEntry() should return an entryId (mmerli via ivank)\n-\n-        BOOKKEEPER-324: Flakeyness in LedgerCreateDeleteTest (ivank)\n-\n-        BOOKKEEPER-318: Spelling mistake in MultiCallback log message. (surendra via sijie)\n-\n-        BOOKKEEPER-296: It's better provide stop script for bookie (nijel via sijie)\n-\n-        BOOKKEEPER-294: Not able to start the bookkeeper before the ZK session timeout. (rakeshr via ivank)\n-\n-        BOOKKEEPER-327: System.currentTimeMillis usage in BookKeeper (uma via fpj)\n-\n-        BOOKKEEPER-349: Entry logger should close all the chennels which are there in Map, instead of closing only current channel. (umamaheswararao via sijie)\n-\n-        BOOKKEEPER-326: DeadLock during ledger recovery (rakeshr via ivank)\n-\n-        BOOKKEEPER-372: Check service name in bookie start/stop script. (nijel via ivank)\n-\n-        BOOKKEEPER-354: [BOOKKEEPER-296] [Documentation] Modify the bookkeeper start script and document the bookkeeper stop command in bookkeeperConfig.xml (Kiran BC via ivank)\n- \n-        BOOKKEEPER-378: ReplicationWorker may not get ZK watcher notification on UnderReplication ledger lock deletion. (umamaheswararao & ivank via ivank)\n-\n-        BOOKKEEPER-380: ZkLedgerUnderreplicationManager.markLedgerUnderreplicated() is adding duplicate missingReplicas while multiple bk failed for the same ledger (rakeshr via ivank)\n-\n-        BOOKKEEPER-381: ReadLastConfirmedOp's Logger class name is wrong (surendra via sijie)\n-\n-        BOOKKEEPER-382: space missed at concatenations in GarbageCollectorThread logging (Brahma via sijie)\n-\n-        BOOKKEEPER-337: Add entry fails with MetadataVersionException when last ensemble has morethan one bookie failures (rakeshr via ivank)\n-\n-        BOOKKEEPER-376: LedgerManagers should consider 'underreplication' node as a special Znode (Uma via sijie)\n-\n-        BOOKKEEPER-384: Clean up LedgerManagerFactory and LedgerManager usage in tests (rakeshr via ivank)\n-\n-        BOOKKEEPER-385: replicateLedgerFragment should throw Exceptions in error conditions (umamahesh via ivank)\n-\n-        BOOKKEEPER-386: It should not be possible to replicate a ledger fragment which is at the end of an open ledger (ivank & umamahesh via ivank)\n-\n-        BOOKKEEPER-395: HDFS dep transitively depends on a busted pom (Stu Hood via sijie)\n-\n-        BOOKKEEPER-387: BookKeeper Upgrade is not working. (surendra via sijie)\n-\n-        BOOKKEEPER-383: NPE in BookieJournalTest  (sijie via ivank)\n-\n-        BOOKKEEPER-396: Compilation issue in TestClient.java of BenchMark ( showing this in eclipse) (umamahesh via sijie)\n-\n-        BOOKKEEPER-403: ReReadMetadataCb is not executed in the thread responsible for that ledger (ivank)\n-\n-        BOOKKEEPER-405: Let's add Thread name for ReplicationWorker thread. (umamahesh via ivank)\n-\n-        BOOKKEEPER-418: Store hostname of locker in replication lock (ivank)\n-\n-        BOOKKEEPER-417: Hierarchical zk underreplication manager should clean up its hierarchy when done to allow for fast acquisition of underreplicated entries (ivank)\n-\n-        BOOKKEEPER-436: Journal#rollLog may leak file handler (umamahesh via ivank)\n-\n-        BOOKKEEPER-424: Bookie start is failing intermittently when zkclient connection delays (rakeshr via ivank)\n-\n-        BOOKKEEPER-416: LedgerChecker returns underreplicated fragments for an closed ledger with no entries (ivank)\n-\n-        BOOKKEEPER-425: Cleanup Bookie id generation (ivank via fpj)\n-\n-        BOOKKEEPER-430: Remove manual bookie registration from overview (fpj via ivank)\n-\n-        BOOKKEEPER-466: ZooKeeper test utility sets the port number as the tickTime (ivank)\n-\n-        BOOKKEEPER-460: LedgerDeleteTest checks wrong place for log file (Fangmin Lv via ivank)\n-\n-        BOOKKEEPER-477: In ReadOnlyBookieTest, we should wait for the bookie to die before asserting on it (ivank via fpj)\n-\n-        BOOKKEEPER-485: TestFencing hung (ivank via fpj)\n-\n-        BOOKKEEPER-351: asyncAddEntry should not throw an exception (Matteo Merli via sijie)\n-\n-        BOOKKEEPER-291: BKMBeanRegistry uses log4j directly (fpj via ivank)\n-\n-        BOOKKEEPER-459: Rename metastore mock implementation to InMemory implementation (jiannan via ivank)\n-\n-        BOOKKEEPER-347: Provide mechanism to detect r-o bookie by the bookie clients (Vinay via ivank)\n-\n-        BOOKKEEPER-475: BookieRecoveryTest#testSyncBookieRecoveryToRandomBookiesCheckForDupes() iterates too much (ivank via fpj)\n-\n-        BOOKKEEPER-431: Duplicate definition of COOKIES_NODE (uma via fpj)\n-\n-        BOOKKEEPER-474:  BookieReadWriteTest#testShutdown doesn't make sense (ivank via fpj)\n-\n-        BOOKKEEPER-465: CreateNewLog may overwrite lastLogId with smaller value (yixue, fpj via fpj)\n-\n-        BOOKKEEPER-498: BookieRecoveryTest.tearDown NPE (fpj)\n-\n-        BOOKKEEPER-497: GcLedgersTest has a potential race (ivank via sijie)\n-\n-        BOOKKEEPER-493: moveLedgerIndexFile might have chance pickup same directory (sijie via ivank)\n-\n-        BOOKKEEPER-365: Ledger will never recover if one of the quorum bookie is down forever and others dont have entry (sijie via ivank)\n-\n-        BOOKKEEPER-336: bookie readEntries is taking more time if the ensemble has failed bookie(s) (ivank)\n-\n-        BOOKKEEPER-512: BookieZkExpireTest fails periodically (ivank via sijie)\n-\n-        BOOKKEEPER-509: TestBookKeeperPersistenceManager failed on latest trunk (sijie via ivank)\n-\n-        BOOKKEEPER-496: Ensure that the auditor and replication worker will shutdown if they lose their ZK session (ivank)\n-\n-        BOOKKEEPER-500: Fencing doesn't work when restarting bookies. (sijie via ivank)\n-\n-        BOOKKEEPER-520: BookieFailureTest hangs on precommit build (ivank via sijie)\n-\n-        BOOKKEEPER-447: Bookie can fail to recover if index pages flushed before ledger flush acknowledged (ivank via sijie)\n-\n-        BOOKKEEPER-520: BookieFailureTest hangs on precommit build (sijie via fpj, jira reopened)\n-\n-        BOOKKEEPER-514: TestDeadLock hanging sometimes (ivank, sijie via fpj)\n-\n-        BOOKKEEPER-524: Bookie journal filesystem gets full after SyncThread is terminated with exception (Matteo, fpj via sijie)\n-\n-        BOOKKEEPER-355: Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during recovery add (ivank)\n-\n-        BOOKKEEPER-534: Flakeyness in AuditorBookieTest (umamahesh via ivank)\n-\n-        BOOKKEEPER-542: Remove trailing spaces in IndexCorruptionTest (fpj via ivank)\n-\n-        BOOKKEEPER-530: data might be lost during compaction. (ivank)\n-\n-        BOOKKEEPER-538: Race condition in BookKeeper#close (ivank via fpj)\n-\n-        BOOKKEEPER-408: BookieReadWriteTest will enter the endless loop and will not leave out (ivank)\n-\n-        BOOKKEEPER-504: Fix findbugs warning in PendingReadOp (fpj via ivank)\n-\n-      hedwig-protocol:\n-\n-        BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)\n-\n-        BOOKKEEPER-468: Remove <echo> from protobuf generation in hedwig (ivank)\n-\n-      hedwig-client:\n-\n-        BOOKKEEPER-274: Hedwig cpp client library should not link to cppunit which is just used for test. (sijie via ivank)\n-\n-        BOOKKEEPER-320: Let hedwig cpp client could publish messages using Message object instead of string. (jiannan via ivank)\n-\n-        BOOKKEEPER-371: NPE in hedwig hub client causes hedwig hub to shut down. (Aniruddha via sijie)\n-\n-        BOOKKEEPER-392: Racey ConcurrentMap usage in java hedwig-client (Stu Hood via sijie)\n-\n-        BOOKKEEPER-427: TestConcurrentTopicAcquisition hangs every so often (ivank)\n-\n-        BOOKKEEPER-434: [Hedwig CPP Client] Delay resolving default host until necessary. (sijie via ivank)\n-\n-        BOOKKEEPER-452: Rename ClientConfiguration multiplexing_enabled to subscription_connection_sharing_enabled (sijie via ivank)\n-\n-        BOOKKEEPER-454: hedwig c++ tester script assumes sh is bash (ivank)\n-\n-        BOOKKEEPER-470: Possible infinite loop in simple.SubscribeReconnectCallback (sijie via ivank)\n-\n-        BOOKKEEPER-55: SubscribeReconnectRetryTask might retry subscription endlessly when another subscription is already successfully created previously (sijie via ivank)\n-\n-        BOOKKEEPER-513: TestMessageFilter fails periodically (ivank)\n-\n-      hedwig-server:\n-\n-        BOOKKEEPER-302: No more messages delivered when hub server scans messages over two ledgers. (sijie via ivank)\n-\n-        BOOKKEEPER-330: System.currentTimeMillis usage in Hedwig (uma via sijie)\n-\n-        BOOKKEEPER-343: Failed to register hedwig JMX beans in test cases (sijie via ivank)\n-\n-        BOOKKEEPER-259: Create a topic manager using versioned write for leader election (sijie via ivank)\n-\n-        BOOKKEEPER-191: Hub server should change ledger to write, so consumed messages have chance to be garbage collected. (sijie via ivank)\n-\n-        BOOKKEEPER-439: No more messages delivered after deleted consumed ledgers. (sijie via ivank)\n-\n-        BOOKKEEPER-440: Make Write/Delete SubscriptionData Restricted to Version (Fangmin Lv via ivank)\n-\n-        BOOKKEEPER-482: Precommit is reporting findbugs errors in trunk (ivank via sijie)\n-\n-        BOOKKEEPER-442: Failed to deliver messages due to inconsistency between SubscriptionState and LedgerRanges. (jiannan via ivank)\n-\n-        BOOKKEEPER-461: Delivery throughput degrades when there are lots of publishers w/ high traffic. (sijie via ivank)\n-\n-\tBOOKKEEPER-458:  Annoy BKReadException error when changing ledger. (jiannan via fpj)\n-\n-        BOOKKEEPER-507: Race condition happens if closeSubscription and subscribe happened at the same time (in multiplexed client). (sijie via ivank)\n-\n-\tBOOKKEEPER-532: AbstractSubscriptionManager#AcquireOp read subscriptions every time even it already owned the topic. (sijie via fpj)\n-\n-        BOOKKEEPER-531: Cache thread should wait until old entries are collected (sijie via ivank)\n-\n-        BOOKKEEPER-529: stopServingSubscriber in delivery manager should remove stub callbacks in ReadAheadCache (sijie via ivank)\n-\n-        BOOKKEEPER-543: Read zk host list in a wrong way in hedwig server (Fangmin via sijie)\n-\n-        BOOKKEEPER-540: #stopServingSubscriber when channel is disconnected. (Fangmin via sijie)\n-\n-        BOOKKEEPER-539: ClientNotSubscribedException & doesn't receive enough messages in TestThrottlingDelivery#testServerSideThrottle (sijie)\n-\n-        BOOKKEEPER-503: The test case of TestThrottlingDelivery#testServerSideThrottle failed sometimes (jiannan & sijie via ivank)\n-\n-    IMPROVEMENTS:\n-\n-      BOOKKEEPER-467: Allocate ports for testing dynamically (ivank)\n-\n-      BOOKKEEPER-471: Add scripts for preCommit testing (ivank)\n-\n-      BOOKKEEPER-476: Log to file during tests (ivank via fpj)\n-\n-      BOOKKEEPER-491: Hedwig doc for configuration (fpj, sijie via fpj)\n-\n-      BOOKKEEPER-495: Revise BK config doc (fpj, ivank via fpj)\n-\n-      BOOKKEEPER-523: Every test should have a timeout (ivank, sijie via fpj)\n-\n-      BOOKKEEPER-541: Add guava to notice file (ivank via fpj)\n-\n-      bookkeeper-server:\n-\n-        BOOKKEEPER-328: Bookie DeathWatcher is missing thread name (Rakesh via sijie)\n-\n-        BOOKKEEPER-2: bookkeeper does not put enough meta-data in to do recovery properly (ivank via sijie)\n-\n-        BOOKKEEPER-317: Exceptions for replication (ivank via sijie)\n-\n-        BOOKKEEPER-246: Recording of underreplication of ledger entries (ivank)\n-\n-        BOOKKEEPER-247: Detection of under replication (ivank)\n-\n-        BOOKKEEPER-299: Provide LedgerFragmentReplicator which should replicate the fragments found from LedgerChecker (umamahesh via ivank)\n-\n-        BOOKKEEPER-248: Rereplicating of under replicated data (umamahesh via ivank)\n-\n-        BOOKKEEPER-304: Prepare bookie vs ledgers cache and will be used by the Auditor (rakeshr via ivank)\n-\n-        BOOKKEEPER-272: Provide automatic mechanism to know bookie failures (rakeshr via ivank)\n-\n-        BOOKKEEPER-300: Create Bookie format command (Vinay via sijie)\n-\n-        BOOKKEEPER-208: Separate write quorum from ack quorum (ivank)\n-\n-        BOOKKEEPER-325: Delay the replication of a ledger if RW found that its last fragment is in underReplication. (umamahesh via ivank)\n-\n-        BOOKKEEPER-388: Document bookie format command (kiran_bc via ivank)\n-\n-        BOOKKEEPER-278: Ability to disable auto recovery temporarily (rakeshr via ivank)\n-\n-        BOOKKEEPER-319: Manage auditing and replication processes (Vinay via ivank)\n-\n-        BOOKKEEPER-315: Ledger entries should be replicated sequentially instead of parallel. (umamahesh via ivank)\n-\n-        BOOKKEEPER-345: Detect IOExceptions on entrylogger and bookie should consider next ledger dir(if any) (Vinay via ivank)\n-\n-        BOOKKEEPER-346: Detect IOExceptions in LedgerCache and bookie should look at next ledger dir(if any) (Vinay via ivank)\n-\n-        BOOKKEEPER-444: Refactor pending read op to make speculative reads possible (ivank)\n-\n-        BOOKKEEPER-204: Provide a MetaStore interface, and a mock implementation. (Jiannan Wang via ivank)\n-\n-\tBOOKKEEPER-469: Remove System.out.println from TestLedgerManager (ivank via fpj)\n-\n-        BOOKKEEPER-205: implement a MetaStore based ledger manager for bookkeeper client. (jiannan via ivank)\n-\n-        BOOKKEEPER-426: Make auditor Vote znode store a protobuf containing the host that voted (ivank)\n-\n-\tBOOKKEEPER-428: Expose command options in bookie scripts to disable/enable auto recovery temporarily (rakesh,ivank via fpj)\n-\n-        BOOKKEEPER-511: BookieShell is very noisy (ivank via sijie)\n-\n-        BOOKKEEPER-375: Document about Auto replication service in BK (umamahesh via ivank)\n-\n-        BOOKKEEPER-490: add documentation for MetaStore interface (sijie, ivank via sijie)\n-\n-        BOOKKEEPER-463: Refactor garbage collection code for ease to plugin different GC algorithm. (Fangmin, ivank, fpj via sijie)\n-\n-        BOOKKEEPER-409: Integration Test - Perform bookie rereplication cycle by Auditor-RW processes (rakeshr via ivank)\n-\n-        BOOKKEEPER-293: Periodic checking of ledger replication status (ivank)\n-\n-        BOOKKEEPER-472: Provide an option to start Autorecovery along with Bookie Servers (umamahesh via ivank)\n-\n-        BOOKKEEPER-341: add documentation for bookkeeper ledger manager interface. (sijie via ivank)\n-\n-      hedwig-server:\n-\n-        BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)\n-\n-        BOOKKEEPER-329: provide stop scripts for hub server (sijie via ivank)\n-\n-        BOOKKEEPER-331: Let hedwig support returning message seq id for publish requests. (Mridul via sijie)\n-\n-        BOOKKEEPER-340: Test backward compatibility for hedwig between different versions. (sijie via ivank)\n-\n-        BOOKKEEPER-283: Improve Hedwig Console to use Hedwig Metadata Manager. (sijie via ivank)\n-\n-        BOOKKEEPER-332: Add SubscriptionPreferences to record all preferences for a subscription (sijie via ivank)\n-\n-        BOOKKEEPER-333: server-side message filter (sijie via ivank)\n-\n-        BOOKKEEPER-252: Hedwig: provide a subscription mode to kill other subscription channel when hedwig client is used as a proxy-style server. (sijie via ivank)\n-\n-        BOOKKEEPER-397: Make the hedwig client in RegionManager configurable. (Aniruddha via sijie)\n-\n-        BOOKKEEPER-367: Server-Side Message Delivery Flow Control (sijie via ivank)\n-\n-        BOOKKEEPER-415: Rename DeliveryThrottle to MessageWindowSize (ivank via sijie)\n-\n-\tBOOKKEEPER-422: Simplify AbstractSubscriptionManager (stu via fpj)\n-\n-        BOOKKEEPER-435: Create SubscriptionChannelManager to manage all subscription channel (sijie via ivank)\n-\n-        BOOKKEEPER-411: Add CloseSubscription Request for multiplexing support (sijie via ivank)\n-\n-        BOOKKEEPER-441: InMemorySubscriptionManager should back up top2sub2seq before change it (Yixue via ivank)\n-\n-\tBOOKKEEPER-479: Fix apache-rat issues in tree (ivank via fpj)\n-\n-        BOOKKEEPER-457: Create a format command for Hedwig to cleanup its metadata. (sijie via ivank)\n-\n-        BOOKKEEPER-487: Add existed hub server settings to configuration template file (sijie via ivank)\n-\n-        BOOKKEEPER-389: add documentation for message filter. (sijie via ivank)\n-\n-\tBOOKKEEPER-399: Let hub server configure write quorum from ack quorum. (sijie via fpj)\n-\n-        BOOKKEEPER-342: add documentation for hedwig metadata manager interface. (sijie, ivank via sijie)\n-\n-        BOOKKEEPER-522: TestHedwigHub is failing silently on Jenkins (ivank via sijie)\n-\n-        BOOKKEEPER-262: Implement a meta store based hedwig metadata manager. (jiannan via ivank)\n-\n-        BOOKKEEPER-310: Changes in hedwig server to support JMS spec (ivank via sijie)\n-\n-      hedwig-client:\n-\n-        BOOKKEEPER-306: Change C++ client to use gtest for testing (ivank via sijie)\n-\n-        BOOKKEEPER-334: client-side message filter for java client. (sijie via ivank)\n-\n-        BOOKKEEPER-335: client-side message filter for cpp client. (sijie via ivank)\n-\n-        BOOKKEEPER-364: re-factor hedwig java client to support both one-subscription-per-channel and multiplex-subscriptions-per-channel. (sijie via ivank)\n-\n-        BOOKKEEPER-143: Add SSL support for hedwig cpp client (sijie via ivank)\n-\n-        BOOKKEEPER-413: Hedwig C++ client: Rename RUN_AS_SSL_MODE to SSL_ENABLED (ivank via sijie)\n-\n-        BOOKKEEPER-369: re-factor hedwig cpp client to provide better interface to support both one-subscription-per-channel and multiple-subscriptions-per-channel. (sijie via ivank)\n-\n-        BOOKKEEPER-368: Implementing multiplexing java client. (sijie via ivank)\n-\n-        BOOKKEEPER-370: implement multiplexing cpp client. (sijie via ivank)\n-\n-        BOOKKEEPER-453: Extract commonality from MultiplexSubscribeResponseHandler and SimpleSubscribeResponseHandler and put into an abstract class  (sijie via ivank)\n-\n-        BOOKKEEPER-404: Deprecate non-SubscriptionOptions Subscriber Apis (ivank via sijie)\n-\n-Release 4.1.0 - 2012-06-07\n-\n-  Non-backward compatible changes:\n-\n-    BUGFIXES:\n-\n-    IMPROVEMENTS:\n-\n-  Backward compatible changes:\n-\n-    BUGFIXES:\n-\n-      BOOKKEEPER-145: Put notice and license file for distributed binaries in SVN (ivank)\n-\n-      BOOKKEEPER-254: Bump zookeeper version in poms (ivank)\n-\n-      BOOKKEEPER-72: Fix warnings issued by FindBugs (ivank)\n-\n-      BOOKKEEPER-238: Add log4j.properties in conf/ for bin packages (ivank)\n-\n-      bookkeeper-server/\n-\n-        BOOKKEEPER-142: Parsing last log id is wrong, which may make entry log files overwritten (Sijie Gou via ivank)\n-\n-        BOOKKEEPER-141: Run extracting ledger id from entry log files in GC thread to speed up bookie restart (Sijie Gou via ivank)\n-\n-        BOOKKEEPER-148: Jenkins build is failing (ivank via fpj)\n-\n-        BOOKKEEPER-40: BookieClientTest fails intermittantly (fpj via ivank)\n-\n-\tBOOKKEEPER-150: Entry is lost when recovering a ledger with not enough bookies. (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-153: Ledger can't be opened or closed due to zero-length metadata (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-23: Timeout requests (ivank)\n-\n-        BOOKKEEPER-161: PerChannelBookieClient tries to reuse HashedWheelTimer, throws Exception (ivank)\n-\n-        BOOKKEEPER-167: PerChannelBookieClient doesn't use ClientConfiguration (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-156: BookieJournalRollingTest failing (Sijie Guo via ivank)\n-\n-\tBOOKKEEPER-162: LedgerHandle.readLastConfirmed does not work (fpj)\n-\n-        BOOKKEEPER-152: Can't recover a ledger whose current ensemble contain failed bookie. (ivank)\n-\n-        BOOKKEEPER-171: ServerConfiguration can't use more than one directory for ledgers. (ivank via sijie)\n-\t\n-\tBOOKKEEPER-170: Bookie constructor starts a number of threads. (ivank via fpj)\n-\n-        BOOKKEEPER-169: bookie hangs on reading header when encountering partial header index file (sijie via ivank)\n-\n-        BOOKKEEPER-174: Bookie can't start when replaying entries whose ledger were deleted and garbage collected. (sijie via ivank)\n-\n-        BOOKKEEPER-177: Index file is lost or some index pages aren't flushed. (sijie via ivank)\n-\n-        BOOKKEEPER-113: NPE In BookKeeper test (fpj via ivank)\n-\n-\tBOOKKEEPER-176: HierarchicalBookieFailureTest Hung (ivank via fpj)\n-\n-        BOOKKEEPER-180: bookie server doesn't quit when running out of disk space (sijie via ivank)\n-\n-        BOOKKEEPER-185: Remove bookkeeper-server dependency on hadoop-common (ivank)\n-\n-        BOOKKEEPER-184: CompactionTest failing on Jenkins (sijie via ivank)\n-\n-        BOOKKEEPER-182: Entry log file is overwritten when fail to read lastLogId. (sijie via ivank)\n-\n-        BOOKKEEPER-186: Bookkeeper throttling - permits is not released when read has failed from all replicas (Rakesh R via sijie)\n-\n-        BOOKKEEPER-189: AbstractZkLedgerManager doesn't disregard cookies (ivank via sijie)\n-\n-        BOOKKEEPER-195: HierarchicalLedgerManager doesn't consider idgen as a \"specialNode\" (ivank)\n-\n-        BOOKKEEPER-190: Add entries would fail when number of open ledgers reaches more than openFileLimit. (sijie via ivank)\n-\n-        BOOKKEEPER-194: Get correct latency for addEntry operations for JMX. (sijie via ivank)\n-\n-        BOOKKEEPER-166: Bookie will not recover its journal if the length prefix of an entry is truncated (ivank)\n-\n-        BOOKKEEPER-193: Ledger is garbage collected by mistake. (sijie, ivank via sijie)\n-\n-        BOOKKEEPER-198: replaying entries of deleted ledgers would exhaust ledger cache. (sijie)\n-\n-        BOOKKEEPER-112: Bookie Recovery on an open ledger will cause LedgerHandle#close on that ledger to fail (sijie)\n-\n-        BOOKKEEPER-135: Fencing does not check the ledger masterPasswd (ivank)\n-\n-\tBOOKKEEPER-212: Bookie stops responding when creating and deleting many ledgers (sijie via fpj)\n-\n-        BOOKKEEPER-211: Bookie fails to to start (sijie)\n-\n-\tBOOKKEEPER-200: Fix format and comments (fpj)\n-\n-        BOOKKEEPER-216: Bookie doesn't exit with right exit code (sijie via ivank)\n-\n-        BOOKKEEPER-196: Define interface between bookie and ledger storage (ivank)\n-\n-        BOOKKEEPER-213: PerChannelBookieClient calls the wrong errorOut function when encountering an exception (Aniruddha via sijie)\n-\n-        BOOKKEEPER-231: ZKUtil.killServer not closing the FileTxnSnapLog from ZK. (Uma Maheswara Rao G via sijie)\n-\n-        BOOKKEEPER-232: AsyncBK tests failing (umamaheswararao via ivank)\n-\n-\tBOOKKEEPER-229: Deleted entry log files would be garbage collected again and again. (sijie via fpj)\n-\n-        BOOKKEEPER-242: Bookkeeper not able to connect other zookeeper when shutdown the zookeeper server where the BK has connected. (sijie & rakeshr via ivank)\n-\n-        BOOKKEEPER-234: EntryLogger will throw NPE, if any dir does not exist or IO Errors. (umamaheswararao via ivank)\n-\n-\tBOOKKEEPER-235: Bad syncing in entrylogger degrades performance for many concurrent ledgers (ivank via fpj)\n-\n-        BOOKKEEPER-224: Fix findbugs in bookkeeper-server component (ivank)\n-\n-        BOOKKEEPER-251: Noise error message printed when scanning entry log files those have been garbage collected. (sijie via ivank)\n-\n-        BOOKKEEPER-266: Review versioning documentation (ivank)\n-\n-        BOOKKEEPER-258: CompactionTest failed (ivank via sijie)\n-\n-        BOOKKEEPER-273: LedgerHandle.deleteLedger() should be idempotent (Matteo Merli via ivank)\n-\n-        BOOKKEEPER-281: BKClient is failing when zkclient connection delays (ivank via sijie)\n-\n-        BOOKKEEPER-279: LocalBookKeeper is failing intermittently due to zkclient connection establishment delay (Rakesh R via sijie)\n-\n-        BOOKKEEPER-286: Compilation warning (ivank via sijie)\n-\n-        BOOKKEEPER-287: NoSuchElementException in LedgerCacheImpl (sijie)\n-\n-        BOOKKEEPER-288: NOTICE files don't have the correct year (ivank via sijie)\n-\n-      hedwig-client/\n-\n-        BOOKKEEPER-217: NPE in hedwig client when enable DEBUG (sijie via ivank)\n-\n-      hedwig-server/\n-      \n-        BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)\n-\n-        BOOKKEEPER-133: Hub server should update subscription state to zookeeper when losing topic or shutting down (Sijie Gou via ivank)\n-\n-        BOOKKEEPER-74: Bookkeeper Persistence Manager should give up topic on error (sijie via ivank)\n-\n-        BOOKKEEPER-163: Prevent incorrect NoSuchLedgerException for readLastConfirmed. (ivank via sijie)\n-\n-        BOOKKEEPER-197: HedwigConsole uses the same file to load bookkeeper client config and hub server config (sijie)\n-\n-        BOOKKEEPER-56: Race condition of message handler in connection recovery in Hedwig client (sijie & Gavin Li via ivank)\n-\n-        BOOKKEEPER-215: Deadlock occurs under high load (sijie via ivank)\n-\n-        BOOKKEEPER-245: Intermittent failures in PersistanceManager tests (ivank)\n-\n-        BOOKKEEPER-209: Typo in ServerConfiguration for READAHEAD_ENABLED (ivank)\n-\n-        BOOKKEEPER-146: TestConcurrentTopicAcquisition sometimes hangs (ivank)\n-\n-        BOOKKEEPER-285: TestZkSubscriptionManager quits due to NPE, so other tests are not run in hedwig server. (sijie)\n-\n-      bookkeeper-benchmark/\n-\t\n-\tBOOKKEEPER-207: BenchBookie doesn't run correctly (ivank via fpj)\n-\n-        BOOKKEEPER-228: Fix the bugs in BK benchmark (umamaheswararao via ivank)\n-\n-    IMPROVEMENTS:\n-\n-\tBOOKKEEPER-265: Review JMX documentation (sijie via fpj)\n-\n-      bookkeeper-server/\n-\n-        BOOKKEEPER-95: extends zookeeper JMX to monitor and manage bookie server (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-98: collect add/read statistics on bookie server (Sijie Guo via ivank)\n-\n-\tBOOKKEEPER-157:\tFor small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n-\n-        BOOKKEEPER-165: Add versioning support for journal files (ivank)\n-\n-        BOOKKEEPER-137: Do not create Ledger index files until absolutely necessary. (ivank)\n-\n-\tBOOKKEEPER-172: Upgrade framework for filesystem layouts (ivank via fpj)\n-\n-        BOOKKEEPER-178: Delay ledger directory creation until the ledger index file was created (sijie via ivank)\n-\n-        BOOKKEEPER-160: bookie server needs to do compaction over entry log files to reclaim disk space (sijie via ivank)\n-\n-        BOOKKEEPER-187: Create well defined interface for LedgerCache (ivank)\n-\n-        BOOKKEEPER-175: Bookie code is very coupled (ivank)\n-\n-        BOOKKEEPER-188: Garbage collection code is in the wrong place (ivank via sijie)\n-\n-        BOOKKEEPER-218: Provide journal manager to manage journal related operations (sijie)\n-\n-\tBOOKKEEPER-173: Uncontrolled number of threads in bookkeeper (sijie via fpj)\n-\n-\tBOOKKEEPER-241: Add documentation for bookie entry log compaction (sijie via fpj)\n-\n-\tBOOKKEEPER-263: ZK ledgers root path is hard coded (Aniruddha via sijie)\n-\n-\tBOOKKEEPER-260: Define constant for -1 (invalid entry id) (ivank via fpj)\n-\n-\tBOOKKEEPER-270: Review documentation on bookie cookie (ivank via fpj)\n-\n-      hedwig-server/\n-\n-        BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-168: Message bounding on subscriptions (ivank)\n-\n-        BOOKKEEPER-96: extends zookeeper JMX to monitor and manage hedwig server (sijie via ivank)\n-\n-        BOOKKEEPER-97: collect pub/sub/consume statistics on hub server (sijie via ivank)\n-\n-\tBOOKKEEPER-269: Review documentation for hedwig console client (sijie via fpj)\n-\n-      hedwig-client/\n-\n-\tBOOKKEEPER-271: Review documentation for message bounding (ivank via fpj)\n-\n-      bookkeeper-benchmark/\n-\tBOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n-\n-\tBOOKKEEPER-236: Benchmarking improvements from latest round of benchmarking (ivank via fpj)\n-\n-Release 4.0.0 - 2011-11-30\n-\n-  Non-backward compatible changes:\n-\n-    BUGFIXES:\n-\n-      BOOKKEEPER-89: Bookkeeper API changes for initial Bookkeeper release (ivank)\n-\n-      BOOKKEEPER-108: add configuration support for BK (Sijie via ivank)\n-\n-      BOOKKEEPER-90: Hedwig API changes for initial Bookkeeper release (ivank via fpj)\n-\n-  Backward compatible changes:\n-\n-    BUGFIXES:\n-\n-      BOOKKEEPER-124: build has RAT failures (ivank)\n-\n-      BOOKKEEPER-121: Review Hedwig client documentation (breed via ivank)\n-\n-      BOOKKEEPER-127: Make poms use official zookeeper 3.4.0 (ivank)\n-\n-      BOOKKEEPER-120: Review BookKeeper client documentation (ivank)\n- \n-      BOOKKEEPER-122: Review BookKeeper server documentation (fpj & ivank)\n- \n-      BOOKKEEPER-66: use IPv4 for builds (mmorel via ivank)\n-\n-      BOOKKEEPER-132: Sign artifacts before deploying to maven (ivank)\n-\n-      BOOKKEEPER-131: Fix zookeeper test dependency (ivank)\n-\n-      BOOKKEEPER-134: Delete superfluous lib directories (ivank)\n-\n-      BOOKKEEPER-138: NOTICE.txt is invalid (ivank)\n-\n-      BOOKKEEPER-139: Binary packages do not carry NOTICE.txt (ivank)\n-\n-      bookkeeper-server/\n-\n-        BOOKKEEPER-1: Static variable makes tests fail (fpj via ivank)\n-\n-        BOOKKEEPER-19: BookKeeper doesn't support more than 2Gig of memory (ivan via fpj)\n-\n-        BOOKEEPER-22: Exception in LedgerCache causes addEntry request to fail (fpj via fpj)\n-\n-        BOOKEEPER-5: Issue with Netty in BookKeeper (fpj and ivank via fpj)\n-\n-        BOOKKEEPER-30: Test are too noisy (ivank via fpj)\n-\n-        BOOKKEEPER-11: Read from open ledger (fpj via ivank)\n-\n-        BOOKKEEPER-27: mvn site failed with unresolved dependencies (ivank via fpj)\n-  \n-        BOOKKEEPER-29: BookieRecoveryTest fails intermittently (fpj via ivank)\n-\n-        BOOKKEEPER-33: Add length and offset parameter to addEntry (ivank via fpj)\n-\n-        BOOKKEEPER-29: BookieRecoveryTest fails intermittently (ivank, fpj via fpj)\n-\n-        BOOKKEEPER-38: Bookie Server doesn't exit when its zookeeper session is expired. So the process is hang there. (Sijie Guo via breed)\n-\n-        BOOKKEEPER-58: Changes introduced in BK-38 cause BookieClientTest to hang indefinitely. (ivank)\n-\n-        BOOKKEEPER-18: maven build is unstable (mmorel, ivank via ivank)\n-\n-        BOOKKEEPER-57: NullPointException at bookie.zk@EntryLogger (xulei via ivank)\n-\n-        BOOKKEEPER-59: Race condition in netty code allocates and orphans resources (BK-5 revisited) (ivank via fpj)\n-  \n-        BOOKKEEPER-68: Conditional setData (fpj via ivank)\n-\n-        BOOKKEEPER-86: bookkeeper-benchmark fails to compile after BOOKKEEPER-68 (ivank via breed)\n-\n-        BOOKKEEPER-61: BufferedChannel read endless when the remaining bytes of file is less than the capacity of read buffer (Sijie Guo via breed)\n-\n-        BOOKKEEPER-84: Add versioning for ZK metadata (ivank via breed)\n-\n-        BOOKKEEPER-92: using wrong context object in readLastConfirmedComplete callback (Sijie Guo via ivank)\n- \n-        BOOKKEEPER-94: Double callbacks in readLastConfirmedOp which fails readLastConfirmed operation even received enough valid responses. (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-83: Added versioning and flags to the bookie protocol (ivank)\n-\n-        BOOKKEEPER-93: bookkeeper doesn't work correctly on OpenLedgerNoRecovery (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-103: ledgerId and entryId is parsed wrong when addEntry (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-50: NullPointException at LedgerDescriptor#cmpMasterKey (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-82: support journal rolling (Sijie Guo via fpj)\n-\n-        BOOKKEEPER-106: recoveryBookieData can select a recovery bookie which is already in the ledgers ensemble (ivank via fpj)\n-\n-        BOOKKEEPER-101: Add Fencing to Bookkeeper (ivank)\n-\n-        BOOKKEEPER-104: Add versioning between bookie and its filesystem layout (ivank)\n-\n-        BOOKKEEPER-81: disk space of garbage collected entry logger files isn't reclaimed util process quit (Sijie Guo via fpj)\n-\n-        BOOKKEEPER-91: Bookkeeper and hedwig clients should not use log4j directly (ivank via fpj)\n-\n-        BOOKKEEPER-115: LocalBookKeeper fails after BOOKKEEPER-108 (ivank)\n-\n-        BOOKKEEPER-114: add a shutdown hook to shut down bookie server safely. (Sijie via ivank)\n-\n-        BOOKKEEPER-39: Bookie server failed to restart because of too many ledgers (more than ~50,000 ledgers) (Sijie via ivank)\n-\n-        BOOKKEEPER-125: log4j still used in some places (ivank)\n-\n-        BOOKKEEPER-62: Bookie can not start when encountering corrupted records (breed via ivank)\n-\n-        BOOKKEEPER-111: Document bookie recovery feature (ivank)\n-\n-        BOOKKEEPER-129: ZK_TIMEOUT typo in client/server configuration (Sijie via ivank)\n-\n-        BOOKKEEPER-22: Exception in LedgerCache causes addEntry request to fail (fpj via fpj)\n-\n-        BOOKKEEPER-5: Issue with Netty in BookKeeper (fpj and ivank via fpj)\n-\n-      hedwig-server/\n-\n-        BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)\n-  \n-        BOOKKEEPER-51: NullPointException at FIFODeliveryManager#deliveryPtrs (xulei via ivank)\n-\n-        BOOKKEEPER-63: Hedwig PubSubServer must wait for its Zookeeper client to be connected upon startup (mmorel via ivank)\n-\n-        BOOKKEEPER-100: Some hedwig tests have build errors (dferro via ivank)\n-\n-        BOOKKEEPER-69: ServerRedirectLoopException when a machine (hosts bookie server & hub server) reboot, which is caused by race condition of topic manager (Sijie, ivank via ivank)\n-\n-      hedwig-client/\n- \n-        BOOKKEEPER-52: Message sequence confuse due to the subscribeMsgQueue@SubscribeResponseHandler (xulei via ivank)\n-\n-        BOOKKEEPER-88: derby doesn't like - in the topic names (breed via ivank)\n-\n-        BOOKKEEPER-71: hedwig c++ client does not build . (ivank)\n-\n-        BOOKKEEPER-107: memory leak in HostAddress of hedwig c++ client (Sijie Guo via ivank)\n- \n-        BOOKKEEPER-80: subscription msg queue race condition in hedwig c++ client (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-87: TestHedwigHub exhausts direct buffer memory with netty 3.2.4.Final (ivank via fpj)  \n-\n-        BOOKKEEPER-79: randomly startDelivery/stopDelivery will core dump in c++ hedwig client (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-118: Hedwig client doesn't kill and remove old subscription channel after redirection. (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-117: Support multi threads in hedwig cpp client to leverage multi-core hardware (Sijie Guo via ivank)\n-\n-        BOOKKEEPER-53: race condition of outstandingMsgSet@SubscribeResponseHandler (fpj via breed)\n-\n-    IMPROVEMENTS:\n-\n-      BOOKKEEPER-28: Create useful startup scripts for bookkeeper and hedwig (ivank)\n-\n-      BOOKKEEPER-26: Indentation is all messed up in the BookKeeper code (ivank via fpj)\n-\n-      BOOKKEEPER-41: Generation of packages for distribution (ivank via fpj)\n-\n-      BOOKKEEPER-65: fix dependencies on incompatible versions of netty (mmorel via ivank)\n-\n-      BOOKKEEPER-102: Make bookkeeper use ZK from temporary repo (ivank)\n-\n-      BOOKKEEPER-128: pom and script modifications required for generating release packages (ivank)\n-\n-      hedwig-client/\n-\n-        BOOKKEEPER-44: Reuse publish channel to default server to avoid too many connect requests to default server when lots of producers came in same time (Sijie Guo via breed)\n-\n-        BOOKKEEPER-109: Add documentation to describe how bookies flushes data (Sijie Guo via fpj)\n-\n-        BOOKKEEPER-119: Keys in configuration have inconsistent style (ivank via fpj)\n-"},{"sha":"d645695673349e3947e8e5ae42332d0ac3164cd7","filename":"branch-4.3/LICENSE","status":"removed","additions":0,"deletions":202,"changes":202,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/LICENSE","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/LICENSE","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/LICENSE?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,202 +0,0 @@\n-\n-                                 Apache License\n-                           Version 2.0, January 2004\n-                        http://www.apache.org/licenses/\n-\n-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n-\n-   1. Definitions.\n-\n-      \"License\" shall mean the terms and conditions for use, reproduction,\n-      and distribution as defined by Sections 1 through 9 of this document.\n-\n-      \"Licensor\" shall mean the copyright owner or entity authorized by\n-      the copyright owner that is granting the License.\n-\n-      \"Legal Entity\" shall mean the union of the acting entity and all\n-      other entities that control, are controlled by, or are under common\n-      control with that entity. For the purposes of this definition,\n-      \"control\" means (i) the power, direct or indirect, to cause the\n-      direction or management of such entity, whether by contract or\n-      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n-      outstanding shares, or (iii) beneficial ownership of such entity.\n-\n-      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n-      exercising permissions granted by this License.\n-\n-      \"Source\" form shall mean the preferred form for making modifications,\n-      including but not limited to software source code, documentation\n-      source, and configuration files.\n-\n-      \"Object\" form shall mean any form resulting from mechanical\n-      transformation or translation of a Source form, including but\n-      not limited to compiled object code, generated documentation,\n-      and conversions to other media types.\n-\n-      \"Work\" shall mean the work of authorship, whether in Source or\n-      Object form, made available under the License, as indicated by a\n-      copyright notice that is included in or attached to the work\n-      (an example is provided in the Appendix below).\n-\n-      \"Derivative Works\" shall mean any work, whether in Source or Object\n-      form, that is based on (or derived from) the Work and for which the\n-      editorial revisions, annotations, elaborations, or other modifications\n-      represent, as a whole, an original work of authorship. For the purposes\n-      of this License, Derivative Works shall not include works that remain\n-      separable from, or merely link (or bind by name) to the interfaces of,\n-      the Work and Derivative Works thereof.\n-\n-      \"Contribution\" shall mean any work of authorship, including\n-      the original version of the Work and any modifications or additions\n-      to that Work or Derivative Works thereof, that is intentionally\n-      submitted to Licensor for inclusion in the Work by the copyright owner\n-      or by an individual or Legal Entity authorized to submit on behalf of\n-      the copyright owner. For the purposes of this definition, \"submitted\"\n-      means any form of electronic, verbal, or written communication sent\n-      to the Licensor or its representatives, including but not limited to\n-      communication on electronic mailing lists, source code control systems,\n-      and issue tracking systems that are managed by, or on behalf of, the\n-      Licensor for the purpose of discussing and improving the Work, but\n-      excluding communication that is conspicuously marked or otherwise\n-      designated in writing by the copyright owner as \"Not a Contribution.\"\n-\n-      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n-      on behalf of whom a Contribution has been received by Licensor and\n-      subsequently incorporated within the Work.\n-\n-   2. Grant of Copyright License. Subject to the terms and conditions of\n-      this License, each Contributor hereby grants to You a perpetual,\n-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n-      copyright license to reproduce, prepare Derivative Works of,\n-      publicly display, publicly perform, sublicense, and distribute the\n-      Work and such Derivative Works in Source or Object form.\n-\n-   3. Grant of Patent License. Subject to the terms and conditions of\n-      this License, each Contributor hereby grants to You a perpetual,\n-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n-      (except as stated in this section) patent license to make, have made,\n-      use, offer to sell, sell, import, and otherwise transfer the Work,\n-      where such license applies only to those patent claims licensable\n-      by such Contributor that are necessarily infringed by their\n-      Contribution(s) alone or by combination of their Contribution(s)\n-      with the Work to which such Contribution(s) was submitted. If You\n-      institute patent litigation against any entity (including a\n-      cross-claim or counterclaim in a lawsuit) alleging that the Work\n-      or a Contribution incorporated within the Work constitutes direct\n-      or contributory patent infringement, then any patent licenses\n-      granted to You under this License for that Work shall terminate\n-      as of the date such litigation is filed.\n-\n-   4. Redistribution. You may reproduce and distribute copies of the\n-      Work or Derivative Works thereof in any medium, with or without\n-      modifications, and in Source or Object form, provided that You\n-      meet the following conditions:\n-\n-      (a) You must give any other recipients of the Work or\n-          Derivative Works a copy of this License; and\n-\n-      (b) You must cause any modified files to carry prominent notices\n-          stating that You changed the files; and\n-\n-      (c) You must retain, in the Source form of any Derivative Works\n-          that You distribute, all copyright, patent, trademark, and\n-          attribution notices from the Source form of the Work,\n-          excluding those notices that do not pertain to any part of\n-          the Derivative Works; and\n-\n-      (d) If the Work includes a \"NOTICE\" text file as part of its\n-          distribution, then any Derivative Works that You distribute must\n-          include a readable copy of the attribution notices contained\n-          within such NOTICE file, excluding those notices that do not\n-          pertain to any part of the Derivative Works, in at least one\n-          of the following places: within a NOTICE text file distributed\n-          as part of the Derivative Works; within the Source form or\n-          documentation, if provided along with the Derivative Works; or,\n-          within a display generated by the Derivative Works, if and\n-          wherever such third-party notices normally appear. The contents\n-          of the NOTICE file are for informational purposes only and\n-          do not modify the License. You may add Your own attribution\n-          notices within Derivative Works that You distribute, alongside\n-          or as an addendum to the NOTICE text from the Work, provided\n-          that such additional attribution notices cannot be construed\n-          as modifying the License.\n-\n-      You may add Your own copyright statement to Your modifications and\n-      may provide additional or different license terms and conditions\n-      for use, reproduction, or distribution of Your modifications, or\n-      for any such Derivative Works as a whole, provided Your use,\n-      reproduction, and distribution of the Work otherwise complies with\n-      the conditions stated in this License.\n-\n-   5. Submission of Contributions. Unless You explicitly state otherwise,\n-      any Contribution intentionally submitted for inclusion in the Work\n-      by You to the Licensor shall be under the terms and conditions of\n-      this License, without any additional terms or conditions.\n-      Notwithstanding the above, nothing herein shall supersede or modify\n-      the terms of any separate license agreement you may have executed\n-      with Licensor regarding such Contributions.\n-\n-   6. Trademarks. This License does not grant permission to use the trade\n-      names, trademarks, service marks, or product names of the Licensor,\n-      except as required for reasonable and customary use in describing the\n-      origin of the Work and reproducing the content of the NOTICE file.\n-\n-   7. Disclaimer of Warranty. Unless required by applicable law or\n-      agreed to in writing, Licensor provides the Work (and each\n-      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-      implied, including, without limitation, any warranties or conditions\n-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n-      PARTICULAR PURPOSE. You are solely responsible for determining the\n-      appropriateness of using or redistributing the Work and assume any\n-      risks associated with Your exercise of permissions under this License.\n-\n-   8. Limitation of Liability. In no event and under no legal theory,\n-      whether in tort (including negligence), contract, or otherwise,\n-      unless required by applicable law (such as deliberate and grossly\n-      negligent acts) or agreed to in writing, shall any Contributor be\n-      liable to You for damages, including any direct, indirect, special,\n-      incidental, or consequential damages of any character arising as a\n-      result of this License or out of the use or inability to use the\n-      Work (including but not limited to damages for loss of goodwill,\n-      work stoppage, computer failure or malfunction, or any and all\n-      other commercial damages or losses), even if such Contributor\n-      has been advised of the possibility of such damages.\n-\n-   9. Accepting Warranty or Additional Liability. While redistributing\n-      the Work or Derivative Works thereof, You may choose to offer,\n-      and charge a fee for, acceptance of support, warranty, indemnity,\n-      or other liability obligations and/or rights consistent with this\n-      License. However, in accepting such obligations, You may act only\n-      on Your own behalf and on Your sole responsibility, not on behalf\n-      of any other Contributor, and only if You agree to indemnify,\n-      defend, and hold each Contributor harmless for any liability\n-      incurred by, or claims asserted against, such Contributor by reason\n-      of your accepting any such warranty or additional liability.\n-\n-   END OF TERMS AND CONDITIONS\n-\n-   APPENDIX: How to apply the Apache License to your work.\n-\n-      To apply the Apache License to your work, attach the following\n-      boilerplate notice, with the fields enclosed by brackets \"[]\"\n-      replaced with your own identifying information. (Don't include\n-      the brackets!)  The text should be enclosed in the appropriate\n-      comment syntax for the file format. We also recommend that a\n-      file or class name and description of purpose be included on the\n-      same \"printed page\" as the copyright notice for easier\n-      identification within third-party archives.\n-\n-   Copyright [yyyy] [name of copyright owner]\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License."},{"sha":"5a6871a22146047413d2620d53e2578aa49b8aa3","filename":"branch-4.3/NOTICE","status":"removed","additions":0,"deletions":6,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/NOTICE","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/NOTICE","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/NOTICE?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,6 +0,0 @@\n-Apache BookKeeper\n-Copyright 2011-2014 The Apache Software Foundation\n-\n-This product includes software developed at\n-The Apache Software Foundation (http://www.apache.org/).\n-"},{"sha":"33f7540d96aa79546674b48092f577651029ea0c","filename":"branch-4.3/README","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/README","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/README","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/README?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,88 +0,0 @@\n-Build instructions for BookKeeper\n-\n--------------------------------------------------------------------------------\n-Requirements:\n-\n-* Unix System\n-* JDK 1.6\n-* Maven 3.0\n-* Autotools (if compiling native hedwig client)\n-* Internet connection for first build (to fetch all dependencies)\n-\n--------------------------------------------------------------------------------\n-The BookKeeper project contains:\n-\n- - bookkeeper-server            (BookKeeper server and client)\n- - bookkeeper-benchmark         (Benchmark suite for testing BookKeeper performance)\n- - bookkeeper-stats             (BookKeeper stats library)\n- - bookkeeper-stats-providers   (BookKeeper stats providers)\n- - hedwig-protocol              (Hedwig network protocol)\n- - hedwig-server                (Hedwig server)\n- - hedwig-client                (Hedwig client library)\n- - hedwig-client-jms            (Hedwig client jms library)\n-\n-BookKeeper is a system to reliably log streams of records. It is designed to \n-store  write ahead logs, such as those found in database or database like \n-applications.\n-\n-Hedwig is a publish-subscribe system designed to carry large amounts of data \n-across the internet in a guaranteed-delivery fashion from those who produce \n-it (publishers) to those who are interested in it (subscribers).\n-\n---------------------------------------------------------------------------------\n-How do I build?\n-\n- BookKeeper uses maven as its build system. To build, run \"mvn package\" from the \n- top-level directory, or from within any of the submodules.\n-\n- Useful maven commands are:\n-\n- * Clean                     : mvn clean\n- * Compile                   : mvn compile\n- * Run tests                 : mvn test \n- * Create JAR                : mvn package\n- * Run findbugs              : mvn compile findbugs:findbugs\n- * Install JAR in M2 cache   : mvn install\n- * Deploy JAR to Maven repo  : mvn deploy\n- * Run Rat                   : mvn apache-rat:check\n- * Build javadocs            : mvn compile javadoc:aggregate\n- * Build distribution        : mvn package assembly:single\n-\n- Tests options:\n-\n- * Use -DskipTests to skip tests when running the following Maven goals:\n-    'package',  'install', 'deploy' or 'verify'\n- * -Dtest=<TESTCLASSNAME>,<TESTCLASSNAME#METHODNAME>,....\n- * -Dtest.exclude=<TESTCLASSNAME>\n- * -Dtest.exclude.pattern=**/<TESTCLASSNAME1>.java,**/<TESTCLASSNAME2>.java\n-\n---------------------------------------------------------------------------------\n-How do I run the services?\n-\n- Running a Hedwig service requires a running BookKeeper service, which in turn\n- requires a running ZooKeeper service (see http://zookeeper.apache.org). To \n- start a bookkeeper service quickly for testing, run:\n-   \n-   $ bookkeeper-server/bin/bookkeeper localbookie 10\n-\n- This will start a standalone, ZooKeeper instance and 10 BookKeeper bookies.\n- Note that this is only useful for testing. Data is not persisted between runs.\n-\n- To start a real BookKeeper service, you must set up a ZooKeeper instance and\n- run start a bookie on several machines. Modify bookkeeper-server/conf/bk_server.conf\n- to point to your ZooKeeper instance. To start a bookie run:\n-\n-   $ bookkeeper-server/bin/bookkeeper bookie\n-\n- Once you have at least 3 bookies runnings, you can start some Hedwig hubs. A \n- hub is a machines which is responsible for a set of topics in the pubsub \n- system. The service automatically distributes the topics among the hubs. \n- To start a hedwig hub:\n-\n-   $ hedwig-server/bin/hedwig server\n-\n- You can get more help on using these commands by running:\n-\n-   $ bookkeeper-server/bin/bookkeeper help\n-       and\n-   $ hedwig-server/bin/hedwig help"},{"sha":"1515495912bf8ed4769de164e3769e14cc69adb2","filename":"branch-4.3/bin/find-new-patch-available-jiras","status":"removed","additions":0,"deletions":129,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/find-new-patch-available-jiras","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/find-new-patch-available-jiras","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/find-new-patch-available-jiras?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,129 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TEMPDIR=${BASEDIR}/tmp\n-\n-JIRAAVAILPATCHQUERY=\"https://issues.apache.org/jira/sr/jira.issueviews:searchrequest-xml/temp/SearchRequest.xml?jqlQuery=project+in+%28BOOKKEEPER%29+AND+status+%3D+%22Patch+Available%22+ORDER+BY+updated+DESC&tempMax=1000\"\n-TESTPATCHJOBURL=\"https://builds.apache.org/job/bookkeeper-trunk-precommit-build\"\n-TOKEN=\"\"\n-SUBMIT=\"false\"\n-DELETEHISTORYFILE=\"false\"\n-\n-RUNTESTSFILE=${BASEDIR}/TESTED_PATCHES.txt\n-\n-printUsage() {\n-    echo \"Usage: $0 <OPTIONS>\"\n-    echo \"          --submit --token=<BOOKKEEPER PRECOMMIT JOB TOKEN>\"\n-    echo \"          [--delete-history-file]\"\n-    echo \"          [--script-debug]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --submit)\n-            SUBMIT=\"true\"\n-            ;;\n-        --token=*)\n-            TOKEN=${i#*=}\n-            ;;\n-        --script-debug)\n-            DEBUG=\"-x\"\n-            ;;\n-        --delete-history-file)\n-            DELETEHISTORYFILE=\"true\"\n-            ;;\n-        *)\n-            echo \"Invalid option\"\n-            echo\n-            printUsage\n-            exit 1\n-            ;;\n-        esac\n-    done\n-    if [[ \"$SUBMIT\" == \"true\" && \"${TOKEN}\" == \"\" ]] ; then\n-        echo \"Token has not been specified\"\n-        echo\n-        printUsage\n-        exit 1\n-    fi\n-}\n-\n-###############################################################################\n-findAndSubmitAvailablePatches() {\n-    ## Grab all the key (issue numbers) and largest attachment id for each item in the XML\n-    curl --fail --location --retry 3 \"${JIRAAVAILPATCHQUERY}\" > ${TEMPDIR}/patch-availables.xml\n-    if [ \"$?\" != \"0\" ] ; then\n-        echo \"Could not retrieve available patches from JIRA\"\n-        exit 1\n-    fi\n-    xpath -e \"//item/key/text() | //item/attachments/attachment[not(../attachment/@id > @id)]/@id\" \\\n-        ${TEMPDIR}/patch-availables.xml > ${TEMPDIR}/patch-attachments.element\n-\n-    ### Replace newlines with nothing, then replace id=\" with =, then replace \" with newline\n-    ### to yield lines with pairs (issueNumber,largestAttachmentId). Example: BOOKKEEPER-123,456984\n-    cat ${TEMPDIR}/patch-attachments.element \\\n-        | awk '{ if ( $1 ~ /^BOOKKEEPER\\-/) {JIRA=$1 }; if ($1 ~ /id=/) { print JIRA\",\"$1} }' \\\n-        | sed 's/id\\=\"//' | sed 's/\"//' > ${TEMPDIR}/patch-availables.pair\n-\n-    ### Iterate through issue list and find the (issueNumber,largestAttachmentId) pairs that have\n-    ### not been tested (ie don't already exist in the patch_tested.txt file\n-    touch ${RUNTESTSFILE}\n-    cat ${TEMPDIR}/patch-availables.pair | while read PAIR ; do\n-        set +e\n-        COUNT=`grep -c \"$PAIR\" ${RUNTESTSFILE}`\n-        set -e\n-        if [ \"$COUNT\" -lt \"1\" ] ; then\n-        ### Parse $PAIR into project, issue number, and attachment id\n-            ISSUE=`echo $PAIR | sed -e \"s/,.*$//\"`\n-            echo \"Found new patch for issue $ISSUE\"\n-            if [ \"$SUBMIT\" == \"true\" ]; then\n-            ### Kick off job\n-                echo \"Submitting job for issue $ISSUE\"\n-                curl --fail --location --retry 3 \\\n-                    \"${TESTPATCHJOBURL}/buildWithParameters?token=${TOKEN}&JIRA_NUMBER=${ISSUE}\" > /dev/null\n-                if [ \"$?\" != \"0\" ] ; then\n-                    echo \"Could not submit precommit job for $ISSUE\"\n-                    exit 1\n-                fi\n-            fi\n-            ### Mark this pair as tested by appending to file\n-            echo \"$PAIR\" >> ${RUNTESTSFILE}\n-        fi\n-    done\n-}\n-###############################################################################\n-\n-mkdir -p ${TEMPDIR} 2>&1 $STDOUT\n-\n-parseArgs \"$@\"\n-\n-if [ -n \"${DEBUG}\" ] ; then\n-    set -x\n-fi\n-\n-if [ \"${DELETEHISTORYFILE}\" == \"true\" ] ; then\n-    rm ${RUNTESTSFILE}\n-fi\n-\n-findAndSubmitAvailablePatches\n-\n-exit 0"},{"sha":"b3bfd01af87e735b2aa6abdfe5c490160f4ea8be","filename":"branch-4.3/bin/raw-check-patch","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/raw-check-patch","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/raw-check-patch","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/raw-check-patch?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,47 +0,0 @@\n-#!/usr/bin/env bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-printTrailingSpaces() {\n-    PATCH=$1\n-    cat $PATCH | awk '/^+/ { if (/ $/) { print \"\\tL\" NR \":\" $0} }'\n-}\n-\n-printTabs() {\n-    PATCH=$1\n-    cat $PATCH | awk '/^+/ { if (/\\t/) { print \"\\tL\" NR \":\" $0 } }'\n-}\n-\n-printAuthors() {\n-    PATCH=$1\n-    cat $PATCH | awk '/^+/ { L=tolower($0); if (L ~ /.*\\*.* @author/) { print \"\\tL\" NR \":\" $0 } }'\n-}\n-\n-printLongLines() {\n-    PATCH=$1\n-    cat $PATCH | awk '/^+/ { if ( length > 121 ) { print \"\\tL\" NR \":\" $0 } }'\n-}\n-\n-if [[ \"X$(basename -- \"$0\")\" = \"Xraw-check-patch\" ]]; then\n-    echo Trailing spaces\n-    printTrailingSpaces $1\n-    echo\n-    echo Tabs\n-    printTabs $1\n-    echo\n-    echo Authors\n-    printAuthors $1\n-    echo\n-    echo Long lines\n-    printLongLines $1\n-fi"},{"sha":"e81d653d53fffdc0cefc9c9633e26993e68f8afb","filename":"branch-4.3/bin/test-patch","status":"removed","additions":0,"deletions":416,"changes":416,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,416 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TESTPATCHDIRNAME=test-patch\n-TESTPATCHDIR=${BASEDIR}/${TESTPATCHDIRNAME}\n-TOOLSDIR=${TESTPATCHDIR}/tools\n-TEMPDIR=${TESTPATCHDIR}/tmp\n-REPORTDIR=${TESTPATCHDIR}/reports\n-SUMMARYFILE=${REPORTDIR}/TEST-SUMMARY.jira\n-SUMMARYFILETXT=${REPORTDIR}/TEST-SUMMARY.txt\n-\n-JIRAHOST=\"https://issues.apache.org\"\n-JIRAURL=\"${JIRAHOST}/jira\"\n-JIRAURLISSUEPREFIX=\"${JIRAURL}/browse/\"\n-\n-JIRAUPDATE=\"false\"\n-JIRAUSER=\"\"\n-JIRAPASSWORD=\"\"\n-\n-\n-VERBOSEOPTION=\"\"\n-JIRAISSUE=\"\"\n-PATCHFILE=\"\"\n-TASKSTORUN=\"\"\n-TASKSTOSKIP=\"\"\n-RESETSCM=\"false\"\n-DIRTYSCM=\"false\"\n-STDOUT=\"/dev/null\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-gitOrSvn() {\n-    SCM=\"NONE\"\n-    which git &> /dev/null\n-    if [[ $? == 0 ]] ; then\n-        git status &> /dev/null\n-        if [[ $? == 0 ]] ; then\n-            SCM=\"git\"\n-        fi\n-    fi\n-    if [ \"${SCM}\" == \"NONE\" ] ; then\n-        which svn &> /dev/null\n-        if [[ $? == 0 ]] ; then\n-            svnOutput=`svn status 2>&1`\n-            if [[  \"$svnOutput\" != *\"is not a working copy\" ]] ; then\n-                SCM=\"svn\"\n-            fi\n-        fi\n-    fi\n-    if [ \"${SCM}\" == \"NONE\" ] ; then\n-        echo \"The current workspace is not under Source Control (GIT or SVN)\"\n-        exit 1\n-    fi\n-}\n-###############################################################################\n-prepareSCM() {\n-    gitOrSvn\n-    if [ \"${DIRTYSCM}\" != \"true\" ] ; then\n-        if [ \"${RESETSCM}\" == \"true\" ] ; then\n-            if [ \"${SCM}\" == \"git\" ] ; then\n-                git reset --hard HEAD > /dev/null\n-                git clean -f -d -e $TESTPATCHDIRNAME > /dev/null\n-            fi\n-            if [ \"${SCM}\" == \"svn\" ] ; then\n-                svn revert -R . > /dev/null\n-                svn status | grep \"\\?\" | awk '{print $2}' | xargs rm -rf\n-            fi\n-        else\n-            echo \"It should not happen DIRTYSCM=false & RESETSCM=false\"\n-            exit 1\n-        fi\n-        echo \"Cleaning local ${SCM} workspace\" >> ${SUMMARYFILE}\n-    else\n-        echo \"WARNING: Running test-patch on a dirty local ${SCM} workspace\" >> ${SUMMARYFILE}\n-    fi\n-}\n-###############################################################################\n-prepareTestPatchDirs() {\n-    mkdir -p ${TESTPATCHDIR} 2> /dev/null\n-    rm -rf ${REPORTDIR} 2> /dev/null\n-    rm -rf ${TEMPDIR} 2> /dev/null\n-    mkdir -p ${TOOLSDIR} 2> /dev/null\n-    mkdir -p ${TEMPDIR} 2> /dev/null\n-    mkdir -p ${REPORTDIR} 2> /dev/null\n-    if [ ! -e \"${TESTPATCHDIR}\" ] ; then\n-        echo \"Could not create test-patch/ dir\"\n-        exit 1\n-    fi\n-}\n-###############################################################################\n-updateJira() {\n-    if [[ \"${JIRAUPDATE}\" != \"\" && \"${JIRAISSUE}\" != \"\" ]] ; then\n-        if [[ \"$JIRAPASSWORD\" != \"\" ]] ; then\n-            JIRACLI=${TOOLSDIR}/jira-cli/jira.sh\n-            if [ ! -e \"${JIRACLI}\" ] ; then\n-                curl https://bobswift.atlassian.net/wiki/download/attachments/16285777/jira-cli-2.6.0-distribution.zip > ${TEMPDIR}/jira-cli.zip\n-                if [ $? != 0 ] ; then\n-                    echo\n-                    echo \"Could not download jira-cli tool, thus no JIRA updating\"\n-                    echo\n-                    exit 1\n-                fi\n-                mkdir ${TEMPDIR}/jira-cli-tmp\n-                (cd ${TEMPDIR}/jira-cli-tmp;jar xf ${TEMPDIR}/jira-cli.zip; mv jira-cli-2.6.0 ${TOOLSDIR}/jira-cli)\n-                chmod u+x ${JIRACLI}\n-            fi\n-            echo \"Adding comment to JIRA\"\n-            comment=`cat ${SUMMARYFILE}`\n-            $JIRACLI -s $JIRAURL -a addcomment -u $JIRAUSER -p \"$JIRAPASSWORD\" --comment \"$comment\" --issue $JIRAISSUE\n-            echo\n-        else\n-            echo \"Skipping JIRA update\"\n-            echo\n-        fi\n-    fi\n-}\n-###############################################################################\n-cleanupAndExit() {\n-    updateJira\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 <OPTIONS>\"\n-    echo \"          (--jira=<JIRA ISSUE> | --patch=<PATCH PATH>)\"\n-    echo \"          (--reset-scm | --dirty-scm)\"\n-    echo \"          [--tasks=<TASK,...>]\"\n-    echo \"          [--skip-tasks=<TASK,...>]\"\n-    echo \"          [--jira-cli=<JIRA CLIENT>]\"\n-    echo \"          [--jira-user=<JIRA USER>]\"\n-    echo \"          [--jira-password=<JIRA PASSWORD>]\"\n-    echo \"          [-D<MVN PROPERTY>...]\"\n-    echo \"          [-P<MVN PROFILE>...]\"\n-    echo \"          [--list-tasks]\"\n-    echo \"          [--verbose]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --jira=*)\n-            JIRAISSUE=${i#*=}\n-            ;;\n-        --patch=*)\n-            PATCHFILE=${i#*=}\n-            ;;\n-        --tasks=*)\n-            TASKSTORUN=${i#*=}\n-            ;;\n-        --skip-tasks=*)\n-            TASKSTOSKIP=${i#*=}\n-            ;;\n-        --list-tasks)\n-            listTasks\n-            cleanupAndExit 0\n-            ;;\n-        --jira-cli=*)\n-            JIRACLI=${i#*=}\n-            ;;\n-        --jira-user=*)\n-            JIRAUSER=${i#*=}\n-            ;;\n-        --jira-password=*)\n-            JIRAPASSWORD=${i#*=}\n-            JIRAUPDATE=\"true\"\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        --reset-scm)\n-            RESETSCM=\"true\"\n-            ;;\n-        --dirty-scm)\n-            DIRTYSCM=\"true\"\n-            ;;\n-        --verbose)\n-            VERBOSEOPTION=\"--verbose\"\n-            STDOUT=\"/dev/stdout\"\n-            ;;\n-        *)\n-            echo \"Invalid option\"\n-            echo\n-            printUsage\n-            exit 1\n-            ;;\n-        esac\n-    done\n-\n-    if [[ \"${JIRAISSUE}\" == \"\" && \"${PATCHFILE}\" == \"\" ]] ; then\n-        echo \"Either --jira or --patch option must be specified\"\n-        echo\n-        printUsage\n-        exit 1\n-    fi\n-    if [[ \"${JIRAISSUE}\" != \"\" && \"${PATCHFILE}\" != \"\" ]] ; then\n-        echo \"Cannot specify --jira or --patch options together\"\n-        echo\n-        printUsage\n-        exit 1\n-    fi\n-    if [[ \"${RESETSCM}\" == \"false\" && \"${DIRTYSCM}\" == \"false\" ]] ; then\n-        echo \"Either --reset-scm or --dirty-scm option must be specified\"\n-        echo\n-        printUsage\n-        exit 1\n-    fi\n-    if [[ \"${RESETSCM}\" == \"true\" && \"${DIRTYSCM}\" == \"true\" ]] ; then\n-        echo \"Cannot specify --reset-scm and --dirty-scm options together\"\n-        echo\n-        printUsage\n-        exit 1\n-    fi\n-}\n-\n-###############################################################################\n-listTasks() {\n-    echo \"Available Tasks:\"\n-    echo \"\"\n-    getAllTasks\n-    for taskFile in ${TASKFILES} ; do\n-        taskName=`bash $taskFile --taskname`\n-        echo \"  $taskName\"\n-    done\n-    echo\n-}\n-###############################################################################\n-downloadPatch () {\n-    PATCHFILE=${TEMPDIR}/test.patch\n-    jiraPage=${TEMPDIR}/jira.txt\n-    curl \"${JIRAURLISSUEPREFIX}${JIRAISSUE}\" > ${jiraPage}\n-    if [[ `grep -c 'Patch Available' ${jiraPage}` == 0 ]] ; then\n-        echo \"$JIRAISSUE is not \\\"Patch Available\\\".  Exiting.\"\n-        echo\n-        exit 1\n-    fi\n-    relativePatchURL=`grep -o '\"/jira/secure/attachment/[0-9]*/[^\"]*' ${jiraPage} \\\n-        | grep -v -e 'htm[l]*$' | sort | tail -1 \\\n-        | grep -o '/jira/secure/attachment/[0-9]*/[^\"]*'`\n-    patchURL=\"${JIRAHOST}${relativePatchURL}\"\n-    patchNum=`echo $patchURL | grep -o '[0-9]*/' | grep -o '[0-9]*'`\n-    curl ${patchURL} > ${PATCHFILE}\n-    if [[ $? != 0 ]] ; then\n-        echo \"Could not download patch for ${JIRAISSUE} from ${patchURL}\"\n-        echo\n-        cleanupAndExit 1\n-    fi\n-    PATCHNAME=$(echo $patchURL | sed 's/.*\\///g')\n-    echo \"JIRA ${JIRAISSUE}, patch downloaded at `date` from ${patchURL}\" \n-    echo\n-    echo \"Patch [$PATCHNAME|$patchURL] downloaded at $(date)\" >> ${SUMMARYFILE}\n-    echo \"\" >> ${SUMMARYFILE}\n-}\n-###############################################################################\n-applyPatch() {\n-    echo \"Applying patch\" >> $STDOUT\n-    echo \"\" >> $STDOUT\n-    patch -f -E --dry-run -p0 < ${PATCHFILE} | tee ${REPORTDIR}/APPLY-PATCH.txt \\\n-        >> $STDOUT\n-    if [[  ${PIPESTATUS[0]} != 0 ]] ; then\n-        echo \"Patch failed to apply to head of branch\"\n-        echo \"{color:red}-1{color} Patch failed to apply to head of branch\" >> ${SUMMARYFILE}\n-        echo \"\" >> ${SUMMARYFILE}\n-        echo \"----------------------------\" >> ${SUMMARYFILE}\n-        echo\n-        cleanupAndExit 1\n-    fi\n-    patch -f -E -p0 < ${PATCHFILE} > ${REPORTDIR}/APPLY-PATCH.txt\n-    if [[ $? != 0 ]] ; then\n-        echo \"ODD!, dry run passed, but patch failed to apply to head of branch\"\n-        echo\n-        cleanupAndExit 1\n-    fi\n-    echo \"\" >> $STDOUT\n-    echo \"Patch applied\"\n-    echo \"{color:green}+1 PATCH_APPLIES{color}\" >> $SUMMARYFILE\n-    echo\n-}\n-###############################################################################\n-run() {\n-    task=`bash $1 --taskname`\n-    if [[ \"${TASKSTORUN}\" == \"\" || \"${TASKSTORUN}\" =~ \"${task}\" ]] ; then\n-        if [[ ! \"${TASKSTOSKIP}\" =~ \"${task}\" ]] ; then\n-            echo \"  Running test-patch task ${task}\"\n-            outputFile=\"`basename $1`-$2.out\"\n-            $1 --op=$2 --tempdir=${TEMPDIR} --reportdir=${REPORTDIR} \\\n-                --summaryfile=${SUMMARYFILE} --patchfile=${PATCHFILE} ${MVNPASSTHRU} \\\n-                ${VERBOSEOPTION} | tee ${TEMPDIR}/${outputFile} >> $STDOUT\n-            if [[ $? != 0 ]] ; then\n-                echo \"  Failure, check for details ${TEMPDIR}/${outputFile}\"\n-                echo\n-                cleanupAndExit 1\n-            fi\n-        fi\n-    fi\n-}\n-###############################################################################\n-getAllTasks() {\n-    TASKFILES=`ls -a bin/test\\-patch\\-[0-9][0-9]\\-*`\n-}\n-###############################################################################\n-prePatchRun() {\n-    echo \"Pre patch\"\n-    for taskFile in ${TASKFILES} ; do\n-        run $taskFile pre\n-    done\n-    echo\n-}\n-###############################################################################\n-postPatchRun() {\n-    echo \"Post patch\"\n-    for taskFile in ${TASKFILES} ; do\n-        run $taskFile post\n-    done\n-    echo\n-}\n-###############################################################################\n-createReports() {\n-    echo \"Reports\"\n-    for taskFile in ${TASKFILES} ; do\n-        run $taskFile report\n-    done\n-    echo\n-}\n-###############################################################################\n-\n-echo\n-\n-parseArgs \"$@\"\n-\n-prepareSCM\n-\n-prepareTestPatchDirs\n-\n-echo \"\" > ${SUMMARYFILE}\n-\n-if [ \"${PATCHFILE}\" == \"\" ] ; then\n-    echo \"Testing JIRA ${JIRAISSUE}\"\n-    echo\n-    echo \"Testing JIRA ${JIRAISSUE}\" >> ${SUMMARYFILE}\n-    echo \"\" >> ${SUMMARYFILE}\n-else\n-    if [ ! -e ${PATCHFILE} ] ; then\n-        echo \"Patch file does not exist\"\n-        cleanupAndExit 1\n-    fi\n-    echo \"Testing patch ${PATCHFILE}\"\n-    echo\n-    echo \"Testing patch ${PATCHFILE}\" >> ${SUMMARYFILE}\n-    echo \"\" >> ${SUMMARYFILE}\n-fi\n-\n-echo \"\" >> ${SUMMARYFILE}\n-\n-if [ \"${PATCHFILE}\" == \"\" ] ; then\n-    downloadPatch ${JIRAISSUE}\n-fi\n-\n-echo \"----------------------------\" >> ${SUMMARYFILE}\n-echo \"\" >> ${SUMMARYFILE}\n-getAllTasks\n-prePatchRun\n-applyPatch\n-postPatchRun\n-createReports\n-echo \"\" >> ${SUMMARYFILE}\n-echo \"----------------------------\" >> ${SUMMARYFILE}\n-MINUSONES=`grep -c \"\\}\\-1\" ${SUMMARYFILE}`\n-if [[ $MINUSONES == 0 ]]; then\n-    echo \"{color:green}*+1 Overall result, good!, no -1s*{color}\" >> ${SUMMARYFILE}\n-else\n-    echo \"{color:red}*-1 Overall result, please check the reported -1(s)*{color}\" >> ${SUMMARYFILE}\n-fi\n-echo \"\" >> ${SUMMARYFILE}\n-WARNINGS=`grep -c \"\\}WARNING\" ${SUMMARYFILE}`\n-if [[ $WARNINGS != 0 ]]; then\n-    echo \"{color:red}.   There is at least one warning, please check{color}\" >> ${SUMMARYFILE}\n-fi\n-echo \"\" >> ${SUMMARYFILE}\n-\n-if [ ! -z \"${JIRAISSUE}\" ]; then\n-    echo \"The full output of the test-patch run is available at\"  >> ${SUMMARYFILE}\n-    echo \"\"  >> ${SUMMARYFILE}\n-    echo \".   ${BUILD_URL}\"  >> ${SUMMARYFILE}\n-    echo \"\"  >> ${SUMMARYFILE}\n-else\n-    echo\n-    echo \"Refer to ${REPORTDIR} for detailed test-patch reports\"\n-    echo\n-fi\n-\n-cat ${SUMMARYFILE} | sed -e 's/{color}//' -e 's/{color:green}//' -e 's/{color:red}//' -e 's/^\\.//' -e 's/^\\*//' -e 's/\\*$//' > ${SUMMARYFILETXT}\n-\n-cat ${SUMMARYFILETXT}\n-\n-cleanupAndExit `expr $MINUSONES != 0`"},{"sha":"d266bbeb2b880a94cbf99271992784d9469746f7","filename":"branch-4.3/bin/test-patch-00-clean","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-00-clean","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-00-clean","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-00-clean?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,100 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"CLEAN\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR>) [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    mvn clean ${MVNPASSTHRU} > ${TEMPDIR}/${TASKNAME}.txt\n-    EXITCODE=$?\n-    # removing files created by dependency:copy-dependencies\n-    rm -f */lib/*\n-    exit $EXITCODE\n-    ;;\n-post)\n-    mvn clean ${MVNPASSTHRU} >> ${TEMPDIR}/${TASKNAME}.txt\n-    EXITCODE=$?\n-    ;;\n-report)\n-    echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"52c0b2f50006fb0e016172502ad84fd668d9c16b","filename":"branch-4.3/bin/test-patch-05-patch-raw-analysis","status":"removed","additions":0,"deletions":165,"changes":165,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-05-patch-raw-analysis","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-05-patch-raw-analysis","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-05-patch-raw-analysis?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,165 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-source $(dirname \"$0\")/raw-check-patch\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"RAW_PATCH_ANALYSIS\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-PATCHFILE=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>)\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        --patchfile=*)\n-            PATCHFILE=${i#*=}\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" || \"${PATCHFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-checkNoAuthors() {\n-    TMPFILE=$TEMPDIR/$TASKNAME-authors.txt\n-    printAuthors $PATCHFILE > $TMPFILE\n-    authorTags=$(wc -l $TMPFILE | awk '{print $1}')\n-    if [[ ${authorTags} != 0 ]] ; then\n-        REPORT+=(\"{color:red}-1{color} the patch seems to contain ${authorTags} line(s) with @author tags\")\n-        REPORT+=(\"$(cat $TMPFILE)\")\n-    else\n-        REPORT+=(\"{color:green}+1{color} the patch does not introduce any @author tags\")\n-    fi\n-}\n-###############################################################################\n-checkNoTabs() {\n-    TMPFILE=$TEMPDIR/$TASKNAME-tabs.txt\n-    printTabs $PATCHFILE > $TMPFILE\n-    tabs=$(wc -l $TMPFILE | awk '{print $1}')\n-    if [[ ${tabs} != 0 ]] ; then\n-        REPORT+=(\"{color:red}-1{color} the patch contains ${tabs} line(s) with tabs\")\n-        REPORT+=(\"$(cat $TMPFILE)\")\n-    else\n-        REPORT+=(\"{color:green}+1{color} the patch does not introduce any tabs\")\n-    fi\n-}\n-###############################################################################\n-checkNoTrailingSpaces() {\n-    TMPFILE=$TEMPDIR/$TASKNAME-trailingspaces.txt\n-    printTrailingSpaces $PATCHFILE > $TMPFILE\n-    trailingSpaces=$(wc -l $TMPFILE | awk '{print $1}')\n-    if [[ ${trailingSpaces} != 0 ]] ; then\n-        REPORT+=(\"{color:red}-1{color} the patch contains ${trailingSpaces} line(s) with trailing spaces\")\n-        REPORT+=(\"$(cat $TMPFILE)\")\n-    else\n-        REPORT+=(\"{color:green}+1{color} the patch does not introduce any trailing spaces\")\n-    fi\n-}\n-###############################################################################\n-checkLinesLength() {\n-    TMPFILE=$TEMPDIR/$TASKNAME-trailingspaces.txt\n-    printLongLines $PATCHFILE > $TMPFILE\n-    longLines=$(wc -l $TMPFILE | awk '{print $1}')\n-    if [[ ${longLines} != 0 ]] ; then\n-        REPORT+=(\"{color:red}-1{color} the patch contains ${longLines} line(s) longer than 120 characters\")\n-        REPORT+=(\"$(cat $TMPFILE)\")\n-    else\n-        REPORT+=(\"{color:green}+1{color} the patch does not introduce any line longer than 120\")\n-    fi\n-}\n-###############################################################################\n-checkForTestcases() {\n-    testcases=`grep -c -i -e '^+++.*/test' ${PATCHFILE}`\n-    if [[ ${testcases} == 0 ]] ; then\n-        REPORT+=(\"{color:red}-1{color} the patch does not add/modify any testcase\")\n-    #reverting for summary +1 calculation\n-        testcases=1\n-    else\n-        REPORT+=(\"{color:green}+1{color} the patch does adds/modifies ${testcases} testcase(s)\")\n-    #reverting for summary +1 calculation\n-        testcases=0\n-    fi\n-}\n-###############################################################################\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    ;;\n-post)\n-    ;;\n-report)\n-    REPORT=()\n-    checkNoAuthors\n-    checkNoTabs\n-    checkNoTrailingSpaces\n-    checkLinesLength\n-    checkForTestcases\n-    total=`expr $authorTags + $tabs + $trailingSpaces + $longLines + $testcases`\n-    if [[ $total == 0 ]] ; then\n-        echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    else\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    fi\n-    for line in \"${REPORT[@]}\" ; do\n-        echo \".    ${line}\" >> $SUMMARYFILE\n-    done\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"f403301428cba7054a2d40fe630dd322c1f6fe6a","filename":"branch-4.3/bin/test-patch-08-rat","status":"removed","additions":0,"deletions":132,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-08-rat","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-08-rat","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-08-rat?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,132 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"RAT\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-STDOUT=\"/dev/null\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>) [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        --verbose)\n-            STDOUT=\"/dev/stdout\"\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-checkForWarnings() {\n-    cleanWarns=`grep -c '\\!?????' ${REPORTDIR}/${TASKNAME}-clean.txt`\n-    patchWarns=`grep -c '\\!?????' ${REPORTDIR}/${TASKNAME}-patch.txt`\n-    newWarns=`expr $patchWarns - $cleanWarns`\n-    if [[ $newWarns -le 0 ]] ; then\n-        REPORT+=(\"{color:green}+1{color} the patch does not seem to introduce new RAT warnings\")\n-        newWarns=0\n-    else\n-        REPORT+=(\"{color:red}-1{color} the patch seems to introduce $newWarns new RAT warning(s)\")\n-        newWarns=1\n-    fi\n-    if [[ $cleanWarns != 0 ]] ; then\n-        REPORT+=(\"{color:red}WARNING: the current HEAD has $cleanWarns RAT warning(s), they should be addressed ASAP{color}\")\n-    fi\n-}\n-###############################################################################\n-copyRatFiles() {\n-    TAG=$1\n-    rm -f ${REPORTDIR}/${TASKNAME}-$TAG.txt\n-    for f in $(find . -name rat.txt); do\n-        cat $f >> ${REPORTDIR}/${TASKNAME}-$TAG.txt\n-    done\n-}\n-###############################################################################\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    mvn apache-rat:check ${MVNPASSTHRU} > $STDOUT\n-    copyRatFiles clean\n-    ;;\n-post)\n-    mvn apache-rat:check ${MVNPASSTHRU} > $STDOUT\n-    copyRatFiles patch\n-    ;;\n-report)\n-    checkForWarnings\n-    if [[ $newWarns == 0 ]] ; then\n-        echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    else\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    fi\n-    for line in \"${REPORT[@]}\" ; do\n-        echo \".    ${line}\" >> $SUMMARYFILE\n-    done\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"54bbf93419e2604a1f2d01fe8a20528db94d7b1a","filename":"branch-4.3/bin/test-patch-09-javadoc","status":"removed","additions":0,"deletions":118,"changes":118,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-09-javadoc","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-09-javadoc","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-09-javadoc?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,118 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"JAVADOC\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>) [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-checkForWarnings() {\n-    cleanWarns=`grep '\\[WARNING\\]' ${REPORTDIR}/${TASKNAME}-clean.txt | awk '/Javadoc Warnings/,EOF' | grep warning | awk 'BEGIN {total = 0} {total += 1} END {print total}'`\n-    patchWarns=`grep '\\[WARNING\\]' ${REPORTDIR}/${TASKNAME}-patch.txt | awk '/Javadoc Warnings/,EOF' | grep warning | awk 'BEGIN {total = 0} {total += 1} END {print total}'`\n-    newWarns=`expr $patchWarns - $cleanWarns`\n-    if [[ $newWarns -le 0 ]] ; then\n-        REPORT+=(\"{color:green}+1{color} the patch does not seem to introduce new Javadoc warnings\")\n-        newWarns=0\n-    else\n-        REPORT+=(\"{color:red}-1{color} the patch seems to introduce $newWarns new Javadoc warning(s)\")\n-        newWarns=1\n-    fi\n-    if [[ $cleanWarns != 0 ]] ; then\n-        REPORT+=(\"{color:red}WARNING{color}: the current HEAD has $cleanWarns Javadoc warning(s)\")\n-    fi\n-}\n-###############################################################################\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    mvn clean javadoc:aggregate ${MVNPASSTHRU} > ${REPORTDIR}/${TASKNAME}-clean.txt\n-    ;;\n-post)\n-    mvn clean javadoc:aggregate ${MVNPASSTHRU} > ${REPORTDIR}/${TASKNAME}-patch.txt\n-    ;;\n-report)\n-    checkForWarnings\n-    if [[ $newWarns == 0 ]] ; then\n-        echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    else\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    fi\n-    for line in \"${REPORT[@]}\" ; do\n-        echo \".    ${line}\" >> $SUMMARYFILE\n-    done\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"5714b22342ecbc7bff9dcc3291916ba4534a7ae6","filename":"branch-4.3/bin/test-patch-10-compile","status":"removed","additions":0,"deletions":144,"changes":144,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-10-compile","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-10-compile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-10-compile?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,144 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"COMPILE\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-STDOUT=\"/dev/null\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>) [--verbose] [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        --verbose)\n-            STDOUT=\"/dev/stdout\"\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-checkForWarnings() {\n-    grep '\\[WARNING\\]' ${REPORTDIR}/${TASKNAME}-clean.txt > ${TEMPDIR}/${TASKNAME}-javacwarns-clean.txt\n-    grep '\\[WARNING\\]' ${REPORTDIR}/${TASKNAME}-patch.txt > ${TEMPDIR}/${TASKNAME}-javacwarns-patch.txt\n-    cleanWarns=`cat ${TEMPDIR}/${TASKNAME}-javacwarns-clean.txt | awk 'BEGIN {total = 0} {total += 1} END {print total}'`\n-    patchWarns=`cat ${TEMPDIR}/${TASKNAME}-javacwarns-patch.txt | awk 'BEGIN {total = 0} {total += 1} END {print total}'`\n-    newWarns=`expr $patchWarns - $cleanWarns`\n-    if [[ $newWarns -le 0 ]] ; then\n-        REPORT+=(\"{color:green}+1{color} the patch does not seem to introduce new javac warnings\")\n-        newWarns=0\n-    else\n-        REPORT+=(\"{color:red}-1{color} the patch seems to introduce $newWarns new javac warning(s)\")\n-        newWarns=1\n-    fi\n-    if [[ $cleanWarns != 0 ]] ; then\n-        REPORT+=(\"{color:red}WARNING{color}: the current HEAD has $cleanWarns javac warning(s)\")\n-    fi\n-}\n-###############################################################################\n-\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    mvn clean install -DskipTests ${MVNPASSTHRU} | tee ${REPORTDIR}/${TASKNAME}-clean.txt >> $STDOUT\n-    if [[ ${PIPESTATUS[0]} == 0 ]] ; then\n-        echo \"{color:green}+1{color} HEAD compiles\" >> ${TEMPDIR}/${TASKNAME}-compile.txt\n-    else\n-        echo \"{color:red}-1{color} HEAD does not compile\" >> ${TEMPDIR}/${TASKNAME}-compile.txt\n-    fi\n-    ;;\n-post)\n-    mvn clean install -DskipTests ${MVNPASSTHRU} | tee ${REPORTDIR}/${TASKNAME}-patch.txt >> $STDOUT\n-    if [[ ${PIPESTATUS[0]} == 0 ]] ; then\n-        echo \"{color:green}+1{color} patch compiles\" >> ${TEMPDIR}/${TASKNAME}-compile.txt\n-    else\n-        echo \"{color:red}-1{color} patch does not compile\" >> ${TEMPDIR}/${TASKNAME}-compile.txt\n-    fi\n-    ;;\n-report)\n-    REPORT=()\n-    compileErrors=0\n-    while read line; do\n-        REPORT+=(\"$line\")\n-        if [[ \"$line\" =~ \"-1\" ]] ; then\n-            compileErrors=1\n-        fi\n-    done < ${TEMPDIR}/${TASKNAME}-compile.txt\n-    checkForWarnings\n-    total=`expr $compileErrors + $newWarns`\n-    if [[ $total == 0 ]] ; then\n-        echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    else\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    fi\n-    for line in \"${REPORT[@]}\" ; do\n-        echo \".    ${line}\" >> $SUMMARYFILE\n-    done\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"c91daffd03156963ff01b363aa5034a6a1194efb","filename":"branch-4.3/bin/test-patch-11-findbugs","status":"removed","additions":0,"deletions":156,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-11-findbugs","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-11-findbugs","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-11-findbugs?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,156 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"FINDBUGS\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-STDOUT=\"/dev/null\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>) [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        --verbose)\n-            STDOUT=\"/dev/stdout\"\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-checkForWarnings() {\n-    cleanBugs=0\n-    patchBugs=0\n-    for m in $(getModules); do\n-        MODNAME=$(echo $m | sed 's/\\///')\n-\n-        m_cleanBugs=$(cat ${REPORTDIR}/${TASKNAME}-${MODNAME}-clean.xml \\\n-            | sed 's/<\\/BugInstance>/<\\/BugInstance>\\n/g' | grep BugInstance | wc -l)\n-        m_patchBugs=$(cat ${REPORTDIR}/${TASKNAME}-${MODNAME}-patch.xml \\\n-            | sed 's/<\\/BugInstance>/<\\/BugInstance>\\n/g' | grep BugInstance | wc -l)\n-        m_newBugs=`expr $m_patchBugs - $m_cleanBugs`\n-        if [[ $m_newBugs != 0 ]] ; then\n-            BUGMODULES=\"$MODNAME $BUGMODULES\"\n-        fi\n-\n-        cleanBugs=$(($cleanBugs+$m_cleanBugs))\n-        patchBugs=$(($patchBugs+$m_patchBugs))\n-    done\n-\n-    BUGMODULES=$(echo $BUGMODULES | sed 's/^ *//' | sed 's/ *$//')\n-    newBugs=`expr $patchBugs - $cleanBugs`\n-    if [[ $newBugs -le 0 ]] ; then\n-        REPORT+=(\"{color:green}+1{color} the patch does not seem to introduce new Findbugs warnings\")\n-        newBugs=0\n-    else\n-        REPORT+=(\"{color:red}-1{color} the patch seems to introduce $patchBugs new Findbugs warning(s) in module(s) [$BUGMODULES]\")\n-        newBugs=1\n-    fi\n-    if [[ $cleanBugs != 0 ]] ; then\n-        REPORT+=(\"{color:red}WARNING: the current HEAD has $cleanWarns Findbugs warning(s), they should be addressed ASAP{color}\")\n-    fi\n-}\n-\n-###############################################################################\n-\n-getModules() {\n-    find . -name pom.xml | sed 's/^.\\///' | sed 's/pom.xml$//' | grep -v compat\n-}\n-###############################################################################\n-\n-copyFindbugsXml() {\n-    TAG=$1\n-    for m in $(getModules); do\n-        MODNAME=$(echo $m | sed 's/\\///')\n-        cp ${m}target/findbugsXml.xml ${REPORTDIR}/${TASKNAME}-${MODNAME}-$TAG.xml\n-    done\n-}\n-\n-parseArgs \"$@\"\n-\n-\n-case $OP in\n-pre)\n-    mvn findbugs:findbugs ${MVNPASSTHRU} > $STDOUT\n-    copyFindbugsXml clean\n-    ;;\n-post)\n-    mvn findbugs:findbugs ${MVNPASSTHRU} > $STDOUT\n-    copyFindbugsXml patch\n-    ;;\n-report)\n-    checkForWarnings\n-    if [[ $newBugs == 0 ]] ; then\n-        echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    else\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-    fi\n-    for line in \"${REPORT[@]}\" ; do\n-        echo \".    ${line}\" >> $SUMMARYFILE\n-    done\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"ab77bcdcea2a4711f964f887829f1b42464b85c7","filename":"branch-4.3/bin/test-patch-20-tests","status":"removed","additions":0,"deletions":125,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-20-tests","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-20-tests","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-20-tests?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,125 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"TESTS\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-STDOUT=\"/dev/null\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>) [--verbose] [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        --verbose)\n-            STDOUT=\"/dev/stdout\"\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    ;;\n-post)\n-    # must use package instead of test so that compat-deps shaded jars are correct\n-    mvn package ${MVNPASSTHRU} -Dmaven.test.failure.ignore=true \\\n-        -Dmaven.test.error.ignore=true -fae \\\n-        -Dtest.timeout=7200 | tee ${TEMPDIR}/${TASKNAME}.out >> $STDOUT\n-    exitCode=${PIPESTATUS[0]}\n-    echo \"$exitCode\" >  ${TEMPDIR}/${TASKNAME}.exitCode\n-    ;;\n-report)\n-    failedTests=` find . -name '*\\.txt' | grep target/surefire-reports | xargs grep  \"<<< FAILURE\" | grep -v \"Tests run:\" | sed 's/.*\\.txt\\://' | sed 's/ .*//'`\n-    testsRun=`grep \"Tests run:\" ${TEMPDIR}/${TASKNAME}.out | grep -v \" Time elapsed:\" | awk '{print $3}' | sed 's/,//' | awk 'BEGIN {count=0} {count=count+$1} END {print count}'`\n-    testsFailed=`grep \"Tests run:\" ${TEMPDIR}/${TASKNAME}.out | grep -v \" Time elapsed:\" | awk '{print $5}' | sed 's/,//' | awk 'BEGIN {count=0} {count=count+$1} END {print count}'`\n-    testsErrors=`grep \"Tests run:\" ${TEMPDIR}/${TASKNAME}.out | grep -v \" Time elapsed:\" | awk '{print $7}' | sed 's/,//' | awk 'BEGIN {count=0} {count=count+$1} END {print count}'`\n-    hasFailures=`expr $testsFailed + $testsErrors`\n-    testsExitCode=`cat ${TEMPDIR}/${TASKNAME}.exitCode`\n-    if [[ $hasFailures != 0 ]] ; then\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-        echo \".    Tests run: $testsRun\" >> $SUMMARYFILE\n-        echo \".    Tests failed: $testsFailed\" >> $SUMMARYFILE\n-        echo \".    Tests errors: $testsErrors\" >> $SUMMARYFILE\n-        echo \"\" >> ${SUMMARYFILE}\n-        echo \".    The patch failed the following testcases:\" >> $SUMMARYFILE\n-        echo \"\" >> ${SUMMARYFILE}\n-        echo \"${failedTests}\" | sed 's/^/.      /' >> $SUMMARYFILE\n-        echo \"\" >> ${SUMMARYFILE}\n-    else\n-        if [[ \"$testsExitCode\" != \"0\" ]] ; then\n-            echo \"{color:red}-1 ${TASKNAME}{color} - patch does not compile, cannot run testcases\" >> $SUMMARYFILE\n-        else\n-            echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-            echo \".    Tests run: $testsRun\" >> $SUMMARYFILE\n-        fi\n-    fi\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"33d4d6c0789320383e46b464b964f8babb9c493b","filename":"branch-4.3/bin/test-patch-30-dist","status":"removed","additions":0,"deletions":106,"changes":106,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-30-dist","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bin/test-patch-30-dist","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bin/test-patch-30-dist?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,106 +0,0 @@\n-#!/bin/bash\n-#\n-#   Licensed under the Apache License, Version 2.0 (the \"License\");\n-#   you may not use this file except in compliance with the License.\n-#   You may obtain a copy of the License at\n-#\n-#       http://www.apache.org/licenses/LICENSE-2.0\n-#\n-#   Unless required by applicable law or agreed to in writing, software\n-#   distributed under the License is distributed on an \"AS IS\" BASIS,\n-#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-#   See the License for the specific language governing permissions and\n-#   limitations under the License.\n-\n-if [ \"${TESTPATCHDEBUG}\" == \"true\" ] ; then\n-    set -x\n-fi\n-\n-BASEDIR=$(pwd)\n-TASKNAME=\"DISTRO\"\n-OP=\"\"\n-TEMPDIR=\"\"\n-REPORTDIR=\"\"\n-SUMMARYFILE=\"\"\n-STDOUT=\"/dev/null\"\n-MVNPASSTHRU=\"\"\n-\n-###############################################################################\n-cleanupAndExit() {\n-    exit $1\n-}\n-###############################################################################\n-printUsage() {\n-    echo \"Usage: $0 --taskname | (--op=pre|post|report --tempdir=<TEMP DIR> --reportdir=<REPORT DIR> --summaryfile=<SUMMARY FILE>) [--verbose] [-D<VALUE>...] [-P<VALUE>...]\"\n-    echo\n-}\n-###############################################################################\n-parseArgs() {\n-    for i in $*\n-    do\n-        case $i in\n-        --taskname)\n-            echo ${TASKNAME}\n-            exit 0\n-            ;;\n-        --op=*)\n-            OP=${i#*=}\n-            ;;\n-        --tempdir=*)\n-            TEMPDIR=${i#*=}\n-            ;;\n-        --reportdir=*)\n-            REPORTDIR=${i#*=}\n-            ;;\n-        --summaryfile=*)\n-            SUMMARYFILE=${i#*=}\n-            ;;\n-        --verbose)\n-            STDOUT=\"/dev/stdout\"\n-            ;;\n-        -D*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        -P*)\n-            MVNPASSTHRU=\"${MVNPASSTHRU} $i\"\n-            ;;\n-        esac\n-    done\n-    if [[ \"${TASKNAME}\" == \"\" || \"${OP}\" == \"\" || \"${TEMPDIR}\" == \"\" || \"${REPORTDIR}\" == \"\" || \"${SUMMARYFILE}\" == \"\" ]] ; then\n-        echo \"Missing options\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-    if [[ \"${OP}\" != \"pre\" && \"${OP}\" != \"post\" && \"${OP}\" != \"report\" ]] ; then\n-        echo \"Invalid operation\"\n-        echo\n-        printUsage\n-        cleanupAndExit 1\n-    fi\n-}\n-###############################################################################\n-\n-parseArgs \"$@\"\n-\n-case $OP in\n-pre)\n-    ;;\n-post)\n-    mvn package assembly:single -DskipTests | tee ${REPORTDIR}/${TASKNAME}.out >> $STDOUT\n-    exitCode=${PIPESTATUS[0]}\n-    echo \"$exitCode\" >  ${TEMPDIR}/${TASKNAME}.exitCode\n-    ;;\n-report)\n-    exitCode=`cat ${TEMPDIR}/${TASKNAME}.exitCode`\n-    if [[ \"$exitCode\" != \"0\" ]] ; then\n-        echo \"{color:red}-1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-        echo \".    {color:red}-1{color} distro tarball fails with the patch\" >> $SUMMARYFILE\n-    else\n-        echo \"{color:green}+1 ${TASKNAME}{color}\" >> $SUMMARYFILE\n-        echo \".    {color:green}+1{color} distro tarball builds with the patch \" >> $SUMMARYFILE\n-    fi\n-    ;;\n-esac\n-\n-exit 0"},{"sha":"3158aac140f83444b9bf0698c044a75b78ebaaae","filename":"branch-4.3/bookkeeper-benchmark/bin/benchmark","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/bin/benchmark","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/bin/benchmark","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/bin/benchmark?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,131 +0,0 @@\n-#!/usr/bin/env bash\n-#\n-#/**\n-# * Copyright 2007 The Apache Software Foundation\n-# *\n-# * Licensed to the Apache Software Foundation (ASF) under one\n-# * or more contributor license agreements.  See the NOTICE file\n-# * distributed with this work for additional information\n-# * regarding copyright ownership.  The ASF licenses this file\n-# * to you under the Apache License, Version 2.0 (the\n-# * \"License\"); you may not use this file except in compliance\n-# * with the License.  You may obtain a copy of the License at\n-# *\n-# *     http://www.apache.org/licenses/LICENSE-2.0\n-# *\n-# * Unless required by applicable law or agreed to in writing, software\n-# * distributed under the License is distributed on an \"AS IS\" BASIS,\n-# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# * See the License for the specific language governing permissions and\n-# * limitations under the License.\n-# */\n-\n-# check if net.ipv6.bindv6only is set to 1\n-bindv6only=$(/sbin/sysctl -n net.ipv6.bindv6only 2> /dev/null)\n-if [ -n \"$bindv6only\" ] && [ \"$bindv6only\" -eq \"1\" ]\n-then\n-  echo \"Error: \\\"net.ipv6.bindv6only\\\" is set to 1 - Java networking could be broken\"\n-  echo \"For more info (the following page also applies to bookkeeper): http://wiki.apache.org/hadoop/HadoopIPv6\"\n-  exit 1\n-fi\n-\n-BINDIR=`dirname \"$0\"`\n-BENCH_HOME=`cd $BINDIR/..;pwd`\n-\n-RELEASE_JAR=`ls $BENCH_HOME/bookkeeper-benchmark-*.jar 2> /dev/null | tail -1` \n-if [ $? == 0 ]; then\n-    BENCHMARK_JAR=$RELEASE_JAR\n-fi\n-\n-BUILT_JAR=`ls $BENCH_HOME/target/bookkeeper-benchmark-*.jar 2> /dev/null | tail -1`\n-if [ $? != 0 ] && [ ! -e \"$BENCHMARK_JAR\" ]; then \n-    echo \"\\nCouldn't find benchmark jar.\";\n-    echo \"Make sure you've run 'mvn package'\\n\";\n-    exit 1;\n-elif [ -e \"$BUILT_JAR\" ]; then\n-    BENCHMARK_JAR=$BUILT_JAR\n-fi\n-\n-benchmark_help() {\n-    cat <<EOF\n-Usage: $0 <command>\n-where command is one of:\n-    writes              Benchmark throughput and latency for writes\n-    reads               Benchmark throughput and latency for reads\n-    bookie              Benchmark an individual bookie\n-    help                This help message\n-\n-use -help with individual commands for more options. For example,\n-   $0 writes -help\n-\n-or command is the full name of a class with a defined main() method.\n-\n-Environment variables:\n-   BENCHMARK_LOG_CONF        Log4j configuration file (default: conf/log4j.properties)\n-   BENCHMARK_EXTRA_OPTS      Extra options to be passed to the jvm\n-   BENCHMARK_EXTRA_CLASSPATH Add extra paths to the bookkeeper classpath\n-\n-EOF\n-}\n-\n-add_maven_deps_to_classpath() {\n-    MVN=\"mvn\"\n-    if [ \"$MAVEN_HOME\" != \"\" ]; then\n-\tMVN=${MAVEN_HOME}/bin/mvn\n-    fi\n-    \n-    # Need to generate classpath from maven pom. This is costly so generate it\n-    # and cache it. Save the file into our target dir so a mvn clean will get\n-    # clean it up and force us create a new one.\n-    f=\"${BENCH_HOME}/target/cached_classpath.txt\"\n-    if [ ! -f \"${f}\" ]\n-    then\n-\t${MVN} -f \"${BENCH_HOME}/pom.xml\" dependency:build-classpath -Dmdep.outputFile=\"${f}\" &> /dev/null\n-    fi\n-    BENCHMARK_CLASSPATH=${CLASSPATH}:`cat \"${f}\"`\n-}\n-\n-if [ -d \"$BENCH_HOME/lib\" ]; then\n-    for i in $BENCH_HOME/lib/*.jar; do\n-\tBENCHMARK_CLASSPATH=$BENCHMARK_CLASSPATH:$i\n-    done\n-else\n-    add_maven_deps_to_classpath\n-fi\n-\n-# if no args specified, show usage\n-if [ $# = 0 ]; then\n-    benchmark_help;\n-    exit 1;\n-fi\n-\n-# get arguments\n-COMMAND=$1\n-shift\n-\n-BENCHMARK_CLASSPATH=\"$BENCHMARK_JAR:$BENCHMARK_CLASSPATH:$BENCHMARK_EXTRA_CLASSPATH\"\n-BENCHMARK_LOG_CONF=${BENCHMARK_LOG_CONF:-$BENCH_HOME/conf/log4j.properties}\n-\n-if [ \"$BENCHMARK_LOG_CONF\" != \"\" ]; then\n-    BENCHMARK_CLASSPATH=\"`dirname $BENCHMARK_LOG_CONF`:$BENCHMARK_CLASSPATH\"\n-    OPTS=\"$OPTS -Dlog4j.configuration=`basename $BENCHMARK_LOG_CONF`\"\n-fi\n-OPTS=\"-cp $BENCHMARK_CLASSPATH $OPTS $BENCHMARK_EXTRA_OPTS\"\n-\n-OPTS=\"$OPTS $BENCHMARK_EXTRA_OPTS\"\n-\n-# Disable ipv6 as it can cause issues\n-OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n-\n-if [ $COMMAND == \"writes\" ]; then\n-    exec java $OPTS org.apache.bookkeeper.benchmark.BenchThroughputLatency $@\n-elif [ $COMMAND == \"reads\" ]; then\n-    exec java $OPTS org.apache.bookkeeper.benchmark.BenchReadThroughputLatency $@\n-elif [ $COMMAND == \"bookie\" ]; then\n-    exec java $OPTS org.apache.bookkeeper.benchmark.BenchBookie $@\n-elif [ $COMMAND == \"help\" ]; then\n-    benchmark_help;\n-else\n-    exec java $OPTS $COMMAND $@\n-fi\n-"},{"sha":"79e0db26a66e74fd6f6908e1e27962e34e5d9c04","filename":"branch-4.3/bookkeeper-benchmark/conf/log4j.properties","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/conf/log4j.properties?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,73 +0,0 @@\n-#\n-# \n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-# \n-#   http://www.apache.org/licenses/LICENSE-2.0\n-# \n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-# \n-#\n-\n-#\n-# Bookkeeper Logging Configuration\n-#\n-\n-# Format is \"<default threshold> (, <appender>)+\n-\n-# DEFAULT: console appender only\n-log4j.rootLogger=ERROR, CONSOLE\n-\n-# Example with rolling log file\n-#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n-\n-# Example with rolling log file and tracing\n-#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n-\n-#\n-# Log INFO level and above messages to the console\n-#\n-log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n-log4j.appender.CONSOLE.Threshold=INFO\n-log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-log4j.logger.org.apache.bookkeeper.benchmark=INFO\n-\n-#\n-# Add ROLLINGFILE to rootLogger to get log file output\n-#    Log DEBUG level and above messages to a log file\n-log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n-log4j.appender.ROLLINGFILE.Threshold=DEBUG\n-log4j.appender.ROLLINGFILE.File=bookkeeper-benchmark.log\n-log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-\n-# Max log file size of 10MB\n-log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n-# uncomment the next line to limit number of backup files\n-#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n-\n-log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n-\n-\n-#\n-# Add TRACEFILE to rootLogger to get log file output\n-#    Log DEBUG level and above messages to a log file\n-log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n-log4j.appender.TRACEFILE.Threshold=TRACE\n-log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n-\n-log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n-### Notice we are including log4j's NDC here (%x)\n-log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"a303d27b91cd455ac5a5ab4ddb4afe6804604bbb","filename":"branch-4.3/bookkeeper-benchmark/pom.xml","status":"removed","additions":0,"deletions":160,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/pom.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,160 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n-  <modelVersion>4.0.0</modelVersion>\n-  <parent>\n-    <artifactId>bookkeeper</artifactId>\n-    <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.3.0</version>\n-  </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n-  <artifactId>bookkeeper-benchmark</artifactId>\n-  <name>bookkeeper-benchmark</name>\n-  <url>http://maven.apache.org</url>\n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-  </properties>\n-  <build>\n-    <plugins>\n-      <plugin>\n-        <artifactId>maven-assembly-plugin</artifactId>\n-        <version>2.2.1</version>\n-        <configuration>\n-\t  <skipAssembly>true</skipAssembly>\n-        </configuration>\n-      </plugin>\n-      <plugin>\n-      \t<groupId>org.apache.maven.plugins</groupId>\n-\t<artifactId>maven-surefire-plugin</artifactId>\n-\t<configuration>\n-          <systemPropertyVariables>\n-            <test.latency.file>target/latencyDump.dat</test.latency.file>\n-          </systemPropertyVariables>\n-\t</configuration>\n-      </plugin>\n-    </plugins>\n-  </build>\n-  <dependencies>\n-    <dependency>\n-      <groupId>junit</groupId>\n-      <artifactId>junit</artifactId>\n-      <version>4.8.1</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.slf4j</groupId>\n-      <artifactId>slf4j-api</artifactId>\n-      <version>1.6.4</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.slf4j</groupId>\n-      <artifactId>slf4j-log4j12</artifactId>\n-      <version>1.6.4</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.zookeeper</groupId>\n-      <artifactId>zookeeper</artifactId>\n-      <version>${zookeeper.version}</version>\n-      <type>jar</type>\n-      <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.zookeeper</groupId>\n-      <artifactId>zookeeper</artifactId>\n-      <version>${zookeeper.version}</version>\n-      <type>test-jar</type>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>io.netty</groupId>\n-      <artifactId>netty</artifactId>\n-      <version>${netty.version}</version>\n-      <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server</artifactId>\n-      <version>${project.parent.version}</version>\n-      <scope>compile</scope>\n-      <type>jar</type>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server</artifactId>\n-      <version>${project.parent.version}</version>\n-      <scope>test</scope>\n-      <type>test-jar</type>\n-    </dependency>\n-    <!--\n-\tAnnoying dependency we need to include because\n-\tzookeeper uses log4j and so we transatively do, but\n-\tlog4j has some dependencies which aren't in the \n-\tdefault maven repositories\n-    //-->\n-    <dependency>\n-      <groupId>log4j</groupId>\n-      <artifactId>log4j</artifactId>\n-      <version>1.2.15</version>\n-      <exclusions>\n-\t<exclusion>\n-\t  <groupId>javax.mail</groupId>\n-\t  <artifactId>mail</artifactId>\n-\t</exclusion>\n-\t<exclusion>\n-\t  <groupId>javax.jms</groupId>\n-\t  <artifactId>jms</artifactId>\n-\t</exclusion>\n-\t<exclusion>\n-\t  <groupId>com.sun.jdmk</groupId>\n-\t  <artifactId>jmxtools</artifactId>\n-\t</exclusion>\n-\t<exclusion>\n-\t  <groupId>com.sun.jmx</groupId>\n-\t  <artifactId>jmxri</artifactId>\n-\t</exclusion>\n-      </exclusions>\n-    </dependency>\n-    <dependency>\n-      <groupId>commons-cli</groupId>\n-      <artifactId>commons-cli</artifactId>\n-      <version>1.2</version>\n-    </dependency>\n-    <dependency>\n-       <groupId>org.apache.hadoop</groupId>\n-       <artifactId>hadoop-common</artifactId>\n-       <version>0.23.1</version>\n-       <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.hadoop</groupId>\n-      <artifactId>hadoop-hdfs</artifactId>\n-      <version>0.23.1</version>\n-      <scope>compile</scope>\n-      <!-- commons-daemon has a malformed pom, which can cause the build to fail in an\n-           environment which uses an artifactory cache. -->\n-      <exclusions>\n-        <exclusion>\n-          <groupId>commons-daemon</groupId>\n-          <artifactId>commons-daemon</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-  </dependencies>\n-</project>"},{"sha":"258a3fb606b3b47d52b8ebfd8ca4024768a31ab6","filename":"branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","status":"removed","additions":0,"deletions":212,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,212 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.benchmark;\n-\n-import java.io.IOException;\n-import java.util.concurrent.Executors;\n-\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.proto.BookieClient;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n-import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.PosixParser;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.zookeeper.KeeperException;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class BenchBookie {\n-    static final Logger LOG = LoggerFactory.getLogger(BenchBookie.class);\n-\n-    static class LatencyCallback implements WriteCallback {\n-        boolean complete;\n-        @Override\n-        synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n-                BookieSocketAddress addr, Object ctx) {\n-            if (rc != 0) {\n-                LOG.error(\"Got error \" + rc);\n-            }\n-            complete = true;\n-            notifyAll();\n-        }\n-        synchronized public void resetComplete() {\n-            complete = false;\n-        }\n-        synchronized public void waitForComplete() throws InterruptedException {\n-            while(!complete) {\n-                wait();\n-            }\n-        }\n-    }\n-\n-    static class ThroughputCallback implements WriteCallback {\n-        int count;\n-        int waitingCount = Integer.MAX_VALUE;\n-        synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n-                BookieSocketAddress addr, Object ctx) {\n-            if (rc != 0) {\n-                LOG.error(\"Got error \" + rc);\n-            }\n-            count++;\n-            if (count >= waitingCount) {\n-                notifyAll();\n-            }\n-        }\n-        synchronized public void waitFor(int count) throws InterruptedException {\n-            while(this.count < count) {\n-                waitingCount = count;\n-                wait(1000);\n-            }\n-            waitingCount = Integer.MAX_VALUE;\n-        }\n-    }\n-\n-    private static long getValidLedgerId(String zkServers)\n-            throws IOException, BKException, KeeperException, InterruptedException {\n-        BookKeeper bkc = null;\n-        LedgerHandle lh = null;\n-        long id = 0;\n-        try {\n-            bkc =new BookKeeper(zkServers);\n-            lh = bkc.createLedger(1, 1, BookKeeper.DigestType.CRC32,\n-                                  new byte[20]);\n-            id = lh.getId();\n-            return id;\n-        } finally {\n-            if (lh != null) { lh.close(); }\n-            if (bkc != null) { bkc.close(); }\n-        }\n-    }\n-    /**\n-     * @param args\n-     * @throws InterruptedException\n-     */\n-    public static void main(String[] args)\n-            throws InterruptedException, ParseException, IOException,\n-            BKException, KeeperException {\n-        Options options = new Options();\n-        options.addOption(\"host\", true, \"Hostname or IP of bookie to benchmark\");\n-        options.addOption(\"port\", true, \"Port of bookie to benchmark (default 3181)\");\n-        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, (default \\\"localhost:2181\\\")\");\n-        options.addOption(\"size\", true, \"Size of message to send, in bytes (default 1024)\");\n-        options.addOption(\"help\", false, \"This message\");\n-\n-        CommandLineParser parser = new PosixParser();\n-        CommandLine cmd = parser.parse(options, args);\n-\n-        if (cmd.hasOption(\"help\") || !cmd.hasOption(\"host\")) {\n-            HelpFormatter formatter = new HelpFormatter();\n-            formatter.printHelp(\"BenchBookie <options>\", options);\n-            System.exit(-1);\n-        }\n-\n-        String addr = cmd.getOptionValue(\"host\");\n-        int port = Integer.valueOf(cmd.getOptionValue(\"port\", \"3181\"));\n-        int size = Integer.valueOf(cmd.getOptionValue(\"size\", \"1024\"));\n-        String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n-\n-\n-\n-        ClientSocketChannelFactory channelFactory\n-            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n-                                                .newCachedThreadPool());\n-        OrderedSafeExecutor executor = new OrderedSafeExecutor(1, \"BenchBookieClientScheduler\");\n-\n-        ClientConfiguration conf = new ClientConfiguration();\n-        BookieClient bc = new BookieClient(conf, channelFactory, executor);\n-        LatencyCallback lc = new LatencyCallback();\n-\n-        ThroughputCallback tc = new ThroughputCallback();\n-        int warmUpCount = 999;\n-\n-        long ledger = getValidLedgerId(servers);\n-        for(long entry = 0; entry < warmUpCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n-            toSend.resetReaderIndex();\n-            toSend.resetWriterIndex();\n-            toSend.writeLong(ledger);\n-            toSend.writeLong(entry);\n-            toSend.writerIndex(toSend.capacity());\n-            bc.addEntry(new BookieSocketAddress(addr, port), ledger, new byte[20],\n-                        entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n-        }\n-        LOG.info(\"Waiting for warmup\");\n-        tc.waitFor(warmUpCount);\n-\n-        ledger = getValidLedgerId(servers);\n-        LOG.info(\"Benchmarking latency\");\n-        int entryCount = 5000;\n-        long startTime = System.nanoTime();\n-        for(long entry = 0; entry < entryCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n-            toSend.resetReaderIndex();\n-            toSend.resetWriterIndex();\n-            toSend.writeLong(ledger);\n-            toSend.writeLong(entry);\n-            toSend.writerIndex(toSend.capacity());\n-            lc.resetComplete();\n-            bc.addEntry(new BookieSocketAddress(addr, port), ledger, new byte[20],\n-                        entry, toSend, lc, null, BookieProtocol.FLAG_NONE);\n-            lc.waitForComplete();\n-        }\n-        long endTime = System.nanoTime();\n-        LOG.info(\"Latency: \" + (((double)(endTime-startTime))/((double)entryCount))/1000000.0);\n-\n-        entryCount = 50000;\n-\n-        ledger = getValidLedgerId(servers);\n-        LOG.info(\"Benchmarking throughput\");\n-        startTime = System.currentTimeMillis();\n-        tc = new ThroughputCallback();\n-        for(long entry = 0; entry < entryCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n-            toSend.resetReaderIndex();\n-            toSend.resetWriterIndex();\n-            toSend.writeLong(ledger);\n-            toSend.writeLong(entry);\n-            toSend.writerIndex(toSend.capacity());\n-            bc.addEntry(new BookieSocketAddress(addr, port), ledger, new byte[20],\n-                        entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n-        }\n-        tc.waitFor(entryCount);\n-        endTime = System.currentTimeMillis();\n-        LOG.info(\"Throughput: \" + ((long)entryCount)*1000/(endTime-startTime));\n-\n-        bc.close();\n-        channelFactory.releaseExternalResources();\n-        executor.shutdown();\n-    }\n-\n-}"},{"sha":"d5baaa400fa42feda40d91e3cff8de8b987eb0da","filename":"branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","status":"removed","additions":0,"deletions":274,"changes":274,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,274 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.benchmark;\n-\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n-\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher.Event;\n-\n-import java.util.Enumeration;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.PosixParser;\n-import org.apache.commons.cli.ParseException;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class BenchReadThroughputLatency {\n-    static final Logger LOG = LoggerFactory.getLogger(BenchReadThroughputLatency.class);\n-\n-    private static final Pattern LEDGER_PATTERN = Pattern.compile(\"L([0-9]+)$\");\n-\n-    private static final Comparator<String> ZK_LEDGER_COMPARE = new Comparator<String>() {\n-        public int compare(String o1, String o2) {\n-            try {\n-                Matcher m1 = LEDGER_PATTERN.matcher(o1);\n-                Matcher m2 = LEDGER_PATTERN.matcher(o2);\n-                if (m1.find() && m2.find()) {\n-                    return Integer.valueOf(m1.group(1))\n-                        - Integer.valueOf(m2.group(1));\n-                } else {\n-                    return o1.compareTo(o2);\n-                }\n-            } catch (Throwable t) {\n-                return o1.compareTo(o2);\n-            }\n-        }\n-    };\n-\n-    private static void readLedger(ClientConfiguration conf, long ledgerId, byte[] passwd) {\n-        LOG.info(\"Reading ledger {}\", ledgerId);\n-        BookKeeper bk = null;\n-        long time = 0;\n-        long entriesRead = 0;\n-        long lastRead = 0;\n-        int nochange = 0;\n-\n-        long absoluteLimit = 5000000;\n-        LedgerHandle lh = null;\n-        try {\n-            bk = new BookKeeper(conf);\n-            while (true) {\n-                lh = bk.openLedgerNoRecovery(ledgerId, BookKeeper.DigestType.CRC32, \n-                                             passwd);\n-                long lastConfirmed = Math.min(lh.getLastAddConfirmed(), absoluteLimit);\n-                if (lastConfirmed == lastRead) {\n-                    nochange++;\n-                    if (nochange == 10) {\n-                        break;\n-                    } else {\n-                        Thread.sleep(1000);\n-                        continue;\n-                    }\n-                } else {\n-                    nochange = 0;\n-                }\n-                long starttime = System.nanoTime();\n-\n-                while (lastRead < lastConfirmed) {\n-                    long nextLimit = lastRead + 100000;\n-                    long readTo = Math.min(nextLimit, lastConfirmed);\n-                    Enumeration<LedgerEntry> entries = lh.readEntries(lastRead+1, readTo);\n-                    lastRead = readTo;\n-                    while (entries.hasMoreElements()) {\n-                        LedgerEntry e = entries.nextElement();\n-                        entriesRead++;\n-                        if ((entriesRead % 10000) == 0) {\n-                            LOG.info(\"{} entries read\", entriesRead);\n-                        }\n-                    }\n-                }\n-                long endtime = System.nanoTime();\n-                time += endtime - starttime;\n-\n-                lh.close();\n-                lh = null;\n-                Thread.sleep(1000);\n-            }\n-        } catch (InterruptedException ie) {\n-            // ignore\n-        } catch (Exception e ) {\n-            LOG.error(\"Exception in reader\", e);\n-        } finally {\n-            LOG.info(\"Read {} in {}ms\", entriesRead, time/1000/1000);\n-\n-            try {\n-                if (lh != null) {\n-                    lh.close();\n-                }\n-                if (bk != null) {\n-                    bk.close();\n-                }\n-            } catch (Exception e) {\n-                LOG.error(\"Exception closing stuff\", e);\n-            }\n-        }\n-    }\n-\n-    private static void usage(Options options) {\n-        HelpFormatter formatter = new HelpFormatter();\n-        formatter.printHelp(\"BenchReadThroughputLatency <options>\", options);\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static void main(String[] args) throws Exception {\n-        Options options = new Options();\n-        options.addOption(\"ledger\", true, \"Ledger to read. If empty, read all ledgers which come available. \" \n-                          + \" Cannot be used with -listen\");\n-        options.addOption(\"listen\", true, \"Listen for creation of <arg> ledgers, and read each one fully\");\n-        options.addOption(\"password\", true, \"Password used to access ledgers (default 'benchPasswd')\");\n-        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n-        options.addOption(\"sockettimeout\", true, \"Socket timeout for bookkeeper client. In seconds. Default 5\");\n-        options.addOption(\"help\", false, \"This message\");\n-\n-        CommandLineParser parser = new PosixParser();\n-        CommandLine cmd = parser.parse(options, args);\n-\n-        if (cmd.hasOption(\"help\")) {\n-            usage(options);\n-            System.exit(-1);\n-        }\n-\n-        final String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n-        final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes(UTF_8);\n-        final int sockTimeout = Integer.valueOf(cmd.getOptionValue(\"sockettimeout\", \"5\"));\n-        if (cmd.hasOption(\"ledger\") && cmd.hasOption(\"listen\")) {\n-            LOG.error(\"Cannot used -ledger and -listen together\");\n-            usage(options);\n-            System.exit(-1);\n-        }\n-\n-        final AtomicInteger ledger = new AtomicInteger(0);\n-        final AtomicInteger numLedgers = new AtomicInteger(0);\n-        if (cmd.hasOption(\"ledger\")) {\n-            ledger.set(Integer.valueOf(cmd.getOptionValue(\"ledger\")));\n-        } else if (cmd.hasOption(\"listen\")) {\n-            numLedgers.set(Integer.valueOf(cmd.getOptionValue(\"listen\")));\n-        } else {\n-            LOG.error(\"You must use -ledger or -listen\");\n-            usage(options);\n-            System.exit(-1);\n-        }\n-\n-        final CountDownLatch shutdownLatch = new CountDownLatch(1);\n-        final CountDownLatch connectedLatch = new CountDownLatch(1);\n-        final String nodepath = String.format(\"/ledgers/L%010d\", ledger.get());\n-\n-        final ClientConfiguration conf = new ClientConfiguration();\n-        conf.setReadTimeout(sockTimeout).setZkServers(servers);\n-\n-\n-        final ZooKeeper zk = new ZooKeeper(servers, 3000, new Watcher() {\n-                public void process(WatchedEvent event) {\n-                    if (event.getState() == Event.KeeperState.SyncConnected\n-                            && event.getType() == Event.EventType.None) {\n-                        connectedLatch.countDown();\n-                    }\n-                }\n-            });\n-        try {\n-            zk.register(new Watcher() {\n-                    public void process(WatchedEvent event) {\n-                        try {\n-                            if (event.getState() == Event.KeeperState.SyncConnected \n-                                && event.getType() == Event.EventType.None) {\n-                                connectedLatch.countDown();\n-                            } else if (event.getType() == Event.EventType.NodeCreated\n-                                       && event.getPath().equals(nodepath)) {\n-                                readLedger(conf, ledger.get(), passwd);\n-                                shutdownLatch.countDown();\n-                            } else if (event.getType() == Event.EventType.NodeChildrenChanged) {\n-                                if (numLedgers.get() < 0) {\n-                                    return;\n-                                }\n-                                List<String> children = zk.getChildren(\"/ledgers\", true);\n-                                List<String> ledgers = new ArrayList<String>();\n-                                for (String child : children) {\n-                                    if (LEDGER_PATTERN.matcher(child).find()) {\n-                                        ledgers.add(child);\n-                                    }\n-                                }\n-                                Collections.sort(ledgers, ZK_LEDGER_COMPARE);\n-                                String last = ledgers.get(ledgers.size() - 1);\n-                                final Matcher m = LEDGER_PATTERN.matcher(last);\n-                                if (m.find()) {\n-                                    int ledgersLeft = numLedgers.decrementAndGet();\n-                                    Thread t = new Thread() {\n-                                            public void run() {\n-                                                readLedger(conf, Long.valueOf(m.group(1)), passwd);\n-                                            }\n-                                        };\n-                                    t.start();\n-                                    if (ledgersLeft <= 0) {\n-                                        shutdownLatch.countDown();\n-                                    }\n-                                } else {\n-                                    LOG.error(\"Cant file ledger id in {}\", last);\n-                                }\n-                            } else {\n-                                LOG.warn(\"Unknown event {}\", event);\n-                            }\n-                        } catch (Exception e) {\n-                            LOG.error(\"Exception in watcher\", e);\n-                        }\n-                    }\n-                });\n-            connectedLatch.await();\n-            if (ledger.get() != 0) {\n-                if (zk.exists(nodepath, true) != null) {\n-                    readLedger(conf, ledger.get(), passwd);\n-                    shutdownLatch.countDown();\n-                } else {\n-                    LOG.info(\"Watching for creation of\" + nodepath);\n-                }\n-            } else {\n-                zk.getChildren(\"/ledgers\", true);\n-            }\n-            shutdownLatch.await();\n-            LOG.info(\"Shutting down\");\n-        } finally {\n-            zk.close();\n-        }\n-    }\n-}"},{"sha":"4a21792f54d99045547b0bc8b582f21659b4520a","filename":"branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","status":"removed","additions":0,"deletions":461,"changes":461,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,461 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.benchmark;\n-\n-import java.io.BufferedOutputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Random;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.ZooDefs;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.Watcher.Event.EventType;\n-import org.apache.zookeeper.Watcher.Event.KeeperState;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-public class BenchThroughputLatency implements AddCallback, Runnable {\n-    static final Logger LOG = LoggerFactory.getLogger(BenchThroughputLatency.class);\n-\n-    BookKeeper bk;\n-    LedgerHandle lh[];\n-    AtomicLong counter;\n-\n-    Semaphore sem;\n-    int numberOfLedgers = 1;\n-    final int sendLimit;\n-    final long latencies[];\n-\n-    static class Context {\n-        long localStartTime;\n-        long id;\n-\n-        Context(long id, long time){\n-            this.id = id;\n-            this.localStartTime = time;\n-        }\n-    }\n-\n-    public BenchThroughputLatency(int ensemble, int writeQuorumSize, int ackQuorumSize, byte[] passwd,\n-            int numberOfLedgers, int sendLimit, ClientConfiguration conf)\n-            throws KeeperException, IOException, InterruptedException {\n-        this.sem = new Semaphore(conf.getThrottleValue());\n-        bk = new BookKeeper(conf);\n-        this.counter = new AtomicLong(0);\n-        this.numberOfLedgers = numberOfLedgers;\n-        this.sendLimit = sendLimit;\n-        this.latencies = new long[sendLimit];\n-        try{\n-            lh = new LedgerHandle[this.numberOfLedgers];\n-\n-            for(int i = 0; i < this.numberOfLedgers; i++) {\n-                lh[i] = bk.createLedger(ensemble, writeQuorumSize,\n-                                        ackQuorumSize,\n-                                        BookKeeper.DigestType.CRC32,\n-                                        passwd);\n-                LOG.debug(\"Ledger Handle: \" + lh[i].getId());\n-            }\n-        } catch (BKException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    Random rand = new Random();\n-    public void close() throws InterruptedException, BKException {\n-        for(int i = 0; i < numberOfLedgers; i++) {\n-            lh[i].close();\n-        }\n-        bk.close();\n-    }\n-\n-    long previous = 0;\n-    byte bytes[];\n-\n-    void setEntryData(byte data[]) {\n-        bytes = data;\n-    }\n-\n-    int lastLedger = 0;\n-    private int getRandomLedger() {\n-         return rand.nextInt(numberOfLedgers);\n-    }\n-\n-    int latencyIndex = -1;\n-    AtomicLong completedRequests = new AtomicLong(0);\n-\n-    long duration = -1;\n-    synchronized public long getDuration() {\n-        return duration;\n-    }\n-\n-    public void run() {\n-        LOG.info(\"Running...\");\n-        long start = previous = System.currentTimeMillis();\n-\n-        int sent = 0;\n-\n-        Thread reporter = new Thread() {\n-                public void run() {\n-                    try {\n-                        while(true) {\n-                            Thread.sleep(1000);\n-                            LOG.info(\"ms: {} req: {}\", System.currentTimeMillis(), completedRequests.getAndSet(0));\n-                        }\n-                    } catch (InterruptedException ie) {\n-                        LOG.info(\"Caught interrupted exception, going away\");\n-                    }\n-                }\n-            };\n-        reporter.start();\n-        long beforeSend = System.nanoTime();\n-\n-        while(!Thread.currentThread().isInterrupted() && sent < sendLimit) {\n-            try {\n-                sem.acquire();\n-                if (sent == 10000) {\n-                    long afterSend = System.nanoTime();\n-                    long time = afterSend - beforeSend;\n-                    LOG.info(\"Time to send first batch: {}s {}ns \",\n-                             time/1000/1000/1000, time);\n-                }\n-            } catch (InterruptedException e) {\n-                break;\n-            }\n-\n-            final int index = getRandomLedger();\n-            LedgerHandle h = lh[index];\n-            if (h == null) {\n-                LOG.error(\"Handle \" + index + \" is null!\");\n-            } else {\n-                long nanoTime = System.nanoTime();\n-                lh[index].asyncAddEntry(bytes, this, new Context(sent, nanoTime));\n-                counter.incrementAndGet();\n-            }\n-            sent++;\n-        }\n-        LOG.info(\"Sent: \"  + sent);\n-        try {\n-            int i = 0;\n-            while(this.counter.get() > 0) {\n-                Thread.sleep(1000);\n-                i++;\n-                if (i > 30) {\n-                    break;\n-                }\n-            }\n-        } catch(InterruptedException e) {\n-            LOG.error(\"Interrupted while waiting\", e);\n-        }\n-        synchronized(this) {\n-            duration = System.currentTimeMillis() - start;\n-        }\n-        throughput = sent*1000/getDuration();\n-\n-        reporter.interrupt();\n-        try {\n-            reporter.join();\n-        } catch (InterruptedException ie) {\n-            // ignore\n-        }\n-        LOG.info(\"Finished processing in ms: \" + getDuration() + \" tp = \" + throughput);\n-    }\n-\n-    long throughput = -1;\n-    public long getThroughput() {\n-        return throughput;\n-    }\n-\n-    long threshold = 20000;\n-    long runningAverageCounter = 0;\n-    long totalTime = 0;\n-    @Override\n-    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-        Context context = (Context) ctx;\n-\n-        // we need to use the id passed in the context in the case of\n-        // multiple ledgers, and it works even with one ledger\n-        entryId = context.id;\n-        long newTime = System.nanoTime() - context.localStartTime;\n-\n-        sem.release();\n-        counter.decrementAndGet();\n-\n-        if (rc == 0) {\n-            latencies[(int)entryId] = newTime;\n-            completedRequests.incrementAndGet();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static void main(String[] args)\n-            throws KeeperException, IOException, InterruptedException, ParseException, BKException {\n-        Options options = new Options();\n-        options.addOption(\"time\", true, \"Running time (seconds), default 60\");\n-        options.addOption(\"entrysize\", true, \"Entry size (bytes), default 1024\");\n-        options.addOption(\"ensemble\", true, \"Ensemble size, default 3\");\n-        options.addOption(\"quorum\", true, \"Quorum size, default 2\");\n-        options.addOption(\"ackQuorum\", true, \"Ack quorum size, default is same as quorum\");\n-        options.addOption(\"throttle\", true, \"Max outstanding requests, default 10000\");\n-        options.addOption(\"ledgers\", true, \"Number of ledgers, default 1\");\n-        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n-        options.addOption(\"password\", true, \"Password used to create ledgers (default 'benchPasswd')\");\n-        options.addOption(\"coordnode\", true, \"Coordination znode for multi client benchmarks (optional)\");\n-        options.addOption(\"timeout\", true, \"Number of seconds after which to give up\");\n-        options.addOption(\"sockettimeout\", true, \"Socket timeout for bookkeeper client. In seconds. Default 5\");\n-        options.addOption(\"skipwarmup\", false, \"Skip warm up, default false\");\n-        options.addOption(\"sendlimit\", true, \"Max number of entries to send. Default 20000000\");\n-        options.addOption(\"latencyFile\", true, \"File to dump latencies. Default is latencyDump.dat\");\n-        options.addOption(\"help\", false, \"This message\");\n-\n-        CommandLineParser parser = new PosixParser();\n-        CommandLine cmd = parser.parse(options, args);\n-\n-        if (cmd.hasOption(\"help\")) {\n-            HelpFormatter formatter = new HelpFormatter();\n-            formatter.printHelp(\"BenchThroughputLatency <options>\", options);\n-            System.exit(-1);\n-        }\n-\n-        long runningTime = Long.valueOf(cmd.getOptionValue(\"time\", \"60\"));\n-        String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n-        int entrysize = Integer.valueOf(cmd.getOptionValue(\"entrysize\", \"1024\"));\n-\n-        int ledgers = Integer.valueOf(cmd.getOptionValue(\"ledgers\", \"1\"));\n-        int ensemble = Integer.valueOf(cmd.getOptionValue(\"ensemble\", \"3\"));\n-        int quorum = Integer.valueOf(cmd.getOptionValue(\"quorum\", \"2\"));\n-        int ackQuorum = quorum;\n-        if (cmd.hasOption(\"ackQuorum\")) {\n-            ackQuorum = Integer.valueOf(cmd.getOptionValue(\"ackQuorum\"));\n-        }\n-        int throttle = Integer.valueOf(cmd.getOptionValue(\"throttle\", \"10000\"));\n-        int sendLimit = Integer.valueOf(cmd.getOptionValue(\"sendlimit\", \"20000000\"));\n-\n-        final int sockTimeout = Integer.valueOf(cmd.getOptionValue(\"sockettimeout\", \"5\"));\n-\n-        String coordinationZnode = cmd.getOptionValue(\"coordnode\");\n-        final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes(UTF_8);\n-\n-        String latencyFile = cmd.getOptionValue(\"latencyFile\", \"latencyDump.dat\");\n-\n-        Timer timeouter = new Timer();\n-        if (cmd.hasOption(\"timeout\")) {\n-            final long timeout = Long.valueOf(cmd.getOptionValue(\"timeout\", \"360\")) * 1000;\n-\n-            timeouter.schedule(new TimerTask() {\n-                    public void run() {\n-                        System.err.println(\"Timing out benchmark after \" + timeout + \"ms\");\n-                        System.exit(-1);\n-                    }\n-                }, timeout);\n-        }\n-\n-        LOG.warn(\"(Parameters received) running time: \" + runningTime +\n-                \", entry size: \" + entrysize + \", ensemble size: \" + ensemble +\n-                \", quorum size: \" + quorum +\n-                \", throttle: \" + throttle +\n-                \", number of ledgers: \" + ledgers +\n-                \", zk servers: \" + servers +\n-                \", latency file: \" + latencyFile);\n-\n-        long totalTime = runningTime*1000;\n-\n-        // Do a warmup run\n-        Thread thread;\n-\n-        byte data[] = new byte[entrysize];\n-        Arrays.fill(data, (byte)'x');\n-\n-        ClientConfiguration conf = new ClientConfiguration();\n-        conf.setThrottleValue(throttle).setReadTimeout(sockTimeout).setZkServers(servers);\n-\n-        if (!cmd.hasOption(\"skipwarmup\")) {\n-            long throughput;\n-            LOG.info(\"Starting warmup\");\n-\n-            throughput = warmUp(data, ledgers, ensemble, quorum, passwd, conf);\n-            LOG.info(\"Warmup tp: \" + throughput);\n-            LOG.info(\"Warmup phase finished\");\n-        }\n-\n-\n-        // Now do the benchmark\n-        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, ackQuorum,\n-                passwd, ledgers, sendLimit, conf);\n-        bench.setEntryData(data);\n-        thread = new Thread(bench);\n-        ZooKeeper zk = null;\n-\n-        if (coordinationZnode != null) {\n-            final CountDownLatch connectLatch = new CountDownLatch(1);\n-            zk = new ZooKeeper(servers, 15000, new Watcher() {\n-                    @Override\n-                    public void process(WatchedEvent event) {\n-                        if (event.getState() == KeeperState.SyncConnected) {\n-                            connectLatch.countDown();\n-                        }\n-                    }});\n-            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n-                LOG.error(\"Couldn't connect to zookeeper at \" + servers);\n-                zk.close();\n-                System.exit(-1);\n-            }\n-\n-            final CountDownLatch latch = new CountDownLatch(1);\n-            LOG.info(\"Waiting for \" + coordinationZnode);\n-            if (zk.exists(coordinationZnode, new Watcher() {\n-                @Override\n-                public void process(WatchedEvent event) {\n-                    if (event.getType() == EventType.NodeCreated) {\n-                        latch.countDown();\n-                    }\n-                }}) != null) {\n-                latch.countDown();\n-            }\n-            latch.await();\n-            LOG.info(\"Coordination znode created\");\n-        }\n-        thread.start();\n-        Thread.sleep(totalTime);\n-        thread.interrupt();\n-        thread.join();\n-\n-        LOG.info(\"Calculating percentiles\");\n-\n-        int numlat = 0;\n-        for(int i = 0; i < bench.latencies.length; i++) {\n-            if (bench.latencies[i] > 0) {\n-                numlat++;\n-            }\n-        }\n-        int numcompletions = numlat;\n-        numlat = Math.min(bench.sendLimit, numlat);\n-        long[] latency = new long[numlat];\n-        int j =0;\n-        for(int i = 0; i < bench.latencies.length && j < numlat; i++) {\n-            if (bench.latencies[i] > 0) {\n-                latency[j++] = bench.latencies[i];\n-            }\n-        }\n-        Arrays.sort(latency);\n-\n-        long tp = (long)((double)(numcompletions*1000.0)/(double)bench.getDuration());\n-\n-        LOG.info(numcompletions + \" completions in \" + bench.getDuration() + \" milliseconds: \" + tp + \" ops/sec\");\n-\n-        if (zk != null) {\n-            zk.create(coordinationZnode + \"/worker-\",\n-                      (\"tp \" + tp + \" duration \" + bench.getDuration()).getBytes(UTF_8),\n-                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n-            zk.close();\n-        }\n-\n-        // dump the latencies for later debugging (it will be sorted by entryid)\n-        OutputStream fos = new BufferedOutputStream(new FileOutputStream(latencyFile));\n-\n-        for(Long l: latency) {\n-            fos.write((Long.toString(l)+\"\\t\"+(l/1000000)+ \"ms\\n\").getBytes(UTF_8));\n-        }\n-        fos.flush();\n-        fos.close();\n-\n-        // now get the latencies\n-        LOG.info(\"99th percentile latency: {}\", percentile(latency, 99));\n-        LOG.info(\"95th percentile latency: {}\", percentile(latency, 95));\n-\n-        bench.close();\n-        timeouter.cancel();\n-    }\n-\n-    private static double percentile(long[] latency, int percentile) {\n-        int size = latency.length;\n-        int sampleSize = (size * percentile) / 100;\n-        long total = 0;\n-        int count = 0;\n-        for(int i = 0; i < sampleSize; i++) {\n-            total += latency[i];\n-            count++;\n-        }\n-        return ((double)total/(double)count)/1000000.0;\n-    }\n-\n-    private static long warmUp(byte[] data, int ledgers, int ensemble, int qSize,\n-                               byte[] passwd, ClientConfiguration conf)\n-            throws KeeperException, IOException, InterruptedException, BKException {\n-        final CountDownLatch connectLatch = new CountDownLatch(1);\n-        final int bookies;\n-        String bookieRegistrationPath = conf.getZkAvailableBookiesPath();\n-        ZooKeeper zk = null;\n-        try {\n-            final String servers = conf.getZkServers();\n-            zk = new ZooKeeper(servers, 15000, new Watcher() {\n-                    @Override\n-                    public void process(WatchedEvent event) {\n-                        if (event.getState() == KeeperState.SyncConnected) {\n-                            connectLatch.countDown();\n-                        }\n-                    }});\n-            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n-                LOG.error(\"Couldn't connect to zookeeper at \" + servers);\n-                throw new IOException(\"Couldn't connect to zookeeper \" + servers);\n-            }\n-            bookies = zk.getChildren(bookieRegistrationPath, false).size();\n-        } finally {\n-            if (zk != null) {\n-                zk.close();\n-            }\n-        }\n-\n-        BenchThroughputLatency warmup = new BenchThroughputLatency(bookies, bookies, bookies, passwd,\n-                                                                   ledgers, 10000, conf);\n-        warmup.setEntryData(data);\n-        Thread thread = new Thread(warmup);\n-        thread.start();\n-        thread.join();\n-        warmup.close();\n-        return warmup.getThroughput();\n-    }\n-}"},{"sha":"ebea877076ec9125ac03e838366b4030cd4fa029","filename":"branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","status":"removed","additions":0,"deletions":138,"changes":138,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,138 +0,0 @@\n-package org.apache.bookkeeper.benchmark;\n-\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import java.io.FileOutputStream;\n-import java.sql.Connection;\n-import java.sql.DriverManager;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.HashMap;\n-\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import org.apache.zookeeper.KeeperException;\n-\n-public class MySqlClient {\n-    static final Logger LOG = LoggerFactory.getLogger(MySqlClient.class);\n-\n-    BookKeeper x;\n-    LedgerHandle lh;\n-    Integer entryId;\n-    HashMap<Integer, Integer> map;\n-\n-    FileOutputStream fStream;\n-    FileOutputStream fStreamLocal;\n-    long start, lastId;\n-    Connection con;\n-    Statement stmt;\n-\n-\n-    public MySqlClient(String hostport, String user, String pass)\n-            throws ClassNotFoundException {\n-        entryId = 0;\n-        map = new HashMap<Integer, Integer>();\n-        Class.forName(\"com.mysql.jdbc.Driver\");\n-        // database is named \"bookkeeper\"\n-        String url = \"jdbc:mysql://\" + hostport + \"/bookkeeper\";\n-        try {\n-            con = DriverManager.getConnection(url, user, pass);\n-            stmt = con.createStatement();\n-            // drop table and recreate it\n-            stmt.execute(\"DROP TABLE IF EXISTS data;\");\n-            stmt.execute(\"create table data(transaction_id bigint PRIMARY KEY AUTO_INCREMENT, content TEXT);\");\n-            LOG.info(\"Database initialization terminated\");\n-        } catch (SQLException e) {\n-\n-            // TODO Auto-generated catch block\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    public void closeHandle() throws KeeperException, InterruptedException, SQLException {\n-        con.close();\n-    }\n-    /**\n-     * First parameter is an integer defining the length of the message\n-     * Second parameter is the number of writes\n-     * Third parameter is host:port\n-     * Fourth parameter is username\n-     * Fifth parameter is password\n-     * @param args\n-     * @throws ClassNotFoundException\n-     * @throws SQLException\n-     */\n-    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n-        int lenght = Integer.parseInt(args[1]);\n-        StringBuilder sb = new StringBuilder();\n-        while(lenght-- > 0) {\n-            sb.append('a');\n-        }\n-        try {\n-            MySqlClient c = new MySqlClient(args[2], args[3], args[4]);\n-            c.writeSameEntryBatch(sb.toString().getBytes(UTF_8), Integer.parseInt(args[0]));\n-            c.writeSameEntry(sb.toString().getBytes(UTF_8), Integer.parseInt(args[0]));\n-            c.closeHandle();\n-        } catch (NumberFormatException e) {\n-            e.printStackTrace();\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        } catch (KeeperException e) {\n-            e.printStackTrace();\n-        }\n-\n-    }\n-\n-    /**\n-     * \tAdds  data entry to the DB\n-     * \t@param data \tthe entry to be written, given as a byte array\n-     * \t@param times\tthe number of times the entry should be written on the DB\t*/\n-    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException, SQLException {\n-        start = System.currentTimeMillis();\n-        int count = times;\n-        String content = new String(data, UTF_8);\n-        System.out.println(\"Data: \" + content + \", \" + data.length);\n-        while(count-- > 0) {\n-            stmt.addBatch(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n-        }\n-        LOG.info(\"Finished writing batch SQL command in ms: \" + (System.currentTimeMillis() - start));\n-        start = System.currentTimeMillis();\n-        stmt.executeBatch();\n-        System.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));\n-        LOG.info(\"Ended computation\");\n-    }\n-\n-    void writeSameEntry(byte[] data, int times) throws InterruptedException, SQLException {\n-        start = System.currentTimeMillis();\n-        int count = times;\n-        String content = new String(data, UTF_8);\n-        System.out.println(\"Data: \" + content + \", \" + data.length);\n-        while(count-- > 0) {\n-            stmt.executeUpdate(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n-        }\n-        System.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));\n-        LOG.info(\"Ended computation\");\n-    }\n-\n-}"},{"sha":"b64151c565e4f249dfc3642b002fc3d46b01c935","filename":"branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","status":"removed","additions":0,"deletions":358,"changes":358,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,358 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.benchmark;\n-\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hadoop.fs.FSDataOutputStream;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.fs.Path;\n-import org.apache.zookeeper.KeeperException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-/**\n- * This is a simple test program to compare the performance of writing to\n- * BookKeeper and to the local file system.\n- *\n- */\n-\n-public class TestClient {\n-    private static final Logger LOG = LoggerFactory.getLogger(TestClient.class);\n-\n-    /**\n-     * First says if entries should be written to BookKeeper (0) or to the local\n-     * disk (1). Second parameter is an integer defining the length of a ledger entry.\n-     * Third parameter is the number of writes.\n-     *\n-     * @param args\n-     */\n-    public static void main(String[] args) throws ParseException {\n-        Options options = new Options();\n-        options.addOption(\"length\", true, \"Length of packets being written. Default 1024\");\n-        options.addOption(\"target\", true, \"Target medium to write to. Options are bk, fs & hdfs. Default fs\");\n-        options.addOption(\"runfor\", true, \"Number of seconds to run for. Default 60\");\n-        options.addOption(\"path\", true, \"Path to write to. fs & hdfs only. Default /foobar\");\n-        options.addOption(\"zkservers\", true, \"ZooKeeper servers, comma separated. bk only. Default localhost:2181.\");\n-        options.addOption(\"bkensemble\", true, \"BookKeeper ledger ensemble size. bk only. Default 3\");\n-        options.addOption(\"bkquorum\", true, \"BookKeeper ledger quorum size. bk only. Default 2\");\n-        options.addOption(\"bkthrottle\", true, \"BookKeeper throttle size. bk only. Default 10000\");\n-        options.addOption(\"sync\", false, \"Use synchronous writes with BookKeeper. bk only.\");\n-        options.addOption(\"numconcurrent\", true, \"Number of concurrently clients. Default 1\");\n-        options.addOption(\"timeout\", true, \"Number of seconds after which to give up\");\n-        options.addOption(\"help\", false, \"This message\");\n-\n-        CommandLineParser parser = new PosixParser();\n-        CommandLine cmd = parser.parse(options, args);\n-\n-        if (cmd.hasOption(\"help\")) {\n-            HelpFormatter formatter = new HelpFormatter();\n-            formatter.printHelp(\"TestClient <options>\", options);\n-            System.exit(-1);\n-        }\n-\n-        int length = Integer.valueOf(cmd.getOptionValue(\"length\", \"1024\"));\n-        String target = cmd.getOptionValue(\"target\", \"fs\");\n-        long runfor = Long.valueOf(cmd.getOptionValue(\"runfor\", \"60\")) * 1000;\n-\n-        StringBuilder sb = new StringBuilder();\n-        while(length-- > 0) {\n-            sb.append('a');\n-        }\n-\n-        Timer timeouter = new Timer();\n-        if (cmd.hasOption(\"timeout\")) {\n-            final long timeout = Long.valueOf(cmd.getOptionValue(\"timeout\", \"360\")) * 1000;\n-\n-            timeouter.schedule(new TimerTask() {\n-                    public void run() {\n-                        System.err.println(\"Timing out benchmark after \" + timeout + \"ms\");\n-                        System.exit(-1);\n-                    }\n-                }, timeout);\n-        }\n-\n-        BookKeeper bkc = null;\n-        try {\n-            int numFiles = Integer.valueOf(cmd.getOptionValue(\"numconcurrent\", \"1\"));\n-            int numThreads = Math.min(numFiles, 1000);\n-            byte[] data = sb.toString().getBytes(UTF_8);\n-            long runid = System.currentTimeMillis();\n-            List<Callable<Long>> clients = new ArrayList<Callable<Long>>();\n-\n-            if (target.equals(\"bk\")) {\n-                String zkservers = cmd.getOptionValue(\"zkservers\", \"localhost:2181\");\n-                int bkensemble = Integer.valueOf(cmd.getOptionValue(\"bkensemble\", \"3\"));\n-                int bkquorum = Integer.valueOf(cmd.getOptionValue(\"bkquorum\", \"2\"));\n-                int bkthrottle = Integer.valueOf(cmd.getOptionValue(\"bkthrottle\", \"10000\"));\n-\n-                ClientConfiguration conf = new ClientConfiguration();\n-                conf.setThrottleValue(bkthrottle);\n-                conf.setZkServers(zkservers);\n-\n-                bkc = new BookKeeper(conf);\n-                List<LedgerHandle> handles = new ArrayList<LedgerHandle>();\n-                for (int i = 0; i < numFiles; i++) {\n-                    handles.add(bkc.createLedger(bkensemble, bkquorum, DigestType.CRC32, new byte[] {'a', 'b'}));\n-                }\n-                for (int i = 0; i < numFiles; i++) {\n-                    clients.add(new BKClient(handles, data, runfor, cmd.hasOption(\"sync\")));\n-                }\n-            } else if (target.equals(\"hdfs\")) {\n-                FileSystem fs = FileSystem.get(new Configuration());\n-                LOG.info(\"Default replication for HDFS: {}\", fs.getDefaultReplication());\n-\n-                List<FSDataOutputStream> streams = new ArrayList<FSDataOutputStream>();\n-                for (int i = 0; i < numFiles; i++) {\n-                    String path = cmd.getOptionValue(\"path\", \"/foobar\");\n-                    streams.add(fs.create(new Path(path + runid + \"_\" + i)));\n-                }\n-\n-                for (int i = 0; i < numThreads; i++) {\n-                    clients.add(new HDFSClient(streams, data, runfor));\n-                }\n-            } else if (target.equals(\"fs\")) {\n-                List<FileOutputStream> streams = new ArrayList<FileOutputStream>();\n-                for (int i = 0; i < numFiles; i++) {\n-                    String path = cmd.getOptionValue(\"path\", \"/foobar \" + i);\n-                    streams.add(new FileOutputStream(path + runid + \"_\" + i));\n-                }\n-\n-                for (int i = 0; i < numThreads; i++) {\n-                    clients.add(new FileClient(streams, data, runfor));\n-                }\n-            } else {\n-                LOG.error(\"Unknown option: \" + target);\n-                throw new IllegalArgumentException(\"Unknown target \" + target);\n-            }\n-\n-            ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n-            long start = System.currentTimeMillis();\n-\n-            List<Future<Long>> results = executor.invokeAll(clients,\n-                                                            10, TimeUnit.MINUTES);\n-            long end = System.currentTimeMillis();\n-            long count = 0;\n-            for (Future<Long> r : results) {\n-                if (!r.isDone()) {\n-                    LOG.warn(\"Job didn't complete\");\n-                    System.exit(2);\n-                }\n-                long c = r.get();\n-                if (c == 0) {\n-                    LOG.warn(\"Task didn't complete\");\n-                }\n-                count += c;\n-            }\n-            long time = end-start;\n-            LOG.info(\"Finished processing writes (ms): {} TPT: {} op/s\",\n-                     time, count/((double)time/1000));\n-            executor.shutdown();\n-        } catch (ExecutionException ee) {\n-            LOG.error(\"Exception in worker\", ee);\n-        }  catch (KeeperException ke) {\n-            LOG.error(\"Error accessing zookeeper\", ke);\n-        } catch (BKException e) {\n-            LOG.error(\"Error accessing bookkeeper\", e);\n-        } catch (IOException ioe) {\n-            LOG.error(\"I/O exception during benchmark\", ioe);\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"Benchmark interrupted\", ie);\n-        } finally {\n-            if (bkc != null) {\n-                try {\n-                    bkc.close();\n-                } catch (BKException bke) {\n-                    LOG.error(\"Error closing bookkeeper client\", bke);\n-                } catch (InterruptedException ie) {\n-                    LOG.warn(\"Interrupted closing bookkeeper client\", ie);\n-                }\n-            }\n-        }\n-        timeouter.cancel();\n-    }\n-\n-    static class HDFSClient implements Callable<Long> {\n-        final List<FSDataOutputStream> streams;\n-        final byte[] data;\n-        final long time;\n-        final Random r;\n-\n-        HDFSClient(List<FSDataOutputStream> streams, byte[] data, long time) {\n-            this.streams = streams;\n-            this.data = data;\n-            this.time = time;\n-            this.r = new Random(System.identityHashCode(this));\n-        }\n-\n-        public Long call() {\n-            try {\n-                long count = 0;\n-                long start = System.currentTimeMillis();\n-                long stopat = start + time;\n-                while(System.currentTimeMillis() < stopat) {\n-                    FSDataOutputStream stream = streams.get(r.nextInt(streams.size()));\n-                    synchronized(stream) {\n-                        stream.write(data);\n-                        stream.flush();\n-                        stream.hflush();\n-                    }\n-                    count++;\n-                }\n-\n-                long time = (System.currentTimeMillis() - start);\n-                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\",\n-                         time, count/((double)time/1000));\n-                return count;\n-            } catch(IOException ioe) {\n-                LOG.error(\"Exception in worker thread\", ioe);\n-                return 0L;\n-            }\n-        }\n-    }\n-\n-    static class FileClient implements Callable<Long> {\n-        final List<FileOutputStream> streams;\n-        final byte[] data;\n-        final long time;\n-        final Random r;\n-\n-        FileClient(List<FileOutputStream> streams, byte[] data, long time) {\n-            this.streams = streams;\n-            this.data = data;\n-            this.time = time;\n-            this.r = new Random(System.identityHashCode(this));\n-        }\n-\n-        public Long call() {\n-            try {\n-                long count = 0;\n-                long start = System.currentTimeMillis();\n-\n-                long stopat = start + time;\n-                while(System.currentTimeMillis() < stopat) {\n-                    FileOutputStream stream = streams.get(r.nextInt(streams.size()));\n-                    synchronized(stream) {\n-                        stream.write(data);\n-                        stream.flush();\n-                        stream.getChannel().force(false);\n-                    }\n-                    count++;\n-                }\n-\n-                long time = (System.currentTimeMillis() - start);\n-                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\", time, count/((double)time/1000));\n-                return count;\n-            } catch(IOException ioe) {\n-                LOG.error(\"Exception in worker thread\", ioe);\n-                return 0L;\n-            }\n-        }\n-    }\n-\n-    static class BKClient implements Callable<Long>, AddCallback {\n-        final List<LedgerHandle> handles;\n-        final byte[] data;\n-        final long time;\n-        final Random r;\n-        final boolean sync;\n-        final AtomicLong success = new AtomicLong(0);\n-        final AtomicLong outstanding = new AtomicLong(0);\n-\n-        BKClient(List<LedgerHandle> handles, byte[] data, long time, boolean sync) {\n-            this.handles = handles;\n-            this.data = data;\n-            this.time = time;\n-            this.r = new Random(System.identityHashCode(this));\n-            this.sync = sync;\n-        }\n-\n-        public Long call() {\n-            try {\n-                long start = System.currentTimeMillis();\n-\n-                long stopat = start + time;\n-                while(System.currentTimeMillis() < stopat) {\n-                    LedgerHandle lh = handles.get(r.nextInt(handles.size()));\n-                    if (sync) {\n-                        lh.addEntry(data);\n-                        success.incrementAndGet();\n-                    } else {\n-                        lh.asyncAddEntry(data, this, null);\n-                        outstanding.incrementAndGet();\n-                    }\n-                }\n-\n-                int ticks = 10; // don't wait for more than 10 seconds\n-                while (outstanding.get() > 0 && ticks-- > 0) {\n-                    Thread.sleep(10);\n-                }\n-\n-                long time = (System.currentTimeMillis() - start);\n-                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\",\n-                         time, success.get()/((double)time/1000));\n-                return success.get();\n-            } catch (BKException e) {\n-                LOG.error(\"Exception in worker thread\", e);\n-                return 0L;\n-            } catch (InterruptedException ie) {\n-                LOG.error(\"Exception in worker thread\", ie);\n-                return 0L;\n-            }\n-        }\n-\n-        @Override\n-        public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-            if (rc == BKException.Code.OK) {\n-                success.incrementAndGet();\n-            }\n-            outstanding.decrementAndGet();\n-        }\n-    }\n-}"},{"sha":"ec3cd610f532321e7663b6509f167b89065da3b7","filename":"branch-4.3/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","status":"removed","additions":0,"deletions":161,"changes":161,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,161 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.benchmark;\n-\n-import org.junit.BeforeClass;\n-import org.junit.AfterClass;\n-import org.junit.Test;\n-import org.junit.Assert;\n-\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import org.apache.bookkeeper.util.LocalBookKeeper;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.Watcher.Event.EventType;\n-import org.apache.zookeeper.Watcher.Event.KeeperState;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-public class TestBenchmark extends BookKeeperClusterTestCase {\n-    protected static final Logger LOG = LoggerFactory.getLogger(TestBenchmark.class);\n-\n-    public TestBenchmark() {\n-        super(5);\n-    }\n-\n-    @Test(timeout=60000)\n-    public void testThroughputLatency() throws Exception {\n-        String latencyFile = System.getProperty(\"test.latency.file\", \"latencyDump.dat\");\n-        BenchThroughputLatency.main(new String[] {\n-                \"--zookeeper\", zkUtil.getZooKeeperConnectString(),\n-                \"--time\", \"10\",\n-                \"--skipwarmup\",\n-                \"--throttle\", \"1\",\n-                \"--sendlimit\", \"10000\",\n-                \"--latencyFile\", latencyFile\n-            });\n-    }\n-\n-    @Test(timeout=60000)\n-    public void testBookie() throws Exception {\n-        BookieSocketAddress bookie = getBookie(0);\n-        BenchBookie.main(new String[] {\n-                \"--host\", bookie.getSocketAddress().getHostName(),\n-                \"--port\", String.valueOf(bookie.getPort()),\n-                \"--zookeeper\", zkUtil.getZooKeeperConnectString()\n-                });\n-    }\n-\n-    @Test(timeout=60000)\n-    public void testReadThroughputLatency() throws Exception {\n-        final AtomicBoolean threwException = new AtomicBoolean(false);\n-        Thread t = new Thread() {\n-                public void run() {\n-                    try {\n-                        BenchReadThroughputLatency.main(new String[] {\n-                                \"--zookeeper\", zkUtil.getZooKeeperConnectString(),\n-                                \"--listen\", \"10\"});\n-                    } catch (Throwable t) {\n-                        LOG.error(\"Error reading\", t);\n-                        threwException.set(true);\n-                    }\n-                }\n-            };\n-        t.start();\n-\n-        Thread.sleep(10000);\n-        byte data[] = new byte[1024];\n-        Arrays.fill(data, (byte)'x');\n-\n-        long lastLedgerId = 0;\n-        Assert.assertTrue(\"Thread should be running\", t.isAlive());\n-        for (int i = 0; i < 10; i++) {\n-            BookKeeper bk = new BookKeeper(zkUtil.getZooKeeperConnectString());\n-            LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.CRC32, \"benchPasswd\".getBytes());\n-            lastLedgerId = lh.getId();\n-            try {\n-                for (int j = 0; j < 100; j++) {\n-                    lh.addEntry(data);\n-                }\n-            } finally {\n-                lh.close();\n-                bk.close();\n-            }\n-        }\n-        for (int i = 0; i < 60; i++) {\n-            if (!t.isAlive()) {\n-                break;\n-            }\n-            Thread.sleep(1000); // wait for 10 seconds for reading to finish\n-        }\n-\n-        Assert.assertFalse(\"Thread should be finished\", t.isAlive());\n-\n-        BenchReadThroughputLatency.main(new String[] {\n-                \"--zookeeper\", zkUtil.getZooKeeperConnectString(),\n-                \"--ledger\", String.valueOf(lastLedgerId)});\n-\n-        final long nextLedgerId = lastLedgerId+1;\n-        t = new Thread() {\n-                public void run() {\n-                    try {\n-                        BenchReadThroughputLatency.main(new String[] {\n-                                \"--zookeeper\", zkUtil.getZooKeeperConnectString(),\n-                                \"--ledger\", String.valueOf(nextLedgerId)});\n-                    } catch (Throwable t) {\n-                        LOG.error(\"Error reading\", t);\n-                        threwException.set(true);\n-                    }\n-                }\n-            };\n-        t.start();\n-\n-        Assert.assertTrue(\"Thread should be running\", t.isAlive());\n-        BookKeeper bk = new BookKeeper(zkUtil.getZooKeeperConnectString());\n-        LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.CRC32, \"benchPasswd\".getBytes());\n-        try {\n-            for (int j = 0; j < 100; j++) {\n-                lh.addEntry(data);\n-            }\n-        } finally {\n-            lh.close();\n-            bk.close();\n-        }\n-        for (int i = 0; i < 60; i++) {\n-            if (!t.isAlive()) {\n-                break;\n-            }\n-            Thread.sleep(1000); // wait for 10 seconds for reading to finish\n-        }\n-        Assert.assertFalse(\"Thread should be finished\", t.isAlive());\n-        Assert.assertFalse(\"A thread has thrown an exception, check logs\", threwException.get());\n-    }\n-}"},{"sha":"040f01172fa9746ae2549c7a70a5f136ad4c9bb7","filename":"branch-4.3/bookkeeper-benchmark/src/test/resources/log4j.properties","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/test/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-benchmark/src/test/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-benchmark/src/test/resources/log4j.properties?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,72 +0,0 @@\n-#\n-# \n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-# \n-#   http://www.apache.org/licenses/LICENSE-2.0\n-# \n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-# \n-#\n-\n-#\n-# Bookkeeper Logging Configuration\n-#\n-\n-# Format is \"<default threshold> (, <appender>)+\n-\n-# DEFAULT: console appender only\n-log4j.rootLogger=INFO, CONSOLE\n-\n-# Example with rolling log file\n-#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n-\n-# Example with rolling log file and tracing\n-#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n-\n-#\n-# Log INFO level and above messages to the console\n-#\n-log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n-log4j.appender.CONSOLE.Threshold=INFO\n-log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-\n-#\n-# Add ROLLINGFILE to rootLogger to get log file output\n-#    Log DEBUG level and above messages to a log file\n-log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n-log4j.appender.ROLLINGFILE.Threshold=DEBUG\n-log4j.appender.ROLLINGFILE.File=bookkeeper-benchmark.log\n-log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-\n-# Max log file size of 10MB\n-log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n-# uncomment the next line to limit number of backup files\n-#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n-\n-log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n-\n-\n-#\n-# Add TRACEFILE to rootLogger to get log file output\n-#    Log DEBUG level and above messages to a log file\n-log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n-log4j.appender.TRACEFILE.Threshold=TRACE\n-log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n-\n-log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n-### Notice we are including log4j's NDC here (%x)\n-log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"daa499170839896c041727bd82e4fc907cf7020d","filename":"branch-4.3/bookkeeper-server/bin/bookkeeper","status":"removed","additions":0,"deletions":203,"changes":203,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/bin/bookkeeper","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/bin/bookkeeper","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/bin/bookkeeper?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,203 +0,0 @@\n-#!/usr/bin/env bash\n-#\n-#/**\n-# * Copyright 2007 The Apache Software Foundation\n-# *\n-# * Licensed to the Apache Software Foundation (ASF) under one\n-# * or more contributor license agreements.  See the NOTICE file\n-# * distributed with this work for additional information\n-# * regarding copyright ownership.  The ASF licenses this file\n-# * to you under the Apache License, Version 2.0 (the\n-# * \"License\"); you may not use this file except in compliance\n-# * with the License.  You may obtain a copy of the License at\n-# *\n-# *     http://www.apache.org/licenses/LICENSE-2.0\n-# *\n-# * Unless required by applicable law or agreed to in writing, software\n-# * distributed under the License is distributed on an \"AS IS\" BASIS,\n-# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# * See the License for the specific language governing permissions and\n-# * limitations under the License.\n-# */\n-\n-# check if net.ipv6.bindv6only is set to 1\n-bindv6only=$(/sbin/sysctl -n net.ipv6.bindv6only 2> /dev/null)\n-if [ -n \"$bindv6only\" ] && [ \"$bindv6only\" -eq \"1\" ]\n-then\n-  echo \"Error: \\\"net.ipv6.bindv6only\\\" is set to 1 - Java networking could be broken\"\n-  echo \"For more info (the following page also applies to bookkeeper): http://wiki.apache.org/hadoop/HadoopIPv6\"\n-  exit 1\n-fi\n-\n-# See the following page for extensive details on setting\n-# up the JVM to accept JMX remote management:\n-# http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html\n-# by default we allow local JMX connections\n-if [ \"x$JMXLOCALONLY\" = \"x\" ]\n-then\n-    JMXLOCALONLY=false\n-fi\n-\n-if [ \"x$JMXDISABLE\" = \"x\" ]\n-then\n-    echo \"JMX enabled by default\" >&2\n-    # for some reason these two options are necessary on jdk6 on Ubuntu\n-    #   accord to the docs they are not necessary, but otw jconsole cannot\n-    #   do a local attach\n-    JMX_ARGS=\"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY\"\n-else\n-    echo \"JMX disabled by user request\" >&2\n-fi\n-\n-BINDIR=`dirname \"$0\"`\n-BK_HOME=`cd $BINDIR/..;pwd`\n-\n-DEFAULT_CONF=$BK_HOME/conf/bk_server.conf\n-DEFAULT_LOG_CONF=$BK_HOME/conf/log4j.properties\n-\n-source $BK_HOME/conf/bkenv.sh\n-\n-# Check for the java to use\n-if [[ -z $JAVA_HOME ]]; then\n-    JAVA=$(which java)\n-    if [ $? = 0 ]; then\n-        echo \"JAVA_HOME not set, using java from PATH. ($JAVA)\"\n-    else\n-        echo \"Error: JAVA_HOME not set, and no java executable found in $PATH.\" 1>&2\n-        exit 1\n-    fi\n-else\n-    JAVA=$JAVA_HOME/bin/java\n-fi\n-\n-# exclude tests jar\n-RELEASE_JAR=`ls $BK_HOME/bookkeeper-server-*.jar 2> /dev/null | grep -v tests | tail -1` \n-if [ $? == 0 ]; then\n-    BOOKIE_JAR=$RELEASE_JAR\n-fi\n-\n-# exclude tests jar\n-BUILT_JAR=`ls $BK_HOME/target/bookkeeper-server-*.jar 2> /dev/null | grep -v tests | tail -1`\n-if [ $? != 0 ] && [ ! -e \"$BOOKIE_JAR\" ]; then \n-    echo \"\\nCouldn't find bookkeeper jar.\";\n-    echo \"Make sure you've run 'mvn package'\\n\";\n-    exit 1;\n-elif [ -e \"$BUILT_JAR\" ]; then\n-    BOOKIE_JAR=$BUILT_JAR\n-fi\n-\n-bookkeeper_help() {\n-    cat <<EOF\n-Usage: bookkeeper <command>\n-where command is one of:\n-    bookie              Run a bookie server\n-    autorecovery        Run AutoRecovery service daemon\n-    localbookie <n>     Run a test ensemble of <n> bookies locally\n-    upgrade             Upgrade bookie filesystem\n-    shell               Run shell for admin commands\n-    help                This help message\n-\n-or command is the full name of a class with a defined main() method.\n-\n-Environment variables:\n-   BOOKIE_LOG_CONF        Log4j configuration file (default $DEFAULT_LOG_CONF)\n-   BOOKIE_CONF            Configuration file (default: $DEFAULT_CONF)\n-   BOOKIE_EXTRA_OPTS      Extra options to be passed to the jvm\n-   BOOKIE_EXTRA_CLASSPATH Add extra paths to the bookkeeper classpath\n-   ENTRY_FORMATTER_CLASS  Entry formatter class to format entries.\n-   BOOKIE_PID_DIR         Folder where the Bookie server PID file should be stored\n-   BOOKIE_STOP_TIMEOUT    Wait time before forcefully kill the Bookie server instance, if the stop is not successful\n-\n-These variable can also be set in conf/bkenv.sh\n-EOF\n-}\n-\n-add_maven_deps_to_classpath() {\n-    MVN=\"mvn\"\n-    if [ \"$MAVEN_HOME\" != \"\" ]; then\n-\tMVN=${MAVEN_HOME}/bin/mvn\n-    fi\n-    \n-    # Need to generate classpath from maven pom. This is costly so generate it\n-    # and cache it. Save the file into our target dir so a mvn clean will get\n-    # clean it up and force us create a new one.\n-    f=\"${BK_HOME}/target/cached_classpath.txt\"\n-    if [ ! -f \"${f}\" ]\n-    then\n-\t${MVN} -f \"${BK_HOME}/pom.xml\" dependency:build-classpath -Dmdep.outputFile=\"${f}\" &> /dev/null\n-    fi\n-    BOOKIE_CLASSPATH=${CLASSPATH}:`cat \"${f}\"`\n-}\n-\n-if [ -d \"$BK_HOME/lib\" ]; then\n-    for i in $BK_HOME/lib/*.jar; do\n-\tBOOKIE_CLASSPATH=$BOOKIE_CLASSPATH:$i\n-    done\n-else\n-    add_maven_deps_to_classpath\n-fi\n-\n-# if no args specified, show usage\n-if [ $# = 0 ]; then\n-    bookkeeper_help;\n-    exit 1;\n-fi\n-\n-# get arguments\n-COMMAND=$1\n-shift\n-\n-if [ $COMMAND == \"shell\" ]; then\n-    DEFAULT_LOG_CONF=$BK_HOME/conf/log4j.shell.properties\n-fi\n-\n-if [ -z \"$BOOKIE_CONF\" ]; then\n-    BOOKIE_CONF=$DEFAULT_CONF\n-fi\n-\n-if [ -z \"$BOOKIE_LOG_CONF\" ]; then\n-    BOOKIE_LOG_CONF=$DEFAULT_LOG_CONF\n-fi\n-\n-BOOKIE_CLASSPATH=\"$BOOKIE_JAR:$BOOKIE_CLASSPATH:$BOOKIE_EXTRA_CLASSPATH\"\n-BOOKIE_CLASSPATH=\"`dirname $BOOKIE_LOG_CONF`:$BOOKIE_CLASSPATH\"\n-OPTS=\"$OPTS -Dlog4j.configuration=`basename $BOOKIE_LOG_CONF`\"\n-\n-OPTS=\"-cp $BOOKIE_CLASSPATH $OPTS\"\n-\n-OPTS=\"$OPTS $BOOKIE_EXTRA_OPTS\"\n-\n-# Disable ipv6 as it can cause issues\n-OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n-\n-# log directory & file\n-BOOKIE_ROOT_LOGGER=${BOOKIE_ROOT_LOGGER:-\"INFO,CONSOLE\"}\n-BOOKIE_LOG_DIR=${BOOKIE_LOG_DIR:-\"$BK_HOME/logs\"}\n-BOOKIE_LOG_FILE=${BOOKIE_LOG_FILE:-\"bookkeeper-server.log\"}\n-\n-#Configure log configuration system properties\n-OPTS=\"$OPTS -Dbookkeeper.root.logger=$BOOKIE_ROOT_LOGGER\"\n-OPTS=\"$OPTS -Dbookkeeper.log.dir=$BOOKIE_LOG_DIR\"\n-OPTS=\"$OPTS -Dbookkeeper.log.file=$BOOKIE_LOG_FILE\"\n-\n-#Change to BK_HOME to support relative paths\n-cd \"$BK_HOME\"\n-if [ $COMMAND == \"bookie\" ]; then\n-    exec $JAVA $OPTS $JMX_ARGS org.apache.bookkeeper.proto.BookieServer --conf $BOOKIE_CONF $@\n-elif [ $COMMAND == \"autorecovery\" ]; then\n-    exec $JAVA $OPTS $JMX_ARGS org.apache.bookkeeper.replication.AutoRecoveryMain --conf $BOOKIE_CONF $@\n-elif [ $COMMAND == \"localbookie\" ]; then\n-    NUMBER=$1\n-    shift\n-    exec $JAVA $OPTS $JMX_ARGS org.apache.bookkeeper.util.LocalBookKeeper $NUMBER $BOOKIE_CONF $@\n-elif [ $COMMAND == \"upgrade\" ]; then\n-    exec $JAVA $OPTS org.apache.bookkeeper.bookie.FileSystemUpgrade --conf $BOOKIE_CONF $@\n-elif [ $COMMAND == \"shell\" ]; then\n-    ENTRY_FORMATTER_ARG=\"-DentryFormatterClass=${ENTRY_FORMATTER_CLASS:-org.apache.bookkeeper.util.StringEntryFormatter}\"\n-    exec $JAVA $OPTS $ENTRY_FORMATTER_ARG org.apache.bookkeeper.bookie.BookieShell -conf $BOOKIE_CONF $@\n-elif [ $COMMAND == \"help\" ]; then\n-    bookkeeper_help;\n-else\n-    exec $JAVA $OPTS $COMMAND $@\n-fi\n-"},{"sha":"d27236d25a116db3592f9461c90959c58058023d","filename":"branch-4.3/bookkeeper-server/bin/bookkeeper-cluster.sh","status":"removed","additions":0,"deletions":135,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/bin/bookkeeper-cluster.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/bin/bookkeeper-cluster.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/bin/bookkeeper-cluster.sh?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,135 +0,0 @@\n-#!/usr/bin/env bash\n-#\n-#/**\n-# * Licensed to the Apache Software Foundation (ASF) under one\n-# * or more contributor license agreements.  See the NOTICE file\n-# * distributed with this work for additional information\n-# * regarding copyright ownership.  The ASF licenses this file\n-# * to you under the Apache License, Version 2.0 (the\n-# * \"License\"); you may not use this file except in compliance\n-# * with the License.  You may obtain a copy of the License at\n-# *\n-# *     http://www.apache.org/licenses/LICENSE-2.0\n-# *\n-# * Unless required by applicable law or agreed to in writing, software\n-# * distributed under the License is distributed on an \"AS IS\" BASIS,\n-# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# * See the License for the specific language governing permissions and\n-# * limitations under the License.\n-# */\n-\n-\n-BINDIR=`dirname \"$0\"`\n-BK_HOME=`cd $BINDIR/..;pwd`\n-if [ -f $BK_HOME/conf/bkenv.sh ]\n-then\n- . $BK_HOME/conf/bkenv.sh\n-fi\n-\n-BKCFG=$BK_HOME/conf/bk_server.conf\n-CLUSTER=$BK_HOME/conf/bookies\n-usage() {\n-    cat <<EOF\n-Usage: bookkeeper-cluster.sh (start|stop|kill)\n-\n-The list of hosts in the cluster must be available in\n-$CLUSTER\n-with one hostname per line.\n-\n-BookKeeper must be installed in the same location on each host.\n-EOF\n-}\n-\n-if [ ! -f $CLUSTER ]; then\n-    echo -e \"\\nCluster file ($CLUSTER) does not exist\\n\"\n-    usage\n-    exit 1\n-fi\n-\n-NUMHOSTS=$(wc -l $CLUSTER | awk '{print $1}')\n-if [ \"$NUMHOSTS\" = \"0\" ]; then\n-    echo -e \"\\nCluster file ($CLUSTER) is empty\\n\"\n-    usage\n-    exit 1\n-fi\n-\n-bookies_list() {\n-    $BINDIR/bookkeeper shell listbookies 2> /dev/null\n-}\n-\n-bookies_available() {\n-    bookies_list | wc -l\n-}\n-\n-start() {\n-    for B in `cat $CLUSTER`; do\n-\techo \"Starting bookie on $B\"\n-\tssh $B $BINDIR/bookkeeper-daemon.sh start bookie\n-    done\n-\n-    BOOKIESSTARTED=0\n-    COUNT=0\n-\n-    while [ $BOOKIESSTARTED -lt $NUMHOSTS ];  do\n-\tsleep 1\n-\tCOUNT=$(($COUNT+1))\n-\tif [ $COUNT = 20 ]; then\n-\t    echo \"Could not start all bookies\"\n-\t    exit 1\n-\tfi\n-\n-\tBOOKIESSTARTED=$(bookies_available)\n-\n-\techo \"$BOOKIESSTARTED bookies started\"\n-    done\n-}\n-\n-stop() {\n-    for B in `cat $CLUSTER`; do\n-\techo \"Stopping bookie on $B\"\n-\tssh $B $BINDIR/bookkeeper-daemon.sh stop bookie $FORCE\n-    done\n-\n-    COUNT=0\n-    BOOKIESSTARTED=$NUMHOSTS\n-    while [ $BOOKIESSTARTED -gt 0 ];  do\n-\tsleep 1\n-\t\n-\tCOUNT=$((COUNT+1))\n-\tif [ $COUNT = 20 ]; then\n-\t    echo \"Couldn not stop all bookies. $BOOKIESSTARTED still running\"\n-\t    exit 2\n-\tfi\n-\n-\tBOOKIESSTARTED=$(bookies_available)\n-    done\n-}\n-\n-status() {\n-    BOOKIESSTARTED=$(bookies_available)\n-    echo \"$BOOKIESSTARTED bookies running\"\n-    COUNT=1\n-    for b in $(bookies_list); do\n-\techo \"$COUNT: $b\"\n-\tCOUNT=$(($COUNT+1))\n-    done\n-}\n-\n-case $1 in\n-    start)\n-\tstart\n-\t;;\n-    stop)\n-\tstop\n-\t;;\n-    kill)\n-\tFORCE=\"-force\"\n-\tstop\n-\t;;\n-    status)\n-\tstatus\n-\t;;\n-    *)\n-\tusage\n-\t;;\n-esac"},{"sha":"766f528dd0db29250ae73529b810724d584cec6b","filename":"branch-4.3/bookkeeper-server/bin/bookkeeper-daemon.sh","status":"removed","additions":0,"deletions":174,"changes":174,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/bin/bookkeeper-daemon.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/bin/bookkeeper-daemon.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/bin/bookkeeper-daemon.sh?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,174 +0,0 @@\n-#!/usr/bin/env bash\n-#\n-#/**\n-# * Licensed to the Apache Software Foundation (ASF) under one\n-# * or more contributor license agreements.  See the NOTICE file\n-# * distributed with this work for additional information\n-# * regarding copyright ownership.  The ASF licenses this file\n-# * to you under the Apache License, Version 2.0 (the\n-# * \"License\"); you may not use this file except in compliance\n-# * with the License.  You may obtain a copy of the License at\n-# *\n-# *     http://www.apache.org/licenses/LICENSE-2.0\n-# *\n-# * Unless required by applicable law or agreed to in writing, software\n-# * distributed under the License is distributed on an \"AS IS\" BASIS,\n-# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# * See the License for the specific language governing permissions and\n-# * limitations under the License.\n-# */\n-\n-usage() {\n-    cat <<EOF\n-Usage: bookkeeper-daemon.sh (start|stop) <command> <args...>\n-where command is one of:\n-    bookie           Run the bookie server\n-\n-where argument is one of:\n-    -force (accepted only with stop command): Decides whether to stop the Bookie Server forcefully if not stopped by normal shutdown\n-EOF\n-}\n-\n-BINDIR=`dirname \"$0\"`\n-BK_HOME=`cd $BINDIR/..;pwd`\n-\n-if [ -f $BK_HOME/conf/bkenv.sh ]\n-then\n- . $BK_HOME/conf/bkenv.sh\n-fi\n-\n-BOOKIE_LOG_DIR=${BOOKIE_LOG_DIR:-\"$BK_HOME/logs\"}\n-\n-BOOKIE_ROOT_LOGGER=${BOOKIE_ROOT_LOGGER:-'INFO,ROLLINGFILE'}\n-\n-BOOKIE_STOP_TIMEOUT=${BOOKIE_STOP_TIMEOUT:-30}\n-\n-BOOKIE_PID_DIR=${BOOKIE_PID_DIR:-$BK_HOME/bin}\n-\n-if [ $# -lt 2 ]\n-then\n-    echo \"Error: no enough arguments provided.\"\n-    usage\n-    exit 1\n-fi\n-\n-startStop=$1\n-shift\n-command=$1\n-shift\n-\n-case $command in\n-    (bookie)\n-        echo \"doing $startStop $command ...\"\n-        ;;\n-    (autorecovery)\n-        echo \"doing $startStop $command ...\"\n-        ;;\n-    (*)\n-        echo \"Error: unknown service name $command\"\n-        usage\n-        exit 1\n-        ;;\n-esac\n-\n-export BOOKIE_LOG_DIR=$BOOKIE_LOG_DIR\n-export BOOKIE_ROOT_LOGGER=$BOOKIE_ROOT_LOGGER\n-export BOOKIE_LOG_FILE=bookkeeper-$command-$HOSTNAME.log\n-\n-pid=$BOOKIE_PID_DIR/bookkeeper-$command.pid\n-out=$BOOKIE_LOG_DIR/bookkeeper-$command-$HOSTNAME.out\n-logfile=$BOOKIE_LOG_DIR/$BOOKIE_LOG_FILE\n-\n-rotate_out_log ()\n-{\n-    log=$1;\n-    num=5;\n-    if [ -n \"$2\" ]; then\n-       num=$2\n-    fi\n-    if [ -f \"$log\" ]; then # rotate logs\n-        while [ $num -gt 1 ]; do\n-            prev=`expr $num - 1`\n-            [ -f \"$log.$prev\" ] && mv \"$log.$prev\" \"$log.$num\"\n-            num=$prev\n-        done\n-        mv \"$log\" \"$log.$num\";\n-    fi\n-}\n-\n-mkdir -p \"$BOOKIE_LOG_DIR\"\n-\n-case $startStop in\n-  (start)\n-    if [ -f $pid ]; then\n-      if kill -0 `cat $pid` > /dev/null 2>&1; then\n-        echo $command running as process `cat $pid`.  Stop it first.\n-        exit 1\n-      fi\n-    fi\n-\n-    rotate_out_log $out\n-    echo starting $command, logging to $logfile\n-    bookkeeper=$BK_HOME/bin/bookkeeper\n-    nohup $bookkeeper $command \"$@\" > \"$out\" 2>&1 < /dev/null &\n-    echo $! > $pid\n-    sleep 1; head $out\n-    sleep 2;\n-    if ! ps -p $! > /dev/null ; then\n-      exit 1\n-    fi\n-    ;;\n-\n-  (stop)\n-    if [ -f $pid ]; then\n-      TARGET_PID=`cat $pid`\n-      if kill -0 $TARGET_PID > /dev/null 2>&1; then\n-        echo stopping $command\n-        kill $TARGET_PID\n-\n-        count=0\n-        location=$BOOKIE_LOG_DIR\n-        while ps -p $TARGET_PID > /dev/null;\n-         do\n-          echo \"Shutdown is in progress... Please wait...\"\n-          sleep 1\n-          count=`expr $count + 1`\n-         \n-          if [ \"$count\" = \"$BOOKIE_STOP_TIMEOUT\" ]; then\n-                break\n-          fi\n-         done\n-        \n-        if [ \"$count\" != \"$BOOKIE_STOP_TIMEOUT\" ]; then\n-            echo \"Shutdown completed.\"\n-        fi\n-                 \n-        if kill -0 $TARGET_PID > /dev/null 2>&1; then\n-              fileName=$location/$command.out\n-              $JAVA_HOME/bin/jstack $TARGET_PID > $fileName\n-              echo Thread dumps are taken for analysis at $fileName\n-              if [ \"$1\" == \"-force\" ]\n-              then\n-                 echo forcefully stopping $command\n-                 kill -9 $TARGET_PID >/dev/null 2>&1\n-                 echo Successfully stopped the process\n-              else\n-                 echo \"WARNNING :  Bookie Server is not stopped completely.\"\n-                 exit 1\n-              fi\n-        fi\n-      else\n-        echo no $command to stop\n-      fi\n-      rm $pid\n-    else\n-      echo no $command to stop\n-    fi\n-    ;;\n-\n-  (*)\n-    usage\n-    echo $supportedargs\n-    exit 1\n-    ;;\n-esac"},{"sha":"e38ea2b83a72f024637cdf090ea4eefbbb598c33","filename":"branch-4.3/bookkeeper-server/conf/bk_server.conf","status":"removed","additions":0,"deletions":277,"changes":277,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/conf/bk_server.conf?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,277 +0,0 @@\n-#!/bin/sh\n-#\n-#/**\n-# * Copyright 2007 The Apache Software Foundation\n-# *\n-# * Licensed to the Apache Software Foundation (ASF) under one\n-# * or more contributor license agreements.  See the NOTICE file\n-# * distributed with this work for additional information\n-# * regarding copyright ownership.  The ASF licenses this file\n-# * to you under the Apache License, Version 2.0 (the\n-# * \"License\"); you may not use this file except in compliance\n-# * with the License.  You may obtain a copy of the License at\n-# *\n-# *     http://www.apache.org/licenses/LICENSE-2.0\n-# *\n-# * Unless required by applicable law or agreed to in writing, software\n-# * distributed under the License is distributed on an \"AS IS\" BASIS,\n-# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# * See the License for the specific language governing permissions and\n-# * limitations under the License.\n-# */\n-\n-## Bookie settings\n-\n-# Port that bookie server listen on\n-bookiePort=3181\n-\n-# Set the network interface that the bookie should listen on.\n-# If not set, the bookie will listen on all interfaces.\n-#listeningInterface=eth0\n-\n-# Whether the bookie allowed to use a loopback interface as its primary\n-# interface(i.e. the interface it uses to establish its identity)?\n-# By default, loopback interfaces are not allowed as the primary\n-# interface.\n-# Using a loopback interface as the primary interface usually indicates\n-# a configuration error. For example, its fairly common in some VPS setups\n-# to not configure a hostname, or to have the hostname resolve to\n-# 127.0.0.1. If this is the case, then all bookies in the cluster will\n-# establish their identities as 127.0.0.1:3181, and only one will be able\n-# to join the cluster. For VPSs configured like this, you should explicitly\n-# set the listening interface.\n-#allowLoopback=false\n-\n-# Directory Bookkeeper outputs its write ahead log\n-journalDirectory=/tmp/bk-txn\n-\n-# Directory Bookkeeper outputs ledger snapshots\n-# could define multi directories to store snapshots, separated by ','\n-# For example:\n-# ledgerDirectories=/tmp/bk1-data,/tmp/bk2-data\n-# \n-# Ideally ledger dirs and journal dir are each in a differet device,\n-# which reduce the contention between random i/o and sequential write.\n-# It is possible to run with a single disk, but performance will be significantly lower.\n-ledgerDirectories=/tmp/bk-data\n-# Directories to store index files. If not specified, will use ledgerDirectories to store.\n-# indexDirectories=/tmp/bk-data\n-\n-# Ledger Manager Class\n-# What kind of ledger manager is used to manage how ledgers are stored, managed\n-# and garbage collected. Try to read 'BookKeeper Internals' for detail info.\n-# ledgerManagerType=flat\n-\n-# Root zookeeper path to store ledger metadata\n-# This parameter is used by zookeeper-based ledger manager as a root znode to\n-# store all ledgers.\n-# zkLedgersRootPath=/ledgers\n-\n-# Enable/Disable entry logger preallocation\n-# entryLogFilePreallocationEnabled=true\n-\n-# Max file size of entry logger, in bytes\n-# A new entry log file will be created when the old one reaches the file size limitation\n-# logSizeLimit=2147483648\n-\n-# Threshold of minor compaction\n-# For those entry log files whose remaining size percentage reaches below\n-# this threshold will be compacted in a minor compaction.\n-# If it is set to less than zero, the minor compaction is disabled.\n-# minorCompactionThreshold=0.2\n-\n-# Interval to run minor compaction, in seconds\n-# If it is set to less than zero, the minor compaction is disabled. \n-# minorCompactionInterval=3600\n-\n-# Threshold of major compaction\n-# For those entry log files whose remaining size percentage reaches below\n-# this threshold will be compacted in a major compaction.\n-# Those entry log files whose remaining size percentage is still\n-# higher than the threshold will never be compacted.\n-# If it is set to less than zero, the minor compaction is disabled.\n-# majorCompactionThreshold=0.8\n-\n-# Interval to run major compaction, in seconds\n-# If it is set to less than zero, the major compaction is disabled. \n-# majorCompactionInterval=86400 \n-\n-# Set the maximum number of entries which can be compacted without flushing.\n-# When compacting, the entries are written to the entrylog and the new offsets\n-# are cached in memory. Once the entrylog is flushed the index is updated with\n-# the new offsets. This parameter controls the number of entries added to the\n-# entrylog before a flush is forced. A higher value for this parameter means\n-# more memory will be used for offsets. Each offset consists of 3 longs.\n-# This parameter should _not_ be modified unless you know what you're doing.\n-# The default is 100,000.\n-#compactionMaxOutstandingRequests=100000\n-\n-# Set the rate at which compaction will readd entries. The unit is adds per second.\n-#compactionRate=1000\n-\n-# Max file size of journal file, in mega bytes\n-# A new journal file will be created when the old one reaches the file size limitation\n-#\n-# journalMaxSizeMB=2048\n-\n-# Max number of old journal file to kept\n-# Keep a number of old journal files would help data recovery in specia case\n-#\n-# journalMaxBackups=5\n-\n-# How much space should we pre-allocate at a time in the journal\n-# journalPreAllocSizeMB=16\n-\n-# Size of the write buffers used for the journal\n-# journalWriteBufferSizeKB=64\n-\n-# Should we remove pages from page cache after force write\n-# journalRemoveFromPageCache=false\n-\n-# Should we group journal force writes, which optimize group commit\n-# for higher throughput\n-# journalAdaptiveGroupWrites=true\n-\n-# Maximum latency to impose on a journal write to achieve grouping\n-# journalMaxGroupWaitMSec=200\n-\n-# Maximum writes to buffer to achieve grouping\n-# journalBufferedWritesThreshold=524288\n-\n-# If we should flush the journal when journal queue is empty\n-# journalFlushWhenQueueEmpty=false\n-\n-# The number of threads that should handle journal callbacks\n-# numJournalCallbackThreads=1\n-\n-# How long the interval to trigger next garbage collection, in milliseconds\n-# Since garbage collection is running in background, too frequent gc\n-# will heart performance. It is better to give a higher number of gc\n-# interval if there is enough disk capacity.\n-# gcWaitTime=1000\n-\n-# How long the interval to flush ledger index pages to disk, in milliseconds\n-# Flushing index files will introduce much random disk I/O.\n-# If separating journal dir and ledger dirs each on different devices,\n-# flushing would not affect performance. But if putting journal dir\n-# and ledger dirs on same device, performance degrade significantly\n-# on too frequent flushing. You can consider increment flush interval\n-# to get better performance, but you need to pay more time on bookie\n-# server restart after failure.\n-#\n-# flushInterval=100\n-\n-# Interval to watch whether bookie is dead or not, in milliseconds\n-#\n-# bookieDeathWatchInterval=1000\n-\n-## zookeeper client settings\n-\n-# A list of one of more servers on which zookeeper is running.\n-# The server list can be comma separated values, for example:\n-# zkServers=zk1:2181,zk2:2181,zk3:2181\n-zkServers=localhost:2181\n-# ZooKeeper client session timeout in milliseconds\n-# Bookie server will exit if it received SESSION_EXPIRED because it\n-# was partitioned off from ZooKeeper for more than the session timeout\n-# JVM garbage collection, disk I/O will cause SESSION_EXPIRED.\n-# Increment this value could help avoiding this issue\n-zkTimeout=10000\n-\n-## NIO Server settings\n-\n-# This settings is used to enabled/disabled Nagle's algorithm, which is a means of\n-# improving the efficiency of TCP/IP networks by reducing the number of packets\n-# that need to be sent over the network.\n-# If you are sending many small messages, such that more than one can fit in\n-# a single IP packet, setting server.tcpnodelay to false to enable Nagle algorithm\n-# can provide better performance.\n-# Default value is true.\n-#\n-# serverTcpNoDelay=true\n-\n-## ledger cache settings\n-\n-# Max number of ledger index files could be opened in bookie server\n-# If number of ledger index files reaches this limitation, bookie\n-# server started to swap some ledgers from memory to disk.\n-# Too frequent swap will affect performance. You can tune this number\n-# to gain performance according your requirements.\n-# openFileLimit=900\n-\n-# Size of a index page in ledger cache, in bytes\n-# A larger index page can improve performance writing page to disk,\n-# which is efficent when you have small number of ledgers and these\n-# ledgers have similar number of entries.\n-# If you have large number of ledgers and each ledger has fewer entries,\n-# smaller index page would improve memory usage.\n-# pageSize=8192\n-\n-# How many index pages provided in ledger cache\n-# If number of index pages reaches this limitation, bookie server\n-# starts to swap some ledgers from memory to disk. You can increment\n-# this value when you found swap became more frequent. But make sure\n-# pageLimit*pageSize should not more than JVM max memory limitation,\n-# otherwise you would got OutOfMemoryException.\n-# In general, incrementing pageLimit, using smaller index page would\n-# gain bettern performance in lager number of ledgers with fewer entries case\n-# If pageLimit is -1, bookie server will use 1/3 of JVM memory to compute\n-# the limitation of number of index pages.\n-# pageLimit=-1\n-\n-#If all ledger directories configured are full, then support only read requests for clients.\n-#If \"readOnlyModeEnabled=true\" then on all ledger disks full, bookie will be converted\n-#to read-only mode and serve only read requests. Otherwise the bookie will be shutdown.\n-#By default this will be disabled.\n-#readOnlyModeEnabled=false\n-\n-#For each ledger dir, maximum disk space which can be used.\n-#Default is 0.95f. i.e. 95% of disk can be used at most after which nothing will\n-#be written to that partition. If all ledger dir partions are full, then bookie\n-#will turn to readonly mode if 'readOnlyModeEnabled=true' is set, else it will\n-#shutdown.\n-#Valid values should be in between 0 and 1 (exclusive). \n-#diskUsageThreshold=0.95\n-\n-#Disk check interval in milli seconds, interval to check the ledger dirs usage.\n-#Default is 10000\n-#diskCheckInterval=10000\n-\n-# Interval at which the auditor will do a check of all ledgers in the cluster.\n-# By default this runs once a week. The interval is set in seconds.\n-# To disable the periodic check completely, set this to 0.\n-# Note that periodic checking will put extra load on the cluster, so it should\n-# not be run more frequently than once a day.\n-#auditorPeriodicCheckInterval=604800\n-\n-# The interval between auditor bookie checks.\n-# The auditor bookie check, checks ledger metadata to see which bookies should\n-# contain entries for each ledger. If a bookie which should contain entries is\n-# unavailable, then the ledger containing that entry is marked for recovery.\n-# Setting this to 0 disabled the periodic check. Bookie checks will still\n-# run when a bookie fails.\n-# The interval is specified in seconds.\n-#auditorPeriodicBookieCheckInterval=86400\n-\n-# number of threads that should handle write requests. if zero, the writes would\n-# be handled by netty threads directly.\n-# numAddWorkerThreads=1\n-\n-# number of threads that should handle read requests. if zero, the reads would\n-# be handled by netty threads directly.\n-# numReadWorkerThreads=1\n-\n-# The number of bytes we should use as capacity for BufferedReadChannel. Default is 512 bytes.\n-# readBufferSizeBytes=512\n-\n-# The number of bytes used as capacity for the write buffer. Default is 64KB.\n-# writeBufferSizeBytes=65536\n-\n-# Whether the bookie should use its hostname to register with the\n-# co-ordination service(eg: zookeeper service).\n-# When false, bookie will use its ipaddress for the registration.\n-# Defaults to false.\n-#useHostNameAsBookieID=false\n-\n-# Stats Provider Class\n-#statsProviderClass=org.apache.bookkeeper.stats.CodahaleMetricsProvider"},{"sha":"c85b295c23dec0ebee6f361f73e6beaf478974c5","filename":"branch-4.3/bookkeeper-server/conf/bkenv.sh","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/bkenv.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/bkenv.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/conf/bkenv.sh?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,50 +0,0 @@\n-#!/bin/sh\n-#\n-#/**\n-# * Copyright 2007 The Apache Software Foundation\n-# *\n-# * Licensed to the Apache Software Foundation (ASF) under one\n-# * or more contributor license agreements.  See the NOTICE file\n-# * distributed with this work for additional information\n-# * regarding copyright ownership.  The ASF licenses this file\n-# * to you under the Apache License, Version 2.0 (the\n-# * \"License\"); you may not use this file except in compliance\n-# * with the License.  You may obtain a copy of the License at\n-# *\n-# *     http://www.apache.org/licenses/LICENSE-2.0\n-# *\n-# * Unless required by applicable law or agreed to in writing, software\n-# * distributed under the License is distributed on an \"AS IS\" BASIS,\n-# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# * See the License for the specific language governing permissions and\n-# * limitations under the License.\n-# */\n-\n-# Set JAVA_HOME here to override the environment setting\n-# JAVA_HOME=\n-\n-# default settings for starting bookkeeper\n-\n-# Configuration file of settings used in bookie server\n-# BOOKIE_CONF=\n-\n-# Log4j configuration file\n-# BOOKIE_LOG_CONF=\n-\n-# Logs location\n-# BOOKIE_LOG_DIR=\n-\n-# Extra options to be passed to the jvm\n-# BOOKIE_EXTRA_OPTS=\n-\n-# Add extra paths to the bookkeeper classpath\n-# BOOKIE_EXTRA_CLASSPATH=\n-\n-#Folder where the Bookie server PID file should be stored\n-#BOOKIE_PID_DIR=\n-\n-#Wait time before forcefully kill the Bookie server instance, if the stop is not successful\n-#BOOKIE_STOP_TIMEOUT=\n-\n-#Entry formatter class to format entries.\n-#ENTRY_FORMATTER_CLASS="},{"sha":"1dadb3d69d0c9d812a493fc752beaa3e58de3f5b","filename":"branch-4.3/bookkeeper-server/conf/log4j.properties","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/conf/log4j.properties?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,77 +0,0 @@\n-#\n-#\n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-#\n-#   http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-#\n-#\n-\n-#\n-# Hedwig Logging Configuration\n-#\n-\n-# Format is \"<default threshold> (, <appender>)+\n-\n-# DEFAULT: console appender only\n-# Define some default values that can be overridden by system properties\n-bookkeeper.root.logger=WARN,CONSOLE\n-bookkeeper.log.dir=.\n-bookkeeper.log.file=bookkeeper-server.log\n-\n-log4j.rootLogger=${bookkeeper.root.logger}\n-\n-# Example with rolling log file\n-#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n-\n-# Example with rolling log file and tracing\n-#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n-\n-#\n-# Log INFO level and above messages to the console\n-#\n-log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n-log4j.appender.CONSOLE.Threshold=INFO\n-log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-\n-#\n-# Add ROLLINGFILE to rootLogger to get log file output\n-#    Log DEBUG level and above messages to a log file\n-log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n-\n-log4j.appender.ROLLINGFILE.Threshold=INFO\n-log4j.appender.ROLLINGFILE.File=${bookkeeper.log.dir}/${bookkeeper.log.file}\n-log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-\n-# Max log file size of 10MB\n-#log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n-# uncomment the next line to limit number of backup files\n-#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n-\n-log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n-\n-#\n-# Add TRACEFILE to rootLogger to get log file output\n-#    Log DEBUG level and above messages to a log file\n-log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n-log4j.appender.TRACEFILE.Threshold=TRACE\n-log4j.appender.TRACEFILE.File=bookkeeper-trace.log\n-\n-log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n-### Notice we are including log4j's NDC here (%x)\n-log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"dcdc77c7fb93df0a2a51ff220051dc789edd230f","filename":"branch-4.3/bookkeeper-server/conf/log4j.shell.properties","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/log4j.shell.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/conf/log4j.shell.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/conf/log4j.shell.properties?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,41 +0,0 @@\n-#\n-#\n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-#\n-#   http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-#\n-#\n-\n-#\n-# BookieShell configuration\n-\n-# DEFAULT: console appender only\n-# Define some default values that can be overridden by system properties\n-bookkeeper.root.logger=ERROR,CONSOLE\n-\n-log4j.rootLogger=${bookkeeper.root.logger}\n-\n-#\n-# Log INFO level and above messages to the console\n-#\n-log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n-log4j.appender.CONSOLE.Threshold=INFO\n-log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.CONSOLE.layout.ConversionPattern=%d{ABSOLUTE} %-5p %m%n\n-\n-log4j.logger.org.apache.zookeeper=ERROR\n-log4j.logger.org.apache.bookkeeper=ERROR\n-log4j.logger.org.apache.bookkeeper.bookie.BookieShell=INFO"},{"sha":"adc8ae8fe85e052e342c07015b6f118a5f77e77b","filename":"branch-4.3/bookkeeper-server/pom.xml","status":"removed","additions":0,"deletions":359,"changes":359,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/pom.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,359 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n-  <modelVersion>4.0.0</modelVersion>\n-  <parent>\n-    <artifactId>bookkeeper</artifactId>\n-    <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.3.0</version>\n-  </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n-  <artifactId>bookkeeper-server</artifactId>\n-  <name>bookkeeper-server</name>\n-  <url>http://maven.apache.org</url>\n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <project.libdir>${basedir}/lib</project.libdir>\n-  </properties>\n-  <dependencies>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper.stats</groupId>\n-      <artifactId>bookkeeper-stats-api</artifactId>\n-      <version>${project.parent.version}</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>com.google.protobuf</groupId>\n-      <artifactId>protobuf-java</artifactId>\n-      <version>${protobuf.version}</version>\n-      <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>com.google.guava</groupId>\n-      <artifactId>guava</artifactId>\n-      <version>${guava.version}</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>junit</groupId>\n-      <artifactId>junit</artifactId>\n-      <version>4.8.1</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.slf4j</groupId>\n-      <artifactId>slf4j-api</artifactId>\n-      <version>1.6.4</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.slf4j</groupId>\n-      <artifactId>slf4j-log4j12</artifactId>\n-      <version>1.6.4</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.zookeeper</groupId>\n-      <artifactId>zookeeper</artifactId>\n-      <version>${zookeeper.version}</version>\n-      <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.zookeeper</groupId>\n-      <artifactId>zookeeper</artifactId>\n-      <version>${zookeeper.version}</version>\n-      <type>test-jar</type>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>io.netty</groupId>\n-      <artifactId>netty</artifactId>\n-      <version>${netty.version}</version>\n-      <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>commons-configuration</groupId>\n-      <artifactId>commons-configuration</artifactId>\n-      <version>1.6</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>commons-cli</groupId>\n-      <artifactId>commons-cli</artifactId>\n-      <version>1.2</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>commons-codec</groupId>\n-      <artifactId>commons-codec</artifactId>\n-      <version>1.6</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>commons-io</groupId>\n-      <artifactId>commons-io</artifactId>\n-      <version>2.1</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>net.java.dev.jna</groupId>\n-      <artifactId>jna</artifactId>\n-      <version>3.2.7</version>\n-    </dependency>\n-    <!--\n-        Annoying dependency we need to include because\n-        zookeeper uses log4j and so we transatively do, but\n-        log4j has some dependencies which aren't in the \n-        default maven repositories\n-    //-->\n-    <dependency>\n-      <groupId>log4j</groupId>\n-      <artifactId>log4j</artifactId>\n-      <version>1.2.15</version>\n-      <exclusions>\n-        <exclusion>\n-          <groupId>javax.mail</groupId>\n-          <artifactId>mail</artifactId>\n-        </exclusion>\n-        <exclusion>\n-          <groupId>javax.jms</groupId>\n-          <artifactId>jms</artifactId>\n-        </exclusion>\n-        <exclusion>\n-          <groupId>com.sun.jdmk</groupId>\n-          <artifactId>jmxtools</artifactId>\n-        </exclusion>\n-        <exclusion>\n-          <groupId>com.sun.jmx</groupId>\n-          <artifactId>jmxri</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server-compat400</artifactId>\n-      <version>4.0.0</version>\n-      <scope>test</scope>\n-      <exclusions>\n-        <exclusion>\n-          <groupId>org.apache.bookkeeper</groupId>\n-          <artifactId>bookkeeper-server</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server-compat410</artifactId>\n-      <version>4.1.0</version>\n-      <scope>test</scope>\n-      <exclusions>\n-        <exclusion>\n-          <groupId>org.apache.bookkeeper</groupId>\n-          <artifactId>bookkeeper-server</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server-compat420</artifactId>\n-      <version>4.2.0</version>\n-      <scope>test</scope>\n-      <exclusions>\n-        <exclusion>\n-          <groupId>org.apache.bookkeeper</groupId>\n-          <artifactId>bookkeeper-server</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-  </dependencies>\n-  <build>\n-    <plugins>\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-shade-plugin</artifactId>\n-        <version>2.1</version>\n-        <configuration>\n-          <!-- put your configurations here -->\n-        </configuration>\n-        <executions>\n-          <execution>\n-            <phase>package</phase>\n-            <goals>\n-              <goal>shade</goal>\n-            </goals>\n-            <configuration>\n-              <createDependencyReducedPom>true</createDependencyReducedPom>\n-              <artifactSet>\n-                <includes>\n-                  <include>com.google.protobuf:protobuf-java</include>\n-                  <include>com.google.guava:guava</include>\n-                </includes>\n-              </artifactSet>\n-              <minimizeJar>true</minimizeJar>\n-              <relocations>\n-                <relocation>\n-                  <pattern>com.google</pattern>\n-                  <shadedPattern>bk-shade.com.google</shadedPattern>\n-                </relocation>\n-              </relocations>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-      <plugin>\n-        <groupId>org.codehaus.mojo</groupId>\n-        <artifactId>license-maven-plugin</artifactId>\n-        <version>1.6</version>\n-        <configuration>\n-          <canUpdateCopyright>false</canUpdateCopyright>\n-          <roots><root>${project.basedir}</root></roots>\n-        </configuration>\n-        <executions>\n-          <execution>\n-            <id>update-pom-license</id>\n-            <goals>\n-              <goal>update-file-header</goal>\n-            </goals>\n-            <phase>package</phase>\n-            <configuration>\n-              <licenseName>apache_v2</licenseName>\n-              <includes>\n-                <include>dependency-reduced-pom.xml</include>\n-              </includes>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-jar-plugin</artifactId>\n-        <version>2.2</version>\n-        <executions>\n-          <execution>\n-            <goals>\n-              <goal>test-jar</goal>\n-            </goals>\n-          </execution>\n-        </executions>\n-      </plugin>\n-      <plugin>\n-        <artifactId>maven-assembly-plugin</artifactId>\n-        <version>2.2.1</version>\n-        <configuration>\n-          <descriptors>\n-            <descriptor>../src/assemble/bin.xml</descriptor>\n-          </descriptors>\n-        </configuration>\n-      </plugin>\n-      <plugin>\n-        <groupId>org.apache.rat</groupId>\n-        <artifactId>apache-rat-plugin</artifactId>\n-        <version>0.7</version>\n-        <configuration>\n-          <excludes>\n-            <!-- exclude generated file //-->\n-            <exclude>**/DataFormats.java</exclude>\n-            <exclude>**/BookkeeperProtocol.java</exclude>\n-          </excludes>\n-        </configuration>\n-      </plugin>\n-      <plugin>\n-        <groupId>org.codehaus.mojo</groupId>\n-        <artifactId>findbugs-maven-plugin</artifactId>\n-        <configuration>\n-          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile>\n-        </configuration>\n-      </plugin>\n-      <plugin>\n-        <artifactId>maven-dependency-plugin</artifactId>\n-        <executions>\n-          <execution>\n-            <phase>package</phase>\n-            <goals>\n-              <goal>copy-dependencies</goal>\n-            </goals>\n-            <configuration>\n-              <outputDirectory>${project.libdir}</outputDirectory>\n-\t      <includeScope>runtime</includeScope>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-      <plugin>\n-        <artifactId>maven-clean-plugin</artifactId>\n-        <version>2.5</version>\n-\t<configuration>\n-\t  <filesets>\n-            <fileset>\n-              <directory>${project.libdir}</directory>\n-              <followSymlinks>false</followSymlinks>\n-            </fileset>\n-            <fileset>\n-              <directory>${project.basedir}</directory>\n-              <includes>\n-                <include>dependency-reduced-pom.xml</include>\n-              </includes>\n-            </fileset>\n-          </filesets>\n-\t</configuration>\n-      </plugin>\n-    </plugins>\n-  </build>\n-  <profiles>\n-    <profile>\n-      <id>protobuf</id>\n-      <build>\n-        <plugins>\n-          <plugin>\n-            <artifactId>maven-antrun-plugin</artifactId>\n-            <executions>\n-              <execution>\n-                <phase>generate-sources</phase>\n-                <id>default-cli</id>\n-                <configuration>\n-                  <target>\n-                    <exec executable=\"protoc\" failonerror=\"true\">\n-                      <arg value=\"--java_out=src/main/java\" />\n-                      <arg value=\"src/main/proto/DataFormats.proto\" />\n-                    </exec>\n-                  </target>\n-                </configuration>\n-                <goals>\n-                  <goal>run</goal>\n-                </goals>\n-              </execution>\n-            </executions>\n-          </plugin>\n-        </plugins>\n-      </build>\n-    </profile>\n-    <profile>\n-      <id>twitter-science-provider</id>\n-      <dependencies>\n-        <dependency>\n-          <groupId>org.apache.bookkeeper.stats</groupId>\n-          <artifactId>twitter-science-provider</artifactId>\n-          <version>${project.parent.version}</version>\n-        </dependency>\n-      </dependencies>\n-    </profile>\n-    <profile>\n-      <id>codahale-metrics-provider</id>\n-      <dependencies>\n-        <dependency>\n-          <groupId>org.apache.bookkeeper.stats</groupId>\n-          <artifactId>codahale-metrics-provider</artifactId>\n-          <version>${project.parent.version}</version>\n-        </dependency>\n-      </dependencies>\n-    </profile>\n-  </profiles>\n-</project>"},{"sha":"ddd142ece040bfa3fbc285e958407876ac45edc7","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","status":"removed","additions":0,"deletions":85,"changes":85,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,85 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-public interface BookKeeperServerStats {\n-\n-    public final static String SERVER_SCOPE = \"bookkeeper_server\";\n-    public final static String BOOKIE_SCOPE = \"bookie\";\n-\n-    public final static String SERVER_STATUS = \"SERVER_STATUS\";\n-\n-    // Server Operations\n-    public final static String ADD_ENTRY_REQUEST = \"ADD_ENTRY_REQUEST\";\n-    public final static String ADD_ENTRY = \"ADD_ENTRY\";\n-    public final static String READ_ENTRY_REQUEST = \"READ_ENTRY_REQUEST\";\n-    public final static String READ_ENTRY = \"READ_ENTRY\";\n-    public final static String READ_ENTRY_FENCE_REQUEST = \"READ_ENTRY_FENCE_REQUEST\";\n-    public final static String READ_ENTRY_FENCE_WAIT = \"READ_ENTRY_FENCE_WAIT\";\n-    public final static String READ_ENTRY_FENCE_READ = \"READ_ENTRY_FENCE_READ\";\n-\n-    // Journal Stats\n-    public final static String JOURNAL_ADD_ENTRY = \"JOURNAL_ADD_ENTRY\";\n-    public final static String JOURNAL_MEM_ADD_ENTRY = \"JOURNAL_MEM_ADD_ENTRY\";\n-    public final static String JOURNAL_PREALLOCATION = \"JOURNAL_PREALLOCATION\";\n-    public final static String JOURNAL_FORCE_WRITE_LATENCY = \"JOURNAL_FORCE_WRITE_LATENCY\";\n-    public final static String JOURNAL_FORCE_WRITE_BATCH_ENTRIES = \"JOURNAL_FORCE_WRITE_BATCH_ENTRIES\";\n-    public final static String JOURNAL_FORCE_WRITE_BATCH_BYTES = \"JOURNAL_FORCE_WRITE_BATCH_BYTES\";\n-    public final static String JOURNAL_FLUSH_LATENCY = \"JOURNAL_FLUSH_LATENCY\";\n-    public final static String JOURNAL_CREATION_LATENCY = \"JOURNAL_CREATION_LATENCY\";\n-\n-    // Ledger Storage Stats\n-    public final static String STORAGE_GET_OFFSET = \"STORAGE_GET_OFFSET\";\n-    public final static String STORAGE_GET_ENTRY = \"STORAGE_GET_ENTRY\";\n-    public final static String SKIP_LIST_GET_ENTRY = \"SKIP_LIST_GET_ENTRY\";\n-    public final static String SKIP_LIST_PUT_ENTRY = \"SKIP_LIST_PUT_ENTRY\";\n-    public final static String SKIP_LIST_SNAPSHOT = \"SKIP_LIST_SNAPSHOT\";\n-\n-    // Counters\n-    public final static String JOURNAL_WRITE_BYTES = \"JOURNAL_WRITE_BYTES\";\n-    public final static String JOURNAL_QUEUE_SIZE = \"JOURNAL_QUEUE_SIZE\";\n-    public final static String READ_BYTES = \"READ_BYTES\";\n-    public final static String WRITE_BYTES = \"WRITE_BYTES\";\n-    public final static String NUM_MINOR_COMP = \"NUM_MINOR_COMP\";\n-    public final static String NUM_MAJOR_COMP = \"NUM_MAJOR_COMP\";\n-    public final static String JOURNAL_FORCE_WRITE_QUEUE_SIZE = \"JOURNAL_FORCE_WRITE_QUEUE_SIZE\";\n-    public final static String JOURNAL_NUM_FORCE_WRITES = \"JOURNAL_NUM_FORCE_WRITES\";\n-    public final static String JOURNAL_NUM_FLUSH_EMPTY_QUEUE = \"JOURNAL_NUM_FLUSH_EMPTY_QUEUE\";\n-    public final static String JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES = \"JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES\";\n-    public final static String JOURNAL_NUM_FLUSH_MAX_WAIT = \"JOURNAL_NUM_FLUSH_MAX_WAIT\";\n-    public final static String SKIP_LIST_FLUSH_BYTES = \"SKIP_LIST_FLUSH_BYTES\";\n-    public final static String SKIP_LIST_THROTTLING = \"SKIP_LIST_THROTTLING\";\n-    public final static String READ_LAST_ENTRY_NOENTRY_ERROR = \"READ_LAST_ENTRY_NOENTRY_ERROR\";\n-    public final static String LEDGER_CACHE_NUM_EVICTED_LEDGERS = \"LEDGER_CACHE_NUM_EVICTED_LEDGERS\";\n-\n-    // Gauge\n-    public final static String NUM_INDEX_PAGES = \"NUM_INDEX_PAGES\";\n-    public final static String NUM_OPEN_LEDGERS = \"NUM_OPEN_LEDGERS\";\n-    public final static String JOURNAL_FORCE_WRITE_GROUPING_COUNT = \"JOURNAL_FORCE_WRITE_GROUPING_COUNT\";\n-    public final static String NUM_PENDING_READ = \"NUM_PENDING_READ\";\n-    public final static String NUM_PENDING_ADD = \"NUM_PENDING_ADD\";\n-\n-    // LedgerDirs Stats\n-    public final static String LD_LEDGER_SCOPE = \"ledger\";\n-    public final static String LD_INDEX_SCOPE = \"index\";\n-    public final static String LD_WRITABLE_DIRS = \"writable_dirs\";\n-\n-}"},{"sha":"54a3c9fbfaf9f372b569ef50c7f5533b107133d8","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"removed","additions":0,"deletions":1307,"changes":1307,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,1307 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FilenameFilter;\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.net.UnknownHostException;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.jmx.BKMBeanInfo;\n-import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.meta.LedgerManagerFactory;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.net.DNS;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.Gauge;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.BookKeeperConstants;\n-import org.apache.bookkeeper.util.IOUtils;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n-import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n-import org.apache.commons.io.FileUtils;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.KeeperException.NodeExistsException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.Watcher.Event.EventType;\n-import org.apache.zookeeper.ZooDefs.Ids;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.data.Stat;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_LEDGER_SCOPE;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_INDEX_SCOPE;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_BYTES;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SERVER_STATUS;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_BYTES;\n-\n-/**\n- * Implements a bookie.\n- *\n- */\n-public class Bookie extends BookieCriticalThread {\n-\n-    private final static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n-\n-    final File journalDirectory;\n-    final ServerConfiguration conf;\n-\n-    final SyncThread syncThread;\n-    final LedgerManagerFactory ledgerManagerFactory;\n-    final LedgerManager ledgerManager;\n-    final LedgerStorage ledgerStorage;\n-    final Journal journal;\n-\n-    final HandleFactory handles;\n-\n-    static final long METAENTRY_ID_LEDGER_KEY = -0x1000;\n-    static final long METAENTRY_ID_FENCE_KEY  = -0x2000;\n-\n-    // ZK registration path for this bookie\n-    private final String bookieRegistrationPath;\n-\n-    private final LedgerDirsManager ledgerDirsManager;\n-    private LedgerDirsManager indexDirsManager;\n-\n-    // ZooKeeper client instance for the Bookie\n-    ZooKeeper zk;\n-\n-    // Running flag\n-    private volatile boolean running = false;\n-    // Flag identify whether it is in shutting down progress\n-    private volatile boolean shuttingdown = false;\n-\n-    private int exitCode = ExitCode.OK;\n-\n-    // jmx related beans\n-    BookieBean jmxBookieBean;\n-    BKMBeanInfo jmxLedgerStorageBean;\n-\n-    final ConcurrentMap<Long, byte[]> masterKeyCache = new ConcurrentHashMap<Long, byte[]>();\n-\n-    final private String zkBookieRegPath;\n-    final private String zkBookieReadOnlyPath;\n-\n-    final private AtomicBoolean readOnly = new AtomicBoolean(false);\n-\n-    // Expose Stats\n-    private final Counter writeBytes;\n-    private final Counter readBytes;\n-\n-    public static class NoLedgerException extends IOException {\n-        private static final long serialVersionUID = 1L;\n-        private final long ledgerId;\n-        public NoLedgerException(long ledgerId) {\n-            super(\"Ledger \" + ledgerId + \" not found\");\n-            this.ledgerId = ledgerId;\n-        }\n-        public long getLedgerId() {\n-            return ledgerId;\n-        }\n-    }\n-    public static class NoEntryException extends IOException {\n-        private static final long serialVersionUID = 1L;\n-        private final long ledgerId;\n-        private final long entryId;\n-        public NoEntryException(long ledgerId, long entryId) {\n-            this(\"Entry \" + entryId + \" not found in \" + ledgerId, ledgerId, entryId);\n-        }\n-\n-        public NoEntryException(String msg, long ledgerId, long entryId) {\n-            super(msg);\n-            this.ledgerId = ledgerId;\n-            this.entryId = entryId;\n-        }\n-\n-        public long getLedger() {\n-            return ledgerId;\n-        }\n-        public long getEntry() {\n-            return entryId;\n-        }\n-    }\n-\n-    // Write Callback do nothing\n-    static class NopWriteCallback implements WriteCallback {\n-        @Override\n-        public void writeComplete(int rc, long ledgerId, long entryId,\n-                                  BookieSocketAddress addr, Object ctx) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n-                          new Object[] { entryId, ledgerId, addr, rc });\n-            }\n-        }\n-    }\n-\n-    final static Future<Boolean> SUCCESS_FUTURE = new Future<Boolean>() {\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) { return false; }\n-        @Override\n-        public Boolean get() { return true; }\n-        @Override\n-        public Boolean get(long timeout, TimeUnit unit) { return true; }\n-        @Override\n-        public boolean isCancelled() { return false; }\n-        @Override\n-        public boolean isDone() {\n-            return true;\n-        }\n-    };\n-\n-    static class CountDownLatchFuture<T> implements Future<T> {\n-\n-        T value = null;\n-        volatile boolean done = false;\n-        CountDownLatch latch = new CountDownLatch(1);\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) { return false; }\n-        @Override\n-        public T get() throws InterruptedException {\n-            latch.await();\n-            return value;\n-        }\n-        @Override\n-        public T get(long timeout, TimeUnit unit)\n-            throws InterruptedException, TimeoutException {\n-            if (!latch.await(timeout, unit)) {\n-                throw new TimeoutException(\"Timed out waiting for latch\");\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public boolean isCancelled() { return false; }\n-\n-        @Override\n-        public boolean isDone() {\n-            return done;\n-        }\n-\n-        void setDone(T value) {\n-            this.value = value;\n-            done = true;\n-            latch.countDown();\n-        }\n-    }\n-\n-    static class FutureWriteCallback implements WriteCallback {\n-\n-        CountDownLatchFuture<Boolean> result =\n-            new CountDownLatchFuture<Boolean>();\n-\n-        @Override\n-        public void writeComplete(int rc, long ledgerId, long entryId,\n-                                  BookieSocketAddress addr, Object ctx) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n-                          new Object[] { entryId, ledgerId, addr, rc });\n-            }\n-            result.setDone(0 == rc);\n-        }\n-\n-        public Future<Boolean> getResult() {\n-            return result;\n-        }\n-    }\n-\n-    public static void checkDirectoryStructure(File dir) throws IOException {\n-        if (!dir.exists()) {\n-            File parent = dir.getParentFile();\n-            File preV3versionFile = new File(dir.getParent(),\n-                    BookKeeperConstants.VERSION_FILENAME);\n-\n-            final AtomicBoolean oldDataExists = new AtomicBoolean(false);\n-            parent.list(new FilenameFilter() {\n-                    @Override\n-                    public boolean accept(File dir, String name) {\n-                        if (name.endsWith(\".txn\") || name.endsWith(\".idx\") || name.endsWith(\".log\")) {\n-                            oldDataExists.set(true);\n-                        }\n-                        return true;\n-                    }\n-                });\n-            if (preV3versionFile.exists() || oldDataExists.get()) {\n-                String err = \"Directory layout version is less than 3, upgrade needed\";\n-                LOG.error(err);\n-                throw new IOException(err);\n-            }\n-            if (!dir.mkdirs()) {\n-                String err = \"Unable to create directory \" + dir;\n-                LOG.error(err);\n-                throw new IOException(err);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check that the environment for the bookie is correct.\n-     * This means that the configuration has stayed the same as the\n-     * first run and the filesystem structure is up to date.\n-     */\n-    private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException {\n-        List<File> allLedgerDirs = new ArrayList<File>(ledgerDirsManager.getAllLedgerDirs().size()\n-                                                     + indexDirsManager.getAllLedgerDirs().size());\n-        allLedgerDirs.addAll(ledgerDirsManager.getAllLedgerDirs());\n-        if (indexDirsManager != ledgerDirsManager) {\n-            allLedgerDirs.addAll(indexDirsManager.getAllLedgerDirs());\n-        }\n-        if (zk == null) { // exists only for testing, just make sure directories are correct\n-            checkDirectoryStructure(journalDirectory);\n-            for (File dir : allLedgerDirs) {\n-                    checkDirectoryStructure(dir);\n-            }\n-            return;\n-        }\n-        try {\n-            boolean newEnv = false;\n-            List<File> missedCookieDirs = new ArrayList<File>();\n-            Cookie journalCookie = null;\n-            // try to read cookie from journal directory.\n-            try {\n-                journalCookie = Cookie.readFromDirectory(journalDirectory);\n-                if (journalCookie.isBookieHostCreatedFromIp()) {\n-                    conf.setUseHostNameAsBookieID(false);\n-                } else {\n-                    conf.setUseHostNameAsBookieID(true);\n-                }\n-            } catch (FileNotFoundException fnf) {\n-                newEnv = true;\n-                missedCookieDirs.add(journalDirectory);\n-            }\n-            String instanceId = getInstanceId(zk);\n-            Cookie.Builder builder = Cookie.generateCookie(conf);\n-            if (null != instanceId) {\n-                builder.setInstanceId(instanceId);\n-            }\n-            Cookie masterCookie = builder.build();\n-            try {\n-                Versioned<Cookie> zkCookie = Cookie.readFromZooKeeper(zk, conf);\n-                masterCookie.verify(zkCookie.getValue());\n-            } catch (KeeperException.NoNodeException nne) {\n-                // can occur in cases:\n-                // 1) new environment or\n-                // 2) done only metadata format and started bookie server.\n-            }\n-            checkDirectoryStructure(journalDirectory);\n-\n-            if(!newEnv){\n-                journalCookie.verify(masterCookie);\n-            }\n-            for (File dir : allLedgerDirs) {\n-                checkDirectoryStructure(dir);\n-                try {\n-                    Cookie c = Cookie.readFromDirectory(dir);\n-                    c.verify(masterCookie);\n-                } catch (FileNotFoundException fnf) {\n-                    missedCookieDirs.add(dir);\n-                }\n-            }\n-\n-            if (!newEnv && missedCookieDirs.size() > 0){\n-                LOG.error(\"Cookie exists in zookeeper, but not in all local directories. \"\n-                        + \" Directories missing cookie file are \" + missedCookieDirs);\n-                throw new BookieException.InvalidCookieException();\n-            }\n-            if (newEnv) {\n-                if (missedCookieDirs.size() > 0) {\n-                    LOG.debug(\"Directories missing cookie file are {}\", missedCookieDirs);\n-                    masterCookie.writeToDirectory(journalDirectory);\n-                    for (File dir : allLedgerDirs) {\n-                        masterCookie.writeToDirectory(dir);\n-                    }\n-                }\n-                masterCookie.writeToZooKeeper(zk, conf, Version.NEW);\n-            }\n-        } catch (KeeperException ke) {\n-            LOG.error(\"Couldn't access cookie in zookeeper\", ke);\n-            throw new BookieException.InvalidCookieException(ke);\n-        } catch (UnknownHostException uhe) {\n-            LOG.error(\"Couldn't check cookies, networking is broken\", uhe);\n-            throw new BookieException.InvalidCookieException(uhe);\n-        } catch (IOException ioe) {\n-            LOG.error(\"Error accessing cookie on disks\", ioe);\n-            throw new BookieException.InvalidCookieException(ioe);\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"Thread interrupted while checking cookies, exiting\", ie);\n-            throw new BookieException.InvalidCookieException(ie);\n-        }\n-    }\n-\n-    /**\n-     * Return the configured address of the bookie.\n-     */\n-    public static BookieSocketAddress getBookieAddress(ServerConfiguration conf)\n-            throws UnknownHostException {\n-        String iface = conf.getListeningInterface();\n-        if (iface == null) {\n-            iface = \"default\";\n-        }\n-        InetSocketAddress inetAddr = new InetSocketAddress(DNS.getDefaultHost(iface), conf.getBookiePort());\n-        String hostAddress = inetAddr.getAddress().getHostAddress();\n-        if (conf.getUseHostNameAsBookieID()) {\n-            hostAddress = inetAddr.getAddress().getCanonicalHostName();\n-        }\n-        BookieSocketAddress addr =\n-                new BookieSocketAddress(hostAddress, conf.getBookiePort());\n-        if (addr.getSocketAddress().getAddress().isLoopbackAddress()\n-            && !conf.getAllowLoopback()) {\n-            throw new UnknownHostException(\"Trying to listen on loopback address, \"\n-                    + addr + \" but this is forbidden by default \"\n-                    + \"(see ServerConfiguration#getAllowLoopback())\");\n-        }\n-        return addr;\n-    }\n-\n-    private String getInstanceId(ZooKeeper zk) throws KeeperException,\n-            InterruptedException {\n-        String instanceId = null;\n-        if (zk.exists(conf.getZkLedgersRootPath(), null) == null) {\n-            LOG.error(\"BookKeeper metadata doesn't exist in zookeeper. \"\n-                      + \"Has the cluster been initialized? \"\n-                      + \"Try running bin/bookkeeper shell metaformat\");\n-            throw new KeeperException.NoNodeException(\"BookKeeper metadata\");\n-        }\n-        try {\n-            byte[] data = zk.getData(conf.getZkLedgersRootPath() + \"/\"\n-                    + BookKeeperConstants.INSTANCEID, false, null);\n-            instanceId = new String(data, UTF_8);\n-        } catch (KeeperException.NoNodeException e) {\n-            LOG.info(\"INSTANCEID not exists in zookeeper. Not considering it for data verification\");\n-        }\n-        return instanceId;\n-    }\n-\n-    public LedgerDirsManager getLedgerDirsManager() {\n-        return ledgerDirsManager;\n-    }\n-\n-    LedgerDirsManager getIndexDirsManager() {\n-        return indexDirsManager;\n-    }\n-\n-    public static File getCurrentDirectory(File dir) {\n-        return new File(dir, BookKeeperConstants.CURRENT_DIR);\n-    }\n-\n-    public static File[] getCurrentDirectories(File[] dirs) {\n-        File[] currentDirs = new File[dirs.length];\n-        for (int i = 0; i < dirs.length; i++) {\n-            currentDirs[i] = getCurrentDirectory(dirs[i]);\n-        }\n-        return currentDirs;\n-    }\n-\n-    public Bookie(ServerConfiguration conf)\n-            throws IOException, KeeperException, InterruptedException, BookieException {\n-        this(conf, NullStatsLogger.INSTANCE);\n-    }\n-\n-    public Bookie(ServerConfiguration conf, StatsLogger statsLogger)\n-            throws IOException, KeeperException, InterruptedException, BookieException {\n-        super(\"Bookie-\" + conf.getBookiePort());\n-        this.bookieRegistrationPath = conf.getZkAvailableBookiesPath() + \"/\";\n-        this.conf = conf;\n-        this.journalDirectory = getCurrentDirectory(conf.getJournalDir());\n-        this.ledgerDirsManager = new LedgerDirsManager(conf, conf.getLedgerDirs(),\n-                statsLogger.scope(LD_LEDGER_SCOPE));\n-        File[] idxDirs = conf.getIndexDirs();\n-        if (null == idxDirs) {\n-            this.indexDirsManager = this.ledgerDirsManager;\n-        } else {\n-            this.indexDirsManager = new LedgerDirsManager(conf, idxDirs,\n-                    statsLogger.scope(LD_INDEX_SCOPE));\n-        }\n-\n-        // instantiate zookeeper client to initialize ledger manager\n-        this.zk = instantiateZookeeperClient(conf);\n-        checkEnvironment(this.zk);\n-        ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n-        LOG.info(\"instantiate ledger manager {}\", ledgerManagerFactory.getClass().getName());\n-        ledgerManager = ledgerManagerFactory.newLedgerManager();\n-\n-        // Initialise ledgerDirManager. This would look through all the\n-        // configured directories. When disk errors or all the ledger\n-        // directories are full, would throws exception and fail bookie startup.\n-        this.ledgerDirsManager.init();\n-        // instantiate the journal\n-        journal = new Journal(conf, ledgerDirsManager);\n-        // Check the type of storage.\n-        if (conf.getSortedLedgerStorageEnabled()) {\n-            ledgerStorage = new SortedLedgerStorage(conf, ledgerManager,\n-                                                    ledgerDirsManager, indexDirsManager,\n-                                                    journal, statsLogger);\n-        } else {\n-            ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager,\n-                                                         ledgerDirsManager, indexDirsManager,\n-                                                         journal, statsLogger);\n-        }\n-        syncThread = new SyncThread(conf, getLedgerDirsListener(),\n-                                    ledgerStorage, journal);\n-\n-        handles = new HandleFactoryImpl(ledgerStorage);\n-\n-        // ZK ephemeral node for this Bookie.\n-        String myID = getMyId();\n-        zkBookieRegPath = this.bookieRegistrationPath + myID;\n-        zkBookieReadOnlyPath = this.bookieRegistrationPath + BookKeeperConstants.READONLY + \"/\" + myID;\n-\n-        // Expose Stats\n-        writeBytes = statsLogger.getCounter(WRITE_BYTES);\n-        readBytes = statsLogger.getCounter(READ_BYTES);\n-        // 1 : up, 0 : readonly\n-        statsLogger.registerGauge(SERVER_STATUS, new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return readOnly.get() ? 0 : 1;\n-            }\n-        });\n-    }\n-\n-    private String getMyId() throws UnknownHostException {\n-        return Bookie.getBookieAddress(conf).toString();\n-    }\n-\n-    void readJournal() throws IOException, BookieException {\n-        journal.replay(new JournalScanner() {\n-            @Override\n-            public void process(int journalVersion, long offset, ByteBuffer recBuff) throws IOException {\n-                long ledgerId = recBuff.getLong();\n-                long entryId = recBuff.getLong();\n-                try {\n-                    LOG.debug(\"Replay journal - ledger id : {}, entry id : {}.\", ledgerId, entryId);\n-                    if (entryId == METAENTRY_ID_LEDGER_KEY) {\n-                        if (journalVersion >= JournalChannel.V3) {\n-                            int masterKeyLen = recBuff.getInt();\n-                            byte[] masterKey = new byte[masterKeyLen];\n-\n-                            recBuff.get(masterKey);\n-                            masterKeyCache.put(ledgerId, masterKey);\n-                        } else {\n-                            throw new IOException(\"Invalid journal. Contains journalKey \"\n-                                    + \" but layout version (\" + journalVersion\n-                                    + \") is too old to hold this\");\n-                        }\n-                    } else if (entryId == METAENTRY_ID_FENCE_KEY) {\n-                        if (journalVersion >= JournalChannel.V4) {\n-                            byte[] key = masterKeyCache.get(ledgerId);\n-                            if (key == null) {\n-                                key = ledgerStorage.readMasterKey(ledgerId);\n-                            }\n-                            LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n-                            handle.setFenced();\n-                        } else {\n-                            throw new IOException(\"Invalid journal. Contains fenceKey \"\n-                                    + \" but layout version (\" + journalVersion\n-                                    + \") is too old to hold this\");\n-                        }\n-                    } else {\n-                        byte[] key = masterKeyCache.get(ledgerId);\n-                        if (key == null) {\n-                            key = ledgerStorage.readMasterKey(ledgerId);\n-                        }\n-                        LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n-\n-                        recBuff.rewind();\n-                        handle.addEntry(recBuff);\n-                    }\n-                } catch (NoLedgerException nsle) {\n-                    LOG.debug(\"Skip replaying entries of ledger {} since it was deleted.\", ledgerId);\n-                } catch (BookieException be) {\n-                    throw new IOException(be);\n-                }\n-            }\n-        });\n-    }\n-\n-    @Override\n-    synchronized public void start() {\n-        setDaemon(true);\n-        LOG.debug(\"I'm starting a bookie with journal directory {}\", journalDirectory.getName());\n-        //Start DiskChecker thread\n-        ledgerDirsManager.start();\n-        if (indexDirsManager != ledgerDirsManager) {\n-            indexDirsManager.start();\n-        }\n-        // replay journals\n-        try {\n-            readJournal();\n-        } catch (IOException ioe) {\n-            LOG.error(\"Exception while replaying journals, shutting down\", ioe);\n-            shutdown(ExitCode.BOOKIE_EXCEPTION);\n-            return;\n-        } catch (BookieException be) {\n-            LOG.error(\"Exception while replaying journals, shutting down\", be);\n-            shutdown(ExitCode.BOOKIE_EXCEPTION);\n-            return;\n-        }\n-        LOG.info(\"Finished reading journal, starting bookie\");\n-        // start bookie thread\n-        super.start();\n-\n-        // After successful bookie startup, register listener for disk\n-        // error/full notifications.\n-        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n-        if (indexDirsManager != ledgerDirsManager) {\n-            indexDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n-        }\n-\n-        ledgerStorage.start();\n-\n-        syncThread.start();\n-        // set running here.\n-        // since bookie server use running as a flag to tell bookie server whether it is alive\n-        // if setting it in bookie thread, the watcher might run before bookie thread.\n-        running = true;\n-        try {\n-            registerBookie(conf);\n-        } catch (IOException e) {\n-            LOG.error(\"Couldn't register bookie with zookeeper, shutting down\", e);\n-            shutdown(ExitCode.ZK_REG_FAIL);\n-        }\n-    }\n-\n-    /*\n-     * Get the DiskFailure listener for the bookie\n-     */\n-    private LedgerDirsListener getLedgerDirsListener() {\n-\n-        return new LedgerDirsListener() {\n-\n-            @Override\n-            public void diskFull(File disk) {\n-                // Nothing needs to be handled here.\n-            }\n-\n-            @Override\n-            public void diskAlmostFull(File disk) {\n-                // Nothing needs to be handled here.\n-            }\n-\n-            @Override\n-            public void diskFailed(File disk) {\n-                // Shutdown the bookie on disk failure.\n-                triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n-            }\n-\n-            @Override\n-            public void allDisksFull() {\n-                // Transition to readOnly mode on all disks full\n-                transitionToReadOnlyMode();\n-            }\n-\n-            @Override\n-            public void fatalError() {\n-                LOG.error(\"Fatal error reported by ledgerDirsManager\");\n-                triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n-            }\n-\n-            @Override\n-            public void diskWritable(File disk) {\n-                // Transition to writable mode when a disk becomes writable again.\n-                transitionToWritableMode();\n-            }\n-\n-            @Override\n-            public void diskJustWritable(File disk) {\n-                // Transition to writable mode when a disk becomes writable again.\n-                transitionToWritableMode();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Register jmx with parent\n-     *\n-     * @param parent parent bk mbean info\n-     */\n-    public void registerJMX(BKMBeanInfo parent) {\n-        try {\n-            jmxBookieBean = new BookieBean(this);\n-            BKMBeanRegistry.getInstance().register(jmxBookieBean, parent);\n-\n-            try {\n-                jmxLedgerStorageBean = this.ledgerStorage.getJMXBean();\n-                BKMBeanRegistry.getInstance().register(jmxLedgerStorageBean, jmxBookieBean);\n-            } catch (Exception e) {\n-                LOG.warn(\"Failed to register with JMX for ledger cache\", e);\n-                jmxLedgerStorageBean = null;\n-            }\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to register with JMX\", e);\n-            jmxBookieBean = null;\n-        }\n-    }\n-\n-    /**\n-     * Unregister jmx\n-     */\n-    public void unregisterJMX() {\n-        try {\n-            if (jmxLedgerStorageBean != null) {\n-                BKMBeanRegistry.getInstance().unregister(jmxLedgerStorageBean);\n-            }\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to unregister with JMX\", e);\n-        }\n-        try {\n-            if (jmxBookieBean != null) {\n-                BKMBeanRegistry.getInstance().unregister(jmxBookieBean);\n-            }\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to unregister with JMX\", e);\n-        }\n-        jmxBookieBean = null;\n-        jmxLedgerStorageBean = null;\n-    }\n-\n-\n-    /**\n-     * Instantiate the ZooKeeper client for the Bookie.\n-     */\n-    private ZooKeeper instantiateZookeeperClient(ServerConfiguration conf)\n-            throws IOException, InterruptedException, KeeperException {\n-        if (conf.getZkServers() == null) {\n-            LOG.warn(\"No ZK servers passed to Bookie constructor so BookKeeper clients won't know about this server!\");\n-            return null;\n-        }\n-        // Create the ZooKeeper client instance\n-        return newZookeeper(conf.getZkServers(), conf.getZkTimeout());\n-    }\n-\n-    /**\n-     * Check existence of <i>regPath</i> and wait it expired if possible\n-     *\n-     * @param regPath\n-     *          reg node path.\n-     * @return true if regPath exists, otherwise return false\n-     * @throws IOException if can't create reg path\n-     */\n-    protected boolean checkRegNodeAndWaitExpired(String regPath) throws IOException {\n-        final CountDownLatch prevNodeLatch = new CountDownLatch(1);\n-        Watcher zkPrevRegNodewatcher = new Watcher() {\n-            @Override\n-            public void process(WatchedEvent event) {\n-                // Check for prev znode deletion. Connection expiration is\n-                // not handling, since bookie has logic to shutdown.\n-                if (EventType.NodeDeleted == event.getType()) {\n-                    prevNodeLatch.countDown();\n-                }\n-            }\n-        };\n-        try {\n-            Stat stat = zk.exists(regPath, zkPrevRegNodewatcher);\n-            if (null != stat) {\n-                // if the ephemeral owner isn't current zookeeper client\n-                // wait for it to be expired.\n-                if (stat.getEphemeralOwner() != zk.getSessionId()) {\n-                    LOG.info(\"Previous bookie registration znode: {} exists, so waiting zk sessiontimeout:\"\n-                            + \" {} ms for znode deletion\", regPath, conf.getZkTimeout());\n-                    // waiting for the previous bookie reg znode deletion\n-                    if (!prevNodeLatch.await(conf.getZkTimeout(), TimeUnit.MILLISECONDS)) {\n-                        throw new NodeExistsException(regPath);\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        } catch (KeeperException ke) {\n-            LOG.error(\"ZK exception checking and wait ephemeral znode {} expired : \", regPath, ke);\n-            throw new IOException(\"ZK exception checking and wait ephemeral znode \"\n-                    + regPath + \" expired\", ke);\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"Interrupted checking and wait ephemeral znode {} expired : \", regPath, ie);\n-            throw new IOException(\"Interrupted checking and wait ephemeral znode \"\n-                    + regPath + \" expired\", ie);\n-        }\n-    }\n-\n-    /**\n-     * Register as an available bookie\n-     */\n-    protected void registerBookie(ServerConfiguration conf) throws IOException {\n-        if (null == zk) {\n-            // zookeeper instance is null, means not register itself to zk\n-            return;\n-        }\n-\n-        // ZK ephemeral node for this Bookie.\n-        try{\n-            if (!checkRegNodeAndWaitExpired(zkBookieRegPath)) {\n-                // Create the ZK ephemeral node for this Bookie.\n-                zk.create(zkBookieRegPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n-                        CreateMode.EPHEMERAL);\n-            }\n-        } catch (KeeperException ke) {\n-            LOG.error(\"ZK exception registering ephemeral Znode for Bookie!\", ke);\n-            // Throw an IOException back up. This will cause the Bookie\n-            // constructor to error out. Alternatively, we could do a System\n-            // exit here as this is a fatal error.\n-            throw new IOException(ke);\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"ZK exception registering ephemeral Znode for Bookie!\",\n-                    ie);\n-            // Throw an IOException back up. This will cause the Bookie\n-            // constructor to error out. Alternatively, we could do a System\n-            // exit here as this is a fatal error.\n-            throw new IOException(ie);\n-        }\n-    }\n-\n-    /**\n-     * Transition the bookie from readOnly mode to writable\n-     */\n-    @VisibleForTesting\n-    public void transitionToWritableMode() {\n-        if (!readOnly.compareAndSet(true, false)) {\n-            return;\n-        }\n-        LOG.info(\"Transitioning Bookie to Writable mode and will serve read/write requests.\");\n-        try {\n-            this.registerBookie(conf);\n-        } catch (IOException e) {\n-            LOG.warn(\"Error in transitioning back to writable mode : \", e);\n-            transitionToReadOnlyMode();\n-            return;\n-        }\n-        // clear the readonly state\n-        try {\n-            zk.delete(zkBookieReadOnlyPath, -1);\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            LOG.warn(\"Interrupted clearing readonly state while transitioning to writable mode : \", e);\n-            return;\n-        } catch (KeeperException e) {\n-            // if we failed when deleting the readonly flag in zookeeper, it is OK since client would\n-            // already see the bookie in writable list. so just log the exception\n-            LOG.warn(\"Failed to delete bookie readonly state in zookeeper : \", e);\n-            return;\n-        }\n-    }\n-\n-    /**\n-     * Transition the bookie to readOnly mode\n-     */\n-    @VisibleForTesting\n-    public void transitionToReadOnlyMode() {\n-        if (shuttingdown) {\n-            return;\n-        }\n-\n-        if (!readOnly.compareAndSet(false, true)) {\n-            return;\n-        }\n-        if (!conf.isReadOnlyModeEnabled()) {\n-            LOG.warn(\"ReadOnly mode is not enabled. \"\n-                    + \"Can be enabled by configuring \"\n-                    + \"'readOnlyModeEnabled=true' in configuration.\"\n-                    + \"Shutting down bookie\");\n-            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n-            return;\n-        }\n-        LOG.info(\"Transitioning Bookie to ReadOnly mode,\"\n-                + \" and will serve only read requests from clients!\");\n-        try {\n-            if (null == zk.exists(this.bookieRegistrationPath\n-                    + BookKeeperConstants.READONLY, false)) {\n-                try {\n-                    zk.create(this.bookieRegistrationPath\n-                            + BookKeeperConstants.READONLY, new byte[0],\n-                            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-                } catch (NodeExistsException e) {\n-                    // this node is just now created by someone.\n-                }\n-            }\n-            if (!checkRegNodeAndWaitExpired(zkBookieReadOnlyPath)) {\n-                // Create the readonly node\n-                zk.create(zkBookieReadOnlyPath,\n-                        new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n-            }\n-            try {\n-                // Clear the current registered node\n-                zk.delete(zkBookieRegPath, -1);\n-            } catch (KeeperException.NoNodeException nne) {\n-                LOG.warn(\"No writable bookie registered node {} when transitioning to readonly\",\n-                        zkBookieRegPath, nne);\n-            }\n-        } catch (IOException e) {\n-            LOG.error(\"Error in transition to ReadOnly Mode.\"\n-                    + \" Shutting down\", e);\n-            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n-            return;\n-        } catch (KeeperException e) {\n-            LOG.error(\"Error in transition to ReadOnly Mode.\"\n-                    + \" Shutting down\", e);\n-            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n-            return;\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            LOG.warn(\"Interrupted Exception while transitioning to ReadOnly Mode.\");\n-            return;\n-        }\n-    }\n-\n-    /*\n-     * Check whether Bookie is writable\n-     */\n-    public boolean isReadOnly() {\n-        return readOnly.get();\n-    }\n-\n-    /**\n-     * Create a new zookeeper client to zk cluster.\n-     *\n-     * <p>\n-     * Bookie Server just used zk client when syncing ledgers for garbage collection.\n-     * So when zk client is expired, it means this bookie server is not available in\n-     * bookie server list. The bookie client will be notified for its expiration. No\n-     * more bookie request will be sent to this server. So it's better to exit when zk\n-     * expired.\n-     * </p>\n-     * <p>\n-     * Since there are lots of bk operations cached in queue, so we wait for all the operations\n-     * are processed and quit. It is done by calling <b>shutdown</b>.\n-     * </p>\n-     *\n-     * @param zkServers the quorum list of zk servers\n-     * @param sessionTimeout session timeout of zk connection\n-     *\n-     * @return zk client instance\n-     */\n-    private ZooKeeper newZookeeper(final String zkServers,\n-            final int sessionTimeout) throws IOException, InterruptedException,\n-            KeeperException {\n-        ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(conf.getZkTimeout()) {\n-            @Override\n-            public void process(WatchedEvent event) {\n-                // Check for expired connection.\n-                if (event.getState().equals(Watcher.Event.KeeperState.Expired)) {\n-                    LOG.error(\"ZK client connection to the ZK server has expired!\");\n-                    shutdown(ExitCode.ZK_EXPIRED);\n-                } else {\n-                    super.process(event);\n-                }\n-            }\n-        };\n-        return ZkUtils.createConnectedZookeeperClient(zkServers, w);\n-    }\n-\n-    public boolean isRunning() {\n-        return running;\n-    }\n-\n-    @Override\n-    public void run() {\n-        // bookie thread wait for journal thread\n-        try {\n-            // start journal\n-            journal.start();\n-            // wait until journal quits\n-            journal.join();\n-        } catch (InterruptedException ie) {\n-        }\n-        // if the journal thread quits due to shutting down, it is ok\n-        if (!shuttingdown) {\n-            // some error found in journal thread and it quits\n-            // following add operations to it would hang unit client timeout\n-            // so we should let bookie server exists\n-            LOG.error(\"Journal manager quits unexpectedly.\");\n-            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n-        }\n-    }\n-\n-    // Triggering the Bookie shutdown in its own thread,\n-    // because shutdown can be called from sync thread which would be\n-    // interrupted by shutdown call.\n-    AtomicBoolean shutdownTriggered = new AtomicBoolean(false);\n-    void triggerBookieShutdown(final int exitCode) {\n-        if (!shutdownTriggered.compareAndSet(false, true)) {\n-            return;\n-        }\n-        LOG.info(\"Triggering shutdown of Bookie-{} with exitCode {}\",\n-                 conf.getBookiePort(), exitCode);\n-        BookieThread th = new BookieThread(\"BookieShutdownTrigger\") {\n-            @Override\n-            public void run() {\n-                Bookie.this.shutdown(exitCode);\n-            }\n-        };\n-        th.start();\n-    }\n-\n-    // provided a public shutdown method for other caller\n-    // to shut down bookie gracefully\n-    public int shutdown() {\n-        return shutdown(ExitCode.OK);\n-    }\n-\n-    // internal shutdown method to let shutdown bookie gracefully\n-    // when encountering exception\n-    synchronized int shutdown(int exitCode) {\n-        try {\n-            if (running) { // avoid shutdown twice\n-                // the exitCode only set when first shutdown usually due to exception found\n-                LOG.info(\"Shutting down Bookie-{} with exitCode {}\",\n-                         conf.getBookiePort(), exitCode);\n-                if (this.exitCode == ExitCode.OK) {\n-                    this.exitCode = exitCode;\n-                }\n-                // mark bookie as in shutting down progress\n-                shuttingdown = true;\n-\n-                // Shutdown journal\n-                journal.shutdown();\n-                this.join();\n-                syncThread.shutdown();\n-\n-                // Shutdown the EntryLogger which has the GarbageCollector Thread running\n-                ledgerStorage.shutdown();\n-\n-                // close Ledger Manager\n-                try {\n-                    ledgerManager.close();\n-                    ledgerManagerFactory.uninitialize();\n-                } catch (IOException ie) {\n-                    LOG.error(\"Failed to close active ledger manager : \", ie);\n-                }\n-\n-                //Shutdown disk checker\n-                ledgerDirsManager.shutdown();\n-                if (indexDirsManager != ledgerDirsManager) {\n-                    indexDirsManager.shutdown();\n-                }\n-\n-                // Shutdown the ZK client\n-                if(zk != null) zk.close();\n-            }\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"Interrupted during shutting down bookie : \", ie);\n-        } finally {\n-            // setting running to false here, so watch thread\n-            // in bookie server know it only after bookie shut down\n-            running = false;\n-        }\n-        return this.exitCode;\n-    }\n-\n-    /**\n-     * Retrieve the ledger descriptor for the ledger which entry should be added to.\n-     * The LedgerDescriptor returned from this method should be eventually freed with\n-     * #putHandle().\n-     *\n-     * @throws BookieException if masterKey does not match the master key of the ledger\n-     */\n-    private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey)\n-            throws IOException, BookieException {\n-        long ledgerId = entry.getLong();\n-        LedgerDescriptor l = handles.getHandle(ledgerId, masterKey);\n-        if (!masterKeyCache.containsKey(ledgerId)) {\n-            // new handle, we should add the key to journal ensure we can rebuild\n-            ByteBuffer bb = ByteBuffer.allocate(8 + 8 + 4 + masterKey.length);\n-            bb.putLong(ledgerId);\n-            bb.putLong(METAENTRY_ID_LEDGER_KEY);\n-            bb.putInt(masterKey.length);\n-            bb.put(masterKey);\n-            bb.flip();\n-\n-            if (null == masterKeyCache.putIfAbsent(ledgerId, masterKey)) {\n-                journal.logAddEntry(bb, new NopWriteCallback(), null);\n-            }\n-        }\n-        return l;\n-    }\n-\n-    /**\n-     * Add an entry to a ledger as specified by handle.\n-     */\n-    private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCallback cb, Object ctx)\n-            throws IOException, BookieException {\n-        long ledgerId = handle.getLedgerId();\n-        entry.rewind();\n-        long entryId = handle.addEntry(entry);\n-\n-        entry.rewind();\n-        writeBytes.add(entry.remaining());\n-\n-        LOG.trace(\"Adding {}@{}\", entryId, ledgerId);\n-        journal.logAddEntry(entry, cb, ctx);\n-    }\n-\n-    /**\n-     * Add entry to a ledger, even if the ledger has previous been fenced. This should only\n-     * happen in bookie recovery or ledger recovery cases, where entries are being replicates\n-     * so that they exist on a quorum of bookies. The corresponding client side call for this\n-     * is not exposed to users.\n-     */\n-    public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n-            throws IOException, BookieException {\n-        try {\n-            LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n-            synchronized (handle) {\n-                addEntryInternal(handle, entry, cb, ctx);\n-            }\n-        } catch (NoWritableLedgerDirException e) {\n-            transitionToReadOnlyMode();\n-            throw new IOException(e);\n-        }\n-    }\n-\n-    /**\n-     * Add entry to a ledger.\n-     * @throws BookieException.LedgerFencedException if the ledger is fenced\n-     */\n-    public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n-            throws IOException, BookieException {\n-        try {\n-            LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n-            synchronized (handle) {\n-                if (handle.isFenced()) {\n-                    throw BookieException\n-                            .create(BookieException.Code.LedgerFencedException);\n-                }\n-                addEntryInternal(handle, entry, cb, ctx);\n-            }\n-        } catch (NoWritableLedgerDirException e) {\n-            transitionToReadOnlyMode();\n-            throw new IOException(e);\n-        }\n-    }\n-\n-    /**\n-     * Fences a ledger. From this point on, clients will be unable to\n-     * write to this ledger. Only recoveryAddEntry will be\n-     * able to add entries to the ledger.\n-     * This method is idempotent. Once a ledger is fenced, it can\n-     * never be unfenced. Fencing a fenced ledger has no effect.\n-     */\n-    public Future<Boolean> fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n-        LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);\n-        boolean success;\n-        synchronized (handle) {\n-            success = handle.setFenced();\n-        }\n-        if (success) {\n-            // fenced first time, we should add the key to journal ensure we can rebuild\n-            ByteBuffer bb = ByteBuffer.allocate(8 + 8);\n-            bb.putLong(ledgerId);\n-            bb.putLong(METAENTRY_ID_FENCE_KEY);\n-            bb.flip();\n-\n-            FutureWriteCallback fwc = new FutureWriteCallback();\n-            LOG.debug(\"record fenced state for ledger {} in journal.\", ledgerId);\n-            journal.logAddEntry(bb, fwc, null);\n-            return fwc.getResult();\n-        } else {\n-            // already fenced\n-            return SUCCESS_FUTURE;\n-        }\n-    }\n-\n-    public ByteBuffer readEntry(long ledgerId, long entryId)\n-            throws IOException, NoLedgerException {\n-        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n-        LOG.trace(\"Reading {}@{}\", entryId, ledgerId);\n-        ByteBuffer entry = handle.readEntry(entryId);\n-        readBytes.add(entry.remaining());\n-        return entry;\n-    }\n-\n-    // The rest of the code is test stuff\n-    static class CounterCallback implements WriteCallback {\n-        int count;\n-\n-        @Override\n-        synchronized public void writeComplete(int rc, long l, long e, BookieSocketAddress addr, Object ctx) {\n-            count--;\n-            if (count == 0) {\n-                notifyAll();\n-            }\n-        }\n-\n-        synchronized public void incCount() {\n-            count++;\n-        }\n-\n-        synchronized public void waitZero() throws InterruptedException {\n-            while (count > 0) {\n-                wait();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Format the bookie server data\n-     *\n-     * @param conf\n-     *            ServerConfiguration\n-     * @param isInteractive\n-     *            Whether format should ask prompt for confirmation if old data\n-     *            exists or not.\n-     * @param force\n-     *            If non interactive and force is true, then old data will be\n-     *            removed without confirm prompt.\n-     * @return Returns true if the format is success else returns false\n-     */\n-    public static boolean format(ServerConfiguration conf,\n-            boolean isInteractive, boolean force) {\n-        File journalDir = conf.getJournalDir();\n-        if (journalDir.exists() && journalDir.isDirectory()\n-                && journalDir.list().length != 0) {\n-            try {\n-                boolean confirm = false;\n-                if (!isInteractive) {\n-                    // If non interactive and force is set, then delete old\n-                    // data.\n-                    if (force) {\n-                        confirm = true;\n-                    } else {\n-                        confirm = false;\n-                    }\n-                } else {\n-                    confirm = IOUtils\n-                            .confirmPrompt(\"Are you sure to format Bookie data..?\");\n-                }\n-\n-                if (!confirm) {\n-                    LOG.error(\"Bookie format aborted!!\");\n-                    return false;\n-                }\n-            } catch (IOException e) {\n-                LOG.error(\"Error during bookie format\", e);\n-                return false;\n-            }\n-        }\n-        if (!cleanDir(journalDir)) {\n-            LOG.error(\"Formatting journal directory failed\");\n-            return false;\n-        }\n-\n-        File[] ledgerDirs = conf.getLedgerDirs();\n-        for (File dir : ledgerDirs) {\n-            if (!cleanDir(dir)) {\n-                LOG.error(\"Formatting ledger directory \" + dir + \" failed\");\n-                return false;\n-            }\n-        }\n-\n-        // Clean up index directories if they are separate from the ledger dirs\n-        File[] indexDirs = conf.getIndexDirs();\n-        if (null != indexDirs) {\n-            for (File dir : indexDirs) {\n-                if (!cleanDir(dir)) {\n-                    LOG.error(\"Formatting ledger directory \" + dir + \" failed\");\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        LOG.info(\"Bookie format completed successfully\");\n-        return true;\n-    }\n-\n-    private static boolean cleanDir(File dir) {\n-        if (dir.exists()) {\n-            for (File child : dir.listFiles()) {\n-                boolean delete = FileUtils.deleteQuietly(child);\n-                if (!delete) {\n-                    LOG.error(\"Not able to delete \" + child);\n-                    return false;\n-                }\n-            }\n-        } else if (!dir.mkdirs()) {\n-            LOG.error(\"Not able to create the directory \" + dir);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * @param args\n-     * @throws IOException\n-     * @throws InterruptedException\n-     */\n-    public static void main(String[] args)\n-            throws IOException, InterruptedException, BookieException, KeeperException {\n-        Bookie b = new Bookie(new ServerConfiguration());\n-        b.start();\n-        CounterCallback cb = new CounterCallback();\n-        long start = MathUtils.now();\n-        for (int i = 0; i < 100000; i++) {\n-            ByteBuffer buff = ByteBuffer.allocate(1024);\n-            buff.putLong(1);\n-            buff.putLong(i);\n-            buff.limit(1024);\n-            buff.position(0);\n-            cb.incCount();\n-            b.addEntry(buff, cb, null, new byte[0]);\n-        }\n-        cb.waitZero();\n-        long end = MathUtils.now();\n-        System.out.println(\"Took \" + (end-start) + \"ms\");\n-    }\n-\n-    /**\n-     * Returns exit code - cause of failure\n-     *\n-     * @return {@link ExitCode}\n-     */\n-    public int getExitCode() {\n-        return exitCode;\n-    }\n-}"},{"sha":"9ad7c9c123863555a6cfcaf1566d95d50c78c591","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,51 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-\n-import org.apache.bookkeeper.jmx.BKMBeanInfo;\n-\n-/**\n- * Bookie Bean\n- */\n-public class BookieBean implements BookieMXBean, BKMBeanInfo {\n-\n-    protected Bookie bk;\n-\n-    public BookieBean(Bookie bk) {\n-        this.bk = bk;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return \"Bookie\";\n-    }\n-\n-    @Override\n-    public boolean isHidden() {\n-        return false;\n-    }\n-\n-    @Override\n-    public int getQueueLength() {\n-        return bk.journal.getJournalQueueLength();\n-    }\n-\n-}"},{"sha":"53116611c9cc1528e97c224aaa8d541f07416fd4","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieCriticalThread.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieCriticalThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieCriticalThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieCriticalThread.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,45 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Thread is marked as critical and will exit, when there is an uncaught\n- * exception occurred in thread.\n- */\n-public class BookieCriticalThread extends BookieThread {\n-    private static final Logger LOG = LoggerFactory\n-            .getLogger(BookieCriticalThread.class);\n-\n-    public BookieCriticalThread(String name) {\n-        super(name);\n-    }\n-\n-    public BookieCriticalThread(Runnable thread, String name) {\n-        super(thread, name);\n-    }\n-\n-    @Override\n-    protected void handleException(Thread t, Throwable e) {\n-        LOG.error(\"Uncaught exception in thread {} and is exiting!\",\n-                t.getName(), e);\n-        Runtime.getRuntime().exit(ExitCode.BOOKIE_EXCEPTION);\n-    }\n-}"},{"sha":"b3ee280ffd44251a1564071e0ff4b09d810b7ffd","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","status":"removed","additions":0,"deletions":157,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,157 +0,0 @@\n-package org.apache.bookkeeper.bookie;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-\n-import java.lang.Exception;\n-\n-@SuppressWarnings(\"serial\")\n-public abstract class BookieException extends Exception {\n-\n-    private int code;\n-    public BookieException(int code) {\n-        this.code = code;\n-    }\n-\n-    public BookieException(int code, Throwable t) {\n-        super(t);\n-    }\n-\n-    public BookieException(int code, String reason) {\n-        super(reason);\n-    }\n-\n-    public static BookieException create(int code) {\n-        switch(code) {\n-        case Code.UnauthorizedAccessException:\n-            return new BookieUnauthorizedAccessException();\n-        case Code.LedgerFencedException:\n-            return new LedgerFencedException();\n-        case Code.InvalidCookieException:\n-            return new InvalidCookieException();\n-        case Code.UpgradeException:\n-            return new UpgradeException();\n-        default:\n-            return new BookieIllegalOpException();\n-        }\n-    }\n-\n-    public interface Code {\n-        int OK = 0;\n-        int UnauthorizedAccessException = -1;\n-\n-        int IllegalOpException = -100;\n-        int LedgerFencedException = -101;\n-\n-        int InvalidCookieException = -102;\n-        int UpgradeException = -103;\n-    }\n-\n-    public void setCode(int code) {\n-        this.code = code;\n-    }\n-\n-    public int getCode() {\n-        return this.code;\n-    }\n-\n-    public String getMessage(int code) {\n-        String err;\n-        switch(code) {\n-        case Code.OK:\n-            err = \"No problem\";\n-            break;\n-        case Code.UnauthorizedAccessException:\n-            err = \"Error while reading ledger\";\n-            break;\n-        case Code.LedgerFencedException:\n-            err = \"Ledger has been fenced; No more entries can be added\";\n-            break;\n-        case Code.InvalidCookieException:\n-            err = \"Invalid environment cookie found\";\n-            break;\n-        case Code.UpgradeException:\n-            err = \"Error performing an upgrade operation \";\n-            break;\n-        default:\n-            err = \"Invalid operation\";\n-            break;\n-        }\n-        String reason = super.getMessage();\n-        if (reason == null) {\n-            if (super.getCause() != null) {\n-                reason = super.getCause().getMessage();\n-            }\n-        }\n-        if (reason == null) {\n-            return err;\n-        } else {\n-            return String.format(\"%s [%s]\", err, reason);\n-        }\n-    }\n-\n-    public static class BookieUnauthorizedAccessException extends BookieException {\n-        public BookieUnauthorizedAccessException() {\n-            super(Code.UnauthorizedAccessException);\n-        }\n-    }\n-\n-    public static class BookieIllegalOpException extends BookieException {\n-        public BookieIllegalOpException() {\n-            super(Code.UnauthorizedAccessException);\n-        }\n-    }\n-\n-    public static class LedgerFencedException extends BookieException {\n-        public LedgerFencedException() {\n-            super(Code.LedgerFencedException);\n-        }\n-    }\n-\n-    public static class InvalidCookieException extends BookieException {\n-        public InvalidCookieException() {\n-            this(\"\");\n-        }\n-\n-        public InvalidCookieException(String reason) {\n-            super(Code.InvalidCookieException, reason);\n-        }\n-\n-        public InvalidCookieException(Throwable cause) {\n-            super(Code.InvalidCookieException, cause);\n-        }\n-    }\n-\n-    public static class UpgradeException extends BookieException {\n-        public UpgradeException() {\n-            super(Code.UpgradeException);\n-        }\n-\n-        public UpgradeException(Throwable cause) {\n-            super(Code.UpgradeException, cause);\n-        }\n-\n-        public UpgradeException(String reason) {\n-            super(Code.UpgradeException, reason);\n-        }\n-    }\n-}"},{"sha":"24f299cc5ca38db1df20917e371517b646107deb","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,31 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-\n-/**\n- * Bookie MBean\n- */\n-public interface BookieMXBean {\n-    /**\n-     * @return log entry queue length\n-     */\n-    public int getQueueLength();\n-}"},{"sha":"a9af846e642c302d9a1eddfac5ddeba85556e2db","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"removed","additions":0,"deletions":1540,"changes":1540,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,1540 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.Formatter;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.Collections;\n-import java.util.Collection;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.apache.bookkeeper.replication.AuditorElector;\n-import org.apache.bookkeeper.bookie.BookieException.InvalidCookieException;\n-import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n-import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.BookKeeperAdmin;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.LedgerMetadata;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n-import org.apache.bookkeeper.meta.LedgerManager.LedgerRange;\n-import org.apache.bookkeeper.meta.LedgerManagerFactory;\n-import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.util.EntryFormatter;\n-import org.apache.bookkeeper.util.Tool;\n-import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n-import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n-\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-\n-import com.google.common.util.concurrent.AbstractFuture;\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import org.apache.commons.configuration.Configuration;\n-import org.apache.commons.configuration.CompositeConfiguration;\n-import org.apache.commons.configuration.PropertiesConfiguration;\n-import org.apache.commons.cli.BasicParser;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.MissingArgumentException;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Bookie Shell is to provide utilities for users to administer a bookkeeper cluster.\n- */\n-public class BookieShell implements Tool {\n-\n-    static final Logger LOG = LoggerFactory.getLogger(BookieShell.class);\n-\n-    static final String ENTRY_FORMATTER_CLASS = \"entryFormatterClass\";\n-\n-    static final String CMD_METAFORMAT = \"metaformat\";\n-    static final String CMD_BOOKIEFORMAT = \"bookieformat\";\n-    static final String CMD_RECOVER = \"recover\";\n-    static final String CMD_LEDGER = \"ledger\";\n-    static final String CMD_LISTLEDGERS = \"listledgers\";\n-    static final String CMD_LEDGERMETADATA = \"ledgermetadata\";\n-    static final String CMD_LISTUNDERREPLICATED = \"listunderreplicated\";\n-    static final String CMD_WHOISAUDITOR = \"whoisauditor\";\n-    static final String CMD_SIMPLETEST = \"simpletest\";\n-    static final String CMD_READLOG = \"readlog\";\n-    static final String CMD_READJOURNAL = \"readjournal\";\n-    static final String CMD_LASTMARK = \"lastmark\";\n-    static final String CMD_AUTORECOVERY = \"autorecovery\";\n-    static final String CMD_LISTBOOKIES = \"listbookies\";\n-    static final String CMD_UPDATECOOKIE = \"updatecookie\";\n-    static final String CMD_HELP = \"help\";\n-\n-    final ServerConfiguration bkConf = new ServerConfiguration();\n-    File[] ledgerDirectories;\n-    File journalDirectory;\n-\n-    EntryLogger entryLogger = null;\n-    Journal journal = null;\n-    EntryFormatter formatter;\n-\n-    int pageSize;\n-    int entriesPerPage;\n-\n-    interface Command {\n-        public int runCmd(String[] args) throws Exception;\n-        public void printUsage();\n-    }\n-\n-    abstract class MyCommand implements Command {\n-        abstract Options getOptions();\n-        abstract String getDescription();\n-        abstract String getUsage();\n-        abstract int runCmd(CommandLine cmdLine) throws Exception;\n-\n-        String cmdName;\n-\n-        MyCommand(String cmdName) {\n-            this.cmdName = cmdName;\n-        }\n-\n-        @Override\n-        public int runCmd(String[] args) throws Exception {\n-            try {\n-                BasicParser parser = new BasicParser();\n-                CommandLine cmdLine = parser.parse(getOptions(), args);\n-                return runCmd(cmdLine);\n-            } catch (ParseException e) {\n-                LOG.error(\"Error parsing command line arguments : \", e);\n-                printUsage();\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public void printUsage() {\n-            HelpFormatter hf = new HelpFormatter();\n-            System.err.println(cmdName + \": \" + getDescription());\n-            hf.printHelp(getUsage(), getOptions());\n-        }\n-    }\n-\n-    /**\n-     * Format the bookkeeper metadata present in zookeeper\n-     */\n-    class MetaFormatCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        MetaFormatCmd() {\n-            super(CMD_METAFORMAT);\n-            opts.addOption(\"n\", \"nonInteractive\", false,\n-                    \"Whether to confirm if old data exists..?\");\n-            opts.addOption(\"f\", \"force\", false,\n-                    \"If [nonInteractive] is specified, then whether\"\n-                            + \" to force delete the old data without prompt.\");\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Format bookkeeper metadata in zookeeper\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"metaformat   [-nonInteractive] [-force]\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            boolean interactive = (!cmdLine.hasOption(\"n\"));\n-            boolean force = cmdLine.hasOption(\"f\");\n-\n-            ClientConfiguration adminConf = new ClientConfiguration(bkConf);\n-            boolean result = BookKeeperAdmin.format(adminConf, interactive,\n-                    force);\n-            return (result) ? 0 : 1;\n-        }\n-    }\n-\n-    /**\n-     * Formats the local data present in current bookie server\n-     */\n-    class BookieFormatCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        public BookieFormatCmd() {\n-            super(CMD_BOOKIEFORMAT);\n-            opts.addOption(\"n\", \"nonInteractive\", false,\n-                    \"Whether to confirm if old data exists..?\");\n-            opts.addOption(\"f\", \"force\", false,\n-                    \"If [nonInteractive] is specified, then whether\"\n-                            + \" to force delete the old data without prompt..?\");\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Format the current server contents\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"bookieformat [-nonInteractive] [-force]\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            boolean interactive = (!cmdLine.hasOption(\"n\"));\n-            boolean force = cmdLine.hasOption(\"f\");\n-\n-            ServerConfiguration conf = new ServerConfiguration(bkConf);\n-            boolean result = Bookie.format(conf, interactive, force);\n-            return (result) ? 0 : 1;\n-        }\n-    }\n-\n-    /**\n-     * Recover command for ledger data recovery for failed bookie\n-     */\n-    class RecoverCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        public RecoverCmd() {\n-            super(CMD_RECOVER);\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Recover the ledger data for failed bookie\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"recover      <bookieSrc> [bookieDest]\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            String[] args = cmdLine.getArgs();\n-            if (args.length < 1) {\n-                throw new MissingArgumentException(\n-                        \"'bookieSrc' argument required\");\n-            }\n-\n-            ClientConfiguration adminConf = new ClientConfiguration(bkConf);\n-            BookKeeperAdmin admin = new BookKeeperAdmin(adminConf);\n-            try {\n-                return bkRecovery(admin, args);\n-            } finally {\n-                if (null != admin) {\n-                    admin.close();\n-                }\n-            }\n-        }\n-\n-        private int bkRecovery(BookKeeperAdmin bkAdmin, String[] args)\n-                throws InterruptedException, BKException {\n-            final String bookieSrcString[] = args[0].split(\":\");\n-            if (bookieSrcString.length != 2) {\n-                System.err.println(\"BookieSrc inputted has invalid format\"\n-                        + \"(host:port expected): \" + args[0]);\n-                return -1;\n-            }\n-            final BookieSocketAddress bookieSrc = new BookieSocketAddress(\n-                    bookieSrcString[0], Integer.parseInt(bookieSrcString[1]));\n-            BookieSocketAddress bookieDest = null;\n-            if (args.length >= 2) {\n-                final String bookieDestString[] = args[1].split(\":\");\n-                if (bookieDestString.length < 2) {\n-                    System.err.println(\"BookieDest inputted has invalid format\"\n-                            + \"(host:port expected): \" + args[1]);\n-                    return -1;\n-                }\n-                bookieDest = new BookieSocketAddress(bookieDestString[0],\n-                        Integer.parseInt(bookieDestString[1]));\n-            }\n-\n-            bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n-            return 0;\n-        }\n-    }\n-\n-    /**\n-     * Ledger Command Handles ledger related operations\n-     */\n-    class LedgerCmd extends MyCommand {\n-        Options lOpts = new Options();\n-\n-        LedgerCmd() {\n-            super(CMD_LEDGER);\n-            lOpts.addOption(\"m\", \"meta\", false, \"Print meta information\");\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            String[] leftArgs = cmdLine.getArgs();\n-            if (leftArgs.length <= 0) {\n-                System.err.println(\"ERROR: missing ledger id\");\n-                printUsage();\n-                return -1;\n-            }\n-\n-            boolean printMeta = false;\n-            if (cmdLine.hasOption(\"m\")) {\n-                printMeta = true;\n-            }\n-            long ledgerId;\n-            try {\n-                ledgerId = Long.parseLong(leftArgs[0]);\n-            } catch (NumberFormatException nfe) {\n-                System.err.println(\"ERROR: invalid ledger id \" + leftArgs[0]);\n-                printUsage();\n-                return -1;\n-            }\n-            if (printMeta) {\n-                // print meta\n-                readLedgerMeta(ledgerId);\n-            }\n-            // dump ledger info\n-            readLedgerIndexEntries(ledgerId);\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Dump ledger index entries into readable format.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"ledger       [-m] <ledger_id>\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return lOpts;\n-        }\n-    }\n-\n-    /**\n-     * Command for listing underreplicated ledgers\n-     */\n-    class ListUnderreplicatedCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        public ListUnderreplicatedCmd() {\n-            super(CMD_LISTUNDERREPLICATED);\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"List ledgers marked as underreplicated\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"listunderreplicated\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            ZooKeeper zk = null;\n-            try {\n-                ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(bkConf.getZkTimeout());\n-                zk = ZkUtils.createConnectedZookeeperClient(bkConf.getZkServers(), w);\n-                LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bkConf, zk);\n-                LedgerUnderreplicationManager underreplicationManager = mFactory.newLedgerUnderreplicationManager();\n-                Iterator<Long> iter = underreplicationManager.listLedgersToRereplicate();\n-                while (iter.hasNext()) {\n-                    System.out.println(iter.next());\n-                }\n-            } finally {\n-                if (zk != null) {\n-                    zk.close();\n-                }\n-            }\n-\n-            return 0;\n-        }\n-    }\n-\n-    final static int LIST_BATCH_SIZE = 1000;\n-    /**\n-     * Command to list all ledgers in the cluster\n-     */\n-    class ListLedgersCmd extends MyCommand {\n-        Options lOpts = new Options();\n-\n-        ListLedgersCmd() {\n-            super(CMD_LISTLEDGERS);\n-            lOpts.addOption(\"m\", \"meta\", false, \"Print metadata\");\n-\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            ZooKeeper zk = null;\n-            try {\n-                ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(bkConf.getZkTimeout());\n-                zk = ZkUtils.createConnectedZookeeperClient(bkConf.getZkServers(), w);\n-                LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bkConf, zk);\n-                LedgerManager m = mFactory.newLedgerManager();\n-                LedgerRangeIterator iter = m.getLedgerRanges();\n-                if (cmdLine.hasOption(\"m\")) {\n-                    List<ReadMetadataCallback> futures\n-                        = new ArrayList<ReadMetadataCallback>(LIST_BATCH_SIZE);\n-                    while (iter.hasNext()) {\n-                        LedgerRange r = iter.next();\n-                        for (Long lid : r.getLedgers()) {\n-                            ReadMetadataCallback cb = new ReadMetadataCallback(lid);\n-                            m.readLedgerMetadata(lid, cb);\n-                            futures.add(cb);\n-                        }\n-                        if (futures.size() >= LIST_BATCH_SIZE) {\n-                            while (futures.size() > 0) {\n-                                ReadMetadataCallback cb = futures.remove(0);\n-                                printLedgerMetadata(cb);\n-                            }\n-                        }\n-                    }\n-                    while (futures.size() > 0) {\n-                        ReadMetadataCallback cb = futures.remove(0);\n-                        printLedgerMetadata(cb);\n-                    }\n-                } else {\n-                    while (iter.hasNext()) {\n-                        LedgerRange r = iter.next();\n-                        for (Long lid : r.getLedgers()) {\n-                            System.out.println(Long.toString(lid));\n-                        }\n-                    }\n-                }\n-            } finally {\n-                if (zk != null) {\n-                    zk.close();\n-                }\n-            }\n-\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"List all ledgers on the cluster (this may take a long time)\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"listledgers  [-meta]\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return lOpts;\n-        }\n-    }\n-\n-    static void printLedgerMetadata(ReadMetadataCallback cb) throws Exception {\n-        LedgerMetadata md = cb.get();\n-        System.out.println(\"ledgerID: \" + cb.getLedgerId());\n-        System.out.println(new String(md.serialize(), UTF_8));\n-    }\n-\n-    static class ReadMetadataCallback extends AbstractFuture<LedgerMetadata>\n-        implements GenericCallback<LedgerMetadata> {\n-        final long ledgerId;\n-\n-        ReadMetadataCallback(long ledgerId) {\n-            this.ledgerId = ledgerId;\n-        }\n-\n-        long getLedgerId() {\n-            return ledgerId;\n-        }\n-\n-        public void operationComplete(int rc, LedgerMetadata result) {\n-            if (rc != 0) {\n-                setException(BKException.create(rc));\n-            } else {\n-                set(result);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Print the metadata for a ledger\n-     */\n-    class LedgerMetadataCmd extends MyCommand {\n-        Options lOpts = new Options();\n-\n-        LedgerMetadataCmd() {\n-            super(CMD_LEDGERMETADATA);\n-            lOpts.addOption(\"l\", \"ledgerid\", true, \"Ledger ID\");\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            final long lid = getOptionLongValue(cmdLine, \"ledgerid\", -1);\n-            if (lid == -1) {\n-                System.err.println(\"Must specify a ledger id\");\n-                return -1;\n-            }\n-\n-            ZooKeeper zk = null;\n-            try {\n-                ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(bkConf.getZkTimeout());\n-                zk = ZkUtils.createConnectedZookeeperClient(bkConf.getZkServers(), w);\n-                LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bkConf, zk);\n-                LedgerManager m = mFactory.newLedgerManager();\n-                ReadMetadataCallback cb = new ReadMetadataCallback(lid);\n-                m.readLedgerMetadata(lid, cb);\n-                printLedgerMetadata(cb);\n-            } finally {\n-                if (zk != null) {\n-                    zk.close();\n-                }\n-            }\n-\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Print the metadata for a ledger\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"ledgermetadata -ledgerid <ledgerid>\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return lOpts;\n-        }\n-    }\n-\n-    /**\n-     * Simple test to create a ledger and write to it\n-     */\n-    class SimpleTestCmd extends MyCommand {\n-        Options lOpts = new Options();\n-\n-        SimpleTestCmd() {\n-            super(CMD_SIMPLETEST);\n-            lOpts.addOption(\"e\", \"ensemble\", true, \"Ensemble size (default 3)\");\n-            lOpts.addOption(\"w\", \"writeQuorum\", true, \"Write quorum size (default 2)\");\n-            lOpts.addOption(\"a\", \"ackQuorum\", true, \"Ack quorum size (default 2)\");\n-            lOpts.addOption(\"n\", \"numEntries\", true, \"Entries to write (default 1000)\");\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            byte[] data = new byte[100]; // test data\n-\n-            int ensemble = getOptionIntValue(cmdLine, \"ensemble\", 3);\n-            int writeQuorum = getOptionIntValue(cmdLine, \"writeQuorum\", 2);\n-            int ackQuorum = getOptionIntValue(cmdLine, \"ackQuorum\", 2);\n-            int numEntries = getOptionIntValue(cmdLine, \"numEntries\", 1000);\n-\n-            ClientConfiguration conf = new ClientConfiguration();\n-            conf.addConfiguration(bkConf);\n-            BookKeeper bk = new BookKeeper(conf);\n-            LedgerHandle lh = bk.createLedger(ensemble, writeQuorum, ackQuorum,\n-                                              BookKeeper.DigestType.MAC, new byte[0]);\n-            System.out.println(\"Ledger ID: \" + lh.getId());\n-            long lastReport = System.nanoTime();\n-            for (int i = 0; i < numEntries; i++) {\n-                lh.addEntry(data);\n-                if (TimeUnit.SECONDS.convert(System.nanoTime() - lastReport,\n-                                             TimeUnit.NANOSECONDS) > 1) {\n-                    System.out.println(i + \" entries written\");\n-                    lastReport = System.nanoTime();\n-                }\n-            }\n-\n-            lh.close();\n-            bk.close();\n-            System.out.println(numEntries + \" entries written to ledger \" + lh.getId());\n-\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Simple test to create a ledger and write entries to it\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"simpletest   [-ensemble N] [-writeQuorum N] [-ackQuorum N] [-numEntries N]\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return lOpts;\n-        }\n-    }\n-\n-    /**\n-     * Command to read entry log files.\n-     */\n-    class ReadLogCmd extends MyCommand {\n-        Options rlOpts = new Options();\n-\n-        ReadLogCmd() {\n-            super(CMD_READLOG);\n-            rlOpts.addOption(\"m\", \"msg\", false, \"Print message body\");\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            String[] leftArgs = cmdLine.getArgs();\n-            if (leftArgs.length <= 0) {\n-                System.err.println(\"ERROR: missing entry log id or entry log file name\");\n-                printUsage();\n-                return -1;\n-            }\n-\n-            boolean printMsg = false;\n-            if (cmdLine.hasOption(\"m\")) {\n-                printMsg = true;\n-            }\n-            long logId;\n-            try {\n-                logId = Long.parseLong(leftArgs[0]);\n-            } catch (NumberFormatException nfe) {\n-                // not a entry log id\n-                File f = new File(leftArgs[0]);\n-                String name = f.getName();\n-                if (!name.endsWith(\".log\")) {\n-                    // not a log file\n-                    System.err.println(\"ERROR: invalid entry log file name \" + leftArgs[0]);\n-                    printUsage();\n-                    return -1;\n-                }\n-                String idString = name.split(\"\\\\.\")[0];\n-                logId = Long.parseLong(idString, 16);\n-            }\n-            // scan entry log\n-            scanEntryLog(logId, printMsg);\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Scan an entry file and format the entries into readable format.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"readlog      [-msg] <entry_log_id | entry_log_file_name>\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return rlOpts;\n-        }\n-    }\n-\n-    /**\n-     * Command to read journal files\n-     */\n-    class ReadJournalCmd extends MyCommand {\n-        Options rjOpts = new Options();\n-\n-        ReadJournalCmd() {\n-            super(CMD_READJOURNAL);\n-            rjOpts.addOption(\"m\", \"msg\", false, \"Print message body\");\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            String[] leftArgs = cmdLine.getArgs();\n-            if (leftArgs.length <= 0) {\n-                System.err.println(\"ERROR: missing journal id or journal file name\");\n-                printUsage();\n-                return -1;\n-            }\n-\n-            boolean printMsg = false;\n-            if (cmdLine.hasOption(\"m\")) {\n-                printMsg = true;\n-            }\n-            long journalId;\n-            try {\n-                journalId = Long.parseLong(leftArgs[0]);\n-            } catch (NumberFormatException nfe) {\n-                // not a journal id\n-                File f = new File(leftArgs[0]);\n-                String name = f.getName();\n-                if (!name.endsWith(\".txn\")) {\n-                    // not a journal file\n-                    System.err.println(\"ERROR: invalid journal file name \" + leftArgs[0]);\n-                    printUsage();\n-                    return -1;\n-                }\n-                String idString = name.split(\"\\\\.\")[0];\n-                journalId = Long.parseLong(idString, 16);\n-            }\n-            // scan journal\n-            scanJournal(journalId, printMsg);\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Scan a journal file and format the entries into readable format.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"readjournal  [-msg] <journal_id | journal_file_name>\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return rjOpts;\n-        }\n-    }\n-\n-    /**\n-     * Command to print last log mark\n-     */\n-    class LastMarkCmd extends MyCommand {\n-        LastMarkCmd() {\n-            super(CMD_LASTMARK);\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine c) throws Exception {\n-            printLastLogMark();\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Print last log marker.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"lastmark\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return new Options();\n-        }\n-    }\n-\n-    /**\n-     * List available bookies\n-     */\n-    class ListBookiesCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        ListBookiesCmd() {\n-            super(CMD_LISTBOOKIES);\n-            opts.addOption(\"rw\", \"readwrite\", false, \"Print readwrite bookies\");\n-            opts.addOption(\"ro\", \"readonly\", false, \"Print readonly bookies\");\n-            opts.addOption(\"h\", \"hostnames\", false,\n-                    \"Also print hostname of the bookie\");\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            boolean readwrite = cmdLine.hasOption(\"rw\");\n-            boolean readonly = cmdLine.hasOption(\"ro\");\n-\n-            if ((!readwrite && !readonly) || (readwrite && readonly)) {\n-                LOG.error(\"One and only one of -readwrite and -readonly must be specified\");\n-                printUsage();\n-                return 1;\n-            }\n-            ClientConfiguration clientconf = new ClientConfiguration(bkConf)\n-                .setZkServers(bkConf.getZkServers());\n-            BookKeeperAdmin bka = new BookKeeperAdmin(clientconf);\n-\n-            int count = 0;\n-            Collection<BookieSocketAddress> bookies = new ArrayList<BookieSocketAddress>();\n-            if (cmdLine.hasOption(\"rw\")) {\n-                Collection<BookieSocketAddress> availableBookies = bka\n-                        .getAvailableBookies();\n-                bookies.addAll(availableBookies);\n-            } else if (cmdLine.hasOption(\"ro\")) {\n-                Collection<BookieSocketAddress> roBookies = bka\n-                        .getReadOnlyBookies();\n-                bookies.addAll(roBookies);\n-            }\n-            for (BookieSocketAddress b : bookies) {\n-                System.out.print(b);\n-                if (cmdLine.hasOption(\"h\")) {\n-                    System.out.print(\"\\t\" + b.getSocketAddress().getHostName());\n-                }\n-                System.out.println(\"\");\n-                count++;\n-            }\n-            if (count == 0) {\n-                System.err.println(\"No bookie exists!\");\n-                return 1;\n-            }\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"List the bookies, which are running as either readwrite or readonly mode.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"listbookies  [-readwrite|-readonly] [-hostnames]\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-    }\n-\n-    /**\n-     * Command to print help message\n-     */\n-    class HelpCmd extends MyCommand {\n-        HelpCmd() {\n-            super(CMD_HELP);\n-        }\n-\n-        @Override\n-        public int runCmd(CommandLine cmdLine) throws Exception {\n-            String[] args = cmdLine.getArgs();\n-            if (args.length == 0) {\n-                printShellUsage();\n-                return 0;\n-            }\n-            String cmdName = args[0];\n-            Command cmd = commands.get(cmdName);\n-            if (null == cmd) {\n-                System.err.println(\"Unknown command \" + cmdName);\n-                printShellUsage();\n-                return -1;\n-            }\n-            cmd.printUsage();\n-            return 0;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Describe the usage of this program or its subcommands.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"help         [COMMAND]\";\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return new Options();\n-        }\n-    }\n-\n-    /**\n-     * Command for administration of autorecovery\n-     */\n-    class AutoRecoveryCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        public AutoRecoveryCmd() {\n-            super(CMD_AUTORECOVERY);\n-            opts.addOption(\"e\", \"enable\", false,\n-                           \"Enable auto recovery of underreplicated ledgers\");\n-            opts.addOption(\"d\", \"disable\", false,\n-                           \"Disable auto recovery of underreplicated ledgers\");\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Enable or disable autorecovery in the cluster.\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"autorecovery [-enable|-disable]\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            boolean disable = cmdLine.hasOption(\"d\");\n-            boolean enable = cmdLine.hasOption(\"e\");\n-\n-            if ((!disable && !enable)\n-                || (enable && disable)) {\n-                LOG.error(\"One and only one of -enable and -disable must be specified\");\n-                printUsage();\n-                return 1;\n-            }\n-            ZooKeeper zk = null;\n-            try {\n-                ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(bkConf.getZkTimeout());\n-                zk = ZkUtils.createConnectedZookeeperClient(bkConf.getZkServers(), w);\n-                LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bkConf, zk);\n-                LedgerUnderreplicationManager underreplicationManager = mFactory.newLedgerUnderreplicationManager();\n-                if (enable) {\n-                    if (underreplicationManager.isLedgerReplicationEnabled()) {\n-                        LOG.warn(\"Autorecovery already enabled. Doing nothing\");\n-                    } else {\n-                        LOG.info(\"Enabling autorecovery\");\n-                        underreplicationManager.enableLedgerReplication();\n-                    }\n-                } else {\n-                    if (!underreplicationManager.isLedgerReplicationEnabled()) {\n-                        LOG.warn(\"Autorecovery already disabled. Doing nothing\");\n-                    } else {\n-                        LOG.info(\"Disabling autorecovery\");\n-                        underreplicationManager.disableLedgerReplication();\n-                    }\n-                }\n-            } finally {\n-                if (zk != null) {\n-                    zk.close();\n-                }\n-            }\n-\n-            return 0;\n-        }\n-    }\n-\n-    /**\n-     * Print which node has the auditor lock\n-     */\n-    class WhoIsAuditorCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        public WhoIsAuditorCmd() {\n-            super(CMD_WHOISAUDITOR);\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Print the node which holds the auditor lock\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"whoisauditor\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            ZooKeeper zk = null;\n-            try {\n-                ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(bkConf.getZkTimeout());\n-                zk = ZkUtils.createConnectedZookeeperClient(bkConf.getZkServers(), w);\n-                BookieSocketAddress bookieId = AuditorElector.getCurrentAuditor(bkConf, zk);\n-                if (bookieId == null) {\n-                    LOG.info(\"No auditor elected\");\n-                    return -1;\n-                }\n-                LOG.info(\"Auditor: {}/{}:{}\",\n-                         new Object[] {\n-                             bookieId.getSocketAddress().getAddress().getCanonicalHostName(),\n-                             bookieId.getSocketAddress().getAddress().getHostAddress(),\n-                             bookieId.getSocketAddress().getPort() });\n-            } finally {\n-                if (zk != null) {\n-                    zk.close();\n-                }\n-            }\n-\n-            return 0;\n-        }\n-    }\n-\n-    /**\n-     * Update cookie command\n-     */\n-    class UpdateCookieCmd extends MyCommand {\n-        Options opts = new Options();\n-\n-        UpdateCookieCmd() {\n-            super(CMD_UPDATECOOKIE);\n-            opts.addOption(\"b\", \"bookieId\", true, \"Bookie Id\");\n-        }\n-\n-        @Override\n-        Options getOptions() {\n-            return opts;\n-        }\n-\n-        @Override\n-        String getDescription() {\n-            return \"Update bookie id in cookie\";\n-        }\n-\n-        @Override\n-        String getUsage() {\n-            return \"updatecookie -bookieId <hostname|ip>\";\n-        }\n-\n-        @Override\n-        int runCmd(CommandLine cmdLine) throws Exception {\n-            final String bookieId = cmdLine.getOptionValue(\"bookieId\");\n-            if (StringUtils.isBlank(bookieId)) {\n-                LOG.error(\"Invalid argument list!\");\n-                this.printUsage();\n-                return -1;\n-            }\n-            if (!StringUtils.equals(bookieId, \"hostname\") && !StringUtils.equals(bookieId, \"ip\")) {\n-                LOG.error(\"Invalid option value:\" + bookieId);\n-                this.printUsage();\n-                return -1;\n-            }\n-            boolean useHostName = getOptionalValue(bookieId, \"hostname\");\n-            if (!bkConf.getUseHostNameAsBookieID() && useHostName) {\n-                LOG.error(\"Expects configuration useHostNameAsBookieID=true as the option value passed is 'hostname'\");\n-                return -1;\n-            } else if (bkConf.getUseHostNameAsBookieID() && !useHostName) {\n-                LOG.error(\"Expects configuration useHostNameAsBookieID=false as the option value passed is 'ip'\");\n-                return -1;\n-            }\n-            return updateBookieIdInCookie(bookieId, useHostName);\n-        }\n-\n-        private int updateBookieIdInCookie(final String bookieId, final boolean useHostname) throws IOException,\n-                InterruptedException {\n-            ZooKeeper zk = null;\n-            ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(bkConf.getZkTimeout());\n-            try {\n-                zk = ZkUtils.createConnectedZookeeperClient(bkConf.getZkServers(), w);\n-                ServerConfiguration conf = new ServerConfiguration(bkConf);\n-                String newBookieId = Bookie.getBookieAddress(conf).toString();\n-                // read oldcookie\n-                Versioned<Cookie> oldCookie = null;\n-                try {\n-                    conf.setUseHostNameAsBookieID(!useHostname);\n-                    oldCookie = Cookie.readFromZooKeeper(zk, conf);\n-                } catch (KeeperException.NoNodeException nne) {\n-                    LOG.error(\"Either cookie already updated with UseHostNameAsBookieID={} or no cookie exists!\",\n-                            useHostname, nne);\n-                    return -1;\n-                }\n-                Cookie newCookie = Cookie.newBuilder(oldCookie.getValue()).setBookieHost(newBookieId).build();\n-                boolean hasCookieUpdatedInDirs = verifyCookie(newCookie, journalDirectory);\n-                for (File dir : ledgerDirectories) {\n-                    hasCookieUpdatedInDirs &= verifyCookie(newCookie, dir);\n-                }\n-\n-                if (hasCookieUpdatedInDirs) {\n-                    try {\n-                        conf.setUseHostNameAsBookieID(useHostname);\n-                        Cookie.readFromZooKeeper(zk, conf);\n-                        // since newcookie exists, just do cleanup of oldcookie and return\n-                        conf.setUseHostNameAsBookieID(!useHostname);\n-                        oldCookie.getValue().deleteFromZooKeeper(zk, conf, oldCookie.getVersion());\n-                        return 0;\n-                    } catch (KeeperException.NoNodeException nne) {\n-                        LOG.debug(\"Ignoring, cookie will be written to zookeeper\");\n-                    }\n-                } else {\n-                    // writes newcookie to local dirs\n-                    newCookie.writeToDirectory(journalDirectory);\n-                    LOG.info(\"Updated cookie file present in journalDirectory {}\", journalDirectory);\n-                    for (File dir : ledgerDirectories) {\n-                        newCookie.writeToDirectory(dir);\n-                    }\n-                    LOG.info(\"Updated cookie file present in ledgerDirectories {}\", ledgerDirectories);\n-                }\n-                // writes newcookie to zookeeper\n-                conf.setUseHostNameAsBookieID(useHostname);\n-                newCookie.writeToZooKeeper(zk, conf, Version.NEW);\n-\n-                // delete oldcookie\n-                conf.setUseHostNameAsBookieID(!useHostname);\n-                oldCookie.getValue().deleteFromZooKeeper(zk, conf, oldCookie.getVersion());\n-            } catch (KeeperException ke) {\n-                LOG.error(\"KeeperException during cookie updation!\", ke);\n-                return -1;\n-            } catch (IOException ioe) {\n-                LOG.error(\"IOException during cookie updation!\", ioe);\n-                return -1;\n-            } finally {\n-                if (zk != null) {\n-                    zk.close();\n-                }\n-            }\n-            return 0;\n-        }\n-\n-        private boolean getOptionalValue(String optValue, String optName) {\n-            if (StringUtils.equals(optValue, optName)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        private boolean verifyCookie(Cookie oldCookie, File dir) throws IOException {\n-            try {\n-                Cookie cookie = Cookie.readFromDirectory(dir);\n-                cookie.verify(oldCookie);\n-            } catch (InvalidCookieException e) {\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    final Map<String, MyCommand> commands = new HashMap<String, MyCommand>();\n-    {\n-        commands.put(CMD_METAFORMAT, new MetaFormatCmd());\n-        commands.put(CMD_BOOKIEFORMAT, new BookieFormatCmd());\n-        commands.put(CMD_RECOVER, new RecoverCmd());\n-        commands.put(CMD_LEDGER, new LedgerCmd());\n-        commands.put(CMD_LISTLEDGERS, new ListLedgersCmd());\n-        commands.put(CMD_LISTUNDERREPLICATED, new ListUnderreplicatedCmd());\n-        commands.put(CMD_WHOISAUDITOR, new WhoIsAuditorCmd());\n-        commands.put(CMD_LEDGERMETADATA, new LedgerMetadataCmd());\n-        commands.put(CMD_SIMPLETEST, new SimpleTestCmd());\n-        commands.put(CMD_READLOG, new ReadLogCmd());\n-        commands.put(CMD_READJOURNAL, new ReadJournalCmd());\n-        commands.put(CMD_LASTMARK, new LastMarkCmd());\n-        commands.put(CMD_AUTORECOVERY, new AutoRecoveryCmd());\n-        commands.put(CMD_LISTBOOKIES, new ListBookiesCmd());\n-        commands.put(CMD_UPDATECOOKIE, new UpdateCookieCmd());\n-        commands.put(CMD_HELP, new HelpCmd());\n-    }\n-\n-    @Override\n-    public void setConf(Configuration conf) throws Exception {\n-        bkConf.loadConf(conf);\n-        journalDirectory = Bookie.getCurrentDirectory(bkConf.getJournalDir());\n-        ledgerDirectories = Bookie.getCurrentDirectories(bkConf.getLedgerDirs());\n-        formatter = EntryFormatter.newEntryFormatter(bkConf, ENTRY_FORMATTER_CLASS);\n-        LOG.debug(\"Using entry formatter {}\", formatter.getClass().getName());\n-        pageSize = bkConf.getPageSize();\n-        entriesPerPage = pageSize / 8;\n-    }\n-\n-    private void printShellUsage() {\n-        System.err.println(\"Usage: BookieShell [-conf configuration] <command>\");\n-        System.err.println();\n-        List<String> commandNames = new ArrayList<String>();\n-        for (MyCommand c : commands.values()) {\n-            commandNames.add(\"       \" + c.getUsage());\n-        }\n-        Collections.sort(commandNames);\n-        for (String s : commandNames) {\n-            System.err.println(s);\n-        }\n-    }\n-\n-    @Override\n-    public int run(String[] args) throws Exception {\n-        if (args.length <= 0) {\n-            printShellUsage();\n-            return -1;\n-        }\n-        String cmdName = args[0];\n-        Command cmd = commands.get(cmdName);\n-        if (null == cmd) {\n-            System.err.println(\"ERROR: Unknown command \" + cmdName);\n-            printShellUsage();\n-            return -1;\n-        }\n-        // prepare new args\n-        String[] newArgs = new String[args.length - 1];\n-        System.arraycopy(args, 1, newArgs, 0, newArgs.length);\n-        return cmd.runCmd(newArgs);\n-    }\n-\n-    public static void main(String argv[]) throws Exception {\n-        BookieShell shell = new BookieShell();\n-        if (argv.length <= 0) {\n-            shell.printShellUsage();\n-            System.exit(-1);\n-        }\n-\n-        CompositeConfiguration conf = new CompositeConfiguration();\n-        // load configuration\n-        if (\"-conf\".equals(argv[0])) {\n-            if (argv.length <= 1) {\n-                shell.printShellUsage();\n-                System.exit(-1);\n-            }\n-            conf.addConfiguration(new PropertiesConfiguration(\n-                                  new File(argv[1]).toURI().toURL()));\n-\n-            String[] newArgv = new String[argv.length - 2];\n-            System.arraycopy(argv, 2, newArgv, 0, newArgv.length);\n-            argv = newArgv;\n-        }\n-\n-\n-        shell.setConf(conf);\n-        int res = shell.run(argv);\n-        System.exit(res);\n-    }\n-\n-    ///\n-    /// Bookie File Operations\n-    ///\n-\n-    /**\n-     * Get the ledger file of a specified ledger.\n-     *\n-     * @param ledgerId\n-     *          Ledger Id\n-     *\n-     * @return file object.\n-     */\n-    private File getLedgerFile(long ledgerId) {\n-        String ledgerName = IndexPersistenceMgr.getLedgerName(ledgerId);\n-        File lf = null;\n-        for (File d : ledgerDirectories) {\n-            lf = new File(d, ledgerName);\n-            if (lf.exists()) {\n-                break;\n-            }\n-            lf = null;\n-        }\n-        return lf;\n-    }\n-\n-    /**\n-     * Get FileInfo for a specified ledger.\n-     *\n-     * @param ledgerId\n-     *          Ledger Id\n-     * @return read only file info instance\n-     */\n-    ReadOnlyFileInfo getFileInfo(long ledgerId) throws IOException {\n-        File ledgerFile = getLedgerFile(ledgerId);\n-        if (null == ledgerFile) {\n-            throw new FileNotFoundException(\"No index file found for ledger \" + ledgerId + \". It may be not flushed yet.\");\n-        }\n-        ReadOnlyFileInfo fi = new ReadOnlyFileInfo(ledgerFile, null);\n-        fi.readHeader();\n-        return fi;\n-    }\n-\n-    private synchronized void initEntryLogger() throws IOException {\n-        if (null == entryLogger) {\n-            // provide read only entry logger\n-            entryLogger = new ReadOnlyEntryLogger(bkConf);\n-        }\n-    }\n-\n-    /**\n-     * scan over entry log\n-     *\n-     * @param logId\n-     *          Entry Log Id\n-     * @param scanner\n-     *          Entry Log Scanner\n-     */\n-    protected void scanEntryLog(long logId, EntryLogScanner scanner) throws IOException {\n-        initEntryLogger();\n-        entryLogger.scanEntryLog(logId, scanner);\n-    }\n-\n-    private synchronized Journal getJournal() throws IOException {\n-        if (null == journal) {\n-            journal = new Journal(bkConf, new LedgerDirsManager(bkConf, bkConf.getLedgerDirs()));\n-        }\n-        return journal;\n-    }\n-\n-    /**\n-     * Scan journal file\n-     *\n-     * @param journalId\n-     *          Journal File Id\n-     * @param scanner\n-     *          Journal File Scanner\n-     */\n-    protected void scanJournal(long journalId, JournalScanner scanner) throws IOException {\n-        getJournal().scanJournal(journalId, 0L, scanner);\n-    }\n-\n-    ///\n-    /// Bookie Shell Commands\n-    ///\n-\n-    /**\n-     * Read ledger meta\n-     *\n-     * @param ledgerId\n-     *          Ledger Id\n-     */\n-    protected void readLedgerMeta(long ledgerId) throws Exception {\n-        System.out.println(\"===== LEDGER: \" + ledgerId + \" =====\");\n-        FileInfo fi = getFileInfo(ledgerId);\n-        byte[] masterKey = fi.getMasterKey();\n-        if (null == masterKey) {\n-            System.out.println(\"master key  : NULL\");\n-        } else {\n-            System.out.println(\"master key  : \" + bytes2Hex(fi.getMasterKey()));\n-        }\n-        long size = fi.size();\n-        if (size % 8 == 0) {\n-            System.out.println(\"size        : \" + size);\n-        } else {\n-            System.out.println(\"size : \" + size + \" (not aligned with 8, may be corrupted or under flushing now)\");\n-        }\n-        System.out.println(\"entries     : \" + (size / 8));\n-    }\n-\n-    /**\n-     * Read ledger index entires\n-     *\n-     * @param ledgerId\n-     *          Ledger Id\n-     * @throws IOException\n-     */\n-    protected void readLedgerIndexEntries(long ledgerId) throws IOException {\n-        System.out.println(\"===== LEDGER: \" + ledgerId + \" =====\");\n-        FileInfo fi = getFileInfo(ledgerId);\n-        long size = fi.size();\n-        System.out.println(\"size        : \" + size);\n-        long curSize = 0;\n-        long curEntry = 0;\n-        LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n-        lep.usePage();\n-        try {\n-            while (curSize < size) {\n-                lep.setLedgerAndFirstEntry(ledgerId, curEntry);\n-                lep.readPage(fi);\n-\n-                // process a page\n-                for (int i=0; i<entriesPerPage; i++) {\n-                    long offset = lep.getOffset(i * 8);\n-                    if (0 == offset) {\n-                        System.out.println(\"entry \" + curEntry + \"\\t:\\tN/A\");\n-                    } else {\n-                        long entryLogId = offset >> 32L;\n-                        long pos = offset & 0xffffffffL;\n-                        System.out.println(\"entry \" + curEntry + \"\\t:\\t(log:\" + entryLogId + \", pos: \" + pos + \")\");\n-                    }\n-                    ++curEntry;\n-                }\n-\n-                curSize += pageSize;\n-            }\n-        } catch (IOException ie) {\n-            LOG.error(\"Failed to read index page : \", ie);\n-            if (curSize + pageSize < size) {\n-                System.out.println(\"Failed to read index page @ \" + curSize + \", the index file may be corrupted : \" + ie.getMessage());\n-            } else {\n-                System.out.println(\"Failed to read last index page @ \" + curSize\n-                                 + \", the index file may be corrupted or last index page is not fully flushed yet : \" + ie.getMessage());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Scan over an entry log file.\n-     *\n-     * @param logId\n-     *          Entry Log File id.\n-     * @param printMsg\n-     *          Whether printing the entry data.\n-     */\n-    protected void scanEntryLog(long logId, final boolean printMsg) throws Exception {\n-        System.out.println(\"Scan entry log \" + logId + \" (\" + Long.toHexString(logId) + \".log)\");\n-        scanEntryLog(logId, new EntryLogScanner() {\n-            @Override\n-            public boolean accept(long ledgerId) {\n-                return true;\n-            }\n-            @Override\n-            public void process(long ledgerId, long startPos, ByteBuffer entry) {\n-                formatEntry(startPos, entry, printMsg);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Scan a journal file\n-     *\n-     * @param journalId\n-     *          Journal File Id\n-     * @param printMsg\n-     *          Whether printing the entry data.\n-     */\n-    protected void scanJournal(long journalId, final boolean printMsg) throws Exception {\n-        System.out.println(\"Scan journal \" + journalId + \" (\" + Long.toHexString(journalId) + \".txn)\");\n-        scanJournal(journalId, new JournalScanner() {\n-            boolean printJournalVersion = false;\n-            @Override\n-            public void process(int journalVersion, long offset, ByteBuffer entry) throws IOException {\n-                if (!printJournalVersion) {\n-                    System.out.println(\"Journal Version : \" + journalVersion);\n-                    printJournalVersion = true;\n-                }\n-                formatEntry(offset, entry, printMsg);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Print last log mark\n-     */\n-    protected void printLastLogMark() throws IOException {\n-        LogMark lastLogMark = getJournal().getLastLogMark().getCurMark();\n-        System.out.println(\"LastLogMark: Journal Id - \" + lastLogMark.getLogFileId() + \"(\"\n-                + Long.toHexString(lastLogMark.getLogFileId()) + \".txn), Pos - \"\n-                + lastLogMark.getLogFileOffset());\n-    }\n-\n-    /**\n-     * Format the message into a readable format.\n-     *\n-     * @param pos\n-     *          File offset of the message stored in entry log file\n-     * @param recBuff\n-     *          Entry Data\n-     * @param printMsg\n-     *          Whether printing the message body\n-     */\n-    private void formatEntry(long pos, ByteBuffer recBuff, boolean printMsg) {\n-        long ledgerId = recBuff.getLong();\n-        long entryId = recBuff.getLong();\n-        int entrySize = recBuff.limit();\n-\n-        System.out.println(\"--------- Lid=\" + ledgerId + \", Eid=\" + entryId\n-                         + \", ByteOffset=\" + pos + \", EntrySize=\" + entrySize + \" ---------\");\n-        if (entryId == Bookie.METAENTRY_ID_LEDGER_KEY) {\n-            int masterKeyLen = recBuff.getInt();\n-            byte[] masterKey = new byte[masterKeyLen];\n-            recBuff.get(masterKey);\n-            System.out.println(\"Type:           META\");\n-            System.out.println(\"MasterKey:      \" + bytes2Hex(masterKey));\n-            System.out.println();\n-            return;\n-        }\n-        if (entryId == Bookie.METAENTRY_ID_FENCE_KEY) {\n-            System.out.println(\"Type:           META\");\n-            System.out.println(\"Fenced\");\n-            System.out.println();\n-            return;\n-        }\n-        // process a data entry\n-        long lastAddConfirmed = recBuff.getLong();\n-        System.out.println(\"Type:           DATA\");\n-        System.out.println(\"LastConfirmed:  \" + lastAddConfirmed);\n-        if (!printMsg) {\n-            System.out.println();\n-            return;\n-        }\n-        // skip digest checking\n-        recBuff.position(32 + 8);\n-        System.out.println(\"Data:\");\n-        System.out.println();\n-        try {\n-            byte[] ret = new byte[recBuff.remaining()];\n-            recBuff.get(ret);\n-            formatter.formatEntry(ret);\n-        } catch (Exception e) {\n-            System.out.println(\"N/A. Corrupted.\");\n-        }\n-        System.out.println();\n-    }\n-\n-    static String bytes2Hex(byte[] data) {\n-        StringBuilder sb = new StringBuilder(data.length * 2);\n-        Formatter formatter = new Formatter(sb);\n-        for (byte b : data) {\n-            formatter.format(\"%02x\", b);\n-        }\n-        formatter.close();\n-        return sb.toString();\n-    }\n-\n-    private static int getOptionIntValue(CommandLine cmdLine, String option, int defaultVal) {\n-        if (cmdLine.hasOption(option)) {\n-            String val = cmdLine.getOptionValue(option);\n-            try {\n-                return Integer.parseInt(val);\n-            } catch (NumberFormatException nfe) {\n-                System.err.println(\"ERROR: invalid value for option \" + option + \" : \" + val);\n-                return defaultVal;\n-            }\n-        }\n-        return defaultVal;\n-    }\n-\n-    private static long getOptionLongValue(CommandLine cmdLine, String option, long defaultVal) {\n-        if (cmdLine.hasOption(option)) {\n-            String val = cmdLine.getOptionValue(option);\n-            try {\n-                return Long.parseLong(val);\n-            } catch (NumberFormatException nfe) {\n-                System.err.println(\"ERROR: invalid value for option \" + option + \" : \" + val);\n-                return defaultVal;\n-            }\n-        }\n-        return defaultVal;\n-    }\n-}"},{"sha":"8fddc3f677a8e0fd9a682926f78fd9fe69c2428f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieThread.java","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieThread.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,55 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/*\n-* Wrapper that wraps bookie threads\n-* Any common handing that we require for all bookie threads\n-* should be implemented here\n-*/\n-public class BookieThread extends Thread implements\n-        Thread.UncaughtExceptionHandler {\n-\n-    private static final Logger LOG = LoggerFactory\n-            .getLogger(BookieThread.class);\n-\n-    @Override\n-    public void uncaughtException(Thread t, Throwable e) {\n-        handleException(t, e);\n-    }\n-\n-    public BookieThread(String name) {\n-        super(name);\n-        setUncaughtExceptionHandler(this);\n-    }\n-\n-    public BookieThread(Runnable thread, String name) {\n-        super(thread, name);\n-        setUncaughtExceptionHandler(this);\n-    }\n-\n-    /**\n-     * Handles uncaught exception occurred in thread\n-     */\n-    protected void handleException(Thread t, Throwable e) {\n-        LOG.error(\"Uncaught exception in thread {}\", t.getName(), e);\n-    }\n-}"},{"sha":"cb7d914d7cf68307307641b13b226e1e125f2893","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","status":"removed","additions":0,"deletions":204,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,204 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import org.apache.bookkeeper.util.ZeroBuffer;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-/**\n- * Provides a buffering layer in front of a FileChannel.\n- */\n-public class BufferedChannel extends BufferedReadChannel {\n-    // The capacity of the write buffer.\n-    protected final int writeCapacity;\n-    // The position of the file channel's write pointer.\n-    protected AtomicLong writeBufferStartPosition = new AtomicLong(0);\n-    // The buffer used to write operations.\n-    protected final ByteBuffer writeBuffer;\n-    // The absolute position of the next write operation.\n-    protected volatile long position;\n-\n-    // make constructor to be public for unit test\n-    public BufferedChannel(FileChannel fc, int capacity) throws IOException {\n-        // Use the same capacity for read and write buffers.\n-        this(fc, capacity, capacity);\n-    }\n-\n-    public BufferedChannel(FileChannel fc, int writeCapacity, int readCapacity) throws IOException {\n-        super(fc, readCapacity);\n-        // Set the read buffer's limit to readCapacity.\n-        this.readBuffer.limit(readCapacity);\n-        this.writeCapacity = writeCapacity;\n-        this.position = fc.position();\n-        this.writeBufferStartPosition.set(position);\n-        this.writeBuffer = ByteBuffer.allocateDirect(writeCapacity);\n-    }\n-\n-    /**\n-     * Write all the data in src to the {@link FileChannel}. Note that this function can\n-     * buffer or re-order writes based on the implementation. These writes will be flushed\n-     * to the disk only when flush() is invoked.\n-     *\n-     * @param src The source ByteBuffer which contains the data to be written.\n-     * @throws IOException if a write operation fails.\n-     */\n-    synchronized public void write(ByteBuffer src) throws IOException {\n-        int copied = 0;\n-        while(src.remaining() > 0) {\n-            int truncated = 0;\n-            if (writeBuffer.remaining() < src.remaining()) {\n-                truncated = src.remaining() - writeBuffer.remaining();\n-                src.limit(src.limit()-truncated);\n-            }\n-            copied += src.remaining();\n-            writeBuffer.put(src);\n-            src.limit(src.limit()+truncated);\n-            // if we have run out of buffer space, we should flush to the file\n-            if (writeBuffer.remaining() == 0) {\n-                flushInternal();\n-            }\n-        }\n-        position += copied;\n-    }\n-\n-    /**\n-     * Get the position where the next write operation will begin writing from.\n-     * @return\n-     */\n-    public long position() {\n-        return position;\n-    }\n-\n-    /**\n-     * Get the position of the file channel's write pointer.\n-     * @return\n-     */\n-    public long getFileChannelPosition() {\n-        return writeBufferStartPosition.get();\n-    }\n-\n-\n-    /**\n-     * Write any data in the buffer to the file. If sync is set to true, force a sync operation so that\n-     * data is persisted to the disk.\n-     * @param shouldForceWrite\n-     * @throws IOException if the write or sync operation fails.\n-     */\n-    public void flush(boolean shouldForceWrite) throws IOException {\n-        synchronized(this) {\n-            flushInternal();\n-        }\n-        if (shouldForceWrite) {\n-            forceWrite(false);\n-        }\n-    }\n-\n-    /**\n-     * Write any data in the buffer to the file and advance the writeBufferPosition\n-     * Callers are expected to synchronize appropriately\n-     * @throws IOException if the write fails.\n-     */\n-    private void flushInternal() throws IOException {\n-        writeBuffer.flip();\n-        do {\n-            fileChannel.write(writeBuffer);\n-        } while (writeBuffer.hasRemaining());\n-        writeBuffer.clear();\n-        writeBufferStartPosition.set(fileChannel.position());\n-    }\n-\n-    public long forceWrite(boolean forceMetadata) throws IOException {\n-        // This is the point up to which we had flushed to the file system page cache\n-        // before issuing this force write hence is guaranteed to be made durable by\n-        // the force write, any flush that happens after this may or may\n-        // not be flushed\n-        long positionForceWrite = writeBufferStartPosition.get();\n-        fileChannel.force(forceMetadata);\n-        return positionForceWrite;\n-    }\n-\n-    @Override\n-    synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n-        long prevPos = pos;\n-        while(dest.remaining() > 0) {\n-            // check if it is in the write buffer\n-            if (writeBuffer != null && writeBufferStartPosition.get() <= pos) {\n-                long positionInBuffer = pos - writeBufferStartPosition.get();\n-                long bytesToCopy = writeBuffer.position()-positionInBuffer;\n-                if (bytesToCopy > dest.remaining()) {\n-                    bytesToCopy = dest.remaining();\n-                }\n-                if (bytesToCopy == 0) {\n-                    throw new IOException(\"Read past EOF\");\n-                }\n-                ByteBuffer src = writeBuffer.duplicate();\n-                src.position((int) positionInBuffer);\n-                src.limit((int) (positionInBuffer+bytesToCopy));\n-                dest.put(src);\n-                pos+= bytesToCopy;\n-            } else if (writeBuffer == null && writeBufferStartPosition.get() <= pos) {\n-                // here we reach the end\n-                break;\n-                // first check if there is anything we can grab from the readBuffer\n-            } else if (readBufferStartPosition <= pos && pos < readBufferStartPosition+readBuffer.capacity()) {\n-                long positionInBuffer = pos - readBufferStartPosition;\n-                long bytesToCopy = readBuffer.capacity()-positionInBuffer;\n-                if (bytesToCopy > dest.remaining()) {\n-                    bytesToCopy = dest.remaining();\n-                }\n-                ByteBuffer src = readBuffer.duplicate();\n-                src.position((int) positionInBuffer);\n-                src.limit((int) (positionInBuffer+bytesToCopy));\n-                dest.put(src);\n-                pos += bytesToCopy;\n-                // let's read it\n-            } else {\n-                readBufferStartPosition = pos;\n-                readBuffer.clear();\n-                // make sure that we don't overlap with the write buffer\n-                if (readBufferStartPosition + readBuffer.capacity() >= writeBufferStartPosition.get()) {\n-                    readBufferStartPosition = writeBufferStartPosition.get() - readBuffer.capacity();\n-                    if (readBufferStartPosition < 0) {\n-                        ZeroBuffer.put(readBuffer, (int)-readBufferStartPosition);\n-                    }\n-                }\n-                while(readBuffer.remaining() > 0) {\n-                    if (fileChannel.read(readBuffer, readBufferStartPosition+readBuffer.position()) <= 0) {\n-                        throw new IOException(\"Short read\");\n-                    }\n-                }\n-                ZeroBuffer.put(readBuffer);\n-                readBuffer.clear();\n-            }\n-        }\n-        return (int)(pos - prevPos);\n-    }\n-\n-    @Override\n-    synchronized public void clear() {\n-        super.clear();\n-        writeBuffer.clear();\n-    }\n-}"},{"sha":"782a39849758871512cabd9c57aba9096c2aad98","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannelBase.java","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannelBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannelBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannelBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,55 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-\n-public abstract class BufferedChannelBase {\n-    protected final FileChannel fileChannel;\n-\n-    protected BufferedChannelBase(FileChannel fc) {\n-        this.fileChannel = fc;\n-    }\n-\n-    protected FileChannel validateAndGetFileChannel() throws IOException {\n-        // Even if we have BufferedChannelBase objects in the cache, higher layers should\n-        // guarantee that once a log file has been closed and possibly deleted during garbage\n-        // collection, attempts will not be made to read from it\n-        if (!fileChannel.isOpen()) {\n-            throw new IOException(\"Attempting to access a file channel that has already been closed\");\n-        }\n-        return fileChannel;\n-    }\n-\n-    /**\n-     * Get the current size of the underlying FileChannel.\n-     * @return\n-     */\n-    public long size() throws IOException {\n-        return validateAndGetFileChannel().size();\n-    }\n-\n-    /**\n-     * Get the {@link FileChannel} that this BufferedChannel wraps around.\n-     * @return\n-     */\n-    public FileChannel getFileChannel() {\n-        return fileChannel;\n-    }\n-}"},{"sha":"0114043d47e9ce1f642e43606eb3e9f0c8646fee","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedReadChannel.java","status":"removed","additions":0,"deletions":103,"changes":103,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedReadChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedReadChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedReadChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,103 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-\n-/**\n- * A Buffered channel without a write buffer. Only reads are buffered.\n- */\n-public class BufferedReadChannel extends BufferedChannelBase {\n-    private static Logger LOG = LoggerFactory.getLogger(BufferedReadChannel.class);\n-    // The capacity of the read buffer.\n-    protected final int readCapacity;\n-    // The buffer for read operations.\n-    protected ByteBuffer readBuffer;\n-    // The starting position of the data currently in the read buffer.\n-    protected long readBufferStartPosition = Long.MIN_VALUE;\n-\n-    long invocationCount = 0;\n-    long cacheHitCount = 0;\n-\n-    public BufferedReadChannel(FileChannel fileChannel, int readCapacity) throws IOException {\n-        super(fileChannel);\n-        this.readCapacity = readCapacity;\n-        this.readBuffer = ByteBuffer.allocateDirect(readCapacity);\n-        this.readBuffer.limit(0);\n-    }\n-\n-    /**\n-     * Read as many bytes into dest as dest.capacity() starting at position pos in the\n-     * FileChannel. This function can read from the buffer or the file channel\n-     * depending on the implementation..\n-     * @param dest\n-     * @param pos\n-     * @return The total number of bytes read. -1 if the given position is greater than or equal to the file's current size.\n-     * @throws IOException if I/O error occurs\n-     */\n-    synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n-        invocationCount++;\n-        long currentPosition = pos;\n-        long eof = validateAndGetFileChannel().size();\n-        // return -1 if the given position is greater than or equal to the file's current size.\n-        if (pos >= eof) {\n-            return -1;\n-        }\n-        while (dest.remaining() > 0) {\n-            // Check if the data is in the buffer, if so, copy it.\n-            if (readBufferStartPosition <= currentPosition && currentPosition < readBufferStartPosition + readBuffer.limit()) {\n-                long posInBuffer = currentPosition - readBufferStartPosition;\n-                long bytesToCopy = Math.min(dest.remaining(), readBuffer.limit() - posInBuffer);\n-                ByteBuffer rbDup = readBuffer.duplicate();\n-                rbDup.position((int)posInBuffer);\n-                rbDup.limit((int)(posInBuffer + bytesToCopy));\n-                dest.put(rbDup);\n-                currentPosition += bytesToCopy;\n-                cacheHitCount++;\n-            } else if (currentPosition >= eof) {\n-                // here we reached eof.\n-                break;\n-            } else {\n-                // We don't have it in the buffer, so put necessary data in the buffer\n-                readBuffer.clear();\n-                readBufferStartPosition = currentPosition;\n-                int readBytes = 0;\n-                if ((readBytes = validateAndGetFileChannel().read(readBuffer, currentPosition)) <= 0) {\n-                    throw new IOException(\"Reading from filechannel returned a non-positive value. Short read.\");\n-                }\n-                readBuffer.limit(readBytes);\n-            }\n-        }\n-        return (int)(currentPosition - pos);\n-    }\n-\n-    synchronized public void clear() {\n-        readBuffer.clear();\n-        readBuffer.limit(0);\n-    }\n-\n-}"},{"sha":"43da72fac30c927865867b8b2f4dc9b3e57a388e","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,34 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-\n-/**\n- * Interface plugged into caching to receive callback notifications\n- */\n-public interface CacheCallback {\n-    /**\n-     * Process notification that cache size limit reached.\n-     */\n-    public void onSizeLimitReached() throws IOException;\n-}"},{"sha":"911c6f4f0fc54d9973be1fd4fcad8f289fd0a195","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CheckpointSource.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CheckpointSource.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CheckpointSource.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CheckpointSource.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,83 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-\n-/**\n- * Interface to communicate checkpoint progress.\n- */\n-public interface CheckpointSource {\n-\n-    /**\n-     * A checkpoint presented a time point. All entries added before this checkpoint are already persisted.\n-     */\n-    public static interface Checkpoint extends Comparable<Checkpoint> {\n-\n-        public static final Checkpoint MAX = new Checkpoint() {\n-\n-            @Override\n-            public int compareTo(Checkpoint o) {\n-                if (o == MAX) {\n-                    return 0;\n-                }\n-                return 1;\n-            }\n-\n-            @Override\n-            public boolean equals(Object o) {\n-                return this == o;\n-            }\n-\n-        };\n-\n-        public static final Checkpoint MIN = new Checkpoint() {\n-            @Override\n-            public int compareTo(Checkpoint o) {\n-                if (o == MIN) {\n-                    return 0;\n-                }\n-                return -1;\n-            }\n-\n-            @Override\n-            public boolean equals(Object o) {\n-                return this == o;\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Request a new a checkpoint.\n-     *\n-     * @return checkpoint.\n-     */\n-    public Checkpoint newCheckpoint();\n-\n-    /**\n-     * Tell checkpoint source that the checkpoint is completed.\n-     * If <code>compact</code> is true, the implementation could compact\n-     * to reduce size of data containing old checkpoints.\n-     *\n-     * @param checkpoint\n-     *          The checkpoint that has been completed\n-     * @param compact\n-     *          Flag to compact old checkpoints.\n-     */\n-    public void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IOException;\n-}"},{"sha":"9e77029e46622b0611a896b48375f6279b14d73a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","status":"removed","additions":0,"deletions":438,"changes":438,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,438 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import java.io.BufferedReader;\n-import java.io.BufferedWriter;\n-import java.io.EOFException;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.StringReader;\n-import java.net.InetSocketAddress;\n-import java.net.UnknownHostException;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.ZkVersion;\n-import org.apache.bookkeeper.proto.DataFormats.CookieFormat;\n-import org.apache.bookkeeper.util.BookKeeperConstants;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZooDefs.Ids;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.data.Stat;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.protobuf.TextFormat;\n-\n-/**\n- * When a bookie starts for the first time it generates  a cookie, and stores\n- * the cookie in zookeeper as well as in the each of the local filesystem\n- * directories it uses. This cookie is used to ensure that for the life of the\n- * bookie, its configuration stays the same. If any of the bookie directories\n- * becomes unavailable, the bookie becomes unavailable. If the bookie changes\n- * port, it must also reset all of its data.\n- *\n- * This is done to ensure data integrity. Without the cookie a bookie could\n- * start with one of its ledger directories missing, so data would be missing,\n- * but the bookie would be up, so the client would think that everything is ok\n- * with the cluster. It's better to fail early and obviously.\n- */\n-class Cookie {\n-    private final static Logger LOG = LoggerFactory.getLogger(Cookie.class);\n-\n-    static final int CURRENT_COOKIE_LAYOUT_VERSION = 4;\n-    private final int layoutVersion;\n-    private final String bookieHost;\n-    private final String journalDir;\n-    private final String ledgerDirs;\n-    private final String instanceId;\n-\n-    private Cookie(int layoutVersion, String bookieHost, String journalDir, String ledgerDirs, String instanceId) {\n-        this.layoutVersion = layoutVersion;\n-        this.bookieHost = bookieHost;\n-        this.journalDir = journalDir;\n-        this.ledgerDirs = ledgerDirs;\n-        this.instanceId = instanceId;\n-    }\n-\n-    public void verify(Cookie c) throws BookieException.InvalidCookieException {\n-        String errMsg;\n-        if (c.layoutVersion < 3 && c.layoutVersion != layoutVersion) {\n-            errMsg = \"Cookie is of too old version \" + c.layoutVersion;\n-            LOG.error(errMsg);\n-            throw new BookieException.InvalidCookieException(errMsg);\n-        } else if (!(c.layoutVersion >= 3 && c.bookieHost.equals(bookieHost)\n-                && c.journalDir.equals(journalDir) && c.ledgerDirs\n-                    .equals(ledgerDirs))) {\n-            errMsg = \"Cookie [\" + this + \"] is not matching with [\" + c + \"]\";\n-            throw new BookieException.InvalidCookieException(errMsg);\n-        } else if ((instanceId == null && c.instanceId != null)\n-                || (instanceId != null && !instanceId.equals(c.instanceId))) {\n-            // instanceId should be same in both cookies\n-            errMsg = \"instanceId \" + instanceId\n-                    + \" is not matching with \" + c.instanceId;\n-            throw new BookieException.InvalidCookieException(errMsg);\n-        }\n-    }\n-\n-    public String toString() {\n-        if (layoutVersion <= 3) {\n-            return toStringVersion3();\n-        }\n-        CookieFormat.Builder builder = CookieFormat.newBuilder();\n-        builder.setBookieHost(bookieHost);\n-        builder.setJournalDir(journalDir);\n-        builder.setLedgerDirs(ledgerDirs);\n-        if (null != instanceId) {\n-            builder.setInstanceId(instanceId);\n-        }\n-        StringBuilder b = new StringBuilder();\n-        b.append(CURRENT_COOKIE_LAYOUT_VERSION).append(\"\\n\");\n-        b.append(TextFormat.printToString(builder.build()));\n-        return b.toString();\n-    }\n-\n-    private String toStringVersion3() {\n-        StringBuilder b = new StringBuilder();\n-        b.append(CURRENT_COOKIE_LAYOUT_VERSION).append(\"\\n\")\n-            .append(bookieHost).append(\"\\n\")\n-            .append(journalDir).append(\"\\n\")\n-            .append(ledgerDirs).append(\"\\n\");\n-        return b.toString();\n-    }\n-\n-    private static Builder parse(BufferedReader reader) throws IOException {\n-        Builder cBuilder = Cookie.newBuilder();\n-        int layoutVersion = 0;\n-        String line = reader.readLine();\n-        if (null == line) {\n-            throw new EOFException(\"Exception in parsing cookie\");\n-        }\n-        try {\n-            layoutVersion = Integer.parseInt(line.trim());\n-            cBuilder.setLayoutVersion(layoutVersion);\n-        } catch (NumberFormatException e) {\n-            throw new IOException(\"Invalid string '\" + line.trim()\n-                    + \"', cannot parse cookie.\");\n-        }\n-        if (layoutVersion == 3) {\n-            cBuilder.setBookieHost(reader.readLine());\n-            cBuilder.setJournalDir(reader.readLine());\n-            cBuilder.setLedgerDirs(reader.readLine());\n-        } else if (layoutVersion >= 4) {\n-            CookieFormat.Builder cfBuilder = CookieFormat.newBuilder();\n-            TextFormat.merge(reader, cfBuilder);\n-            CookieFormat data = cfBuilder.build();\n-            cBuilder.setBookieHost(data.getBookieHost());\n-            cBuilder.setJournalDir(data.getJournalDir());\n-            cBuilder.setLedgerDirs(data.getLedgerDirs());\n-            // Since InstanceId is optional\n-            if (null != data.getInstanceId() && !data.getInstanceId().isEmpty()) {\n-                cBuilder.setInstanceId(data.getInstanceId());\n-            }\n-        }\n-        return cBuilder;\n-    }\n-\n-    void writeToDirectory(File directory) throws IOException {\n-        File versionFile = new File(directory,\n-                BookKeeperConstants.VERSION_FILENAME);\n-\n-        FileOutputStream fos = new FileOutputStream(versionFile);\n-        BufferedWriter bw = null;\n-        try {\n-            bw = new BufferedWriter(new OutputStreamWriter(fos, UTF_8));\n-            bw.write(toString());\n-        } finally {\n-            if (bw != null) {\n-                bw.close();\n-            }\n-            fos.close();\n-        }\n-    }\n-\n-    /**\n-     * Writes cookie details to ZooKeeper\n-     *\n-     * @param zk\n-     *            ZooKeeper instance\n-     * @param conf\n-     *            configuration\n-     * @param version\n-     *            version\n-     *\n-     * @throws KeeperException\n-     * @throws InterruptedException\n-     * @throws UnknownHostException\n-     */\n-    void writeToZooKeeper(ZooKeeper zk, ServerConfiguration conf, Version version)\n-            throws KeeperException, InterruptedException, UnknownHostException {\n-        String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\"\n-                + BookKeeperConstants.COOKIE_NODE;\n-        String zkPath = getZkPath(conf);\n-        byte[] data = toString().getBytes(UTF_8);\n-        if (Version.NEW == version) {\n-            if (zk.exists(bookieCookiePath, false) == null) {\n-                try {\n-                    zk.create(bookieCookiePath, new byte[0],\n-                            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-                } catch (KeeperException.NodeExistsException nne) {\n-                    LOG.info(\"More than one bookie tried to create {} at once. Safe to ignore\",\n-                            bookieCookiePath);\n-                }\n-            }\n-            zk.create(zkPath, data,\n-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        } else {\n-            if (!(version instanceof ZkVersion)) {\n-                throw new IllegalArgumentException(\"Invalid version type, expected ZkVersion type\");\n-            }\n-            zk.setData(zkPath, data, ((ZkVersion) version).getZnodeVersion());\n-        }\n-    }\n-\n-    /**\n-     * Deletes cookie from ZooKeeper and sets znode version to DEFAULT_COOKIE_ZNODE_VERSION\n-     *\n-     * @param zk\n-     *            ZooKeeper instance\n-     * @param conf\n-     *            configuration\n-     * @param version\n-     *            zookeeper version\n-     *\n-     * @throws KeeperException\n-     * @throws InterruptedException\n-     * @throws UnknownHostException\n-     */\n-    void deleteFromZooKeeper(ZooKeeper zk, ServerConfiguration conf, Version version) throws KeeperException,\n-            InterruptedException, UnknownHostException {\n-        if (!(version instanceof ZkVersion)) {\n-            throw new IllegalArgumentException(\"Invalid version type, expected ZkVersion type\");\n-        }\n-        String zkPath = getZkPath(conf);\n-        zk.delete(zkPath, ((ZkVersion)version).getZnodeVersion());\n-    }\n-\n-    /**\n-     * Generate cookie from the given configuration\n-     *\n-     * @param conf\n-     *            configuration\n-     *\n-     * @return cookie builder object\n-     *\n-     * @throws UnknownHostException\n-     */\n-    static Builder generateCookie(ServerConfiguration conf)\n-            throws UnknownHostException {\n-        StringBuilder b = new StringBuilder();\n-        String[] dirs = conf.getLedgerDirNames();\n-        b.append(dirs.length);\n-        for (String d : dirs) {\n-            b.append(\"\\t\").append(d);\n-        }\n-        Builder builder = Cookie.newBuilder();\n-        builder.setLayoutVersion(CURRENT_COOKIE_LAYOUT_VERSION);\n-        builder.setBookieHost(Bookie.getBookieAddress(conf).toString());\n-        builder.setJournalDir(conf.getJournalDirName());\n-        builder.setLedgerDirs(b.toString());\n-        return builder;\n-    }\n-\n-    /**\n-     * Read cookie from ZooKeeper.\n-     *\n-     * @param zk\n-     *            ZooKeeper instance\n-     * @param conf\n-     *            configuration\n-     *\n-     * @return versioned cookie object\n-     *\n-     * @throws KeeperException\n-     * @throws InterruptedException\n-     * @throws IOException\n-     * @throws UnknownHostException\n-     */\n-    static Versioned<Cookie> readFromZooKeeper(ZooKeeper zk, ServerConfiguration conf)\n-            throws KeeperException, InterruptedException, IOException, UnknownHostException {\n-        String zkPath = getZkPath(conf);\n-\n-        Stat stat = zk.exists(zkPath, false);\n-        byte[] data = zk.getData(zkPath, false, stat);\n-        BufferedReader reader = new BufferedReader(new StringReader(new String(data, UTF_8)));\n-        try {\n-            Builder builder = parse(reader);\n-            Cookie cookie = builder.build();\n-            // sets stat version from ZooKeeper\n-            ZkVersion version = new ZkVersion(stat.getVersion());\n-            return new Versioned<Cookie>(cookie, version);\n-        } finally {\n-            reader.close();\n-        }\n-    }\n-\n-    /**\n-     * Returns cookie from the given directory\n-     *\n-     * @param directory\n-     *            directory\n-     *\n-     * @return cookie object\n-     *\n-     * @throws IOException\n-     */\n-    static Cookie readFromDirectory(File directory) throws IOException {\n-        File versionFile = new File(directory,\n-                BookKeeperConstants.VERSION_FILENAME);\n-        BufferedReader reader = new BufferedReader(\n-                new InputStreamReader(new FileInputStream(versionFile), UTF_8));\n-        try {\n-            return parse(reader).build();\n-        } finally {\n-            reader.close();\n-        }\n-    }\n-\n-    /**\n-     * Returns cookie path in zookeeper\n-     *\n-     * @param conf\n-     *            configuration\n-     *          \n-     * @return cookie zk path\n-     *\n-     * @throws UnknownHostException\n-     */\n-    static String getZkPath(ServerConfiguration conf)\n-            throws UnknownHostException {\n-        String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\"\n-                + BookKeeperConstants.COOKIE_NODE;\n-        return bookieCookiePath + \"/\" + Bookie.getBookieAddress(conf);\n-    }\n-\n-    /**\n-     * Check whether the 'bookieHost' was created using a hostname or an IP\n-     * address. Represent as 'hostname/IPaddress' if the InetSocketAddress was\n-     * created using hostname. Represent as '/IPaddress' if the\n-     * InetSocketAddress was created using an IPaddress\n-     * \n-     * @return true if the 'bookieHost' was created using an IP address, false\n-     *         if the 'bookieHost' was created using a hostname\n-     */\n-    public boolean isBookieHostCreatedFromIp() throws IOException {\n-        String parts[] = bookieHost.split(\":\");\n-        if (parts.length != 2) {\n-            throw new IOException(bookieHost + \" does not have the form host:port\");\n-        }\n-        int port;\n-        try {\n-            port = Integer.parseInt(parts[1]);\n-        } catch (NumberFormatException e) {\n-            throw new IOException(bookieHost + \" does not have the form host:port\");\n-        }\n-\n-        InetSocketAddress addr = new InetSocketAddress(parts[0], port);\n-        return addr.toString().startsWith(\"/\");\n-    }\n-\n-    /**\n-     * Cookie builder\n-     */\n-    public static class Builder {\n-        private int layoutVersion = 0;\n-        private String bookieHost = null;\n-        private String journalDir = null;\n-        private String ledgerDirs = null;\n-        private String instanceId = null;\n-\n-        private Builder() {\n-        }\n-\n-        private Builder(int layoutVersion, String bookieHost, String journalDir, String ledgerDirs, String instanceId) {\n-            this.layoutVersion = layoutVersion;\n-            this.bookieHost = bookieHost;\n-            this.journalDir = journalDir;\n-            this.ledgerDirs = ledgerDirs;\n-            this.instanceId = instanceId;\n-        }\n-\n-        public Builder setLayoutVersion(int layoutVersion) {\n-            this.layoutVersion = layoutVersion;\n-            return this;\n-        }\n-\n-        public Builder setBookieHost(String bookieHost) {\n-            this.bookieHost = bookieHost;\n-            return this;\n-        }\n-\n-        public Builder setJournalDir(String journalDir) {\n-            this.journalDir = journalDir;\n-            return this;\n-        }\n-\n-        public Builder setLedgerDirs(String ledgerDirs) {\n-            this.ledgerDirs = ledgerDirs;\n-            return this;\n-        }\n-\n-        public Builder setInstanceId(String instanceId) {\n-            this.instanceId = instanceId;\n-            return this;\n-        }\n-\n-        public Cookie build() {\n-            return new Cookie(layoutVersion, bookieHost, journalDir, ledgerDirs, instanceId);\n-        }\n-    }\n-\n-    /**\n-     * Returns Cookie builder\n-     * \n-     * @return cookie builder\n-     */\n-    static Builder newBuilder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Returns Cookie builder with the copy of given oldCookie\n-     *\n-     * @param oldCookie\n-     *            build new cookie from this cookie\n-     * @return cookie builder\n-     */\n-    static Builder newBuilder(Cookie oldCookie) {\n-        return new Builder(oldCookie.layoutVersion, oldCookie.bookieHost, oldCookie.journalDir, oldCookie.ledgerDirs,\n-                oldCookie.instanceId);\n-    }\n-}"},{"sha":"0107d7a1e6248516369310a15dd9aa65e8ba6fab","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKey.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKey.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKey.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKey.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,83 +0,0 @@\n-/**\n- * Copyright The Apache Software Foundation\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.Serializable;\n-import java.util.Comparator;\n-\n-public class EntryKey {\n-    long ledgerId;\n-    long entryId;\n-\n-    public EntryKey() {\n-        this(0, 0);\n-    }\n-\n-    public EntryKey(long ledgerId, long entryId) {\n-        this.ledgerId = ledgerId;\n-        this.entryId = entryId;\n-    }\n-\n-    public long getLedgerId() {\n-        return ledgerId;\n-    }\n-\n-    public long getEntryId() {\n-        return entryId;\n-    }\n-\n-    /**\n-    * Comparator for the key portion\n-    */\n-    public static final KeyComparator COMPARATOR = new KeyComparator();\n-\n-    // Only compares the key portion\n-    @Override\n-    public boolean equals(Object other) {\n-        if (!(other instanceof EntryKey)) {\n-          return false;\n-        }\n-        EntryKey key = (EntryKey)other;\n-        return ledgerId == key.ledgerId &&\n-            entryId == key.entryId;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return (int)(ledgerId * 13 ^ entryId * 17);\n-    }\n-}\n-\n-/**\n-* Compare EntryKey.\n-*/\n-class KeyComparator implements Comparator<EntryKey>, Serializable {\n-\n-    private static final long serialVersionUID = 0L;\n-\n-    @Override\n-    public int compare(EntryKey left, EntryKey right) {\n-        long ret = left.ledgerId - right.ledgerId;\n-        if (ret == 0) {\n-            ret = left.entryId - right.entryId;\n-        }\n-        return (ret < 0)? -1 : ((ret > 0)? 1 : 0);\n-    }\n-}"},{"sha":"dab5396c3a91c30a8ad55761cc2cda7241b62db0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","status":"removed","additions":0,"deletions":129,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,129 +0,0 @@\n-/**\n- * Copyright The Apache Software Foundation\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.nio.ByteBuffer;\n-\n-/**\n- * An entry Key/Value.\n- * EntryKeyValue wraps a byte array and takes offsets and lengths into the array to\n- * interpret the content as entry blob.\n- */\n-public class EntryKeyValue extends EntryKey {\n-    final private byte [] bytes;\n-    private int offset = 0; // start offset of entry blob\n-    private int length = 0; // length of entry blob\n-\n-    /**\n-    * @return The byte array backing this EntryKeyValue.\n-    */\n-    public byte [] getBuffer() {\n-        return this.bytes;\n-    }\n-\n-    /**\n-    * @return Offset into {@link #getBuffer()} at which the EntryKeyValue starts.\n-    */\n-    public int getOffset() {\n-        return this.offset;\n-    }\n-\n-    /**\n-    * @return Length of bytes this EntryKeyValue occupies in {@link #getBuffer()}.\n-    */\n-    public int getLength() {\n-        return this.length;\n-    }\n-\n-    /**\n-     *\n-     * Creates a EntryKeyValue from the start of the specified byte array.\n-     * Presumes <code>bytes</code> content contains the value portion of a EntryKeyValue.\n-     * @param bytes byte array\n-     */\n-    public EntryKeyValue(long ledgerId, long entryId, final byte [] bytes) {\n-        this(ledgerId, entryId, bytes, 0, bytes.length);\n-    }\n-\n-    /**\n-     *\n-     * Creates a EntryKeyValue from the start of the specified byte array.\n-     * Presumes <code>bytes</code> content contains the value portion of a EntryKeyValue.\n-     * @param bytes byte array\n-     * @param offset offset in bytes as start of blob\n-     * @param length of blob\n-     */\n-    public EntryKeyValue(long ledgerId, long entryId, final byte [] bytes, int offset, int length) {\n-        super(ledgerId, entryId);\n-        this.bytes = bytes;\n-        this.offset = offset;\n-        this.length = length;\n-    }\n-\n-    /**\n-    * Returns the blob wrapped in a new <code>ByteBuffer</code>.\n-    *\n-    * @return the value\n-    */\n-    public ByteBuffer getValueAsByteBuffer() {\n-        return ByteBuffer.wrap(getBuffer(), getOffset(), getLength());\n-    }\n-\n-    /**\n-    * Write EntryKeyValue blob into the provided byte buffer.\n-    *\n-    * @param dst the bytes buffer to use\n-    *\n-    * @return The number of useful bytes in the buffer.\n-    *\n-    * @throws IllegalArgumentException an illegal value was passed or there is insufficient space\n-    * remaining in the buffer\n-    */\n-    int writeToByteBuffer(ByteBuffer dst) {\n-        if (dst.remaining() < getLength()) {\n-            throw new IllegalArgumentException(\"Buffer size \" + dst.remaining() + \" < \" + getLength());\n-        }\n-\n-        dst.put(getBuffer(), getOffset(), getLength());\n-        return getLength();\n-    }\n-\n-    /**\n-    * String representation\n-    */\n-    public String toString() {\n-        return ledgerId + \":\" + entryId;\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        // since this entry is identified by (lid, eid)\n-        // so just use {@link org.apache.bookkeeper.bookie.EntryKey#equals}.\n-        return super.equals(other);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        // since this entry is identified by (lid, eid)\n-        // so just use {@link org.apache.bookkeeper.bookie.EntryKey#hashCode} as the hash code.\n-        return super.hashCode();\n-    }\n-\n-}"},{"sha":"0e052b527e215da193a4faa4ce56262344324900","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"removed","additions":0,"deletions":873,"changes":873,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,873 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import java.io.BufferedReader;\n-import java.io.BufferedWriter;\n-import java.io.File;\n-import java.io.FileFilter;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.util.IOUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.MapMaker;\n-\n-/**\n- * This class manages the writing of the bookkeeper entries. All the new\n- * entries are written to a common log. The LedgerCache will have pointers\n- * into files created by this class with offsets into the files to find\n- * the actual ledger entry. The entry log files created by this class are\n- * identified by a long.\n- */\n-public class EntryLogger {\n-    private static final Logger LOG = LoggerFactory.getLogger(EntryLogger.class);\n-\n-    private static class BufferedLogChannel extends BufferedChannel {\n-        final private long logId;\n-        public BufferedLogChannel(FileChannel fc, int writeCapacity,\n-                                  int readCapacity, long logId) throws IOException {\n-            super(fc, writeCapacity, readCapacity);\n-            this.logId = logId;\n-        }\n-        public long getLogId() {\n-            return logId;\n-        }\n-    }\n-\n-    volatile File currentDir;\n-    private final LedgerDirsManager ledgerDirsManager;\n-    private final AtomicBoolean shouldCreateNewEntryLog = new AtomicBoolean(false);\n-\n-    private volatile long leastUnflushedLogId;\n-\n-    /**\n-     * The maximum size of a entry logger file.\n-     */\n-    final long logSizeLimit;\n-    private List<BufferedLogChannel> logChannelsToFlush;\n-    private volatile BufferedLogChannel logChannel;\n-    private final EntryLoggerAllocator entryLoggerAllocator;\n-    private final boolean entryLogPreAllocationEnabled;\n-    private final CopyOnWriteArrayList<EntryLogListener> listeners\n-        = new CopyOnWriteArrayList<EntryLogListener>();\n-\n-    /**\n-     * The 1K block at the head of the entry logger file\n-     * that contains the fingerprint and (future) meta-data\n-     */\n-    final static int LOGFILE_HEADER_SIZE = 1024;\n-    final ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n-    final static long INVALID_LID = -1L;\n-\n-    final static int MIN_SANE_ENTRY_SIZE = 8 + 8;\n-    final static long MB = 1024 * 1024;\n-\n-    final ServerConfiguration conf;\n-    /**\n-     * Scan entries in a entry log file.\n-     */\n-    static interface EntryLogScanner {\n-        /**\n-         * Tests whether or not the entries belongs to the specified ledger\n-         * should be processed.\n-         *\n-         * @param ledgerId\n-         *          Ledger ID.\n-         * @return true if and only the entries of the ledger should be scanned.\n-         */\n-        public boolean accept(long ledgerId);\n-\n-        /**\n-         * Process an entry.\n-         *\n-         * @param ledgerId\n-         *          Ledger ID.\n-         * @param offset\n-         *          File offset of this entry.\n-         * @param entry\n-         *          Entry ByteBuffer\n-         * @throws IOException\n-         */\n-        public void process(long ledgerId, long offset, ByteBuffer entry) throws IOException;\n-    }\n-\n-    /**\n-     * Entry Log Listener\n-     */\n-    static interface EntryLogListener {\n-        /**\n-         * Rotate a new entry log to write.\n-         */\n-        public void onRotateEntryLog();\n-    }\n-\n-    /**\n-     * Create an EntryLogger that stores it's log files in the given\n-     * directories\n-     */\n-    public EntryLogger(ServerConfiguration conf,\n-            LedgerDirsManager ledgerDirsManager) throws IOException {\n-        this(conf, ledgerDirsManager, null);\n-    }\n-\n-    public EntryLogger(ServerConfiguration conf,\n-            LedgerDirsManager ledgerDirsManager, EntryLogListener listener)\n-                    throws IOException {\n-        this.ledgerDirsManager = ledgerDirsManager;\n-        if (listener != null) {\n-            addListener(listener);\n-        }\n-        // log size limit\n-        this.logSizeLimit = conf.getEntryLogSizeLimit();\n-        this.entryLogPreAllocationEnabled = conf.isEntryLogFilePreAllocationEnabled();\n-\n-        // Initialize the entry log header buffer. This cannot be a static object\n-        // since in our unit tests, we run multiple Bookies and thus EntryLoggers\n-        // within the same JVM. All of these Bookie instances access this header\n-        // so there can be race conditions when entry logs are rolled over and\n-        // this header buffer is cleared before writing it into the new logChannel.\n-        LOGFILE_HEADER.put(\"BKLO\".getBytes(UTF_8));\n-\n-        // Find the largest logId\n-        long logId = INVALID_LID;\n-        for (File dir : ledgerDirsManager.getAllLedgerDirs()) {\n-            if (!dir.exists()) {\n-                throw new FileNotFoundException(\n-                        \"Entry log directory does not exist\");\n-            }\n-            long lastLogId = getLastLogId(dir);\n-            if (lastLogId > logId) {\n-                logId = lastLogId;\n-            }\n-        }\n-        this.leastUnflushedLogId = logId + 1;\n-        this.entryLoggerAllocator = new EntryLoggerAllocator(logId);\n-        this.conf = conf;\n-        initialize();\n-    }\n-\n-    void addListener(EntryLogListener listener) {\n-        if (null != listener) {\n-            listeners.add(listener);\n-        }\n-    }\n-\n-    /**\n-     * If the log id of current writable channel is the same as entryLogId and the position\n-     * we want to read might end up reading from a position in the write buffer of the\n-     * buffered channel, route this read to the current logChannel. Else,\n-     * read from the BufferedReadChannel that is provided.\n-     * @param entryLogId\n-     * @param channel\n-     * @param buff remaining() on this bytebuffer tells us the last position that we\n-     *             expect to read.\n-     * @param pos The starting position from where we want to read.\n-     * @return\n-     */\n-    private int readFromLogChannel(long entryLogId, BufferedReadChannel channel, ByteBuffer buff, long pos)\n-            throws IOException {\n-        BufferedLogChannel bc = logChannel;\n-        if (null != bc) {\n-            if (entryLogId == bc.getLogId()) {\n-                synchronized (bc) {\n-                    if (pos + buff.remaining() >= bc.getFileChannelPosition()) {\n-                        return bc.read(buff, pos);\n-                    }\n-                }\n-            }\n-        }\n-        return channel.read(buff, pos);\n-    }\n-\n-    /**\n-     * A thread-local variable that wraps a mapping of log ids to bufferedchannels\n-     * These channels should be used only for reading. logChannel is the one\n-     * that is used for writes.\n-     */\n-    private final ThreadLocal<Map<Long, BufferedReadChannel>> logid2Channel\n-            = new ThreadLocal<Map<Long, BufferedReadChannel>>() {\n-        @Override\n-        public Map<Long, BufferedReadChannel> initialValue() {\n-            // Since this is thread local there only one modifier\n-            // We dont really need the concurrency, but we need to use\n-            // the weak values. Therefore using the concurrency level of 1\n-            return new MapMaker().concurrencyLevel(1)\n-                .weakValues()\n-                .makeMap();\n-        }\n-    };\n-\n-    /**\n-     * Each thread local buffered read channel can share the same file handle because reads are not relative\n-     * and don't cause a change in the channel's position. We use this map to store the file channels. Each\n-     * file channel is mapped to a log id which represents an open log file.\n-     */\n-    private final ConcurrentMap<Long, FileChannel> logid2FileChannel\n-            = new ConcurrentHashMap<Long, FileChannel>();\n-\n-    /**\n-     * Put the logId, bc pair in the map responsible for the current thread.\n-     * @param logId\n-     * @param bc\n-     */\n-    public BufferedReadChannel putInReadChannels(long logId, BufferedReadChannel bc) {\n-        Map<Long, BufferedReadChannel> threadMap = logid2Channel.get();\n-        return threadMap.put(logId, bc);\n-    }\n-\n-    /**\n-     * Remove all entries for this log file in each thread's cache.\n-     * @param logId\n-     */\n-    public void removeFromChannelsAndClose(long logId) {\n-        FileChannel fileChannel = logid2FileChannel.remove(logId);\n-        if (null != fileChannel) {\n-            try {\n-                fileChannel.close();\n-            } catch (IOException e) {\n-                LOG.warn(\"Exception while closing channel for log file:\" + logId);\n-            }\n-        }\n-    }\n-\n-    public BufferedReadChannel getFromChannels(long logId) {\n-        return logid2Channel.get().get(logId);\n-    }\n-\n-    /**\n-     * Get the least unflushed log id. Garbage collector thread should not process\n-     * unflushed entry log file.\n-     *\n-     * @return least unflushed log id.\n-     */\n-    synchronized long getLeastUnflushedLogId() {\n-        return leastUnflushedLogId;\n-    }\n-\n-    synchronized long getCurrentLogId() {\n-        return logChannel.getLogId();\n-    }\n-\n-    protected void initialize() throws IOException {\n-        // Register listener for disk full notifications.\n-        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n-        // create a new log to write\n-        createNewLog();\n-    }\n-\n-    private LedgerDirsListener getLedgerDirsListener() {\n-        return new LedgerDirsListener() {\n-            @Override\n-            public void diskFull(File disk) {\n-                // If the current entry log disk is full, then create new entry\n-                // log.\n-                if (currentDir != null && currentDir.equals(disk)) {\n-                    shouldCreateNewEntryLog.set(true);\n-                }\n-            }\n-\n-            @Override\n-            public void diskAlmostFull(File disk) {\n-                // If the current entry log disk is almost full, then create new entry\n-                // log.\n-                if (currentDir != null && currentDir.equals(disk)) {\n-                    shouldCreateNewEntryLog.set(true);\n-                }\n-            }\n-\n-            @Override\n-            public void diskFailed(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void allDisksFull() {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void fatalError() {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void diskWritable(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void diskJustWritable(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Rolling a new log file to write.\n-     */\n-    synchronized void rollLog() throws IOException {\n-        createNewLog();\n-    }\n-\n-    /**\n-     * Creates a new log file\n-     */\n-    void createNewLog() throws IOException {\n-        // first tried to create a new log channel. add current log channel to ToFlush list only when\n-        // there is a new log channel. it would prevent that a log channel is referenced by both\n-        // *logChannel* and *ToFlush* list.\n-        if (null != logChannel) {\n-            if (null == logChannelsToFlush) {\n-                logChannelsToFlush = new LinkedList<BufferedLogChannel>();\n-            }\n-            // flush the internal buffer back to filesystem but not sync disk\n-            // so the readers could access the data from filesystem.\n-            logChannel.flush(false);\n-            BufferedLogChannel newLogChannel = entryLoggerAllocator.createNewLog();\n-            logChannelsToFlush.add(logChannel);\n-            LOG.info(\"Flushing entry logger {} back to filesystem, pending for syncing entry loggers : {}.\",\n-                    logChannel.getLogId(), logChannelsToFlush);\n-            for (EntryLogListener listener : listeners) {\n-                listener.onRotateEntryLog();\n-            }\n-            logChannel = newLogChannel;\n-        } else {\n-            logChannel = entryLoggerAllocator.createNewLog();\n-        }\n-    }\n-\n-    /**\n-     * An allocator pre-allocates entry log files.\n-     */\n-    class EntryLoggerAllocator {\n-\n-        long preallocatedLogId;\n-        Future<BufferedLogChannel> preallocation = null;\n-        ExecutorService allocatorExecutor;\n-\n-        EntryLoggerAllocator(long logId) {\n-            preallocatedLogId = logId;\n-            allocatorExecutor = Executors.newSingleThreadExecutor();\n-        }\n-\n-        synchronized BufferedLogChannel createNewLog() throws IOException {\n-            BufferedLogChannel bc;\n-            if (!entryLogPreAllocationEnabled || null == preallocation) {\n-                // initialization time to create a new log\n-                bc = allocateNewLog();\n-            } else {\n-                // has a preallocated entry log\n-                try {\n-                    bc = preallocation.get();\n-                } catch (ExecutionException ee) {\n-                    if (ee.getCause() instanceof IOException) {\n-                        throw (IOException) (ee.getCause());\n-                    } else {\n-                        throw new IOException(\"Error to execute entry log allocation.\", ee);\n-                    }\n-                } catch (CancellationException ce) {\n-                    throw new IOException(\"Task to allocate a new entry log is cancelled.\", ce);\n-                } catch (InterruptedException ie) {\n-                    throw new IOException(\"Intrrupted when waiting a new entry log to be allocated.\", ie);\n-                }\n-                preallocation = allocatorExecutor.submit(new Callable<BufferedLogChannel>() {\n-                    @Override\n-                    public BufferedLogChannel call() throws IOException {\n-                        return allocateNewLog();\n-                    }\n-                });\n-            }\n-            LOG.info(\"Created new entry logger {}.\", bc.getLogId());\n-            return bc;\n-        }\n-\n-        /**\n-         * Allocate a new log file.\n-         */\n-        BufferedLogChannel allocateNewLog() throws IOException {\n-            List<File> list = ledgerDirsManager.getWritableLedgerDirs();\n-            Collections.shuffle(list);\n-            // It would better not to overwrite existing entry log files\n-            File newLogFile = null;\n-            do {\n-                String logFileName = Long.toHexString(++preallocatedLogId) + \".log\";\n-                for (File dir : list) {\n-                    newLogFile = new File(dir, logFileName);\n-                    currentDir = dir;\n-                    if (newLogFile.exists()) {\n-                        LOG.warn(\"Found existed entry log \" + newLogFile\n-                               + \" when trying to create it as a new log.\");\n-                        newLogFile = null;\n-                        break;\n-                    }\n-                }\n-            } while (newLogFile == null);\n-\n-            FileChannel channel = new RandomAccessFile(newLogFile, \"rw\").getChannel();\n-            BufferedLogChannel logChannel = new BufferedLogChannel(channel,\n-                    conf.getWriteBufferBytes(), conf.getReadBufferBytes(), preallocatedLogId);\n-            logChannel.write((ByteBuffer) LOGFILE_HEADER.clear());\n-\n-            for (File f : list) {\n-                setLastLogId(f, preallocatedLogId);\n-            }\n-            LOG.info(\"Preallocated entry logger {}.\", preallocatedLogId);\n-            return logChannel;\n-        }\n-\n-        /**\n-         * Stop the allocator.\n-         */\n-        void stop() {\n-            // wait until the preallocation finished.\n-            allocatorExecutor.shutdown();\n-            LOG.info(\"Stopped entry logger preallocator.\");\n-        }\n-    }\n-\n-    /**\n-     * Remove entry log.\n-     *\n-     * @param entryLogId\n-     *          Entry Log File Id\n-     */\n-    protected boolean removeEntryLog(long entryLogId) {\n-        removeFromChannelsAndClose(entryLogId);\n-        File entryLogFile;\n-        try {\n-            entryLogFile = findFile(entryLogId);\n-        } catch (FileNotFoundException e) {\n-            LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n-                    + entryLogId + \".log\");\n-            return false;\n-        }\n-        if (!entryLogFile.delete()) {\n-            LOG.warn(\"Could not delete entry log file {}\", entryLogFile);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * writes the given id to the \"lastId\" file in the given directory.\n-     */\n-    private void setLastLogId(File dir, long logId) throws IOException {\n-        FileOutputStream fos;\n-        fos = new FileOutputStream(new File(dir, \"lastId\"));\n-        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos, UTF_8));\n-        try {\n-            bw.write(Long.toHexString(logId) + \"\\n\");\n-            bw.flush();\n-        } finally {\n-            try {\n-                bw.close();\n-            } catch (IOException e) {\n-                LOG.error(\"Could not close lastId file in {}\", dir.getPath());\n-            }\n-        }\n-    }\n-\n-    private long getLastLogId(File dir) {\n-        long id = readLastLogId(dir);\n-        // read success\n-        if (id > 0) {\n-            return id;\n-        }\n-        // read failed, scan the ledger directories to find biggest log id\n-        File[] logFiles = dir.listFiles(new FileFilter() {\n-            @Override\n-            public boolean accept(File file) {\n-                return file.getName().endsWith(\".log\");\n-            }\n-        });\n-        List<Long> logs = new ArrayList<Long>();\n-        for (File lf : logFiles) {\n-            String idString = lf.getName().split(\"\\\\.\")[0];\n-            try {\n-                long lid = Long.parseLong(idString, 16);\n-                logs.add(lid);\n-            } catch (NumberFormatException nfe) {\n-            }\n-        }\n-        // no log file found in this directory\n-        if (0 == logs.size()) {\n-            return INVALID_LID;\n-        }\n-        // order the collections\n-        Collections.sort(logs);\n-        return logs.get(logs.size() - 1);\n-    }\n-\n-    /**\n-     * reads id from the \"lastId\" file in the given directory.\n-     */\n-    private long readLastLogId(File f) {\n-        FileInputStream fis;\n-        try {\n-            fis = new FileInputStream(new File(f, \"lastId\"));\n-        } catch (FileNotFoundException e) {\n-            return INVALID_LID;\n-        }\n-        BufferedReader br = new BufferedReader(new InputStreamReader(fis, UTF_8));\n-        try {\n-            String lastIdString = br.readLine();\n-            return Long.parseLong(lastIdString, 16);\n-        } catch (IOException e) {\n-            return INVALID_LID;\n-        } catch(NumberFormatException e) {\n-            return INVALID_LID;\n-        } finally {\n-            try {\n-                br.close();\n-            } catch (IOException e) {\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Flushes all rotated log channels. After log channels are flushed,\n-     * move leastUnflushedLogId ptr to current logId.\n-     */\n-    void checkpoint() throws IOException {\n-        flushRotatedLogs();\n-    }\n-\n-    void flushRotatedLogs() throws IOException {\n-        List<BufferedLogChannel> channels = null;\n-        long flushedLogId = INVALID_LID;\n-        synchronized (this) {\n-            channels = logChannelsToFlush;\n-            logChannelsToFlush = null;\n-        }\n-        if (null == channels) {\n-            return;\n-        }\n-        for (BufferedLogChannel channel : channels) {\n-            channel.flush(true);\n-            // since this channel is only used for writing, after flushing the channel,\n-            // we had to close the underlying file channel. Otherwise, we might end up\n-            // leaking fds which cause the disk spaces could not be reclaimed.\n-            closeFileChannel(channel);\n-            if (channel.getLogId() > flushedLogId) {\n-                flushedLogId = channel.getLogId();\n-            }\n-            LOG.info(\"Synced entry logger {} to disk.\", channel.getLogId());\n-        }\n-        // move the leastUnflushedLogId ptr\n-        leastUnflushedLogId = flushedLogId + 1;\n-    }\n-\n-    void flush() throws IOException {\n-        flushRotatedLogs();\n-        flushCurrentLog();\n-    }\n-\n-    synchronized void flushCurrentLog() throws IOException {\n-        if (logChannel != null) {\n-            logChannel.flush(true);\n-            LOG.debug(\"Flush and sync current entry logger {}.\", logChannel.getLogId());\n-        }\n-    }\n-\n-    long addEntry(long ledger, ByteBuffer entry) throws IOException {\n-        return addEntry(ledger, entry, true);\n-    }\n-\n-    synchronized long addEntry(long ledger, ByteBuffer entry, boolean rollLog) throws IOException {\n-        if (rollLog) {\n-            // Create new log if logSizeLimit reached or current disk is full\n-            boolean createNewLog = shouldCreateNewEntryLog.get();\n-            if (createNewLog || reachEntryLogLimit(entry.remaining() + 4)) {\n-                createNewLog();\n-                // Reset the flag\n-                if (createNewLog) {\n-                    shouldCreateNewEntryLog.set(false);\n-                }\n-            }\n-        }\n-        ByteBuffer buff = ByteBuffer.allocate(4);\n-        buff.putInt(entry.remaining());\n-        buff.flip();\n-        logChannel.write(buff);\n-        long pos = logChannel.position();\n-        logChannel.write(entry);\n-\n-        return (logChannel.getLogId() << 32L) | pos;\n-    }\n-\n-    static long logIdForOffset(long offset) {\n-        return offset >> 32L;\n-    }\n-\n-    synchronized boolean reachEntryLogLimit(long size) {\n-        return logChannel.position() + size > logSizeLimit;\n-    }\n-\n-    byte[] readEntry(long ledgerId, long entryId, long location) throws IOException, Bookie.NoEntryException {\n-        long entryLogId = logIdForOffset(location);\n-        long pos = location & 0xffffffffL;\n-        ByteBuffer sizeBuff = ByteBuffer.allocate(4);\n-        pos -= 4; // we want to get the ledgerId and length to check\n-        BufferedReadChannel fc;\n-        try {\n-            fc = getChannelForLogId(entryLogId);\n-        } catch (FileNotFoundException e) {\n-            FileNotFoundException newe = new FileNotFoundException(e.getMessage() + \" for \" + ledgerId + \" with location \" + location);\n-            newe.setStackTrace(e.getStackTrace());\n-            throw newe;\n-        }\n-        if (readFromLogChannel(entryLogId, fc, sizeBuff, pos) != sizeBuff.capacity()) {\n-            throw new Bookie.NoEntryException(\"Short read from entrylog \" + entryLogId,\n-                                              ledgerId, entryId);\n-        }\n-        pos += 4;\n-        sizeBuff.flip();\n-        int entrySize = sizeBuff.getInt();\n-        // entrySize does not include the ledgerId\n-        if (entrySize > MB) {\n-            LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \" + entryLogId);\n-\n-        }\n-        if (entrySize < MIN_SANE_ENTRY_SIZE) {\n-            LOG.error(\"Read invalid entry length {}\", entrySize);\n-            throw new IOException(\"Invalid entry length \" + entrySize);\n-        }\n-        byte data[] = new byte[entrySize];\n-        ByteBuffer buff = ByteBuffer.wrap(data);\n-        int rc = readFromLogChannel(entryLogId, fc, buff, pos);\n-        if ( rc != data.length) {\n-            // Note that throwing NoEntryException here instead of IOException is not\n-            // without risk. If all bookies in a quorum throw this same exception\n-            // the client will assume that it has reached the end of the ledger.\n-            // However, this may not be the case, as a very specific error condition\n-            // could have occurred, where the length of the entry was corrupted on all\n-            // replicas. However, the chance of this happening is very very low, so\n-            // returning NoEntryException is mostly safe.\n-            throw new Bookie.NoEntryException(\"Short read for \" + ledgerId + \"@\"\n-                                              + entryId + \" in \" + entryLogId + \"@\"\n-                                              + pos + \"(\"+rc+\"!=\"+data.length+\")\", ledgerId, entryId);\n-        }\n-        buff.flip();\n-        long thisLedgerId = buff.getLong();\n-        if (thisLedgerId != ledgerId) {\n-            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry belongs to \" + thisLedgerId + \" not \" + ledgerId);\n-        }\n-        long thisEntryId = buff.getLong();\n-        if (thisEntryId != entryId) {\n-            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry is \" + thisEntryId + \" not \" + entryId);\n-        }\n-\n-        return data;\n-    }\n-\n-    private BufferedReadChannel getChannelForLogId(long entryLogId) throws IOException {\n-        BufferedReadChannel fc = getFromChannels(entryLogId);\n-        if (fc != null) {\n-            return fc;\n-        }\n-        File file = findFile(entryLogId);\n-        // get channel is used to open an existing entry log file\n-        // it would be better to open using read mode\n-        FileChannel newFc = new RandomAccessFile(file, \"r\").getChannel();\n-        FileChannel oldFc = logid2FileChannel.putIfAbsent(entryLogId, newFc);\n-        if (null != oldFc) {\n-            newFc.close();\n-            newFc = oldFc;\n-        }\n-        // We set the position of the write buffer of this buffered channel to Long.MAX_VALUE\n-        // so that there are no overlaps with the write buffer while reading\n-        fc = new BufferedReadChannel(newFc, conf.getReadBufferBytes());\n-        putInReadChannels(entryLogId, fc);\n-        return fc;\n-    }\n-\n-    /**\n-     * Whether the log file exists or not.\n-     */\n-    boolean logExists(long logId) {\n-        for (File d : ledgerDirsManager.getAllLedgerDirs()) {\n-            File f = new File(d, Long.toHexString(logId) + \".log\");\n-            if (f.exists()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private File findFile(long logId) throws FileNotFoundException {\n-        for (File d : ledgerDirsManager.getAllLedgerDirs()) {\n-            File f = new File(d, Long.toHexString(logId)+\".log\");\n-            if (f.exists()) {\n-                return f;\n-            }\n-        }\n-        throw new FileNotFoundException(\"No file for log \" + Long.toHexString(logId));\n-    }\n-\n-    /**\n-     * Scan entry log\n-     *\n-     * @param entryLogId\n-     *          Entry Log Id\n-     * @param scanner\n-     *          Entry Log Scanner\n-     * @throws IOException\n-     */\n-    protected void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOException {\n-        ByteBuffer sizeBuff = ByteBuffer.allocate(4);\n-        ByteBuffer lidBuff = ByteBuffer.allocate(8);\n-        BufferedReadChannel bc;\n-        // Get the BufferedChannel for the current entry log file\n-        try {\n-            bc = getChannelForLogId(entryLogId);\n-        } catch (IOException e) {\n-            LOG.warn(\"Failed to get channel to scan entry log: \" + entryLogId + \".log\");\n-            throw e;\n-        }\n-        // Start the read position in the current entry log file to be after\n-        // the header where all of the ledger entries are.\n-        long pos = LOGFILE_HEADER_SIZE;\n-        // Read through the entry log file and extract the ledger ID's.\n-        while (true) {\n-            // Check if we've finished reading the entry log file.\n-            if (pos >= bc.size()) {\n-                break;\n-            }\n-            if (readFromLogChannel(entryLogId, bc, sizeBuff, pos) != sizeBuff.capacity()) {\n-                throw new IOException(\"Short read for entry size from entrylog \" + entryLogId);\n-            }\n-            long offset = pos;\n-            pos += 4;\n-            sizeBuff.flip();\n-            int entrySize = sizeBuff.getInt();\n-            if (entrySize > MB) {\n-                LOG.warn(\"Found large size entry of \" + entrySize + \" at location \" + pos + \" in \"\n-                        + entryLogId);\n-            }\n-            sizeBuff.clear();\n-            // try to read ledger id first\n-            if (readFromLogChannel(entryLogId, bc, lidBuff, pos) != lidBuff.capacity()) {\n-                throw new IOException(\"Short read for ledger id from entrylog \" + entryLogId);\n-            }\n-            lidBuff.flip();\n-            long lid = lidBuff.getLong();\n-            lidBuff.clear();\n-            if (!scanner.accept(lid)) {\n-                // skip this entry\n-                pos += entrySize;\n-                continue;\n-            }\n-            // read the entry\n-            byte data[] = new byte[entrySize];\n-            ByteBuffer buff = ByteBuffer.wrap(data);\n-            int rc = readFromLogChannel(entryLogId, bc, buff, pos);\n-            if (rc != data.length) {\n-                throw new IOException(\"Short read for ledger entry from entryLog \" + entryLogId\n-                                    + \"@\" + pos + \"(\" + rc + \"!=\" + data.length + \")\");\n-            }\n-            buff.flip();\n-            // process the entry\n-            scanner.process(lid, offset, buff);\n-            // Advance position to the next entry\n-            pos += entrySize;\n-        }\n-    }\n-\n-    /**\n-     * Shutdown method to gracefully stop entry logger.\n-     */\n-    public void shutdown() {\n-        // since logChannel is buffered channel, do flush when shutting down\n-        LOG.info(\"Stopping EntryLogger\");\n-        try {\n-            flush();\n-            for (FileChannel fc : logid2FileChannel.values()) {\n-                fc.close();\n-            }\n-            // clear the mapping, so we don't need to go through the channels again in finally block in normal case.\n-            logid2FileChannel.clear();\n-            // close current writing log file\n-            closeFileChannel(logChannel);\n-            logChannel = null;\n-        } catch (IOException ie) {\n-            // we have no idea how to avoid io exception during shutting down, so just ignore it\n-            LOG.error(\"Error flush entry log during shutting down, which may cause entry log corrupted.\", ie);\n-        } finally {\n-            for (FileChannel fc : logid2FileChannel.values()) {\n-                IOUtils.close(LOG, fc);\n-            }\n-            forceCloseFileChannel(logChannel);\n-        }\n-        // shutdown the pre-allocation thread\n-        entryLoggerAllocator.stop();\n-    }\n-\n-    private static void closeFileChannel(BufferedChannelBase channel) throws IOException {\n-        if (null == channel) {\n-            return;\n-        }\n-        FileChannel fileChannel = channel.getFileChannel();\n-        if (null != fileChannel) {\n-            fileChannel.close();\n-        }\n-    }\n-\n-    private static void forceCloseFileChannel(BufferedChannelBase channel) {\n-        if (null == channel) {\n-            return;\n-        }\n-        FileChannel fileChannel = channel.getFileChannel();\n-        if (null != fileChannel) {\n-            IOUtils.close(LOG, fileChannel);\n-        }\n-    }\n-\n-}"},{"sha":"9fbe866fc0404985601e487f1ecdcbfdfa9261f0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","status":"removed","additions":0,"deletions":440,"changes":440,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,440 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.concurrent.ConcurrentSkipListMap;\n-\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_FLUSH_BYTES;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_GET_ENTRY;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_PUT_ENTRY;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_SNAPSHOT;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_THROTTLING;\n-\n-/**\n- * The EntryMemTable holds in-memory representation to the entries not-yet flushed.\n- * When asked to flush, current EntrySkipList is moved to snapshot and is cleared.\n- * We continue to serve edits out of new EntrySkipList and backing snapshot until\n- * flusher reports in that the flush succeeded. At that point we let the snapshot go.\n- */\n-public class EntryMemTable {\n-    private static Logger Logger = LoggerFactory.getLogger(Journal.class);\n-\n-    /**\n-     * Entry skip list\n-     */\n-    static class EntrySkipList extends ConcurrentSkipListMap<EntryKey, EntryKeyValue> {\n-        final Checkpoint cp;\n-        static final EntrySkipList EMPTY_VALUE = new EntrySkipList(Checkpoint.MAX) {\n-            @Override\n-            public boolean isEmpty() {\n-                return true;\n-            }\n-        };\n-\n-        EntrySkipList(final Checkpoint cp) {\n-            super(EntryKey.COMPARATOR);\n-            this.cp = cp;\n-        }\n-\n-        int compareTo(final Checkpoint cp) {\n-            return this.cp.compareTo(cp);\n-        }\n-\n-        @Override\n-        public EntryKeyValue put(EntryKey k, EntryKeyValue v) {\n-            return putIfAbsent(k, v);\n-        }\n-\n-        @Override\n-        public EntryKeyValue putIfAbsent(EntryKey k, EntryKeyValue v) {\n-            assert k.equals(v);\n-            return super.putIfAbsent(v, v);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return this == o;\n-        }\n-    }\n-\n-    volatile EntrySkipList kvmap;\n-\n-    // Snapshot of EntryMemTable.  Made for flusher.\n-    volatile EntrySkipList snapshot;\n-\n-    final ServerConfiguration conf;\n-    final CheckpointSource checkpointSource;\n-\n-    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n-\n-    // Used to track own data size\n-    final AtomicLong size;\n-\n-    final long skipListSizeLimit;\n-\n-    SkipListArena allocator;\n-\n-    private EntrySkipList newSkipList() {\n-        return new EntrySkipList(checkpointSource.newCheckpoint());\n-    }\n-\n-    // Stats\n-    private final OpStatsLogger snapshotStats;\n-    private final OpStatsLogger putEntryStats;\n-    private final OpStatsLogger getEntryStats;\n-    private final Counter flushBytesCounter;\n-    private final Counter throttlingCounter;\n-\n-    /**\n-    * Constructor.\n-    * @param conf Server configuration\n-    */\n-    public EntryMemTable(final ServerConfiguration conf, final CheckpointSource source,\n-                         final StatsLogger statsLogger) {\n-        this.checkpointSource = source;\n-        this.kvmap = newSkipList();\n-        this.snapshot = EntrySkipList.EMPTY_VALUE;\n-        this.conf = conf;\n-        this.size = new AtomicLong(0);\n-        this.allocator = new SkipListArena(conf);\n-        // skip list size limit\n-        this.skipListSizeLimit = conf.getSkipListSizeLimit();\n-\n-        // Stats\n-        this.snapshotStats = statsLogger.getOpStatsLogger(SKIP_LIST_SNAPSHOT);\n-        this.putEntryStats = statsLogger.getOpStatsLogger(SKIP_LIST_PUT_ENTRY);\n-        this.getEntryStats = statsLogger.getOpStatsLogger(SKIP_LIST_GET_ENTRY);\n-        this.flushBytesCounter = statsLogger.getCounter(SKIP_LIST_FLUSH_BYTES);\n-        this.throttlingCounter = statsLogger.getCounter(SKIP_LIST_THROTTLING);\n-    }\n-\n-    void dump() {\n-        for (EntryKey key: this.kvmap.keySet()) {\n-            Logger.info(key.toString());\n-        }\n-        for (EntryKey key: this.snapshot.keySet()) {\n-            Logger.info(key.toString());\n-        }\n-    }\n-\n-    Checkpoint snapshot() throws IOException {\n-        return snapshot(Checkpoint.MAX);\n-    }\n-\n-    /**\n-     * Snapshot current EntryMemTable. if given <i>oldCp</i> is older than current checkpoint,\n-     * we don't do any snapshot. If snapshot happened, we return the checkpoint of the snapshot.\n-     *\n-     * @param oldCp\n-     *          checkpoint\n-     * @return checkpoint of the snapshot, null means no snapshot\n-     * @throws IOException\n-     */\n-    Checkpoint snapshot(Checkpoint oldCp) throws IOException {\n-        Checkpoint cp = null;\n-        // No-op if snapshot currently has entries\n-        if (this.snapshot.isEmpty() &&\n-                this.kvmap.compareTo(oldCp) < 0) {\n-            final long startTimeNanos = MathUtils.nowInNano();\n-            this.lock.writeLock().lock();\n-            try {\n-                if (this.snapshot.isEmpty() && !this.kvmap.isEmpty()\n-                        && this.kvmap.compareTo(oldCp) < 0) {\n-                    this.snapshot = this.kvmap;\n-                    this.kvmap = newSkipList();\n-                    // get the checkpoint of the memtable.\n-                    cp = this.kvmap.cp;\n-                    // Reset heap to not include any keys\n-                    this.size.set(0);\n-                    // Reset allocator so we get a fresh buffer for the new EntryMemTable\n-                    this.allocator = new SkipListArena(conf);\n-                }\n-            } finally {\n-                this.lock.writeLock().unlock();\n-            }\n-\n-            if (null != cp) {\n-                snapshotStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            } else {\n-                snapshotStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            }\n-        }\n-        return cp;\n-    }\n-\n-    /**\n-     * Flush snapshot and clear it.\n-     */\n-    long flush(final SkipListFlusher flusher) throws IOException {\n-        return flushSnapshot(flusher, Checkpoint.MAX);\n-    }\n-\n-    /**\n-     * Flush memtable until checkpoint.\n-     *\n-     * @param checkpoint\n-     *          all data before this checkpoint need to be flushed.\n-     */\n-    public long flush(SkipListFlusher flusher, Checkpoint checkpoint) throws IOException {\n-        long size = flushSnapshot(flusher, checkpoint);\n-        if (null != snapshot(checkpoint)) {\n-            size += flushSnapshot(flusher, checkpoint);\n-        }\n-        return size;\n-    }\n-\n-    /**\n-     * Flush snapshot and clear it iff its data is before checkpoint.\n-     * Only this function change non-empty this.snapshot.\n-     */\n-    private long flushSnapshot(final SkipListFlusher flusher, Checkpoint checkpoint) throws IOException {\n-        long size = 0;\n-        if (this.snapshot.compareTo(checkpoint) < 0) {\n-            long ledger, ledgerGC = -1;\n-            synchronized (this) {\n-                EntrySkipList keyValues = this.snapshot;\n-                if (keyValues.compareTo(checkpoint) < 0) {\n-                    for (EntryKey key : keyValues.keySet()) {\n-                        EntryKeyValue kv = (EntryKeyValue)key;\n-                        size += kv.getLength();\n-                        ledger = kv.getLedgerId();\n-                        if (ledgerGC != ledger) {\n-                            try {\n-                                flusher.process(ledger, kv.getEntryId(), kv.getValueAsByteBuffer());\n-                            } catch (NoLedgerException exception) {\n-                                ledgerGC = ledger;\n-                            }\n-                        }\n-                    }\n-                    flushBytesCounter.add(size);\n-                    clearSnapshot(keyValues);\n-                }\n-            }\n-        }\n-\n-        return size;\n-    }\n-\n-    /**\n-     * The passed snapshot was successfully persisted; it can be let go.\n-     * @param keyValues The snapshot to clean out.\n-     * @see {@link #snapshot()}\n-     */\n-    private void clearSnapshot(final EntrySkipList keyValues) {\n-        // Caller makes sure that keyValues not empty\n-        assert !keyValues.isEmpty();\n-        this.lock.writeLock().lock();\n-        try {\n-            // create a new snapshot and let the old one go.\n-            assert this.snapshot == keyValues;\n-            this.snapshot = EntrySkipList.EMPTY_VALUE;\n-        } finally {\n-            this.lock.writeLock().unlock();\n-        }\n-    }\n-\n-    /**\n-     * Throttling writer w/ 1 ms delay\n-     */\n-    private void throttleWriters() {\n-        try {\n-            Thread.sleep(1);\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-        }\n-        throttlingCounter.inc();\n-    }\n-\n-    /**\n-    * Write an update\n-    * @param entry\n-    * @return approximate size of the passed key and value.\n-    */\n-    public long addEntry(long ledgerId, long entryId, final ByteBuffer entry, final CacheCallback cb)\n-            throws IOException {\n-        long size = 0;\n-        long startTimeNanos = MathUtils.nowInNano();\n-        boolean success = false;\n-        try {\n-            if (isSizeLimitReached()) {\n-                Checkpoint cp = snapshot();\n-                if (null != cp) {\n-                    cb.onSizeLimitReached();\n-                } else {\n-                    throttleWriters();\n-                }\n-            }\n-\n-            this.lock.readLock().lock();\n-            try {\n-                EntryKeyValue toAdd = cloneWithAllocator(ledgerId, entryId, entry);\n-                size = internalAdd(toAdd);\n-            } finally {\n-                this.lock.readLock().unlock();\n-            }\n-            success = true;\n-            return size;\n-        } finally {\n-            if (success) {\n-                putEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            } else {\n-                putEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            }\n-        }\n-    }\n-\n-    /**\n-    * Internal version of add() that doesn't clone KVs with the\n-    * allocator, and doesn't take the lock.\n-    *\n-    * Callers should ensure they already have the read lock taken\n-    */\n-    private long internalAdd(final EntryKeyValue toAdd) throws IOException {\n-        long sizeChange = 0;\n-        if (kvmap.putIfAbsent(toAdd, toAdd) == null) {\n-            sizeChange = toAdd.getLength();\n-            size.addAndGet(sizeChange);\n-        }\n-        return sizeChange;\n-    }\n-\n-    private EntryKeyValue newEntry(long ledgerId, long entryId, final ByteBuffer entry) {\n-        byte[] buf;\n-        int offset = 0;\n-        int length = entry.remaining();\n-\n-        if (entry.hasArray()) {\n-            buf = entry.array();\n-            offset = entry.arrayOffset();\n-        }\n-        else {\n-            buf = new byte[length];\n-            entry.get(buf);\n-        }\n-        return new EntryKeyValue(ledgerId, entryId, buf, offset, length);\n-    }\n-\n-    private EntryKeyValue cloneWithAllocator(long ledgerId, long entryId, final ByteBuffer entry) {\n-        int len = entry.remaining();\n-        SkipListArena.MemorySlice alloc = allocator.allocateBytes(len);\n-        if (alloc == null) {\n-            // The allocation was too large, allocator decided\n-            // not to do anything with it.\n-            return newEntry(ledgerId, entryId, entry);\n-        }\n-\n-        assert alloc.getData() != null;\n-        entry.get(alloc.getData(), alloc.getOffset(), len);\n-        return new EntryKeyValue(ledgerId, entryId, alloc.getData(), alloc.getOffset(), len);\n-    }\n-\n-    /**\n-     * Find the entry with given key\n-     * @param ledgerId\n-     * @param entryId\n-     * @return the entry kv or null if none found.\n-     */\n-    public EntryKeyValue getEntry(long ledgerId, long entryId) throws IOException {\n-        EntryKey key = new EntryKey(ledgerId, entryId);\n-        EntryKeyValue value = null;\n-        long startTimeNanos = MathUtils.nowInNano();\n-        boolean success = false;\n-        this.lock.readLock().lock();\n-        try {\n-            value = this.kvmap.get(key);\n-            if (value == null) {\n-                value = this.snapshot.get(key);\n-            }\n-            success = true;\n-        } finally {\n-            this.lock.readLock().unlock();\n-            if (success) {\n-                getEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            } else {\n-                getEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            }\n-        }\n-\n-        return value;\n-    }\n-\n-    /**\n-     * Find the last entry with the given ledger key\n-     * @param ledgerId\n-     * @return the entry kv or null if none found.\n-     */\n-    public EntryKeyValue getLastEntry(long ledgerId) throws IOException {\n-        EntryKey result = null;\n-        EntryKey key = new EntryKey(ledgerId, Long.MAX_VALUE);\n-        long startTimeNanos = MathUtils.nowInNano();\n-        boolean success = false;\n-        this.lock.readLock().lock();\n-        try {\n-            result = this.kvmap.floorKey(key);\n-            if (result == null || result.getLedgerId() != ledgerId) {\n-                result = this.snapshot.floorKey(key);\n-            }\n-            success = true;\n-        } finally {\n-            this.lock.readLock().unlock();\n-            if (success) {\n-                getEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            } else {\n-                getEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            }\n-        }\n-\n-        if (result == null || result.getLedgerId() != ledgerId) {\n-            return null;\n-        }\n-        return (EntryKeyValue)result;\n-    }\n-\n-    /**\n-     * Check if the entire heap usage for this EntryMemTable exceeds limit\n-     */\n-    boolean isSizeLimitReached() {\n-        return size.get() >= skipListSizeLimit;\n-    }\n-\n-    /**\n-     * Check if there is data in the mem-table\n-     * @return\n-     */\n-    boolean isEmpty() {\n-        return size.get() == 0 && snapshot.isEmpty();\n-    }\n-}"},{"sha":"b683c7b546561ea4df979bca41835e0a8d384fa8","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,40 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-/**\n- * Exit code used to exit bookie server\n- */\n-public class ExitCode {\n-    // normal quit\n-    public final static int OK                  = 0;\n-    // invalid configuration\n-    public final static int INVALID_CONF        = 1;\n-    // exception running bookie server\n-    public final static int SERVER_EXCEPTION    = 2;\n-    // zookeeper is expired\n-    public final static int ZK_EXPIRED          = 3;\n-    // register bookie on zookeeper failed\n-    public final static int ZK_REG_FAIL         = 4;\n-    // exception running bookie\n-    public final static int BOOKIE_EXCEPTION    = 5;\n-}"},{"sha":"f96627b1f2d35ba56012ed26710468e2ee037f0e","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"removed","additions":0,"deletions":387,"changes":387,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,387 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.BufferUnderflowException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-\n-/**\n- * This is the file handle for a ledger's index file that maps entry ids to location.\n- * It is used by LedgerCache.\n- *\n- * <p>\n- * Ledger index file is made of a header and several fixed-length index pages, which records the offsets of data stored in entry loggers\n- * <pre>&lt;header&gt;&lt;index pages&gt;</pre>\n- * <b>Header</b> is formated as below:\n- * <pre>&lt;magic bytes&gt;&lt;len of master key&gt;&lt;master key&gt;</pre>\n- * <ul>\n- * <li>magic bytes: 4 bytes, 'BKLE', version: 4 bytes\n- * <li>len of master key: indicates length of master key. -1 means no master key stored in header.\n- * <li>master key: master key\n- * <li>state: bit map to indicate the state, 32 bits.\n- * </ul>\n- * <b>Index page</b> is a fixed-length page, which contains serveral entries which point to the offsets of data stored in entry loggers.\n- * </p>\n- */\n-class FileInfo {\n-    private final static Logger LOG = LoggerFactory.getLogger(FileInfo.class);\n-\n-    static final int NO_MASTER_KEY = -1;\n-    static final int STATE_FENCED_BIT = 0x1;\n-\n-    private FileChannel fc;\n-    private File lf;\n-    byte[] masterKey;\n-\n-    /**\n-     * The fingerprint of a ledger index file\n-     */\n-    static final public int signature = ByteBuffer.wrap(\"BKLE\".getBytes(UTF_8)).getInt();\n-    static final public int headerVersion = 0;\n-\n-    static final long START_OF_DATA = 1024;\n-    private long size;\n-    private AtomicInteger useCount = new AtomicInteger(0);\n-    private boolean isClosed;\n-    private long sizeSinceLastwrite;\n-\n-    // bit map for states of the ledger.\n-    private int stateBits;\n-    private boolean needFlushHeader = false;\n-\n-    // file access mode\n-    protected String mode;\n-\n-    public FileInfo(File lf, byte[] masterKey) throws IOException {\n-        this.lf = lf;\n-\n-        this.masterKey = masterKey;\n-        mode = \"rw\";\n-    }\n-\n-    public File getLf() {\n-        return lf;\n-    }\n-\n-    public long getSizeSinceLastwrite() {\n-        return sizeSinceLastwrite;\n-    }\n-\n-    synchronized public void readHeader() throws IOException {\n-        if (lf.exists()) {\n-            if (fc != null) {\n-                return;\n-            }\n-\n-            fc = new RandomAccessFile(lf, mode).getChannel();\n-            size = fc.size();\n-            sizeSinceLastwrite = size;\n-\n-            // avoid hang on reading partial index\n-            ByteBuffer bb = ByteBuffer.allocate((int)(Math.min(size, START_OF_DATA)));\n-            while(bb.hasRemaining()) {\n-                fc.read(bb);\n-            }\n-            bb.flip();\n-            if (bb.getInt() != signature) {\n-                throw new IOException(\"Missing ledger signature\");\n-            }\n-            int version = bb.getInt();\n-            if (version != headerVersion) {\n-                throw new IOException(\"Incompatible ledger version \" + version);\n-            }\n-            int length = bb.getInt();\n-            if (length < 0) {\n-                throw new IOException(\"Length \" + length + \" is invalid\");\n-            } else if (length > bb.remaining()) {\n-                throw new BufferUnderflowException();\n-            }\n-            masterKey = new byte[length];\n-            bb.get(masterKey);\n-            stateBits = bb.getInt();\n-            needFlushHeader = false;\n-        } else {\n-            throw new IOException(\"Ledger index file does not exist\");\n-        }\n-    }\n-\n-    synchronized private void checkOpen(boolean create) throws IOException {\n-        if (fc != null) {\n-            return;\n-        }\n-        boolean exists = lf.exists();\n-        if (masterKey == null && !exists) {\n-            throw new IOException(lf + \" not found\");\n-        }\n-\n-        if (!exists) {\n-            if (create) {\n-                // delayed the creation of parents directories\n-                checkParents(lf);\n-                fc = new RandomAccessFile(lf, mode).getChannel();\n-                size = fc.size();\n-                if (size == 0) {\n-                    writeHeader();\n-                }\n-            }\n-        } else {\n-            try {\n-                readHeader();\n-            } catch (BufferUnderflowException buf) {\n-                LOG.warn(\"Exception when reading header of {} : {}\", lf, buf);\n-                if (null != masterKey) {\n-                    LOG.warn(\"Attempting to write header of {} again.\", lf);\n-                    writeHeader();\n-                } else {\n-                    throw new IOException(\"Error reading header \" + lf);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void writeHeader() throws IOException {\n-        ByteBuffer bb = ByteBuffer.allocate((int)START_OF_DATA);\n-        bb.putInt(signature);\n-        bb.putInt(headerVersion);\n-        bb.putInt(masterKey.length);\n-        bb.put(masterKey);\n-        bb.putInt(stateBits);\n-        bb.rewind();\n-        fc.position(0);\n-        fc.write(bb);\n-    }\n-\n-    synchronized public boolean isFenced() throws IOException {\n-        checkOpen(false);\n-        return (stateBits & STATE_FENCED_BIT) == STATE_FENCED_BIT;\n-    }\n-\n-    /**\n-     * @return true if set fence succeed, otherwise false when\n-     * it already fenced or failed to set fenced.\n-     */\n-    synchronized public boolean setFenced() throws IOException {\n-        checkOpen(false);\n-        LOG.debug(\"Try to set fenced state in file info {} : state bits {}.\", lf, stateBits);\n-        if ((stateBits & STATE_FENCED_BIT) != STATE_FENCED_BIT) {\n-            // not fenced yet\n-            stateBits |= STATE_FENCED_BIT;\n-            needFlushHeader = true;\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    // flush the header when header is changed\n-    synchronized public void flushHeader() throws IOException {\n-        if (needFlushHeader) {\n-            checkOpen(true);\n-            writeHeader();\n-            needFlushHeader = false;\n-        }\n-    }\n-\n-    synchronized public long size() throws IOException {\n-        checkOpen(false);\n-        long rc = size-START_OF_DATA;\n-        if (rc < 0) {\n-            rc = 0;\n-        }\n-        return rc;\n-    }\n-\n-    public int read(ByteBuffer bb, long position) throws IOException {\n-        return readAbsolute(bb, position + START_OF_DATA);\n-    }\n-\n-    private int readAbsolute(ByteBuffer bb, long start) throws IOException {\n-        checkOpen(false);\n-        synchronized (this) {\n-            if (fc == null) {\n-                return 0;\n-            }\n-        }\n-        int total = 0;\n-        int rc = 0;\n-        while(bb.remaining() > 0) {\n-            synchronized (this) {\n-                rc = fc.read(bb, start);\n-            }\n-            if (rc <= 0) {\n-                throw new IOException(\"Short read\");\n-            }\n-            total += rc;\n-            // should move read position\n-            start += rc;\n-        }\n-        return total;\n-    }\n-\n-    /**\n-     * Close a file info\n-     *\n-     * @param force\n-     *          if set to true, the index is forced to create before closed,\n-     *          if set to false, the index is not forced to create.\n-     */\n-    synchronized public void close(boolean force) throws IOException {\n-        isClosed = true;\n-        checkOpen(force);\n-        if (useCount.get() == 0 && fc != null) {\n-            fc.close();\n-        }\n-    }\n-\n-    synchronized public long write(ByteBuffer[] buffs, long position) throws IOException {\n-        checkOpen(true);\n-        long total = 0;\n-        try {\n-            fc.position(position+START_OF_DATA);\n-            while(buffs[buffs.length-1].remaining() > 0) {\n-                long rc = fc.write(buffs);\n-                if (rc <= 0) {\n-                    throw new IOException(\"Short write\");\n-                }\n-                total += rc;\n-            }\n-        } finally {\n-            fc.force(true);\n-            long newsize = position+START_OF_DATA+total;\n-            if (newsize > size) {\n-                size = newsize;\n-            }\n-        }\n-        sizeSinceLastwrite = fc.size();\n-        return total;\n-    }\n-\n-    /**\n-     * Copies current file contents upto specified size to the target file and\n-     * deletes the current file. If size not known then pass size as\n-     * Long.MAX_VALUE to copy complete file.\n-     */\n-    public synchronized void moveToNewLocation(File newFile, long size) throws IOException {\n-        checkOpen(false);\n-        // If the channel is null, or same file path, just return.\n-        if (null == fc || isSameFile(newFile)) {\n-            return;\n-        }\n-        if (size > fc.size()) {\n-            size = fc.size();\n-        }\n-        File rlocFile = new File(newFile.getParentFile(), newFile.getName() + IndexPersistenceMgr.RLOC);\n-        if (!rlocFile.exists()) {\n-            checkParents(rlocFile);\n-            if (!rlocFile.createNewFile()) {\n-                throw new IOException(\"Creating new cache index file \" + rlocFile + \" failed \");\n-            }\n-        }\n-        // copy contents from old.idx to new.idx.rloc\n-        FileChannel newFc = new RandomAccessFile(rlocFile, \"rw\").getChannel();\n-        try {\n-            long written = 0;\n-            while (written < size) {\n-                long count = fc.transferTo(written, size, newFc);\n-                if (count <= 0) {\n-                    throw new IOException(\"Copying to new location \" + rlocFile + \" failed\");\n-                }\n-                written += count;\n-            }\n-            if (written <= 0 && size > 0) {\n-                throw new IOException(\"Copying to new location \" + rlocFile + \" failed\");\n-            }\n-        } finally {\n-            newFc.force(true);\n-            newFc.close();\n-        }\n-        // delete old.idx\n-        fc.close();\n-        if (!delete()) {\n-            LOG.error(\"Failed to delete the previous index file \" + lf);\n-            throw new IOException(\"Failed to delete the previous index file \" + lf);\n-        }\n-\n-        // rename new.idx.rloc to new.idx\n-        if (!rlocFile.renameTo(newFile)) {\n-            LOG.error(\"Failed to rename \" + rlocFile + \" to \" + newFile);\n-            throw new IOException(\"Failed to rename \" + rlocFile + \" to \" + newFile);\n-        }\n-        fc = new RandomAccessFile(newFile, mode).getChannel();\n-        lf = newFile;\n-    }\n-\n-    synchronized public byte[] getMasterKey() throws IOException {\n-        checkOpen(false);\n-        return masterKey;\n-    }\n-\n-    public void use() {\n-        useCount.incrementAndGet();\n-    }\n-\n-    @VisibleForTesting\n-    int getUseCount() {\n-        return useCount.get();\n-    }\n-\n-    synchronized public void release() {\n-        int count = useCount.decrementAndGet();\n-        if (isClosed && (count == 0) && fc != null) {\n-            try {\n-                fc.close();\n-            } catch (IOException e) {\n-                LOG.error(\"Error closing file channel\", e);\n-            }\n-        }\n-    }\n-\n-    public boolean delete() {\n-        return lf.delete();\n-    }\n-\n-    static final private void checkParents(File f) throws IOException {\n-        File parent = f.getParentFile();\n-        if (parent.exists()) {\n-            return;\n-        }\n-        if (parent.mkdirs() == false) {\n-            throw new IOException(\"Counldn't mkdirs for \" + parent);\n-        }\n-    }\n-\n-    public boolean isSameFile(File f) {\n-        return this.lf.equals(f);\n-    }\n-}"},{"sha":"f6ec59c9bfcee8fd3e9365d0ad58fd79e9e52fa2","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","status":"removed","additions":0,"deletions":393,"changes":393,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,393 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import org.apache.bookkeeper.util.BookKeeperConstants;\n-import org.apache.bookkeeper.util.HardLink;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n-\n-import org.apache.commons.io.FileUtils;\n-import org.apache.commons.cli.BasicParser;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.HelpFormatter;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.File;\n-import java.io.FilenameFilter;\n-import java.io.IOException;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Scanner;\n-import java.util.NoSuchElementException;\n-\n-import java.net.MalformedURLException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.commons.configuration.ConfigurationException;\n-\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.KeeperException;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-/**\n- * Application for upgrading the bookkeeper filesystem\n- * between versions\n- */\n-public class FileSystemUpgrade {\n-    private final static Logger LOG = LoggerFactory.getLogger(FileSystemUpgrade.class);\n-\n-    static FilenameFilter BOOKIE_FILES_FILTER = new FilenameFilter() {\n-            private boolean containsIndexFiles(File dir, String name) {\n-                if (name.endsWith(\".idx\")) {\n-                    return true;\n-                }\n-\n-                try {\n-                    Long.parseLong(name, 16);\n-                    File d = new File(dir, name);\n-                    if (d.isDirectory()) {\n-                        String[] files = d.list();\n-                        for (String f : files) {\n-                            if (containsIndexFiles(d, f)) {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                } catch (NumberFormatException nfe) {\n-                    return false;\n-                }\n-                return false;\n-            }\n-\n-            public boolean accept(File dir, String name) {\n-                if (name.endsWith(\".txn\") || name.endsWith(\".log\")\n-                    || name.equals(\"lastId\") || name.equals(\"lastMark\")) {\n-                    return true;\n-                }\n-                if (containsIndexFiles(dir, name)) {\n-                    return true;\n-                }\n-                return false;\n-            }\n-        };\n-\n-    private static List<File> getAllDirectories(ServerConfiguration conf) {\n-        List<File> dirs = new ArrayList<File>();\n-        dirs.add(conf.getJournalDir());\n-        for (File d: conf.getLedgerDirs()) {\n-            dirs.add(d);\n-        }\n-        return dirs;\n-    }\n-\n-    private static int detectPreviousVersion(File directory) throws IOException {\n-        String[] files = directory.list(BOOKIE_FILES_FILTER);\n-        File v2versionFile = new File(directory,\n-                BookKeeperConstants.VERSION_FILENAME);\n-        if (files.length == 0 && !v2versionFile.exists()) { // no old data, so we're ok\n-            return Cookie.CURRENT_COOKIE_LAYOUT_VERSION;\n-        }\n-\n-        if (!v2versionFile.exists()) {\n-            return 1;\n-        }\n-        Scanner s = new Scanner(v2versionFile, UTF_8.name());\n-        try {\n-            return s.nextInt();\n-        } catch (NoSuchElementException nse) {\n-            LOG.error(\"Couldn't parse version file \" + v2versionFile , nse);\n-            throw new IOException(\"Couldn't parse version file\", nse);\n-        } catch (IllegalStateException ise) {\n-            LOG.error(\"Error reading file \" + v2versionFile, ise);\n-            throw new IOException(\"Error reading version file\", ise);\n-        } finally {\n-            s.close();\n-        }\n-    }\n-\n-    private static ZooKeeper newZookeeper(final ServerConfiguration conf)\n-            throws BookieException.UpgradeException {\n-        try {\n-            final CountDownLatch latch = new CountDownLatch(1);\n-            ZooKeeper zk = new ZooKeeper(conf.getZkServers(), conf.getZkTimeout(),\n-                    new Watcher() {\n-                        @Override\n-                        public void process(WatchedEvent event) {\n-                            // handle session disconnects and expires\n-                            if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n-                                latch.countDown();\n-                            }\n-                        }\n-                    });\n-            if (!latch.await(conf.getZkTimeout()*2, TimeUnit.MILLISECONDS)) {\n-                zk.close();\n-                throw new BookieException.UpgradeException(\"Couldn't connect to zookeeper\");\n-            }\n-            return zk;\n-        } catch (InterruptedException ie) {\n-            throw new BookieException.UpgradeException(ie);\n-        } catch (IOException ioe) {\n-            throw new BookieException.UpgradeException(ioe);\n-        }\n-    }\n-\n-    private static void linkIndexDirectories(File srcPath, File targetPath) throws IOException {\n-        String[] files = srcPath.list();\n-\n-        for (String f : files) {\n-            if (f.endsWith(\".idx\")) { // this is an index dir, create the links\n-                if (!targetPath.mkdirs()) {\n-                    throw new IOException(\"Could not create target path [\"+targetPath+\"]\");\n-                }\n-                HardLink.createHardLinkMult(srcPath, files, targetPath);\n-                return;\n-            }\n-            File newSrcPath = new File(srcPath, f);\n-            if (newSrcPath.isDirectory()) {\n-                try {\n-                    Long.parseLong(f, 16);\n-                    linkIndexDirectories(newSrcPath, new File(targetPath, f));\n-                } catch (NumberFormatException nfe) {\n-                    // filename does not parse to a hex Long, so\n-                    // it will not contain idx files. Ignoring\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void upgrade(ServerConfiguration conf)\n-            throws BookieException.UpgradeException, InterruptedException {\n-        LOG.info(\"Upgrading...\");\n-\n-        ZooKeeper zk = newZookeeper(conf);\n-        try {\n-            Map<File,File> deferredMoves = new HashMap<File, File>();\n-            Cookie.Builder cookieBuilder = Cookie.generateCookie(conf);\n-            Cookie c = cookieBuilder.build();\n-            for (File d : getAllDirectories(conf)) {\n-                LOG.info(\"Upgrading {}\", d);\n-                int version = detectPreviousVersion(d);\n-                if (version == Cookie.CURRENT_COOKIE_LAYOUT_VERSION) {\n-                    LOG.info(\"Directory is current, no need to upgrade\");\n-                    continue;\n-                }\n-                try {\n-                    File curDir = new File(d, BookKeeperConstants.CURRENT_DIR);\n-                    File tmpDir = new File(d, \"upgradeTmp.\" + System.nanoTime());\n-                    deferredMoves.put(curDir, tmpDir);\n-                    if (!tmpDir.mkdirs()) {\n-                        throw new BookieException.UpgradeException(\"Could not create temporary directory \" + tmpDir);\n-                    }\n-                    c.writeToDirectory(tmpDir);\n-\n-                    String[] files = d.list(new FilenameFilter() {\n-                            public boolean accept(File dir, String name) {\n-                                return BOOKIE_FILES_FILTER.accept(dir, name)\n-                                    && !(new File(dir, name).isDirectory());\n-                            }\n-                        });\n-                    HardLink.createHardLinkMult(d, files, tmpDir);\n-\n-                    linkIndexDirectories(d, tmpDir);\n-                } catch (IOException ioe) {\n-                    LOG.error(\"Error upgrading {}\", d);\n-                    throw new BookieException.UpgradeException(ioe);\n-                }\n-            }\n-\n-            for (Map.Entry<File,File> e : deferredMoves.entrySet()) {\n-                try {\n-                    FileUtils.moveDirectory(e.getValue(), e.getKey());\n-                } catch (IOException ioe) {\n-                    String err = String.format(\"Error moving upgraded directories into place %s -> %s \",\n-                                               e.getValue(), e.getKey());\n-                    LOG.error(err, ioe);\n-                    throw new BookieException.UpgradeException(ioe);\n-                }\n-            }\n-\n-            if (deferredMoves.isEmpty()) {\n-                return;\n-            }\n-\n-            try {\n-                c.writeToZooKeeper(zk, conf, Version.NEW);\n-            } catch (KeeperException ke) {\n-                LOG.error(\"Error writing cookie to zookeeper\");\n-                throw new BookieException.UpgradeException(ke);\n-            }\n-        } catch (IOException ioe) {\n-            throw new BookieException.UpgradeException(ioe);\n-        } finally {\n-            zk.close();\n-        }\n-        LOG.info(\"Done\");\n-    }\n-\n-    public static void finalizeUpgrade(ServerConfiguration conf)\n-            throws BookieException.UpgradeException, InterruptedException {\n-        LOG.info(\"Finalizing upgrade...\");\n-        // verify that upgrade is correct\n-        for (File d : getAllDirectories(conf)) {\n-            LOG.info(\"Finalizing {}\", d);\n-            try {\n-                int version = detectPreviousVersion(d);\n-                if (version < 3) {\n-                    if (version == 2) {\n-                        File v2versionFile = new File(d,\n-                                BookKeeperConstants.VERSION_FILENAME);\n-                        if (!v2versionFile.delete()) {\n-                            LOG.warn(\"Could not delete old version file {}\", v2versionFile);\n-                        }\n-                    }\n-                    File[] files = d.listFiles(BOOKIE_FILES_FILTER);\n-                    for (File f : files) {\n-                        if (f.isDirectory()) {\n-                            FileUtils.deleteDirectory(f);\n-                        } else{\n-                            if (!f.delete()) {\n-                                LOG.warn(\"Could not delete {}\", f);\n-                            }\n-                        }\n-                    }\n-                }\n-            } catch (IOException ioe) {\n-                LOG.error(\"Error finalizing {}\", d);\n-                throw new BookieException.UpgradeException(ioe);\n-            }\n-        }\n-        // noop at the moment\n-        LOG.info(\"Done\");\n-    }\n-\n-    public static void rollback(ServerConfiguration conf)\n-            throws BookieException.UpgradeException, InterruptedException {\n-        LOG.info(\"Rolling back upgrade...\");\n-        ZooKeeper zk = newZookeeper(conf);\n-        try {\n-            for (File d : getAllDirectories(conf)) {\n-                LOG.info(\"Rolling back {}\", d);\n-                try {\n-                    // ensure there is a previous version before rollback\n-                    int version = detectPreviousVersion(d);\n-\n-                    if (version <= Cookie.CURRENT_COOKIE_LAYOUT_VERSION) {\n-                        File curDir = new File(d,\n-                                BookKeeperConstants.CURRENT_DIR);\n-                        FileUtils.deleteDirectory(curDir);\n-                    } else {\n-                        throw new BookieException.UpgradeException(\n-                                \"Cannot rollback as previous data does not exist\");\n-                    }\n-                } catch (IOException ioe) {\n-                    LOG.error(\"Error rolling back {}\", d);\n-                    throw new BookieException.UpgradeException(ioe);\n-                }\n-            }\n-            try {\n-                Versioned<Cookie> cookie = Cookie.readFromZooKeeper(zk, conf);\n-                cookie.getValue().deleteFromZooKeeper(zk, conf, cookie.getVersion());\n-            } catch (KeeperException ke) {\n-                LOG.error(\"Error deleting cookie from ZooKeeper\");\n-                throw new BookieException.UpgradeException(ke);\n-            } catch (IOException ioe) {\n-                LOG.error(\"I/O Error deleting cookie from ZooKeeper\");\n-                throw new BookieException.UpgradeException(ioe);\n-            }\n-        } finally {\n-            zk.close();\n-        }\n-        LOG.info(\"Done\");\n-    }\n-\n-    private static void printHelp(Options opts) {\n-        HelpFormatter hf = new HelpFormatter();\n-        hf.printHelp(\"FileSystemUpgrade [options]\", opts);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        org.apache.log4j.Logger root = org.apache.log4j.Logger.getRootLogger();\n-        root.addAppender(new org.apache.log4j.ConsoleAppender(\n-                                 new org.apache.log4j.PatternLayout(\"%-5p [%t]: %m%n\")));\n-        root.setLevel(org.apache.log4j.Level.ERROR);\n-        org.apache.log4j.Logger.getLogger(FileSystemUpgrade.class).setLevel(\n-                org.apache.log4j.Level.INFO);\n-\n-        final Options opts = new Options();\n-        opts.addOption(\"c\", \"conf\", true, \"Configuration for Bookie\");\n-        opts.addOption(\"u\", \"upgrade\", false, \"Upgrade bookie directories\");\n-        opts.addOption(\"f\", \"finalize\", false, \"Finalize upgrade\");\n-        opts.addOption(\"r\", \"rollback\", false, \"Rollback upgrade\");\n-        opts.addOption(\"h\", \"help\", false, \"Print help message\");\n-\n-        BasicParser parser = new BasicParser();\n-        CommandLine cmdLine = parser.parse(opts, args);\n-        if (cmdLine.hasOption(\"h\")) {\n-            printHelp(opts);\n-            return;\n-        }\n-\n-        if (!cmdLine.hasOption(\"c\")) {\n-            String err = \"Cannot upgrade without configuration\";\n-            LOG.error(err);\n-            printHelp(opts);\n-            throw new IllegalArgumentException(err);\n-        }\n-\n-        String confFile = cmdLine.getOptionValue(\"c\");\n-        ServerConfiguration conf = new ServerConfiguration();\n-        try {\n-            conf.loadConf(new File(confFile).toURI().toURL());\n-        } catch (MalformedURLException mue) {\n-            LOG.error(\"Could not open configuration file \" + confFile, mue);\n-            throw new IllegalArgumentException();\n-        } catch (ConfigurationException ce) {\n-            LOG.error(\"Invalid configuration file \" + confFile, ce);\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (cmdLine.hasOption(\"u\")) {\n-            upgrade(conf);\n-        } else if (cmdLine.hasOption(\"r\")) {\n-            rollback(conf);\n-        } else if (cmdLine.hasOption(\"f\")) {\n-            finalizeUpgrade(conf);\n-        } else {\n-            String err = \"Must specify -upgrade, -finalize or -rollback\";\n-            LOG.error(err);\n-            printHelp(opts);\n-            throw new IllegalArgumentException(err);\n-        }\n-    }\n-}"},{"sha":"bfe69a4c3656b3bb82d2be7e9224b17f5b3ca492","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,51 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-/**\n- * This is the garbage collector interface, garbage collector implementers\n- * need to extends this class to remove the deleted ledgers.\n- */\n-public interface GarbageCollector {\n-    /**\n-     * Do the garbage collector work\n-     *\n-     * @param garbageCleaner\n-     *          cleaner used to clean selected garbages\n-     */\n-    public abstract void gc(GarbageCleaner garbageCleaner);\n-\n-    /**\n-     * A interface used to define customised garbage cleaner\n-     */\n-    public interface GarbageCleaner {\n-\n-        /**\n-         * Clean a specific ledger\n-         *\n-         * @param ledgerId\n-         *          Ledger ID to be cleaned\n-         */\n-        public void clean(final long ledgerId) ;\n-    }\n-\n-}"},{"sha":"74c6ec2d3840e39a016383571f98b1ec8e3a51d0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"removed","additions":0,"deletions":637,"changes":637,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,637 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.util.concurrent.RateLimiter;\n-\n-import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n-import org.apache.bookkeeper.bookie.GarbageCollector.GarbageCleaner;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.apache.bookkeeper.util.SnapshotMap;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * This is the garbage collector thread that runs in the background to\n- * remove any entry log files that no longer contains any active ledger.\n- */\n-public class GarbageCollectorThread extends BookieThread {\n-    private static final Logger LOG = LoggerFactory.getLogger(GarbageCollectorThread.class);\n-    private static final int SECOND = 1000;\n-\n-    // Maps entry log files to the set of ledgers that comprise the file and the size usage per ledger\n-    private Map<Long, EntryLogMetadata> entryLogMetaMap = new ConcurrentHashMap<Long, EntryLogMetadata>();\n-\n-    // This is how often we want to run the Garbage Collector Thread (in milliseconds).\n-    final long gcWaitTime;\n-\n-    // Compaction parameters\n-    boolean enableMinorCompaction = false;\n-    final double minorCompactionThreshold;\n-    final long minorCompactionInterval;\n-\n-    boolean enableMajorCompaction = false;\n-    final double majorCompactionThreshold;\n-    final long majorCompactionInterval;\n-\n-    long lastMinorCompactionTime;\n-    long lastMajorCompactionTime;\n-\n-    final int maxOutstandingRequests;\n-    final int compactionRate;\n-    final CompactionScannerFactory scannerFactory;\n-\n-    // Entry Logger Handle\n-    final EntryLogger entryLogger;\n-\n-    // Ledger Cache Handle\n-    final LedgerCache ledgerCache;\n-    final SnapshotMap<Long, Boolean> activeLedgers;\n-\n-    // flag to ensure gc thread will not be interrupted during compaction\n-    // to reduce the risk getting entry log corrupted\n-    final AtomicBoolean compacting = new AtomicBoolean(false);\n-\n-    volatile boolean running = true;\n-\n-    // track the last scanned successfully log id\n-    long scannedLogId = 0;\n-\n-    // Boolean to trigger a forced GC.\n-    final AtomicBoolean forceGarbageCollection = new AtomicBoolean(false);\n-\n-    final GarbageCollector garbageCollector;\n-    final GarbageCleaner garbageCleaner;\n-\n-    private static class Offset {\n-        final long ledger;\n-        final long entry;\n-        final long offset;\n-\n-        Offset(long ledger, long entry, long offset) {\n-            this.ledger = ledger;\n-            this.entry = entry;\n-            this.offset = offset;\n-        }\n-    }\n-\n-    /**\n-     * A scanner wrapper to check whether a ledger is alive in an entry log file\n-     */\n-    class CompactionScannerFactory implements EntryLogger.EntryLogListener {\n-        List<Offset> offsets = new ArrayList<Offset>();\n-\n-        EntryLogScanner newScanner(final EntryLogMetadata meta) {\n-            final RateLimiter rateLimiter = RateLimiter.create(compactionRate);\n-            return new EntryLogScanner() {\n-                @Override\n-                public boolean accept(long ledgerId) {\n-                    return meta.containsLedger(ledgerId);\n-                }\n-\n-                @Override\n-                public void process(final long ledgerId, long offset, ByteBuffer entry)\n-                        throws IOException {\n-                    rateLimiter.acquire();\n-                    synchronized (CompactionScannerFactory.this) {\n-                        if (offsets.size() > maxOutstandingRequests) {\n-                            waitEntrylogFlushed();\n-                        }\n-                        entry.getLong(); // discard ledger id, we already have it\n-                        long entryId = entry.getLong();\n-                        entry.rewind();\n-\n-                        long newoffset = entryLogger.addEntry(ledgerId, entry);\n-                        offsets.add(new Offset(ledgerId, entryId, newoffset));\n-                    }\n-                }\n-            };\n-        }\n-\n-        Object flushLock = new Object();\n-\n-        @Override\n-        public void onRotateEntryLog() {\n-            synchronized (flushLock) {\n-                flushLock.notifyAll();\n-            }\n-        }\n-\n-        synchronized private void waitEntrylogFlushed() throws IOException {\n-            try {\n-                if (offsets.size() <= 0) {\n-                    LOG.debug(\"Skipping entry log flushing, as there is no offset!\");\n-                    return;\n-                }\n-                synchronized (flushLock) {\n-                    Offset lastOffset = offsets.get(offsets.size()-1);\n-                    long lastOffsetLogId = EntryLogger.logIdForOffset(lastOffset.offset);\n-                    while (lastOffsetLogId < entryLogger.getLeastUnflushedLogId() && running) {\n-                        flushLock.wait(1000);\n-\n-                        lastOffset = offsets.get(offsets.size()-1);\n-                        lastOffsetLogId = EntryLogger.logIdForOffset(lastOffset.offset);\n-                    }\n-                    if (lastOffsetLogId >= entryLogger.getLeastUnflushedLogId() && !running) {\n-                        throw new IOException(\"Shutdown before flushed\");\n-                    }\n-                }\n-            } catch (InterruptedException ie) {\n-                Thread.currentThread().interrupt();\n-                throw new IOException(\"Interrupted waiting for flush\", ie);\n-            }\n-\n-            for (Offset o : offsets) {\n-                ledgerCache.putEntryOffset(o.ledger, o.entry, o.offset);\n-            }\n-            offsets.clear();\n-        }\n-\n-        synchronized void flush() throws IOException {\n-            waitEntrylogFlushed();\n-\n-            ledgerCache.flushLedger(true);\n-        }\n-    }\n-\n-\n-    /**\n-     * Create a garbage collector thread.\n-     *\n-     * @param conf\n-     *          Server Configuration Object.\n-     * @throws IOException\n-     */\n-    public GarbageCollectorThread(ServerConfiguration conf,\n-                                  final LedgerCache ledgerCache,\n-                                  EntryLogger entryLogger,\n-                                  SnapshotMap<Long, Boolean> activeLedgers,\n-                                  LedgerManager ledgerManager)\n-        throws IOException {\n-        super(\"GarbageCollectorThread\");\n-\n-        this.ledgerCache = ledgerCache;\n-        this.entryLogger = entryLogger;\n-        this.activeLedgers = activeLedgers;\n-\n-        this.gcWaitTime = conf.getGcWaitTime();\n-        this.maxOutstandingRequests = conf.getCompactionMaxOutstandingRequests();\n-        this.compactionRate = conf.getCompactionRate();\n-        this.scannerFactory = new CompactionScannerFactory();\n-        entryLogger.addListener(this.scannerFactory);\n-\n-        this.garbageCleaner = new GarbageCollector.GarbageCleaner() {\n-            @Override\n-            public void clean(long ledgerId) {\n-                try {\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"delete ledger : \" + ledgerId);\n-                    }\n-                    ledgerCache.deleteLedger(ledgerId);\n-                } catch (IOException e) {\n-                    LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n-                }\n-            }\n-        };\n-\n-        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, activeLedgers);\n-\n-        // compaction parameters\n-        minorCompactionThreshold = conf.getMinorCompactionThreshold();\n-        minorCompactionInterval = conf.getMinorCompactionInterval() * SECOND;\n-        majorCompactionThreshold = conf.getMajorCompactionThreshold();\n-        majorCompactionInterval = conf.getMajorCompactionInterval() * SECOND;\n-\n-        if (minorCompactionInterval > 0 && minorCompactionThreshold > 0) {\n-            if (minorCompactionThreshold > 1.0f) {\n-                throw new IOException(\"Invalid minor compaction threshold \"\n-                                    + minorCompactionThreshold);\n-            }\n-            if (minorCompactionInterval <= gcWaitTime) {\n-                throw new IOException(\"Too short minor compaction interval : \"\n-                                    + minorCompactionInterval);\n-            }\n-            enableMinorCompaction = true;\n-        }\n-\n-        if (majorCompactionInterval > 0 && majorCompactionThreshold > 0) {\n-            if (majorCompactionThreshold > 1.0f) {\n-                throw new IOException(\"Invalid major compaction threshold \"\n-                                    + majorCompactionThreshold);\n-            }\n-            if (majorCompactionInterval <= gcWaitTime) {\n-                throw new IOException(\"Too short major compaction interval : \"\n-                                    + majorCompactionInterval);\n-            }\n-            enableMajorCompaction = true;\n-        }\n-\n-        if (enableMinorCompaction && enableMajorCompaction) {\n-            if (minorCompactionInterval >= majorCompactionInterval ||\n-                minorCompactionThreshold >= majorCompactionThreshold) {\n-                throw new IOException(\"Invalid minor/major compaction settings : minor (\"\n-                                    + minorCompactionThreshold + \", \" + minorCompactionInterval\n-                                    + \"), major (\" + majorCompactionThreshold + \", \"\n-                                    + majorCompactionInterval + \")\");\n-            }\n-        }\n-\n-        LOG.info(\"Minor Compaction : enabled=\" + enableMinorCompaction + \", threshold=\"\n-               + minorCompactionThreshold + \", interval=\" + minorCompactionInterval);\n-        LOG.info(\"Major Compaction : enabled=\" + enableMajorCompaction + \", threshold=\"\n-               + majorCompactionThreshold + \", interval=\" + majorCompactionInterval);\n-\n-        lastMinorCompactionTime = lastMajorCompactionTime = MathUtils.now();\n-    }\n-\n-    public synchronized void enableForceGC() {\n-        if (forceGarbageCollection.compareAndSet(false, true)) {\n-            LOG.info(\"Forced garbage collection triggered by thread: {}\", Thread.currentThread().getName());\n-            notify();\n-        }\n-    }\n-\n-    public void disableForceGC() {\n-        if (forceGarbageCollection.compareAndSet(true, false)) {\n-            LOG.info(\"{} disabled force garbage collection since bookie has enough space now.\", Thread\n-                    .currentThread().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void run() {\n-        while (running) {\n-            synchronized (this) {\n-                try {\n-                    wait(gcWaitTime);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    continue;\n-                }\n-            }\n-            boolean force = forceGarbageCollection.get();\n-            if (force) {\n-                LOG.info(\"Garbage collector thread forced to perform GC before expiry of wait time.\");\n-            }\n-\n-            // Extract all of the ledger ID's that comprise all of the entry logs\n-            // (except for the current new one which is still being written to).\n-            entryLogMetaMap = extractMetaFromEntryLogs(entryLogMetaMap);\n-\n-            // gc inactive/deleted ledgers\n-            doGcLedgers();\n-\n-            // gc entry logs\n-            doGcEntryLogs();\n-\n-            long curTime = MathUtils.now();\n-            if (force || (enableMajorCompaction &&\n-                curTime - lastMajorCompactionTime > majorCompactionInterval)) {\n-                // enter major compaction\n-                LOG.info(\"Enter major compaction\");\n-                doCompactEntryLogs(majorCompactionThreshold);\n-                lastMajorCompactionTime = MathUtils.now();\n-                // also move minor compaction time\n-                lastMinorCompactionTime = lastMajorCompactionTime;\n-                continue;\n-            }\n-\n-            if (force || (enableMinorCompaction &&\n-                curTime - lastMinorCompactionTime > minorCompactionInterval)) {\n-                // enter minor compaction\n-                LOG.info(\"Enter minor compaction\");\n-                doCompactEntryLogs(minorCompactionThreshold);\n-                lastMinorCompactionTime = MathUtils.now();\n-            }\n-            forceGarbageCollection.set(false);\n-        }\n-        LOG.info(\"GarbageCollectorThread exited loop!\");\n-    }\n-\n-    /**\n-     * Do garbage collection ledger index files\n-     */\n-    private void doGcLedgers() {\n-        garbageCollector.gc(garbageCleaner);\n-    }\n-\n-    /**\n-     * Garbage collect those entry loggers which are not associated with any active ledgers\n-     */\n-    private void doGcEntryLogs() {\n-        // Loop through all of the entry logs and remove the non-active ledgers.\n-        for (Long entryLogId : entryLogMetaMap.keySet()) {\n-            EntryLogMetadata meta = entryLogMetaMap.get(entryLogId);\n-            for (Long entryLogLedger : meta.ledgersMap.keySet()) {\n-                // Remove the entry log ledger from the set if it isn't active.\n-                if (!activeLedgers.containsKey(entryLogLedger)) {\n-                    meta.removeLedger(entryLogLedger);\n-                }\n-            }\n-            if (meta.isEmpty()) {\n-                // This means the entry log is not associated with any active ledgers anymore.\n-                // We can remove this entry log file now.\n-                LOG.info(\"Deleting entryLogId \" + entryLogId + \" as it has no active ledgers!\");\n-                removeEntryLog(entryLogId);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Compact entry logs if necessary.\n-     *\n-     * <p>\n-     * Compaction will be executed from low unused space to high unused space.\n-     * Those entry log files whose remaining size percentage is higher than threshold\n-     * would not be compacted.\n-     * </p>\n-     */\n-    @VisibleForTesting\n-    void doCompactEntryLogs(double threshold) {\n-        LOG.info(\"Do compaction to compact those files lower than \" + threshold);\n-        // sort the ledger meta by occupied unused space\n-        Comparator<EntryLogMetadata> sizeComparator = new Comparator<EntryLogMetadata>() {\n-            @Override\n-            public int compare(EntryLogMetadata m1, EntryLogMetadata m2) {\n-                long unusedSize1 = m1.totalSize - m1.remainingSize;\n-                long unusedSize2 = m2.totalSize - m2.remainingSize;\n-                if (unusedSize1 > unusedSize2) {\n-                    return -1;\n-                } else if (unusedSize1 < unusedSize2) {\n-                    return 1;\n-                } else {\n-                    return 0;\n-                }\n-            }\n-        };\n-        List<EntryLogMetadata> logsToCompact = new ArrayList<EntryLogMetadata>();\n-        logsToCompact.addAll(entryLogMetaMap.values());\n-        Collections.sort(logsToCompact, sizeComparator);\n-        List<Long> toRemove = new ArrayList<Long>();\n-\n-        for (EntryLogMetadata meta : logsToCompact) {\n-            if (meta.getUsage() >= threshold) {\n-                break;\n-            }\n-            LOG.debug(\"Compacting entry log {} below threshold {}.\", meta.entryLogId, threshold);\n-            try {\n-                compactEntryLog(scannerFactory, meta);\n-                toRemove.add(meta.entryLogId);\n-            } catch (LedgerDirsManager.NoWritableLedgerDirException nwlde) {\n-                LOG.warn(\"No writable ledger directory available, aborting compaction\", nwlde);\n-                break;\n-            } catch (IOException ioe) {\n-                // if compact entry log throws IOException, we don't want to remove that\n-                // entry log. however, if some entries from that log have been readded\n-                // to the entry log, and the offset updated, it's ok to flush that\n-                LOG.error(\"Error compacting entry log. Log won't be deleted\", ioe);\n-            }\n-\n-            if (!running) { // if gc thread is not running, stop compaction\n-                return;\n-            }\n-        }\n-        try {\n-            // compaction finished, flush any outstanding offsets\n-            scannerFactory.flush();\n-        } catch (IOException ioe) {\n-            LOG.error(\"Cannot flush compacted entries, skip removal\", ioe);\n-            return;\n-        }\n-\n-        // offsets have been flushed, its now safe to remove the old entrylogs\n-        for (Long l : toRemove) {\n-            removeEntryLog(l);\n-        }\n-    }\n-\n-    /**\n-     * Shutdown the garbage collector thread.\n-     *\n-     * @throws InterruptedException if there is an exception stopping gc thread.\n-     */\n-    public void shutdown() throws InterruptedException {\n-        this.running = false;\n-        LOG.info(\"Shutting down GarbageCollectorThread\");\n-        if (compacting.compareAndSet(false, true)) {\n-            // if setting compacting flag succeed, means gcThread is not compacting now\n-            // it is safe to interrupt itself now\n-            this.interrupt();\n-        }\n-        this.join();\n-    }\n-\n-    /**\n-     * Remove entry log.\n-     *\n-     * @param entryLogId\n-     *          Entry Log File Id\n-     */\n-    private void removeEntryLog(long entryLogId) {\n-        // remove entry log file successfully\n-        if (entryLogger.removeEntryLog(entryLogId)) {\n-            entryLogMetaMap.remove(entryLogId);\n-        }\n-    }\n-\n-    /**\n-     * Compact an entry log.\n-     *\n-     * @param entryLogId\n-     *          Entry Log File Id\n-     */\n-    protected void compactEntryLog(CompactionScannerFactory scannerFactory,\n-                                   EntryLogMetadata entryLogMeta) throws IOException {\n-        // Similar with Sync Thread\n-        // try to mark compacting flag to make sure it would not be interrupted\n-        // by shutdown during compaction. otherwise it will receive\n-        // ClosedByInterruptException which may cause index file & entry logger\n-        // closed and corrupted.\n-        if (!compacting.compareAndSet(false, true)) {\n-            // set compacting flag failed, means compacting is true now\n-            // indicates another thread wants to interrupt gc thread to exit\n-            return;\n-        }\n-\n-        LOG.info(\"Compacting entry log : {}\", entryLogMeta.entryLogId);\n-\n-        try {\n-            entryLogger.scanEntryLog(entryLogMeta.entryLogId,\n-                                     scannerFactory.newScanner(entryLogMeta));\n-        } finally {\n-            // clear compacting flag\n-            compacting.set(false);\n-        }\n-    }\n-\n-    /**\n-     * Records the total size, remaining size and the set of ledgers that comprise a entry log.\n-     */\n-    static class EntryLogMetadata {\n-        long entryLogId;\n-        long totalSize;\n-        long remainingSize;\n-        ConcurrentHashMap<Long, Long> ledgersMap;\n-\n-        public EntryLogMetadata(long logId) {\n-            this.entryLogId = logId;\n-\n-            totalSize = remainingSize = 0;\n-            ledgersMap = new ConcurrentHashMap<Long, Long>();\n-        }\n-\n-        public void addLedgerSize(long ledgerId, long size) {\n-            totalSize += size;\n-            remainingSize += size;\n-            Long ledgerSize = ledgersMap.get(ledgerId);\n-            if (null == ledgerSize) {\n-                ledgerSize = 0L;\n-            }\n-            ledgerSize += size;\n-            ledgersMap.put(ledgerId, ledgerSize);\n-        }\n-\n-        public void removeLedger(long ledgerId) {\n-            Long size = ledgersMap.remove(ledgerId);\n-            if (null == size) {\n-                return;\n-            }\n-            remainingSize -= size;\n-        }\n-\n-        public boolean containsLedger(long ledgerId) {\n-            return ledgersMap.containsKey(ledgerId);\n-        }\n-\n-        public double getUsage() {\n-            if (totalSize == 0L) {\n-                return 0.0f;\n-            }\n-            return (double)remainingSize / totalSize;\n-        }\n-\n-        public boolean isEmpty() {\n-            return ledgersMap.isEmpty();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(\"{ totalSize = \").append(totalSize).append(\", remainingSize = \")\n-              .append(remainingSize).append(\", ledgersMap = \").append(ledgersMap).append(\" }\");\n-            return sb.toString();\n-        }\n-    }\n-\n-    /**\n-     * A scanner used to extract entry log meta from entry log files.\n-     */\n-    static class ExtractionScanner implements EntryLogScanner {\n-        EntryLogMetadata meta;\n-\n-        public ExtractionScanner(EntryLogMetadata meta) {\n-            this.meta = meta;\n-        }\n-\n-        @Override\n-        public boolean accept(long ledgerId) {\n-            return true;\n-        }\n-        @Override\n-        public void process(long ledgerId, long offset, ByteBuffer entry) {\n-            // add new entry size of a ledger to entry log meta\n-            meta.addLedgerSize(ledgerId, entry.limit() + 4);\n-        }\n-    }\n-\n-    /**\n-     * Method to read in all of the entry logs (those that we haven't done so yet),\n-     * and find the set of ledger ID's that make up each entry log file.\n-     *\n-     * @param entryLogMetaMap\n-     *          Existing EntryLogs to Meta\n-     * @throws IOException\n-     */\n-    protected Map<Long, EntryLogMetadata> extractMetaFromEntryLogs(Map<Long, EntryLogMetadata> entryLogMetaMap) {\n-        // Extract it for every entry log except for the current one.\n-        // Entry Log ID's are just a long value that starts at 0 and increments\n-        // by 1 when the log fills up and we roll to a new one.\n-        long curLogId = entryLogger.getLeastUnflushedLogId();\n-        boolean hasExceptionWhenScan = false;\n-        for (long entryLogId = scannedLogId; entryLogId < curLogId; entryLogId++) {\n-            // Comb the current entry log file if it has not already been extracted.\n-            if (entryLogMetaMap.containsKey(entryLogId)) {\n-                continue;\n-            }\n-\n-            // check whether log file exists or not\n-            // if it doesn't exist, this log file might have been garbage collected.\n-            if (!entryLogger.logExists(entryLogId)) {\n-                continue;\n-            }\n-\n-            LOG.info(\"Extracting entry log meta from entryLogId: {}\", entryLogId);\n-\n-            try {\n-                // Read through the entry log file and extract the entry log meta\n-                EntryLogMetadata entryLogMeta = extractMetaFromEntryLog(entryLogger, entryLogId);\n-                entryLogMetaMap.put(entryLogId, entryLogMeta);\n-            } catch (IOException e) {\n-                hasExceptionWhenScan = true;\n-                LOG.warn(\"Premature exception when processing \" + entryLogId +\n-                         \" recovery will take care of the problem\", e);\n-            }\n-\n-            // if scan failed on some entry log, we don't move 'scannedLogId' to next id\n-            // if scan succeed, we don't need to scan it again during next gc run,\n-            // we move 'scannedLogId' to next id\n-            if (!hasExceptionWhenScan) {\n-                ++scannedLogId;\n-            }\n-        }\n-        return entryLogMetaMap;\n-    }\n-\n-    static EntryLogMetadata extractMetaFromEntryLog(EntryLogger entryLogger, long entryLogId)\n-            throws IOException {\n-        EntryLogMetadata entryLogMeta = new EntryLogMetadata(entryLogId);\n-        ExtractionScanner scanner = new ExtractionScanner(entryLogMeta);\n-        // Read through the entry log file and extract the entry log meta\n-        entryLogger.scanEntryLog(entryLogId, scanner);\n-        LOG.debug(\"Retrieved entry log meta data entryLogId: {}, meta: {}\",\n-                  entryLogId, entryLogMeta);\n-        return entryLogMeta;\n-    }\n-}"},{"sha":"ee5f8f81eedf737a0b1736a5d6b0f9d7bb9c83e1","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,32 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-\n-interface HandleFactory {\n-    LedgerDescriptor getHandle(long ledgerId, byte[] masterKey)\n-            throws IOException, BookieException;\n-\n-    LedgerDescriptor getReadOnlyHandle(long ledgerId)\n-            throws IOException, Bookie.NoLedgerException;\n-}\n\\ No newline at end of file"},{"sha":"45be76397a02b1e32df02eb0a8b16d50ebdd7e00","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","status":"removed","additions":0,"deletions":68,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,68 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-class HandleFactoryImpl implements HandleFactory {\n-    ConcurrentMap<Long, LedgerDescriptor> ledgers = new ConcurrentHashMap<Long, LedgerDescriptor>();\n-    ConcurrentMap<Long, LedgerDescriptor> readOnlyLedgers\n-        = new ConcurrentHashMap<Long, LedgerDescriptor>();\n-\n-    final LedgerStorage ledgerStorage;\n-\n-    HandleFactoryImpl(LedgerStorage ledgerStorage) {\n-        this.ledgerStorage = ledgerStorage;\n-    }\n-\n-    @Override\n-    public LedgerDescriptor getHandle(long ledgerId, byte[] masterKey)\n-            throws IOException, BookieException {\n-        LedgerDescriptor handle = null;\n-        if (null == (handle = ledgers.get(ledgerId))) {\n-            // LedgerDescriptor#create sets the master key in the ledger storage, calling it\n-            // twice on the same ledgerId is safe because it eventually puts a value in the ledger cache\n-            // that guarantees synchronized access across all cached entries.\n-            handle = ledgers.putIfAbsent(ledgerId, LedgerDescriptor.create(masterKey, ledgerId, ledgerStorage));\n-            if (null == handle) {\n-                handle = ledgers.get(ledgerId);\n-            }\n-        }\n-        handle.checkAccess(masterKey);\n-        return handle;\n-    }\n-\n-    @Override\n-    public LedgerDescriptor getReadOnlyHandle(long ledgerId)\n-            throws IOException, Bookie.NoLedgerException {\n-        LedgerDescriptor handle = null;\n-        if (null == (handle = readOnlyLedgers.get(ledgerId))) {\n-            handle = readOnlyLedgers.putIfAbsent(ledgerId, LedgerDescriptor.createReadOnly(ledgerId, ledgerStorage));\n-            if (null == handle) {\n-                handle = readOnlyLedgers.get(ledgerId);\n-            }\n-        }\n-        return handle;\n-    }\n-}"},{"sha":"454a38335c8fb3ddaca268ece564c6ae171fef1f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","status":"removed","additions":0,"deletions":564,"changes":564,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,564 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.stats.Gauge;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentSkipListSet;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_INDEX_PAGES;\n-\n-class IndexInMemPageMgr {\n-    private final static Logger LOG = LoggerFactory.getLogger(IndexInMemPageMgr.class);\n-    private final static ConcurrentHashMap<Long, LedgerEntryPage> EMPTY_PAGE_MAP\n-        = new ConcurrentHashMap<Long, LedgerEntryPage>();\n-\n-    private static class InMemPageCollection implements LEPStateChangeCallback {\n-\n-        ConcurrentMap<Long, ConcurrentMap<Long,LedgerEntryPage>> pages;\n-\n-        Map<EntryKey, LedgerEntryPage> lruCleanPageMap;\n-\n-        public InMemPageCollection() {\n-            pages = new ConcurrentHashMap<Long, ConcurrentMap<Long,LedgerEntryPage>>();\n-            lruCleanPageMap =\n-                Collections.synchronizedMap(new LinkedHashMap<EntryKey, LedgerEntryPage>(16, 0.75f, true));\n-        }\n-\n-        /**\n-         * Retrieve the LedgerEntryPage corresponding to the ledger and firstEntry\n-         *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @param firstEntry\n-         *          Id of the first entry in the page\n-         * @returns LedgerEntryPage if present\n-         */\n-        private LedgerEntryPage getPage(long ledgerId, long firstEntry) {\n-            ConcurrentMap<Long, LedgerEntryPage> map = pages.get(ledgerId);\n-            if (null != map) {\n-                return map.get(firstEntry);\n-            }\n-            return null;\n-        }\n-\n-        /**\n-         * Add a LedgerEntryPage to the page map\n-         *\n-         * @param lep\n-         *          Ledger Entry Page object\n-         */\n-        private LedgerEntryPage putPage(LedgerEntryPage lep) {\n-            // Do a get here to avoid too many new ConcurrentHashMaps() as putIntoTable is called frequently.\n-            ConcurrentMap<Long, LedgerEntryPage> map = pages.get(lep.getLedger());\n-            if (null == map) {\n-                ConcurrentMap<Long, LedgerEntryPage> mapToPut = new ConcurrentHashMap<Long, LedgerEntryPage>();\n-                map = pages.putIfAbsent(lep.getLedger(), mapToPut);\n-                if (null == map) {\n-                    map = mapToPut;\n-                }\n-            }\n-            LedgerEntryPage oldPage = map.putIfAbsent(lep.getFirstEntry(), lep);\n-            if (null == oldPage) {\n-                oldPage = lep;\n-                // Also include this in the clean page map if it qualifies.\n-                // Note: This is done for symmetry and correctness, however it should never\n-                // get exercised since we shouldn't attempt a put without the page being in use\n-                addToCleanPagesList(lep);\n-            }\n-            return oldPage;\n-        }\n-\n-        /**\n-         * Traverse the pages for a given ledger in memory and find the highest\n-         * entry amongst these pages\n-         *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @returns last entry in the in memory pages\n-         */\n-        private long getLastEntryInMem(long ledgerId) {\n-            long lastEntry = 0;\n-            // Find the last entry in the cache\n-            ConcurrentMap<Long, LedgerEntryPage> map = pages.get(ledgerId);\n-            if (map != null) {\n-                for(LedgerEntryPage lep: map.values()) {\n-                    if (lep.getMaxPossibleEntry() < lastEntry) {\n-                        continue;\n-                    }\n-                    lep.usePage();\n-                    long highest = lep.getLastEntry();\n-                    if (highest > lastEntry) {\n-                        lastEntry = highest;\n-                    }\n-                    lep.releasePage();\n-                }\n-            }\n-            return lastEntry;\n-        }\n-\n-        /**\n-         * Removes ledger entry pages for a given ledger\n-         *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @returns number of pages removed\n-         */\n-        private int removeEntriesForALedger(long ledgerId) {\n-            // remove pages first to avoid page flushed when deleting file info\n-            ConcurrentMap<Long, LedgerEntryPage> lPages = pages.remove(ledgerId);\n-            if (null != lPages) {\n-                for (long entryId: lPages.keySet()) {\n-                    synchronized(lruCleanPageMap) {\n-                        lruCleanPageMap.remove(new EntryKey(ledgerId, entryId));\n-                    }\n-                }\n-                return lPages.size();\n-            }\n-            return 0;\n-        }\n-\n-        /**\n-         * Gets the list of pages in memory that have been changed and hence need to\n-         * be written as a part of the flush operation that is being issued\n-         *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @returns last entry in the in memory pages.\n-         */\n-        private LinkedList<Long> getFirstEntryListToBeFlushed(long ledgerId) {\n-            ConcurrentMap<Long, LedgerEntryPage> pageMap = pages.get(ledgerId);\n-            if (pageMap == null || pageMap.isEmpty()) {\n-                return null;\n-            }\n-\n-            LinkedList<Long> firstEntryList = new LinkedList<Long>();\n-            for(ConcurrentMap.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n-                LedgerEntryPage lep = entry.getValue();\n-                if (lep.isClean()) {\n-                    if (!lep.inUse()) {\n-                        addToCleanPagesList(lep);\n-                    }\n-                    if (LOG.isTraceEnabled()) {\n-                        LOG.trace(\"Page is clean \" + lep);\n-                    }\n-                } else {\n-                    firstEntryList.add(lep.getFirstEntry());\n-                }\n-            }\n-            return firstEntryList;\n-        }\n-\n-        /**\n-         * Add the LedgerEntryPage to the clean page LRU map\n-         *\n-         * @param lep\n-         *          Ledger Entry Page object\n-         */\n-        private void addToCleanPagesList(LedgerEntryPage lep) {\n-            synchronized(lruCleanPageMap) {\n-                if (lep.isClean() && !lep.inUse()) {\n-                    lruCleanPageMap.put(lep.getEntryKey(), lep);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Remove the LedgerEntryPage from the clean page LRU map\n-         *\n-         * @param lep\n-         *          Ledger Entry Page object\n-         */\n-        private void removeFromCleanPageList(LedgerEntryPage lep) {\n-            synchronized(lruCleanPageMap) {\n-                if (!lep.isClean() || lep.inUse()) {\n-                    lruCleanPageMap.remove(lep.getEntryKey());\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Get the set of active ledgers\n-         *\n-         */\n-        Set<Long> getActiveLedgers() {\n-            return pages.keySet();\n-        }\n-\n-        /**\n-         * Get a clean page and provision it for the specified ledger and firstEntry within\n-         * the ledger\n-         *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @param firstEntry\n-         *          Id of the first entry in the page\n-         * @returns LedgerEntryPage if present\n-         */\n-        LedgerEntryPage grabCleanPage(long ledgerId, long firstEntry) {\n-            LedgerEntryPage lep = null;\n-            while (lruCleanPageMap.size() > 0) {\n-                lep = null;\n-                synchronized(lruCleanPageMap) {\n-                    Iterator<Map.Entry<EntryKey,LedgerEntryPage>> iterator = lruCleanPageMap.entrySet().iterator();\n-\n-                    Map.Entry<EntryKey,LedgerEntryPage> entry = null;\n-                    while (iterator.hasNext())\n-                    {\n-                        entry = iterator.next();\n-                        iterator.remove();\n-                        if (entry.getValue().isClean() &&\n-                                !entry.getValue().inUse()) {\n-                            lep = entry.getValue();\n-                            break;\n-                        }\n-                    }\n-\n-                    if (null == lep) {\n-                        LOG.debug(\"Did not find eligible page in the first pass\");\n-                        return null;\n-                    }\n-                }\n-\n-                // We found a candidate page, lets see if we can reclaim it before its re-used\n-                ConcurrentMap<Long, LedgerEntryPage> pageMap = pages.get(lep.getLedger());\n-                // Remove from map only if nothing has changed since we checked this lep.\n-                // Its possible for the ledger to have been deleted or the page to have already\n-                // been reclaimed. The page map is the definitive source of information, if anything\n-                // has changed we should leave this page along and continue iterating to find\n-                // another suitable page.\n-                if ((null != pageMap) && (pageMap.remove(lep.getFirstEntry(), lep))) {\n-                    if (!lep.isClean()) {\n-                        // Someone wrote to this page while we were reclaiming it.\n-                        pageMap.put(lep.getFirstEntry(), lep);\n-                        lep = null;\n-                    } else {\n-                        // Do some bookkeeping on the page table\n-                        pages.remove(lep.getLedger(), EMPTY_PAGE_MAP);\n-                        // We can now safely reset this lep and return it.\n-                        lep.usePage();\n-                        lep.zeroPage();\n-                        lep.setLedgerAndFirstEntry(ledgerId, firstEntry);\n-                        return lep;\n-                    }\n-                } else {\n-                    lep = null;\n-                }\n-            }\n-            return lep;\n-        }\n-\n-        @Override\n-        public void onSetInUse(LedgerEntryPage lep) {\n-            removeFromCleanPageList(lep);\n-        }\n-\n-        @Override\n-        public void onResetInUse(LedgerEntryPage lep) {\n-            addToCleanPagesList(lep);\n-        }\n-\n-        @Override\n-        public void onSetClean(LedgerEntryPage lep) {\n-            addToCleanPagesList(lep);\n-        }\n-\n-        @Override\n-        public void onSetDirty(LedgerEntryPage lep) {\n-            removeFromCleanPageList(lep);\n-        }\n-    }\n-\n-    final int pageSize;\n-    final int entriesPerPage;\n-    final int pageLimit;\n-    final InMemPageCollection pageMapAndList;\n-\n-    // The number of pages that have actually been used\n-    private final AtomicInteger pageCount = new AtomicInteger(0);\n-\n-    // The persistence manager that this page manager uses to\n-    // flush and read pages\n-    private final IndexPersistenceMgr indexPersistenceManager;\n-\n-    /**\n-     * the list of potentially dirty ledgers\n-     */\n-    private final ConcurrentLinkedQueue<Long> ledgersToFlush = new ConcurrentLinkedQueue<Long>();\n-    private final ConcurrentSkipListSet<Long> ledgersFlushing = new ConcurrentSkipListSet<Long>();\n-\n-    public IndexInMemPageMgr(int pageSize,\n-                             int entriesPerPage,\n-                             ServerConfiguration conf,\n-                             IndexPersistenceMgr indexPersistenceManager,\n-                             StatsLogger statsLogger) {\n-        this.pageSize = pageSize;\n-        this.entriesPerPage = entriesPerPage;\n-        this.indexPersistenceManager = indexPersistenceManager;\n-        this.pageMapAndList = new InMemPageCollection();\n-\n-        if (conf.getPageLimit() <= 0) {\n-            // allocate half of the memory to the page cache\n-            this.pageLimit = (int) ((Runtime.getRuntime().maxMemory() / 3) / this.pageSize);\n-        } else {\n-            this.pageLimit = conf.getPageLimit();\n-        }\n-        LOG.info(\"maxMemory = {}, pageSize = {}, pageLimit = {}\", new Object[] { Runtime.getRuntime().maxMemory(),\n-                        pageSize, pageLimit });\n-        // Expose Stats\n-        statsLogger.registerGauge(NUM_INDEX_PAGES, new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return getNumUsedPages();\n-            }\n-        });\n-    }\n-\n-    /**\n-     * @return page size used in ledger cache\n-     */\n-    public int getPageSize() {\n-        return pageSize;\n-    }\n-\n-    /**\n-     * @return entries per page used in ledger cache\n-     */\n-    public int getEntriesPerPage() {\n-        return entriesPerPage;\n-    }\n-\n-    /**\n-     * @return page limitation in ledger cache\n-     */\n-    public int getPageLimit() {\n-        return pageLimit;\n-    }\n-\n-    /**\n-     * @return number of page used in ledger cache\n-     */\n-    public int getNumUsedPages() {\n-        return pageCount.get();\n-    }\n-\n-    LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n-        LedgerEntryPage lep = pageMapAndList.getPage(ledger, firstEntry);\n-        if (onlyDirty && null != lep && lep.isClean()) {\n-            return null;\n-        }\n-        if (null != lep) {\n-            lep.usePage();\n-        }\n-        return lep;\n-    }\n-\n-    /**\n-     * Grab ledger entry page whose first entry is <code>pageEntry</code>.\n-     *\n-     * If the page doesn't existed before, we allocate a memory page.\n-     * Otherwise, we grab a clean page and read it from disk.\n-     *\n-     * @param ledger\n-     *          Ledger Id\n-     * @param pageEntry\n-     *          Start entry of this entry page.\n-     */\n-    private LedgerEntryPage grabLedgerEntryPage(long ledger, long pageEntry) throws IOException {\n-        LedgerEntryPage lep = grabCleanPage(ledger, pageEntry);\n-        try {\n-            // should get the up to date page from the persistence manager\n-            // before we put it into table otherwise we would put\n-            // an empty page in it\n-            indexPersistenceManager.updatePage(lep);\n-            LedgerEntryPage oldLep;\n-            if (lep != (oldLep = pageMapAndList.putPage(lep))) {\n-                lep.releasePage();\n-                // Decrement the page count because we couldn't put this lep in the page cache.\n-                pageCount.decrementAndGet();\n-                // Increment the use count of the old lep because this is unexpected\n-                oldLep.usePage();\n-                lep = oldLep;\n-            }\n-        } catch (IOException ie) {\n-            // if we grab a clean page, but failed to update the page\n-            // we are exhausting the count of ledger entry pages.\n-            // since this page will be never used, so we need to decrement\n-            // page count of ledger cache.\n-            lep.releasePage();\n-            pageCount.decrementAndGet();\n-            throw ie;\n-        }\n-        return lep;\n-    }\n-\n-    void removePagesForLedger(long ledgerId) {\n-        int removedPageCount = pageMapAndList.removeEntriesForALedger(ledgerId);\n-        if (pageCount.addAndGet(-removedPageCount) < 0) {\n-            throw new RuntimeException(\"Page count of ledger cache has been decremented to be less than zero.\");\n-        }\n-        ledgersToFlush.remove(ledgerId);\n-    }\n-\n-    long getLastEntryInMem(long ledgerId) {\n-        return pageMapAndList.getLastEntryInMem(ledgerId);\n-    }\n-\n-    private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOException {\n-        if (entry % entriesPerPage != 0) {\n-            throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n-        }\n-\n-        while(true) {\n-            boolean canAllocate = false;\n-            if (pageCount.incrementAndGet() <= pageLimit) {\n-                canAllocate = true;\n-            } else {\n-                pageCount.decrementAndGet();\n-            }\n-\n-            if (canAllocate) {\n-                LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage, pageMapAndList);\n-                lep.setLedgerAndFirstEntry(ledger, entry);\n-                lep.usePage();\n-                return lep;\n-            }\n-\n-            LedgerEntryPage lep = pageMapAndList.grabCleanPage(ledger, entry);\n-            if (null != lep) {\n-                return lep;\n-            }\n-            LOG.info(\"Could not grab a clean page for ledger {}, entry {}, force flushing dirty ledgers.\",\n-                    ledger, entry);\n-            flushOneOrMoreLedgers(false);\n-        }\n-    }\n-\n-    void flushOneOrMoreLedgers(boolean doAll) throws IOException {\n-        if (ledgersToFlush.isEmpty()) {\n-            ledgersToFlush.addAll(pageMapAndList.getActiveLedgers());\n-        }\n-        Long potentiallyDirtyLedger;\n-        while (null != (potentiallyDirtyLedger = ledgersToFlush.poll())) {\n-            if (!ledgersFlushing.add(potentiallyDirtyLedger)) {\n-                continue;\n-            }\n-            try {\n-                flushSpecificLedger(potentiallyDirtyLedger);\n-            } finally {\n-                ledgersFlushing.remove(potentiallyDirtyLedger);\n-            }\n-            if (!doAll) {\n-                break;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Flush a specified ledger\n-     *\n-     * @param ledger\n-     *          Ledger Id\n-     * @throws IOException\n-     */\n-    private void flushSpecificLedger(long ledger) throws IOException {\n-        LinkedList<Long> firstEntryList = pageMapAndList.getFirstEntryListToBeFlushed(ledger);\n-\n-        // flush ledger index file header if necessary\n-        indexPersistenceManager.flushLedgerHeader(ledger);\n-\n-        if (null == firstEntryList || firstEntryList.size() == 0) {\n-            LOG.debug(\"Nothing to flush for ledger {}.\", ledger);\n-            // nothing to do\n-            return;\n-        }\n-\n-        // Now flush all the pages of a ledger\n-        List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n-        try {\n-            for(Long firstEntry: firstEntryList) {\n-                LedgerEntryPage lep = getLedgerEntryPage(ledger, firstEntry, true);\n-                if (lep != null) {\n-                    entries.add(lep);\n-                }\n-            }\n-            indexPersistenceManager.flushLedgerEntries(ledger, entries);\n-        } finally {\n-            for(LedgerEntryPage lep: entries) {\n-                lep.releasePage();\n-            }\n-        }\n-    }\n-\n-    void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n-        int offsetInPage = (int) (entry % entriesPerPage);\n-        // find the id of the first entry of the page that has the entry\n-        // we are looking for\n-        long pageEntry = entry - offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        if (lep == null) {\n-            lep = grabLedgerEntryPage(ledger, pageEntry);\n-        }\n-        assert lep != null;\n-        lep.setOffset(offset, offsetInPage * LedgerEntryPage.getIndexEntrySize());\n-        lep.releasePage();\n-    }\n-\n-    long getEntryOffset(long ledger, long entry) throws IOException {\n-        int offsetInPage = (int) (entry % entriesPerPage);\n-        // find the id of the first entry of the page that has the entry\n-        // we are looking for\n-        long pageEntry = entry - offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        try {\n-            if (lep == null) {\n-                lep = grabLedgerEntryPage(ledger, pageEntry);\n-            }\n-            return lep.getOffset(offsetInPage * LedgerEntryPage.getIndexEntrySize());\n-        } finally {\n-            if (lep != null) {\n-                lep.releasePage();\n-            }\n-        }\n-    }\n-}"},{"sha":"60b409951cef808ec8718fba4984c6042615f07f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"removed","additions":0,"deletions":588,"changes":588,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,588 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.Gauge;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.SnapshotMap;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_NUM_EVICTED_LEDGERS;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_OPEN_LEDGERS;\n-\n-public class IndexPersistenceMgr {\n-    private final static Logger LOG = LoggerFactory.getLogger(IndexPersistenceMgr.class);\n-\n-    private static final String IDX = \".idx\";\n-    static final String RLOC = \".rloc\";\n-\n-    @VisibleForTesting\n-    public static final String getLedgerName(long ledgerId) {\n-        int parent = (int) (ledgerId & 0xff);\n-        int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(Integer.toHexString(grandParent));\n-        sb.append('/');\n-        sb.append(Integer.toHexString(parent));\n-        sb.append('/');\n-        sb.append(Long.toHexString(ledgerId));\n-        sb.append(IDX);\n-        return sb.toString();\n-    }\n-\n-    final ConcurrentMap<Long, FileInfo> fileInfoCache = new ConcurrentHashMap<Long, FileInfo>();\n-    final int openFileLimit;\n-    final int pageSize;\n-    final int entriesPerPage;\n-\n-    // Manage all active ledgers in LedgerManager\n-    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n-    final SnapshotMap<Long, Boolean> activeLedgers;\n-    private LedgerDirsManager ledgerDirsManager;\n-    final LinkedList<Long> openLedgers = new LinkedList<Long>();\n-\n-    // Stats\n-    private final Counter evictedLedgersCounter;\n-\n-    public IndexPersistenceMgr(int pageSize,\n-                               int entriesPerPage,\n-                               ServerConfiguration conf,\n-                               SnapshotMap<Long, Boolean> activeLedgers,\n-                               LedgerDirsManager ledgerDirsManager,\n-                               StatsLogger statsLogger) throws IOException {\n-        this.openFileLimit = conf.getOpenFileLimit();\n-        this.activeLedgers = activeLedgers;\n-        this.ledgerDirsManager = ledgerDirsManager;\n-        this.pageSize = pageSize;\n-        this.entriesPerPage = entriesPerPage;\n-        LOG.info(\"openFileLimit = {}\", openFileLimit);\n-        // Retrieve all of the active ledgers.\n-        getActiveLedgers();\n-        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n-\n-        // Expose Stats\n-        evictedLedgersCounter = statsLogger.getCounter(LEDGER_CACHE_NUM_EVICTED_LEDGERS);\n-        statsLogger.registerGauge(NUM_OPEN_LEDGERS, new Gauge<Integer>() {\n-            @Override\n-            public Integer getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Integer getSample() {\n-                return getNumOpenLedgers();\n-            }\n-        });\n-    }\n-\n-    FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n-        FileInfo fi = fileInfoCache.get(ledger);\n-        if (null == fi) {\n-            boolean createdNewFile = false;\n-            File lf = null;\n-            synchronized (this) {\n-                // Check if the index file exists on disk.\n-                lf = findIndexFile(ledger);\n-                if (null == lf) {\n-                    if (null == masterKey) {\n-                        throw new Bookie.NoLedgerException(ledger);\n-                    }\n-                    // We don't have a ledger index file on disk, so create it.\n-                    lf = getNewLedgerIndexFile(ledger, null);\n-                    createdNewFile = true;\n-                }\n-            }\n-            fi = putFileInfo(ledger, masterKey, lf, createdNewFile);\n-        }\n-\n-        assert null != fi;\n-        fi.use();\n-        return fi;\n-    }\n-\n-    private FileInfo putFileInfo(Long ledger, byte masterKey[], File lf, boolean createdNewFile) throws IOException {\n-        FileInfo fi = new FileInfo(lf, masterKey);\n-        FileInfo oldFi = fileInfoCache.putIfAbsent(ledger, fi);\n-        if (null != oldFi) {\n-            // Some other thread won the race. We should delete our file if we created\n-            // a new one and the paths are different.\n-            if (createdNewFile && !oldFi.isSameFile(lf)) {\n-                fi.delete();\n-            }\n-            fi = oldFi;\n-        } else {\n-            if (createdNewFile) {\n-                // Else, we won and the active ledger manager should know about this.\n-                LOG.debug(\"New ledger index file created for ledgerId: {}\", ledger);\n-                activeLedgers.put(ledger, true);\n-            }\n-            // Evict cached items from the file info cache if necessary\n-            evictFileInfoIfNecessary();\n-            synchronized (openLedgers) {\n-                openLedgers.offer(ledger);\n-            }\n-        }\n-        return fi;\n-    }\n-\n-    /**\n-     * Get a new index file for ledger excluding directory <code>excludedDir</code>.\n-     *\n-     * @param ledger\n-     *          Ledger id.\n-     * @param excludedDir\n-     *          The ledger directory to exclude.\n-     * @return new index file object.\n-     * @throws NoWritableLedgerDirException if there is no writable dir available.\n-     */\n-    private File getNewLedgerIndexFile(Long ledger, File excludedDir)\n-                    throws NoWritableLedgerDirException {\n-        File dir = ledgerDirsManager.pickRandomWritableDir(excludedDir);\n-        String ledgerName = getLedgerName(ledger);\n-        return new File(dir, ledgerName);\n-    }\n-\n-    /**\n-     * This method will look within the ledger directories for the ledger index\n-     * files. That will comprise the set of active ledgers this particular\n-     * BookieServer knows about that have not yet been deleted by the BookKeeper\n-     * Client. This is called only once during initialization.\n-     */\n-    private void getActiveLedgers() throws IOException {\n-        // Ledger index files are stored in a file hierarchy with a parent and\n-        // grandParent directory. We'll have to go two levels deep into these\n-        // directories to find the index files.\n-        for (File ledgerDirectory : ledgerDirsManager.getAllLedgerDirs()) {\n-            for (File grandParent : ledgerDirectory.listFiles()) {\n-                if (grandParent.isDirectory()) {\n-                    for (File parent : grandParent.listFiles()) {\n-                        if (parent.isDirectory()) {\n-                            for (File index : parent.listFiles()) {\n-                                if (!index.isFile()\n-                                        || (!index.getName().endsWith(IDX) && !index.getName().endsWith(RLOC))) {\n-                                    continue;\n-                                }\n-\n-                                // We've found a ledger index file. The file\n-                                // name is the HexString representation of the\n-                                // ledgerId.\n-                                String ledgerIdInHex = index.getName().replace(RLOC, \"\").replace(IDX, \"\");\n-                                if (index.getName().endsWith(RLOC)) {\n-                                    if (findIndexFile(Long.parseLong(ledgerIdInHex)) != null) {\n-                                        if (!index.delete()) {\n-                                            LOG.warn(\"Deleting the rloc file \" + index + \" failed\");\n-                                        }\n-                                        continue;\n-                                    } else {\n-                                        File dest = new File(index.getParentFile(), ledgerIdInHex + IDX);\n-                                        if (!index.renameTo(dest)) {\n-                                            throw new IOException(\"Renaming rloc file \" + index\n-                                                    + \" to index file has failed\");\n-                                        }\n-                                    }\n-                                }\n-                                activeLedgers.put(Long.parseLong(ledgerIdInHex, 16), true);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is called whenever a ledger is deleted by the BookKeeper Client\n-     * and we want to remove all relevant data for it stored in the LedgerCache.\n-     */\n-    void removeLedger(long ledgerId) throws IOException {\n-        // Delete the ledger's index file and close the FileInfo\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(ledgerId, null);\n-            fi.close(false);\n-            fi.delete();\n-        } finally {\n-            // should release use count\n-            // otherwise the file channel would not be closed.\n-            if (null != fi) {\n-                fi.release();\n-            }\n-        }\n-\n-        // Remove it from the active ledger manager\n-        activeLedgers.remove(ledgerId);\n-\n-        // Now remove it from all the other lists and maps.\n-        fileInfoCache.remove(ledgerId);\n-        synchronized (openLedgers) {\n-            openLedgers.remove(ledgerId);\n-        }\n-    }\n-\n-    private File findIndexFile(long ledgerId) throws IOException {\n-        String ledgerName = getLedgerName(ledgerId);\n-        for (File d : ledgerDirsManager.getAllLedgerDirs()) {\n-            File lf = new File(d, ledgerName);\n-            if (lf.exists()) {\n-                return lf;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    boolean ledgerExists(long ledgerId) throws IOException {\n-        FileInfo fi = fileInfoCache.get(ledgerId);\n-        if (fi == null) {\n-            File lf = findIndexFile(ledgerId);\n-            if (lf == null) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    int getNumOpenLedgers() {\n-        return openLedgers.size();\n-    }\n-\n-    // evict file info if necessary\n-    private void evictFileInfoIfNecessary() throws IOException {\n-        if (openLedgers.size() > openFileLimit) {\n-            Long ledgerToRemove;\n-            synchronized (openLedgers) {\n-                ledgerToRemove = openLedgers.poll();\n-            }\n-            if (null == ledgerToRemove) {\n-                // Should not reach here. We probably cleared this while the thread\n-                // was executing.\n-                return;\n-            }\n-            evictedLedgersCounter.inc();\n-            FileInfo fi = fileInfoCache.remove(ledgerToRemove);\n-            if (null == fi) {\n-                // Seems like someone else already closed the file.\n-                return;\n-            }\n-            fi.close(true);\n-         }\n-    }\n-\n-    void close() throws IOException {\n-        for (Entry<Long, FileInfo> fileInfo : fileInfoCache.entrySet()) {\n-            FileInfo value = fileInfo.getValue();\n-            if (value != null) {\n-                value.close(true);\n-            }\n-        }\n-        fileInfoCache.clear();\n-    }\n-\n-    byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n-        FileInfo fi = fileInfoCache.get(ledgerId);\n-        if (fi == null) {\n-            File lf = findIndexFile(ledgerId);\n-            if (lf == null) {\n-                throw new Bookie.NoLedgerException(ledgerId);\n-            }\n-            fi = putFileInfo(ledgerId, null, lf, false);\n-        }\n-        return fi.getMasterKey();\n-    }\n-\n-    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(ledgerId, masterKey);\n-        } finally {\n-            if (null != fi) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    boolean setFenced(long ledgerId) throws IOException {\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(ledgerId, null);\n-            return fi.setFenced();\n-        } finally {\n-            if (null != fi) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    boolean isFenced(long ledgerId) throws IOException {\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(ledgerId, null);\n-            return fi.isFenced();\n-        } finally {\n-            if (null != fi) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    int getOpenFileLimit() {\n-        return openFileLimit;\n-    }\n-\n-    private LedgerDirsListener getLedgerDirsListener() {\n-        return new LedgerDirsListener() {\n-            @Override\n-            public void diskFull(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void diskAlmostFull(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void diskFailed(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void allDisksFull() {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void fatalError() {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void diskWritable(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-\n-            @Override\n-            public void diskJustWritable(File disk) {\n-                // Nothing to handle here. Will be handled in Bookie\n-            }\n-        };\n-    }\n-\n-    private void relocateIndexFileAndFlushHeader(long ledger, FileInfo fi) throws IOException {\n-        File currentDir = getLedgerDirForLedger(fi);\n-        if (ledgerDirsManager.isDirFull(currentDir)) {\n-            moveLedgerIndexFile(ledger, fi);\n-        }\n-        fi.flushHeader();\n-    }\n-\n-    /**\n-     * Get the ledger directory that the ledger index belongs to.\n-     *\n-     * @param fi File info of a ledger\n-     * @return ledger directory that the ledger belongs to.\n-     */\n-    private File getLedgerDirForLedger(FileInfo fi) {\n-        return fi.getLf().getParentFile().getParentFile().getParentFile();\n-    }\n-\n-    private void moveLedgerIndexFile(Long l, FileInfo fi) throws NoWritableLedgerDirException, IOException {\n-        File newLedgerIndexFile = getNewLedgerIndexFile(l, getLedgerDirForLedger(fi));\n-        fi.moveToNewLocation(newLedgerIndexFile, fi.getSizeSinceLastwrite());\n-    }\n-\n-    void flushLedgerHeader(long ledger) throws IOException {\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(ledger, null);\n-            relocateIndexFileAndFlushHeader(ledger, fi);\n-        } catch (Bookie.NoLedgerException nle) {\n-            // ledger has been deleted\n-            LOG.info(\"No ledger {} found when flushing header.\", ledger);\n-            return;\n-        } finally {\n-            if (null != fi) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    void flushLedgerEntries(long l, List<LedgerEntryPage> entries) throws IOException {\n-        FileInfo fi = null;\n-        try {\n-            Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n-                @Override\n-                public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n-                    return (int) (o1.getFirstEntry() - o2.getFirstEntry());\n-                }\n-            });\n-            int[] versions = new int[entries.size()];\n-            try {\n-                fi = getFileInfo(l, null);\n-            } catch (Bookie.NoLedgerException nle) {\n-                // ledger has been deleted\n-                LOG.info(\"No ledger {} found when flushing entries.\", l);\n-                return;\n-            }\n-\n-            // flush the header if necessary\n-            relocateIndexFileAndFlushHeader(l, fi);\n-            int start = 0;\n-            long lastOffset = -1;\n-            for (int i = 0; i < entries.size(); i++) {\n-                versions[i] = entries.get(i).getVersion();\n-                if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n-                    // send up a sequential list\n-                    int count = i - start;\n-                    if (count == 0) {\n-                        LOG.warn(\"Count cannot possibly be zero!\");\n-                    }\n-                    writeBuffers(l, entries, fi, start, count);\n-                    start = i;\n-                }\n-                lastOffset = entries.get(i).getFirstEntry();\n-            }\n-            if (entries.size() - start == 0 && entries.size() != 0) {\n-                LOG.warn(\"Nothing to write, but there were entries!\");\n-            }\n-            writeBuffers(l, entries, fi, start, entries.size() - start);\n-            for (int i = 0; i < entries.size(); i++) {\n-                LedgerEntryPage lep = entries.get(i);\n-                lep.setClean(versions[i]);\n-            }\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Flushed ledger {} with {} pages.\", l, entries.size());\n-            }\n-        } finally {\n-            if (fi != null) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    private void writeBuffers(Long ledger,\n-                              List<LedgerEntryPage> entries, FileInfo fi,\n-                              int start, int count) throws IOException {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Writing {} buffers of {}\", count, Long.toHexString(ledger));\n-        }\n-        if (count == 0) {\n-            return;\n-        }\n-        ByteBuffer buffs[] = new ByteBuffer[count];\n-        for (int j = 0; j < count; j++) {\n-            buffs[j] = entries.get(start + j).getPageToWrite();\n-            if (entries.get(start + j).getLedger() != ledger) {\n-                throw new IOException(\"Writing to \" + ledger + \" but page belongs to \"\n-                                + entries.get(start + j).getLedger());\n-            }\n-        }\n-        long totalWritten = 0;\n-        while (buffs[buffs.length - 1].remaining() > 0) {\n-            long rc = fi.write(buffs, entries.get(start + 0).getFirstEntryPosition());\n-            if (rc <= 0) {\n-                throw new IOException(\"Short write to ledger \" + ledger + \" rc = \" + rc);\n-            }\n-            totalWritten += rc;\n-        }\n-        if (totalWritten != (long) count * (long) pageSize) {\n-            throw new IOException(\"Short write to ledger \" + ledger + \" wrote \" + totalWritten\n-                            + \" expected \" + count * pageSize);\n-        }\n-    }\n-\n-    void updatePage(LedgerEntryPage lep) throws IOException {\n-        if (!lep.isClean()) {\n-            throw new IOException(\"Trying to update a dirty page\");\n-        }\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(lep.getLedger(), null);\n-            long pos = lep.getFirstEntryPosition();\n-            if (pos >= fi.size()) {\n-                lep.zeroPage();\n-            } else {\n-                lep.readPage(fi);\n-            }\n-        } finally {\n-            if (fi != null) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    long getPersistEntryBeyondInMem(long ledgerId, long lastEntryInMem) throws IOException {\n-        FileInfo fi = null;\n-        long lastEntry = lastEntryInMem;\n-        try {\n-            fi = getFileInfo(ledgerId, null);\n-            long size = fi.size();\n-            // make sure the file size is aligned with index entry size\n-            // otherwise we may read incorret data\n-            if (0 != size % LedgerEntryPage.getIndexEntrySize()) {\n-                LOG.warn(\"Index file of ledger {} is not aligned with index entry size.\", ledgerId);\n-                size = size - size % LedgerEntryPage.getIndexEntrySize();\n-            }\n-            // we may not have the last entry in the cache\n-            if (size > lastEntry * LedgerEntryPage.getIndexEntrySize()) {\n-                ByteBuffer bb = ByteBuffer.allocate(pageSize);\n-                long position = size - pageSize;\n-                if (position < 0) {\n-                    position = 0;\n-                }\n-                fi.read(bb, position);\n-                bb.flip();\n-                long startingEntryId = position / LedgerEntryPage.getIndexEntrySize();\n-                for (int i = entriesPerPage - 1; i >= 0; i--) {\n-                    if (bb.getLong(i * LedgerEntryPage.getIndexEntrySize()) != 0) {\n-                        if (lastEntry < startingEntryId + i) {\n-                            lastEntry = startingEntryId + i;\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-        } finally {\n-            if (fi != null) {\n-                fi.release();\n-            }\n-        }\n-        return lastEntry;\n-    }\n-\n-}"},{"sha":"1a69692207b6b1a65a8590a99fa8596febd3e81c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"removed","additions":0,"deletions":352,"changes":352,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,352 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n-import org.apache.bookkeeper.bookie.EntryLogger.EntryLogListener;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.jmx.BKMBeanInfo;\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.apache.bookkeeper.util.SnapshotMap;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.STORAGE_GET_ENTRY;\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.STORAGE_GET_OFFSET;\n-\n-/**\n- * Interleave ledger storage\n- * This ledger storage implementation stores all entries in a single\n- * file and maintains an index file for each ledger.\n- */\n-class InterleavedLedgerStorage implements LedgerStorage, EntryLogListener {\n-    private final static Logger LOG = LoggerFactory.getLogger(InterleavedLedgerStorage.class);\n-\n-    // Hold the last checkpoint\n-    protected static class CheckpointHolder {\n-        Checkpoint lastCheckpoint = Checkpoint.MAX;\n-\n-        protected synchronized void setNextCheckpoint(Checkpoint cp) {\n-            if (Checkpoint.MAX.equals(lastCheckpoint) || lastCheckpoint.compareTo(cp) < 0) {\n-                lastCheckpoint = cp;\n-            }\n-        }\n-\n-        protected synchronized void clearLastCheckpoint(Checkpoint done) {\n-            if (0 == lastCheckpoint.compareTo(done)) {\n-                lastCheckpoint = Checkpoint.MAX;\n-            }\n-        }\n-\n-        protected synchronized Checkpoint getLastCheckpoint() {\n-            return lastCheckpoint;\n-        }\n-    }\n-\n-    EntryLogger entryLogger;\n-    LedgerCache ledgerCache;\n-    private final CheckpointSource checkpointSource;\n-    protected final CheckpointHolder checkpointHolder = new CheckpointHolder();\n-\n-    // A sorted map to stored all active ledger ids\n-    protected final SnapshotMap<Long, Boolean> activeLedgers;\n-\n-    // This is the thread that garbage collects the entry logs that do not\n-    // contain any active ledgers in them; and compacts the entry logs that\n-    // has lower remaining percentage to reclaim disk space.\n-    final GarbageCollectorThread gcThread;\n-\n-    // this indicates that a write has happened since the last flush\n-    private volatile boolean somethingWritten = false;\n-\n-    // Expose Stats\n-    private final OpStatsLogger getOffsetStats;\n-    private final OpStatsLogger getEntryStats;\n-\n-    InterleavedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n-                             LedgerDirsManager ledgerDirsManager, CheckpointSource checkpointSource)\n-            throws IOException {\n-        this(conf, ledgerManager, ledgerDirsManager, ledgerDirsManager, checkpointSource, NullStatsLogger.INSTANCE);\n-    }\n-\n-    InterleavedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n-                             LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n-                             CheckpointSource checkpointSource, StatsLogger statsLogger)\n-            throws IOException {\n-        activeLedgers = new SnapshotMap<Long, Boolean>();\n-        this.checkpointSource = checkpointSource;\n-        entryLogger = new EntryLogger(conf, ledgerDirsManager, this);\n-        ledgerCache = new LedgerCacheImpl(conf, activeLedgers,\n-                null == indexDirsManager ? ledgerDirsManager : indexDirsManager, statsLogger);\n-        gcThread = new GarbageCollectorThread(conf, ledgerCache, entryLogger,\n-                activeLedgers, ledgerManager);\n-        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n-        // Expose Stats\n-        getOffsetStats = statsLogger.getOpStatsLogger(STORAGE_GET_OFFSET);\n-        getEntryStats = statsLogger.getOpStatsLogger(STORAGE_GET_ENTRY);\n-    }\n-\n-    private LedgerDirsListener getLedgerDirsListener() {\n-        return new LedgerDirsListener() {\n-            @Override\n-            public void diskFailed(File disk) {\n-                // do nothing.\n-            }\n-\n-            @Override\n-            public void diskAlmostFull(File disk) {\n-                gcThread.enableForceGC();\n-            }\n-\n-            @Override\n-            public void diskFull(File disk) {\n-                gcThread.enableForceGC();\n-            }\n-\n-            @Override\n-            public void allDisksFull() {\n-                gcThread.enableForceGC();\n-            }\n-\n-            @Override\n-            public void fatalError() {\n-                // do nothing.\n-            }\n-\n-            @Override\n-            public void diskWritable(File disk) {\n-                // we have enough space now, disable force gc.\n-                gcThread.disableForceGC();\n-            }\n-\n-            @Override\n-            public void diskJustWritable(File disk) {\n-                // if a disk is just writable, we still need force gc.\n-                gcThread.enableForceGC();\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public void start() {\n-        gcThread.start();\n-    }\n-\n-    @Override\n-    public void shutdown() throws InterruptedException {\n-        // shut down gc thread, which depends on zookeeper client\n-        // also compaction will write entries again to entry log file\n-        LOG.info(\"Shutting down InterleavedLedgerStorage\");\n-        gcThread.shutdown();\n-        entryLogger.shutdown();\n-        try {\n-            ledgerCache.close();\n-        } catch (IOException e) {\n-            LOG.error(\"Error while closing the ledger cache\", e);\n-        }\n-    }\n-\n-    @Override\n-    public boolean setFenced(long ledgerId) throws IOException {\n-        return ledgerCache.setFenced(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean isFenced(long ledgerId) throws IOException {\n-        return ledgerCache.isFenced(ledgerId);\n-    }\n-\n-    @Override\n-    public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n-        ledgerCache.setMasterKey(ledgerId, masterKey);\n-    }\n-\n-    @Override\n-    public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n-        return ledgerCache.readMasterKey(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean ledgerExists(long ledgerId) throws IOException {\n-        return ledgerCache.ledgerExists(ledgerId);\n-    }\n-\n-    @Override\n-    synchronized public long addEntry(ByteBuffer entry) throws IOException {\n-        long ledgerId = entry.getLong();\n-        long entryId = entry.getLong();\n-        entry.rewind();\n-\n-        processEntry(ledgerId, entryId, entry);\n-\n-        return entryId;\n-    }\n-\n-    @Override\n-    public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n-        long offset;\n-        /*\n-         * If entryId is BookieProtocol.LAST_ADD_CONFIRMED, then return the last written.\n-         */\n-        if (entryId == BookieProtocol.LAST_ADD_CONFIRMED) {\n-            entryId = ledgerCache.getLastEntry(ledgerId);\n-        }\n-\n-        // Get Offset\n-        long startTimeNanos = MathUtils.nowInNano();\n-        boolean success = false;\n-        try {\n-            offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n-            if (offset == 0) {\n-                throw new Bookie.NoEntryException(ledgerId, entryId);\n-            }\n-            success = true;\n-        } finally {\n-            if (success) {\n-                getOffsetStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            } else {\n-                getOffsetStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            }\n-        }\n-        // Get Entry\n-        startTimeNanos = MathUtils.nowInNano();\n-        success = false;\n-        try {\n-            byte[] retBytes = entryLogger.readEntry(ledgerId, entryId, offset);\n-            success = true;\n-            return ByteBuffer.wrap(retBytes);\n-        } finally {\n-            if (success) {\n-                getEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            } else {\n-                getEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n-            }\n-        }\n-    }\n-\n-    private void flushOrCheckpoint(boolean isCheckpointFlush)\n-            throws IOException {\n-\n-        boolean flushFailed = false;\n-        try {\n-            ledgerCache.flushLedger(true);\n-        } catch (LedgerDirsManager.NoWritableLedgerDirException e) {\n-            throw e;\n-        } catch (IOException ioe) {\n-            LOG.error(\"Exception flushing Ledger cache\", ioe);\n-            flushFailed = true;\n-        }\n-\n-        try {\n-            // if it is just a checkpoint flush, we just flush rotated entry log files\n-            // in entry logger.\n-            if (isCheckpointFlush) {\n-                entryLogger.checkpoint();\n-            } else {\n-                entryLogger.flush();\n-            }\n-        } catch (LedgerDirsManager.NoWritableLedgerDirException e) {\n-            throw e;\n-        } catch (IOException ioe) {\n-            LOG.error(\"Exception flushing Ledger\", ioe);\n-            flushFailed = true;\n-        }\n-        if (flushFailed) {\n-            throw new IOException(\"Flushing to storage failed, check logs\");\n-        }\n-    }\n-\n-    @Override\n-    public Checkpoint checkpoint(Checkpoint checkpoint) throws IOException {\n-        Checkpoint lastCheckpoint = checkpointHolder.getLastCheckpoint();\n-        // if checkpoint is less than last checkpoint, we don't need to do checkpoint again.\n-        if (lastCheckpoint.compareTo(checkpoint) > 0) {\n-            return lastCheckpoint;\n-        }\n-        // we don't need to check somethingwritten since checkpoint\n-        // is scheduled when rotate an entry logger file. and we could\n-        // not set somethingWritten to false after checkpoint, since\n-        // current entry logger file isn't flushed yet.\n-        flushOrCheckpoint(true);\n-        // after the ledger storage finished checkpointing, try to clear the done checkpoint\n-\n-        checkpointHolder.clearLastCheckpoint(lastCheckpoint);\n-        return lastCheckpoint;\n-    }\n-\n-    @Override\n-    synchronized public void flush() throws IOException {\n-        if (!somethingWritten) {\n-            return;\n-        }\n-        somethingWritten = false;\n-        flushOrCheckpoint(false);\n-    }\n-\n-    @Override\n-    public BKMBeanInfo getJMXBean() {\n-        return ledgerCache.getJMXBean();\n-    }\n-\n-    protected void processEntry(long ledgerId, long entryId, ByteBuffer entry) throws IOException {\n-        processEntry(ledgerId, entryId, entry, true);\n-    }\n-\n-    synchronized protected void processEntry(long ledgerId, long entryId, ByteBuffer entry, boolean rollLog)\n-            throws IOException {\n-        /*\n-         * Touch dirty flag\n-         */\n-        somethingWritten = true;\n-\n-        /*\n-         * Log the entry\n-         */\n-        long pos = entryLogger.addEntry(ledgerId, entry, rollLog);\n-\n-        /*\n-         * Set offset of entry id to be the current ledger position\n-         */\n-        ledgerCache.putEntryOffset(ledgerId, entryId, pos);\n-    }\n-\n-    @Override\n-    public void onRotateEntryLog() {\n-        // for interleaved ledger storage, we request a checkpoint when rotating a entry log file.\n-        // the checkpoint represent the point that all the entries added before this point are already\n-        // in ledger storage and ready to be synced to disk.\n-        // TODO: we could consider remove checkpointSource and checkpointSouce#newCheckpoint\n-        // later if we provide kind of LSN (Log/Journal Squeuence Number)\n-        // mechanism when adding entry.\n-        checkpointHolder.setNextCheckpoint(checkpointSource.newCheckpoint());\n-    }\n-}"},{"sha":"ad48386ca666eb7fbde98f469ad0edd5801e6935","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"removed","additions":0,"deletions":973,"changes":973,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,973 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.google.common.base.Stopwatch;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.DaemonThreadFactory;\n-import org.apache.bookkeeper.util.IOUtils;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.apache.bookkeeper.util.ZeroBuffer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.*;\n-\n-/**\n- * Provide journal related management.\n- */\n-class Journal extends BookieCriticalThread implements CheckpointSource {\n-\n-    private final static Logger LOG = LoggerFactory.getLogger(Journal.class);\n-\n-    /**\n-     * Filter to pickup journals\n-     */\n-    private static interface JournalIdFilter {\n-        public boolean accept(long journalId);\n-    }\n-\n-    /**\n-     * List all journal ids by a specified journal id filer\n-     *\n-     * @param journalDir journal dir\n-     * @param filter journal id filter\n-     * @return list of filtered ids\n-     */\n-    private static List<Long> listJournalIds(File journalDir, JournalIdFilter filter) {\n-        File logFiles[] = journalDir.listFiles();\n-        List<Long> logs = new ArrayList<Long>();\n-        for(File f: logFiles) {\n-            String name = f.getName();\n-            if (!name.endsWith(\".txn\")) {\n-                continue;\n-            }\n-            String idString = name.split(\"\\\\.\")[0];\n-            long id = Long.parseLong(idString, 16);\n-            if (filter != null) {\n-                if (filter.accept(id)) {\n-                    logs.add(id);\n-                }\n-            } else {\n-                logs.add(id);\n-            }\n-        }\n-        Collections.sort(logs);\n-        return logs;\n-    }\n-\n-    /**\n-     * A wrapper over log mark to provide a checkpoint for users of journal\n-     * to do checkpointing.\n-     */\n-    private static class LogMarkCheckpoint implements Checkpoint {\n-        final LastLogMark mark;\n-\n-        public LogMarkCheckpoint(LastLogMark checkpoint) {\n-            this.mark = checkpoint;\n-        }\n-\n-        @Override\n-        public int compareTo(Checkpoint o) {\n-            if (o == Checkpoint.MAX) {\n-                return -1;\n-            } else if (o == Checkpoint.MIN) {\n-                return 1;\n-            }\n-            return mark.getCurMark().compare(((LogMarkCheckpoint)o).mark.getCurMark());\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (!(o instanceof LogMarkCheckpoint)) {\n-                return false;\n-            }\n-            return 0 == compareTo((LogMarkCheckpoint)o);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return mark.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return mark.toString();\n-        }\n-    }\n-\n-    /**\n-     * Last Log Mark\n-     */\n-    class LastLogMark {\n-        private final LogMark curMark;\n-\n-        LastLogMark(long logId, long logPosition) {\n-            this.curMark = new LogMark(logId, logPosition);\n-        }\n-\n-        void setCurLogMark(long logId, long logPosition) {\n-            curMark.setLogMark(logId, logPosition);\n-        }\n-\n-        LastLogMark markLog() {\n-            return new LastLogMark(curMark.getLogFileId(), curMark.getLogFileOffset());\n-        }\n-\n-        LogMark getCurMark() {\n-            return curMark;\n-        }\n-\n-        void rollLog(LastLogMark lastMark) throws NoWritableLedgerDirException {\n-            byte buff[] = new byte[16];\n-            ByteBuffer bb = ByteBuffer.wrap(buff);\n-            // we should record <logId, logPosition> marked in markLog\n-            // which is safe since records before lastMark have been\n-            // persisted to disk (both index & entry logger)\n-            lastMark.getCurMark().writeLogMark(bb);\n-            LOG.debug(\"RollLog to persist last marked log : {}\", lastMark.getCurMark());\n-            List<File> writableLedgerDirs = ledgerDirsManager\n-                    .getWritableLedgerDirs();\n-            for (File dir : writableLedgerDirs) {\n-                File file = new File(dir, \"lastMark\");\n-                FileOutputStream fos = null;\n-                try {\n-                    fos = new FileOutputStream(file);\n-                    fos.write(buff);\n-                    fos.getChannel().force(true);\n-                    fos.close();\n-                    fos = null;\n-                } catch (IOException e) {\n-                    LOG.error(\"Problems writing to \" + file, e);\n-                } finally {\n-                    // if stream already closed in try block successfully,\n-                    // stream might have nullified, in such case below\n-                    // call will simply returns\n-                    IOUtils.close(LOG, fos);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Read last mark from lastMark file.\n-         * The last mark should first be max journal log id,\n-         * and then max log position in max journal log.\n-         */\n-        void readLog() {\n-            byte buff[] = new byte[16];\n-            ByteBuffer bb = ByteBuffer.wrap(buff);\n-            LogMark mark = new LogMark();\n-            for(File dir: ledgerDirsManager.getAllLedgerDirs()) {\n-                File file = new File(dir, \"lastMark\");\n-                try {\n-                    FileInputStream fis = new FileInputStream(file);\n-                    try {\n-                        int bytesRead = fis.read(buff);\n-                        if (bytesRead != 16) {\n-                            throw new IOException(\"Couldn't read enough bytes from lastMark.\"\n-                                                  + \" Wanted \" + 16 + \", got \" + bytesRead);\n-                        }\n-                    } finally {\n-                        fis.close();\n-                    }\n-                    bb.clear();\n-                    mark.readLogMark(bb);\n-                    if (curMark.compare(mark) < 0) {\n-                        curMark.setLogMark(mark.getLogFileId(), mark.getLogFileOffset());\n-                    }\n-                } catch (IOException e) {\n-                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return curMark.toString();\n-        }\n-    }\n-\n-    /**\n-     * Filter to return list of journals for rolling\n-     */\n-    private static class JournalRollingFilter implements JournalIdFilter {\n-\n-        final LastLogMark lastMark;\n-\n-        JournalRollingFilter(LastLogMark lastMark) {\n-            this.lastMark = lastMark;\n-        }\n-\n-        @Override\n-        public boolean accept(long journalId) {\n-            if (journalId < lastMark.getCurMark().getLogFileId()) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Scanner used to scan a journal\n-     */\n-    public static interface JournalScanner {\n-        /**\n-         * Process a journal entry.\n-         *\n-         * @param journalVersion\n-         *          Journal Version\n-         * @param offset\n-         *          File offset of the journal entry\n-         * @param entry\n-         *          Journal Entry\n-         * @throws IOException\n-         */\n-        public void process(int journalVersion, long offset, ByteBuffer entry) throws IOException;\n-    }\n-\n-    /**\n-     * Journal Entry to Record\n-     */\n-    private static class QueueEntry {\n-        ByteBuffer entry;\n-        long ledgerId;\n-        long entryId;\n-        WriteCallback cb;\n-        Object ctx;\n-        long enqueueTime;\n-\n-        QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n-                   WriteCallback cb, Object ctx, long enqueueTime) {\n-            this.entry = entry.duplicate();\n-            this.cb = cb;\n-            this.ctx = ctx;\n-            this.ledgerId = ledgerId;\n-            this.entryId = entryId;\n-            this.enqueueTime = enqueueTime;\n-        }\n-\n-        public void callback() {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Acknowledge Ledger: {}, Entry: {}\", ledgerId, entryId);\n-            }\n-            cb.writeComplete(0, ledgerId, entryId, null, ctx);\n-        }\n-    }\n-\n-    private class ForceWriteRequest implements Runnable {\n-        private final JournalChannel logFile;\n-        private final LinkedList<QueueEntry> forceWriteWaiters;\n-        private boolean shouldClose;\n-        private final boolean isMarker;\n-        private final long lastFlushedPosition;\n-        private final long logId;\n-\n-        private ForceWriteRequest(JournalChannel logFile,\n-                          long logId,\n-                          long lastFlushedPosition,\n-                          LinkedList<QueueEntry> forceWriteWaiters,\n-                          boolean shouldClose,\n-                          boolean isMarker) {\n-            this.forceWriteWaiters = forceWriteWaiters;\n-            this.logFile = logFile;\n-            this.logId = logId;\n-            this.lastFlushedPosition = lastFlushedPosition;\n-            this.shouldClose = shouldClose;\n-            this.isMarker = isMarker;\n-            forceWriteQueueSize.inc();\n-        }\n-\n-        public int process(boolean shouldForceWrite) throws IOException {\n-            forceWriteQueueSize.dec();\n-            if (isMarker) {\n-                return 0;\n-            }\n-\n-            try {\n-                if (shouldForceWrite) {\n-                    this.logFile.forceWrite(false);\n-                }\n-                lastLogMark.setCurLogMark(this.logId, this.lastFlushedPosition);\n-\n-                // Notify the waiters that the force write succeeded\n-                cbThreadPool.submit(this);\n-\n-                return this.forceWriteWaiters.size();\n-            }\n-            finally {\n-                closeFileIfNecessary();\n-            }\n-        }\n-\n-        @Override\n-        public void run() {\n-            for (QueueEntry e : this.forceWriteWaiters) {\n-                journalAddEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(e.enqueueTime));\n-                e.callback();    // Process cbs inline\n-            }\n-        }\n-\n-        public void closeFileIfNecessary() {\n-            // Close if shouldClose is set\n-            if (shouldClose) {\n-                // We should guard against exceptions so its\n-                // safe to call in catch blocks\n-                try {\n-                    logFile.close();\n-                    // Call close only once\n-                    shouldClose = false;\n-                }\n-                catch (IOException ioe) {\n-                    LOG.error(\"I/O exception while closing file\", ioe);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * ForceWriteThread is a background thread which makes the journal durable periodically\n-     *\n-     */\n-    private class ForceWriteThread extends BookieCriticalThread {\n-        volatile boolean running = true;\n-        // This holds the queue entries that should be notified after a\n-        // successful force write\n-        Thread threadToNotifyOnEx;\n-        // should we group force writes\n-        private final boolean enableGroupForceWrites;\n-        // make flush interval as a parameter\n-        public ForceWriteThread(Thread threadToNotifyOnEx, boolean enableGroupForceWrites) {\n-            super(\"ForceWriteThread\");\n-            this.threadToNotifyOnEx = threadToNotifyOnEx;\n-            this.enableGroupForceWrites = enableGroupForceWrites;\n-        }\n-        @Override\n-        public void run() {\n-            LOG.info(\"ForceWrite Thread started\");\n-            boolean shouldForceWrite = true;\n-            int numReqInLastForceWrite = 0;\n-            while(running) {\n-                ForceWriteRequest req = null;\n-                try {\n-                    req = forceWriteRequests.take();\n-\n-                    // Force write the file and then notify the write completions\n-                    //\n-                    if (!req.isMarker) {\n-                        if (shouldForceWrite) {\n-                            // if we are going to force write, any request that is already in the\n-                            // queue will benefit from this force write - post a marker prior to issuing\n-                            // the flush so until this marker is encountered we can skip the force write\n-                            if (enableGroupForceWrites) {\n-                                forceWriteRequests.put(new ForceWriteRequest(req.logFile, 0, 0, null, false, true));\n-                            }\n-\n-                            // If we are about to issue a write, record the number of requests in\n-                            // the last force write and then reset the counter so we can accumulate\n-                            // requests in the write we are about to issue\n-                            if (numReqInLastForceWrite > 0) {\n-                                forceWriteGroupingCountStats.registerSuccessfulEvent(numReqInLastForceWrite);\n-                                numReqInLastForceWrite = 0;\n-                            }\n-                        }\n-                        numReqInLastForceWrite += req.process(shouldForceWrite);\n-                    }\n-\n-                    if (enableGroupForceWrites &&\n-                        // if its a marker we should switch back to flushing\n-                        !req.isMarker &&\n-                        // This indicates that this is the last request in a given file\n-                        // so subsequent requests will go to a different file so we should\n-                        // flush on the next request\n-                        !req.shouldClose) {\n-                        shouldForceWrite = false;\n-                    }\n-                    else {\n-                        shouldForceWrite = true;\n-                    }\n-                } catch (IOException ioe) {\n-                    LOG.error(\"I/O exception in ForceWrite thread\", ioe);\n-                    running = false;\n-                } catch (InterruptedException e) {\n-                    LOG.error(\"ForceWrite thread interrupted\", e);\n-                    // close is idempotent\n-                    if (null != req) {\n-                        req.closeFileIfNecessary();\n-                    }\n-                    running = false;\n-                }\n-            }\n-            // Regardless of what caused us to exit, we should notify the\n-            // the parent thread as it should either exit or be in the process\n-            // of exiting else we will have write requests hang\n-            threadToNotifyOnEx.interrupt();\n-        }\n-        // shutdown sync thread\n-        void shutdown() throws InterruptedException {\n-            running = false;\n-            this.interrupt();\n-            this.join();\n-        }\n-    }\n-\n-    final static int PADDING_MASK = -0x100;\n-\n-    static void writePaddingBytes(JournalChannel jc, ByteBuffer paddingBuffer, int journalAlignSize)\n-            throws IOException {\n-        int bytesToAlign = (int) (jc.bc.position() % journalAlignSize);\n-        if (0 != bytesToAlign) {\n-            int paddingBytes = journalAlignSize - bytesToAlign;\n-            if (paddingBytes < 8) {\n-                paddingBytes = journalAlignSize - (8 - paddingBytes);\n-            } else {\n-                paddingBytes -= 8;\n-            }\n-            paddingBuffer.clear();\n-            // padding mask\n-            paddingBuffer.putInt(PADDING_MASK);\n-            // padding len\n-            paddingBuffer.putInt(paddingBytes);\n-            // padding bytes\n-            paddingBuffer.position(8 + paddingBytes);\n-\n-            paddingBuffer.flip();\n-            jc.preAllocIfNeeded(paddingBuffer.limit());\n-            // write padding bytes\n-            jc.bc.write(paddingBuffer);\n-        }\n-    }\n-\n-    final static long MB = 1024 * 1024L;\n-    final static int KB = 1024;\n-    // max journal file size\n-    final long maxJournalSize;\n-    // pre-allocation size for the journal files\n-    final long journalPreAllocSize;\n-    // write buffer size for the journal files\n-    final int journalWriteBufferSize;\n-    // number journal files kept before marked journal\n-    final int maxBackupJournals;\n-\n-    final File journalDirectory;\n-    final ServerConfiguration conf;\n-    final ForceWriteThread forceWriteThread;\n-    // Time after which we will stop grouping and issue the flush\n-    private final long maxGroupWaitInMSec;\n-    // Threshold after which we flush any buffered journal entries\n-    private final long bufferedEntriesThreshold;\n-    // Threshold after which we flush any buffered journal writes\n-    private final long bufferedWritesThreshold;\n-    // should we flush if the queue is empty\n-    private final boolean flushWhenQueueEmpty;\n-    // should we hint the filesystem to remove pages from cache after force write\n-    private final boolean removePagesFromCache;\n-\n-    private final LastLogMark lastLogMark = new LastLogMark(0, 0);\n-\n-    /**\n-     * The thread pool used to handle callback.\n-     */\n-    private final ExecutorService cbThreadPool;\n-\n-    // journal entry queue to commit\n-    final LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n-    final LinkedBlockingQueue<ForceWriteRequest> forceWriteRequests = new LinkedBlockingQueue<ForceWriteRequest>();\n-\n-    volatile boolean running = true;\n-    private final LedgerDirsManager ledgerDirsManager;\n-\n-    // Expose Stats\n-    private final OpStatsLogger journalAddEntryStats;\n-    private final OpStatsLogger journalCreationStats;\n-    private final OpStatsLogger journalFlushStats;\n-    private final OpStatsLogger forceWriteGroupingCountStats;\n-    private final OpStatsLogger forceWriteBatchEntriesStats;\n-    private final OpStatsLogger forceWriteBatchBytesStats;\n-    private final Counter journalQueueSize;\n-    private final Counter forceWriteQueueSize;\n-    private final Counter flushMaxWaitCounter;\n-    private final Counter flushMaxOutstandingBytesCounter;\n-    private final Counter flushEmptyQueueCounter;\n-    private final Counter journalWriteBytes;\n-\n-    public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager) {\n-        this(conf, ledgerDirsManager, NullStatsLogger.INSTANCE);\n-    }\n-\n-    public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager, StatsLogger statsLogger) {\n-        super(\"BookieJournal-\" + conf.getBookiePort());\n-        this.ledgerDirsManager = ledgerDirsManager;\n-        this.conf = conf;\n-        this.journalDirectory = Bookie.getCurrentDirectory(conf.getJournalDir());\n-        this.maxJournalSize = conf.getMaxJournalSizeMB() * MB;\n-        this.journalPreAllocSize = conf.getJournalPreAllocSizeMB() * MB;\n-        this.journalWriteBufferSize = conf.getJournalWriteBufferSizeKB() * KB;\n-        this.maxBackupJournals = conf.getMaxBackupJournals();\n-        this.forceWriteThread = new ForceWriteThread(this, conf.getJournalAdaptiveGroupWrites());\n-        this.maxGroupWaitInMSec = conf.getJournalMaxGroupWaitMSec();\n-        this.bufferedWritesThreshold = conf.getJournalBufferedWritesThreshold();\n-        this.bufferedEntriesThreshold = conf.getJournalBufferedEntriesThreshold();\n-        this.cbThreadPool = Executors.newFixedThreadPool(conf.getNumJournalCallbackThreads(),\n-                                                         new DaemonThreadFactory());\n-\n-        // Unless there is a cap on the max wait (which requires group force writes)\n-        // we cannot skip flushing for queue empty\n-        this.flushWhenQueueEmpty = maxGroupWaitInMSec <= 0 || conf.getJournalFlushWhenQueueEmpty();\n-\n-        this.removePagesFromCache = conf.getJournalRemovePagesFromCache();\n-        // read last log mark\n-        lastLogMark.readLog();\n-        LOG.debug(\"Last Log Mark : {}\", lastLogMark.getCurMark());\n-\n-        // Expose Stats\n-        journalAddEntryStats = statsLogger.getOpStatsLogger(JOURNAL_ADD_ENTRY);\n-        journalCreationStats = statsLogger.getOpStatsLogger(JOURNAL_CREATION_LATENCY);\n-        journalFlushStats = statsLogger.getOpStatsLogger(JOURNAL_FLUSH_LATENCY);\n-        forceWriteGroupingCountStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_GROUPING_COUNT);\n-        forceWriteBatchEntriesStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_BATCH_ENTRIES);\n-        forceWriteBatchBytesStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_BATCH_BYTES);\n-        journalQueueSize = statsLogger.getCounter(JOURNAL_QUEUE_SIZE);\n-        forceWriteQueueSize = statsLogger.getCounter(JOURNAL_FORCE_WRITE_QUEUE_SIZE);\n-        flushMaxWaitCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_MAX_WAIT);\n-        flushMaxOutstandingBytesCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES);\n-        flushEmptyQueueCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_EMPTY_QUEUE);\n-        journalWriteBytes = statsLogger.getCounter(JOURNAL_WRITE_BYTES);\n-    }\n-\n-    LastLogMark getLastLogMark() {\n-        return lastLogMark;\n-    }\n-\n-    /**\n-     * Application tried to schedule a checkpoint. After all the txns added\n-     * before checkpoint are persisted, a <i>checkpoint</i> will be returned\n-     * to application. Application could use <i>checkpoint</i> to do its logic.\n-     */\n-    @Override\n-    public Checkpoint newCheckpoint() {\n-        return new LogMarkCheckpoint(lastLogMark.markLog());\n-    }\n-\n-    /**\n-     * Telling journal a checkpoint is finished.\n-     *\n-     * @throws IOException\n-     */\n-    @Override\n-    public void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IOException {\n-        if (!(checkpoint instanceof LogMarkCheckpoint)) {\n-            return; // we didn't create this checkpoint, so dont do anything with it\n-        }\n-        LogMarkCheckpoint lmcheckpoint = (LogMarkCheckpoint)checkpoint;\n-        LastLogMark mark = lmcheckpoint.mark;\n-\n-        mark.rollLog(mark);\n-        if (compact) {\n-            // list the journals that have been marked\n-            List<Long> logs = listJournalIds(journalDirectory, new JournalRollingFilter(mark));\n-            // keep MAX_BACKUP_JOURNALS journal files before marked journal\n-            if (logs.size() >= maxBackupJournals) {\n-                int maxIdx = logs.size() - maxBackupJournals;\n-                for (int i=0; i<maxIdx; i++) {\n-                    long id = logs.get(i);\n-                    // make sure the journal id is smaller than marked journal id\n-                    if (id < mark.getCurMark().getLogFileId()) {\n-                        File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n-                        if (!journalFile.delete()) {\n-                            LOG.warn(\"Could not delete old journal file {}\", journalFile);\n-                        }\n-                        LOG.info(\"garbage collected journal \" + journalFile.getName());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Scan the journal\n-     *\n-     * @param journalId\n-     *          Journal Log Id\n-     * @param journalPos\n-     *          Offset to start scanning\n-     * @param scanner\n-     *          Scanner to handle entries\n-     * @throws IOException\n-     */\n-    public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n-        throws IOException {\n-        JournalChannel recLog;\n-        if (journalPos <= 0) {\n-            recLog = new JournalChannel(journalDirectory, journalId, journalPreAllocSize, journalWriteBufferSize);\n-        } else {\n-            recLog = new JournalChannel(journalDirectory, journalId, journalPreAllocSize, journalWriteBufferSize, journalPos);\n-        }\n-        int journalVersion = recLog.getFormatVersion();\n-        try {\n-            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n-            while(true) {\n-                // entry start offset\n-                long offset = recLog.fc.position();\n-                // start reading entry\n-                lenBuff.clear();\n-                fullRead(recLog, lenBuff);\n-                if (lenBuff.remaining() != 0) {\n-                    break;\n-                }\n-                lenBuff.flip();\n-                int len = lenBuff.getInt();\n-                if (len == 0) {\n-                    break;\n-                }\n-                boolean isPaddingRecord = false;\n-                if (len == PADDING_MASK) {\n-                    if (journalVersion >= JournalChannel.V5) {\n-                        // skip padding bytes\n-                        lenBuff.clear();\n-                        fullRead(recLog, lenBuff);\n-                        if (lenBuff.remaining() != 0) {\n-                            break;\n-                        }\n-                        lenBuff.flip();\n-                        len = lenBuff.getInt();\n-                        if (len == 0) {\n-                            continue;\n-                        }\n-                        isPaddingRecord = true;\n-                    } else {\n-                        throw new IOException(\"Invalid record found with negative length : \" + len);\n-                    }\n-                }\n-                recBuff.clear();\n-                if (recBuff.remaining() < len) {\n-                    recBuff = ByteBuffer.allocate(len);\n-                }\n-                recBuff.limit(len);\n-                if (fullRead(recLog, recBuff) != len) {\n-                    // This seems scary, but it just means that this is where we\n-                    // left off writing\n-                    break;\n-                }\n-                recBuff.flip();\n-                if (!isPaddingRecord) {\n-                    scanner.process(journalVersion, offset, recBuff);\n-                }\n-            }\n-        } finally {\n-            recLog.close();\n-        }\n-    }\n-\n-    /**\n-     * Replay journal files\n-     *\n-     * @param scanner\n-     *          Scanner to process replayed entries.\n-     * @throws IOException\n-     */\n-    public void replay(JournalScanner scanner) throws IOException {\n-        final LogMark markedLog = lastLogMark.getCurMark();\n-        List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n-            @Override\n-            public boolean accept(long journalId) {\n-                if (journalId < markedLog.getLogFileId()) {\n-                    return false;\n-                }\n-                return true;\n-            }\n-        });\n-        // last log mark may be missed due to no sync up before\n-        // validate filtered log ids only when we have markedLogId\n-        if (markedLog.getLogFileId() > 0) {\n-            if (logs.size() == 0 || logs.get(0) != markedLog.getLogFileId()) {\n-                throw new IOException(\"Recovery log \" + markedLog.getLogFileId() + \" is missing\");\n-            }\n-        }\n-        LOG.debug(\"Try to relay journal logs : {}\", logs);\n-        // TODO: When reading in the journal logs that need to be synced, we\n-        // should use BufferedChannels instead to minimize the amount of\n-        // system calls done.\n-        for(Long id: logs) {\n-            long logPosition = 0L;\n-            if(id == markedLog.getLogFileId()) {\n-                logPosition = markedLog.getLogFileOffset();\n-            }\n-            LOG.info(\"Replaying journal {} from position {}\", id, logPosition);\n-            scanJournal(id, logPosition, scanner);\n-        }\n-    }\n-\n-    /**\n-     * record an add entry operation in journal\n-     */\n-    public void logAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx) {\n-        long ledgerId = entry.getLong();\n-        long entryId = entry.getLong();\n-        entry.rewind();\n-        journalQueueSize.inc();\n-        queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx, MathUtils.nowInNano()));\n-    }\n-\n-    /**\n-     * Get the length of journal entries queue.\n-     *\n-     * @return length of journal entry queue.\n-     */\n-    public int getJournalQueueLength() {\n-        return queue.size();\n-    }\n-\n-    /**\n-     * A thread used for persisting journal entries to journal files.\n-     *\n-     * <p>\n-     * Besides persisting journal entries, it also takes responsibility of\n-     * rolling journal files when a journal file reaches journal file size\n-     * limitation.\n-     * </p>\n-     * <p>\n-     * During journal rolling, it first closes the writing journal, generates\n-     * new journal file using current timestamp, and continue persistence logic.\n-     * Those journals will be garbage collected in SyncThread.\n-     * </p>\n-     * @see org.apache.bookkeeper.bookie.SyncThread\n-     */\n-    @Override\n-    public void run() {\n-        LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n-        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-        ByteBuffer paddingBuff = ByteBuffer.allocate(2 * conf.getJournalAlignmentSize());\n-        ZeroBuffer.put(paddingBuff);\n-        JournalChannel logFile = null;\n-        forceWriteThread.start();\n-        Stopwatch journalCreationWatcher = new Stopwatch();\n-        Stopwatch journalFlushWatcher = new Stopwatch();\n-        long batchSize = 0;\n-        try {\n-            List<Long> journalIds = listJournalIds(journalDirectory, null);\n-            // Should not use MathUtils.now(), which use System.nanoTime() and\n-            // could only be used to measure elapsed time.\n-            // http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/System.html#nanoTime%28%29\n-            long logId = journalIds.isEmpty() ? System.currentTimeMillis() : journalIds.get(journalIds.size() - 1);\n-            BufferedChannel bc = null;\n-            long lastFlushPosition = 0;\n-            boolean groupWhenTimeout = false;\n-\n-            QueueEntry qe = null;\n-            while (true) {\n-                // new journal file to write\n-                if (null == logFile) {\n-                    logId = logId + 1;\n-\n-                    journalCreationWatcher.reset().start();\n-                    logFile = new JournalChannel(journalDirectory,\n-                                        logId,\n-                                        journalPreAllocSize,\n-                                        journalWriteBufferSize,\n-                                        conf.getJournalAlignmentSize(),\n-                                        removePagesFromCache,\n-                                        conf.getJournalFormatVersionToWrite());\n-                    journalCreationStats.registerSuccessfulEvent(\n-                            journalCreationWatcher.stop().elapsedTime(TimeUnit.MILLISECONDS));\n-\n-                    bc = logFile.getBufferedChannel();\n-\n-                    lastFlushPosition = bc.position();\n-                }\n-\n-                if (qe == null) {\n-                    if (toFlush.isEmpty()) {\n-                        qe = queue.take();\n-                    } else {\n-                        long pollWaitTime = maxGroupWaitInMSec - MathUtils.elapsedMSec(toFlush.getFirst().enqueueTime);\n-                        if (flushWhenQueueEmpty || pollWaitTime < 0) {\n-                            pollWaitTime = 0;\n-                        }\n-                        qe = queue.poll(pollWaitTime, TimeUnit.MILLISECONDS);\n-                        boolean shouldFlush = false;\n-                        // We should issue a forceWrite if any of the three conditions below holds good\n-                        // 1. If the oldest pending entry has been pending for longer than the max wait time\n-                        if (maxGroupWaitInMSec > 0 && !groupWhenTimeout && (MathUtils.elapsedMSec(toFlush.getFirst().enqueueTime) > maxGroupWaitInMSec)) {\n-                            groupWhenTimeout = true;\n-                        } else if (maxGroupWaitInMSec > 0 && groupWhenTimeout && qe != null && MathUtils.elapsedMSec(qe.enqueueTime) < maxGroupWaitInMSec) {\n-                            // when group timeout, it would be better to look forward, as there might be lots of entries already timeout\n-                            // due to a previous slow write (writing to filesystem which impacted by force write).\n-                            // Group those entries in the queue\n-                            // a) already timeout\n-                            // b) limit the number of entries to group\n-                            groupWhenTimeout = false;\n-                            shouldFlush = true;\n-                            flushMaxWaitCounter.inc();\n-                        } else if (qe != null &&\n-                                ((bufferedEntriesThreshold > 0 && toFlush.size() > bufferedEntriesThreshold) ||\n-                                 (bc.position() > lastFlushPosition + bufferedWritesThreshold))) {\n-                            // 2. If we have buffered more than the buffWriteThreshold or bufferedEntriesThreshold\n-                            shouldFlush = true;\n-                            flushMaxOutstandingBytesCounter.inc();\n-                        } else if (qe == null) {\n-                            // We should get here only if we flushWhenQueueEmpty is true else we would wait\n-                            // for timeout that would put is past the maxWait threshold\n-                            // 3. If the queue is empty i.e. no benefit of grouping. This happens when we have one\n-                            // publish at a time - common case in tests.\n-                            shouldFlush = true;\n-                            flushEmptyQueueCounter.inc();\n-                        }\n-\n-                        // toFlush is non null and not empty so should be safe to access getFirst\n-                        if (shouldFlush) {\n-                            if (conf.getJournalFormatVersionToWrite() >= JournalChannel.V5) {\n-                                writePaddingBytes(logFile, paddingBuff, conf.getJournalAlignmentSize());\n-                            }\n-                            journalFlushWatcher.reset().start();\n-                            bc.flush(false);\n-                            lastFlushPosition = bc.position();\n-                            journalFlushStats.registerSuccessfulEvent(\n-                                    journalFlushWatcher.stop().elapsedTime(TimeUnit.MILLISECONDS));\n-\n-                            // Trace the lifetime of entries through persistence\n-                            if (LOG.isDebugEnabled()) {\n-                                for (QueueEntry e : toFlush) {\n-                                    LOG.debug(\"Written and queuing for flush Ledger:\" + e.ledgerId + \" Entry:\" + e.entryId);\n-                                }\n-                            }\n-\n-                            forceWriteBatchEntriesStats.registerSuccessfulEvent(toFlush.size());\n-                            forceWriteBatchBytesStats.registerSuccessfulEvent(batchSize);\n-\n-                            forceWriteRequests.put(new ForceWriteRequest(logFile, logId, lastFlushPosition, toFlush, (lastFlushPosition > maxJournalSize), false));\n-                            toFlush = new LinkedList<QueueEntry>();\n-                            batchSize = 0L;\n-                            // check whether journal file is over file limit\n-                            if (bc.position() > maxJournalSize) {\n-                                logFile = null;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (!running) {\n-                    LOG.info(\"Journal Manager is asked to shut down, quit.\");\n-                    break;\n-                }\n-\n-                if (qe == null) { // no more queue entry\n-                    continue;\n-                }\n-\n-                journalWriteBytes.add(qe.entry.remaining());\n-                journalQueueSize.dec();\n-\n-                batchSize += (4 + qe.entry.remaining());\n-\n-                lenBuff.clear();\n-                lenBuff.putInt(qe.entry.remaining());\n-                lenBuff.flip();\n-\n-                // preAlloc based on size\n-                logFile.preAllocIfNeeded(4 + qe.entry.remaining());\n-\n-                //\n-                // we should be doing the following, but then we run out of\n-                // direct byte buffers\n-                // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n-                bc.write(lenBuff);\n-                bc.write(qe.entry);\n-\n-                toFlush.add(qe);\n-                qe = null;\n-            }\n-            logFile.close();\n-            logFile = null;\n-        } catch (IOException ioe) {\n-            LOG.error(\"I/O exception in Journal thread!\", ioe);\n-        } catch (InterruptedException ie) {\n-            LOG.warn(\"Journal exits when shutting down\", ie);\n-        } finally {\n-            // There could be packets queued for forceWrite on this logFile\n-            // That is fine as this exception is going to anyway take down the\n-            // the bookie. If we execute this as a part of graceful shutdown,\n-            // close will flush the file system cache making any previous\n-            // cached writes durable so this is fine as well.\n-            IOUtils.close(LOG, logFile);\n-        }\n-        LOG.info(\"Journal exited loop!\");\n-    }\n-\n-    /**\n-     * Shuts down the journal.\n-     */\n-    public synchronized void shutdown() {\n-        try {\n-            if (!running) {\n-                return;\n-            }\n-            LOG.info(\"Shutting down Journal\");\n-            forceWriteThread.shutdown();\n-            cbThreadPool.shutdown();\n-            if (!cbThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n-                LOG.warn(\"Couldn't shutdown journal callback thread gracefully. Forcing\");\n-            }\n-            cbThreadPool.shutdownNow();\n-\n-            running = false;\n-            this.interrupt();\n-            this.join();\n-        } catch (InterruptedException ie) {\n-            LOG.warn(\"Interrupted during shutting down journal : \", ie);\n-        }\n-    }\n-\n-    private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException {\n-        int total = 0;\n-        while(bb.remaining() > 0) {\n-            int rc = fc.read(bb);\n-            if (rc <= 0) {\n-                return total;\n-            }\n-            total += rc;\n-        }\n-        return total;\n-    }\n-}"},{"sha":"ad46e5cf3a826d9718ce9382d1c028ce7848fb70","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","status":"removed","additions":0,"deletions":275,"changes":275,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,275 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.Closeable;\n-import java.io.File;\n-import java.io.RandomAccessFile;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-\n-import org.apache.bookkeeper.util.NativeIO;\n-import org.apache.bookkeeper.util.ZeroBuffer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-/**\n- * Simple wrapper around FileChannel to add versioning\n- * information to the file.\n- */\n-class JournalChannel implements Closeable {\n-    private final static Logger LOG = LoggerFactory.getLogger(JournalChannel.class);\n-\n-    final RandomAccessFile randomAccessFile;\n-    final int fd;\n-    final FileChannel fc;\n-    final BufferedChannel bc;\n-    final int formatVersion;\n-    long nextPrealloc = 0;\n-\n-    final byte[] MAGIC_WORD = \"BKLG\".getBytes(UTF_8);\n-\n-    final static int SECTOR_SIZE = 512;\n-    private final static int START_OF_FILE = -12345;\n-    private static long CACHE_DROP_LAG_BYTES = 8 * 1024 * 1024;\n-\n-    // No header\n-    static final int V1 = 1;\n-    // Adding header\n-    static final int V2 = 2;\n-    // Adding ledger key\n-    static final int V3 = 3;\n-    // Adding fencing key\n-    static final int V4 = 4;\n-    // 1) expanding header to 512\n-    // 2) Padding writes to align sector size\n-    static final int V5 = 5;\n-\n-    static final int HEADER_SIZE = SECTOR_SIZE; // align header to sector size\n-    static final int VERSION_HEADER_SIZE = 8; // 4byte magic word, 4 byte version\n-    static final int MIN_COMPAT_JOURNAL_FORMAT_VERSION = V1;\n-    static final int CURRENT_JOURNAL_FORMAT_VERSION = V5;\n-\n-    private final long preAllocSize;\n-    private final int journalAlignSize;\n-    private final boolean fRemoveFromPageCache;\n-    public final ByteBuffer zeros;\n-\n-    // The position of the file channel's last drop position\n-    private long lastDropPosition = 0L;\n-\n-    // Mostly used by tests\n-    JournalChannel(File journalDirectory, long logId) throws IOException {\n-        this(journalDirectory, logId, 4 * 1024 * 1024, 65536, START_OF_FILE);\n-    }\n-\n-    // Open journal for scanning starting from the first record in journal.\n-    JournalChannel(File journalDirectory, long logId, long preAllocSize, int writeBufferSize) throws IOException {\n-        this(journalDirectory, logId, preAllocSize, writeBufferSize, START_OF_FILE);\n-    }\n-\n-    // Open journal for scanning starting from given position.\n-    JournalChannel(File journalDirectory, long logId,\n-                   long preAllocSize, int writeBufferSize, long position) throws IOException {\n-         this(journalDirectory, logId, preAllocSize, writeBufferSize, SECTOR_SIZE, position, false, V5);\n-    }\n-\n-    // Open journal to write\n-    JournalChannel(File journalDirectory, long logId,\n-                   long preAllocSize, int writeBufferSize, int journalAlignSize,\n-                   boolean fRemoveFromPageCache, int formatVersionToWrite) throws IOException {\n-        this(journalDirectory, logId, preAllocSize, writeBufferSize, journalAlignSize,\n-             START_OF_FILE, fRemoveFromPageCache, formatVersionToWrite);\n-    }\n-\n-    /**\n-     * Create a journal file.\n-     *\n-     * @param journalDirectory\n-     *          directory to store the journal file.\n-     * @param logId\n-     *          log id for the journal file.\n-     * @param preAllocSize\n-     *          pre allocation size.\n-     * @param writeBufferSize\n-     *          write buffer size.\n-     * @param journalAlignSize\n-     *          size to align journal writes.\n-     * @param position\n-     *          position to start read/write\n-     * @param fRemoveFromPageCache\n-     *          whether to remove cached pages from page cache.\n-     * @param formatVersionToWrite\n-     *          format version to write\n-     * @throws IOException\n-     */\n-    private JournalChannel(File journalDirectory, long logId,\n-                           long preAllocSize, int writeBufferSize, int journalAlignSize,\n-                           long position, boolean fRemoveFromPageCache,\n-                           int formatVersionToWrite) throws IOException {\n-        this.journalAlignSize = journalAlignSize;\n-        this.zeros = ByteBuffer.allocate(journalAlignSize);\n-        this.preAllocSize = preAllocSize - preAllocSize % journalAlignSize;\n-        this.fRemoveFromPageCache = fRemoveFromPageCache;\n-        File fn = new File(journalDirectory, Long.toHexString(logId) + \".txn\");\n-\n-        if (formatVersionToWrite < V4) {\n-            throw new IOException(\"Invalid journal format to write : version = \" + formatVersionToWrite);\n-        }\n-\n-        LOG.info(\"Opening journal {}\", fn);\n-        if (!fn.exists()) { // new file, write version\n-            if (!fn.createNewFile()) {\n-                LOG.error(\"Journal file {}, that shouldn't exist, already exists. \"\n-                          + \" is there another bookie process running?\", fn);\n-                throw new IOException(\"File \" + fn\n-                        + \" suddenly appeared, is another bookie process running?\");\n-            }\n-            randomAccessFile = new RandomAccessFile(fn, \"rw\");\n-            fc = randomAccessFile.getChannel();\n-            formatVersion = formatVersionToWrite;\n-\n-            int headerSize = (V4 == formatVersion) ? VERSION_HEADER_SIZE : HEADER_SIZE;\n-            ByteBuffer bb = ByteBuffer.allocate(headerSize);\n-            ZeroBuffer.put(bb);\n-            bb.clear();\n-            bb.put(MAGIC_WORD);\n-            bb.putInt(formatVersion);\n-            bb.clear();\n-            fc.write(bb);\n-\n-            bc = new BufferedChannel(fc, writeBufferSize);\n-            forceWrite(true);\n-            nextPrealloc = this.preAllocSize;\n-            fc.write(zeros, nextPrealloc - journalAlignSize);\n-        } else {  // open an existing file\n-            randomAccessFile = new RandomAccessFile(fn, \"r\");\n-            fc = randomAccessFile.getChannel();\n-            bc = null; // readonly\n-\n-            ByteBuffer bb = ByteBuffer.allocate(VERSION_HEADER_SIZE);\n-            int c = fc.read(bb);\n-            bb.flip();\n-\n-            if (c == VERSION_HEADER_SIZE) {\n-                byte[] first4 = new byte[4];\n-                bb.get(first4);\n-\n-                if (Arrays.equals(first4, MAGIC_WORD)) {\n-                    formatVersion = bb.getInt();\n-                } else {\n-                    // pre magic word journal, reset to 0;\n-                    formatVersion = V1;\n-                }\n-            } else {\n-                // no header, must be old version\n-                formatVersion = V1;\n-            }\n-\n-            if (formatVersion < MIN_COMPAT_JOURNAL_FORMAT_VERSION\n-                || formatVersion > CURRENT_JOURNAL_FORMAT_VERSION) {\n-                String err = String.format(\"Invalid journal version, unable to read.\"\n-                        + \" Expected between (%d) and (%d), got (%d)\",\n-                        MIN_COMPAT_JOURNAL_FORMAT_VERSION, CURRENT_JOURNAL_FORMAT_VERSION,\n-                        formatVersion);\n-                LOG.error(err);\n-                throw new IOException(err);\n-            }\n-\n-            try {\n-                if (position == START_OF_FILE) {\n-                    if (formatVersion >= V5) {\n-                        fc.position(HEADER_SIZE);\n-                    } else if (formatVersion >= V2) {\n-                        fc.position(VERSION_HEADER_SIZE);\n-                    } else {\n-                        fc.position(0);\n-                    }\n-                } else {\n-                    fc.position(position);\n-                }\n-            } catch (IOException e) {\n-                LOG.error(\"Bookie journal file can seek to position :\", e);\n-            }\n-        }\n-        this.fd = NativeIO.getSysFileDescriptor(randomAccessFile.getFD());\n-    }\n-\n-    int getFormatVersion() {\n-        return formatVersion;\n-    }\n-\n-    BufferedChannel getBufferedChannel() throws IOException {\n-        if (bc == null) {\n-            throw new IOException(\"Read only journal channel\");\n-        }\n-        return bc;\n-    }\n-\n-    void preAllocIfNeeded(long size) throws IOException {\n-        if (bc.position() + size > nextPrealloc) {\n-            nextPrealloc += preAllocSize;\n-            zeros.clear();\n-            fc.write(zeros, nextPrealloc - journalAlignSize);\n-        }\n-    }\n-\n-    int read(ByteBuffer dst)\n-            throws IOException {\n-        return fc.read(dst);\n-    }\n-\n-    public void close() throws IOException {\n-        fc.close();\n-    }\n-\n-    public void forceWrite(boolean forceMetadata) throws IOException {\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Journal ForceWrite\");\n-        }\n-        long newForceWritePosition = bc.forceWrite(forceMetadata);\n-        //\n-        // For POSIX_FADV_DONTNEED, we want to drop from the beginning\n-        // of the file to a position prior to the current position.\n-        //\n-        // The CACHE_DROP_LAG_BYTES is to prevent dropping a page that will\n-        // be appended again, which would introduce random seeking on journal\n-        // device.\n-        //\n-        // <======== drop ==========>\n-        //                           <-----------LAG------------>\n-        // +------------------------+---------------------------O\n-        // lastDropPosition     newDropPos             lastForceWritePosition\n-        //\n-        if (fRemoveFromPageCache) {\n-            long newDropPos = newForceWritePosition - CACHE_DROP_LAG_BYTES;\n-            if (lastDropPosition < newDropPos) {\n-                NativeIO.bestEffortRemoveFromPageCache(fd, lastDropPosition, newDropPos - lastDropPosition);\n-            }\n-            this.lastDropPosition = newDropPos;\n-        }\n-    }\n-}"},{"sha":"9f4fbc6edb43cb090b97b0496bb1dbc31e79f328","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LEPStateChangeCallback.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LEPStateChangeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LEPStateChangeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LEPStateChangeCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,31 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-/**\n- * Callback interface when state of ledger entry page changed.\n- */\n-interface LEPStateChangeCallback {\n-    public void onSetInUse(LedgerEntryPage lep);\n-    public void onResetInUse(LedgerEntryPage lep);\n-    public void onSetClean(LedgerEntryPage lep);\n-    public void onSetDirty(LedgerEntryPage lep);\n-}"},{"sha":"b2f8a9114e591d8de375b5cfc7e347490baaff27","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,50 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-\n-/**\n- * This class maps a ledger entry number into a location (entrylogid, offset) in\n- * an entry log file. It does user level caching to more efficiently manage disk\n- * head scheduling.\n- */\n-interface LedgerCache extends Closeable {\n-\n-    boolean setFenced(long ledgerId) throws IOException;\n-    boolean isFenced(long ledgerId) throws IOException;\n-\n-    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n-    byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n-    boolean ledgerExists(long ledgerId) throws IOException;\n-\n-    void putEntryOffset(long ledger, long entry, long offset) throws IOException;\n-    long getEntryOffset(long ledger, long entry) throws IOException;\n-\n-    void flushLedger(boolean doAll) throws IOException;\n-    long getLastEntry(long ledgerId) throws IOException;\n-\n-    void deleteLedger(long ledgerId) throws IOException;\n-\n-    LedgerCacheBean getJMXBean();\n-}"},{"sha":"dabc12de9b859297b4c0b8652c9e00948133c239","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,27 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import org.apache.bookkeeper.jmx.BKMBeanInfo;\n-\n-/**\n- * Ledger Cache Bean\n- */\n-public interface LedgerCacheBean extends LedgerCacheMXBean, BKMBeanInfo {\n-}"},{"sha":"e6d2edd92d43d15205b8919cfef3e9582a79a905","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"removed","additions":0,"deletions":183,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,183 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.SnapshotMap;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Implementation of LedgerCache interface.\n- * This class serves two purposes.\n- */\n-public class LedgerCacheImpl implements LedgerCache {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerCacheImpl.class);\n-\n-    private final IndexInMemPageMgr indexPageManager;\n-    private final IndexPersistenceMgr indexPersistenceManager;\n-    private final int pageSize;\n-    private final int entriesPerPage;\n-\n-    public LedgerCacheImpl(ServerConfiguration conf, SnapshotMap<Long, Boolean> activeLedgers,\n-                           LedgerDirsManager ledgerDirsManager) throws IOException {\n-        this(conf, activeLedgers, ledgerDirsManager, NullStatsLogger.INSTANCE);\n-    }\n-\n-    public LedgerCacheImpl(ServerConfiguration conf, SnapshotMap<Long, Boolean> activeLedgers,\n-                           LedgerDirsManager ledgerDirsManager, StatsLogger statsLogger) throws IOException {\n-        this.pageSize = conf.getPageSize();\n-        this.entriesPerPage = pageSize / 8;\n-        this.indexPersistenceManager = new IndexPersistenceMgr(pageSize, entriesPerPage, conf, activeLedgers,\n-                ledgerDirsManager, statsLogger);\n-        this.indexPageManager = new IndexInMemPageMgr(pageSize, entriesPerPage, conf,\n-                indexPersistenceManager, statsLogger);\n-    }\n-\n-    IndexPersistenceMgr getIndexPersistenceManager() {\n-        return indexPersistenceManager;\n-    }\n-\n-    IndexInMemPageMgr getIndexPageManager() {\n-        return indexPageManager;\n-    }\n-\n-    /**\n-     * @return page size used in ledger cache\n-     */\n-    public int getPageSize() {\n-        return pageSize;\n-    }\n-\n-    @Override\n-    public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n-        indexPageManager.putEntryOffset(ledger, entry, offset);\n-    }\n-\n-    @Override\n-    public long getEntryOffset(long ledger, long entry) throws IOException {\n-        return indexPageManager.getEntryOffset(ledger, entry);\n-    }\n-\n-    @Override\n-    public void flushLedger(boolean doAll) throws IOException {\n-        indexPageManager.flushOneOrMoreLedgers(doAll);\n-    }\n-\n-    @Override\n-    public long getLastEntry(long ledgerId) throws IOException {\n-        // Get the highest entry from the pages that are in memory\n-        long lastEntryInMem = indexPageManager.getLastEntryInMem(ledgerId);\n-        // Some index pages may have been evicted from memory, retrieve the last entry\n-        // from the persistent store. We will check if there could be an entry beyond the\n-        // last in mem entry and only then attempt to get the last persisted entry from the file\n-        // The latter is just an optimization\n-        long lastEntry = indexPersistenceManager.getPersistEntryBeyondInMem(ledgerId, lastEntryInMem);\n-        return lastEntry;\n-    }\n-\n-    /**\n-     * This method is called whenever a ledger is deleted by the BookKeeper Client\n-     * and we want to remove all relevant data for it stored in the LedgerCache.\n-     */\n-    @Override\n-    public void deleteLedger(long ledgerId) throws IOException {\n-        LOG.debug(\"Deleting ledgerId: {}\", ledgerId);\n-\n-        indexPageManager.removePagesForLedger(ledgerId);\n-        indexPersistenceManager.removeLedger(ledgerId);\n-    }\n-\n-    @Override\n-    public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n-        return indexPersistenceManager.readMasterKey(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean setFenced(long ledgerId) throws IOException {\n-        return indexPersistenceManager.setFenced(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean isFenced(long ledgerId) throws IOException {\n-        return indexPersistenceManager.isFenced(ledgerId);\n-    }\n-\n-    @Override\n-    public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n-        indexPersistenceManager.setMasterKey(ledgerId, masterKey);\n-    }\n-\n-    @Override\n-    public boolean ledgerExists(long ledgerId) throws IOException {\n-        return indexPersistenceManager.ledgerExists(ledgerId);\n-    }\n-\n-    @Override\n-    public LedgerCacheBean getJMXBean() {\n-        return new LedgerCacheBean() {\n-            @Override\n-            public String getName() {\n-                return \"LedgerCache\";\n-            }\n-\n-            @Override\n-            public boolean isHidden() {\n-                return false;\n-            }\n-\n-            @Override\n-            public int getPageCount() {\n-                return LedgerCacheImpl.this.indexPageManager.getNumUsedPages();\n-            }\n-\n-            @Override\n-            public int getPageSize() {\n-                return LedgerCacheImpl.this.getPageSize();\n-            }\n-\n-            @Override\n-            public int getOpenFileLimit() {\n-                return LedgerCacheImpl.this.indexPersistenceManager.getOpenFileLimit();\n-            }\n-\n-            @Override\n-            public int getPageLimit() {\n-                return LedgerCacheImpl.this.indexPageManager.getPageLimit();\n-            }\n-\n-            @Override\n-            public int getNumOpenLedgers() {\n-                return LedgerCacheImpl.this.indexPersistenceManager.getNumOpenLedgers();\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        indexPersistenceManager.close();\n-    }\n-}"},{"sha":"c24e3489426e0c4c4e985c14e78a5e3e0b7d0edb","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,50 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-/**\n- * Ledger Cache MBean\n- */\n-public interface LedgerCacheMXBean {\n-\n-    /**\n-     * @return number of page used in cache\n-     */\n-    public int getPageCount();\n-\n-    /**\n-     * @return page size\n-     */\n-    public int getPageSize();\n-\n-    /**\n-     * @return the limit of open files\n-     */\n-    public int getOpenFileLimit();\n-\n-    /**\n-     * @return the limit number of pages\n-     */\n-    public int getPageLimit();\n-\n-    /**\n-     * @return number of open ledgers\n-     */\n-    public int getNumOpenLedgers();\n-}"},{"sha":"02850d13b2fdad773d2aa4fdae55bb62996c7bcc","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,62 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Implements a ledger inside a bookie. In particular, it implements operations\n- * to write entries to a ledger and read entries from a ledger.\n- */\n-public abstract class LedgerDescriptor {\n-    static LedgerDescriptor create(byte[] masterKey,\n-                                   long ledgerId,\n-                                   LedgerStorage ledgerStorage) throws IOException {\n-        LedgerDescriptor ledger = new LedgerDescriptorImpl(masterKey, ledgerId, ledgerStorage);\n-        ledgerStorage.setMasterKey(ledgerId, masterKey);\n-        return ledger;\n-    }\n-\n-    static LedgerDescriptor createReadOnly(long ledgerId,\n-                                           LedgerStorage ledgerStorage)\n-            throws IOException, Bookie.NoLedgerException {\n-        if (!ledgerStorage.ledgerExists(ledgerId)) {\n-            throw new Bookie.NoLedgerException(ledgerId);\n-        }\n-        return new LedgerDescriptorReadOnlyImpl(ledgerId, ledgerStorage);\n-    }\n-\n-    abstract void checkAccess(byte masterKey[]) throws BookieException, IOException;\n-\n-    abstract long getLedgerId();\n-\n-    abstract boolean setFenced() throws IOException;\n-    abstract boolean isFenced() throws IOException;\n-\n-    abstract long addEntry(ByteBuffer entry) throws IOException;\n-    abstract ByteBuffer readEntry(long entryId) throws IOException;\n-}"},{"sha":"d9814b667317517f80917e9fd7e7a370785881fe","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,87 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Implements a ledger inside a bookie. In particular, it implements operations\n- * to write entries to a ledger and read entries from a ledger.\n- *\n- */\n-public class LedgerDescriptorImpl extends LedgerDescriptor {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n-    final LedgerStorage ledgerStorage;\n-    private long ledgerId;\n-\n-    final byte[] masterKey;\n-\n-    LedgerDescriptorImpl(byte[] masterKey, long ledgerId, LedgerStorage ledgerStorage) {\n-        this.masterKey = masterKey;\n-        this.ledgerId = ledgerId;\n-        this.ledgerStorage = ledgerStorage;\n-    }\n-\n-    @Override\n-    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n-        if (!Arrays.equals(this.masterKey, masterKey)) {\n-            throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n-        }\n-    }\n-\n-    @Override\n-    public long getLedgerId() {\n-        return ledgerId;\n-    }\n-\n-    @Override\n-    boolean setFenced() throws IOException {\n-        return ledgerStorage.setFenced(ledgerId);\n-    }\n-\n-    @Override\n-    boolean isFenced() throws IOException {\n-        return ledgerStorage.isFenced(ledgerId);\n-    }\n-\n-    @Override\n-    long addEntry(ByteBuffer entry) throws IOException {\n-        long ledgerId = entry.getLong();\n-\n-        if (ledgerId != this.ledgerId) {\n-            throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n-        }\n-        entry.rewind();\n-\n-        return ledgerStorage.addEntry(entry);\n-    }\n-\n-    @Override\n-    ByteBuffer readEntry(long entryId) throws IOException {\n-        return ledgerStorage.getEntry(ledgerId, entryId);\n-    }\n-}"},{"sha":"29dcfaf2a0f0716c19779b2a0d6cdd91c667aa0b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","status":"removed","additions":0,"deletions":52,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,52 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-/**\n- * Implements a ledger inside a bookie. In particular, it implements operations\n- * to write entries to a ledger and read entries from a ledger.\n- */\n-public class LedgerDescriptorReadOnlyImpl extends LedgerDescriptorImpl {\n-    LedgerDescriptorReadOnlyImpl(long ledgerId, LedgerStorage storage) {\n-        super(null, ledgerId, storage);\n-    }\n-\n-    @Override\n-    boolean setFenced() throws IOException {\n-        assert false;\n-        throw new IOException(\"Invalid action on read only descriptor\");\n-    }\n-\n-    @Override\n-    long addEntry(ByteBuffer entry) throws IOException {\n-        assert false;\n-        throw new IOException(\"Invalid action on read only descriptor\");\n-    }\n-\n-    @Override\n-    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n-        assert false;\n-        throw new IOException(\"Invalid action on read only descriptor\");\n-    }\n-}"},{"sha":"935befb2fd73d07ce2bee150773f9a9705b0df35","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"removed","additions":0,"deletions":419,"changes":419,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,419 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.stats.Gauge;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.DiskChecker;\n-import org.apache.bookkeeper.util.DiskChecker.DiskErrorException;\n-import org.apache.bookkeeper.util.DiskChecker.DiskOutOfSpaceException;\n-import org.apache.bookkeeper.util.DiskChecker.DiskWarnThresholdException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-\n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_WRITABLE_DIRS;\n-\n-/**\n- * This class manages ledger directories used by the bookie.\n- */\n-public class LedgerDirsManager {\n-    private final static Logger LOG = LoggerFactory\n-            .getLogger(LedgerDirsManager.class);\n-\n-    private volatile List<File> filledDirs;\n-    private final List<File> ledgerDirectories;\n-    private volatile List<File> writableLedgerDirectories;\n-    private final DiskChecker diskChecker;\n-    private final List<LedgerDirsListener> listeners;\n-    private final LedgerDirsMonitor monitor;\n-    private final Random rand = new Random();\n-    private final ConcurrentMap<File, Float> diskUsages =\n-            new ConcurrentHashMap<File, Float>();\n-\n-    public LedgerDirsManager(ServerConfiguration conf, File[] dirs) {\n-        this(conf, dirs, NullStatsLogger.INSTANCE);\n-    }\n-\n-    LedgerDirsManager(ServerConfiguration conf, File[] dirs, StatsLogger statsLogger) {\n-        this.ledgerDirectories = Arrays.asList(Bookie\n-                .getCurrentDirectories(dirs));\n-        this.writableLedgerDirectories = new ArrayList<File>(ledgerDirectories);\n-        this.filledDirs = new ArrayList<File>();\n-        listeners = new ArrayList<LedgerDirsListener>();\n-        diskChecker = new DiskChecker(conf.getDiskUsageThreshold(), conf.getDiskUsageWarnThreshold());\n-        monitor = new LedgerDirsMonitor(conf.getDiskCheckInterval());\n-        for (File dir : dirs) {\n-            diskUsages.put(dir, 0f);\n-            String statName = \"dir_\" + dir.getPath().replace('/', '_') + \"_usage\";\n-            final File targetDir = dir;\n-            statsLogger.registerGauge(statName, new Gauge<Number>() {\n-                @Override\n-                public Number getDefaultValue() {\n-                    return 0;\n-                }\n-\n-                @Override\n-                public Number getSample() {\n-                    return diskUsages.get(targetDir) * 100;\n-                }\n-            });\n-        }\n-        statsLogger.registerGauge(LD_WRITABLE_DIRS, new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return writableLedgerDirectories.size();\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get all ledger dirs configured\n-     */\n-    public List<File> getAllLedgerDirs() {\n-        return ledgerDirectories;\n-    }\n-\n-    /**\n-     * Get only writable ledger dirs.\n-     */\n-    public List<File> getWritableLedgerDirs()\n-            throws NoWritableLedgerDirException {\n-        if (writableLedgerDirectories.isEmpty()) {\n-            String errMsg = \"All ledger directories are non writable\";\n-            NoWritableLedgerDirException e = new NoWritableLedgerDirException(\n-                    errMsg);\n-            LOG.error(errMsg, e);\n-            throw e;\n-        }\n-        return writableLedgerDirectories;\n-    }\n-\n-    /**\n-     * @return full-filled ledger dirs.\n-     */\n-    public List<File> getFullFilledLedgerDirs() {\n-        return filledDirs;\n-    }\n-\n-    /**\n-     * Get dirs, which are full more than threshold\n-     */\n-    public boolean isDirFull(File dir) {\n-        return filledDirs.contains(dir);\n-    }\n-\n-    /**\n-     * Add the dir to filled dirs list\n-     */\n-    @VisibleForTesting\n-    public void addToFilledDirs(File dir) {\n-        if (!filledDirs.contains(dir)) {\n-            LOG.warn(dir + \" is out of space.\"\n-                    + \" Adding it to filled dirs list\");\n-            // Update filled dirs list\n-            List<File> updatedFilledDirs = new ArrayList<File>(filledDirs);\n-            updatedFilledDirs.add(dir);\n-            filledDirs = updatedFilledDirs;\n-            // Update the writable ledgers list\n-            List<File> newDirs = new ArrayList<File>(writableLedgerDirectories);\n-            newDirs.removeAll(filledDirs);\n-            writableLedgerDirectories = newDirs;\n-            // Notify listeners about disk full\n-            for (LedgerDirsListener listener : listeners) {\n-                listener.diskFull(dir);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Add the dir to writable dirs list.\n-     *\n-     * @param dir Dir\n-     */\n-    public void addToWritableDirs(File dir, boolean underWarnThreshold) {\n-        if (writableLedgerDirectories.contains(dir)) {\n-            return;\n-        }\n-        LOG.info(\"{} becomes writable. Adding it to writable dirs list.\", dir);\n-        // Update writable dirs list\n-        List<File> updatedWritableDirs = new ArrayList<File>(writableLedgerDirectories);\n-        updatedWritableDirs.add(dir);\n-        writableLedgerDirectories = updatedWritableDirs;\n-        // Update the filled dirs list\n-        List<File> newDirs = new ArrayList<File>(filledDirs);\n-        newDirs.removeAll(writableLedgerDirectories);\n-        filledDirs = newDirs;\n-        // Notify listeners about disk writable\n-        for (LedgerDirsListener listener : listeners) {\n-            if (underWarnThreshold) {\n-                listener.diskWritable(dir);\n-            } else {\n-                listener.diskJustWritable(dir);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns one of the ledger dir from writable dirs list randomly.\n-     */\n-    File pickRandomWritableDir() throws NoWritableLedgerDirException {\n-        return pickRandomWritableDir(null);\n-    }\n-\n-    /**\n-     * Pick up a writable dir from available dirs list randomly. The <code>excludedDir</code>\n-     * will not be pickedup.\n-     *\n-     * @param excludedDir\n-     *          The directory to exclude during pickup.\n-     * @throws NoWritableLedgerDirException if there is no writable dir available.\n-     */\n-    File pickRandomWritableDir(File excludedDir) throws NoWritableLedgerDirException {\n-        List<File> writableDirs = getWritableLedgerDirs();\n-\n-        final int start = rand.nextInt(writableDirs.size());\n-        int idx = start;\n-        File candidate = writableDirs.get(idx);\n-        while (null != excludedDir && excludedDir.equals(candidate)) {\n-            idx = (idx + 1) % writableDirs.size();\n-            if (idx == start) {\n-                // after searching all available dirs,\n-                // no writable dir is found\n-                throw new NoWritableLedgerDirException(\"No writable directories found from \"\n-                        + \" available writable dirs (\" + writableDirs + \") : exclude dir \"\n-                        + excludedDir);\n-            }\n-            candidate = writableDirs.get(idx);\n-        }\n-        return candidate;\n-    }\n-\n-    public void addLedgerDirsListener(LedgerDirsListener listener) {\n-        if (listener != null) {\n-            listeners.add(listener);\n-        }\n-    }\n-\n-    /**\n-     * Sweep through all the directories to check disk errors or disk full.\n-     *\n-     * @throws DiskErrorException\n-     *             If disk having errors\n-     * @throws NoWritableLedgerDirException\n-     *             If all the configured ledger directories are full or having\n-     *             less space than threshold\n-     */\n-    public void init() throws DiskErrorException, NoWritableLedgerDirException {\n-        monitor.checkDirs(writableLedgerDirectories);\n-    }\n-\n-    // start the daemon for disk monitoring\n-    public void start() {\n-        monitor.setDaemon(true);\n-        monitor.start();\n-    }\n-\n-    // shutdown disk monitoring daemon\n-    public void shutdown() {\n-        LOG.info(\"Shutting down LedgerDirsMonitor\");\n-        monitor.interrupt();\n-        try {\n-            monitor.join();\n-        } catch (InterruptedException e) {\n-            // Ignore\n-        }\n-    }\n-\n-    /**\n-     * Thread to monitor the disk space periodically.\n-     */\n-    private class LedgerDirsMonitor extends BookieThread {\n-        private final int interval;\n-\n-        public LedgerDirsMonitor(int interval) {\n-            super(\"LedgerDirsMonitorThread\");\n-            this.interval = interval;\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (true) {\n-                List<File> writableDirs;\n-                try {\n-                    writableDirs = getWritableLedgerDirs();\n-                } catch (NoWritableLedgerDirException e) {\n-                    for (LedgerDirsListener listener : listeners) {\n-                        listener.allDisksFull();\n-                    }\n-                    break;\n-                }\n-                // Check all writable dirs disk space usage.\n-                for (File dir : writableDirs) {\n-                    try {\n-                        diskUsages.put(dir, diskChecker.checkDir(dir));\n-                    } catch (DiskErrorException e) {\n-                        LOG.error(\"Ledger directory {} failed on disk checking : \", dir, e);\n-                        // Notify disk failure to all listeners\n-                        for (LedgerDirsListener listener : listeners) {\n-                            listener.diskFailed(dir);\n-                        }\n-                    } catch (DiskWarnThresholdException e) {\n-                        LOG.warn(\"Ledger directory {} is almost full.\", dir);\n-                        diskUsages.put(dir, e.getUsage());\n-                        for (LedgerDirsListener listener : listeners) {\n-                            listener.diskAlmostFull(dir);\n-                        }\n-                    } catch (DiskOutOfSpaceException e) {\n-                        LOG.error(\"Ledger directory {} is out-of-space.\", dir);\n-                        diskUsages.put(dir, e.getUsage());\n-                        // Notify disk full to all listeners\n-                        addToFilledDirs(dir);\n-                    }\n-                }\n-                List<File> fullfilledDirs = new ArrayList<File>(getFullFilledLedgerDirs());\n-                // Check all full-filled disk space usage\n-                for (File dir : fullfilledDirs) {\n-                    try {\n-                        diskUsages.put(dir, diskChecker.checkDir(dir));\n-                        addToWritableDirs(dir, true);\n-                    } catch (DiskErrorException e) {\n-                        //Notify disk failure to all the listeners\n-                        for (LedgerDirsListener listener : listeners) {\n-                            listener.diskFailed(dir);\n-                        }\n-                    } catch (DiskWarnThresholdException e) {\n-                        diskUsages.put(dir, e.getUsage());\n-                        // the full-filled dir become writable but still above warn threshold\n-                        addToWritableDirs(dir, false);\n-                    } catch (DiskOutOfSpaceException e) {\n-                        // the full-filled dir is still full-filled\n-                        diskUsages.put(dir, e.getUsage());\n-                    }\n-                }\n-                try {\n-                    Thread.sleep(interval);\n-                } catch (InterruptedException e) {\n-                    LOG.info(\"LedgerDirsMonitor thread is interrupted\");\n-                    break;\n-                }\n-            }\n-            LOG.info(\"LedgerDirsMonitorThread exited!\");\n-        }\n-\n-        private void checkDirs(List<File> writableDirs)\n-                throws DiskErrorException, NoWritableLedgerDirException {\n-            for (File dir : writableDirs) {\n-                try {\n-                    diskChecker.checkDir(dir);\n-                } catch (DiskWarnThresholdException e) {\n-                    // nop\n-                } catch (DiskOutOfSpaceException e) {\n-                    addToFilledDirs(dir);\n-                }\n-            }\n-            getWritableLedgerDirs();\n-        }\n-    }\n-\n-    /**\n-     * Indicates All configured ledger directories are full.\n-     */\n-    public static class NoWritableLedgerDirException extends IOException {\n-        private static final long serialVersionUID = -8696901285061448421L;\n-\n-        public NoWritableLedgerDirException(String errMsg) {\n-            super(errMsg);\n-        }\n-    }\n-\n-    /**\n-     * Listener for the disk check events will be notified from the\n-     * {@link LedgerDirsManager} whenever disk full/failure detected.\n-     */\n-    public static interface LedgerDirsListener {\n-        /**\n-         * This will be notified on disk failure/disk error\n-         *\n-         * @param disk\n-         *            Failed disk\n-         */\n-        void diskFailed(File disk);\n-\n-        /**\n-         * Notified when the disk usage warn threshold is exceeded on\n-         * the drive.\n-         * @param disk\n-         */\n-        void diskAlmostFull(File disk);\n-\n-        /**\n-         * This will be notified on disk detected as full\n-         *\n-         * @param disk\n-         *            Filled disk\n-         */\n-        void diskFull(File disk);\n-\n-        /**\n-         * This will be notified on disk detected as writable and under warn threshold\n-         *\n-         * @param disk\n-         *          Writable disk\n-         */\n-        void diskWritable(File disk);\n-\n-        /**\n-         * This will be notified on disk detected as writable but still in warn threshold\n-         *\n-         * @param disk\n-         *          Writable disk\n-         */\n-        void diskJustWritable(File disk);\n-\n-        /**\n-         * This will be notified whenever all disks are detected as full.\n-         */\n-        void allDisksFull();\n-\n-        /**\n-         * This will notify the fatal errors.\n-         */\n-        void fatalError();\n-    }\n-}"},{"sha":"2d6f80d7c162c7f47c923065107c61ebebfc342b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"removed","additions":0,"deletions":224,"changes":224,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,224 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.util.ZeroBuffer;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-/**\n- * This is a page in the LedgerCache. It holds the locations\n- * (entrylogfile, offset) for entry ids.\n- */\n-public class LedgerEntryPage {\n-    private final static int indexEntrySize = 8;\n-    private final int pageSize;\n-    private final int entriesPerPage;\n-    volatile private EntryKey entryKey = new EntryKey(-1, BookieProtocol.INVALID_ENTRY_ID);\n-    private final ByteBuffer page;\n-    volatile private boolean clean = true;\n-    private final AtomicInteger useCount = new AtomicInteger();\n-    private final AtomicInteger version = new AtomicInteger(0);\n-    volatile private int last = -1; // Last update position\n-    private final LEPStateChangeCallback callback;\n-\n-    public static int getIndexEntrySize() {\n-        return indexEntrySize;\n-    }\n-\n-    public LedgerEntryPage(int pageSize, int entriesPerPage) {\n-        this(pageSize, entriesPerPage, null);\n-    }\n-\n-    public LedgerEntryPage(int pageSize, int entriesPerPage, LEPStateChangeCallback callback) {\n-        this.pageSize = pageSize;\n-        this.entriesPerPage = entriesPerPage;\n-        page = ByteBuffer.allocateDirect(pageSize);\n-        this.callback = callback;\n-        if (null != this.callback) {\n-            callback.onResetInUse(this);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(getLedger());\n-        sb.append('@');\n-        sb.append(getFirstEntry());\n-        sb.append(clean ? \" clean \" : \" dirty \");\n-        sb.append(useCount.get());\n-        return sb.toString();\n-    }\n-\n-    public void usePage() {\n-        int oldVal = useCount.getAndIncrement();\n-        if ((0 == oldVal) && (null != callback)) {\n-            callback.onSetInUse(this);\n-        }\n-    }\n-\n-    public void releasePage() {\n-        int newUseCount = useCount.decrementAndGet();\n-        if (newUseCount < 0) {\n-            throw new IllegalStateException(\"Use count has gone below 0\");\n-        }\n-        if ((null != callback) && (newUseCount == 0)) {\n-            callback.onResetInUse(this);\n-        }\n-    }\n-\n-    private void checkPage() {\n-        if (useCount.get() <= 0) {\n-            throw new IllegalStateException(\"Page not marked in use\");\n-        }\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (other instanceof LedgerEntryPage) {\n-            LedgerEntryPage otherLEP = (LedgerEntryPage) other;\n-            return otherLEP.getLedger() == getLedger() && otherLEP.getFirstEntry() == getFirstEntry();\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return (int)getLedger() ^ (int)(getFirstEntry());\n-    }\n-\n-    void setClean(int versionOfCleaning) {\n-        this.clean = (versionOfCleaning == version.get());\n-\n-        if ((null != callback) && clean) {\n-            callback.onSetClean(this);\n-        }\n-    }\n-\n-    boolean isClean() {\n-        return clean;\n-    }\n-\n-    public void setOffset(long offset, int position) {\n-        checkPage();\n-        page.putLong(position, offset);\n-        version.incrementAndGet();\n-        if (last < position/getIndexEntrySize()) {\n-            last = position/getIndexEntrySize();\n-        }\n-        this.clean = false;\n-\n-        if (null != callback) {\n-            callback.onSetDirty(this);\n-        }\n-    }\n-\n-    public long getOffset(int position) {\n-        checkPage();\n-        return page.getLong(position);\n-    }\n-\n-    public void zeroPage() {\n-        checkPage();\n-        page.clear();\n-        ZeroBuffer.put(page);\n-        last = -1;\n-        clean = true;\n-    }\n-\n-    public void readPage(FileInfo fi) throws IOException {\n-        checkPage();\n-        page.clear();\n-        while(page.remaining() != 0) {\n-            if (fi.read(page, getFirstEntryPosition()) <= 0) {\n-                throw new IOException(\"Short page read of ledger \" + getLedger()\n-                                + \" tried to get \" + page.capacity() + \" from position \" + getFirstEntryPosition()\n-                                + \" still need \" + page.remaining());\n-            }\n-        }\n-        last = getLastEntryIndex();\n-        clean = true;\n-    }\n-\n-    public ByteBuffer getPageToWrite() {\n-        checkPage();\n-        page.clear();\n-        return page;\n-    }\n-\n-    long getLedger() {\n-        return entryKey.getLedgerId();\n-    }\n-\n-    int getVersion() {\n-        return version.get();\n-    }\n-\n-    public EntryKey getEntryKey() {\n-        return entryKey;\n-    }\n-\n-    void setLedgerAndFirstEntry(long ledgerId, long firstEntry) {\n-        if (firstEntry % entriesPerPage != 0) {\n-            throw new IllegalArgumentException(firstEntry + \" is not a multiple of \" + entriesPerPage);\n-        }\n-        this.entryKey = new EntryKey(ledgerId, firstEntry);\n-    }\n-    long getFirstEntry() {\n-        return entryKey.getEntryId();\n-    }\n-\n-    long getMaxPossibleEntry() {\n-        return entryKey.getEntryId() + entriesPerPage;\n-    }\n-\n-    long getFirstEntryPosition() {\n-        return entryKey.getEntryId() * indexEntrySize;\n-    }\n-\n-    public boolean inUse() {\n-        return useCount.get() > 0;\n-    }\n-\n-    private int getLastEntryIndex() {\n-        for(int i = entriesPerPage - 1; i >= 0; i--) {\n-            if (getOffset(i*getIndexEntrySize()) > 0) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public long getLastEntry() {\n-        if (last >= 0) {\n-            return last + entryKey.getEntryId();\n-        } else {\n-            int index = getLastEntryIndex();\n-            return index >= 0 ? (index + entryKey.getEntryId()) : 0;\n-        }\n-    }\n-}"},{"sha":"e992d03ddb2d704ec7f326bb120dc50d0b1f2767","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","status":"removed","additions":0,"deletions":118,"changes":118,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,118 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n-import org.apache.bookkeeper.jmx.BKMBeanInfo;\n-\n-/**\n- * Interface for storing ledger data\n- * on persistant storage.\n- */\n-interface LedgerStorage {\n-    /**\n-     * Start any background threads\n-     * belonging to the storage system. For example,\n-     * garbage collection.\n-     */\n-    void start();\n-\n-    /**\n-     * Cleanup and free any resources\n-     * being used by the storage system.\n-     */\n-    void shutdown() throws InterruptedException;\n-\n-    /**\n-     * Whether a ledger exists\n-     */\n-    boolean ledgerExists(long ledgerId) throws IOException;\n-\n-    /**\n-     * Fenced the ledger id in ledger storage.\n-     *\n-     * @param ledgerId\n-     *          Ledger Id.\n-     * @throws IOException when failed to fence the ledger.\n-     */\n-    boolean setFenced(long ledgerId) throws IOException;\n-\n-    /**\n-     * Check whether the ledger is fenced in ledger storage or not.\n-     *\n-     * @param ledgerId\n-     *          Ledger ID.\n-     * @throws IOException\n-     */\n-    boolean isFenced(long ledgerId) throws IOException;\n-\n-    /**\n-     * Set the master key for a ledger\n-     */\n-    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n-\n-    /**\n-     * Get the master key for a ledger\n-     * @throws IOException if there is an error reading the from the ledger\n-     * @throws BookieException if no such ledger exists\n-     */\n-    byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n-\n-    /**\n-     * Add an entry to the storage.\n-     * @return the entry id of the entry added\n-     */\n-    long addEntry(ByteBuffer entry) throws IOException;\n-\n-    /**\n-     * Read an entry from storage\n-     */\n-    ByteBuffer getEntry(long ledgerId, long entryId) throws IOException;\n-\n-    /**\n-     * Flushes all data in the storage. Once this is called,\n-     * add data written to the LedgerStorage up until this point\n-     * has been persisted to perminant storage\n-     */\n-    void flush() throws IOException;\n-\n-    /**\n-     * Ask the ledger storage to sync data until the given <i>checkpoint</i>.\n-     * The ledger storage implementation do checkpoint and return the real checkpoint\n-     * that it finished. The returned the checkpoint indicates that all entries added\n-     * before that point already persist.\n-     *\n-     * @param checkpoint\n-     *          Check Point that {@link Checkpointer} proposed.\n-     * @throws IOException\n-     * @return the checkpoint that the ledger storage finished.\n-     */\n-    Checkpoint checkpoint(Checkpoint checkpoint) throws IOException;\n-\n-    /**\n-     * Get the JMX management bean for this LedgerStorage\n-     */\n-    BKMBeanInfo getJMXBean();\n-}"},{"sha":"4bf1e050754a974cbdc63a97c7d778b63647a51a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LogMark.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LogMark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LogMark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LogMark.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,83 +0,0 @@\n-/**\n- * Copyright The Apache Software Foundation\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.nio.ByteBuffer;\n-\n-/**\n- * Journal stream position\n- */\n-class LogMark {\n-    long logFileId;\n-    long logFileOffset;\n-\n-    public LogMark() {\n-        setLogMark(0, 0);\n-    }\n-\n-    public LogMark(LogMark other) {\n-        setLogMark(other.getLogFileId(), other.getLogFileOffset());\n-    }\n-\n-    public LogMark(long logFileId, long logFileOffset) {\n-        setLogMark(logFileId, logFileOffset);\n-    }\n-\n-    public synchronized long getLogFileId() {\n-        return logFileId;\n-    }\n-\n-    public synchronized long getLogFileOffset() {\n-        return logFileOffset;\n-    }\n-\n-    public synchronized void readLogMark(ByteBuffer bb) {\n-        logFileId = bb.getLong();\n-        logFileOffset = bb.getLong();\n-    }\n-\n-    public synchronized void writeLogMark(ByteBuffer bb) {\n-        bb.putLong(logFileId);\n-        bb.putLong(logFileOffset);\n-    }\n-\n-    public synchronized void setLogMark(long logFileId, long logFileOffset) {\n-        this.logFileId = logFileId;\n-        this.logFileOffset = logFileOffset;\n-    }\n-\n-    public synchronized int compare(LogMark other) {\n-        long ret = this.logFileId - other.getLogFileId();\n-        if (ret == 0) {\n-            ret = this.logFileOffset - other.getLogFileOffset();\n-        }\n-        return (ret < 0)? -1 : ((ret > 0)? 1 : 0);\n-    }\n-\n-    @Override\n-    public synchronized String toString() {\n-        StringBuilder sb = new StringBuilder();\n-\n-        sb.append(\"LogMark: logFileId - \").append(logFileId)\n-                .append(\" , logFileOffset - \").append(logFileOffset);\n-\n-        return sb.toString();\n-    }\n-}"},{"sha":"8ed63bb29f5b29260a8c69d2c05f6abd60ac6881","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","status":"removed","additions":0,"deletions":147,"changes":147,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,147 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.MappedByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.nio.channels.FileLock;\n-import java.nio.channels.ReadableByteChannel;\n-import java.nio.channels.WritableByteChannel;\n-\n-/**\n- * This class is just a stub that can be used in collections with\n- * FileChannels\n- */\n-public class MarkerFileChannel extends FileChannel {\n-\n-    @Override\n-    public void force(boolean metaData) throws IOException {\n-        // TODO Auto-generated method stub\n-\n-    }\n-\n-    @Override\n-    public FileLock lock(long position, long size, boolean shared)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n-    @Override\n-    public MappedByteBuffer map(MapMode mode, long position, long size)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n-    @Override\n-    public long position() throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public FileChannel position(long newPosition) throws IOException {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer dst) throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer dst, long position) throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public long size() throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public long transferFrom(ReadableByteChannel src, long position, long count)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public long transferTo(long position, long count, WritableByteChannel target)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public FileChannel truncate(long size) throws IOException {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n-    @Override\n-    public FileLock tryLock(long position, long size, boolean shared)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer src) throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer src, long position) throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n-            throws IOException {\n-        // TODO Auto-generated method stub\n-        return 0;\n-    }\n-\n-    @Override\n-    protected void implCloseChannel() throws IOException {\n-        // TODO Auto-generated method stub\n-\n-    }\n-\n-}"},{"sha":"a2ce9e3cb94ecfc4116fa6279373393e6495ae1e","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","status":"removed","additions":0,"deletions":58,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,58 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-\n-/**\n- * Read Only Entry Logger\n- */\n-public class ReadOnlyEntryLogger extends EntryLogger {\n-\n-    public ReadOnlyEntryLogger(ServerConfiguration conf) throws IOException {\n-        super(conf, new LedgerDirsManager(conf, conf.getLedgerDirs()));\n-    }\n-\n-    @Override\n-    protected void initialize() throws IOException {\n-        // do nothing for read only entry logger\n-    }\n-\n-    @Override\n-    void createNewLog() throws IOException {\n-        throw new IOException(\"Can't create new entry log using a readonly entry logger.\");\n-    }\n-\n-    @Override\n-    protected boolean removeEntryLog(long entryLogId) {\n-        // can't remove entry log in readonly mode\n-        return false;\n-    }\n-\n-    @Override\n-    synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n-        throw new IOException(\"Can't add entry to a readonly entry logger.\");\n-    }\n-}"},{"sha":"0040fa6124dc3fb6f7402a38d0435b45c26d211f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyFileInfo.java","status":"removed","additions":0,"deletions":44,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyFileInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyFileInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyFileInfo.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,44 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.ByteBuffer;\n-import java.nio.BufferUnderflowException;\n-import java.nio.channels.FileChannel;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Provide a readonly file info.\n- */\n-class ReadOnlyFileInfo extends FileInfo {\n-\n-    public ReadOnlyFileInfo(File lf, byte[] masterKey) throws IOException {\n-        super(lf, masterKey);\n-        mode = \"r\";\n-    }\n-\n-}"},{"sha":"d8a87e4b31ac44676599d9227f0e096ec3bdac51","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","status":"removed","additions":0,"deletions":108,"changes":108,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,108 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.util.Map;\n-import java.util.NavigableMap;\n-import java.util.Set;\n-\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.meta.LedgerManager.LedgerRange;\n-import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n-import org.apache.bookkeeper.util.SnapshotMap;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Garbage collector implementation using scan and compare.\n- *\n- * <p>\n- * Garbage collection is processed as below:\n- * <ul>\n- * <li> fetch all existing ledgers from zookeeper or metastore according to\n- * the LedgerManager, called <b>globalActiveLedgers</b>\n- * <li> fetch all active ledgers from bookie server, said <b>bkActiveLedgers</b>\n- * <li> loop over <b>bkActiveLedgers</b> to find those ledgers that are not in\n- * <b>globalActiveLedgers</b>, do garbage collection on them.\n- * </ul>\n- * </p>\n- */\n-public class ScanAndCompareGarbageCollector implements GarbageCollector{\n-\n-    static final Logger LOG = LoggerFactory.getLogger(ScanAndCompareGarbageCollector.class);\n-    private SnapshotMap<Long, Boolean> activeLedgers;\n-    private LedgerManager ledgerManager;\n-\n-    public ScanAndCompareGarbageCollector(LedgerManager ledgerManager, SnapshotMap<Long, Boolean> activeLedgers) {\n-        this.ledgerManager = ledgerManager;\n-        this.activeLedgers = activeLedgers;\n-    }\n-\n-    @Override\n-    public void gc(GarbageCleaner garbageCleaner) {\n-        // create a snapshot first\n-        NavigableMap<Long, Boolean> bkActiveLedgersSnapshot =\n-                this.activeLedgers.snapshot();\n-        LedgerRangeIterator ledgerRangeIterator = ledgerManager.getLedgerRanges();\n-        try {\n-            // Empty global active ledgers, need to remove all local active ledgers.\n-            if (!ledgerRangeIterator.hasNext()) {\n-                for (Long bkLid : bkActiveLedgersSnapshot.keySet()) {\n-                    // remove it from current active ledger\n-                    bkActiveLedgersSnapshot.remove(bkLid);\n-                    garbageCleaner.clean(bkLid);\n-                }\n-            }\n-            long lastEnd = -1;\n-\n-            while(ledgerRangeIterator.hasNext()) {\n-                LedgerRange lRange = ledgerRangeIterator.next();\n-                Map<Long, Boolean> subBkActiveLedgers = null;\n-\n-                Long start = lastEnd + 1;\n-                Long end = lRange.end();\n-                if (!ledgerRangeIterator.hasNext()) {\n-                    end = Long.MAX_VALUE;\n-                }\n-                subBkActiveLedgers = bkActiveLedgersSnapshot.subMap(\n-                        start, true, end, true);\n-\n-                Set<Long> ledgersInMetadata = lRange.getLedgers();\n-                LOG.debug(\"Active in metadata {}, Active in bookie {}\",\n-                          ledgersInMetadata, subBkActiveLedgers.keySet());\n-                for (Long bkLid : subBkActiveLedgers.keySet()) {\n-                    if (!ledgersInMetadata.contains(bkLid)) {\n-                        // remove it from current active ledger\n-                        subBkActiveLedgers.remove(bkLid);\n-                        garbageCleaner.clean(bkLid);\n-                    }\n-                }\n-                lastEnd = end;\n-            }\n-        } catch (Exception e) {\n-            // ignore exception, collecting garbage next time\n-            LOG.warn(\"Exception when iterating over the metadata {}\", e);\n-        }\n-    }\n-}\n-\n-"},{"sha":"c3ec897f9bb7840a4f57235c737bb88b44339ab9","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","status":"removed","additions":0,"deletions":238,"changes":238,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,238 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-\n-/**\n- * SkipList allocation buffer to reduce memory fragment.\n- * Adapted from HBase project.\n- * <p>\n- * The SkipListArena is basically a bump-the-pointer allocator that allocates\n- * big (default 2MB) byte[] chunks from and then handles it out to threads that\n- * request slices into the array.\n- * <p>\n- * The purpose of this class is to combat heap fragmentation in the\n- * bookie. By ensuring that all KeyValues in a given SkipList refer\n- * only to large chunks of contiguous memory, we ensure that large blocks\n- * get freed up when the SkipList is flushed.\n- * <p>\n- * Without the Arena, the byte array allocated during insertion end up\n- * interleaved throughout the heap, and the old generation gets progressively\n- * more fragmented until a stop-the-world compacting collection occurs.\n- * <p>\n- */\n-public class SkipListArena {\n-    private AtomicReference<Chunk> curChunk = new AtomicReference<Chunk>();\n-\n-    final int chunkSize;\n-\n-    final int maxAlloc;\n-\n-    public SkipListArena(ServerConfiguration cfg) {\n-        chunkSize = cfg.getSkipListArenaChunkSize();\n-        maxAlloc = cfg.getSkipListArenaMaxAllocSize();\n-        assert maxAlloc <= chunkSize;\n-    }\n-\n-    /**\n-    * Allocate a slice of the given length.\n-    *\n-    * If the size is larger than the maximum size specified for this\n-    * allocator, returns null.\n-    */\n-    public MemorySlice allocateBytes(int size) {\n-        assert size >= 0;\n-\n-        // Callers should satisfy large allocations directly from JVM since they\n-        // don't cause fragmentation as badly.\n-        if (size > maxAlloc) {\n-            return null;\n-        }\n-\n-        while (true) {\n-            Chunk c = getCurrentChunk();\n-\n-            // Try to allocate from this chunk\n-            int allocOffset = c.alloc(size);\n-            if (allocOffset != -1) {\n-                // We succeeded - this is the common case - small alloc\n-                // from a big buffer\n-                return new MemorySlice(c.data, allocOffset);\n-            }\n-\n-            // not enough space!\n-            // try to retire this chunk\n-            retireCurrentChunk(c);\n-        }\n-    }\n-\n-    /**\n-    * Try to retire the current chunk if it is still there.\n-    */\n-    private void retireCurrentChunk(Chunk c) {\n-        curChunk.compareAndSet(c, null);\n-        // If the CAS fails, that means that someone else already\n-        // retired the chunk for us.\n-    }\n-\n-    /**\n-    * Get the current chunk, or, if there is no current chunk,\n-    * allocate a new one from the JVM.\n-    */\n-    private Chunk getCurrentChunk() {\n-        while (true) {\n-            // Try to get the chunk\n-            Chunk c = curChunk.get();\n-            if (c != null) {\n-                return c;\n-            }\n-\n-            // No current chunk, so we want to allocate one. We race\n-            // against other allocators to CAS in an uninitialized chunk\n-            // (which is cheap to allocate)\n-            c = new Chunk(chunkSize);\n-            if (curChunk.compareAndSet(null, c)) {\n-                c.init();\n-                return c;\n-            }\n-            // lost race\n-        }\n-    }\n-\n-    /**\n-    * A chunk of memory out of which allocations are sliced.\n-    */\n-    private static class Chunk {\n-        /** Actual underlying data */\n-        private byte[] data;\n-\n-        private static final int UNINITIALIZED = -1;\n-        private static final int OOM = -2;\n-        /**\n-         * Offset for the next allocation, or the sentinel value -1\n-         * which implies that the chunk is still uninitialized.\n-         * */\n-        private AtomicInteger nextFreeOffset = new AtomicInteger(UNINITIALIZED);\n-\n-        /** Total number of allocations satisfied from this buffer */\n-        private AtomicInteger allocCount = new AtomicInteger();\n-\n-        /** Size of chunk in bytes */\n-        private final int size;\n-\n-        /**\n-         * Create an uninitialized chunk. Note that memory is not allocated yet, so\n-         * this is cheap.\n-         * @param size in bytes\n-         */\n-        private Chunk(int size) {\n-            this.size = size;\n-        }\n-\n-        /**\n-         * Actually claim the memory for this chunk. This should only be called from\n-         * the thread that constructed the chunk. It is thread-safe against other\n-         * threads calling alloc(), who will block until the allocation is complete.\n-         */\n-        public void init() {\n-            assert nextFreeOffset.get() == UNINITIALIZED;\n-            try {\n-                data = new byte[size];\n-            } catch (OutOfMemoryError e) {\n-                boolean failInit = nextFreeOffset.compareAndSet(UNINITIALIZED, OOM);\n-                assert failInit; // should be true.\n-                throw e;\n-            }\n-            // Mark that it's ready for use\n-            boolean okInit = nextFreeOffset.compareAndSet(UNINITIALIZED, 0);\n-            assert okInit;    // single-threaded call\n-        }\n-\n-        /**\n-         * Try to allocate <code>size</code> bytes from the chunk.\n-         * @return the offset of the successful allocation, or -1 to indicate not-enough-space\n-         */\n-        public int alloc(int size) {\n-            while (true) {\n-                int oldOffset = nextFreeOffset.get();\n-                if (oldOffset == UNINITIALIZED) {\n-                    // Other thread allocating it right now\n-                    Thread.yield();\n-                    continue;\n-                }\n-                if (oldOffset == OOM) {\n-                    return -1;\n-                }\n-\n-                if (oldOffset + size > data.length) {\n-                    return -1; // alloc doesn't fit\n-                }\n-\n-                // Try to atomically claim this chunk\n-                if (nextFreeOffset.compareAndSet(oldOffset, oldOffset + size)) {\n-                    // we got the alloc\n-                    allocCount.incrementAndGet();\n-                    return oldOffset;\n-                }\n-                // lost race\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Chunk@\" + System.identityHashCode(this) +\n-                \": used(\" + allocCount.get() + \"), free(\" +\n-                (data.length - nextFreeOffset.get() + \")\");\n-        }\n-    }\n-\n-    /**\n-    * The result of a single allocation. Contains the chunk that the\n-    * allocation points into, and the offset in this array where the\n-    * slice begins.\n-    */\n-    public static class MemorySlice {\n-        private final byte[] data;\n-        private final int offset;\n-\n-        private MemorySlice(byte[] data, int off) {\n-            this.data = data;\n-            this.offset = off;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Slice:\" + \"capacity(\" + data.length + \"), offset(\" + offset + \")\";\n-        }\n-\n-        byte[] getData() {\n-            return data;\n-        }\n-\n-        int getOffset() {\n-            return offset;\n-        }\n-    }\n-}"},{"sha":"1dfb880ce288ba87ef205f362504f94a30f7a323","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,43 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-/**\n- * Flush entries from skip list\n- */\n-public interface SkipListFlusher {\n-    /**\n-     * Process an entry.\n-     *\n-     * @param ledgerId\n-     *          Ledger ID.\n-     * @param entryId\n-     *          The entry id this entry.\n-     * @param entry\n-     *          Entry ByteBuffer\n-     * @throws IOException\n-     */\n-    public void process(long ledgerId, long entryId, ByteBuffer entry) throws IOException;\n-}"},{"sha":"0a3884c2636fed66618af2ab9a8c3bf87abf8bbc","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"removed","additions":0,"deletions":186,"changes":186,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,186 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class SortedLedgerStorage extends InterleavedLedgerStorage\n-        implements LedgerStorage, CacheCallback, SkipListFlusher {\n-    private final static Logger LOG = LoggerFactory.getLogger(SortedLedgerStorage.class);\n-\n-    private final EntryMemTable memTable;\n-    private final ScheduledExecutorService scheduler;\n-\n-    public SortedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n-                               LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n-                               final CheckpointSource checkpointSource, StatsLogger statsLogger)\n-                                       throws IOException {\n-        super(conf, ledgerManager, ledgerDirsManager, indexDirsManager, null, statsLogger);\n-        this.memTable = new EntryMemTable(conf, checkpointSource, statsLogger);\n-        this.scheduler = Executors.newSingleThreadScheduledExecutor(\n-                new ThreadFactoryBuilder()\n-                .setNameFormat(\"SortedLedgerStorage-%d\")\n-                .setPriority((Thread.NORM_PRIORITY + Thread.MAX_PRIORITY)/2).build());\n-    }\n-\n-    @Override\n-    public void start() {\n-        try {\n-            flush();\n-        } catch (IOException e) {\n-            LOG.error(\"Exception thrown while flushing ledger cache.\", e);\n-        }\n-        super.start();\n-    }\n-\n-    @Override\n-    public void shutdown() throws InterruptedException {\n-        // Wait for any jobs currently scheduled to be completed and then shut down.\n-        scheduler.shutdown();\n-        if (!scheduler.awaitTermination(3, TimeUnit.SECONDS)) {\n-            scheduler.shutdownNow();\n-        }\n-        super.shutdown();\n-    }\n-\n-    @Override\n-    public boolean ledgerExists(long ledgerId) throws IOException {\n-        // Done this way because checking the skip list is an O(logN) operation compared to\n-        // the O(1) for the ledgerCache.\n-        if (!super.ledgerExists(ledgerId)) {\n-            EntryKeyValue kv = memTable.getLastEntry(ledgerId);\n-            if (null == kv) {\n-                return super.ledgerExists(ledgerId);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    @Override\n-    public long addEntry(ByteBuffer entry) throws IOException {\n-        long ledgerId = entry.getLong();\n-        long entryId = entry.getLong();\n-        entry.rewind();\n-        memTable.addEntry(ledgerId, entryId, entry, this);\n-        return entryId;\n-    }\n-\n-    /**\n-     * Get the last entry id for a particular ledger.\n-     * @param ledgerId\n-     * @return\n-     */\n-    private ByteBuffer getLastEntryId(long ledgerId) throws IOException {\n-        EntryKeyValue kv = memTable.getLastEntry(ledgerId);\n-        if (null != kv) {\n-            return kv.getValueAsByteBuffer();\n-        }\n-        // If it doesn't exist in the skip list, then fallback to the ledger cache+index.\n-        return super.getEntry(ledgerId, BookieProtocol.LAST_ADD_CONFIRMED);\n-    }\n-\n-    @Override\n-    public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n-        if (entryId == BookieProtocol.LAST_ADD_CONFIRMED) {\n-            return getLastEntryId(ledgerId);\n-        }\n-        ByteBuffer buffToRet;\n-        try {\n-            buffToRet = super.getEntry(ledgerId, entryId);\n-        } catch (Bookie.NoEntryException nee) {\n-            EntryKeyValue kv = memTable.getEntry(ledgerId, entryId);\n-            if (null == kv) {\n-                // The entry might have been flushed since we last checked, so query the ledger cache again.\n-                // If the entry truly doesn't exist, then this will throw a NoEntryException\n-                buffToRet = super.getEntry(ledgerId, entryId);\n-            } else {\n-                buffToRet = kv.getValueAsByteBuffer();\n-            }\n-        }\n-        // buffToRet will not be null when we reach here.\n-        return buffToRet;\n-    }\n-\n-    @Override\n-    public Checkpoint checkpoint(final Checkpoint checkpoint) throws IOException {\n-        Checkpoint lastCheckpoint = checkpointHolder.getLastCheckpoint();\n-        // if checkpoint is less than last checkpoint, we don't need to do checkpoint again.\n-        if (lastCheckpoint.compareTo(checkpoint) > 0) {\n-            return lastCheckpoint;\n-        }\n-        memTable.flush(this, checkpoint);\n-        return super.checkpoint(checkpoint);\n-    }\n-\n-    @Override\n-    public void process(long ledgerId, long entryId,\n-                        ByteBuffer buffer) throws IOException {\n-        processEntry(ledgerId, entryId, buffer, false);\n-    }\n-\n-    @Override\n-    public void flush() throws IOException {\n-        memTable.flush(this, Checkpoint.MAX);\n-        super.flush();\n-    }\n-\n-    // CacheCallback functions.\n-    @Override\n-    public void onSizeLimitReached() throws IOException {\n-        // when size limit reached, we get the previous checkpoint from snapshot mem-table.\n-        // at this point, we are safer to schedule a checkpoint, since the entries added before\n-        // this checkpoint already written to entry logger.\n-        // but it would be better not to let mem-table flush to different entry log files,\n-        // so we roll entry log files in SortedLedgerStorage itself.\n-        // After that, we could make the process writing data to entry logger file not bound with checkpoint.\n-        // otherwise, it hurts add performance.\n-        scheduler.submit(new Runnable() {\n-            @Override\n-            public void run() {\n-                try {\n-                    LOG.info(\"Started flushing mem table.\");\n-                    memTable.flush(SortedLedgerStorage.this);\n-                    if (entryLogger.reachEntryLogLimit(0)) {\n-                        entryLogger.rollLog();\n-                        LOG.info(\"Rolling entry logger since it reached size limitation\");\n-                    }\n-                } catch (IOException e) {\n-                    // TODO: if we failed to flush data, we should switch the bookie back to readonly mode\n-                    //       or shutdown it.\n-                    LOG.error(\"Exception thrown while flushing skip list cache.\", e);\n-                }\n-            }\n-        });\n-    }\n-}"},{"sha":"71a21580294d18664fa9002bf1fb03bff6b1a78d","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","status":"removed","additions":0,"deletions":189,"changes":189,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,189 +0,0 @@\n-/**\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-\n-/**\n- * SyncThread is a background thread which help checkpointing ledger storage\n- * when a checkpoint is requested. After a ledger storage is checkpointed,\n- * the journal files added before checkpoint will be garbage collected.\n- * <p>\n- * After all data has been persisted to ledger index files and entry\n- * loggers, it is safe to complete a checkpoint by persisting the log marker\n- * to disk. If bookie failed after persist log mark, bookie is able to relay\n- * journal entries started from last log mark without losing any entries.\n- * </p>\n- * <p>\n- * Those journal files whose id are less than the log id in last log mark,\n- * could be removed safely after persisting last log mark. We provide a\n- * setting to let user keeping number of old journal files which may be used\n- * for manual recovery in critical disaster.\n- * </p>\n- */\n-class SyncThread {\n-    private final static Logger LOG = LoggerFactory.getLogger(SyncThread.class);\n-\n-    final ScheduledExecutorService executor;\n-    final int flushInterval;\n-    final LedgerStorage ledgerStorage;\n-    final LedgerDirsListener dirsListener;\n-    final CheckpointSource checkpointSource;\n-\n-    public SyncThread(ServerConfiguration conf,\n-                      LedgerDirsListener dirsListener,\n-                      LedgerStorage ledgerStorage,\n-                      CheckpointSource checkpointSource) {\n-        this.dirsListener = dirsListener;\n-        this.ledgerStorage = ledgerStorage;\n-        this.checkpointSource = checkpointSource;\n-        ThreadFactoryBuilder tfb = new ThreadFactoryBuilder()\n-            .setNameFormat(\"SyncThread-\" + conf.getBookiePort() + \"-%d\");\n-        this.executor = Executors.newSingleThreadScheduledExecutor(tfb.build());\n-        flushInterval = conf.getFlushInterval();\n-        LOG.debug(\"Flush Interval : {}\", flushInterval);\n-    }\n-\n-    void start() {\n-        executor.scheduleAtFixedRate(new Runnable() {\n-                public void run() {\n-                    try {\n-                        synchronized (suspensionLock) {\n-                            while (suspended) {\n-                                try {\n-                                    suspensionLock.wait();\n-                                } catch (InterruptedException e) {\n-                                    Thread.currentThread().interrupt();\n-                                    continue;\n-                                }\n-                            }\n-                        }\n-                        checkpoint(checkpointSource.newCheckpoint());\n-                    } catch (Throwable t) {\n-                        LOG.error(\"Exception in SyncThread\", t);\n-                        dirsListener.fatalError();\n-                    }\n-                }\n-            }, flushInterval, flushInterval, TimeUnit.MILLISECONDS);\n-    }\n-\n-    private void flush() {\n-        Checkpoint checkpoint = checkpointSource.newCheckpoint();\n-        try {\n-            ledgerStorage.flush();\n-        } catch (NoWritableLedgerDirException e) {\n-            LOG.error(\"No writeable ledger directories\", e);\n-            dirsListener.allDisksFull();\n-            return;\n-        } catch (IOException e) {\n-            LOG.error(\"Exception flushing ledgers\", e);\n-            return;\n-        }\n-\n-        try {\n-            checkpointSource.checkpointComplete(checkpoint, false);\n-        } catch (IOException e) {\n-            LOG.error(\"Exception marking checkpoint as complete\", e);\n-            dirsListener.allDisksFull();\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public void checkpoint(Checkpoint checkpoint) {\n-        try {\n-            checkpoint = ledgerStorage.checkpoint(checkpoint);\n-        } catch (NoWritableLedgerDirException e) {\n-            LOG.error(\"No writeable ledger directories\", e);\n-            dirsListener.allDisksFull();\n-            return;\n-        } catch (IOException e) {\n-            LOG.error(\"Exception flushing ledgers\", e);\n-            return;\n-        }\n-\n-        try {\n-            checkpointSource.checkpointComplete(checkpoint, true);\n-        } catch (IOException e) {\n-            LOG.error(\"Exception marking checkpoint as complete\", e);\n-            dirsListener.allDisksFull();\n-        }\n-    }\n-\n-    private Object suspensionLock = new Object();\n-    private boolean suspended = false;\n-\n-    /**\n-     * Suspend sync thread. (for testing)\n-     */\n-    @VisibleForTesting\n-    public void suspendSync() {\n-        synchronized(suspensionLock) {\n-            suspended = true;\n-        }\n-    }\n-\n-    /**\n-     * Resume sync thread. (for testing)\n-     */\n-    @VisibleForTesting\n-    public void resumeSync() {\n-        synchronized(suspensionLock) {\n-            suspended = false;\n-            suspensionLock.notify();\n-        }\n-    }\n-\n-    // shutdown sync thread\n-    void shutdown() throws InterruptedException {\n-        LOG.info(\"Shutting down SyncThread\");\n-        executor.submit(new Runnable() {\n-                public void run() {\n-                    try {\n-                        flush();\n-                    } catch (Throwable t) {\n-                        LOG.error(\"Exception flushing ledgers at shutdown\", t);\n-                    }\n-                }\n-            });\n-        executor.shutdown();\n-        long start = MathUtils.now();\n-        while (!executor.awaitTermination(5, TimeUnit.MINUTES)) {\n-            long now = MathUtils.now();\n-            LOG.info(\"SyncThread taking a long time to shutdown. Has taken {}\"\n-                    + \" seconds so far\", now - start);\n-        }\n-    }\n-}"},{"sha":"d3f17284bc8efd4b188ef3b5c6c41fbcc6e87192","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"removed","additions":0,"deletions":151,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,151 +0,0 @@\n-package org.apache.bookkeeper.client;\n-\n-import java.util.Enumeration;\n-\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with this\n- * work for additional information regarding copyright ownership. The ASF\n- * licenses this file to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-public interface AsyncCallback {\n-    public interface AddCallback {\n-        /**\n-         * Callback declaration\n-         *\n-         * @param rc\n-         *          return code\n-         * @param lh\n-         *          ledger handle\n-         * @param entryId\n-         *          entry identifier\n-         * @param ctx\n-         *          context object\n-         */\n-        void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n-    }\n-\n-    public interface CloseCallback {\n-        /**\n-         * Callback definition\n-         *\n-         * @param rc\n-         *          return code\n-         * @param lh\n-         *          ledger handle\n-         * @param ctx\n-         *          context object\n-         */\n-        void closeComplete(int rc, LedgerHandle lh, Object ctx);\n-    }\n-\n-    public interface CreateCallback {\n-        /**\n-         * Declaration of callback method\n-         *\n-         * @param rc\n-         *          return status\n-         * @param lh\n-         *          ledger handle\n-         * @param ctx\n-         *          context object\n-         */\n-\n-        void createComplete(int rc, LedgerHandle lh, Object ctx);\n-    }\n-\n-    public interface OpenCallback {\n-        /**\n-         * Callback for asynchronous call to open ledger\n-         *\n-         * @param rc\n-         *          Return code\n-         * @param lh\n-         *          ledger handle\n-         * @param ctx\n-         *          context object\n-         */\n-\n-        public void openComplete(int rc, LedgerHandle lh, Object ctx);\n-\n-    }\n-\n-    public interface ReadCallback {\n-        /**\n-         * Callback declaration\n-         *\n-         * @param rc\n-         *          return code\n-         * @param lh\n-         *          ledger handle\n-         * @param seq\n-         *          sequence of entries\n-         * @param ctx\n-         *          context object\n-         */\n-\n-        void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n-                          Object ctx);\n-    }\n-\n-    public interface DeleteCallback {\n-        /**\n-         * Callback definition for delete operations\n-         *\n-         * @param rc\n-         *          return code\n-         * @param ctx\n-         *          context object\n-         */\n-        void deleteComplete(int rc, Object ctx);\n-    }\n-\n-    public interface ReadLastConfirmedCallback {\n-        /**\n-         * Callback definition for bookie recover operations\n-         *\n-         * @param rc Return code\n-         * @param lastConfirmed The entry id of the last confirmed write or\n-         *                      {@link LedgerHandle#INVALID_ENTRY_ID INVALID_ENTRY_ID}\n-         *                      if no entry has been confirmed\n-         * @param ctx\n-         *          context object\n-         */\n-        void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n-    }\n-\n-    public interface RecoverCallback {\n-        /**\n-         * Callback definition for bookie recover operations\n-         *\n-         * @param rc\n-         *          return code\n-         * @param ctx\n-         *          context object\n-         */\n-        void recoverComplete(int rc, Object ctx);\n-    }\n-    \n-    public interface IsClosedCallback {\n-        /**\n-         * Callback definition for isClosed operation\n-         *\n-         * @param rc\n-         *          return code\n-         * @param isClosed\n-         *          true if ledger is closed\n-         */\n-        void isClosedComplete(int rc, boolean isClosed, Object ctx);\n-    }\n-}"},{"sha":"c5be32d543da38655f09cff31a15cfe124e73e4f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"removed","additions":0,"deletions":364,"changes":364,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -1,364 +0,0 @@\n-package org.apache.bookkeeper.client;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-import java.lang.Exception;\n-\n-/**\n- * Class the enumerates all the possible error conditions\n- *\n- */\n-\n-@SuppressWarnings(\"serial\")\n-public abstract class BKException extends Exception {\n-\n-    private int code;\n-\n-    BKException(int code) {\n-        this.code = code;\n-    }\n-\n-    /**\n-     * Create an exception from an error code\n-     * @param code return error code\n-     * @return correponding exception\n-     */\n-    public static BKException create(int code) {\n-        switch (code) {\n-        case Code.ReadException:\n-            return new BKReadException();\n-        case Code.QuorumException:\n-            return new BKQuorumException();\n-        case Code.NoBookieAvailableException:\n-            return new BKBookieException();\n-        case Code.DigestNotInitializedException:\n-            return new BKDigestNotInitializedException();\n-        case Code.DigestMatchException:\n-            return new BKDigestMatchException();\n-        case Code.NotEnoughBookiesException:\n-            return new BKNotEnoughBookiesException();\n-        case Code.NoSuchLedgerExistsException:\n-            return new BKNoSuchLedgerExistsException();\n-        case Code.BookieHandleNotAvailableException:\n-            return new BKBookieHandleNotAvailableException();\n-        case Code.ZKException:\n-            return new ZKException();\n-        case Code.MetaStoreException:\n-            return new MetaStoreException();\n-        case Code.LedgerRecoveryException:\n-            return new BKLedgerRecoveryException();\n-        case Code.LedgerClosedException:\n-            return new BKLedgerClosedException();\n-        case Code.WriteException:\n-            return new BKWriteException();\n-        case Code.NoSuchEntryException:\n-            return new BKNoSuchEntryException();\n-        case Code.IncorrectParameterException:\n-            return new BKIncorrectParameterException();\n-        case Code.InterruptedException:\n-            return new BKInterruptedException();\n-        case Code.ProtocolVersionException:\n-            return new BKProtocolVersionException();\n-        case Code.MetadataVersionException:\n-            return new BKMetadataVersionException();\n-        case Code.LedgerFencedException:\n-            return new BKLedgerFencedException();\n-        case Code.UnauthorizedAccessException:\n-            return new BKUnauthorizedAccessException();\n-        case Code.UnclosedFragmentException:\n-            return new BKUnclosedFragmentException();\n-        case Code.WriteOnReadOnlyBookieException:\n-            return new BKWriteOnReadOnlyBookieException();\n-        case Code.ReplicationException:\n-            return new BKReplicationException();\n-        case Code.ClientClosedException:\n-            return new BKClientClosedException();\n-        case Code.IllegalOpException:\n-            return new BKIllegalOpException();\n-        default:\n-            return new BKUnexpectedConditionException();\n-        }\n-    }\n-\n-    /**\n-     * List of return codes\n-     *\n-     */\n-    public interface Code {\n-        int OK = 0;\n-        int ReadException = -1;\n-        int QuorumException = -2;\n-        int NoBookieAvailableException = -3;\n-        int DigestNotInitializedException = -4;\n-        int DigestMatchException = -5;\n-        int NotEnoughBookiesException = -6;\n-        int NoSuchLedgerExistsException = -7;\n-        int BookieHandleNotAvailableException = -8;\n-        int ZKException = -9;\n-        int LedgerRecoveryException = -10;\n-        int LedgerClosedException = -11;\n-        int WriteException = -12;\n-        int NoSuchEntryException = -13;\n-        int IncorrectParameterException = -14;\n-        int InterruptedException = -15;\n-        int ProtocolVersionException = -16;\n-        int MetadataVersionException = -17;\n-        int MetaStoreException = -18;\n-        int ClientClosedException = -19;\n-\n-        int IllegalOpException = -100;\n-        int LedgerFencedException = -101;\n-        int UnauthorizedAccessException = -102;\n-        int UnclosedFragmentException = -103;\n-        int WriteOnReadOnlyBookieException = -104;\n-\n-        // generic exception code used to propagate in replication pipeline\n-        int ReplicationException = -200;\n-\n-        // For all unexpected error conditions\n-        int UnexpectedConditionException = -999;\n-    }\n-\n-    public void setCode(int code) {\n-        this.code = code;\n-    }\n-\n-    public int getCode() {\n-        return this.code;\n-    }\n-\n-    public static String getMessage(int code) {\n-        switch (code) {\n-        case Code.OK:\n-            return \"No problem\";\n-        case Code.ReadException:\n-            return \"Error while reading ledger\";\n-        case Code.QuorumException:\n-            return \"Invalid quorum size on ensemble size\";\n-        case Code.NoBookieAvailableException:\n-            return \"Invalid quorum size on ensemble size\";\n-        case Code.DigestNotInitializedException:\n-            return \"Digest engine not initialized\";\n-        case Code.DigestMatchException:\n-            return \"Entry digest does not match\";\n-        case Code.NotEnoughBookiesException:\n-            return \"Not enough non-faulty bookies available\";\n-        case Code.NoSuchLedgerExistsException:\n-            return \"No such ledger exists\";\n-        case Code.BookieHandleNotAvailableException:\n-            return \"Bookie handle is not available\";\n-        case Code.ZKException:\n-            return \"Error while using ZooKeeper\";\n-        case Code.MetaStoreException:\n-            return \"Error while using MetaStore\";\n-        case Code.LedgerRecoveryException:\n-            return \"Error while recovering ledger\";\n-        case Code.LedgerClosedException:\n-            return \"Attempt to write to a closed ledger\";\n-        case Code.WriteException:\n-            return \"Write failed on bookie\";\n-        case Code.NoSuchEntryException:\n-            return \"No such entry\";\n-        case Code.IncorrectParameterException:\n-            return \"Incorrect parameter input\";\n-        case Code.InterruptedException:\n-            return \"Interrupted while waiting for permit\";\n-        case Code.ProtocolVersionException:\n-            return \"Bookie protocol version on server is incompatible with client\";\n-        case Code.MetadataVersionException:\n-            return \"Bad ledger metadata version\";\n-        case Code.LedgerFencedException:\n-            return \"Ledger has been fenced off. Some other client must have opened it to read\";\n-        case Code.UnauthorizedAccessException:\n-            return \"Attempted to access ledger using the wrong password\";\n-        case Code.UnclosedFragmentException:\n-            return \"Attempting to use an unclosed fragment; This is not safe\";\n-        case Code.WriteOnReadOnlyBookieException:\n-            return \"Attempting to write on ReadOnly bookie\";\n-        case Code.ReplicationException:\n-            return \"Errors in replication pipeline\";\n-        case Code.ClientClosedException:\n-            return \"BookKeeper client is closed\";\n-        case Code.IllegalOpException:\n-            return \"Invalid operation\";\n-        default:\n-            return \"Unexpected condition\";\n-        }\n-    }\n-\n-    public static class BKReadException extends BKException {\n-        public BKReadException() {\n-            super(Code.ReadException);\n-        }\n-    }\n-\n-    public static class BKNoSuchEntryException extends BKException {\n-        public BKNoSuchEntryException() {\n-            super(Code.NoSuchEntryException);\n-        }\n-    }\n-\n-    public static class BKQuorumException extends BKException {\n-        public BKQuorumException() {\n-            super(Code.QuorumException);\n-        }\n-    }\n-\n-    public static class BKBookieException extends BKException {\n-        public BKBookieException() {\n-            super(Code.NoBookieAvailableException);\n-        }\n-    }\n-\n-    public static class BKDigestNotInitializedException extends BKException {\n-        public BKDigestNotInitializedException() {\n-            super(Code.DigestNotInitializedException);\n-        }\n-    }\n-\n-    public static class BKDigestMatchException extends BKException {\n-        public BKDigestMatchException() {\n-            super(Code.DigestMatchException);\n-        }\n-    }\n-\n-    public static class BKIllegalOpException extends BKException {\n-        public BKIllegalOpException() {\n-            super(Code.IllegalOpException);\n-        }\n-    }\n-\n-    public static class BKUnexpectedConditionException extends BKException {\n-        public BKUnexpectedConditionException() {\n-            super(Code.UnexpectedConditionException);\n-        }\n-    }\n-\n-    public static class BKNotEnoughBookiesException extends BKException {\n-        public BKNotEnoughBookiesException() {\n-            super(Code.NotEnoughBookiesException);\n-        }\n-    }\n-\n-    public static class BKWriteException extends BKException {\n-        public BKWriteException() {\n-            super(Code.WriteException);\n-        }\n-    }\n-\n-    public static class BKProtocolVersionException extends BKException {\n-        public BKProtocolVersionException() {\n-            super(Code.ProtocolVersionException);\n-        }\n-    }\n-\n-    public static class BKMetadataVersionException extends BKException {\n-        public BKMetadataVersionException() {\n-            super(Code.MetadataVersionException);\n-        }\n-    }\n-\n-    public static class BKNoSuchLedgerExistsException extends BKException {\n-        public BKNoSuchLedgerExistsException() {\n-            super(Code.NoSuchLedgerExistsException);\n-        }\n-    }\n-\n-    public static class BKBookieHandleNotAvailableException extends BKException {\n-        public BKBookieHandleNotAvailableException() {\n-            super(Code.BookieHandleNotAvailableException);\n-        }\n-    }\n-\n-    public static class ZKException extends BKException {\n-        public ZKException() {\n-            super(Code.ZKException);\n-        }\n-    }\n-\n-    public static class MetaStoreException extends BKException {\n-        public MetaStoreException() {\n-            super(Code.MetaStoreException);\n-        }\n-    }\n-\n-    public static class BKLedgerRecoveryException extends BKException {\n-        public BKLedgerRecoveryException() {\n-            super(Code.LedgerRecoveryException);\n-        }\n-    }\n-\n-    public static class BKLedgerClosedException extends BKException {\n-        public BKLedgerClosedException() {\n-            super(Code.LedgerClosedException);\n-        }\n-    }\n-\n-    public static class BKIncorrectParameterException extends BKException {\n-        public BKIncorrectParameterException() {\n-            super(Code.IncorrectParameterException);\n-        }\n-    }\n-\n-    public static class BKInterruptedException extends BKException {\n-        public BKInterruptedException() {\n-            super(Code.InterruptedException);\n-        }\n-    }\n-\n-    public static class BKLedgerFencedException extends BKException {\n-        public BKLedgerFencedException() {\n-            super(Code.LedgerFencedException);\n-        }\n-    }\n-\n-    public static class BKUnauthorizedAccessException extends BKException {\n-        public BKUnauthorizedAccessException() {\n-            super(Code.UnauthorizedAccessException);\n-        }\n-    }\n-\n-    public static class BKUnclosedFragmentException extends BKException {\n-        public BKUnclosedFragmentException() {\n-            super(Code.UnclosedFragmentException);\n-        }\n-    }\n-\n-    public static class BKWriteOnReadOnlyBookieException extends BKException {\n-        public BKWriteOnReadOnlyBookieException() {\n-            super(Code.WriteOnReadOnlyBookieException);\n-        }\n-    }\n-\n-    public static class BKReplicationException extends BKException {\n-        public BKReplicationException() {\n-            super(Code.ReplicationException);\n-        }\n-    }\n-\n-    public static class BKClientClosedException extends BKException {\n-        public BKClientClosedException() {\n-            super(Code.ClientClosedException);\n-        }\n-    }\n-\n-}"},{"sha":"49d8e5915d762dc2971d70dbf28517ffbe705e10","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"18a801cba914b2f6ce25af904a6d4d44ce9e0b2f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"removed","additions":0,"deletions":902,"changes":902,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e245ea310070cf33099ec803b80d742f298b184c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"204f0dc8c19307efd5c7996a2f7da628c22225bc","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"removed","additions":0,"deletions":325,"changes":325,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2f125fb166cae2717c404a90f16d12842e2b7138","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookiesListener.java","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookiesListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookiesListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookiesListener.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9194bf9c32c21994c40a8c7601485fbbda83fa9e","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5f2d2c31c7decee7f9acdd45c0ac2e4161846f90","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","status":"removed","additions":0,"deletions":93,"changes":93,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2753680f23a556109fdec840f9fa01b7e599873c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"removed","additions":0,"deletions":191,"changes":191,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6dba0ccc6b9adfc7aae9b022ed4684476eb206d2","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"removed","additions":0,"deletions":90,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a1d8ce38f766a8a8e399935433eaff500b59785b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"3f2580fd2d16de8cd716dad0e5fae608ebd888ac","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"removed","additions":0,"deletions":273,"changes":273,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"fe223af959228c34482ce9c96b25c4559858494b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"removed","additions":0,"deletions":152,"changes":152,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f8caa5be03777deff259eaf24e8ae50e46a2adc9","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"removed","additions":0,"deletions":90,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"91f897c45f1f852a7067870ef312a6520f6ee2ca","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"removed","additions":0,"deletions":82,"changes":82,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6aadb8aaa1fc77cb12731fa24e1087bc3e67dda4","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4501524ae849472ae8405afdbc940f4ad0341a89","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"removed","additions":0,"deletions":421,"changes":421,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7204d6cbb2795f5503a3ad8a38407bbc5cd84ee6","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"removed","additions":0,"deletions":1190,"changes":1190,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a20f34ade6af14e2b892afb243827e796b78329b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"removed","additions":0,"deletions":528,"changes":528,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4df89ea24bf3604d6aa113c73c53ca4e01944d27","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"removed","additions":0,"deletions":205,"changes":205,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7ed7aa251751f78f691e46be9d16fe605c33ca33","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"removed","additions":0,"deletions":190,"changes":190,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"df09d527741b5c43ba7e3dbccf7ccdc763968ee0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"removed","additions":0,"deletions":86,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1b92d093792b56ae7ebb55c7f3debf8b6cd61055","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"removed","additions":0,"deletions":212,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e548f3d456a2a1d9d0ace577a870c8a99bb65912","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"removed","additions":0,"deletions":408,"changes":408,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7b15d9e6e8a17d19d495245382dcbe8d07e6b584","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","status":"removed","additions":0,"deletions":572,"changes":572,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"af21f442dba35d8761247d9766a6a1f7a38a89f0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"removed","additions":0,"deletions":132,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8de4092b8d9e289a9702e2f8f2fb40e5c9bee329","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"removed","additions":0,"deletions":168,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b34ff754f924fd989a9cea4cc0783cde5fbaff99","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"removed","additions":0,"deletions":109,"changes":109,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"888e46d00a8505de08aa8b7cf6ef6352f403d3f6","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","status":"removed","additions":0,"deletions":85,"changes":85,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"01b81c9ff53c829550d4f906a5182d64638302dd","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TryReadLastConfirmedOp.java","status":"removed","additions":0,"deletions":107,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TryReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TryReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TryReadLastConfirmedOp.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"3ec2b5a1c305a8807d1299b36b99af51b022ab71","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"removed","additions":0,"deletions":237,"changes":237,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2f4127a96980c2a893f2e9d6461481f0b87c3fe6","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"removed","additions":0,"deletions":511,"changes":511,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"361669043693c6a5ea19f93bf5a153ba79d3c138","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/Configurable.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"03b3be49ba96fad8f6065af8e670aad7cf15aa37","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"removed","additions":0,"deletions":1361,"changes":1361,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5d4f1201517bd46f90face4752d3d593de3913d1","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"39889168ab0eb19af71c9edfbccef99e53467d99","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0fc8afee8658ef747e100ab53c23f6514e782517","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"removed","additions":0,"deletions":482,"changes":482,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a8731124807ff59eab8566e91376e8d1a1937e7a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","status":"removed","additions":0,"deletions":226,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2bc42580f4ae87784f44910009821c5c77553e9c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"removed","additions":0,"deletions":166,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"db16d26b1672ce4f549d9d4010307e7924475db8","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7f2df736bc1e511f0c4eafcfb0d9ede140f8e84c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"removed","additions":0,"deletions":476,"changes":476,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b843e994af49da314d17204110a191968e685220","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","status":"removed","additions":0,"deletions":93,"changes":93,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d358ffbec2ecadef0e7becc4ff3f28d96ec4b982","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","status":"removed","additions":0,"deletions":244,"changes":244,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"72290286e1b0227db0b712393411b34a34db0731","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","status":"removed","additions":0,"deletions":204,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7c3cf5c994c7a8a61e8ad1cea70bab9c0c2720ec","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"removed","additions":0,"deletions":252,"changes":252,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d006895e9e4eb7b7afb4fded35e7325d47e18783","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","status":"removed","additions":0,"deletions":119,"changes":119,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2510b89d749f3123f0ea225b3396d1e84e28f292","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","status":"removed","additions":0,"deletions":733,"changes":733,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a4600bc5f087df057e755c621715251e1637f3e5","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"removed","additions":0,"deletions":630,"changes":630,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7fdb8bdb22897eb4059534914505487d895a5f61","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java","status":"removed","additions":0,"deletions":69,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkVersion.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7358504f1abdb62c9e63c132b989fbce53043627","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetaStore.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a7cc953a33c59dc946af2786c1399d9787463103","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreCursor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"03f1c600566dd6f42ab8fc661454bf1588e0a544","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java","status":"removed","additions":0,"deletions":380,"changes":380,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a1350dc7d77b18efc32b6460cc1cae85ce9cbffa","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java","status":"removed","additions":0,"deletions":214,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"182387877f5ed058e018f9127a5d60364010b95a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSWatchedEvent.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSWatchedEvent.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSWatchedEvent.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSWatchedEvent.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"29fd3294468598d497e40b74768330a103468925","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java","status":"removed","additions":0,"deletions":79,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"78c709c15fe0c4cf158a695c98bf256fd7ce10ce","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java","status":"removed","additions":0,"deletions":25,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f4f9d65a1292f517cd2d37ec850cb4a25cb851f9","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c85b36ad4704d9f42bbb555cc85033697f1ee95a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bedbf8b082a5f801781b29c9d2fcd8a408362fe9","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java","status":"removed","additions":0,"deletions":33,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"036cdb6299ad655bb511b149c0e7f08b5d355508","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java","status":"removed","additions":0,"deletions":104,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"735931e92fc3a7a6884a393b442d5a7d0cfdc2ed","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java","status":"removed","additions":0,"deletions":193,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c874b3f3deaa4e235305c3e74585014192d0a9ac","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java","status":"removed","additions":0,"deletions":70,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ab577f1634dd5d320a1c9c581d40243189940b7d","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java","status":"removed","additions":0,"deletions":140,"changes":140,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4c6ebc9bcee6e05b1e44978dde051cb2b84f21f8","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreWatcher.java","status":"removed","additions":0,"deletions":22,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreWatcher.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9424bf93ea0ebbd8703b86cae9f646b51481288e","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java","status":"removed","additions":0,"deletions":156,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"cba1f7ebdad4d7ce36c5e12d7c30da49ccfa089a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","status":"removed","additions":0,"deletions":142,"changes":142,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"78773330188f2e511ef282bc04d96ddbe2ffe5e0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"96acbc2409fa39ee5c0a7da7f1ef734b27470c42","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"12a3f1ad987d79855bf20c59d7ef91d23569db9a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CommonConfigurationKeys.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a5dce939076ce7468b053c0b82baff50743a8ae0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","status":"removed","additions":0,"deletions":340,"changes":340,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"35f9a36da4cfd9e4f49ca283300ee8a1ccad7215","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bcc880c66ea91f9339a31c0d3422824f248ef456","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"26abc96159f85bbf0fddaaaee0a984a161ddbdce","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","status":"removed","additions":0,"deletions":877,"changes":877,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f11e0a76a2df38b00244458efddf990838f68d96","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f1a4b85cec3edc6563de27b1063abc901a521f41","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","status":"removed","additions":0,"deletions":186,"changes":186,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1671cc888b7ffa77e683851fd9949f072b9a71e2","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","status":"removed","additions":0,"deletions":264,"changes":264,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d785d29eef71b4c5388a8cf8abdf4dfaca04a095","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","status":"removed","additions":0,"deletions":42,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9aa80a06ae95d05db91f64efc9a5448f09c26ae0","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java","status":"removed","additions":0,"deletions":248,"changes":248,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d69d4a812bc16e4d51256ae7bbbf0712d257cc76","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"removed","additions":0,"deletions":358,"changes":358,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b623998aea07f564d4fc3bf141e8b890d8d70634","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"removed","additions":0,"deletions":199,"changes":199,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6ece56ea329504af677d86f650abccc02c2a94bc","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"removed","additions":0,"deletions":330,"changes":330,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4dd26d6e6776a2c505da7d8bf0fff6056ff7b863","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"removed","additions":0,"deletions":346,"changes":346,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"3c5f128497eabf3eecda74e3c50d73ebabab0dc2","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9fec15fa6bc0e3a0c5cb62c7b160be9a90b7094b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"removed","additions":0,"deletions":193,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bf5f438ac28647d885e0630fe3505ba93278533b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"removed","additions":0,"deletions":397,"changes":397,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"afb763e93e116e6b03cc35dc44524685e649757a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","status":"removed","additions":0,"deletions":82,"changes":82,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"054309fc5ed33861bbb2a7f220d65ae258ea622c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java","status":"removed","additions":0,"deletions":53,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e6e7802ddd3cc1c5f5c55047d606326621219db5","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"57d350328e11dffd224382828ab26abcaafaa8b6","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","status":"removed","additions":0,"deletions":4774,"changes":4774,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"65d5444d10dfd2d372872137bdf8f01dcc6de05d","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","status":"removed","additions":0,"deletions":4088,"changes":4088,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"920515ba098f078bb067034db267d98101b5301c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","status":"removed","additions":0,"deletions":93,"changes":93,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b247616839d306e645899fdb7f6724911547ae24","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","status":"removed","additions":0,"deletions":76,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ebff52608470235d93f5ca984653b38f81665631","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"deef9f48f66819280cf496feabaeb08b1564faa7","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"removed","additions":0,"deletions":972,"changes":972,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bd45e9209d6372d68794c59a637f36bc6c56892d","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","status":"removed","additions":0,"deletions":37,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"81b3ba7b10edb226187ed464e7812fb210f168c7","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","status":"removed","additions":0,"deletions":59,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"385cf022b7b362efdac561fc8bbd8a8e8fc1ec6b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","status":"removed","additions":0,"deletions":133,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"03517789625a5c17e474dec00579a6d69b6f6d82","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","status":"removed","additions":0,"deletions":164,"changes":164,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"651c11834a289b19575058713006474dd8247f0f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4920bb9dcddda46db9abf625219c7661740ae890","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ServerStats.java","status":"removed","additions":0,"deletions":101,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ServerStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ServerStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ServerStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"719c937dea9baefc44edd87b85026ef37439b25f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","status":"removed","additions":0,"deletions":99,"changes":99,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ebb9ebe98be14ada2f6083408b82c29b76b21155","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","status":"removed","additions":0,"deletions":151,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4e6e3fb3f9adcdce76a6150ba06ff9247c37453f","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"removed","additions":0,"deletions":556,"changes":556,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c4fb77dffa4127f7208450d1ca25fd693e18fc56","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","status":"removed","additions":0,"deletions":386,"changes":386,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"dd08f71b6274e9ec22f9d8770a7779f6fceca095","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","status":"removed","additions":0,"deletions":296,"changes":296,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1b4efafc1f40c5769fb4c9515aecc666e0d7d755","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","status":"removed","additions":0,"deletions":135,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"77625c30c2b45e64e884e5cf7d6f4e816f7e60f3","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationEnableCb.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"32a03e224e78c44f4d69e3c18e4f1b96b2c21374","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","status":"removed","additions":0,"deletions":78,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9e280a79bdde133e0433a1d7f7514a1a0bea656a","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationStats.java","status":"removed","additions":0,"deletions":35,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"02154e580512d2e3e3577ba3722a6925d4b98bdb","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"removed","additions":0,"deletions":465,"changes":465,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7e01bdca2512b14c485b2aa9135b64a564564fd1","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","status":"removed","additions":0,"deletions":174,"changes":174,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"05d390b61eb159e873f96097fc10bb7debf8d4d6","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"54e07c3df1e445f03fa72108c3d72267c554ac07","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"cc86f07f5fc41d4a686d20c62abd97c6a5784479","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ad805cfdee98ca055e0c6f4dea19e28a59188b00","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DaemonThreadFactory.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DaemonThreadFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DaemonThreadFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DaemonThreadFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"75902c9e8c93f874b589357e94d7d98e7c9e7310","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","status":"removed","additions":0,"deletions":208,"changes":208,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1549a9f045e5af057ace60b2f49ff5e615287f07","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/EntryFormatter.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/EntryFormatter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/EntryFormatter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/EntryFormatter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e770bb09c914906ee3e4d7ac1e81250548b96054","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java","status":"removed","additions":0,"deletions":667,"changes":667,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5e8559461e33f733701e8482b5403e8d3c0c7a57","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","status":"removed","additions":0,"deletions":104,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4897883036c0c7fb8e96501d72fae6f48ead06ee","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"removed","additions":0,"deletions":263,"changes":263,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b289bc4577c58dab1ee87c2d27a5a4a5a7327390","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"32571fa59f8d7c7715d6b2bc8459c8a45b33a99c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","status":"removed","additions":0,"deletions":76,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"24488425b97048ef98335605e73d481cc9dda3e2","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/NativeIO.java","status":"removed","additions":0,"deletions":119,"changes":119,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/NativeIO.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/NativeIO.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/NativeIO.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"597c88662b8e799ab4f2379f84d1a4dd62840a5d","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"removed","additions":0,"deletions":200,"changes":200,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4f3bdb4d93171176947c29553bafdd4095f4ab59","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java","status":"removed","additions":0,"deletions":152,"changes":152,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ReflectionUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b3b5d368ca1c4d4bd3073c29ccd28d9a69e174c1","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5dbfc381359acb9deda890db1b312e4f02dedf22","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","status":"removed","additions":0,"deletions":677,"changes":677,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a665476b89ef74341c36892b02ad7eca5d4a6b65","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"43a5fc9a5d1dbf86d90e83867c4244bd5eba567d","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringEntryFormatter.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringEntryFormatter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringEntryFormatter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringEntryFormatter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bea03721dae126f4bb9c15bee502a30c221c97d7","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"22c56e998a52822e798ff680b2069949a498bac1","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Tool.java","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Tool.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Tool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Tool.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1109da2b71baf69ae14e9eb69907686055a54d66","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZeroBuffer.java","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZeroBuffer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZeroBuffer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZeroBuffer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9608240c70c01ac7ab1805f7aa1ee999cbc76a4c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","status":"removed","additions":0,"deletions":257,"changes":257,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"39ad3e5396df504d8038ddbadc18eae8afa0f5e7","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Version.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7e8f1c96f4e8081d37c44508c577ed339be6a933","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/versioning/Versioned.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7fe237a900a0c53b9387f23c214180e868301b36","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/BoundExponentialBackoffRetryPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"dab7aa719325743ea8bfe54543cb5511c085943c","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ExponentialBackoffRetryPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a4269fbe7193aaa2ba3c957f3eaf89b6b6a99245","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/RetryPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a479a369039f210afe1c1aa36c43b0ca6defd6e4","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","status":"removed","additions":0,"deletions":1046,"changes":1046,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"707b8420cdd11fc1cf8a2b025d8bca090520d53b","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java","status":"removed","additions":0,"deletions":133,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperWatcherBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"871612ef5cade9c7088d300e93235a610973ffc5","filename":"branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java","status":"removed","additions":0,"deletions":147,"changes":147,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooWorker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"56ba5817577e260fe94d188d0f537d0543b5c926","filename":"branch-4.3/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","status":"removed","additions":0,"deletions":122,"changes":122,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"67623ac614880b11684afff624e8f5b0551f1854","filename":"branch-4.3/bookkeeper-server/src/main/proto/DataFormats.proto","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/proto/DataFormats.proto","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/proto/DataFormats.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/proto/DataFormats.proto?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"129943423fb222d7a9fa659efe3007f3692d0a3b","filename":"branch-4.3/bookkeeper-server/src/main/resources/LICENSE.bin.txt","status":"removed","additions":0,"deletions":302,"changes":302,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/resources/LICENSE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/resources/LICENSE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/resources/LICENSE.bin.txt?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c70651426b08f2825ce432662275d1774c3de297","filename":"branch-4.3/bookkeeper-server/src/main/resources/NOTICE.bin.txt","status":"removed","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/resources/NOTICE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/resources/NOTICE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/resources/NOTICE.bin.txt?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bff9431175c62fbee3c41423a264642e153a68da","filename":"branch-4.3/bookkeeper-server/src/main/resources/findbugsExclude.xml","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/main/resources/findbugsExclude.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2e0f18f1bca06d32fc5c6b9eb02fa5e506c41154","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieAccessor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f19583f51fa9e82b56727d5d2c49c6873d6ea8c4","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","status":"removed","additions":0,"deletions":429,"changes":429,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0d6e592b629b96764255df74e3e4097d741e01fd","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","status":"removed","additions":0,"deletions":766,"changes":766,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"17460435ab1a9a25b0cc162d4ffd49f96130c09c","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieShutdownTest.java","status":"removed","additions":0,"deletions":144,"changes":144,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieShutdownTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieShutdownTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieShutdownTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"dfcbcf42eb3a818ee7b35bab23c30225c816cc3a","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieThreadTest.java","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieThreadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieThreadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieThreadTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ef4cea8d93f0443ee49f7e9df82ff79711ae1497","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","status":"removed","additions":0,"deletions":564,"changes":564,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"27577d2924c33886a875eb952c8031bbb072225e","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java","status":"removed","additions":0,"deletions":482,"changes":482,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"51b25bc297d90cb20cd95f07c0ad7afe1c4c957b","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CreateNewLogTest.java","status":"removed","additions":0,"deletions":102,"changes":102,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CreateNewLogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CreateNewLogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CreateNewLogTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8f59b54495485c0152b1d3c3cb9fe6ad784d226c","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","status":"removed","additions":0,"deletions":223,"changes":223,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"151feaeb2dc9b5462afd29b1fd536b33e9aecf47","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/IndexCorruptionTest.java","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/IndexCorruptionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/IndexCorruptionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/IndexCorruptionTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b62c69508379f99df5506904bb2598c91de87b00","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"removed","additions":0,"deletions":455,"changes":455,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"fb48f3f259dff26cb63a0704e1d17f556aa4a96f","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestLedgerDirsManager.java","status":"removed","additions":0,"deletions":80,"changes":80,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestLedgerDirsManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestLedgerDirsManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestLedgerDirsManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d947dff97514d2177a72a0d9224c277b8bec9ed6","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","status":"removed","additions":0,"deletions":353,"changes":353,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5eaf224a42e67bd1cba0e14365a95d6b10609522","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpdateCookieCmdTest.java","status":"removed","additions":0,"deletions":216,"changes":216,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpdateCookieCmdTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpdateCookieCmdTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpdateCookieCmdTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"64d994cf992e40665fe8d365c7dbdb8b72aa80db","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","status":"removed","additions":0,"deletions":264,"changes":264,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"89790f66feca1e4098b7be717c8b37fc210fe274","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","status":"removed","additions":0,"deletions":552,"changes":552,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"364e48eb6e5e1eba3d2d2aa6f80ac24a93feeb47","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"removed","additions":0,"deletions":243,"changes":243,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b394dc2625267e13c37e4662dcce0e21807ba361","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","status":"removed","additions":0,"deletions":71,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f18e159d6be69128475c9c6d95c5ff16200ccd12","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"removed","additions":0,"deletions":996,"changes":996,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7b77c485555047c5aa466326e1ebdd8c0bccc173","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","status":"removed","additions":0,"deletions":232,"changes":232,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"dc43b2c37cdb756d39b9a9c32c9dff731912053d","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"eef56b07f0f735e0a094e80523aae2778ba29130","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","status":"removed","additions":0,"deletions":229,"changes":229,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9af527a36408d3af93e3a16bb12f861c8ea70295","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f54cde1048db8865bbda7db978618744c7313066","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","status":"removed","additions":0,"deletions":422,"changes":422,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d34c0648f9e0ee9251994de9e07f712f4260c6b2","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ListLedgersTest.java","status":"removed","additions":0,"deletions":111,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ListLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ListLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ListLedgersTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ce9aab91b4b25f95578ac4b58d1b054e8bcce3fb","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"521d1e3cb33abcffd4fe7c4090bfffd34aa26ff4","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","status":"removed","additions":0,"deletions":211,"changes":211,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ba51175e2fde93203ebd3b60761a83484ec157a1","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"removed","additions":0,"deletions":393,"changes":393,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"eb61c2120790af7058997dfcd9942240b6a1d039","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"removed","additions":0,"deletions":464,"changes":464,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e4f744f1baf113cf537f5cfbdc7467af9e448c2e","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","status":"removed","additions":0,"deletions":342,"changes":342,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b5f5e322af75b7139aa6686da2cb9bdb4a42d412","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","status":"removed","additions":0,"deletions":286,"changes":286,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"96c5fa872a9feb459cf7d34b7fdf160d68ba96cc","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","status":"removed","additions":0,"deletions":93,"changes":93,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2a6c71d3a57a1f0ec69142e60278b8a70c705939","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"removed","additions":0,"deletions":341,"changes":341,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ac0afb6e075b803ef21ee97f65302a8c27ae8ade","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestTryReadLastConfirmed.java","status":"removed","additions":0,"deletions":188,"changes":188,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestTryReadLastConfirmed.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestTryReadLastConfirmed.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestTryReadLastConfirmed.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"eb833a3e0d554ff223024e5ada540d4911d91a16","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9522ae12e2230a95135f0ae123029f0a16031c0f","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java","status":"removed","additions":0,"deletions":35,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/conf/TestBKConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"19aab44e772d5ecaa83acf9ebc83d6f54ac56f13","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"removed","additions":0,"deletions":274,"changes":274,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"18a818aeaab3c1709a0dce06c7bece06bc171f96","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","status":"removed","additions":0,"deletions":150,"changes":150,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1a581866ab26361a9d1f0baf8ae3fbf6c0936ce0","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerIteratorTest.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerIteratorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerIteratorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerIteratorTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b95d2db4574c5c1a7f6c60907b7e6f12c511e84f","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8fd40c9e57e25de43ca35f92b6546bff5e837a05","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","status":"removed","additions":0,"deletions":324,"changes":324,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"366735652729cc096ad1d7121cc1ce8c5aed7f90","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestZkVersion.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"51201e999ee05328861c1d8245c805bd7f6c96cf","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java","status":"removed","additions":0,"deletions":59,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4c061abd485038537298318cff85126ea9dee64e","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8b52bf5c18135ddb516e0837c39835f5e09b8fc5","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","status":"removed","additions":0,"deletions":646,"changes":646,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"3aed8cb0c1b838b5580d80c28c6d8c0dcc52d9f4","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBKStats.java","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBKStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBKStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBKStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9b90887f63e44e884341635dcdfb7ff29ea0e053","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDeathwatcher.java","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDeathwatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDeathwatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDeathwatcher.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"675c2fd564bce54f97c39d6cb03746205a09d4ac","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"removed","additions":0,"deletions":280,"changes":280,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6fbfdb0a4c535b23f7aebc576bbd0276b970eab2","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"removed","additions":0,"deletions":287,"changes":287,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b1a53e598df7ed0cad3dfa2785bb52f708bad35e","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"removed","additions":0,"deletions":403,"changes":403,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"91aae77fe2e00487c929b69cfd1be416f6e0c67d","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicBookieCheckTest.java","status":"removed","additions":0,"deletions":124,"changes":124,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicBookieCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicBookieCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicBookieCheckTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"fd605a74370fc8fc9c541d9f1a8154453d1e6310","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","status":"removed","additions":0,"deletions":340,"changes":340,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1d4bb00b7ea348c4fa85038c2711a5d99f3af087","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java","status":"removed","additions":0,"deletions":75,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5a50568d2af234d4acbd877ac9419242cf02cb44","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AutoRecoveryMainTest.java","status":"removed","additions":0,"deletions":109,"changes":109,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AutoRecoveryMainTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AutoRecoveryMainTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AutoRecoveryMainTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"72fd11c55c97de80b49ad7e6a843f1711fbb92a5","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"removed","additions":0,"deletions":627,"changes":627,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2872397118ad0d9941d625bbc98ff0c9e0816131","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","status":"removed","additions":0,"deletions":232,"changes":232,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f8dc1c801af4f462653eae052c2d6badbb6d5af3","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/ReplicationTestUtil.java","status":"removed","additions":0,"deletions":59,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/ReplicationTestUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/ReplicationTestUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/ReplicationTestUtil.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e1ccf6895eba5f8c4ecffe3ab637cbd20bf902d2","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java","status":"removed","additions":0,"deletions":101,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ff1bb0f0574c6b18e8d3d5b3c748606b397c6729","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","status":"removed","additions":0,"deletions":763,"changes":763,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d47e4b1ed4cf6c050062b11a4c5cc2fb97a2ba08","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"removed","additions":0,"deletions":604,"changes":604,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"28eff34681b77e92de95ffc29959def33e4b6ca8","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","status":"removed","additions":0,"deletions":260,"changes":260,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"437f0aebeade22edd847840e9544c754447dbc07","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9662777b5201aca9d4ecb80ba7c3ec52470bad57","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"removed","additions":0,"deletions":566,"changes":566,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c860bef4bd0752d3945ddcb419cd8b219b88f2bf","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"removed","additions":0,"deletions":246,"changes":246,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2ece28dd2d2eec2f2fd8aa11221915b9c1eddc1f","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"removed","additions":0,"deletions":402,"changes":402,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a72bf578cddb3bd34526a9b1c107eabf541dff49","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","status":"removed","additions":0,"deletions":275,"changes":275,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4d29ff48d152d0335e764e018a32ac36c8dd142e","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"removed","additions":0,"deletions":1070,"changes":1070,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"93256a7c3dec8714b8c42dd3e41f2d23b60624db","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","status":"removed","additions":0,"deletions":107,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"98c5f10596f0cf568345673815cfeeb41ddcfe19","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"caf1c3d0c456821c583a36926d2be065da84de42","filename":"branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","status":"removed","additions":0,"deletions":184,"changes":184,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"}]}

