{"sha":"5de01f700ede31f186f5d8d97afac382f1e45327","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1ZGUwMWY3MDBlZGUzMWYxODZmNWQ4ZDk3YWZhYzM4MmYxZTQ1MzI3","commit":{"author":{"name":"Ivan Kelly","email":"ivank@apache.org","date":"2014-12-05T16:51:16Z"},"committer":{"name":"Ivan Kelly","email":"ivank@apache.org","date":"2014-12-05T16:51:16Z"},"message":"BOOKKEEPER-799: Distribution schedule coverage sets don't take gaps in response lists into account when writequorum > ackquorum (ivank)","tree":{"sha":"a0b5fad6c793002630998ccf46c5bc3bb8fd8cf6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a0b5fad6c793002630998ccf46c5bc3bb8fd8cf6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5de01f700ede31f186f5d8d97afac382f1e45327","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5de01f700ede31f186f5d8d97afac382f1e45327","html_url":"https://github.com/apache/bookkeeper/commit/5de01f700ede31f186f5d8d97afac382f1e45327","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5de01f700ede31f186f5d8d97afac382f1e45327/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"78d6e49d4d6bf83ee53655e6198848b896c4239c","url":"https://api.github.com/repos/apache/bookkeeper/commits/78d6e49d4d6bf83ee53655e6198848b896c4239c","html_url":"https://github.com/apache/bookkeeper/commit/78d6e49d4d6bf83ee53655e6198848b896c4239c"}],"stats":{"total":135,"additions":102,"deletions":33},"files":[{"sha":"e3f5a87a8d75950ad0ceec39d7c243e607a0d9a6","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5de01f700ede31f186f5d8d97afac382f1e45327/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/5de01f700ede31f186f5d8d97afac382f1e45327/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=5de01f700ede31f186f5d8d97afac382f1e45327","patch":"@@ -16,6 +16,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-815: Ledger fence state is lost when the ledger file is evicted (Charles Xie via ivank)\n \n+      BOOKKEEPER-799: Distribution schedule coverage sets don't take gaps in response lists into account when writequorum > ackquorum (ivank)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-800: Expose whether a ledger is closed or not (ivank)"},{"sha":"82f300b6389e151549b9e81e73587c1d018d58a3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":16,"deletions":18,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/5de01f700ede31f186f5d8d97afac382f1e45327/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/5de01f700ede31f186f5d8d97afac382f1e45327/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=5de01f700ede31f186f5d8d97afac382f1e45327","patch":"@@ -67,33 +67,31 @@ public void removeBookie(int bookie) {\n     }\n \n     private class RRQuorumCoverageSet implements QuorumCoverageSet {\n-        // covered[i] is true if the quorum starting at bookie index i has been\n-        // covered by a recovery reply\n-        private boolean[] covered = null;\n-        private int numQuorumsUncovered;\n+        private final boolean[] covered = new boolean[ensembleSize];\n \n         private RRQuorumCoverageSet() {\n-            covered = new boolean[ensembleSize];\n-            numQuorumsUncovered = ensembleSize;\n+            for (int i = 0; i < covered.length; i++) {\n+                covered[i] = false;\n+            }\n         }\n \n         public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n-            if (numQuorumsUncovered == 0) {\n-                return true;\n-            }\n+            covered[bookieIndexHeardFrom] = true;\n \n-            for (int i = 0; i < ackQuorumSize; i++) {\n-                int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n-                if (!covered[quorumStartIndex]) {\n-                    covered[quorumStartIndex] = true;\n-                    numQuorumsUncovered--;\n-\n-                    if (numQuorumsUncovered == 0) {\n-                        return true;\n+            // now check if there are any write quorums, with |ackQuorum| nodes available\n+            for (int i = 0; i < ensembleSize; i++) {\n+                int nodesNotCovered = 0;\n+                for (int j = 0; j < writeQuorumSize; j++) {\n+                    int nodeIndex = (i + j) % ensembleSize;\n+                    if (!covered[nodeIndex]) {\n+                        nodesNotCovered++;\n                     }\n                 }\n+                if (nodesNotCovered >= ackQuorumSize) {\n+                    return false;\n+                }\n             }\n-            return false;\n+            return true;\n         }\n     }\n "},{"sha":"12e3c178a190cff3900f706a624c4992b7550dcd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","status":"modified","additions":84,"deletions":15,"changes":99,"blob_url":"https://github.com/apache/bookkeeper/blob/5de01f700ede31f186f5d8d97afac382f1e45327/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/5de01f700ede31f186f5d8d97afac382f1e45327/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java?ref=5de01f700ede31f186f5d8d97afac382f1e45327","patch":"@@ -22,6 +22,10 @@\n package org.apache.bookkeeper.client;\n \n import java.util.List;\n+import java.util.Set;\n+import java.util.HashSet;\n+import com.google.common.collect.Sets;\n+\n import org.junit.Test;\n import static org.junit.Assert.*;\n \n@@ -43,21 +47,86 @@ public void testDistributionSchedule() throws Exception {\n         assertFalse(\"Shouldn't ack yet\", ackSet.addBookieAndCheck(wSet.get(0)));\n         assertTrue(\"Should ack after 2 unique\", ackSet.addBookieAndCheck(wSet.get(2)));\n         assertTrue(\"Should still be acking\", ackSet.addBookieAndCheck(wSet.get(1)));\n+    }\n+\n+    /**\n+     * Test that coverage sets only respond as covered when it has\n+     * heard from enough bookies that no ack quorum can exist without these bookies.\n+     */\n+    @Test(timeout=60000)\n+    public void testCoverageSets() {\n+        int errors = 0;\n+        for (int e = 6; e > 0; e--) {\n+            for (int w = e; w > 0; w--) {\n+                for (int a = w; a > 0; a--) {\n+                    errors += testCoverageForConfiguration(e, w, a);\n+                }\n+            }\n+        }\n+        assertEquals(\"Should be no errors\", 0, errors);\n+    }\n+\n+    /**\n+     * Build a boolean array of which nodes have not responded\n+     * and thus are available to build a quorum.\n+     */\n+    boolean[] buildAvailable(int ensemble, Set<Integer> responses) {\n+        boolean[] available = new boolean[ensemble];\n+        for (int i = 0; i < ensemble; i++) {\n+            if (responses.contains(i)) {\n+                available[i] = false;\n+            } else {\n+                available[i] = true;\n+            }\n+        }\n+        return available;\n+    }\n+\n+    /**\n+     * Check whether it is possible for a write to reach\n+     * a quorum with a given set of nodes available\n+     */\n+    boolean canGetAckQuorum(int ensemble, int writeQuorum, int ackQuorum, boolean[] available) {\n+        for (int i = 0; i < ensemble; i++) {\n+            int count = 0;\n+            for (int j = 0; j < writeQuorum; j++) {\n+                if (available[(i+j)%ensemble]) {\n+                    count++;\n+                }\n+            }\n+            if (count >= ackQuorum) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private int testCoverageForConfiguration(int ensemble, int writeQuorum, int ackQuorum) {\n+        RoundRobinDistributionSchedule schedule = new RoundRobinDistributionSchedule(\n+                writeQuorum, ackQuorum, ensemble);\n+        Set<Integer> indexes = new HashSet<Integer>();\n+        for (int i = 0; i < ensemble; i++) {\n+            indexes.add(i);\n+        }\n+        Set<Set<Integer>> subsets = Sets.powerSet(indexes);\n+\n+        int errors = 0;\n+        for (Set<Integer> subset : subsets) {\n+            DistributionSchedule.QuorumCoverageSet covSet = schedule.getCoverageSet();\n+            boolean covSetSays = false;\n+            for (Integer i : subset) {\n+                covSetSays = covSet.addBookieAndCheckCovered(i);\n+            }\n \n-        DistributionSchedule.QuorumCoverageSet covSet = schedule.getCoverageSet();\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(0));\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(2));\n-        assertTrue(\"Should cover now\", covSet.addBookieAndCheckCovered(3));\n-\n-        covSet = schedule.getCoverageSet();\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(0));\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(1));\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(2));\n-        assertTrue(\"Should cover now\", covSet.addBookieAndCheckCovered(3));\n-\n-        covSet = schedule.getCoverageSet();\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(4));\n-        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(0));\n-        assertTrue(\"Should cover now\", covSet.addBookieAndCheckCovered(2));\n+            boolean[] nodesAvailable = buildAvailable(ensemble, subset);\n+            boolean canGetAck = canGetAckQuorum(ensemble, writeQuorum, ackQuorum, nodesAvailable);\n+            if (canGetAck == covSetSays) {\n+                LOG.error(\"e{}:w{}:a{} available {}    canGetAck {} covSetSays {}\",\n+                          new Object[] { ensemble, writeQuorum, ackQuorum,\n+                                         nodesAvailable, canGetAck, covSetSays });\n+                errors++;\n+            }\n+        }\n+        return errors;\n     }\n }"}]}

