{"sha":"5f25edeba1cbf5de489e1f5a3070188f0163b51b","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1ZjI1ZWRlYmExY2JmNWRlNDg5ZTFmNWEzMDcwMTg4ZjAxNjNiNTFi","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T11:20:54Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T11:20:54Z"},"message":"BOOKKEEPER-236: Benchmarking improvements from latest round of benchmarking (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1336100 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dd4cba52c820af66bb97474cc6439ef985ce9d96","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dd4cba52c820af66bb97474cc6439ef985ce9d96"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b","html_url":"https://github.com/apache/bookkeeper/commit/5f25edeba1cbf5de489e1f5a3070188f0163b51b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"d368d86e287ef982fa70e069001e30124ee22b48","url":"https://api.github.com/repos/apache/bookkeeper/commits/d368d86e287ef982fa70e069001e30124ee22b48","html_url":"https://github.com/apache/bookkeeper/commit/d368d86e287ef982fa70e069001e30124ee22b48"}],"stats":{"total":727,"additions":473,"deletions":254},"files":[{"sha":"f7309bb07d4c72c5df502c2b61e186fd789a1b6d","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -173,6 +173,8 @@ Trunk (unreleased changes)\n       bookkeeper-benchmark/\n \tBOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n \n+\tBOOKKEEPER-236: Benchmarking improvements from latest round of benchmarking (ivank via fpj)\n+\n Release 4.0.0 - 2011-11-30\n \n   Non-backward compatible changes:"},{"sha":"e8e837bdcb1c644931e34767ea000b8dbe809036","filename":"bookkeeper-benchmark/pom.xml","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/pom.xml?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -49,6 +49,18 @@\n       <version>1.6.4</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+       <groupId>org.apache.hadoop</groupId>\n+       <artifactId>hadoop-common</artifactId>\n+       <version>0.23.1</version>\n+       <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+       <groupId>org.apache.hadoop</groupId>\n+       <artifactId>hadoop-hdfs</artifactId>\n+       <version>0.23.1</version>\n+       <scope>compile</scope>\n+    </dependency>\n     <dependency>\n     \t<groupId>org.apache.zookeeper</groupId>\n     \t<artifactId>zookeeper</artifactId>"},{"sha":"0831c0a653ef1e62752b4832a60c2ec0e04ee089","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","status":"modified","additions":10,"deletions":4,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -122,7 +122,8 @@ public static void main(String[] args)\n         Options options = new Options();\n         options.addOption(\"host\", true, \"Hostname or IP of bookie to benchmark\");\n         options.addOption(\"port\", true, \"Port of bookie to benchmark (default 3181)\");\n-        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n+        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, (default \\\"localhost:2181\\\")\");\n+        options.addOption(\"size\", true, \"Size of message to send, in bytes (default 1024)\");\n         options.addOption(\"help\", false, \"This message\");\n \n         CommandLineParser parser = new PosixParser();\n@@ -136,6 +137,7 @@ public static void main(String[] args)\n \n         String addr = cmd.getOptionValue(\"host\");\n         int port = Integer.valueOf(cmd.getOptionValue(\"port\", \"3181\"));\n+        int size = Integer.valueOf(cmd.getOptionValue(\"size\", \"1024\"));\n         String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n \n \n@@ -154,7 +156,7 @@ public static void main(String[] args)\n \n         long ledger = getValidLedgerId(servers);\n         for(long entry = 0; entry < warmUpCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(128);\n+            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n             toSend.resetReaderIndex();\n             toSend.resetWriterIndex();\n             toSend.writeLong(ledger);\n@@ -171,7 +173,7 @@ public static void main(String[] args)\n         int entryCount = 5000;\n         long startTime = System.nanoTime();\n         for(long entry = 0; entry < entryCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(128);\n+            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n             toSend.resetReaderIndex();\n             toSend.resetWriterIndex();\n             toSend.writeLong(ledger);\n@@ -192,7 +194,7 @@ public static void main(String[] args)\n         startTime = System.currentTimeMillis();\n         tc = new ThroughputCallback();\n         for(long entry = 0; entry < entryCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(128);\n+            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n             toSend.resetReaderIndex();\n             toSend.resetWriterIndex();\n             toSend.writeLong(ledger);\n@@ -204,6 +206,10 @@ public static void main(String[] args)\n         tc.waitFor(entryCount);\n         endTime = System.currentTimeMillis();\n         LOG.info(\"Throughput: \" + ((long)entryCount)*1000/(endTime-startTime));\n+\n+        bc.close();\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n     }\n \n }"},{"sha":"846b7c12b3aa6626268e1f636c8bd198a296cb8e","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","status":"modified","additions":24,"deletions":13,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -75,21 +75,22 @@ public int compare(String o1, String o2) {\n         }\n     };\n \n-    private static void readLedger(String zkservers, long ledgerId, byte[] passwd) {\n+    private static void readLedger(ClientConfiguration conf, long ledgerId, byte[] passwd) {\n         LOG.info(\"Reading ledger {}\", ledgerId);\n         BookKeeper bk = null;\n         long time = 0;\n         long entriesRead = 0;\n         long lastRead = 0;\n         int nochange = 0;\n \n+        long absoluteLimit = 5000000;\n         LedgerHandle lh = null;\n         try {\n-            bk = new BookKeeper(zkservers);\n+            bk = new BookKeeper(conf);\n             while (true) {\n                 lh = bk.openLedgerNoRecovery(ledgerId, BookKeeper.DigestType.CRC32, \n                                              passwd);\n-                long lastConfirmed = lh.getLastAddConfirmed();\n+                long lastConfirmed = Math.min(lh.getLastAddConfirmed(), absoluteLimit);\n                 if (lastConfirmed == lastRead) {\n                     nochange++;\n                     if (nochange == 10) {\n@@ -103,13 +104,17 @@ private static void readLedger(String zkservers, long ledgerId, byte[] passwd) {\n                 }\n                 long starttime = System.nanoTime();\n \n-                Enumeration<LedgerEntry> entries = lh.readEntries(lastRead+1, lastConfirmed);\n-                lastRead = lastConfirmed;\n-                while (entries.hasMoreElements()) {\n-                    LedgerEntry e = entries.nextElement();\n-                    entriesRead++;\n-                    if ((entriesRead % 10000) == 0) {\n-                        LOG.info(\"{} entries read\", entriesRead);\n+                while (lastRead < lastConfirmed) {\n+                    long nextLimit = lastRead + 100000;\n+                    long readTo = Math.min(nextLimit, lastConfirmed);\n+                    Enumeration<LedgerEntry> entries = lh.readEntries(lastRead+1, readTo);\n+                    lastRead = readTo;\n+                    while (entries.hasMoreElements()) {\n+                        LedgerEntry e = entries.nextElement();\n+                        entriesRead++;\n+                        if ((entriesRead % 10000) == 0) {\n+                            LOG.info(\"{} entries read\", entriesRead);\n+                        }\n                     }\n                 }\n                 long endtime = System.nanoTime();\n@@ -151,6 +156,7 @@ public static void main(String[] args) throws Exception {\n         options.addOption(\"listen\", true, \"Listen for creation of <arg> ledgers, and read each one fully\");\n         options.addOption(\"password\", true, \"Password used to access ledgers (default 'benchPasswd')\");\n         options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n+        options.addOption(\"sockettimeout\", true, \"Socket timeout for bookkeeper client. In seconds. Default 5\");\n         options.addOption(\"help\", false, \"This message\");\n \n         CommandLineParser parser = new PosixParser();\n@@ -163,6 +169,7 @@ public static void main(String[] args) throws Exception {\n \n         final String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n         final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes();\n+        final int sockTimeout = Integer.valueOf(cmd.getOptionValue(\"sockettimeout\", \"5\"));\n         if (cmd.hasOption(\"ledger\") && cmd.hasOption(\"listen\")) {\n             LOG.error(\"Cannot used -ledger and -listen together\");\n             usage(options);\n@@ -185,6 +192,10 @@ public static void main(String[] args) throws Exception {\n         final CountDownLatch connectedLatch = new CountDownLatch(1);\n         final String nodepath = String.format(\"/ledgers/L%010d\", ledger.get());\n \n+        final ClientConfiguration conf = new ClientConfiguration();\n+        conf.setReadTimeout(sockTimeout).setZkServers(servers);\n+\n+\n         final ZooKeeper zk = new ZooKeeper(servers, 3000, new Watcher() {\n                 public void process(WatchedEvent event) {\n                     if (event.getState() == Event.KeeperState.SyncConnected\n@@ -202,7 +213,7 @@ public void process(WatchedEvent event) {\n                                 connectedLatch.countDown();\n                             } else if (event.getType() == Event.EventType.NodeCreated\n                                        && event.getPath().equals(nodepath)) {\n-                                readLedger(servers, ledger.get(), passwd);\n+                                readLedger(conf, ledger.get(), passwd);\n                                 shutdownLatch.countDown();\n                             } else if (event.getType() == Event.EventType.NodeChildrenChanged) {\n                                 if (numLedgers.get() < 0) {\n@@ -222,7 +233,7 @@ public void process(WatchedEvent event) {\n                                     int ledgersLeft = numLedgers.decrementAndGet();\n                                     Thread t = new Thread() {\n                                             public void run() {\n-                                                readLedger(servers, Long.valueOf(m.group(1)), passwd);\n+                                                readLedger(conf, Long.valueOf(m.group(1)), passwd);\n                                             }\n                                         };\n                                     t.start();\n@@ -243,7 +254,7 @@ public void run() {\n             connectedLatch.await();\n             if (ledger.get() != 0) {\n                 if (zk.exists(nodepath, true) != null) {\n-                    readLedger(servers, ledger.get(), passwd);\n+                    readLedger(conf, ledger.get(), passwd);\n                     shutdownLatch.countDown();\n                 } else {\n                     LOG.info(\"Watching for creation of\" + nodepath);"},{"sha":"7d4f6dc9e9a76b22d1c1c2982f3d2b0e7e4fa82b","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","status":"modified","additions":80,"deletions":55,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -31,6 +31,8 @@\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.Timer;\n+import java.util.TimerTask;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -62,10 +64,9 @@\n     AtomicLong counter;\n \n     Semaphore sem;\n-    int pace;\n-    int throttle;\n     int numberOfLedgers = 1;\n-    final String servers;\n+    final int sendLimit;\n+    final long latencies[];\n \n     static class Context {\n         long localStartTime;\n@@ -78,24 +79,19 @@\n     }\n \n     public BenchThroughputLatency(int ensemble, int qSize, byte[] passwd,\n-                                  int throttle, int numberOfLedgers, String servers) \n+            int numberOfLedgers, int sendLimit, ClientConfiguration conf)\n             throws KeeperException, IOException, InterruptedException {\n-        this.sem = new Semaphore(throttle);\n-        this.throttle = throttle;\n-\n-        ClientConfiguration conf = new ClientConfiguration();\n-        conf.setThrottleValue(100000);\n-        conf.setZkServers(servers);\n-        this.servers = servers;\n-\n+        this.sem = new Semaphore(conf.getThrottleValue());\n         bk = new BookKeeper(conf);\n         this.counter = new AtomicLong(0);\n         this.numberOfLedgers = numberOfLedgers;\n+        this.sendLimit = sendLimit;\n+        this.latencies = new long[sendLimit];\n         try{\n             lh = new LedgerHandle[this.numberOfLedgers];\n \n             for(int i = 0; i < this.numberOfLedgers; i++) {\n-                lh[i] = bk.createLedger(ensemble, qSize, BookKeeper.DigestType.CRC32, \n+                lh[i] = bk.createLedger(ensemble, qSize, BookKeeper.DigestType.CRC32,\n                                         passwd);\n                 LOG.info(\"Ledger Handle: \" + lh[i].getId());\n             }\n@@ -124,16 +120,9 @@ private int getRandomLedger() {\n          return rand.nextInt(numberOfLedgers);\n     }\n \n-    int sendLimit = 2000000;\n-    long latencies[] = new long[sendLimit];\n     int latencyIndex = -1;\n     AtomicLong completedRequests = new AtomicLong(0);\n \n-    public void setSendLimit(int sendLimit) {\n-        this.sendLimit = sendLimit;\n-        latencies = new long[sendLimit];\n-    }\n-\n     long duration = -1;\n     synchronized public long getDuration() {\n         return duration;\n@@ -149,7 +138,7 @@ public void run() {\n                 public void run() {\n                     try {\n                         while(true) {\n-                            Thread.sleep(200);\n+                            Thread.sleep(1000);\n                             LOG.info(\"ms: {} req: {}\", System.currentTimeMillis(), completedRequests.getAndSet(0));\n                         }\n                     } catch (InterruptedException ie) {\n@@ -186,9 +175,12 @@ public void run() {\n         }\n         LOG.info(\"Sent: \"  + sent);\n         try {\n-            synchronized (this) {\n-                while (this.counter.get() > 0) {\n-                    waitFor(1000);\n+            int i = 0;\n+            while(this.counter.get() > 0) {\n+                Thread.sleep(1000);\n+                i++;\n+                if (i > 30) {\n+                    break;\n                 }\n             }\n         } catch(InterruptedException e) {\n@@ -208,10 +200,6 @@ public void run() {\n         LOG.info(\"Finished processing in ms: \" + getDuration() + \" tp = \" + throughput);\n     }\n \n-    private void waitFor(int waitTime) throws InterruptedException {\n-        Thread.sleep(waitTime);\n-    }\n-\n     long throughput = -1;\n     public long getThroughput() {\n         return throughput;\n@@ -232,9 +220,10 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         sem.release();\n         counter.decrementAndGet();\n \n-        latencies[(int)entryId] = newTime;\n-\n-        completedRequests.incrementAndGet();\n+        if (rc == 0) {\n+            latencies[(int)entryId] = newTime;\n+            completedRequests.incrementAndGet();\n+        }\n     }\n \n     public static void main(String[] args)\n@@ -248,7 +237,11 @@ public static void main(String[] args)\n         options.addOption(\"ledgers\", true, \"Number of ledgers, default 1\");\n         options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n         options.addOption(\"password\", true, \"Password used to create ledgers (default 'benchPasswd')\");\n-        options.addOption(\"coord_node\", true, \"Coordination znode for multi client benchmarks (optional)\");\n+        options.addOption(\"coordnode\", true, \"Coordination znode for multi client benchmarks (optional)\");\n+        options.addOption(\"timeout\", true, \"Number of seconds after which to give up\");\n+        options.addOption(\"sockettimeout\", true, \"Socket timeout for bookkeeper client. In seconds. Default 5\");\n+        options.addOption(\"skipwarmup\", false, \"Skip warm up, default false\");\n+        options.addOption(\"sendlimit\", true, \"Max number of entries to send. Default 20000000\");\n         options.addOption(\"help\", false, \"This message\");\n \n         CommandLineParser parser = new PosixParser();\n@@ -268,10 +261,25 @@ public static void main(String[] args)\n         int ensemble = Integer.valueOf(cmd.getOptionValue(\"ensemble\", \"3\"));\n         int quorum = Integer.valueOf(cmd.getOptionValue(\"quorum\", \"2\"));\n         int throttle = Integer.valueOf(cmd.getOptionValue(\"throttle\", \"10000\"));\n+        int sendLimit = Integer.valueOf(cmd.getOptionValue(\"sendlimit\", \"20000000\"));\n \n-        String coordinationZnode = cmd.getOptionValue(\"coord_node\");\n+        final int sockTimeout = Integer.valueOf(cmd.getOptionValue(\"sockettimeout\", \"5\"));\n+\n+        String coordinationZnode = cmd.getOptionValue(\"coordnode\");\n         final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes();\n \n+        Timer timeouter = new Timer();\n+        if (cmd.hasOption(\"timeout\")) {\n+            final long timeout = Long.valueOf(cmd.getOptionValue(\"timeout\", \"360\")) * 1000;\n+\n+            timeouter.schedule(new TimerTask() {\n+                    public void run() {\n+                        System.err.println(\"Timing out benchmark after \" + timeout + \"ms\");\n+                        System.exit(-1);\n+                    }\n+                }, timeout);\n+        }\n+\n         LOG.warn(\"(Parameters received) running time: \" + runningTime +\n                 \", entry size: \" + entrysize + \", ensemble size: \" + ensemble +\n                 \", quorum size: \" + quorum +\n@@ -284,19 +292,25 @@ public static void main(String[] args)\n         // Do a warmup run\n         Thread thread;\n \n-        long lastWarmUpTP = -1;\n-        long throughput;\n-        LOG.info(\"Starting warmup\");\n         byte data[] = new byte[entrysize];\n         Arrays.fill(data, (byte)'x');\n \n-        if(lastWarmUpTP < (throughput = warmUp(servers, data, ledgers, ensemble, quorum, passwd, throttle))) {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setThrottleValue(throttle).setReadTimeout(sockTimeout).setZkServers(servers);\n+\n+        if (!cmd.hasOption(\"skipwarmup\")) {\n+            long throughput;\n+            LOG.info(\"Starting warmup\");\n+\n+            throughput = warmUp(data, ledgers, ensemble, quorum, passwd, conf);\n             LOG.info(\"Warmup tp: \" + throughput);\n+            LOG.info(\"Warmup phase finished\");\n         }\n-        LOG.info(\"Warmup phase finished\");\n+\n \n         // Now do the benchmark\n-        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, passwd, throttle, ledgers, servers);\n+        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, passwd,\n+                                                                  ledgers, sendLimit, conf);\n         bench.setEntryData(data);\n         thread = new Thread(bench);\n         ZooKeeper zk = null;\n@@ -336,18 +350,31 @@ public void process(WatchedEvent event) {\n         thread.join();\n \n         LOG.info(\"Calculating percentiles\");\n-        ArrayList<Long> latency = new ArrayList<Long>();\n+\n+        int numlat = 0;\n         for(int i = 0; i < bench.latencies.length; i++) {\n             if (bench.latencies[i] > 0) {\n-                latency.add(bench.latencies[i]);\n+                numlat++;\n             }\n         }\n-        double tp = (double)latency.size()*1000.0/(double)bench.getDuration();\n-        LOG.info(latency.size() + \" completions in \" + bench.getDuration() + \" seconds: \" + tp + \" ops/sec\");\n+        int numcompletions = numlat;\n+        numlat = Math.min(bench.sendLimit, numlat);\n+        long[] latency = new long[numlat];\n+        int j =0;\n+        for(int i = 0; i < bench.latencies.length && j < numlat; i++) {\n+            if (bench.latencies[i] > 0) {\n+                latency[j++] = bench.latencies[i];\n+            }\n+        }\n+        Arrays.sort(latency);\n+\n+        long tp = (long)((double)(numcompletions*1000.0)/(double)bench.getDuration());\n+\n+        LOG.info(numcompletions + \" completions in \" + bench.getDuration() + \" seconds: \" + tp + \" ops/sec\");\n \n         if (zk != null) {\n-            zk.create(coordinationZnode + \"/worker-\", \n-                      (\"tp \" + tp + \" duration \" + bench.getDuration()).getBytes(), \n+            zk.create(coordinationZnode + \"/worker-\",\n+                      (\"tp \" + tp + \" duration \" + bench.getDuration()).getBytes(),\n                       ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n             zk.close();\n         }\n@@ -362,32 +389,33 @@ public void process(WatchedEvent event) {\n         fos.close();\n \n         // now get the latencies\n-        Collections.sort(latency);\n         LOG.info(\"99th percentile latency: {}\", percentile(latency, 99));\n         LOG.info(\"95th percentile latency: {}\", percentile(latency, 95));\n \n         bench.close();\n+        timeouter.cancel();\n     }\n \n-    private static double percentile(ArrayList<Long> latency, int percentile) {\n-        int size = latency.size();\n+    private static double percentile(long[] latency, int percentile) {\n+        int size = latency.length;\n         int sampleSize = (size * percentile) / 100;\n         long total = 0;\n         int count = 0;\n         for(int i = 0; i < sampleSize; i++) {\n-            total += latency.get(i);\n+            total += latency[i];\n             count++;\n         }\n         return ((double)total/(double)count)/1000000.0;\n     }\n \n-    private static long warmUp(String servers, byte[] data,\n-                               int ledgers, int ensemble, int qSize, byte[] passwd, int throttle)\n+    private static long warmUp(byte[] data, int ledgers, int ensemble, int qSize,\n+                               byte[] passwd, ClientConfiguration conf)\n             throws KeeperException, IOException, InterruptedException, BKException {\n         final CountDownLatch connectLatch = new CountDownLatch(1);\n         final int bookies;\n         ZooKeeper zk = null;\n         try {\n+            final String servers = conf.getZkServers();\n             zk = new ZooKeeper(servers, 15000, new Watcher() {\n                     @Override\n                     public void process(WatchedEvent event) {\n@@ -407,10 +435,7 @@ public void process(WatchedEvent event) {\n         }\n \n         BenchThroughputLatency warmup = new BenchThroughputLatency(bookies, bookies, passwd,\n-                                                                   throttle, ledgers, servers);\n-        int limit = 50000;\n-\n-        warmup.setSendLimit(limit);\n+                ledgers, 50000, conf);\n         warmup.setEntryData(data);\n         Thread thread = new Thread(warmup);\n         thread.start();"},{"sha":"34d683c7841a3ffd6eda757e4107997478af7c9e","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","status":"modified","additions":282,"deletions":159,"changes":441,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -23,12 +23,27 @@\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import java.util.concurrent.Future;;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -38,208 +53,316 @@\n \n import org.apache.zookeeper.KeeperException;\n \n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.Path;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+\n /**\n  * This is a simple test program to compare the performance of writing to\n  * BookKeeper and to the local file system.\n  *\n  */\n \n-public class TestClient\n-    implements AddCallback, ReadCallback {\n+public class TestClient {\n     private static final Logger LOG = LoggerFactory.getLogger(TestClient.class);\n \n-    BookKeeper x;\n-    LedgerHandle lh;\n-    Integer entryId;\n-    HashMap<Integer, Integer> map;\n+    /**\n+     * First says if entries should be written to BookKeeper (0) or to the local\n+     * disk (1). Second parameter is an integer defining the length of a ledger entry.\n+     * Third parameter is the number of writes.\n+     *\n+     * @param args\n+     */\n+    public static void main(String[] args) throws ParseException {\n+        Options options = new Options();\n+        options.addOption(\"length\", true, \"Length of packets being written. Default 1024\");\n+        options.addOption(\"target\", true, \"Target medium to write to. Options are bk, fs & hdfs. Default fs\");\n+        options.addOption(\"runfor\", true, \"Number of seconds to run for. Default 60\");\n+        options.addOption(\"path\", true, \"Path to write to. fs & hdfs only. Default /foobar\");\n+        options.addOption(\"zkservers\", true, \"ZooKeeper servers, comma separated. bk only. Default localhost:2181.\");\n+        options.addOption(\"bkensemble\", true, \"BookKeeper ledger ensemble size. bk only. Default 3\");\n+        options.addOption(\"bkquorum\", true, \"BookKeeper ledger quorum size. bk only. Default 2\");\n+        options.addOption(\"bkthrottle\", true, \"BookKeeper throttle size. bk only. Default 10000\");\n+        options.addOption(\"sync\", false, \"Use synchronous writes with BookKeeper. bk only.\");\n+        options.addOption(\"numconcurrent\", true, \"Number of concurrently clients. Default 1\");\n+        options.addOption(\"timeout\", true, \"Number of seconds after which to give up\");\n+        options.addOption(\"help\", false, \"This message\");\n \n-    FileOutputStream fStream;\n-    FileOutputStream fStreamLocal;\n-    long start, lastId;\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n \n-    public TestClient() {\n-        entryId = 0;\n-        map = new HashMap<Integer, Integer>();\n-    }\n+        if (cmd.hasOption(\"help\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"TestClient <options>\", options);\n+            System.exit(-1);\n+        }\n \n-    public TestClient(String servers) throws KeeperException, IOException, InterruptedException {\n-        this();\n-        x = new BookKeeper(servers);\n-        try {\n-            lh = x.createLedger(DigestType.MAC, new byte[] {'a', 'b'});\n-        } catch (BKException e) {\n-            LOG.error(e.toString());\n+        int length = Integer.valueOf(cmd.getOptionValue(\"length\", \"1024\"));\n+        String target = cmd.getOptionValue(\"target\", \"fs\");\n+        long runfor = Long.valueOf(cmd.getOptionValue(\"runfor\", \"60\")) * 1000;\n+\n+        StringBuilder sb = new StringBuilder();\n+        while(length-- > 0) {\n+            sb.append('a');\n         }\n-    }\n \n-    public TestClient(String servers, int ensSize, int qSize)\n-            throws KeeperException, IOException, InterruptedException {\n-        this();\n-        x = new BookKeeper(servers);\n-        try {\n-            lh = x.createLedger(ensSize, qSize, DigestType.MAC, new byte[] {'a', 'b'});\n-        } catch (BKException e) {\n-            LOG.error(e.toString());\n+        Timer timeouter = new Timer();\n+        if (cmd.hasOption(\"timeout\")) {\n+            final long timeout = Long.valueOf(cmd.getOptionValue(\"timeout\", \"360\")) * 1000;\n+\n+            timeouter.schedule(new TimerTask() {\n+                    public void run() {\n+                        System.err.println(\"Timing out benchmark after \" + timeout + \"ms\");\n+                        System.exit(-1);\n+                    }\n+                }, timeout);\n         }\n-    }\n \n-    public TestClient(FileOutputStream fStream)\n-            throws FileNotFoundException {\n-        this.fStream = fStream;\n-        this.fStreamLocal = new FileOutputStream(\"./local.log\");\n-    }\n+        BookKeeper bkc = null;\n+        try {\n+            int numFiles = Integer.valueOf(cmd.getOptionValue(\"numconcurrent\", \"1\"));\n+            int numThreads = Math.min(numFiles, 1000);\n+            byte[] data = sb.toString().getBytes();\n+            long runid = System.currentTimeMillis();\n+            List<Callable<Long>> clients = new ArrayList<Callable<Long>>();\n \n+            if (target.equals(\"bk\")) {\n+                String zkservers = cmd.getOptionValue(\"zkservers\", \"localhost:2181\");\n+                int bkensemble = Integer.valueOf(cmd.getOptionValue(\"bkensemble\", \"3\"));\n+                int bkquorum = Integer.valueOf(cmd.getOptionValue(\"bkquorum\", \"2\"));\n+                int bkthrottle = Integer.valueOf(cmd.getOptionValue(\"bkthrottle\", \"10000\"));\n \n-    public Integer getFreshEntryId(int val) {\n-        ++this.entryId;\n-        synchronized (map) {\n-            map.put(this.entryId, val);\n-        }\n-        return this.entryId;\n-    }\n+                ClientConfiguration conf = new ClientConfiguration();\n+                conf.setThrottleValue(bkthrottle);\n+                conf.setZkServers(zkservers);\n+\n+                bkc = new BookKeeper(conf);\n+                List<LedgerHandle> handles = new ArrayList<LedgerHandle>();\n+                for (int i = 0; i < numFiles; i++) {\n+                    handles.add(bkc.createLedger(bkensemble, bkquorum, DigestType.CRC32, new byte[] {'a', 'b'}));\n+                }\n+                for (int i = 0; i < numFiles; i++) {\n+                    clients.add(new BKClient(handles, data, runfor, cmd.hasOption(\"sync\")));\n+                }\n+            } else if (target.equals(\"hdfs\")) {\n+                FileSystem fs = FileSystem.get(new Configuration());\n+                LOG.info(\"Default replication for HDFS: {}\", fs.getDefaultReplication());\n+\n+                List<FSDataOutputStream> streams = new ArrayList<FSDataOutputStream>();\n+                for (int i = 0; i < numFiles; i++) {\n+                    String path = cmd.getOptionValue(\"path\", \"/foobar\");\n+                    streams.add(fs.create(new Path(path + runid + \"_\" + i)));\n+                }\n \n-    public boolean removeEntryId(Integer id) {\n-        boolean retVal = false;\n-        synchronized (map) {\n-            map.remove(id);\n-            retVal = true;\n+                for (int i = 0; i < numThreads; i++) {\n+                    clients.add(new HDFSClient(streams, data, runfor));\n+                }\n+            } else if (target.equals(\"fs\")) {\n+                List<FileOutputStream> streams = new ArrayList<FileOutputStream>();\n+                for (int i = 0; i < numFiles; i++) {\n+                    String path = cmd.getOptionValue(\"path\", \"/foobar \" + i);\n+                    streams.add(new FileOutputStream(path + runid + \"_\" + i));\n+                }\n \n-            if(map.size() == 0) map.notifyAll();\n-            else {\n-                if(map.size() < 4)\n-                    LOG.error(map.toString());\n+                for (int i = 0; i < numThreads; i++) {\n+                    clients.add(new FileClient(streams, data, runfor));\n+                }\n+            } else {\n+                LOG.error(\"Unknown option: \" + target);\n+                throw new IllegalArgumentException(\"Unknown target \" + target);\n+            }\n+\n+            ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n+            long start = System.currentTimeMillis();\n+\n+            List<Future<Long>> results = executor.invokeAll(clients,\n+                                                            10, TimeUnit.MINUTES);\n+            long end = System.currentTimeMillis();\n+            long count = 0;\n+            for (Future<Long> r : results) {\n+                if (!r.isDone()) {\n+                    LOG.warn(\"Job didn't complete\");\n+                    System.exit(2);\n+                }\n+                long c = r.get();\n+                if (c == 0) {\n+                    LOG.warn(\"Task didn't complete\");\n+                }\n+                count += c;\n+            }\n+            long time = end-start;\n+            LOG.info(\"Finished processing writes (ms): {} TPT: {} op/s\",\n+                     time, count/((double)time/1000));\n+            executor.shutdown();\n+        } catch (ExecutionException ee) {\n+            LOG.error(\"Exception in worker\", ee);\n+        }  catch (KeeperException ke) {\n+            LOG.error(\"Error accessing zookeeper\", ke);\n+        } catch (BKException e) {\n+            LOG.error(\"Error accessing bookkeeper\", e);\n+        } catch (IOException ioe) {\n+            LOG.error(\"I/O exception during benchmark\", ioe);\n+        } catch (InterruptedException ie) {\n+            LOG.error(\"Benchmark interrupted\", ie);\n+        } finally {\n+            if (bkc != null) {\n+                try {\n+                    bkc.close();\n+                } catch (BKException bke) {\n+                    LOG.error(\"Error closing bookkeeper client\", bke);\n+                } catch (InterruptedException ie) {\n+                    LOG.warn(\"Interrupted closing bookkeeper client\", ie);\n+                }\n             }\n         }\n-        return retVal;\n+        timeouter.cancel();\n     }\n \n-    public void closeHandle() throws KeeperException, InterruptedException, BKException {\n-        lh.close();\n-    }\n-    /**\n-     * First says if entries should be written to BookKeeper (0) or to the local\n-     * disk (1). Second parameter is an integer defining the length of a ledger entry.\n-     * Third parameter is the number of writes.\n-     *\n-     * @param args\n-     */\n-    public static void main(String[] args) {\n+    static class HDFSClient implements Callable<Long> {\n+        final List<FSDataOutputStream> streams;\n+        final byte[] data;\n+        final long time;\n+        final Random r;\n \n-        int lenght = Integer.parseInt(args[1]);\n-        StringBuilder sb = new StringBuilder();\n-        while(lenght-- > 0) {\n-            sb.append('a');\n+        HDFSClient(List<FSDataOutputStream> streams, byte[] data, long time) {\n+            this.streams = streams;\n+            this.data = data;\n+            this.time = time;\n+            this.r = new Random(System.identityHashCode(this));\n         }\n \n-        Integer selection = Integer.parseInt(args[0]);\n-        switch(selection) {\n-        case 0:\n-            StringBuilder servers_sb = new StringBuilder();\n-            for (int i = 4; i < args.length; i++) {\n-                servers_sb.append(args[i] + \" \");\n-            }\n-\n-            String servers = servers_sb.toString().trim().replace(' ', ',');\n+        public Long call() {\n             try {\n-                TestClient c = new TestClient(servers, Integer.parseInt(args[3]), Integer.parseInt(args[4]));\n-                c.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[2]));\n-                //c.writeConsecutiveEntriesBatch(Integer.parseInt(args[0]));\n-                c.closeHandle();\n-            } catch (Exception e) {\n-                LOG.error(\"Exception occurred\", e);\n-            } \n-            break;\n-        case 1:\n+                long count = 0;\n+                long start = System.currentTimeMillis();\n+                long stopat = start + time;\n+                while(System.currentTimeMillis() < stopat) {\n+                    FSDataOutputStream stream = streams.get(r.nextInt(streams.size()));\n+                    synchronized(stream) {\n+                        stream.write(data);\n+                        stream.flush();\n+                        stream.hflush();\n+                    }\n+                    count++;\n+                }\n \n-            try {\n-                TestClient c = new TestClient(new FileOutputStream(args[2]));\n-                c.writeSameEntryBatchFS(sb.toString().getBytes(), Integer.parseInt(args[3]));\n-            } catch(FileNotFoundException e) {\n-                LOG.error(\"File not found\", e);\n+                long time = (System.currentTimeMillis() - start);\n+                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\",\n+                         time, count/((double)time/1000));\n+                return count;\n+            } catch(IOException ioe) {\n+                LOG.error(\"Exception in worker thread\", ioe);\n+                return 0L;\n             }\n-            break;\n-        case 2:\n-            break;\n         }\n     }\n \n-    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException {\n-        start = System.currentTimeMillis();\n-        int count = times;\n-        LOG.debug(\"Data: \" + new String(data) + \", \" + data.length);\n-        while(count-- > 0) {\n-            lh.asyncAddEntry(data, this, this.getFreshEntryId(2));\n-        }\n-        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));\n-        synchronized (map) {\n-            while (map.size() != 0) {\n-                map.wait(100);\n-            }\n+    static class FileClient implements Callable<Long> {\n+        final List<FileOutputStream> streams;\n+        final byte[] data;\n+        final long time;\n+        final Random r;\n+\n+        FileClient(List<FileOutputStream> streams, byte[] data, long time) {\n+            this.streams = streams;\n+            this.data = data;\n+            this.time = time;\n+            this.r = new Random(System.identityHashCode(this));\n         }\n-        LOG.debug(\"Finished processing in ms: \" + (System.currentTimeMillis() - start));\n \n-        LOG.debug(\"Ended computation\");\n-    }\n+        public Long call() {\n+            try {\n+                long count = 0;\n+                long start = System.currentTimeMillis();\n \n-    void writeConsecutiveEntriesBatch(int times) throws InterruptedException {\n-        start = System.currentTimeMillis();\n-        int count = times;\n-        while(count-- > 0) {\n-            byte[] write = new byte[2];\n-            int j = count%100;\n-            int k = (count+1)%100;\n-            write[0] = (byte) j;\n-            write[1] = (byte) k;\n-            lh.asyncAddEntry(write, this, this.getFreshEntryId(2));\n-        }\n-        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));\n-        synchronized (map) {\n-            while (map.size() != 0) {\n-                map.wait(100);\n-            }\n-        }\n-        LOG.debug(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n+                long stopat = start + time;\n+                while(System.currentTimeMillis() < stopat) {\n+                    FileOutputStream stream = streams.get(r.nextInt(streams.size()));\n+                    synchronized(stream) {\n+                        stream.write(data);\n+                        stream.flush();\n+                        stream.getChannel().force(false);\n+                    }\n+                    count++;\n+                }\n \n-        Object syncObj = new Object();\n-        synchronized(syncObj) {\n-            lh.asyncReadEntries(1, times - 1, this, syncObj);\n-            syncObj.wait();\n+                long time = (System.currentTimeMillis() - start);\n+                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\", time, count/((double)time/1000));\n+                return count;\n+            } catch(IOException ioe) {\n+                LOG.error(\"Exception in worker thread\", ioe);\n+                return 0L;\n+            }\n         }\n-        LOG.error(\"Ended computation\");\n     }\n \n-    void writeSameEntryBatchFS(byte[] data, int times) {\n-        int count = times;\n-        LOG.debug(\"Data: \" + data.length + \", \" + times);\n-        try {\n-            start = System.currentTimeMillis();\n-            while(count-- > 0) {\n-                fStream.write(data);\n-                fStreamLocal.write(data);\n-                fStream.flush();\n-            }\n-            fStream.close();\n-            System.out.println(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n-        } catch(IOException e) {\n-            LOG.error(\"IOException occurred\", e);\n+    static class BKClient implements Callable<Long>, AddCallback {\n+        final List<LedgerHandle> handles;\n+        final byte[] data;\n+        final long time;\n+        final Random r;\n+        final boolean sync;\n+        final AtomicLong success = new AtomicLong(0);\n+        final AtomicLong outstanding = new AtomicLong(0);\n+\n+        BKClient(List<LedgerHandle> handles, byte[] data, long time, boolean sync) {\n+            this.handles = handles;\n+            this.data = data;\n+            this.time = time;\n+            this.r = new Random(System.identityHashCode(this));\n+            this.sync = sync;\n         }\n-    }\n \n+        public Long call() {\n+            try {\n+                long start = System.currentTimeMillis();\n \n-    @Override\n-    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-        this.removeEntryId((Integer) ctx);\n-    }\n+                long stopat = start + time;\n+                while(System.currentTimeMillis() < stopat) {\n+                    LedgerHandle lh = handles.get(r.nextInt(handles.size()));\n+                    if (sync) {\n+                        lh.addEntry(data);\n+                        success.incrementAndGet();\n+                    } else {\n+                        lh.asyncAddEntry(data, this, null);\n+                        outstanding.incrementAndGet();\n+                    }\n+                }\n \n-    @Override\n-    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-        System.out.println(\"Read callback: \" + rc);\n-        while(seq.hasMoreElements()) {\n-            LedgerEntry le = seq.nextElement();\n-            LOG.debug(new String(le.getEntry()));\n+                int ticks = 10; // don't wait for more than 10 seconds\n+                while (outstanding.get() > 0 && ticks-- > 0) {\n+                    Thread.sleep(10);\n+                }\n+\n+                long time = (System.currentTimeMillis() - start);\n+                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\",\n+                         time, success.get()/((double)time/1000));\n+                return success.get();\n+            } catch (BKException e) {\n+                LOG.error(\"Exception in worker thread\", e);\n+                return 0L;\n+            } catch (InterruptedException ie) {\n+                LOG.error(\"Exception in worker thread\", ie);\n+                return 0L;\n+            }\n         }\n-        synchronized(ctx) {\n-            ctx.notify();\n+\n+        @Override\n+        public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+            if (rc == BKException.Code.OK) {\n+                success.incrementAndGet();\n+            }\n+            outstanding.decrementAndGet();\n         }\n     }\n }"},{"sha":"02e40ba7fb77b024be98f0112bd48fa258ec7edd","filename":"bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -115,7 +115,10 @@ public static void stopEnsemble() throws Exception {\n     @Test\n     public void testThroughputLatency() throws Exception {\n         BenchThroughputLatency.main(new String[] {\n-                \"--time\", \"10\"\n+                \"--time\", \"10\",\n+                \"--skipwarmup\",\n+                \"--throttle\", \"1\",\n+                \"--sendlimit\", \"10000\"\n             });\n     }\n "},{"sha":"cc5e93778a041724de8a050276fcc3497f14c21b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","status":"modified","additions":59,"deletions":22,"changes":81,"blob_url":"https://github.com/apache/bookkeeper/blob/5f25edeba1cbf5de489e1f5a3070188f0163b51b/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/5f25edeba1cbf5de489e1f5a3070188f0163b51b/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java?ref=5f25edeba1cbf5de489e1f5a3070188f0163b51b","patch":"@@ -27,11 +27,20 @@\n import org.jboss.netty.logging.Log4JLoggerFactory;\n \n import com.google.protobuf.ByteString;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.HedwigClient;\n import org.apache.hedwig.client.api.Publisher;\n import org.apache.hedwig.client.api.Subscriber;\n \n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n public class HedwigBenchmark implements Callable<Void> {\n     protected static final Logger logger = LoggerFactory.getLogger(HedwigBenchmark.class);\n \n@@ -40,11 +49,13 @@\n     private final HedwigClient client;\n     private final Publisher publisher;\n     private final Subscriber subscriber;\n+    private final CommandLine cmd;\n \n-    public HedwigBenchmark(ClientConfiguration cfg) {\n+    public HedwigBenchmark(ClientConfiguration cfg, CommandLine cmd) {\n         client = new HedwigClient(cfg);\n         publisher = client.getPublisher();\n         subscriber = client.getSubscriber();\n+        this.cmd = cmd;\n     }\n \n     static boolean amIResponsibleForTopic(int topicNum, int partitionIndex, int numPartitions) {\n@@ -59,24 +70,24 @@ public Void call() throws Exception {\n         //\n \n         // What program to run: pub, sub (subscription benchmark), recv.\n-        final String mode = System.getProperty(\"mode\",\"\");\n+        final String mode = cmd.getOptionValue(\"mode\",\"\");\n \n         // Number of requests to make (publishes or subscribes).\n-        int numTopics = Integer.getInteger(\"nTopics\", 50);\n-        int numMessages = Integer.getInteger(\"nMsgs\", 1000);\n-        int numRegions = Integer.getInteger(\"nRegions\", 1);\n-        int startTopicLabel = Integer.getInteger(\"startTopicLabel\", 0);\n-        int partitionIndex = Integer.getInteger(\"partitionIndex\", 0);\n-        int numPartitions = Integer.getInteger(\"nPartitions\", 1);\n+        int numTopics = Integer.valueOf(cmd.getOptionValue(\"nTopics\", \"50\"));\n+        int numMessages = Integer.valueOf(cmd.getOptionValue(\"nMsgs\", \"1000\"));\n+        int numRegions = Integer.valueOf(cmd.getOptionValue(\"nRegions\", \"1\"));\n+        int startTopicLabel = Integer.valueOf(cmd.getOptionValue(\"startTopicLabel\", \"0\"));\n+        int partitionIndex = Integer.valueOf(cmd.getOptionValue(\"partitionIndex\", \"0\"));\n+        int numPartitions = Integer.valueOf(cmd.getOptionValue(\"nPartitions\", \"1\"));\n \n-        int replicaIndex = Integer.getInteger(\"replicaIndex\", 0);\n+        int replicaIndex = Integer.valueOf(cmd.getOptionValue(\"replicaIndex\", \"0\"));\n \n-        int rate = Integer.getInteger(\"rate\", 0);\n-        int nParallel = Integer.getInteger(\"npar\", 100);\n-        int msgSize = Integer.getInteger(\"msgSize\", 1024);\n+        int rate = Integer.valueOf(cmd.getOptionValue(\"rate\", \"0\"));\n+        int nParallel = Integer.valueOf(cmd.getOptionValue(\"npar\", \"100\"));\n+        int msgSize = Integer.valueOf(cmd.getOptionValue(\"msgSize\", \"1024\"));\n \n         // Number of warmup subscriptions to make.\n-        final int nWarmups = Integer.getInteger(\"nwarmups\", 1000);\n+        final int nWarmups = Integer.valueOf(cmd.getOptionValue(\"nwarmups\", \"1000\"));\n \n         if (mode.equals(\"sub\")) {\n             BenchmarkSubscriber benchmarkSub = new BenchmarkSubscriber(numTopics, 0, 1, startTopicLabel, 0, 1,\n@@ -108,19 +119,45 @@ public Void call() throws Exception {\n     }\n \n     public static void main(String[] args) throws Exception {\n-        ClientConfiguration cfg = new ClientConfiguration();\n-        if (args.length > 0) {\n-            String confFile = args[0];\n-            try {\n-                cfg.loadConf(new File(confFile).toURI().toURL());\n-            } catch (ConfigurationException e) {\n-                throw new RuntimeException(e);\n-            }\n+        Options options = new Options();\n+        options.addOption(\"mode\", true, \"sub, recv, or pub\");\n+        options.addOption(\"nTopics\", true, \"Number of topics, default 50\");\n+        options.addOption(\"nMsgs\", true, \"Number of messages, default 1000\");\n+        options.addOption(\"nRegions\", true, \"Number of regsions, default 1\");\n+        options.addOption(\"startTopicLabel\", true,\n+                          \"Prefix of topic labels. Must be numeric. Default 0\");\n+        options.addOption(\"partitionIndex\", true, \"If partitioning, the partition index for this client\");\n+        options.addOption(\"nPartitions\", true, \"Number of partitions, default 1\");\n+        options.addOption(\"replicaIndex\", true, \"default 0\");\n+        options.addOption(\"rate\", true, \"default 0\");\n+        options.addOption(\"npar\", true, \"default 100\");\n+        options.addOption(\"msgSize\", true, \"Size of messages, default 1024\");\n+        options.addOption(\"nwarmups\", true, \"Number of warmup messages, default 1000\");\n+        options.addOption(\"defaultHub\", true, \"Default hedwig hub to connect to, default localhost:4080\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        final CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"HedwigBenchmark <options>\", options);\n+            System.exit(-1);\n         }\n \n+        ClientConfiguration cfg = new ClientConfiguration() {\n+                public HedwigSocketAddress getDefaultServerHedwigSocketAddress() {\n+                    return new HedwigSocketAddress(cmd.getOptionValue(\"defaultHub\",\n+                                                                      \"localhost:4080\"));\n+                }\n+\n+                public boolean isSSLEnabled() {\n+                    return false;\n+                }\n+            };\n+\n         InternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n \n-        HedwigBenchmark app = new HedwigBenchmark(cfg);\n+        HedwigBenchmark app = new HedwigBenchmark(cfg, cmd);\n         app.call();\n         System.exit(0);\n     }"}]}

