{"sha":"5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1ZjlmNmVmMDcxOWExOWU0ODgxNWU4YjAyMWRhNDNlOGFkMTVmNmY3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-18T10:59:34Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-18T10:59:34Z"},"message":"BOOKKEEPER-369: re-factor hedwig cpp client to provide better interface to support both one-subscription-per-channel and multiple-subscriptions-per-channel. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1399578 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b6f8e7a452ea1bdd1088f3c3f6722e3fd8e48740","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b6f8e7a452ea1bdd1088f3c3f6722e3fd8e48740"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","html_url":"https://github.com/apache/bookkeeper/commit/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"cb059545270e4517c90d2b52000ea06404307f16","url":"https://api.github.com/repos/apache/bookkeeper/commits/cb059545270e4517c90d2b52000ea06404307f16","html_url":"https://github.com/apache/bookkeeper/commit/cb059545270e4517c90d2b52000ea06404307f16"}],"stats":{"total":3185,"additions":2383,"deletions":802},"files":[{"sha":"05a69fe2c680fee15a58837a8ded7471373270bf","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -198,6 +198,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-413: Hedwig C++ client: Rename RUN_AS_SSL_MODE to SSL_ENABLED (ivank via sijie)\n \n+        BOOKKEEPER-369: re-factor hedwig cpp client to provide better interface to support both one-subscription-per-channel and multiple-subscriptions-per-channel. (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"b44fed96eed9bdd3265fadc4bbba063cae683bf1","filename":"hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -32,16 +32,20 @@ namespace Hedwig {\n   class OomException : public ClientException {};\n   class UnknownRequestException : public ClientException {};\n   class InvalidRedirectException : public ClientException {};\n+  class NoChannelHandlerException : public ClientException {};\n \n   class PublisherException : public ClientException { };\n   \n-\n   class SubscriberException : public ClientException { };\n   class AlreadySubscribedException : public SubscriberException {};\n   class NotSubscribedException : public SubscriberException {};\n+  class ResubscribeException : public SubscriberException {};\n   class NullMessageHandlerException : public SubscriberException {};\n   class NullMessageFilterException : public SubscriberException {};\n \n+  class AlreadyStartDeliveryException : public SubscriberException {};\n+  class StartingDeliveryException : public SubscriberException {};\n+\n   class ConfigurationException : public ClientException { };\n   class InvalidPortException : public ConfigurationException {};\n   class HostResolutionException : public ClientException {};"},{"sha":"4bc718c2a1652fae51c9f1d655a165daa970235e","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -51,7 +51,10 @@ namespace Hedwig {\n \n     virtual void stopDelivery(const std::string& topic, const std::string& subscriberId) = 0;\n \n+    virtual bool hasSubscription(const std::string& topic, const std::string& subscriberId) = 0;\n     virtual void closeSubscription(const std::string& topic, const std::string& subscriberId) = 0;\n+    virtual void asyncCloseSubscription(const std::string& topic, const std::string& subscriberId,\n+                                        const OperationCallbackPtr& callback) = 0;\n \n     //\n     // API to register/unregister subscription listeners for receiving"},{"sha":"9a5dea59b8cad0dee02ded0e0509fcd08e3389af","filename":"hedwig-client/src/main/cpp/lib/Makefile.am","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/Makefile.am?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -19,7 +19,7 @@\n PROTODEF = ../../../../../hedwig-protocol/src/main/protobuf/PubSubProtocol.proto\n \n lib_LTLIBRARIES = libhedwig01.la\n-libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp filterablemessagehandler.cpp\n+libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp filterablemessagehandler.cpp simplesubscriberimpl.cpp\n libhedwig01_la_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS)\n libhedwig01_la_LIBADD = $(DEPS_LIBS) $(BOOST_CPPFLAGS) \n libhedwig01_la_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)"},{"sha":"3f573cbfbbb2490c9e2b694ddea2e47b6d240da7","filename":"hedwig-client/src/main/cpp/lib/channel.cpp","status":"modified","additions":5,"deletions":33,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/channel.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/channel.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -47,7 +47,6 @@ static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n \n-const bool DEFAULT_SSL_ENABLED = false;\n const std::string DEFAULT_SSL_PEM_FILE = \"\";\n \n AbstractDuplexChannel::AbstractDuplexChannel(IOServicePtr& service,\n@@ -67,6 +66,10 @@ AbstractDuplexChannel::~AbstractDuplexChannel() {\n   LOG4CXX_INFO(logger, \"Destroying DuplexChannel(\" << this << \")\");\n }\n \n+ChannelHandlerPtr AbstractDuplexChannel::getChannelHandler() {\n+  return handler;\n+}\n+\n /*static*/ void AbstractDuplexChannel::connectCallbackHandler(\n                   AbstractDuplexChannelPtr channel,\n                   OperationCallbackPtr callback,\n@@ -601,6 +604,7 @@ void AsioDuplexChannel::closeSocket() {\n   if (ec) {\n     LOG4CXX_WARN(logger, \"Channel \" << this << \" close error : \" << ec.message().c_str());\n   }\n+  LOG4CXX_DEBUG(logger, \"Closed socket for channel \" << this << \".\");\n }\n \n // SSL Context Factory\n@@ -795,35 +799,3 @@ void AsioSSLDuplexChannel::closeLowestLayer() {\n     LOG4CXX_WARN(logger, \"Channel \" << this << \" close error : \" << ec.message().c_str());\n   }\n }\n-\n-DuplexChannelManagerPtr DuplexChannelManager::create(const Configuration& conf,\n-                                                     EventDispatcher& dispatcher) {\n-  DuplexChannelManagerPtr factory(new DuplexChannelManager(conf, dispatcher));\n-  LOG4CXX_DEBUG(logger, \"Created DuplexChannelManager \" << factory);\n-  return factory;\n-}\n-\n-DuplexChannelManager::DuplexChannelManager(const Configuration& conf,\n-                                           EventDispatcher& dispatcher)\n-  : conf(conf), dispatcher(dispatcher) {\n-  sslEnabled = conf.getBool(Configuration::SSL_ENABLED, DEFAULT_SSL_ENABLED);\n-  if (sslEnabled) {\n-    sslCtxFactory = SSLContextFactoryPtr(new SSLContextFactory(conf));\n-  }\n-}\n-\n-DuplexChannelManager::~DuplexChannelManager() {\n-}\n-\n-DuplexChannelPtr DuplexChannelManager::createChannel(const HostAddress& addr,\n-                                                     const ChannelHandlerPtr& handler) {\n-  LOG4CXX_DEBUG(logger, \"Creating channel with handler \" << handler.get());\n-  IOServicePtr& service = dispatcher.getService();\n-  if (sslEnabled) {\n-    boost_ssl_context_ptr sslCtx =\n-      sslCtxFactory->createSSLContext(service->getService());\n-    return DuplexChannelPtr(new AsioSSLDuplexChannel(service, sslCtx, addr, handler));\n-  } else {\n-    return DuplexChannelPtr(new AsioDuplexChannel(service, addr, handler));\n-  }\n-}"},{"sha":"c9ef2892aed586edeb6d963c9074e3473cdb4a5f","filename":"hedwig-client/src/main/cpp/lib/channel.h","status":"modified","additions":5,"deletions":19,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/channel.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/channel.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -88,6 +88,9 @@ namespace Hedwig {\n   public:\n     virtual ~DuplexChannel() {}\n \n+    // Return the channel handler bound with a channel\n+    virtual ChannelHandlerPtr getChannelHandler() = 0;\n+\n     // Issues a connect request to the target host\n     // User could writeRequest after issued connect request, those requests should\n     // be buffered and written until the channel is connected.\n@@ -156,25 +159,6 @@ namespace Hedwig {\n \n   typedef boost::shared_ptr<SSLContextFactory> SSLContextFactoryPtr;\n \n-  class DuplexChannelManager;\n-  typedef boost::shared_ptr<DuplexChannelManager> DuplexChannelManagerPtr;\n-\n-  class DuplexChannelManager : public boost::enable_shared_from_this<DuplexChannelManager> {\n-  public:\n-    static DuplexChannelManagerPtr create(const Configuration& conf,\n-                                          EventDispatcher& dispatcher);\n-    ~DuplexChannelManager();\n-\n-    DuplexChannelPtr createChannel(const HostAddress& addr, const ChannelHandlerPtr& handler);\n-  private:\n-    DuplexChannelManager(const Configuration& conf, EventDispatcher& dispatcher);\n-\n-    const Configuration& conf;\n-    EventDispatcher& dispatcher;\n-    bool sslEnabled;\n-    SSLContextFactoryPtr sslCtxFactory;\n-  };\n-\n   class AbstractDuplexChannel;\n   typedef boost::shared_ptr<AbstractDuplexChannel> AbstractDuplexChannelPtr;\n \n@@ -186,6 +170,8 @@ namespace Hedwig {\n                           const ChannelHandlerPtr& handler);\n     virtual ~AbstractDuplexChannel();\n \n+    virtual ChannelHandlerPtr getChannelHandler();\n+\n     //\n     // Connect Operation\n     //"},{"sha":"bd192dce0f834b10b6dec910adfdcdac9974fc14","filename":"hedwig-client/src/main/cpp/lib/clientimpl.cpp","status":"modified","additions":490,"deletions":185,"changes":675,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/clientimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/clientimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -23,13 +23,16 @@\n #include \"channel.h\"\n #include \"publisherimpl.h\"\n #include \"subscriberimpl.h\"\n+#include \"simplesubscriberimpl.h\"\n #include <log4cxx/logger.h>\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n \n+const int DEFAULT_MESSAGE_FORCE_CONSUME_RETRY_WAIT_TIME = 5000;\n const std::string DEFAULT_SERVER_DEFAULT_VAL = \"\";\n+const bool DEFAULT_SSL_ENABLED = false;\n \n void SyncOperationCallback::wait() {\n   boost::unique_lock<boost::mutex> lock(mut);\n@@ -104,8 +107,51 @@ void SyncOperationCallback::throwExceptionIfNeeded() {\n   }\n }\n \n-HedwigClientChannelHandler::HedwigClientChannelHandler(const ClientImplPtr& client) \n-  : client(client){\n+ResponseHandler::ResponseHandler(const DuplexChannelManagerPtr& channelManager)\n+  : channelManager(channelManager) {\n+}\n+\n+void ResponseHandler::redirectRequest(const PubSubResponsePtr& response,\n+                                      const PubSubDataPtr& data,\n+                                      const DuplexChannelPtr& channel) {\n+  HostAddress oldhost = channel->getHostAddress();\n+  data->addTriedServer(oldhost);\n+\n+  HostAddress h;\n+  bool redirectToDefaultHost = true;\n+  if (response->has_statusmsg()) {\n+    try {\n+      h = HostAddress::fromString(response->statusmsg());\n+      redirectToDefaultHost = false;\n+    } catch (std::exception& e) {\n+      h = channelManager->getDefaultHost();\n+    }\n+  } else {\n+    h = channelManager->getDefaultHost();\n+  }\n+  if (data->hasTriedServer(h)) {\n+    LOG4CXX_ERROR(logger, \"We've been told to try request [\" << data->getTxnId() << \"] with [\" \n+\t\t                      << h.getAddressString()<< \"] by \" << oldhost.getAddressString() \n+\t\t                      << \" but we've already tried that. Failing operation\");\n+    data->getCallback()->operationFailed(InvalidRedirectException());\n+    return;\n+  }\n+  LOG4CXX_INFO(logger, \"We've been told  [\" << data->getTopic() << \"] is on [\" << h.getAddressString() \n+\t\t                   << \"] by [\" << oldhost.getAddressString() << \"]. Redirecting request \"\n+                       << data->getTxnId());\n+  data->setShouldClaim(true);\n+\n+  // submit the request again to the target host\n+  if (redirectToDefaultHost) {\n+    channelManager->submitOpToDefaultServer(data);\n+  } else {\n+    channelManager->redirectOpToHost(data, h);\n+  }\n+}\n+\n+HedwigClientChannelHandler::HedwigClientChannelHandler(const DuplexChannelManagerPtr& channelManager,\n+                                                       ResponseHandlerMap& handlers)\n+  : channelManager(channelManager), handlers(handlers), closed(false), disconnected(false) {\n }\n \n void HedwigClientChannelHandler::messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) {\n@@ -120,247 +166,421 @@ void HedwigClientChannelHandler::messageReceived(const DuplexChannelPtr& channel\n   /* you now have ownership of data, don't leave this funciton without deleting it or \n      palming it off to someone else */\n \n-  if (data == NULL) {\n+  if (data.get() == 0) {\n+    LOG4CXX_ERROR(logger, \"No pub/sub request for txnid(\" << m->txnid() << \").\");\n     return;\n   }\n \n-  if (m->statuscode() == NOT_RESPONSIBLE_FOR_TOPIC) {\n-    client->redirectRequest(channel, data, m);\n-    return;\n+  // Store the topic2Host mapping if this wasn't a server redirect.\n+  // TODO: add specific response for failure of getting topic ownership\n+  //       to distinguish SERVICE_DOWN to failure of getting topic ownership\n+  if (m->statuscode() != NOT_RESPONSIBLE_FOR_TOPIC) {\n+    const HostAddress& host = channel->getHostAddress();\n+    channelManager->setHostForTopic(data->getTopic(), host);\n   }\n \n-  switch (data->getType()) {\n-  case PUBLISH:\n-    client->getPublisherImpl().messageHandler(m, data);\n-    break;\n-  case SUBSCRIBE:\n-  case UNSUBSCRIBE:\n-    client->getSubscriberImpl().messageHandler(m, data);\n-    break;\n-  default:\n-    LOG4CXX_ERROR(logger, \"Unimplemented request type \" << data->getType());\n-    break;\n+  const ResponseHandlerPtr& respHandler = handlers[data->getType()];\n+  if (respHandler.get()) {\n+    respHandler->handleResponse(m, data, channel);\n+  } else {\n+    LOG4CXX_ERROR(logger, \"Unimplemented request type \" << data->getType() << \" : \"\n+                          << *data);\n+    data->getCallback()->operationFailed(UnknownRequestException());\n   }\n }\n \n-\n void HedwigClientChannelHandler::channelConnected(const DuplexChannelPtr& channel) {\n   // do nothing \n }\n \n-void HedwigClientChannelHandler::channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e) {\n-  LOG4CXX_ERROR(logger, \"Channel disconnected\");\n+void HedwigClientChannelHandler::channelDisconnected(const DuplexChannelPtr& channel,\n+                                                     const std::exception& e) {\n+  if (channelManager->isClosed()) {\n+    return;\n+  }\n \n-  client->channelDied(channel);\n+  // If this channel was closed explicitly by the client code,\n+  // we do not need to do any of this logic. This could happen\n+  // for redundant Publish channels created or redirected subscribe\n+  // channels that are not used anymore or when we shutdown the\n+  // client and manually close all of the open channels.\n+  // Also don't do any of the disconnect logic if the client has stopped.\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(close_lock);\n+    if (closed) {\n+      return;\n+    }\n+    if (disconnected) {\n+      return;\n+    }\n+    disconnected = true;\n+  }\n+  LOG4CXX_INFO(logger, \"Channel \" << channel.get() << \" was disconnected.\");\n+  // execute logic after channel disconnected\n+  onChannelDisconnected(channel);\n+}\n+\n+void HedwigClientChannelHandler::onChannelDisconnected(const DuplexChannelPtr& channel) {\n+  // Clean up the channel from channel manager\n+  channelManager->nonSubscriptionChannelDied(channel);\n }\n \n void HedwigClientChannelHandler::exceptionOccurred(const DuplexChannelPtr& channel, const std::exception& e) {\n   LOG4CXX_ERROR(logger, \"Exception occurred\" << e.what());\n }\n \n-ClientTxnCounter::ClientTxnCounter() : counter(0) \n-{\n+void HedwigClientChannelHandler::close() {\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(close_lock);\n+    if (closed) {\n+      return;\n+    }\n+    closed = true;\n+  }\n+  // do close handle logic here\n+  doClose();\n }\n \n-ClientTxnCounter::~ClientTxnCounter() {\n+void HedwigClientChannelHandler::doClose() {\n+  // do nothing for generic client channel handler\n }\n \n-/**\n-Increment the transaction counter and return the new value.\n+//\n+// Pub/Sub Request Write Callback\n+//\n+PubSubWriteCallback::PubSubWriteCallback(const DuplexChannelPtr& channel,\n+                                         const PubSubDataPtr& data)\n+  : channel(channel), data(data) {\n+}\n \n-@returns the next transaction id\n-*/\n-long ClientTxnCounter::next() {  // would be nice to remove lock from here, look more into it\n-  boost::lock_guard<boost::mutex> lock(mutex);\n+void PubSubWriteCallback::operationComplete() {\n+  LOG4CXX_INFO(logger, \"Successfully wrote pubsub request : \" << *data << \" to channel \"\n+                       << channel.get());\n+}\n \n-  long next= ++counter; \n+void PubSubWriteCallback::operationFailed(const std::exception& exception) {\n+  LOG4CXX_ERROR(logger, \"Error writing pubsub request (\" << *data << \") : \" << exception.what());\n \n-  return next;\n+  // remove the transaction from channel if write failed\n+  channel->retrieveTransaction(data->getTxnId());\n+  data->getCallback()->operationFailed(exception);\n }\n \n-ClientImplPtr ClientImpl::Create(const Configuration& conf) {\n-  ClientImplPtr impl(new ClientImpl(conf));\n-  LOG4CXX_DEBUG(logger, \"Creating Clientimpl \" << impl);\n-  impl->dispatcher->start();\n-  return impl;\n+//\n+// Default Server Connect Callback\n+//\n+DefaultServerConnectCallback::DefaultServerConnectCallback(const DuplexChannelManagerPtr& channelManager,\n+                                                           const DuplexChannelPtr& channel,\n+                                                           const PubSubDataPtr& data)\n+  : channelManager(channelManager), channel(channel), data(data) {\n }\n \n-void ClientImpl::Destroy() {\n-  LOG4CXX_DEBUG(logger, \"destroying Clientimpl \" << this);\n+void DefaultServerConnectCallback::operationComplete() {\n+  LOG4CXX_DEBUG(logger, \"Channel \" << channel.get() << \" is connected to host \"\n+                        << channel->getHostAddress() << \".\");\n+  // After connected, we got the right ip for the target host\n+  // so we could submit the request right now\n+  channelManager->submitOpThruChannel(data, channel);\n+}\n \n-  {\n-    boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n-    \n-    shuttingDownFlag = true;\n-    for (ChannelMap::iterator iter = allchannels.begin(); iter != allchannels.end(); ++iter ) {\n-      (*iter)->close();\n-    }  \n-    allchannels.clear();\n-  }\n-  // SSL Channel shutdown needs to send packets to server\n-  // so we only stop dispatcher after all channels are closed\n-  dispatcher->stop();\n+void DefaultServerConnectCallback::operationFailed(const std::exception& exception) {\n+  LOG4CXX_ERROR(logger, \"Channel \" << channel.get() << \" failed to connect to host \"\n+                        << channel->getHostAddress() << \" : \" << exception.what());\n+  data->getCallback()->operationFailed(exception);\n+}\n \n-  /* destruction of the maps will clean up any items they hold */\n-  \n-  if (subscriber != NULL) {\n-    delete subscriber;\n-    subscriber = NULL;\n+//\n+// Subscription Event Emitter\n+//\n+SubscriptionEventEmitter::SubscriptionEventEmitter() {}\n+\n+void SubscriptionEventEmitter::addSubscriptionListener(\n+  SubscriptionListenerPtr& listener) {\n+  boost::lock_guard<boost::shared_mutex> lock(listeners_lock);\n+  listeners.insert(listener);\n+}\n+\n+void SubscriptionEventEmitter::removeSubscriptionListener(\n+  SubscriptionListenerPtr& listener) {\n+  boost::lock_guard<boost::shared_mutex> lock(listeners_lock);\n+  listeners.erase(listener);\n+}\n+\n+void SubscriptionEventEmitter::emitSubscriptionEvent(\n+  const std::string& topic, const std::string& subscriberId,\n+  const SubscriptionEvent event) {\n+  boost::shared_lock<boost::shared_mutex> lock(listeners_lock);\n+  if (0 == listeners.size()) {\n+    return;\n   }\n-  if (publisher != NULL) {\n-    delete publisher;\n-    publisher = NULL;\n+  for (SubscriptionListenerSet::iterator iter = listeners.begin();\n+       iter != listeners.end(); ++iter) {\n+    (*iter)->processEvent(topic, subscriberId, event);\n   }\n }\n \n-ClientImpl::ClientImpl(const Configuration& conf) \n-  : conf(conf), publisher(NULL), subscriber(NULL), counterobj(), shuttingDownFlag(false)\n-{\n+//\n+// Channel Manager Used to manage all established channels\n+//\n+\n+DuplexChannelManagerPtr DuplexChannelManager::create(const Configuration& conf) {\n+  DuplexChannelManagerPtr manager(new SimpleDuplexChannelManager(conf));\n+  LOG4CXX_DEBUG(logger, \"Created DuplexChannelManager \" << manager);\n+  return manager;\n+}\n+\n+DuplexChannelManager::DuplexChannelManager(const Configuration& conf)\n+  : dispatcher(new EventDispatcher(conf)), conf(conf), closed(false), counterobj() {\n+  sslEnabled = conf.getBool(Configuration::SSL_ENABLED, DEFAULT_SSL_ENABLED); \n   defaultHost = HostAddress::fromString(conf.get(Configuration::DEFAULT_SERVER,\n                                                  DEFAULT_SERVER_DEFAULT_VAL));\n-  dispatcher = EventDispatcherPtr(new EventDispatcher(conf));\n-  channelManager = DuplexChannelManager::create(conf, *dispatcher);\n+  if (sslEnabled) {\n+    sslCtxFactory = SSLContextFactoryPtr(new SSLContextFactory(conf));\n+  }\n+  LOG4CXX_DEBUG(logger, \"Created DuplexChannelManager \" << this << \" with default server \"\n+                        << defaultHost);\n }\n \n-Subscriber& ClientImpl::getSubscriber() {\n-  return getSubscriberImpl();\n+DuplexChannelManager::~DuplexChannelManager() {\n+  LOG4CXX_DEBUG(logger, \"Destroyed DuplexChannelManager \" << this);\n }\n \n-Publisher& ClientImpl::getPublisher() {\n-  return getPublisherImpl();\n+void DuplexChannelManager::submitTo(const PubSubDataPtr& op, const DuplexChannelPtr& channel) {\n+  if (channel.get()) {\n+    channel->storeTransaction(op);\n+    OperationCallbackPtr writecb(new PubSubWriteCallback(channel, op));\n+    LOG4CXX_DEBUG(logger, \"Submit pub/sub request \" << *op << \" thru channel \" << channel.get());\n+    channel->writeRequest(op->getRequest(), writecb);\n+  } else {\n+    submitOpToDefaultServer(op);\n+  }\n }\n     \n-SubscriberImpl& ClientImpl::getSubscriberImpl() {\n-  if (subscriber == NULL) {\n-    boost::lock_guard<boost::mutex> lock(subscribercreate_lock);\n-    if (subscriber == NULL) {\n-      subscriber = new SubscriberImpl(shared_from_this());\n-    }\n+// Submit a pub/sub request\n+void DuplexChannelManager::submitOp(const PubSubDataPtr& op) {\n+  DuplexChannelPtr channel;\n+  switch (op->getType()) {\n+  case PUBLISH:\n+  case UNSUBSCRIBE:\n+    channel = getNonSubscriptionChannel(op->getTopic());  \n+    break;\n+  default:\n+    TopicSubscriber ts(op->getTopic(), op->getSubscriberId());\n+    channel = getSubscriptionChannel(ts, op->isResubscribeRequest());\n+    break;\n   }\n-  return *subscriber;\n+  // write the pub/sub request\n+  submitTo(op, channel);\n }\n \n-PublisherImpl& ClientImpl::getPublisherImpl() {\n-  if (publisher == NULL) { \n-    boost::lock_guard<boost::mutex> lock(publishercreate_lock);\n-    if (publisher == NULL) {\n-      publisher = new PublisherImpl(shared_from_this());\n+// Submit a pub/sub request to target host\n+void DuplexChannelManager::redirectOpToHost(const PubSubDataPtr& op, const HostAddress& addr) {\n+  DuplexChannelPtr channel;\n+  switch (op->getType()) {\n+  case PUBLISH:\n+  case UNSUBSCRIBE:\n+    // check whether there is a channel existed for non-subscription requests\n+    channel = getNonSubscriptionChannel(addr);\n+    if (!channel.get()) {\n+      channel = createNonSubscriptionChannel(addr);\n+      channel = storeNonSubscriptionChannel(channel, true);\n+    }\n+    break;\n+  default:\n+    channel = getSubscriptionChannel(addr);\n+    if (!channel.get()) {\n+      channel = createSubscriptionChannel(addr);\n+      channel = storeSubscriptionChannel(channel, true);\n     }\n+    break;\n   }\n-  return *publisher;\n+  // write the pub/sub request\n+  submitTo(op, channel);\n }\n \n-ClientTxnCounter& ClientImpl::counter() {\n-  return counterobj;\n+// Submit a pub/sub request to established request\n+void DuplexChannelManager::submitOpThruChannel(const PubSubDataPtr& op,\n+                                               const DuplexChannelPtr& ch) {\n+  DuplexChannelPtr channel;\n+  switch (op->getType()) {\n+  case PUBLISH:\n+  case UNSUBSCRIBE:\n+    channel = storeNonSubscriptionChannel(ch, false);\n+    break;\n+  default:\n+    channel = storeSubscriptionChannel(ch, false);\n+    break;\n+  }\n+  // write the pub/sub request\n+  submitTo(op, channel);\n }\n \n-void ClientImpl::redirectRequest(const DuplexChannelPtr& channel, PubSubDataPtr& data, const PubSubResponsePtr& response) {\n-  HostAddress oldhost = channel->getHostAddress();\n-  data->addTriedServer(oldhost);\n-  \n-  HostAddress h = HostAddress::fromString(response->statusmsg());\n-  if (data->hasTriedServer(h)) {\n-    LOG4CXX_ERROR(logger, \"We've been told to try request [\" << data->getTxnId() << \"] with [\" \n-\t\t  << h.getAddressString()<< \"] by \" << oldhost.getAddressString() \n-\t\t  << \" but we've already tried that. Failing operation\");\n-    data->getCallback()->operationFailed(InvalidRedirectException());\n-    return;\n+// Submit a pub/sub request to default server\n+void DuplexChannelManager::submitOpToDefaultServer(const PubSubDataPtr& op) {\n+  DuplexChannelPtr channel;\n+  switch (op->getType()) {\n+  case PUBLISH:\n+  case UNSUBSCRIBE:\n+    channel = createNonSubscriptionChannel(defaultHost);\n+    break;\n+  default:\n+    channel = createSubscriptionChannel(defaultHost);\n+    break;\n   }\n-  LOG4CXX_DEBUG(logger, \"We've been told  [\" << data->getTopic() << \"] is on [\" << h.getAddressString() \n-\t\t<< \"] by [\" << oldhost.getAddressString() << \"]. Redirecting request \" << data->getTxnId());\n-  data->setShouldClaim(true);\n+  OperationCallbackPtr connectCallback(new DefaultServerConnectCallback(shared_from_this(),\n+                                                                        channel, op));\n+  // connect to default server. usually default server is a VIP, we only got the real\n+  // IP address after connected. so before connected, we don't know the real target host.\n+  // we only submit the request after channel is connected (ip address would be updated).\n+  channel->connect(connectCallback);\n+}\n \n-  setHostForTopic(data->getTopic(), h);\n-  DuplexChannelPtr newchannel;\n-  try {\n-    if (data->getType() == SUBSCRIBE) {\n-      // a redirect for subscription, kill old channel and remove old channel from all channels list\n-      // otherwise old channel will not be destroyed, caused lost of CLOSE_WAIT connections\n-      removeAndCloseChannel(channel);\n-\n-      SubscriberClientChannelHandlerPtr handler(new SubscriberClientChannelHandler(shared_from_this(), \n-\t\t\t\t\t\t\t\t\t\t   this->getSubscriberImpl(), data));\n-      newchannel = createChannel(data->getTopic(), handler);\n-      handler->setChannel(newchannel);\n-      newchannel->connect();\n-      getSubscriberImpl().doSubscribe(newchannel, data, handler);\n-    } else if (data->getType() == PUBLISH) {\n-      newchannel = getChannel(data->getTopic());\n-      getPublisherImpl().doPublish(newchannel, data);\n-    } else {\n-      newchannel = getChannel(data->getTopic());\n-      getSubscriberImpl().doUnsubscribe(newchannel, data);\n+DuplexChannelPtr DuplexChannelManager::getNonSubscriptionChannel(const std::string& topic) {\n+  HostAddress addr;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(topic2host_lock);\n+    addr = topic2host[topic];\n+  }\n+  if (addr.isNullHost()) {\n+    return DuplexChannelPtr();\n+  } else {\n+    // we had known which hub server owned the topic\n+    DuplexChannelPtr ch = getNonSubscriptionChannel(addr);\n+    if (ch.get()) {\n+      return ch;\n     }\n-  } catch (ShuttingDownException& e) {\n-    return; // no point in redirecting if we're shutting down\n+    ch = createNonSubscriptionChannel(addr);\n+    return storeNonSubscriptionChannel(ch, true);\n   }\n }\n \n-ClientImpl::~ClientImpl() {\n-  LOG4CXX_DEBUG(logger, \"deleting Clientimpl \" << this);\n+DuplexChannelPtr DuplexChannelManager::getNonSubscriptionChannel(const HostAddress& addr) {\n+  boost::shared_lock<boost::shared_mutex> lock(host2channel_lock);\n+  return host2channel[addr];\n }\n \n-DuplexChannelPtr ClientImpl::createChannel(const std::string& topic, const ChannelHandlerPtr& handler) {\n-  // get the host address\n-  // create a channel to the host\n-  HostAddress addr;\n+DuplexChannelPtr DuplexChannelManager::createNonSubscriptionChannel(const HostAddress& addr) {\n+  // Create a non-subscription channel handler\n+  ChannelHandlerPtr handler(new HedwigClientChannelHandler(shared_from_this(),\n+                                                           nonSubscriptionHandlers));\n+  // Create a non subscription channel\n+  return createChannel(dispatcher->getService(), addr, handler);\n+}\n+\n+DuplexChannelPtr DuplexChannelManager::storeNonSubscriptionChannel(const DuplexChannelPtr& ch,\n+                                                                   bool doConnect) {\n+  const HostAddress& host = ch->getHostAddress();\n+\n+  bool useOldCh;\n+  DuplexChannelPtr oldCh;\n   {\n-    boost::lock_guard<boost::shared_mutex> lock(topic2host_lock);\n-    addr = topic2host[topic];\n-  }\n-  if (addr.isNullHost()) {\n-    addr = defaultHost;\n-    setHostForTopic(topic, addr);\n+    boost::lock_guard<boost::shared_mutex> lock(host2channel_lock);\n+\n+    oldCh = host2channel[host];\n+    if (!oldCh.get()) {\n+      host2channel[host] = ch;\n+      useOldCh = false;\n+    } else {\n+      // If we've reached here, that means we already have a Channel\n+      // mapping for the given host. This should ideally not happen\n+      // and it means we are creating another Channel to a server host\n+      // to publish on when we could have used an existing one. This could\n+      // happen due to a race condition if initially multiple concurrent\n+      // threads are publishing on the same topic and no Channel exists\n+      // currently to the server. We are not synchronizing this initial\n+      // creation of Channels to a given host for performance.\n+      // Another possible way to have redundant Channels created is if\n+      // a new topic is being published to, we connect to the default\n+      // server host which should be a VIP that redirects to a \"real\"\n+      // server host. Since we don't know beforehand what is the full\n+      // set of server hosts, we could be redirected to a server that\n+      // we already have a channel connection to from a prior existing\n+      // topic. Close these redundant channels as they won't be used.\n+      useOldCh = true;\n+    }\n+  } \n+  if (useOldCh) {\n+    LOG4CXX_DEBUG(logger, \"Channel \" << oldCh.get() << \" to host \" << host\n+                          << \" already exists so close channel \" << ch.get() << \".\");\n+    ch->close();\n+    return oldCh;\n+  } else {\n+    if (doConnect) {\n+      ch->connect();\n+    }\n+    LOG4CXX_DEBUG(logger, \"Storing channel \" << ch.get() << \" for host \" << host << \".\");\n+    return ch;\n   }\n+}\n \n-  DuplexChannelPtr channel = channelManager->createChannel(addr, handler);\n+DuplexChannelPtr DuplexChannelManager::createChannel(IOServicePtr& service,\n+                                                     const HostAddress& addr,\n+                                                     const ChannelHandlerPtr& handler) {\n+  DuplexChannelPtr channel;\n+  if (sslEnabled) {\n+    boost_ssl_context_ptr sslCtx = sslCtxFactory->createSSLContext(service->getService());\n+    channel = DuplexChannelPtr(new AsioSSLDuplexChannel(service, sslCtx, addr, handler));\n+  } else {\n+    channel = DuplexChannelPtr(new AsioDuplexChannel(service, addr, handler));\n+  }\n \n   boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n-  if (shuttingDownFlag) {\n+  if (closed) {\n     channel->close();\n     throw ShuttingDownException();\n   }\n-  // Don't connect here, otherwise connect callback may be triggered before setChannel\n-  // channel->connect();\n-\n   allchannels.insert(channel);\n-  LOG4CXX_DEBUG(logger, \"(create) All channels size: \" << allchannels.size());\n+  LOG4CXX_DEBUG(logger, \"Created a channel to \" << addr << \", all channels : \" << allchannels.size());\n \n   return channel;\n }\n \n-DuplexChannelPtr ClientImpl::getChannel(const std::string& topic) {\n-  HostAddress addr;\n-  {\n-    boost::lock_guard<boost::shared_mutex> lock(topic2host_lock);\n-    addr = topic2host[topic];\n-  }\n-  if (addr.isNullHost()) {\n-    addr = defaultHost;\n-    setHostForTopic(topic, addr);\n-  }  \n-  DuplexChannelPtr channel = host2channel[addr];\n-\n-  if (channel.get() == 0) {\n-    LOG4CXX_DEBUG(logger, \" No channel for topic, creating new channel.get() \" << channel.get() << \" addr \" << addr.getAddressString());\n-    ChannelHandlerPtr handler(new HedwigClientChannelHandler(shared_from_this()));\n-    channel = createChannel(topic, handler);\n-    channel->connect();\n+long DuplexChannelManager::nextTxnId() {\n+  return counterobj.next();\n+}\n \n-    boost::lock_guard<boost::shared_mutex> lock(host2channel_lock);\n-    host2channel[addr] = channel;\n-  } \n+void DuplexChannelManager::setHostForTopic(const std::string& topic, const HostAddress& host) {\n+  boost::lock_guard<boost::shared_mutex> h2clock(host2topics_lock);\n+  boost::lock_guard<boost::shared_mutex> t2hlock(topic2host_lock);\n+  topic2host[topic] = host;\n+  TopicSetPtr ts = host2topics[host];\n+  if (!ts.get()) {\n+    ts = TopicSetPtr(new TopicSet());\n+    host2topics[host] = ts;\n+  }\n+  ts->insert(topic);\n+  LOG4CXX_DEBUG(logger, \"Set ownership of topic \" << topic << \" to \" << host << \".\");\n+}\n \n-  return channel;\n+const HostAddress& DuplexChannelManager::getHostForTopic(const std::string& topic) {\n+  boost::shared_lock<boost::shared_mutex> t2hlock(topic2host_lock);\n+  return topic2host[topic];\n }\n \n-void ClientImpl::setHostForTopic(const std::string& topic, const HostAddress& host) {\n-  boost::lock_guard<boost::shared_mutex> lock(topic2host_lock);\n-  topic2host[topic] = host;\n+void DuplexChannelManager::clearAllTopicsForHost(const HostAddress& addr) {\n+  // remove topic mapping\n+  boost::lock_guard<boost::shared_mutex> h2tlock(host2topics_lock);\n+  boost::lock_guard<boost::shared_mutex> t2hlock(topic2host_lock);\n+  Host2TopicsMap::iterator iter = host2topics.find(addr);\n+  if (iter != host2topics.end()) {\n+    for (TopicSet::iterator tsIter = iter->second->begin();\n+         tsIter != iter->second->end(); ++tsIter) {\n+      topic2host.erase(*tsIter);\n+    }\n+    host2topics.erase(iter);\n+  }\n }\n \n-bool ClientImpl::shuttingDown() const {\n-  return shuttingDownFlag;\n+void DuplexChannelManager::clearHostForTopic(const std::string& topic,\n+                                             const HostAddress& addr) {\n+  // remove topic mapping\n+  boost::lock_guard<boost::shared_mutex> h2tlock(host2topics_lock);\n+  boost::lock_guard<boost::shared_mutex> t2hlock(topic2host_lock);\n+  Host2TopicsMap::iterator iter = host2topics.find(addr);\n+  if (iter != host2topics.end()) {\n+    iter->second->erase(topic);\n+  }\n+  topic2host.erase(topic);\n }\n \n /**\n@@ -369,35 +589,120 @@ bool ClientImpl::shuttingDown() const {\n    This does not delete the channel. Some publishers or subscribers will still hold it and will be errored\n    when they try to do anything with it. \n */\n-void ClientImpl::channelDied(const DuplexChannelPtr& channel) {\n-  if (shuttingDownFlag) {\n-    return;\n-  }\n-\n-  boost::lock_guard<boost::shared_mutex> h2tlock(host2topics_lock);\n-  boost::lock_guard<boost::shared_mutex> h2clock(host2channel_lock);\n-  boost::lock_guard<boost::shared_mutex> t2hlock(topic2host_lock);\n+void DuplexChannelManager::nonSubscriptionChannelDied(const DuplexChannelPtr& channel) {\n   // get host\n   HostAddress addr = channel->getHostAddress();\n-  \n-  for (Host2TopicsMap::iterator iter = host2topics.find(addr); iter != host2topics.end(); ++iter) {\n-    topic2host.erase((*iter).second);\n+\n+  // Clear the topic owner ship when a nonsubscription channel disconnected\n+  clearAllTopicsForHost(addr);\n+\n+  // remove channel mapping\n+  {\n+    boost::lock_guard<boost::shared_mutex> h2clock(host2channel_lock);\n+    host2channel.erase(addr);\n   }\n-  host2topics.erase(addr);\n-  host2channel.erase(addr);\n-  removeAndCloseChannel(channel);\n+  removeChannel(channel);\n }\n \n-void ClientImpl::removeAndCloseChannel(const DuplexChannelPtr& channel) {\n-  boost::lock_guard<boost::shared_mutex> aclock(allchannels_lock);\n-  allchannels.erase(channel); // channel should be deleted here\n-  channel->close(); // close channel\n+void DuplexChannelManager::removeChannel(const DuplexChannelPtr& channel) {\n+  {\n+    boost::lock_guard<boost::shared_mutex> aclock(allchannels_lock);\n+    allchannels.erase(channel); // channel should be deleted here\n+  }\n+  channel->close();\n+}\n+\n+void DuplexChannelManager::start() {\n+  // add non-subscription response handlers\n+  nonSubscriptionHandlers[PUBLISH] =\n+    ResponseHandlerPtr(new PublishResponseHandler(shared_from_this()));\n+  nonSubscriptionHandlers[UNSUBSCRIBE] =\n+    ResponseHandlerPtr(new UnsubscribeResponseHandler(shared_from_this()));\n+\n+  // start the dispatcher\n+  dispatcher->start();\n }\n \n-const Configuration& ClientImpl::getConfiguration() {\n-  return conf;\n+bool DuplexChannelManager::isClosed() {\n+  boost::shared_lock<boost::shared_mutex> lock(allchannels_lock);\n+  return closed;\n }\n \n-boost::asio::io_service& ClientImpl::getService() {\n-  return dispatcher->getService()->getService();\n+void DuplexChannelManager::close() {\n+  // stop the dispatcher\n+  dispatcher->stop();\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n+    \n+    closed = true;\n+    for (ChannelMap::iterator iter = allchannels.begin(); iter != allchannels.end(); ++iter ) {\n+      (*iter)->close();\n+    }  \n+    allchannels.clear();\n+  }\n+\n+  // Unregistered response handlers\n+  nonSubscriptionHandlers.clear();\n+  /* destruction of the maps will clean up any items they hold */\n+}\n+\n+ClientImplPtr ClientImpl::Create(const Configuration& conf) {\n+  ClientImplPtr impl(new ClientImpl(conf));\n+  LOG4CXX_DEBUG(logger, \"Creating Clientimpl \" << impl);\n+  impl->channelManager->start();\n+  return impl;\n+}\n+\n+void ClientImpl::Destroy() {\n+  LOG4CXX_DEBUG(logger, \"destroying Clientimpl \" << this);\n+\n+  // close the channel manager\n+  channelManager->close();\n+\n+  if (subscriber != NULL) {\n+    delete subscriber;\n+    subscriber = NULL;\n+  }\n+  if (publisher != NULL) {\n+    delete publisher;\n+    publisher = NULL;\n+  }\n+}\n+\n+ClientImpl::ClientImpl(const Configuration& conf) \n+  : conf(conf), publisher(NULL), subscriber(NULL)\n+{\n+  channelManager = DuplexChannelManager::create(conf);\n+}\n+\n+Subscriber& ClientImpl::getSubscriber() {\n+  return getSubscriberImpl();\n+}\n+\n+Publisher& ClientImpl::getPublisher() {\n+  return getPublisherImpl();\n+}\n+    \n+SubscriberImpl& ClientImpl::getSubscriberImpl() {\n+  if (subscriber == NULL) {\n+    boost::lock_guard<boost::mutex> lock(subscribercreate_lock);\n+    if (subscriber == NULL) {\n+      subscriber = new SubscriberImpl(channelManager);\n+    }\n+  }\n+  return *subscriber;\n+}\n+\n+PublisherImpl& ClientImpl::getPublisherImpl() {\n+  if (publisher == NULL) { \n+    boost::lock_guard<boost::mutex> lock(publishercreate_lock);\n+    if (publisher == NULL) {\n+      publisher = new PublisherImpl(channelManager);\n+    }\n+  }\n+  return *publisher;\n+}\n+\n+ClientImpl::~ClientImpl() {\n+  LOG4CXX_DEBUG(logger, \"deleting Clientimpl \" << this);\n }"},{"sha":"f8fc86b89aff0ce9fc7d6ab2cc9799f1d5f9ec04","filename":"hedwig-client/src/main/cpp/lib/clientimpl.h","status":"modified","additions":284,"deletions":45,"changes":329,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/clientimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/clientimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -164,22 +164,301 @@ namespace Hedwig {\n     int timeout;\n   };\n \n+  class DuplexChannelManager;\n+  typedef boost::shared_ptr<DuplexChannelManager> DuplexChannelManagerPtr;\n+\n+  //\n+  // Hedwig Response Handler\n+  //\n+\n+  // Response Handler used to process response for different types of requests\n+  class ResponseHandler {\n+  public:\n+    ResponseHandler(const DuplexChannelManagerPtr& channelManager); \n+    virtual ~ResponseHandler() {};\n+\n+    virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                                const DuplexChannelPtr& channel) = 0;\n+  protected:\n+    // common method used to redirect request\n+    void redirectRequest(const PubSubResponsePtr& response, const PubSubDataPtr& data,\n+                         const DuplexChannelPtr& channel);\n+\n+    // channel manager to manage all established channels\n+    const DuplexChannelManagerPtr channelManager;\n+  };\n+\n+  typedef boost::shared_ptr<ResponseHandler> ResponseHandlerPtr;\n+  typedef std::tr1::unordered_map<OperationType, ResponseHandlerPtr, OperationTypeHash> ResponseHandlerMap;\n+\n+  class PubSubWriteCallback : public OperationCallback {\n+  public:\n+    PubSubWriteCallback(const DuplexChannelPtr& channel, const PubSubDataPtr& data); \n+    virtual void operationComplete();\n+    virtual void operationFailed(const std::exception& exception);\n+  private:\n+    DuplexChannelPtr channel;\n+    PubSubDataPtr data;\n+  };\n+\n+  class DefaultServerConnectCallback : public OperationCallback {\n+  public:\n+    DefaultServerConnectCallback(const DuplexChannelManagerPtr& channelManager,\n+                                 const DuplexChannelPtr& channel,\n+                                 const PubSubDataPtr& data);\n+    virtual void operationComplete();\n+    virtual void operationFailed(const std::exception& exception);\n+  private:\n+    DuplexChannelManagerPtr channelManager;\n+    DuplexChannelPtr channel;\n+    PubSubDataPtr data;\n+  };\n+\n+  struct SubscriptionListenerPtrHash : public std::unary_function<SubscriptionListenerPtr, size_t> {\n+    size_t operator()(const Hedwig::SubscriptionListenerPtr& listener) const {\n+      return reinterpret_cast<size_t>(listener.get());\n+    }\n+  };\n+\n+  // Subscription Event Emitter\n+  class SubscriptionEventEmitter {\n+  public:\n+    SubscriptionEventEmitter();\n+\n+    void addSubscriptionListener(SubscriptionListenerPtr& listener);\n+    void removeSubscriptionListener(SubscriptionListenerPtr& listener);\n+    void emitSubscriptionEvent(const std::string& topic,\n+                               const std::string& subscriberId,\n+                               const SubscriptionEvent event);\n+\n+  private:\n+    typedef std::tr1::unordered_set<SubscriptionListenerPtr, SubscriptionListenerPtrHash> SubscriptionListenerSet;\n+    SubscriptionListenerSet listeners;\n+    boost::shared_mutex listeners_lock;\n+  };\n+\n+  class SubscriberClientChannelHandler;\n+\n+  //\n+  // Duplex Channel Manager to manage all established channels\n+  //\n+\n+  class DuplexChannelManager : public boost::enable_shared_from_this<DuplexChannelManager> {\n+  public:\n+    static DuplexChannelManagerPtr create(const Configuration& conf);\n+    virtual ~DuplexChannelManager();\n+\n+    inline const Configuration& getConfiguration() const {\n+      return conf;\n+    }\n+\n+    // Submit a pub/sub request\n+    void submitOp(const PubSubDataPtr& op);\n+\n+    // Submit a pub/sub request to default host\n+    // It is called only when client doesn't have the knowledge of topic ownership\n+    void submitOpToDefaultServer(const PubSubDataPtr& op);\n+\n+    // Redirect pub/sub request to a target hosts\n+    void redirectOpToHost(const PubSubDataPtr& op, const HostAddress& host);\n+\n+    // Submit a pub/sub request thru established channel\n+    // It is called when connecting to default server to established a channel\n+    void submitOpThruChannel(const PubSubDataPtr& op, const DuplexChannelPtr& channel);\n+\n+    // Generate next transaction id for pub/sub requests sending thru this manager\n+    long nextTxnId();\n+\n+    // return default host\n+    inline const HostAddress& getDefaultHost() { return defaultHost; }\n+\n+    // set the owner host of a topic\n+    void setHostForTopic(const std::string& topic, const HostAddress& host);\n+\n+    // clear all topics that hosted by a hub server\n+    void clearAllTopicsForHost(const HostAddress& host);\n+\n+    // clear host for a given topic\n+    void clearHostForTopic(const std::string& topic, const HostAddress& host);\n+\n+    // Called when a channel is disconnected\n+    void nonSubscriptionChannelDied(const DuplexChannelPtr& channel);\n+\n+    // Remove a channel from all channel map\n+    void removeChannel(const DuplexChannelPtr& channel);\n+\n+    // Get the subscription channel handler for a given subscription\n+    virtual boost::shared_ptr<SubscriberClientChannelHandler>\n+            getSubscriptionChannelHandler(const TopicSubscriber& ts) = 0;\n+\n+    // Close subscription for a given subscription\n+    virtual void asyncCloseSubscription(const TopicSubscriber& ts,\n+                                        const OperationCallbackPtr& callback) = 0;\n+\n+    virtual void handoverDelivery(const TopicSubscriber& ts,\n+                                  const MessageHandlerCallbackPtr& handler,\n+                                  const ClientMessageFilterPtr& filter) = 0;\n+\n+    // start the channel manager\n+    virtual void start();\n+    // close the channel manager\n+    virtual void close();\n+    // whether the channel manager is closed\n+    bool isClosed();\n+\n+    // Return an available service\n+    inline boost::asio::io_service & getService() const {\n+      return dispatcher->getService()->getService();\n+    }\n+\n+    // Return the event emitter\n+    inline SubscriptionEventEmitter& getEventEmitter() {\n+      return eventEmitter;\n+    }\n+\n+  protected:\n+    DuplexChannelManager(const Configuration& conf);\n+\n+    // Get the ownership for a given topic.\n+    const HostAddress& getHostForTopic(const std::string& topic);\n+\n+    //\n+    // Channel Management\n+    //\n+\n+    // Non subscription channel management\n+\n+    // Get a non subscription channel for a given topic\n+    // If the topic's owner is known, retrieve a subscription channel to\n+    // target host (if there is no channel existed, create one);\n+    // If the topic's owner is unknown, return null\n+    DuplexChannelPtr getNonSubscriptionChannel(const std::string& topic);\n+\n+    // Get an existed non subscription channel to a given host\n+    DuplexChannelPtr getNonSubscriptionChannel(const HostAddress& addr);\n+\n+    // Create a non subscription channel to a given host\n+    DuplexChannelPtr createNonSubscriptionChannel(const HostAddress& addr);\n+\n+    // Store the established non subscription channel\n+    DuplexChannelPtr storeNonSubscriptionChannel(const DuplexChannelPtr& ch,\n+                                                 bool doConnect); \n+\n+    //\n+    // Subscription Channel Management\n+    //\n+\n+    // Get a subscription channel for a given subscription.\n+    // If there is subscription channel established before, return it.\n+    // Otherwise, check whether the topic's owner is known. If the topic owner\n+    // is known, retrieve a subscription channel to target host (if there is no\n+    // channel exsited, create one); If unknown, return null\n+    virtual DuplexChannelPtr getSubscriptionChannel(const TopicSubscriber& ts,\n+                                                    const bool isResubscribeRequest) = 0;\n+\n+    // Get an existed subscription channel to a given host\n+    virtual DuplexChannelPtr getSubscriptionChannel(const HostAddress& addr) = 0;\n+\n+    // Create a subscription channel to a given host\n+    // If store is true, store the channel for future usage.\n+    // If store is false, return a newly created channel.\n+    virtual DuplexChannelPtr createSubscriptionChannel(const HostAddress& addr) = 0;\n+\n+    // Store the established subscription channel\n+    virtual DuplexChannelPtr storeSubscriptionChannel(const DuplexChannelPtr& ch,\n+                                                      bool doConnect) = 0;\n+\n+    //\n+    // Raw Channel Management\n+    //\n+\n+    // Create a raw channel\n+    DuplexChannelPtr createChannel(IOServicePtr& service,\n+                                   const HostAddress& addr, const ChannelHandlerPtr& handler);\n+\n+    // event dispatcher running io threads\n+    typedef boost::shared_ptr<EventDispatcher> EventDispatcherPtr;\n+    EventDispatcherPtr dispatcher;\n+\n+    // topic2host mapping for topic ownership\n+    std::tr1::unordered_map<std::string, HostAddress> topic2host;\n+    boost::shared_mutex topic2host_lock;\n+    typedef std::tr1::unordered_set<std::string> TopicSet;\n+    typedef boost::shared_ptr<TopicSet> TopicSetPtr;\n+    typedef std::tr1::unordered_map<HostAddress, TopicSetPtr, HostAddressHash> Host2TopicsMap;\n+    Host2TopicsMap host2topics;\n+    boost::shared_mutex host2topics_lock;\n+  private:\n+    // write the request to target channel\n+    void submitTo(const PubSubDataPtr& op, const DuplexChannelPtr& channel);\n+\n+    const Configuration& conf;\n+    bool sslEnabled;\n+    SSLContextFactoryPtr sslCtxFactory;\n+\n+    // whether the channel manager is shutting down\n+    bool closed;\n+\n+    // counter used for generating transaction ids\n+    ClientTxnCounter counterobj;\n+\n+    // default host\n+    HostAddress defaultHost;\n+\n+    // non-subscription channels\n+    std::tr1::unordered_map<HostAddress, DuplexChannelPtr, HostAddressHash > host2channel;\n+    boost::shared_mutex host2channel_lock;\n+\n+    // maintain all established channels\n+    typedef std::tr1::unordered_set<DuplexChannelPtr, DuplexChannelPtrHash > ChannelMap;\n+    ChannelMap allchannels;\n+    boost::shared_mutex allchannels_lock;\n+\n+    // Response Handlers for non-subscription requests\n+    ResponseHandlerMap nonSubscriptionHandlers;\n+\n+    // Subscription Event Emitter\n+    SubscriptionEventEmitter eventEmitter;\n+  };\n+\n+  //\n+  // Hedwig Client Channel Handler to handle responses received from the channel\n+  //\n+\n   class HedwigClientChannelHandler : public ChannelHandler {\n   public:\n-    HedwigClientChannelHandler(const ClientImplPtr& client);\n+    HedwigClientChannelHandler(const DuplexChannelManagerPtr& channelManager,\n+                               ResponseHandlerMap& handlers);\n+    virtual ~HedwigClientChannelHandler() {}\n     \n     virtual void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m);\n     virtual void channelConnected(const DuplexChannelPtr& channel);\n     virtual void channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e);\n     virtual void exceptionOccurred(const DuplexChannelPtr& channel, const std::exception& e);\n-    \n+\n+    void close();\n   protected:\n-    const ClientImplPtr client;\n+    // real channel disconnected logic\n+    virtual void onChannelDisconnected(const DuplexChannelPtr& channel);\n+\n+    // real close logic\n+    virtual void doClose();\n+\n+    // channel manager to manage all established channels\n+    const DuplexChannelManagerPtr channelManager;\n+    ResponseHandlerMap& handlers;\n+\n+    boost::shared_mutex close_lock;\n+    // Boolean indicating if we closed the handler explicitly or not.\n+    // If so, we do not need to do the channel disconnected logic here.\n+    bool closed;\n+    // whether channel is disconnected.\n+    bool disconnected;\n   };\n   \n   class PublisherImpl;\n   class SubscriberImpl;\n-  \n+\n   /**\n      Implementation of the hedwig client. This class takes care of globals such as the topic->host map and the transaction id counter.\n   */\n@@ -191,30 +470,9 @@ namespace Hedwig {\n     Subscriber& getSubscriber();\n     Publisher& getPublisher();\n \n-    ClientTxnCounter& counter();\n-\n-    void redirectRequest(const DuplexChannelPtr& channel, PubSubDataPtr& data, const PubSubResponsePtr& response);\n-\n-    const HostAddress& getHostForTopic(const std::string& topic);\n-\n-    //DuplexChannelPtr getChannelForTopic(const std::string& topic, OperationCallback& callback);\n-    //DuplexChannelPtr createChannelForTopic(const std::string& topic, ChannelHandlerPtr& handler, OperationCallback& callback);\n-    DuplexChannelPtr createChannel(const std::string& topic, const ChannelHandlerPtr& handler);    \n-    DuplexChannelPtr getChannel(const std::string& topic);\n-\n-    void setHostForTopic(const std::string& topic, const HostAddress& host);\n-\n-    void setChannelForHost(const HostAddress& address, const DuplexChannelPtr& channel);\n-    void channelDied(const DuplexChannelPtr& channel);\n-    void removeAndCloseChannel(const DuplexChannelPtr& channel);\n-    bool shuttingDown() const;\n-    \n     SubscriberImpl& getSubscriberImpl();\n     PublisherImpl& getPublisherImpl();\n \n-    const Configuration& getConfiguration();\n-    boost::asio::io_service& getService();\n-\n     ~ClientImpl();\n   private:\n     ClientImpl(const Configuration& conf);\n@@ -227,27 +485,8 @@ namespace Hedwig {\n     boost::mutex subscribercreate_lock;\n     SubscriberImpl* subscriber;\n \n-    ClientTxnCounter counterobj;\n-\n-    typedef boost::shared_ptr<EventDispatcher> EventDispatcherPtr;\n-    EventDispatcherPtr dispatcher;\n+    // channel manager manage all channels for the client\n     DuplexChannelManagerPtr channelManager;\n-\n-    typedef std::tr1::unordered_multimap<HostAddress, std::string, HostAddressHash > Host2TopicsMap;\n-    Host2TopicsMap host2topics;\n-    boost::shared_mutex host2topics_lock;\n-    HostAddress defaultHost;\n-\n-    std::tr1::unordered_map<HostAddress, DuplexChannelPtr, HostAddressHash > host2channel;\n-    boost::shared_mutex host2channel_lock;\n-    std::tr1::unordered_map<std::string, HostAddress> topic2host;\n-    boost::shared_mutex topic2host_lock;\n-\n-    typedef std::tr1::unordered_set<DuplexChannelPtr, DuplexChannelPtrHash > ChannelMap;\n-    ChannelMap allchannels;\n-    boost::shared_mutex allchannels_lock;\n-\n-    bool shuttingDownFlag;\n   };\n };\n #endif"},{"sha":"9f81e28e3108dba2de300948e446baa91c0cd8cc","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"modified","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -23,11 +23,23 @@\n #include \"data.h\"\n \n #include <log4cxx/logger.h>\n+#include <iostream>\n+\n+#define stringify( name ) #name\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n \n+const char* OPERATION_TYPE_NAMES[] = {\n+  stringify( PUBLISH ),\n+  stringify( SUBSCRIBE ),\n+  stringify( CONSUME ),\n+  stringify( UNSUBSCRIBE ),\n+  stringify( START_DELIVERY ),\n+  stringify( STOP_DELIVERY )\n+};\n+\n PubSubDataPtr PubSubData::forPublishRequest(long txnid, const std::string& topic, const Message& body,\n                                             const ResponseCallbackPtr& callback) {\n   PubSubDataPtr ptr(new PubSubData());\n@@ -186,3 +198,57 @@ const std::string& PubSubData::getSubscriberId() const {\n const SubscriptionOptions& PubSubData::getSubscriptionOptions() const {\n   return options;\n }\n+\n+void PubSubData::setOrigChannelForResubscribe(\n+  boost::shared_ptr<DuplexChannel>& channel) {\n+  this->origChannel = channel;\n+}\n+\n+boost::shared_ptr<DuplexChannel>& PubSubData::getOrigChannelForResubscribe() {\n+  return this->origChannel;\n+}\n+\n+bool PubSubData::isResubscribeRequest() {\n+  return 0 != this->origChannel.get();\n+}\n+\n+ClientTxnCounter::ClientTxnCounter() : counter(0) \n+{\n+}\n+\n+ClientTxnCounter::~ClientTxnCounter() {\n+}\n+\n+/**\n+Increment the transaction counter and return the new value.\n+\n+@returns the next transaction id\n+*/\n+long ClientTxnCounter::next() {  // would be nice to remove lock from here, look more into it\n+  boost::lock_guard<boost::mutex> lock(mutex);\n+\n+  long next= ++counter; \n+\n+  return next;\n+}\n+\n+std::ostream& Hedwig::operator<<(std::ostream& os, const PubSubData& data) {\n+  OperationType type = data.getType();\n+  os << \"[\" << OPERATION_TYPE_NAMES[type] << \" request (txn:\" << data.getTxnId()\n+     << \") for (topic:\" << data.getTopic();\n+  switch (type) {\n+  case SUBSCRIBE:\n+  case UNSUBSCRIBE:\n+    os << \", subscriber:\" << data.getSubscriberId() << \")\";\n+    break;\n+  case CONSUME:\n+    os << \", subscriber:\" << data.getSubscriberId() << \", seq:\"\n+    << data.getMessageSeqId().localcomponent() << \")\";\n+    break;\n+  case PUBLISH:\n+  default:\n+    os << \")\";\n+    break;\n+  }\n+  return os;\n+}"},{"sha":"c0f7c699e1709077e2a95741c2d502f1cc510b2e","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"modified","additions":12,"deletions":1,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -23,6 +23,7 @@\n #include <hedwig/callback.h>\n \n #include <pthread.h>\n+#include <iostream>\n \n #ifdef USE_BOOST_TR1\n #include <boost/tr1/unordered_set.hpp>\n@@ -57,6 +58,8 @@ namespace Hedwig {\n   typedef boost::shared_ptr<PubSubRequest> PubSubRequestPtr;\n   typedef boost::shared_ptr<PubSubResponse> PubSubResponsePtr;\n \n+  class DuplexChannel;\n+\n   /**\n      Data structure to hold information about requests and build request messages.\n      Used to store requests which may need to be resent to another server. \n@@ -92,6 +95,12 @@ namespace Hedwig {\n     void addTriedServer(HostAddress& h);\n     bool hasTriedServer(HostAddress& h);\n     void clearTriedServers();\n+\n+    void setOrigChannelForResubscribe(boost::shared_ptr<DuplexChannel>& channel);\n+    bool isResubscribeRequest();\n+    boost::shared_ptr<DuplexChannel>& getOrigChannelForResubscribe();\n+\n+    friend std::ostream& operator<<(std::ostream& os, const PubSubData& data);\n   private:\n \n     PubSubData();\n@@ -110,7 +119,9 @@ namespace Hedwig {\n     SubscriptionOptions options;\n     MessageSeqId msgid;\n     std::tr1::unordered_set<HostAddress, HostAddressHash > triedservers;\n+    // record the origChannel for a resubscribe request\n+    boost::shared_ptr<DuplexChannel> origChannel;\n   };\n-  \n+\n };\n #endif"},{"sha":"af3560c5d3dc3c91dddceb2e68a86d4238c2a180","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -66,11 +66,13 @@ EventDispatcher::EventDispatcher(const Configuration& conf)\n   num_threads = conf.getInt(Configuration::NUM_DISPATCH_THREADS,\n                             DEFAULT_NUM_DISPATCH_THREADS);\n   if (0 == num_threads) {\n+    LOG4CXX_ERROR(logger, \"Number of threads in dispatcher is zero\");\n     throw std::runtime_error(\"number of threads in dispatcher is zero\");\n   }\n   for (size_t i = 0; i < num_threads; i++) {\n     services.push_back(IOServicePtr(new IOService()));\n   }\n+  LOG4CXX_DEBUG(logger, \"Created EventDispatcher \" << this);\n }\n \n void EventDispatcher::run_forever(IOServicePtr service, size_t idx) {"},{"sha":"033f17c4e61ea1157ab8aaa724d7e6960fe9f6ee","filename":"hedwig-client/src/main/cpp/lib/publisherimpl.cpp","status":"modified","additions":33,"deletions":35,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/publisherimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/publisherimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/publisherimpl.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -19,11 +19,12 @@\n #include <config.h>\n #endif\n \n+#include <string>\n+#include <log4cxx/logger.h>\n+\n #include \"publisherimpl.h\"\n #include \"channel.h\"\n \n-#include <log4cxx/logger.h>\n-\n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n@@ -48,31 +49,19 @@ void PublishResponseAdaptor::operationFailed(const std::exception& exception) {\n   pubCallback->operationFailed(exception);\n }\n \n-PublishWriteCallback::PublishWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n-\n-void PublishWriteCallback::operationComplete() {\n-  LOG4CXX_DEBUG(logger, \"Successfully wrote transaction: \" << data->getTxnId());\n-}\n-\n-void PublishWriteCallback::operationFailed(const std::exception& exception) {\n-  LOG4CXX_ERROR(logger, \"Error writing to publisher \" << exception.what());\n-  \n-  data->getCallback()->operationFailed(exception);\n-}\n-\n-PublisherImpl::PublisherImpl(const ClientImplPtr& client) \n-  : client(client) {\n+PublisherImpl::PublisherImpl(const DuplexChannelManagerPtr& channelManager)\n+  : channelManager(channelManager) {\n }\n \n PublishResponsePtr PublisherImpl::publish(const std::string& topic, const Message& message) {\n-  SyncCallback<PublishResponsePtr>* cb =\n-    new SyncCallback<PublishResponsePtr>(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n-\t\t\t\t\t\t\t\t\t\t\t                                                     DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  SyncCallback<PublishResponsePtr>* cb = new SyncCallback<PublishResponsePtr>(\n+    channelManager->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT,\n+                                              DEFAULT_SYNC_REQUEST_TIMEOUT));\n   PublishResponseCallbackPtr callback(cb);\n   asyncPublishWithResponse(topic, message, callback);\n   cb->wait();\n-  \n-  cb->throwExceptionIfNeeded();  \n+\n+  cb->throwExceptionIfNeeded();\n   return cb->getResult();\n }\n \n@@ -82,13 +71,15 @@ PublishResponsePtr PublisherImpl::publish(const std::string& topic, const std::s\n   return publish(topic, msg);\n }\n \n-void PublisherImpl::asyncPublish(const std::string& topic, const Message& message, const OperationCallbackPtr& callback) {\n+void PublisherImpl::asyncPublish(const std::string& topic, const Message& message,\n+                                 const OperationCallbackPtr& callback) {\n   // use release after callback to release the channel after the callback is called\n   ResponseCallbackPtr respCallback(new ResponseCallbackAdaptor(callback));\n   doPublish(topic, message, respCallback);\n }\n \n-void PublisherImpl::asyncPublish(const std::string& topic, const std::string& message, const OperationCallbackPtr& callback) {\n+void PublisherImpl::asyncPublish(const std::string& topic, const std::string& message,\n+                                 const OperationCallbackPtr& callback) {\n   Message msg;\n   msg.set_body(message);\n   asyncPublish(topic, msg, callback);\n@@ -100,22 +91,26 @@ void PublisherImpl::asyncPublishWithResponse(const std::string& topic, const Mes\n   doPublish(topic, message, respCallback);\n }\n \n-void PublisherImpl::doPublish(const std::string& topic, const Message& message, const ResponseCallbackPtr& callback) {\n-  PubSubDataPtr data = PubSubData::forPublishRequest(client->counter().next(), topic, message, callback);\n-  \n-  DuplexChannelPtr channel = client->getChannel(topic);\n-\n-  doPublish(channel, data);\n+void PublisherImpl::doPublish(const std::string& topic, const Message& message,\n+                              const ResponseCallbackPtr& callback) {\n+  PubSubDataPtr data = PubSubData::forPublishRequest(channelManager->nextTxnId(),\n+                                                     topic, message, callback);\n+  LOG4CXX_INFO(logger, \"Publish message (topic:\" << data->getTopic() << \", txn:\"\n+                       << data->getTxnId() << \").\");\n+  channelManager->submitOp(data);\n }\n \n-void PublisherImpl::doPublish(const DuplexChannelPtr& channel, const PubSubDataPtr& data) {\n-  channel->storeTransaction(data);\n-  \n-  OperationCallbackPtr writecb(new PublishWriteCallback(client, data));\n-  channel->writeRequest(data->getRequest(), writecb);\n+//\n+// Publish Response Handler\n+//\n+PublishResponseHandler::PublishResponseHandler(const DuplexChannelManagerPtr& channelManager)\n+  : ResponseHandler(channelManager) {\n+  LOG4CXX_DEBUG(logger, \"Created PublishResponseHandler for ChannelManager \" << channelManager.get());\n }\n \n-void PublisherImpl::messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn) {\n+void PublishResponseHandler::handleResponse(const PubSubResponsePtr& m,\n+                                            const PubSubDataPtr& txn,\n+                                            const DuplexChannelPtr& channel) {\n   switch (m->statuscode()) {\n   case SUCCESS:\n     if (m->has_responsebody()) {\n@@ -128,6 +123,9 @@ void PublisherImpl::messageHandler(const PubSubResponsePtr& m, const PubSubDataP\n     LOG4CXX_ERROR(logger, \"Server responsed with SERVICE_DOWN for \" << txn->getTxnId());\n     txn->getCallback()->operationFailed(ServiceDownException());\n     break;\n+  case NOT_RESPONSIBLE_FOR_TOPIC:\n+    redirectRequest(m, txn, channel);\n+    break;\n   default:\n     LOG4CXX_ERROR(logger, \"Unexpected response \" << m->statuscode() << \" for \" << txn->getTxnId());\n     txn->getCallback()->operationFailed(UnexpectedResponseException());"},{"sha":"335a219226d7880c83fb8d9d59945d23a158f0c8","filename":"hedwig-client/src/main/cpp/lib/publisherimpl.h","status":"modified","additions":9,"deletions":14,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/publisherimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/publisherimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/publisherimpl.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -34,20 +34,18 @@ namespace Hedwig {\n     PublishResponseCallbackPtr pubCallback;\n   };\n \n-  class PublishWriteCallback : public OperationCallback {\n+  class PublishResponseHandler : public ResponseHandler {\n   public:\n-    PublishWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n+    PublishResponseHandler(const DuplexChannelManagerPtr& channelManager);\n+    virtual ~PublishResponseHandler() {};\n \n-    void operationComplete();\n-    void operationFailed(const std::exception& exception);\n-  private:\n-    ClientImplPtr client;\n-    PubSubDataPtr data;\n+    virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                                const DuplexChannelPtr& channel);\n   };\n \n   class PublisherImpl : public Publisher {\n   public:\n-    PublisherImpl(const ClientImplPtr& client);\n+    PublisherImpl(const DuplexChannelManagerPtr& channelManager);\n \n     PublishResponsePtr publish(const std::string& topic, const std::string& message);\n     PublishResponsePtr publish(const std::string& topic, const Message& message);\n@@ -56,14 +54,11 @@ namespace Hedwig {\n     void asyncPublish(const std::string& topic, const Message& message, const OperationCallbackPtr& callback);\n     void asyncPublishWithResponse(const std::string& topic, const Message& messsage,\n                                   const PublishResponseCallbackPtr& callback);\n-    \n-    void messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn);\n-\n-    void doPublish(const std::string& topic, const Message& message, const ResponseCallbackPtr& callback);\n-    void doPublish(const DuplexChannelPtr& channel, const PubSubDataPtr& data);\n \n+    void doPublish(const std::string& topic, const Message& message,\n+                   const ResponseCallbackPtr& callback);\n   private:\n-    ClientImplPtr client;\n+    DuplexChannelManagerPtr channelManager;\n   };\n \n };"},{"sha":"562ed9a9f4c91a345c0c3677416eb045a451eca6","filename":"hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","status":"added","additions":470,"deletions":0,"changes":470,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -0,0 +1,470 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <log4cxx/logger.h>\n+\n+#include \"simplesubscriberimpl.h\"\n+#include \"util.h\"\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+const int DEFAULT_MAX_MESSAGE_QUEUE_SIZE = 10;\n+\n+SimpleActiveSubscriber::SimpleActiveSubscriber(const PubSubDataPtr& data,\n+                                               const AbstractDuplexChannelPtr& channel,\n+                                               const SubscriptionPreferencesPtr& preferences,\n+                                               const DuplexChannelManagerPtr& channelManager)\n+  : ActiveSubscriber(data, channel, preferences, channelManager) {\n+  maxQueueLen = channelManager->getConfiguration().getInt(Configuration::MAX_MESSAGE_QUEUE_SIZE,\n+                                                          DEFAULT_MAX_MESSAGE_QUEUE_SIZE);\n+}\n+\n+void SimpleActiveSubscriber::doStartDelivery(const MessageHandlerCallbackPtr& handler,\n+                                             const ClientMessageFilterPtr& filter) {\n+  ActiveSubscriber::doStartDelivery(handler, filter);\n+  // put channel#startReceiving out of lock of subscriber#queue_lock\n+  // otherwise we enter dead lock\n+  // subscriber#startDelivery(subscriber#queue_lock) =>\n+  // channel#startReceiving(channel#receiving_lock) =>\n+  channel->startReceiving();\n+}\n+\n+void SimpleActiveSubscriber::doStopDelivery() {\n+  channel->stopReceiving();\n+}\n+\n+void SimpleActiveSubscriber::queueMessage(const PubSubResponsePtr& m) {\n+  ActiveSubscriber::queueMessage(m);\n+\n+  if (queue.size() >= maxQueueLen) {\n+    channel->stopReceiving();\n+  }\n+}\n+\n+CloseSubscriptionCallback::CloseSubscriptionCallback(const ActiveSubscriberPtr& activeSubscriber)\n+  : activeSubscriber(activeSubscriber) {\n+}\n+\n+void CloseSubscriptionCallback::operationComplete() {\n+  finish();\n+}\n+\n+void CloseSubscriptionCallback::operationFailed(const std::exception& e) {\n+  finish();\n+}\n+\n+void CloseSubscriptionCallback::finish() {\n+  // Process the disconnect logic after cleaning up\n+  activeSubscriber->processEvent(activeSubscriber->getTopic(),\n+                                 activeSubscriber->getSubscriberId(),\n+                                 TOPIC_MOVED);\n+}\n+\n+SimpleSubscriberClientChannelHandler::SimpleSubscriberClientChannelHandler(\n+    const DuplexChannelManagerPtr& channelManager, ResponseHandlerMap& handlers)\n+    : SubscriberClientChannelHandler(channelManager, handlers) {\n+}\n+\n+bool SimpleSubscriberClientChannelHandler::setActiveSubscriber(\n+  const PubSubDataPtr& op, const SubscriptionPreferencesPtr& preferences) {\n+  boost::lock_guard<boost::shared_mutex> lock(subscriber_lock);\n+  if (subscriber.get()) {\n+    LOG4CXX_ERROR(logger, *subscriber << \" has been found alive on channel \" << channel.get());\n+    return false;\n+  }\n+  subscriber = ActiveSubscriberPtr(new SimpleActiveSubscriber(op, channel, preferences,\n+                                                              channelManager));\n+  return true;\n+}\n+\n+void SimpleSubscriberClientChannelHandler::deliverMessage(const TopicSubscriber& ts,\n+                                                          const PubSubResponsePtr& m) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive on channel \" << channel.get());\n+    return;\n+  }\n+  as->deliverMessage(m);\n+}\n+\n+void SimpleSubscriberClientChannelHandler::startDelivery(const TopicSubscriber& ts,\n+                                                         const MessageHandlerCallbackPtr& handler,\n+                                                         const ClientMessageFilterPtr& filter) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive on channel \" << channel.get());\n+    throw NotSubscribedException();\n+  }\n+  as->startDelivery(handler, filter);\n+}\n+\n+void SimpleSubscriberClientChannelHandler::stopDelivery(const TopicSubscriber& ts) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive on channel \" << channel.get());\n+    throw NotSubscribedException();\n+  }\n+  as->stopDelivery();\n+}\n+\n+bool SimpleSubscriberClientChannelHandler::hasSubscription(const TopicSubscriber& ts) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    return false;\n+  }\n+  return ts.first == as->getTopic() && ts.second == as->getSubscriberId();\n+}\n+\n+void SimpleSubscriberClientChannelHandler::asyncCloseSubscription(\n+  const TopicSubscriber& ts, const OperationCallbackPtr& callback) {\n+  // just remove the active subscriber\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (as.get()) {\n+    as->close();\n+    clearActiveSubscriber();\n+  }\n+  callback->operationComplete();\n+}\n+\n+void SimpleSubscriberClientChannelHandler::consume(const TopicSubscriber& ts,\n+                                                   const MessageSeqId& messageSeqId) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found alive on channel \" << channel.get());\n+    return;\n+  }\n+  as->consume(messageSeqId);\n+}\n+\n+void SimpleSubscriberClientChannelHandler::onChannelDisconnected(\n+  const DuplexChannelPtr& channel) {\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (!as.get()) {\n+    LOG4CXX_ERROR(logger, \"No Active Subscriber found when channel \" << channel.get()\n+                          << \" disconnected.\");\n+    // no active subscriber found, but we still need to close the channel\n+    channelManager->removeChannel(channel);\n+    return;\n+  }\n+  // Clear the topic owner ship\n+  channelManager->clearHostForTopic(as->getTopic(), channel->getHostAddress());\n+\n+  // When the channel disconnected, if resubscribe is required, we would just\n+  // cleanup the old channel when resubscribe succeed.\n+  // Otherwise, we would cleanup the old channel then notify with a TOPIC_MOVED event\n+  LOG4CXX_INFO(logger, \"Tell \" << *as << \" his channel \" << channel.get() << \" is disconnected.\");\n+  if (!as->isResubscribeRequired()) {\n+    OperationCallbackPtr closeCb(new CloseSubscriptionCallback(as));\n+    TopicSubscriber ts(as->getTopic(), as->getSubscriberId());\n+    channelManager->asyncCloseSubscription(ts, closeCb);\n+  } else {\n+    as->processEvent(as->getTopic(), as->getSubscriberId(), TOPIC_MOVED);\n+  }\n+}\n+\n+void SimpleSubscriberClientChannelHandler::closeHandler() {\n+  // just remove the active subscriber\n+  ActiveSubscriberPtr as = getActiveSubscriber();\n+  if (as.get()) {\n+    as->close();\n+    clearActiveSubscriber();\n+    LOG4CXX_DEBUG(logger, \"Closed \" << *as << \".\");\n+  }\n+}\n+\n+//\n+// Subscribe Response Handler\n+//\n+SimpleSubscribeResponseHandler::SimpleSubscribeResponseHandler(\n+  const SimpleDuplexChannelManagerPtr& channelManager)\n+  : ResponseHandler(boost::dynamic_pointer_cast<DuplexChannelManager>(channelManager)),\n+    sChannelManager(channelManager) {\n+}\n+\n+void SimpleSubscribeResponseHandler::handleSuccessResponse(\n+  const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+  const SimpleSubscriberClientChannelHandlerPtr& handler) {\n+  // for subscribe request, check whether is any subscription preferences received\n+  SubscriptionPreferencesPtr preferences;\n+  if (m->has_responsebody()) {\n+    const ResponseBody& respBody = m->responsebody();\n+    if (respBody.has_subscriberesponse()) {\n+      const SubscribeResponse& resp = respBody.subscriberesponse();\n+      if (resp.has_preferences()) {\n+        preferences = SubscriptionPreferencesPtr(new SubscriptionPreferences(resp.preferences()));\n+      }\n+    }\n+  }\n+\n+  handler->setActiveSubscriber(txn, preferences);\n+  TopicSubscriber ts(txn->getTopic(), txn->getSubscriberId());\n+  if (!sChannelManager->storeSubscriptionChannelHandler(ts, txn, handler)) {\n+    // found existed subscription channel handler\n+    handler->close();\n+    if (txn->isResubscribeRequest()) {\n+      txn->getCallback()->operationFailed(ResubscribeException());\n+    } else {\n+      txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    }\n+    return;\n+  }\n+  if (m->has_responsebody()) {\n+    txn->getCallback()->operationComplete(m->responsebody());\n+  } else {\n+    txn->getCallback()->operationComplete(ResponseBody());\n+  }\n+}\n+\n+void SimpleSubscribeResponseHandler::handleResponse(const PubSubResponsePtr& m,\n+                                                    const PubSubDataPtr& txn,\n+                                                    const DuplexChannelPtr& channel) {\n+  if (!txn.get()) {\n+    LOG4CXX_ERROR(logger, \"Invalid transaction recevied from channel \" << channel.get());\n+    return;\n+  }\n+\n+  LOG4CXX_DEBUG(logger, \"message received with status \" << m->statuscode()\n+                        << \" from channel \" << channel.get());\n+\n+  SimpleSubscriberClientChannelHandlerPtr handler =\n+    boost::dynamic_pointer_cast<SimpleSubscriberClientChannelHandler>(channel->getChannelHandler());\n+  if (!handler.get()) {\n+    LOG4CXX_ERROR(logger, \"No simple subscriber client channel handler found for channel \"\n+                          << channel.get() << \".\");\n+    // No channel handler, but we still need to close the channel\n+    channel->close();\n+    txn->getCallback()->operationFailed(NoChannelHandlerException());\n+    return;\n+  }\n+\n+  if (SUCCESS != m->statuscode()) {\n+    // Subscribe request doesn't succeed, we close the handle and its binding channel\n+    handler->close();\n+  }\n+\n+  switch (m->statuscode()) {\n+  case SUCCESS:\n+    handleSuccessResponse(m, txn, handler);\n+    break;\n+  case SERVICE_DOWN:\n+    txn->getCallback()->operationFailed(ServiceDownException());\n+    break;\n+  case CLIENT_ALREADY_SUBSCRIBED:\n+  case TOPIC_BUSY:\n+    txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    break;\n+  case CLIENT_NOT_SUBSCRIBED:\n+    txn->getCallback()->operationFailed(NotSubscribedException());\n+    break;\n+  case NOT_RESPONSIBLE_FOR_TOPIC:\n+    redirectRequest(m, txn, channel);\n+    break;\n+  default:\n+    LOG4CXX_ERROR(logger, \"Unexpected response \" << m->statuscode() << \" for \" << txn->getTxnId());\n+    txn->getCallback()->operationFailed(UnexpectedResponseException());\n+    break;\n+  }\n+}\n+\n+//\n+// Simple Duplex Channel Manager\n+//\n+SimpleDuplexChannelManager::SimpleDuplexChannelManager(const Configuration& conf)\n+  : DuplexChannelManager(conf) {\n+  LOG4CXX_DEBUG(logger, \"Created SimpleDuplexChannelManager \" << this);\n+}\n+\n+SimpleDuplexChannelManager::~SimpleDuplexChannelManager() {\n+  LOG4CXX_DEBUG(logger, \"Destroyed SimpleDuplexChannelManager \" << this);\n+}\n+\n+void SimpleDuplexChannelManager::start() {\n+  // Add subscribe response handler\n+  subscriptionHandlers[SUBSCRIBE] =\n+    ResponseHandlerPtr(new SimpleSubscribeResponseHandler(\n+    boost::dynamic_pointer_cast<SimpleDuplexChannelManager>(shared_from_this())));\n+  DuplexChannelManager::start();\n+}\n+\n+void SimpleDuplexChannelManager::close() {\n+  DuplexChannelManager::close();\n+  subscriptionHandlers.clear();\n+}\n+\n+SubscriberClientChannelHandlerPtr\n+SimpleDuplexChannelManager::getSubscriptionChannelHandler(const TopicSubscriber& ts) {\n+  return boost::dynamic_pointer_cast<SubscriberClientChannelHandler>(\n+         getSimpleSubscriptionChannelHandler(ts));\n+}\n+\n+const SimpleSubscriberClientChannelHandlerPtr&\n+SimpleDuplexChannelManager::getSimpleSubscriptionChannelHandler(const TopicSubscriber& ts) {\n+  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+  return topicsubscriber2handler[ts];\n+}\n+\n+DuplexChannelPtr SimpleDuplexChannelManager::getSubscriptionChannel(\n+  const TopicSubscriber& ts, const bool isResubscribeRequest) {\n+  SimpleSubscriberClientChannelHandlerPtr handler;\n+  // for resubscribe request, we forced a new subscription channel\n+  if (!isResubscribeRequest) {\n+    handler = getSimpleSubscriptionChannelHandler(ts);\n+  }\n+  // found a live subscription channel\n+  if (handler.get()) {\n+    return boost::dynamic_pointer_cast<DuplexChannel>(handler->getChannel());\n+  }\n+  const HostAddress& addr = getHostForTopic(ts.first);\n+  if (addr.isNullHost()) {\n+    return DuplexChannelPtr();\n+  } else {\n+    // we had known which hub server owned the topic\n+    DuplexChannelPtr ch = getSubscriptionChannel(addr);\n+    if (ch.get()) {\n+      return ch;\n+    }\n+    ch = createSubscriptionChannel(addr);\n+    return storeSubscriptionChannel(ch, true);\n+  }\n+}\n+\n+DuplexChannelPtr SimpleDuplexChannelManager::getSubscriptionChannel(const HostAddress& addr) {\n+  // for simple subscription channel, we established a new channel each time\n+  return DuplexChannelPtr();\n+}\n+\n+DuplexChannelPtr SimpleDuplexChannelManager::createSubscriptionChannel(const HostAddress& addr) {\n+  // Create a simple subscriber channel handler\n+  SimpleSubscriberClientChannelHandler * subscriberHandler =\n+    new SimpleSubscriberClientChannelHandler(\n+      boost::dynamic_pointer_cast<SimpleDuplexChannelManager>(shared_from_this()),\n+      subscriptionHandlers);\n+  ChannelHandlerPtr channelHandler(subscriberHandler);\n+  // Create a subscription channel\n+  DuplexChannelPtr channel = createChannel(dispatcher->getService(), addr, channelHandler);\n+  subscriberHandler->setChannel(boost::dynamic_pointer_cast<AbstractDuplexChannel>(channel));\n+  LOG4CXX_INFO(logger, \"New subscription channel \" << channel.get() << \" is created to host \"\n+                       << addr << \", whose channel handler is \" << subscriberHandler);\n+  return channel;\n+}\n+\n+DuplexChannelPtr SimpleDuplexChannelManager::storeSubscriptionChannel(const DuplexChannelPtr& ch,\n+                                                                      bool doConnect) {\n+  // for simple duplex channel manager\n+  // we just store subscription channel handler until subscribe successfully\n+  if (doConnect) {\n+    ch->connect();\n+  }\n+  return ch;\n+}\n+\n+bool SimpleDuplexChannelManager::storeSubscriptionChannelHandler(\n+  const TopicSubscriber& ts, const PubSubDataPtr& txn,\n+  const SimpleSubscriberClientChannelHandlerPtr& handler) {\n+  SimpleSubscriberClientChannelHandlerPtr other;\n+  bool success = false;\n+  bool isResubscribeRequest = txn->isResubscribeRequest();\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    other = topicsubscriber2handler[ts];\n+    if (other.get()) {\n+      if (isResubscribeRequest) {\n+        DuplexChannelPtr& origChannel = txn->getOrigChannelForResubscribe();\n+        const AbstractDuplexChannelPtr& otherChannel =\n+          other->getChannel();\n+        if (origChannel.get() != otherChannel.get()) {\n+          // channel has been changed for a specific subscriber\n+          // which means the client closesub and subscribe again\n+          // when channel disconnect to resubscribe for it.\n+          // so we should not let the resubscribe succeed\n+          success = false;\n+        } else {\n+          topicsubscriber2handler[ts] = handler;\n+          success = true;\n+        }\n+      } else {\n+        success = false;\n+      }\n+    } else {\n+      if (isResubscribeRequest) {\n+        // if it is a resubscribe request and there is no handler found\n+        // which means a closesub has been called when resubscribing\n+        // so we should not let the resubscribe succeed\n+        success = false;\n+      } else {\n+        topicsubscriber2handler[ts] = handler;\n+        success = true;\n+      }\n+    }\n+  }\n+  if (isResubscribeRequest && success && other.get()) {\n+    // the old handler is evicted due to resubscribe succeed\n+    // so it is the time to close the old disconnected channel now\n+    other->close();\n+  }\n+  return success;\n+}\n+\n+void SimpleDuplexChannelManager::asyncCloseSubscription(const TopicSubscriber& ts,\n+                                                        const OperationCallbackPtr& callback) {\n+  SimpleSubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    handler = topicsubscriber2handler[ts];\n+    topicsubscriber2handler.erase(ts);\n+    LOG4CXX_DEBUG(logger, \"CloseSubscription:: remove subscriber channel handler for (topic:\"\n+                          << ts.first << \", subscriber:\" << ts.second << \").\");\n+  }\n+\n+  if (handler.get() != 0) {\n+    handler->close();\n+  }\n+  callback->operationComplete();\n+}\n+\n+void SimpleDuplexChannelManager::handoverDelivery(const TopicSubscriber& ts,\n+                                                  const MessageHandlerCallbackPtr& msgHandler,\n+                                                  const ClientMessageFilterPtr& filter) {\n+  SimpleSubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    handler = topicsubscriber2handler[ts];\n+  }\n+\n+  if (!handler.get()) {\n+    LOG4CXX_WARN(logger, \"No channel handler found for (topic:\" << ts.first << \", subscriber:\"\n+                         << ts.second << \") to handover delivery with handler \"\n+                         << msgHandler.get() << \", filter \" << filter.get() << \".\");\n+    return;\n+  }\n+  try {\n+    handler->startDelivery(ts, msgHandler, filter);\n+  } catch(const AlreadyStartDeliveryException& ase) {\n+    LOG4CXX_WARN(logger, \"Other one has started delivery for (topic:\" << ts.first <<\n+                         \", subscriber:\" << ts.second << \") using brand new message handler. \"\n+                         << \"It is OK that we could give up handing over old message handler.\");\n+  } catch(const std::exception& e) {\n+    LOG4CXX_WARN(logger, \"Error when handing over old message handler for (topic:\" << ts.first\n+                         << \", subscriber:\" << ts.second << \") : \" << e.what());\n+  }\n+}"},{"sha":"127ec351c0aaea58ccadec8605afd7a08221b2b2","filename":"hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","status":"added","additions":191,"deletions":0,"changes":191,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -0,0 +1,191 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef SIMPLE_SUBSCRIBE_IMPL_H\n+#define SIMPLE_SUBSCRIBE_IMPL_H\n+\n+#include <boost/thread/mutex.hpp>\n+\n+#include \"subscriberimpl.h\"\n+#include \"clientimpl.h\"\n+\n+namespace Hedwig {\n+\n+  class SimpleActiveSubscriber : public ActiveSubscriber {\n+  public:\n+    SimpleActiveSubscriber(const PubSubDataPtr& data,\n+                           const AbstractDuplexChannelPtr& channel,\n+                           const SubscriptionPreferencesPtr& preferences,\n+                           const DuplexChannelManagerPtr& channelManager);\n+\n+  protected:\n+    virtual void doStartDelivery(const MessageHandlerCallbackPtr& handler,\n+                                 const ClientMessageFilterPtr& filter);\n+\n+    // Stop Delivery\n+    virtual void doStopDelivery();\n+              \n+    // Queue message when message handler is not ready\n+    virtual void queueMessage(const PubSubResponsePtr& m);\n+\n+  private:\n+    std::size_t maxQueueLen;\n+  };\n+\n+  class CloseSubscriptionCallback : public OperationCallback {\n+  public:\n+    explicit CloseSubscriptionCallback(const ActiveSubscriberPtr& activeSubscriber);\n+\n+    virtual void operationComplete();\n+    virtual void operationFailed(const std::exception& exception);\n+  private:\n+    void finish();\n+    const ActiveSubscriberPtr activeSubscriber;\n+  };\n+\n+  // Simple Subscription Channel Handler : One subscription per channel\n+  class SimpleSubscriberClientChannelHandler : public SubscriberClientChannelHandler {\n+  public:\n+    SimpleSubscriberClientChannelHandler(const DuplexChannelManagerPtr& channelManager,\n+                                         ResponseHandlerMap& handlers);\n+    virtual ~SimpleSubscriberClientChannelHandler() {}\n+\n+    // Set the subscriber serving on this channel\n+    bool setActiveSubscriber(const PubSubDataPtr& op,\n+                             const SubscriptionPreferencesPtr& preferences);\n+\n+    // Deliver a received message to given message handler\n+    virtual void deliverMessage(const TopicSubscriber& ts,\n+                                const PubSubResponsePtr& m);\n+\n+    // Start Delivery for a given topic subscriber\n+    virtual void startDelivery(const TopicSubscriber& ts,\n+                               const MessageHandlerCallbackPtr& handler,\n+                               const ClientMessageFilterPtr& filter);\n+\n+    // Stop Delivery for a given topic subscriber\n+    virtual void stopDelivery(const TopicSubscriber& ts);\n+\n+    // Has Subscription on the Channel\n+    virtual bool hasSubscription(const TopicSubscriber& ts);\n+\n+    // Close Subscription for a given topic subscriber\n+    virtual void asyncCloseSubscription(const TopicSubscriber& ts,\n+                                        const OperationCallbackPtr& callback);\n+\n+    // Consume message for a given topic subscriber\n+    virtual void consume(const TopicSubscriber& ts,\n+                         const MessageSeqId& messageSeqId);\n+\n+  protected:\n+    // Subscription channel disconnected: reconnect the subscription channel\n+    virtual void onChannelDisconnected(const DuplexChannelPtr& channel);\n+\n+    virtual void closeHandler();\n+\n+  private:\n+    inline void clearActiveSubscriber() {\n+      boost::lock_guard<boost::shared_mutex> lock(subscriber_lock);\n+      subscriber = ActiveSubscriberPtr();\n+    }\n+\n+    inline const ActiveSubscriberPtr& getActiveSubscriber() {\n+      boost::shared_lock<boost::shared_mutex> lock(subscriber_lock);\n+      return subscriber;\n+    }\n+\n+    ActiveSubscriberPtr subscriber;\n+    boost::shared_mutex subscriber_lock;\n+  };\n+\n+  typedef boost::shared_ptr<SimpleSubscriberClientChannelHandler>\n+    SimpleSubscriberClientChannelHandlerPtr;\n+\n+  //\n+  // Simple Duplex Channel Manager\n+  //\n+\n+  class SimpleDuplexChannelManager : public DuplexChannelManager {\n+  public:\n+    explicit SimpleDuplexChannelManager(const Configuration& conf);\n+    virtual ~SimpleDuplexChannelManager();\n+\n+    bool storeSubscriptionChannelHandler(const TopicSubscriber& ts,\n+                                         const PubSubDataPtr& txn,\n+                                         const SimpleSubscriberClientChannelHandlerPtr& handler);\n+\n+    // Get the subscription channel handler for a given subscription\n+    virtual SubscriberClientChannelHandlerPtr\n+            getSubscriptionChannelHandler(const TopicSubscriber& ts);\n+\n+    // Close subscription for a given subscription\n+    virtual void asyncCloseSubscription(const TopicSubscriber& ts,\n+                                        const OperationCallbackPtr& callback);\n+\n+    virtual void handoverDelivery(const TopicSubscriber& ts,\n+                                  const MessageHandlerCallbackPtr& handler,\n+                                  const ClientMessageFilterPtr& filter);\n+\n+    // start the channel manager\n+    virtual void start();\n+    // close the channel manager\n+    virtual void close();\n+\n+  protected:\n+    virtual DuplexChannelPtr getSubscriptionChannel(const TopicSubscriber& ts,\n+                                                    const bool isResubscribeRequest);\n+\n+    virtual DuplexChannelPtr getSubscriptionChannel(const HostAddress& addr);\n+\n+    virtual DuplexChannelPtr createSubscriptionChannel(const HostAddress& addr);\n+\n+    virtual DuplexChannelPtr storeSubscriptionChannel(const DuplexChannelPtr& ch,\n+                                                      bool doConnect);\n+\n+  private:\n+    const SimpleSubscriberClientChannelHandlerPtr&\n+    getSimpleSubscriptionChannelHandler(const TopicSubscriber& ts);\n+\n+    std::tr1::unordered_map<TopicSubscriber, SimpleSubscriberClientChannelHandlerPtr, TopicSubscriberHash > topicsubscriber2handler;\n+    boost::shared_mutex topicsubscriber2handler_lock;\n+\n+    // Response Handlers for subscription requests\n+    ResponseHandlerMap subscriptionHandlers;\n+  };\n+\n+  typedef boost::shared_ptr<SimpleDuplexChannelManager> SimpleDuplexChannelManagerPtr;\n+\n+  // Subscribe Response Handler\n+\n+  class SimpleSubscribeResponseHandler : public ResponseHandler {\n+  public:\n+    explicit SimpleSubscribeResponseHandler(\n+      const SimpleDuplexChannelManagerPtr& channelManager);\n+\n+    virtual ~SimpleSubscribeResponseHandler() {}\n+\n+    virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                                const DuplexChannelPtr& channel);\n+\n+  private:\n+    void handleSuccessResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                               const SimpleSubscriberClientChannelHandlerPtr& handler);\n+    const SimpleDuplexChannelManagerPtr sChannelManager;\n+  };\n+} /* Namespace Hedwig */\n+\n+#endif"},{"sha":"49b2691b7675148ea84242272e2174e57b8419f9","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":371,"deletions":368,"changes":739,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -19,348 +19,417 @@\n #include <config.h>\n #endif\n \n-#include \"subscriberimpl.h\"\n-#include \"util.h\"\n-#include \"channel.h\"\n-#include \"filterablemessagehandler.h\"\n-\n+#include <string>\n #include <boost/asio.hpp>\n #include <boost/date_time/posix_time/posix_time.hpp>\n \n #include <log4cxx/logger.h>\n \n+#include \"subscriberimpl.h\"\n+#include \"util.h\"\n+#include \"channel.h\"\n+#include \"filterablemessagehandler.h\"\n+\n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n const int DEFAULT_MESSAGE_CONSUME_RETRY_WAIT_TIME = 5000;\n const int DEFAULT_SUBSCRIBER_CONSUME_RETRY_WAIT_TIME = 5000;\n-const int DEFAULT_MAX_MESSAGE_QUEUE_SIZE = 10;\n const int DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME = 5000;\n const bool DEFAULT_SUBSCRIBER_AUTOCONSUME = true;\n const int DEFAULT_SUBSCRIPTION_MESSAGE_BOUND = 0;\n \n-SubscriberWriteCallback::SubscriberWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n+static const std::type_info& RESUBSCRIBE_EXCEPTION = typeid(ResubscribeException());\n \n-void SubscriberWriteCallback::operationComplete() {\n-  LOG4CXX_DEBUG(logger, \"Successfully wrote subscribe transaction: \" << data->getTxnId());\n-}\n-\n-void SubscriberWriteCallback::operationFailed(const std::exception& exception) {\n-  LOG4CXX_ERROR(logger, \"Error writing to subscriber \" << exception.what());\n-  \n-  //remove txn from channel pending list\n-  data->getCallback()->operationFailed(exception);\n-  client->getSubscriberImpl().closeSubscription(data->getTopic(), data->getSubscriberId());\n-}\n-\n-UnsubscribeWriteCallback::UnsubscribeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n-\n-void UnsubscribeWriteCallback::operationComplete() {\n-  LOG4CXX_DEBUG(logger, \"Successfully wrote unsubscribe transaction: \" << data->getTxnId());\n-}\n-\n-void UnsubscribeWriteCallback::operationFailed(const std::exception& exception) {\n-  data->getCallback()->operationFailed(exception);\n-}\n-  \n-ConsumeWriteCallback::ConsumeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) \n-  : client(client), data(data) {\n+ConsumeWriteCallback::ConsumeWriteCallback(const ActiveSubscriberPtr& activeSubscriber,\n+                                           const PubSubDataPtr& data,\n+                                           int retrywait)\n+  : activeSubscriber(activeSubscriber), data(data), retrywait(retrywait) {\n }\n \n ConsumeWriteCallback::~ConsumeWriteCallback() {\n }\n \n-/* static */ void ConsumeWriteCallback::timerComplete(const ClientImplPtr& client, const PubSubDataPtr& data,\n-\t\t\t\t\t\t      const boost::system::error_code& error) {\n+/* static */ void ConsumeWriteCallback::timerComplete(\n+                  const ActiveSubscriberPtr& activeSubscriber,\n+                  const PubSubDataPtr& data,\n+                  const boost::system::error_code& error) {\n   if (error) {\n     // shutting down\n     return;\n   }\n \n-  client->getSubscriberImpl().consume(data->getTopic(), data->getSubscriberId(), data->getMessageSeqId());\n+  activeSubscriber->consume(data->getMessageSeqId());\n }\n \n-\n void ConsumeWriteCallback::operationComplete() {\n   LOG4CXX_DEBUG(logger, \"Successfully wrote consume transaction: \" << data->getTxnId());\n }\n \n void ConsumeWriteCallback::operationFailed(const std::exception& exception) {\n-  int retrywait = client->getConfiguration().getInt(Configuration::MESSAGE_CONSUME_RETRY_WAIT_TIME, \n-\t\t\t\t\t\t    DEFAULT_MESSAGE_CONSUME_RETRY_WAIT_TIME);\n-  LOG4CXX_ERROR(logger, \"Error writing consume transaction: \" << data->getTxnId() << \" error: \" << exception.what() \n-\t\t<< \" retrying in \" << retrywait << \" Microseconds\");\n-\n-  boost::asio::deadline_timer t(client->getService(), boost::posix_time::milliseconds(retrywait));\n+  LOG4CXX_ERROR(logger, \"Error writing consume request (topic:\" << data->getTopic()\n+                     << \", subscriber:\" << data->getSubscriberId() << \", txn:\" << data->getTxnId()\n+                     << \") : \" << exception.what() << \", will be tried in \"\n+                     << retrywait << \" milliseconds\");\n \n-  t.async_wait(boost::bind(&ConsumeWriteCallback::timerComplete, client, data, boost::asio::placeholders::error));  \n+  boost::asio::deadline_timer t(activeSubscriber->getChannel()->getService(),\n+                                boost::posix_time::milliseconds(retrywait));\n }\n \n-SubscriberConsumeCallback::SubscriberConsumeCallback(const ClientImplPtr& client, \n-\t\t\t\t\t\t     const SubscriberClientChannelHandlerPtr& handler, \n-\t\t\t\t\t\t     const PubSubDataPtr& data, const PubSubResponsePtr& m) \n-  : client(client), handler(handler), data(data), m(m)\n-{\n+SubscriberConsumeCallback::SubscriberConsumeCallback(const DuplexChannelManagerPtr& channelManager,\n+                                                     const ActiveSubscriberPtr& activeSubscriber,\n+                                                     const PubSubResponsePtr& m)\n+  : channelManager(channelManager), activeSubscriber(activeSubscriber), m(m) {\n }\n \n void SubscriberConsumeCallback::operationComplete() {\n-  LOG4CXX_DEBUG(logger, \"ConsumeCallback::operationComplete \" << data->getTopic() << \" - \" << data->getSubscriberId());\n+  LOG4CXX_DEBUG(logger, \"ConsumeCallback::operationComplete \" << *activeSubscriber);\n \n-  if (client->getConfiguration().getBool(Configuration::SUBSCRIBER_AUTOCONSUME, DEFAULT_SUBSCRIBER_AUTOCONSUME)) {\n-    client->getSubscriber().consume(data->getTopic(), data->getSubscriberId(), m->message().msgid());\n+  if (channelManager->getConfiguration().getBool(Configuration::SUBSCRIBER_AUTOCONSUME,\n+                                                 DEFAULT_SUBSCRIBER_AUTOCONSUME)) {\n+    activeSubscriber->consume(m->message().msgid());\n   }\n }\n \n-/* static */ void SubscriberConsumeCallback::timerComplete(const SubscriberClientChannelHandlerPtr handler, \n-\t\t\t\t\t\t\t   const PubSubResponsePtr m, \n-\t\t\t\t\t\t\t   const boost::system::error_code& error) {\n+/* static */ void SubscriberConsumeCallback::timerComplete(\n+                 const ActiveSubscriberPtr activeSubscriber,\n+                 const PubSubResponsePtr m,\n+                 const boost::system::error_code& error) {\n   if (error) {\n     return;\n   }\n-  handler->messageReceived(handler->getChannel(), m);\n+  activeSubscriber->deliverMessage(m);\n }\n \n void SubscriberConsumeCallback::operationFailed(const std::exception& exception) {\n-  LOG4CXX_ERROR(logger, \"ConsumeCallback::operationFailed  \" << data->getTopic() << \" - \" << data->getSubscriberId());\n-  \n-  int retrywait = client->getConfiguration().getInt(Configuration::SUBSCRIBER_CONSUME_RETRY_WAIT_TIME,\n-\t\t\t\t\t\t    DEFAULT_SUBSCRIBER_CONSUME_RETRY_WAIT_TIME);\n+  LOG4CXX_ERROR(logger, \"ConsumeCallback::operationFailed  \" << *activeSubscriber);\n+\n+  int retrywait = channelManager->getConfiguration()\n+                  .getInt(Configuration::SUBSCRIBER_CONSUME_RETRY_WAIT_TIME,\n+                          DEFAULT_SUBSCRIBER_CONSUME_RETRY_WAIT_TIME);\n \n-  LOG4CXX_ERROR(logger, \"Error passing message to client transaction: \" << data->getTxnId() << \" error: \" << exception.what() \n-\t\t<< \" retrying in \" << retrywait << \" Microseconds\");\n+  LOG4CXX_ERROR(logger, \"Error passing message to client for \" << *activeSubscriber << \" error: \"\n+                        << exception.what() << \" retrying in \" << retrywait << \" Microseconds\");\n \n-  AbstractDuplexChannelPtr chPtr = boost::dynamic_pointer_cast<AbstractDuplexChannel>(handler->getChannel());\n-  boost::asio::deadline_timer t(chPtr->getService(), boost::posix_time::milliseconds(retrywait));\n+  // We leverage same io service for retrying delivering messages.\n+  AbstractDuplexChannelPtr ch = activeSubscriber->getChannel();\n+  boost::asio::deadline_timer t(ch->getService(), boost::posix_time::milliseconds(retrywait));\n \n-  t.async_wait(boost::bind(&SubscriberConsumeCallback::timerComplete, handler, m, boost::asio::placeholders::error));  \n+  t.async_wait(boost::bind(&SubscriberConsumeCallback::timerComplete,\n+                           activeSubscriber, m, boost::asio::placeholders::error));\n }\n \n-SubscriberReconnectCallback::SubscriberReconnectCallback(const ClientImplPtr& client, const PubSubDataPtr& origData) \n-  : client(client), origData(origData) {\n+CloseSubscriptionForUnsubscribeCallback::CloseSubscriptionForUnsubscribeCallback(\n+  const DuplexChannelManagerPtr& channelManager, const std::string& topic,\n+  const std::string& subscriberId, const OperationCallbackPtr& unsubCb)\n+  : channelManager(channelManager), topic(topic), subscriberId(subscriberId), unsubCb(unsubCb) {\n }\n \n-void SubscriberReconnectCallback::operationComplete(const ResponseBody & resp) {\n+void CloseSubscriptionForUnsubscribeCallback::operationComplete() {\n+  ResponseCallbackPtr respCallback(new ResponseCallbackAdaptor(unsubCb));\n+  PubSubDataPtr data = PubSubData::forUnsubscribeRequest(channelManager->nextTxnId(),\n+                                                         subscriberId, topic, respCallback);\n+  // submit the unsubscribe request\n+  channelManager->submitOp(data);\n }\n \n-void SubscriberReconnectCallback::operationFailed(const std::exception& exception) {\n-  LOG4CXX_ERROR(logger, \"Error writing to new subscriber. Channel should pick this up disconnect the channel and try to connect again \" << exception.what());\n+void CloseSubscriptionForUnsubscribeCallback::operationFailed(const std::exception& exception) {\n+  unsubCb->operationFailed(exception);\n+}\n \n+ResubscribeCallback::ResubscribeCallback(const ActiveSubscriberPtr& activeSubscriber)\n+  : activeSubscriber(activeSubscriber) {\n }\n \n-SubscriberClientChannelHandler::SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber, const PubSubDataPtr& data)\n-  : HedwigClientChannelHandler(client), subscriber(subscriber), origData(data), closed(false),\n-    should_wait(true), disconnected(false) {\n-  LOG4CXX_DEBUG(logger, \"Creating SubscriberClientChannelHandler \" << this);\n+void ResubscribeCallback::operationComplete(const ResponseBody & resp) {\n+  // handover delivery to resubscribed subscriber.\n+  activeSubscriber->handoverDelivery();\n }\n \n-SubscriberClientChannelHandler::~SubscriberClientChannelHandler() {\n-  LOG4CXX_DEBUG(logger, \"Cleaning up SubscriberClientChannelHandler \" << this);\n+void ResubscribeCallback::operationFailed(const std::exception& exception) {\n+  if (RESUBSCRIBE_EXCEPTION == typeid(exception)) {\n+    // it might be caused by closesub when resubscribing.\n+    // so we don't need to retry resubscribe again\n+    LOG4CXX_WARN(logger, \"Failed to resubscribe \" << *activeSubscriber\n+                         << \" : but it is caused by closesub when resubscribing. \"\n+                         << \"so we don't need to retry subscribe again.\");\n+    return;\n+  }\n+  LOG4CXX_ERROR(logger, \"Failed to resubscribe \" << *activeSubscriber << \", will retry later : \"\n+                        << exception.what());\n+  activeSubscriber->resubscribe();\n }\n \n-void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) {\n-  if (m->has_message()) {\n-    boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n-    LOG4CXX_DEBUG(logger, \"Message received (topic:\" << origData->getTopic() << \", subscriberId:\" << origData->getSubscriberId() << \")\");\n+ActiveSubscriber::ActiveSubscriber(const PubSubDataPtr& data,\n+                                   const AbstractDuplexChannelPtr& channel,\n+                                   const SubscriptionPreferencesPtr& preferences,\n+                                   const DuplexChannelManagerPtr& channelManager)\n+  : channel(channel), deliverystate(STOPPED_DELIVERY), origData(data),\n+    preferences(preferences), channelManager(channelManager), should_wait(false) {\n+  LOG4CXX_DEBUG(logger, \"Creating ActiveSubscriber \" << this << \" for (topic:\"\n+                        << data->getTopic() << \", subscriber:\" << data->getSubscriberId() << \").\");\n+}\n \n-    if (this->handler.get()) {\n-      OperationCallbackPtr callback(new SubscriberConsumeCallback(client, shared_from_this(), origData, m));\n-      this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n-    } else {\n-      queue.push_back(m);\n-      if (queue.size() >= (std::size_t)client->getConfiguration().getInt(Configuration::MAX_MESSAGE_QUEUE_SIZE,\n-\t\t\t\t\t\t\t\t\t DEFAULT_MAX_MESSAGE_QUEUE_SIZE)) {\n-\tchannel->stopReceiving();\n-      }\n-    }\n+const std::string& ActiveSubscriber::getTopic() const {\n+  return origData->getTopic();\n+}\n+\n+const std::string& ActiveSubscriber::getSubscriberId() const {\n+  return origData->getSubscriberId();\n+}\n+\n+void ActiveSubscriber::deliverMessage(const PubSubResponsePtr& m) {\n+  boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n+\n+  LOG4CXX_INFO(logger, \"Message received (topic:\" << origData->getTopic() << \", subscriberId:\"\n+                       << origData->getSubscriberId() << \", msgId:\" << m->message().msgid().localcomponent()\n+                       << \") from channel \" << channel.get());\n+\n+  if (this->handler.get()) {\n+    OperationCallbackPtr callback(new SubscriberConsumeCallback(channelManager, shared_from_this(), m));\n+    this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n   } else {\n-    HedwigClientChannelHandler::messageReceived(channel, m);\n+    queueMessage(m);\n   }\n }\n \n-void SubscriberClientChannelHandler::close() {\n-  closed = true;\n+void ActiveSubscriber::queueMessage(const PubSubResponsePtr& m) {\n+  queue.push_back(m);\n+}\n \n-  // cancel reconnect timer\n-  if (reconnectTimer.get()) {\n-    boost::system::error_code ec;\n-    reconnectTimer->cancel(ec);\n-    if (ec) {\n-      LOG4CXX_WARN(logger, \"Handler \" << this << \" cancel reconnect task \" << reconnectTimer.get() << \" error :\" << ec.message().c_str());\n+void ActiveSubscriber::startDelivery(const MessageHandlerCallbackPtr& origHandler,\n+                                     const ClientMessageFilterPtr& origFilter) {\n+  // check delivery state to avoid dealock when calling startdelivery/stopdelivery\n+  // in message handler.\n+  // STOPPED_DELIVERY => STARTED_DELIVERY (only one could start delivery)\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(deliverystate_lock);\n+    if (STARTED_DELIVERY == deliverystate) {\n+      LOG4CXX_ERROR(logger, *this << \" has started delivery with message handler \"\n+                            << this->handler.get());\n+      throw AlreadyStartDeliveryException();\n+    } else if (STARTING_DELIVERY == deliverystate) {\n+      LOG4CXX_ERROR(logger, *this << \" is starting delivery by other one now.\");\n+      throw StartingDeliveryException();\n     }\n+    deliverystate = STARTING_DELIVERY;\n+  }\n+  try {\n+    doStartDelivery(origHandler, origFilter);\n+    // STARTING_DELIVERY => STARTED_DELIVERY\n+    setDeliveryState(STARTED_DELIVERY);\n+  } catch (const std::exception& e) {\n+    // STARTING_DELIVERY => STOPPED_DELIVERY\n+    setDeliveryState(STOPPED_DELIVERY); \n+    throw e;\n+  }\n+}\n+\n+void ActiveSubscriber::doStartDelivery(const MessageHandlerCallbackPtr& origHandler,\n+                                       const ClientMessageFilterPtr& origFilter) {\n+  MessageHandlerCallbackPtr handler;\n+  // origHandler & origFilter has been passed validation. If origFilter is null,\n+  // we start delivery w/o message filtering. or If the preferences is null, which\n+  // means we connected to an old version hub server, also starts w/o message filtering\n+  if (origFilter.get() && preferences.get()) {\n+    origFilter->setSubscriptionPreferences(origData->getTopic(), origData->getSubscriberId(),\n+                                           preferences);\n+    handler = MessageHandlerCallbackPtr(new FilterableMessageHandler(origHandler, origFilter));\n+  } else {\n+    handler = origHandler;\n   }\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n \n-  LOG4CXX_INFO(logger, \"close subscription handler \" << this << \" for (topic:\" << origData->getTopic()\n-                    << \", subscriberId:\" << origData->getSubscriberId() << \").\");\n-  if (channel.get()) {\n-    // need to ensure the channel is removed from allchannels list\n-    // since it will be killed\n-    client->removeAndCloseChannel(channel);\n-    LOG4CXX_INFO(logger, \"removed subscription channel \" << channel.get() << \" for (topic: \" << origData->getTopic()\n-                      << \", subscriberId:\" << origData->getSubscriberId() << \").\");\n+    if (this->handler.get()) {\n+      LOG4CXX_ERROR(logger, *this << \" has started delivery with message handler \"\n+                            << this->handler.get());\n+      throw AlreadyStartDeliveryException();\n+    }\n+\n+    if (!handler.get()) {\n+      // no message handler callback\n+      LOG4CXX_WARN(logger, *this << \" try to start an empty message handler\");\n+      return;\n+    }\n+\n+    this->handler = handler;\n+    // store the original filter and handler\n+    this->origHandler = origHandler;\n+    this->origFilter = origFilter;\n+\n+    while (!queue.empty()) {\n+      PubSubResponsePtr m = queue.front();\n+      queue.pop_front();\n+\n+      OperationCallbackPtr callback(new SubscriberConsumeCallback(channelManager, shared_from_this(), m));\n+      this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n+    }\n   }\n+\n+  LOG4CXX_INFO(logger, *this << \" #startDelivery to receive messages from channel \" << channel.get());\n }\n \n-/*static*/ void SubscriberClientChannelHandler::reconnectTimerComplete(const SubscriberClientChannelHandlerPtr handler,\n-\t\t\t\t\t\t\t\t       const DuplexChannelPtr channel, const std::exception e, \n-\t\t\t\t\t\t\t\t       const boost::system::error_code& error) {\n-  if (error) {\n-    return;\n+void ActiveSubscriber::stopDelivery() {\n+  // if someone is starting delivery, we should not allow it to stop.\n+  // otherwise we would break order gurantee. since queued message would be\n+  // delivered to message handler when #startDelivery.\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(deliverystate_lock);\n+    if (STARTING_DELIVERY == deliverystate) {\n+      LOG4CXX_ERROR(logger, \"someone is starting delivery for \" << *this\n+                            << \". we could not stop delivery now.\");\n+      throw StartingDeliveryException();      \n+    }\n   }\n-  handler->should_wait = false;\n-  handler->reconnect(channel, e);\n+  LOG4CXX_INFO(logger, *this << \" #stopDelivery to stop receiving messages from channel \" << channel.get());\n+  // actual stop delivery\n+  doStopDelivery();\n+  boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n+  this->handler = MessageHandlerCallbackPtr();\n+  // marked the state to stopped\n+  setDeliveryState(STOPPED_DELIVERY);\n }\n \n-void SubscriberClientChannelHandler::channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e) {\n-  // has subscription been closed\n-  if (closed) {\n-    return;\n-  }\n+void ActiveSubscriber::doStopDelivery() {\n+  // do nothing.\n+}\n \n-  // Clean up the channel from all maps\n-  client->channelDied(channel);\n-  if (client->shuttingDown()) {\n-    return;\n-  }\n+void ActiveSubscriber::consume(const MessageSeqId& messageSeqId) {\n+  PubSubDataPtr data = PubSubData::forConsumeRequest(channelManager->nextTxnId(),\n+                                                     origData->getSubscriberId(),\n+                                                     origData->getTopic(), messageSeqId);\n \n-  {\n-    boost::shared_lock<boost::shared_mutex> lock(disconnected_lock);\n-    // some one is reconnecting return\n-    if (disconnected) {\n-      return;\n-    }\n-    disconnected = true;\n+  int retrywait = channelManager->getConfiguration()\n+                  .getInt(Configuration::MESSAGE_CONSUME_RETRY_WAIT_TIME,\n+                          DEFAULT_MESSAGE_CONSUME_RETRY_WAIT_TIME);\n+  OperationCallbackPtr writecb(new ConsumeWriteCallback(shared_from_this(), data, retrywait));\n+  channel->writeRequest(data->getRequest(), writecb);\n+}\n+\n+void ActiveSubscriber::handoverDelivery() {\n+  if (handler.get()) {\n+    TopicSubscriber ts(origData->getTopic(), origData->getSubscriberId());\n+    // handover the message handler to other active subscriber\n+    channelManager->handoverDelivery(ts, origHandler, origFilter);\n   }\n+}\n \n-  // if we have registered the subscription channel listener, disable retry\n-  // just trigger listener to let application handle channel disconnected event\n-  if (!origData->getSubscriptionOptions().enableresubscribe()) {\n-    LOG4CXX_INFO(logger, \"Tell subscriber (topic:\" << origData->getTopic()\n-                         << \", subscriberId:\" << origData->getSubscriberId()\n-                         << \") his topic has been moved : channel \"\n-                         << channel.get() << \" is disconnected\");\n-    // remove record of the failed channel from the subscriber\n-    client->getSubscriberImpl().closeSubscription(origData->getTopic(), origData->getSubscriberId());\n-    // emit the event to notify the client that topic has been moved\n-    client->getSubscriberImpl().emitSubscriptionEvent(\n-      origData->getTopic(), origData->getSubscriberId(), TOPIC_MOVED);\n-  } else {\n-    reconnect(channel, e);\n+void ActiveSubscriber::processEvent(const std::string &topic, const std::string &subscriberId,\n+                                    const SubscriptionEvent event) {\n+  if (!isResubscribeRequired()) {\n+    channelManager->getEventEmitter().emitSubscriptionEvent(topic, subscriberId, event);\n+    return;\n+  }\n+  // resumbit the subscribe request\n+  if (TOPIC_MOVED == event) {\n+    resubscribe();\n   }\n }\n \n-void SubscriberClientChannelHandler::reconnect(const DuplexChannelPtr& channel, const std::exception& e) {\n+void ActiveSubscriber::resubscribe() {\n   if (should_wait) {\n-    int retrywait = client->getConfiguration().getInt(Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME,\n-\t\t\t\t\t\t      DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME);\n-    AbstractDuplexChannelPtr chPtr = boost::dynamic_pointer_cast<AbstractDuplexChannel>(channel);\n-    // set reconnect timer\n-    reconnectTimer = ReconnectTimerPtr(new boost::asio::deadline_timer(chPtr->getService(),\n-                                       boost::posix_time::milliseconds(retrywait)));\n-    reconnectTimer->async_wait(boost::bind(&SubscriberClientChannelHandler::reconnectTimerComplete, shared_from_this(),\n-\t\t\t     channel, e, boost::asio::placeholders::error));  \n+    waitToResubscribe();\n     return;\n   }\n   should_wait = true;\n \n-  // setup pubsub data for reconnection attempt\n   origData->clearTriedServers();\n-  ResponseCallbackPtr newcallback(new SubscriberReconnectCallback(client, origData));\n-  origData->setCallback(newcallback);\n+  origData->setCallback(ResponseCallbackPtr(new ResubscribeCallback(shared_from_this())));\n+  DuplexChannelPtr origChannel = \n+    boost::dynamic_pointer_cast<DuplexChannel>(channel);\n+  origData->setOrigChannelForResubscribe(origChannel);\n \n-  // Create a new handler for the new channel\n-  SubscriberClientChannelHandlerPtr newhandler(new SubscriberClientChannelHandler(client, subscriber, origData));  \n-  ChannelHandlerPtr baseptr = newhandler;\n-  \n-  DuplexChannelPtr newchannel = client->createChannel(origData->getTopic(), baseptr);\n-  newhandler->setChannel(newchannel);\n-  newchannel->connect();\n-  LOG4CXX_DEBUG(logger, \"Create a new channel \" << newchannel.get() << \" to handover delivery to new handler \" << newhandler.get());\n-  handoverDelivery(newhandler);\n-  \n-  // remove record of the failed channel from the subscriber\n-  client->getSubscriberImpl().closeSubscription(origData->getTopic(), origData->getSubscriberId());\n-  \n-  // subscriber\n-  client->getSubscriberImpl().doSubscribe(newchannel, origData, newhandler);\n+  // submit subscribe request again\n+  channelManager->submitOp(origData);\n }\n \n-void SubscriberClientChannelHandler::startDelivery(const MessageHandlerCallbackPtr& handler) {\n-  {\n-    boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n-\n-    this->handler = handler;\n-\n-    if (!(this->handler.get())) {\n-      // no message handler callback\n-      LOG4CXX_WARN(logger, \"Handler \" << this << \" try to start an empty message handler\");\n-      return;\n-    }\n-\n-    while (!queue.empty()) {    \n-      PubSubResponsePtr m = queue.front();\n-      queue.pop_front();\n+void ActiveSubscriber::waitToResubscribe() {\n+  int retrywait = channelManager->getConfiguration().getInt(Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME,\n+                                                            DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME);\n+  retryTimer = RetryTimerPtr(new boost::asio::deadline_timer(channel->getService(),\n+                             boost::posix_time::milliseconds(retrywait)));\n+  retryTimer->async_wait(boost::bind(&ActiveSubscriber::retryTimerComplete,\n+                                     shared_from_this(), boost::asio::placeholders::error));\n+}\n \n-      OperationCallbackPtr callback(new SubscriberConsumeCallback(client, shared_from_this(), origData, m));\n+void ActiveSubscriber::retryTimerComplete(const boost::system::error_code& error) {\n+  if (error) {\n+    return;\n+  }\n+  should_wait = false;\n+  // resubscribe again\n+  resubscribe();\n+}\n \n-      this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n+void ActiveSubscriber::close() {\n+  // cancel reconnect timer\n+  RetryTimerPtr timer = retryTimer;\n+  if (timer.get()) {\n+    boost::system::error_code ec;\n+    timer->cancel(ec);\n+    if (ec) {\n+      LOG4CXX_WARN(logger,  *this << \" cancel resubscribe task \" << timer.get() << \" error :\"\n+                            << ec.message().c_str());\n     }\n   }\n-\n-  // put channel#startReceiving out of lock of subscriber#queue_lock\n-  // otherwise we enter dead lock\n-  // subscriber#startDelivery(subscriber#queue_lock) =>\n-  // channel#startReceiving(channel#receiving_lock) =>\n-  channel->startReceiving();\n }\n \n-void SubscriberClientChannelHandler::stopDelivery() {\n-  channel->stopReceiving();\n-\n-  boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n-  this->handler = MessageHandlerCallbackPtr();\n+SubscriberClientChannelHandler::SubscriberClientChannelHandler(\n+  const DuplexChannelManagerPtr& channelManager, ResponseHandlerMap& handlers)\n+  : HedwigClientChannelHandler(channelManager, handlers) {\n+  LOG4CXX_DEBUG(logger, \"Creating SubscriberClientChannelHandler \" << this);\n }\n \n-\n-void SubscriberClientChannelHandler::handoverDelivery(const SubscriberClientChannelHandlerPtr& newHandler) {\n-  LOG4CXX_DEBUG(logger, \"Messages in queue \" << queue.size());\n-  MessageHandlerCallbackPtr handler = this->handler;\n-  stopDelivery(); // resets old handler\n-  newHandler->startDelivery(handler);\n+SubscriberClientChannelHandler::~SubscriberClientChannelHandler() {\n+  LOG4CXX_DEBUG(logger, \"Cleaning up SubscriberClientChannelHandler \" << this);\n }\n \n-void SubscriberClientChannelHandler::setChannel(const DuplexChannelPtr& channel) {\n-  this->channel = channel;\n+void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) {\n+  if (m->has_message()) {\n+    TopicSubscriber ts(m->topic(), m->subscriberid());\n+    // dispatch the message to target topic subscriber.\n+    deliverMessage(ts, m);\n+  } else {\n+    HedwigClientChannelHandler::messageReceived(channel, m);\n+  }\n }\n \n-DuplexChannelPtr& SubscriberClientChannelHandler::getChannel() {\n-  return channel;\n+void SubscriberClientChannelHandler::doClose() {\n+  // clean the handler status\n+  closeHandler();\n+\n+  if (channel.get()) {\n+    // need to ensure the channel is removed from allchannels list\n+    // since it will be killed\n+    channelManager->removeChannel(channel);\n+    LOG4CXX_INFO(logger, \"remove subscription channel \" << channel.get() << \".\");\n+  }\n }\n \n-SubscriberImpl::SubscriberImpl(const ClientImplPtr& client) \n-  : client(client) \n-{\n+SubscriberImpl::SubscriberImpl(const DuplexChannelManagerPtr& channelManager)\n+  : channelManager(channelManager) {\n }\n \n-SubscriberImpl::~SubscriberImpl() \n-{\n+SubscriberImpl::~SubscriberImpl() {\n   LOG4CXX_DEBUG(logger, \"deleting subscriber\" << this);\n }\n \n-\n void SubscriberImpl::subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode) {\n   SubscriptionOptions options;\n   options.set_createorattach(mode);\n   subscribe(topic, subscriberId, options);\n }\n \n void SubscriberImpl::subscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options) {\n-  SyncOperationCallback* cb = new SyncOperationCallback(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n-\t\t\t\t\t\t\t\t\t\t\t  DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  SyncOperationCallback* cb = new SyncOperationCallback(\n+    channelManager->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT,\n+                                              DEFAULT_SYNC_REQUEST_TIMEOUT));\n   OperationCallbackPtr callback(cb);\n   asyncSubscribe(topic, subscriberId, options, callback);\n   cb->wait();\n   \n-  cb->throwExceptionIfNeeded();  \n+  cb->throwExceptionIfNeeded();\n }\n \n void SubscriberImpl::asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback) {\n@@ -373,51 +442,23 @@ void SubscriberImpl::asyncSubscribe(const std::string& topic, const std::string&\n   SubscriptionOptions options2 = options;\n \n   if (!options2.has_messagebound()) {\n-    int messageBound = client->getConfiguration().getInt(Configuration::SUBSCRIPTION_MESSAGE_BOUND,\n-\t\t\t\t\t\t\t DEFAULT_SUBSCRIPTION_MESSAGE_BOUND);\n+    int messageBound = channelManager->getConfiguration()\n+                       .getInt(Configuration::SUBSCRIPTION_MESSAGE_BOUND,\n+                               DEFAULT_SUBSCRIPTION_MESSAGE_BOUND);\n     options2.set_messagebound(messageBound);\n   }\n \n   ResponseCallbackPtr respCallback(new ResponseCallbackAdaptor(callback));\n-  PubSubDataPtr data = PubSubData::forSubscribeRequest(client->counter().next(), subscriberId, topic,\n+  PubSubDataPtr data = PubSubData::forSubscribeRequest(channelManager->nextTxnId(),\n+                                                       subscriberId, topic,\n                                                        respCallback, options2);\n-\n-  SubscriberClientChannelHandlerPtr handler(new SubscriberClientChannelHandler(client, *this, data));\n-  ChannelHandlerPtr baseptr = handler;\n-\n-  DuplexChannelPtr channel = client->createChannel(topic, handler);\n-  handler->setChannel(channel);\n-  channel->connect();\n-  LOG4CXX_INFO(logger, \"New handler \" << handler.get() << \" on channel \" << channel.get()\n-                    << \" is created for (topic:\" << topic << \", subscriber:\" << subscriberId << \", txn:\"\n-                    << data->getTxnId() << \").\");\n-  doSubscribe(channel, data, handler);\n-}\n-\n-void SubscriberImpl::doSubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data, const SubscriberClientChannelHandlerPtr& handler) {\n-  channel->storeTransaction(data);\n-\n-  OperationCallbackPtr writecb(new SubscriberWriteCallback(client, data));\n-  channel->writeRequest(data->getRequest(), writecb);\n-\n-  SubscriberClientChannelHandlerPtr oldhandler;\n-  {\n-    boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-    TopicSubscriber t(data->getTopic(), data->getSubscriberId());\n-    oldhandler = topicsubscriber2handler[t];\n-    topicsubscriber2handler[t] = handler;\n-  }\n-  if (oldhandler.get() != NULL) {\n-    LOG4CXX_DEBUG(logger, \"(topic:\" << data->getTopic() << \", subscriber:\" << data->getSubscriberId()\n-                          << \") handover delivery from old handler \" << oldhandler.get()\n-                          << \" to new handler \" << handler.get());\n-    oldhandler->handoverDelivery(handler);\n-  }\n+  channelManager->submitOp(data);\n }\n \n void SubscriberImpl::unsubscribe(const std::string& topic, const std::string& subscriberId) {\n-  SyncOperationCallback* cb = new SyncOperationCallback(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n-\t\t\t\t\t\t\t\t\t\t\t  DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  SyncOperationCallback* cb = new SyncOperationCallback(\n+    channelManager->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT,\n+                                              DEFAULT_SYNC_REQUEST_TIMEOUT));\n   OperationCallbackPtr callback(cb);\n   asyncUnsubscribe(topic, subscriberId, callback);\n   cb->wait();\n@@ -426,44 +467,26 @@ void SubscriberImpl::unsubscribe(const std::string& topic, const std::string& su\n }\n \n void SubscriberImpl::asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback) {\n-  closeSubscription(topic, subscriberId);\n-\n-  ResponseCallbackPtr respCallback(new ResponseCallbackAdaptor(callback));\n-  PubSubDataPtr data = PubSubData::forUnsubscribeRequest(client->counter().next(), subscriberId, topic, respCallback);\n-  \n-  DuplexChannelPtr channel = client->getChannel(topic);\n-  doUnsubscribe(channel, data);\n-}\n-\n-void SubscriberImpl::doUnsubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data) {\n-  channel->storeTransaction(data);\n-  OperationCallbackPtr writecb(new UnsubscribeWriteCallback(client, data));\n-  channel->writeRequest(data->getRequest(), writecb);\n+  OperationCallbackPtr closeCb(new CloseSubscriptionForUnsubscribeCallback(channelManager, topic,\n+                                                                           subscriberId, callback));\n+  asyncCloseSubscription(topic, subscriberId, closeCb);\n }\n \n-void SubscriberImpl::consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId) {\n+void SubscriberImpl::consume(const std::string& topic, const std::string& subscriberId,\n+                             const MessageSeqId& messageSeqId) {\n   TopicSubscriber t(topic, subscriberId);\n \n-  SubscriberClientChannelHandlerPtr handler;\n-  {\n-    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-    handler = topicsubscriber2handler[t];\n-  }\n+  // Get the subscriber channel handler\n+  SubscriberClientChannelHandlerPtr handler =\n+    channelManager->getSubscriptionChannelHandler(t);\n \n   if (handler.get() == 0) {\n-    LOG4CXX_ERROR(logger, \"Cannot consume. Bad handler for topic(\" << topic << \") subscriberId(\" << subscriberId << \") topicsubscriber2topic(\" << &topicsubscriber2handler << \")\");\n+    LOG4CXX_ERROR(logger, \"Cannot consume. No subscription channel handler found for topic (\"\n+                          << topic << \") subscriberId(\" << subscriberId << \").\");\n     return;\n   }\n \n-  DuplexChannelPtr channel = handler->getChannel();\n-  if (channel.get() == 0) {\n-    LOG4CXX_ERROR(logger, \"Trying to consume a message on a topic/subscriber pair that don't have a channel. Something fishy going on. Topic: \" << topic << \" SubscriberId: \" << subscriberId << \" MessageSeqId: \" << messageSeqId.localcomponent());\n-    return;\n-  }\n-  \n-  PubSubDataPtr data = PubSubData::forConsumeRequest(client->counter().next(), subscriberId, topic, messageSeqId);  \n-  OperationCallbackPtr writecb(new ConsumeWriteCallback(client, data));\n-  channel->writeRequest(data->getRequest(), writecb);\n+  handler->consume(t, messageSeqId);\n }\n \n void SubscriberImpl::startDeliveryWithFilter(const std::string& topic,\n@@ -476,138 +499,108 @@ void SubscriberImpl::startDeliveryWithFilter(const std::string& topic,\n   if (0 == callback.get()) {\n     throw NullMessageHandlerException();\n   }\n-  const SubscriptionPreferencesPtr& preferences =\n-    getSubscriptionPreferences(topic, subscriberId);\n-  if (0 == preferences.get()) {\n+\n+  TopicSubscriber t(topic, subscriberId);\n+\n+  // Get the subscriber channel handler\n+  SubscriberClientChannelHandlerPtr handler =\n+    channelManager->getSubscriptionChannelHandler(t);\n+\n+  if (handler.get() == 0) {\n+    LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \"\n+                          << topic << \", subscriber = \" << subscriberId);\n     throw NotSubscribedException();\n   }\n-  filter->setSubscriptionPreferences(topic, subscriberId, preferences);\n-  MessageHandlerCallbackPtr filterableHandler(new FilterableMessageHandler(callback, filter));\n-  startDelivery(topic, subscriberId, filterableHandler);\n+\n+  handler->startDelivery(t, callback, filter);\n }\n \n void SubscriberImpl::startDelivery(const std::string& topic, const std::string& subscriberId,\n                                    const MessageHandlerCallbackPtr& callback) {\n   TopicSubscriber t(topic, subscriberId);\n \n-  SubscriberClientChannelHandlerPtr handler;\n-  {\n-    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-    handler = topicsubscriber2handler[t];\n-  }\n+  // Get the subscriber channel handler\n+  SubscriberClientChannelHandlerPtr handler =\n+    channelManager->getSubscriptionChannelHandler(t);\n \n   if (handler.get() == 0) {\n-    LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+    LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \"\n+                          << topic << \", subscriber = \" << subscriberId);\n     throw NotSubscribedException();\n   }\n-  handler->startDelivery(callback);\n+  handler->startDelivery(t, callback, ClientMessageFilterPtr());\n }\n \n void SubscriberImpl::stopDelivery(const std::string& topic, const std::string& subscriberId) {\n   TopicSubscriber t(topic, subscriberId);\n \n-  SubscriberClientChannelHandlerPtr handler;\n-  {\n-    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-    handler = topicsubscriber2handler[t];\n-  }\n+  // Get the subscriber channel handler\n+  SubscriberClientChannelHandlerPtr handler =\n+    channelManager->getSubscriptionChannelHandler(t);\n \n   if (handler.get() == 0) {\n-    LOG4CXX_ERROR(logger, \"Trying to stop deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+    LOG4CXX_ERROR(logger, \"Trying to stop deliver on a non existant handler topic = \"\n+                          << topic << \", subscriber = \" << subscriberId);\n     throw NotSubscribedException();\n   }\n-  handler->stopDelivery();\n+  handler->stopDelivery(t);\n }\n \n-void SubscriberImpl::closeSubscription(const std::string& topic, const std::string& subscriberId) {\n-  LOG4CXX_DEBUG(logger, \"closeSubscription (\" << topic << \",  \" << subscriberId << \")\");\n+bool SubscriberImpl::hasSubscription(const std::string& topic, const std::string& subscriberId) {\n+  TopicSubscriber ts(topic, subscriberId);\n+  // Get the subscriber channel handler\n+  SubscriberClientChannelHandlerPtr handler =\n+    channelManager->getSubscriptionChannelHandler(ts);\n+  return 0 != handler.get();\n+}\n \n-  TopicSubscriber t(topic, subscriberId);\n+void SubscriberImpl::closeSubscription(const std::string& topic, const std::string& subscriberId) {\n+  SyncOperationCallback* cb = new SyncOperationCallback(\n+    channelManager->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT,\n+                                              DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  OperationCallbackPtr callback(cb);\n+  asyncCloseSubscription(topic, subscriberId, callback);\n+  cb->wait();\n \n-  SubscriberClientChannelHandlerPtr handler;\n-  {\n-    boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-    handler = topicsubscriber2handler[t];\n-    topicsubscriber2handler.erase(t);\n-  }\n-  \n-  if (handler.get() != 0) {\n-    handler->close();\n-  }\n+  cb->throwExceptionIfNeeded();\n }\n \n-void SubscriberImpl::setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n-                                                const SubscriptionPreferences& preferences) {\n-  boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2preferences_lock);\n-  TopicSubscriber t(topic, subscriberId);\n-  SubscriptionPreferencesPtr newPreferences(new SubscriptionPreferences(preferences));\n-  topicsubscriber2preferences[t] = newPreferences;\n-}\n+void SubscriberImpl::asyncCloseSubscription(const std::string& topic,\n+                                            const std::string& subscriberId,\n+                                            const OperationCallbackPtr& callback) {\n+  LOG4CXX_INFO(logger, \"closeSubscription (\" << topic << \",  \" << subscriberId << \")\");\n \n-const SubscriptionPreferencesPtr& SubscriberImpl::getSubscriptionPreferences(\n-    const std::string& topic, const std::string& subscriberId) {\n-  boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2preferences_lock);\n   TopicSubscriber t(topic, subscriberId);\n-  const SubscriptionPreferencesPtr &preferences = topicsubscriber2preferences[t];\n-  return preferences;\n+  channelManager->asyncCloseSubscription(t, callback);\n }\n \n void SubscriberImpl::addSubscriptionListener(SubscriptionListenerPtr& listener) {\n-  boost::lock_guard<boost::shared_mutex> lock(listeners_lock);\n-  listeners.insert(listener);\n+  channelManager->getEventEmitter().addSubscriptionListener(listener);\n }\n \n void SubscriberImpl::removeSubscriptionListener(SubscriptionListenerPtr& listener) {\n-  boost::lock_guard<boost::shared_mutex> lock(listeners_lock);\n-  listeners.erase(listener);\n-}\n-\n-void SubscriberImpl::emitSubscriptionEvent(const std::string& topic,\n-                                           const std::string& subscriberId,\n-                                           const SubscriptionEvent event) {\n-  boost::shared_lock<boost::shared_mutex> lock(listeners_lock);\n-  if (0 == listeners.size()) {\n-    return;\n-  }\n-  for (SubscriptionListenerSet::iterator iter = listeners.begin();\n-       iter != listeners.end(); ++iter) {\n-    (*iter)->processEvent(topic, subscriberId, event);\n-  }\n+  channelManager->getEventEmitter().removeSubscriptionListener(listener);\n }\n \n-/**\n-   takes ownership of txn\n-*/\n-void SubscriberImpl::messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn) {\n-  if (!txn.get()) {\n-    LOG4CXX_ERROR(logger, \"Invalid transaction\");\n-    return;\n-  }\n-\n-  LOG4CXX_DEBUG(logger, \"message received with status \" << m->statuscode());\n+//\n+// Unsubscribe Response Handler\n+//\n+UnsubscribeResponseHandler::UnsubscribeResponseHandler(const DuplexChannelManagerPtr& channelManager)\n+  : ResponseHandler(channelManager) {}\n \n+void UnsubscribeResponseHandler::handleResponse(const PubSubResponsePtr& m,\n+                                                const PubSubDataPtr& txn,\n+                                                const DuplexChannelPtr& channel) {\n   switch (m->statuscode()) {\n   case SUCCESS:\n-    // for subscribe request, check whether is any subscription preferences received\n-    if (SUBSCRIBE == txn->getType()) {\n-      if (m->has_responsebody()) {\n-        const ResponseBody& respBody = m->responsebody();\n-        if (respBody.has_subscriberesponse()) {\n-          const SubscribeResponse& resp = respBody.subscriberesponse();\n-          if (resp.has_preferences()) {\n-            setSubscriptionPreferences(txn->getTopic(), txn->getSubscriberId(),\n-                                       resp.preferences());\n-          }\n-        }\n-      }\n-    }\n     if (m->has_responsebody()) {\n       txn->getCallback()->operationComplete(m->responsebody());\n     } else {\n       txn->getCallback()->operationComplete(ResponseBody());\n     }\n     break;\n   case SERVICE_DOWN:\n+    LOG4CXX_ERROR(logger, \"Server responsed with SERVICE_DOWN for \" << txn->getTxnId());\n     txn->getCallback()->operationFailed(ServiceDownException());\n     break;\n   case CLIENT_ALREADY_SUBSCRIBED:\n@@ -617,8 +610,18 @@ void SubscriberImpl::messageHandler(const PubSubResponsePtr& m, const PubSubData\n   case CLIENT_NOT_SUBSCRIBED:\n     txn->getCallback()->operationFailed(NotSubscribedException());\n     break;\n+  case NOT_RESPONSIBLE_FOR_TOPIC:\n+    redirectRequest(m, txn, channel);\n+    break;\n   default:\n+    LOG4CXX_ERROR(logger, \"Unexpected response \" << m->statuscode() << \" for \" << txn->getTxnId());\n     txn->getCallback()->operationFailed(UnexpectedResponseException());\n     break;\n   }\n }\n+\n+std::ostream& Hedwig::operator<<(std::ostream& os, const ActiveSubscriber& subscriber) {\n+  os << \"ActiveSubscriber(\" << &subscriber << \", topic:\" << subscriber.getTopic()\n+     << \", subscriber:\" << subscriber.getSubscriberId() << \")\";\n+  return os;\n+}"},{"sha":"f180d717f82662f6ac979ed43e54effceb064f04","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":210,"deletions":97,"changes":307,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -30,131 +30,254 @@\n #endif\n \n #include <deque>\n+#include <iostream>\n \n #include <boost/shared_ptr.hpp>\n #include <boost/enable_shared_from_this.hpp>\n #include <boost/thread/shared_mutex.hpp>\n \n namespace Hedwig {\n-  class SubscriberWriteCallback : public OperationCallback {\n+\n+  class ActiveSubscriber;\n+  typedef boost::shared_ptr<ActiveSubscriber> ActiveSubscriberPtr;\n+\n+  class ConsumeWriteCallback : public OperationCallback {\n   public:\n-    SubscriberWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n+    ConsumeWriteCallback(const ActiveSubscriberPtr& activeSubscriber,\n+                         const PubSubDataPtr& data,\n+                         int retrywait);\n+    virtual ~ConsumeWriteCallback();\n \n     void operationComplete();\n     void operationFailed(const std::exception& exception);\n+\n+    static void timerComplete(const ActiveSubscriberPtr& activeSubscriber,\n+                              const PubSubDataPtr& data,\n+                              const boost::system::error_code& error);\n   private:\n-    const ClientImplPtr client;\n+    const ActiveSubscriberPtr activeSubscriber;\n     const PubSubDataPtr data;\n+    int retrywait;\n   };\n-  \n-  class UnsubscribeWriteCallback : public OperationCallback {\n-  public:\n-    UnsubscribeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n \n+  class SubscriberClientChannelHandler;\n+  typedef boost::shared_ptr<SubscriberClientChannelHandler> SubscriberClientChannelHandlerPtr;\n+\n+  class SubscriberConsumeCallback : public OperationCallback {\n+  public:\n+    SubscriberConsumeCallback(const DuplexChannelManagerPtr& channelManager,\n+                              const ActiveSubscriberPtr& activeSubscriber,\n+                              const PubSubResponsePtr& m);\n     void operationComplete();\n     void operationFailed(const std::exception& exception);\n+    static void timerComplete(const ActiveSubscriberPtr activeSubscriber,\n+                              const PubSubResponsePtr m,\n+                              const boost::system::error_code& error);\n   private:\n-    const ClientImplPtr client;\n-    const PubSubDataPtr data;\n+    const DuplexChannelManagerPtr channelManager;\n+    const ActiveSubscriberPtr activeSubscriber;\n+    const PubSubResponsePtr m;\n   };\n \n-  class ConsumeWriteCallback : public OperationCallback {\n+  class CloseSubscriptionForUnsubscribeCallback : public OperationCallback {\n   public:\n-    ConsumeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n-    ~ConsumeWriteCallback();\n-\n-    void operationComplete();\n-    void operationFailed(const std::exception& exception);\n-    \n-    static void timerComplete(const ClientImplPtr& client, const PubSubDataPtr& data, const boost::system::error_code& error);\n+    CloseSubscriptionForUnsubscribeCallback(const DuplexChannelManagerPtr& channelManager,\n+                                            const std::string& topic,\n+                                            const std::string& subscriberId,\n+                                            const OperationCallbackPtr& unsubCb);\n+    virtual void operationComplete();\n+    virtual void operationFailed(const std::exception& exception);\n   private:\n-    const ClientImplPtr client;\n-    const PubSubDataPtr data;\n-    };\n+    const DuplexChannelManagerPtr channelManager;\n+    const std::string topic;\n+    const std::string subscriberId;\n+    const OperationCallbackPtr unsubCb;\n+  };\n \n-  class SubscriberReconnectCallback : public ResponseCallback {\n-  public: \n-    SubscriberReconnectCallback(const ClientImplPtr& client, const PubSubDataPtr& origData);\n+  // A instance handle all actions belongs to a subscription\n+  class ActiveSubscriber : public boost::enable_shared_from_this<ActiveSubscriber> {\n+  public:\n+    ActiveSubscriber(const PubSubDataPtr& data,\n+                     const AbstractDuplexChannelPtr& channel,\n+                     const SubscriptionPreferencesPtr& preferences,\n+                     const DuplexChannelManagerPtr& channelManager);\n+    virtual ~ActiveSubscriber() {}\n \n-    void operationComplete(const ResponseBody & resp);\n-    void operationFailed(const std::exception& exception);\n-  private:\n-    const ClientImplPtr client;\n-    const PubSubDataPtr origData;\n-  };\n+    // Get the topic\n+    const std::string& getTopic() const;\n \n-  class SubscriberClientChannelHandler;\n-  typedef boost::shared_ptr<SubscriberClientChannelHandler> SubscriberClientChannelHandlerPtr;\n+    // Get the subscriber id\n+    const std::string& getSubscriberId() const;\n \n-  class SubscriberConsumeCallback : public OperationCallback {\n-  public: \n-    SubscriberConsumeCallback(const ClientImplPtr& client, const SubscriberClientChannelHandlerPtr& handler, const PubSubDataPtr& data, const PubSubResponsePtr& m);\n+    inline MessageHandlerCallbackPtr getMessageHandler() const {\n+      return handler;\n+    }\n \n-    void operationComplete();\n-    void operationFailed(const std::exception& exception);\n-    static void timerComplete(const SubscriberClientChannelHandlerPtr handler, \n-\t\t\t      const PubSubResponsePtr m, \n-\t\t\t      const boost::system::error_code& error);\n+    inline const AbstractDuplexChannelPtr& getChannel() const {\n+      return channel;\n+    }\n \n-  private:\n-    const ClientImplPtr client;\n-    const SubscriberClientChannelHandlerPtr handler;\n-    \n-    const PubSubDataPtr data;\n-    const PubSubResponsePtr m;\n-  };\n+    // Deliver a received message\n+    void deliverMessage(const PubSubResponsePtr& m);\n \n-  class SubscriberClientChannelHandler : public HedwigClientChannelHandler, \n-\t\t\t\t\t public boost::enable_shared_from_this<SubscriberClientChannelHandler> {\n-  public: \n-    SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber,\n-                                   const PubSubDataPtr& data);\n-    ~SubscriberClientChannelHandler();\n+    //\n+    // Start Delivery. If filter is null, just start delivery w/o filter \n+    // otherwise start delivery with the given filter.\n+    // \n+    void startDelivery(const MessageHandlerCallbackPtr& handler,\n+                       const ClientMessageFilterPtr& filter);\n \n-    void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m);\n-    void channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e);\n+    // Stop Delivery\n+    virtual void stopDelivery();\n \n-    void startDelivery(const MessageHandlerCallbackPtr& handler);\n-    void stopDelivery();\n+    // Consume message\n+    void consume(const MessageSeqId& messageSeqId);\n \n-    void handoverDelivery(const SubscriberClientChannelHandlerPtr& newHandler);\n+    // Process Event received from subscription channel\n+    void processEvent(const std::string &topic, const std::string &subscriberId,\n+                      const SubscriptionEvent event);\n \n-    void setChannel(const DuplexChannelPtr& channel);\n-    DuplexChannelPtr& getChannel();\n+    // handover message delivery to other subscriber\n+    void handoverDelivery();\n \n-    void reconnect(const DuplexChannelPtr& channel, const std::exception& e);\n+    // Is resubscribe required\n+    inline bool isResubscribeRequired() {\n+      return origData->getSubscriptionOptions().enableresubscribe();\n+    }\n \n-    static void reconnectTimerComplete(const SubscriberClientChannelHandlerPtr handler, const DuplexChannelPtr channel, const std::exception e, \n-\t\t\t\t       const boost::system::error_code& error);\n+    // Resubscribe the subscriber\n+    void resubscribe();\n \n+    // Close the ActiveSubscriber\n     void close();\n-  private:\n \n-    SubscriberImpl& subscriber;\n+    friend std::ostream& operator<<(std::ostream& os, const ActiveSubscriber& subscriber);\n+  protected:\n+    // Wait to resubscribe\n+    void waitToResubscribe();\n+\n+    void retryTimerComplete(const boost::system::error_code& error);\n+\n+    // Start Delivery with a message filter\n+    virtual void doStartDelivery(const MessageHandlerCallbackPtr& handler,\n+                                 const ClientMessageFilterPtr& filter);\n+\n+    // Stop Delivery\n+    virtual void doStopDelivery();\n+\n+    // Queue message when message handler is not ready\n+    virtual void queueMessage(const PubSubResponsePtr& m);\n+\n+    AbstractDuplexChannelPtr channel;\n+\n     boost::shared_mutex queue_lock;\n     std::deque<PubSubResponsePtr> queue;\n \n+  private:\n+    enum DeliveryState {\n+      STARTING_DELIVERY,\n+      STARTED_DELIVERY,\n+      STOPPED_DELIVERY,\n+    };\n+\n+    inline void setDeliveryState(DeliveryState state) {\n+      {\n+        boost::lock_guard<boost::shared_mutex> lock(deliverystate_lock);\n+        deliverystate = state;\n+      }\n+    }\n+\n+    boost::shared_mutex deliverystate_lock;\n+    DeliveryState deliverystate;\n+\n+    // Keep original handler and filter to handover when resubscribed\n+    MessageHandlerCallbackPtr origHandler;\n+    ClientMessageFilterPtr origFilter;\n+\n     MessageHandlerCallbackPtr handler;\n-    PubSubDataPtr origData;\n-    DuplexChannelPtr channel;\n-    bool closed;\n \n-    boost::shared_mutex disconnected_lock;\n+    const PubSubDataPtr origData;\n+    const SubscriptionPreferencesPtr preferences;\n+\n+    DuplexChannelManagerPtr channelManager;\n+\n+    // variables used for resubscribe\n     bool should_wait;\n-    bool disconnected;\n-    typedef boost::shared_ptr<boost::asio::deadline_timer> ReconnectTimerPtr;\n-    ReconnectTimerPtr reconnectTimer;\n+    typedef boost::shared_ptr<boost::asio::deadline_timer> RetryTimerPtr;\n+    RetryTimerPtr retryTimer;\n   };\n \n-  struct SubscriptionListenerPtrHash : public std::unary_function<SubscriptionListenerPtr, size_t> {\n-    size_t operator()(const Hedwig::SubscriptionListenerPtr& listener) const {\n-      return reinterpret_cast<size_t>(listener.get());\n+  class ResubscribeCallback : public ResponseCallback {\n+  public:\n+    explicit ResubscribeCallback(const ActiveSubscriberPtr& activeSubscriber);\n+\n+    virtual void operationComplete(const ResponseBody & resp);\n+    virtual void operationFailed(const std::exception& exception);\n+\n+  private:\n+    const ActiveSubscriberPtr activeSubscriber;\n+  };\n+\n+  class SubscriberClientChannelHandler : public HedwigClientChannelHandler,\n+      public boost::enable_shared_from_this<SubscriberClientChannelHandler> {\n+  public:\n+    SubscriberClientChannelHandler(const DuplexChannelManagerPtr& channelManager,\n+                                   ResponseHandlerMap& handlers);\n+    virtual ~SubscriberClientChannelHandler();\n+\n+    // Deliver a received message to given message handler\n+    virtual void deliverMessage(const TopicSubscriber& ts,\n+                                const PubSubResponsePtr& m) = 0;\n+\n+    //\n+    // Start Delivery for a given topic subscriber. If the filter is null,\n+    // start delivery w/o filtering; otherwise start delivery with the\n+    // given message filter.\n+    //\n+    virtual void startDelivery(const TopicSubscriber& ts,\n+                               const MessageHandlerCallbackPtr& handler,\n+                               const ClientMessageFilterPtr& filter) = 0;\n+\n+    // Stop Delivery for a given topic subscriber\n+    virtual void stopDelivery(const TopicSubscriber& ts) = 0;\n+\n+    // Has Subscription on the Channel\n+    virtual bool hasSubscription(const TopicSubscriber& ts) = 0;\n+\n+    // Close Subscription for a given topic subscriber\n+    virtual void asyncCloseSubscription(const TopicSubscriber& ts,\n+                                        const OperationCallbackPtr& callback) = 0;\n+\n+    // Consume message for a given topic subscriber\n+    virtual void consume(const TopicSubscriber& ts,\n+                         const MessageSeqId& messageSeqId) = 0;\n+\n+    // Message received from the underlying channel\n+    virtual void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m);\n+\n+    // Bind the underlying channel to the subscription channel handler\n+    inline void setChannel(const AbstractDuplexChannelPtr& channel) {\n+      this->channel = channel;\n+    }\n+\n+    // Return the underlying channel\n+    inline const AbstractDuplexChannelPtr& getChannel() const {\n+      return channel;\n     }\n+\n+  protected:\n+    // close logic for subscription channel handler\n+    virtual void doClose();\n+\n+    // Clean the handler status\n+    virtual void closeHandler() = 0;\n+\n+    AbstractDuplexChannelPtr channel;\n   };\n \n   class SubscriberImpl : public Subscriber {\n   public:\n-    SubscriberImpl(const ClientImplPtr& client);\n+    SubscriberImpl(const DuplexChannelManagerPtr& channelManager);\n     ~SubscriberImpl();\n \n     void subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode);\n@@ -174,38 +297,28 @@ namespace Hedwig {\n                                  const ClientMessageFilterPtr& filter);\n     void stopDelivery(const std::string& topic, const std::string& subscriberId);\n \n+    bool hasSubscription(const std::string& topic, const std::string& subscriberId);\n     void closeSubscription(const std::string& topic, const std::string& subscriberId);\n-\n-    void messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn);\n-\n-    void doSubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data, const SubscriberClientChannelHandlerPtr& handler);\n-    void doUnsubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data);\n+    void asyncCloseSubscription(const std::string& topic, const std::string& subscriberId,\n+                                const OperationCallbackPtr& callback);\n \n     virtual void addSubscriptionListener(SubscriptionListenerPtr& listener);\n     virtual void removeSubscriptionListener(SubscriptionListenerPtr& listener);\n-    void emitSubscriptionEvent(const std::string& topic,\n-                               const std::string& subscriberId,\n-                               const SubscriptionEvent event);\n \n   private:\n-    void setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n-                                    const SubscriptionPreferences& preferences);\n-    const SubscriptionPreferencesPtr& getSubscriptionPreferences(\n-                                    const std::string& topic, const std::string& subscriberId);\n+    const DuplexChannelManagerPtr channelManager;\n+  };\n \n-  private:\n-    const ClientImplPtr client;\n+  // Unsubscribe Response Handler\n \n-    std::tr1::unordered_map<TopicSubscriber, SubscriberClientChannelHandlerPtr, TopicSubscriberHash > topicsubscriber2handler;\n-    boost::shared_mutex topicsubscriber2handler_lock;\t    \n-    std::tr1::unordered_map<TopicSubscriber, SubscriptionPreferencesPtr, TopicSubscriberHash> topicsubscriber2preferences;\n-    boost::shared_mutex topicsubscriber2preferences_lock;\t    \n+  class UnsubscribeResponseHandler : public ResponseHandler {\n+  public:\n+    explicit UnsubscribeResponseHandler(const DuplexChannelManagerPtr& channelManager);\n+    virtual ~UnsubscribeResponseHandler() {}\n \n-    typedef std::tr1::unordered_set<SubscriptionListenerPtr, SubscriptionListenerPtrHash> SubscriptionListenerSet;\n-    SubscriptionListenerSet listeners;\n-    boost::shared_mutex listeners_lock;\n+    virtual void handleResponse(const PubSubResponsePtr& m, const PubSubDataPtr& txn,\n+                                const DuplexChannelPtr& channel);\n   };\n-\n };\n \n #endif"},{"sha":"6c9e7ab849630f7279df0c5edd539bc6a86ade29","filename":"hedwig-client/src/main/cpp/lib/util.cpp","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/util.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/util.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -165,3 +165,19 @@ void ResponseCallbackAdaptor::operationComplete(const ResponseBody& response) {\n void ResponseCallbackAdaptor::operationFailed(const std::exception& exception) {\n   opCallbackPtr->operationFailed(exception);\n }\n+\n+// Help Function\n+std::ostream& Hedwig::operator<<(std::ostream& os, const HostAddress& host) {\n+  if (host.isNullHost()) {\n+    os << \"(host:null)\";\n+  } else {\n+    os << \"(host:\" << host.getAddressString() << \", ip=\" << host.ip() << \", port=\"\n+       << host.port() << \", ssl_port=\" << host.sslPort() << \")\";\n+  }\n+  return os;\n+}\n+\n+std::ostream& Hedwig::operator<<(std::ostream& os, const TopicSubscriber& ts) {\n+  os << \"(topic:\" << ts.first << \", subscriber:\" << ts.second << \")\";\n+  return os;\n+}"},{"sha":"3c53ddd191f788edc3440d1c7342784af43702c3","filename":"hedwig-client/src/main/cpp/lib/util.h","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/lib/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -38,6 +38,8 @@\n \n namespace Hedwig {\n   typedef std::pair<const std::string, const std::string> TopicSubscriber;\n+  // Help Function to print topicSubscriber\n+  std::ostream& operator<<(std::ostream& os, const TopicSubscriber& ts);\n \n   /**\n      Representation of a hosts address\n@@ -61,6 +63,7 @@ namespace Hedwig {\n \n     static HostAddress fromString(std::string host);\n \n+    friend std::ostream& operator<<(std::ostream& os, const HostAddress& host);\n   private:\n \n     void parse_string();\n@@ -106,6 +109,15 @@ namespace Hedwig {\n       return std::tr1::hash<std::string>()(fullstr);\n     }\n   };\n+\n+  /**\n+   * Operation Type Hash\n+   */\n+  struct OperationTypeHash : public std::unary_function<Hedwig::OperationType, size_t> {\n+    size_t operator()(const Hedwig::OperationType& type) const {\n+      return type;\n+    }\n+  };\n };\n \n #endif"},{"sha":"56b7c41805d772e9f403a7110f3643fbfa9563df","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -52,7 +52,7 @@ class MessageBoundOrderCheckingMessageHandlerCallback : public Hedwig::MessageHa\n   }\n \n   virtual void consume(const std::string& topic, const std::string& subscriberId,\n-\t\t       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+                       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n     boost::lock_guard<boost::mutex> lock(mutex);\n       \n     int thisMsg = atoi(msg.body().c_str());\n@@ -118,7 +118,7 @@ TEST(MessageBoundTest, testMessageBound) {\n   Hedwig::Subscriber& sub = client->getSubscriber();\n   Hedwig::Publisher& pub = client->getPublisher();\n \n-  std::string topic = \"testTopic\";\n+  std::string topic = \"testMessageBound\";\n   std::string subid = \"testSubId\";\n   sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n   sub.closeSubscription(topic, subid);\n@@ -145,7 +145,7 @@ TEST(MessageBoundTest, testMultipleSubscribers) {\n   Hedwig::SubscriptionOptions optionsUnlimited;\n   optionsUnlimited.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n \n-  std::string topic = \"testTopic\";\n+  std::string topic = \"testMultipleSubscribers\";\n   std::string subid5 = \"testSubId5\";\n   std::string subid20 = \"testSubId20\";\n   std::string subidUnlimited = \"testSubIdUnlimited\";"},{"sha":"9baba1d8ed2ba82e9e44ed76ba08cc411c25faf2","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"modified","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -36,6 +36,41 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n+class StartStopDeliveryMsgHandler : public Hedwig::MessageHandlerCallback {\n+public:\n+  StartStopDeliveryMsgHandler(Hedwig::Subscriber& subscriber, const int nextValue)\n+    : subscriber(subscriber), nextValue(nextValue) {}\n+\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                       const Hedwig::Message& msg,\n+                       Hedwig::OperationCallbackPtr& callback) {\n+    {\n+      boost::lock_guard<boost::mutex> lock(mutex);\n+\n+      int curVal = atoi(msg.body().c_str());\n+      LOG4CXX_DEBUG(logger, \"received message \" << curVal);\n+      if (curVal == nextValue) {\n+        ++nextValue;\n+      }\n+      callback->operationComplete();\n+    }\n+    ASSERT_THROW(subscriber.startDelivery(topic, subscriberId,\n+                                          Hedwig::MessageHandlerCallbackPtr()),\n+                 Hedwig::StartingDeliveryException);\n+    ASSERT_THROW(subscriber.stopDelivery(topic, subscriberId),\n+                 Hedwig::StartingDeliveryException);\n+  }\n+\n+  int getNextValue() {\n+    return nextValue;\n+  }\n+\n+private:\n+  Hedwig::Subscriber& subscriber;\n+  boost::mutex mutex;\n+  int nextValue;\n+};\n+\n class PubSubMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n public:\n   PubSubMessageHandlerCallback(const std::string& topic, const std::string& subscriberId) : messagesReceived(0), topic(topic), subscriberId(subscriberId) {\n@@ -185,6 +220,127 @@ class IntegerPublisher {\n   long runTime;\n };\n \n+TEST(PubSubTest, testStartDeliveryWithoutSub) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+\n+  std::string topic = \"testStartDeliveryWithoutSub\";\n+  std::string sid = \"mysub\";\n+\n+  PubSubMessageHandlerCallback* cb = new PubSubMessageHandlerCallback(topic, sid);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  ASSERT_THROW(sub.startDelivery(topic, sid, handler),\n+               Hedwig::NotSubscribedException);\n+}\n+\n+TEST(PubSubTest, testAlreadyStartDelivery) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+\n+  std::string topic = \"testAlreadyStartDelivery\";\n+  std::string sid = \"mysub\";\n+\n+  sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+  PubSubMessageHandlerCallback* cb = new PubSubMessageHandlerCallback(topic, sid);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  sub.startDelivery(topic, sid, handler);\n+  ASSERT_THROW(sub.startDelivery(topic, sid, handler),\n+               Hedwig::AlreadyStartDeliveryException);\n+}\n+\n+TEST(PubSubTest, testStopDeliveryWithoutSub) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  ASSERT_THROW(sub.stopDelivery(\"testStopDeliveryWithoutSub\", \"mysub\"),\n+               Hedwig::NotSubscribedException);\n+}\n+\n+TEST(PubSubTest, testStopDeliveryTwice) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+\n+  std::string topic = \"testStopDeliveryTwice\";\n+  std::string subid = \"mysub\";\n+\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+  // it is ok to stop delivery without start delivery\n+  sub.stopDelivery(topic, subid);\n+\n+  PubSubMessageHandlerCallback* cb = new PubSubMessageHandlerCallback(topic, subid);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  sub.startDelivery(topic, subid, handler);\n+  sub.stopDelivery(topic, subid);\n+  // stop again\n+  sub.stopDelivery(topic, subid);\n+}\n+\n+// test startDelivery / stopDelivery in msg handler\n+TEST(PubSubTest, testStartStopDeliveryInMsgHandler) {\n+  std::string topic(\"startStopDeliveryInMsgHandler\");\n+  std::string subscriber(\"mysubid\");\n+\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  // subscribe topic\n+  sub.subscribe(topic, subscriber, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+  int numMsgs = 5;\n+\n+  for (int i=0; i<numMsgs; i++) {\n+    std::stringstream oss;\n+    oss << i;\n+    pub.publish(topic, oss.str());\n+  }\n+\n+  // sleep for a while to wait all messages are sent to subscribe and queue them\n+  sleep(1);\n+\n+  StartStopDeliveryMsgHandler* cb = new StartStopDeliveryMsgHandler(sub, 0);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  sub.startDelivery(topic, subscriber, handler);\n+\n+  for (int i=0 ; i<10; i++) {\n+    if (cb->getNextValue() == numMsgs) {\n+      break;\n+    } else {\n+      sleep(1);\n+    }\n+  }\n+  ASSERT_TRUE(cb->getNextValue() == numMsgs);\n+\n+  sub.stopDelivery(topic, subscriber);\n+  sub.closeSubscription(topic, subscriber);\n+}\n+\n // test startDelivery / stopDelivery randomly\n TEST(PubSubTest, testRandomDelivery) {\n    std::string topic = \"randomDeliveryTopic\";"},{"sha":"d87abea0888d71b5d4a19e97dc70c398f8c29e9a","filename":"hedwig-client/src/main/cpp/test/subscribetest.cpp","status":"modified","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/subscribetest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/subscribetest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/subscribetest.cpp?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -151,6 +151,40 @@ TEST(SubscribeTest, testUnsubscribeWithoutSubscribe) {\n   ASSERT_THROW(sub.unsubscribe(\"testTopic\", \"mySubscriberId-7\"), Hedwig::NotSubscribedException);\n }\n \n+TEST(SubscribeTest, testAsyncSubscribeTwice) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+\n+  SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n+  SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond2ptr(cond2);\n+  \n+  Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+  Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n+\n+  std::string topic(\"testAsyncSubscribeTwice\");\n+  std::string subid(\"mysubid\");\n+\n+  sub.asyncSubscribe(topic, subid,\n+                     Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n+  sub.asyncSubscribe(topic, subid,\n+                     Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb2);\n+  cond1->wait();\n+  cond2->wait();\n+\n+  if (cond1->wasSuccess()) {\n+    ASSERT_TRUE(!cond2->wasSuccess());\n+  } else {\n+    ASSERT_TRUE(cond2->wasSuccess());\n+  }\n+}\n+\n TEST(SubscribeTest, testSubscribeTwice) {\n   Hedwig::Configuration* conf = new TestServerConfiguration();\n   std::auto_ptr<Hedwig::Configuration> confptr(conf);"},{"sha":"60717e91e73f4c3e5591b09d7113a1adebb037e8","filename":"hedwig-client/src/main/cpp/test/util.h","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","patch":"@@ -116,12 +116,15 @@ class TestCallback : public Hedwig::OperationCallback {\n class TestSubscriptionListener : public Hedwig::SubscriptionListener {\n public:\n   TestSubscriptionListener(SimpleWaitCondition* cond) : cond(cond) {\n+    LOG4CXX_DEBUG(utillogger, \"Created TestSubscriptionListener \" << this);\n   }\n \n   virtual ~TestSubscriptionListener() {}\n \n   virtual void processEvent(const std::string& topic, const std::string& subscriberId,\n                             const Hedwig::SubscriptionEvent event) {\n+    LOG4CXX_DEBUG(utillogger, \"Received event \" << event << \" for (topic:\" << topic\n+                              << \", subscriber:\" << subscriberId << \") from listener \" << this);\n     if (Hedwig::TOPIC_MOVED == event) {\n       if (cond) {\n         cond->setSuccess(true);"}]}

