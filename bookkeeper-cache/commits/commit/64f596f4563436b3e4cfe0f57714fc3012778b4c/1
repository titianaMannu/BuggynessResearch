{"sha":"64f596f4563436b3e4cfe0f57714fc3012778b4c","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2NGY1OTZmNDU2MzQzNmIzZTRjZmUwZjU3NzE0ZmMzMDEyNzc4YjRj","commit":{"author":{"name":"Andrey Yegorov","email":"ayegorov@salesforce.com","date":"2016-08-01T06:04:09Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-08-01T06:04:09Z"},"message":"BOOKKEEPER-938 ledger digestType autodetection on open\n\nCurrently digestType verification in LedgerOpenOp seems to be treated as part of security logic.\nSince it is checked after password and error explicitly states that digestType mismatched,\nall that evil hacker has to do is to change digest type to another one. There are only two of them after all.\n\nhere is the scenario significantly affected by current behavior:\n\n1. user rolls out clients with digestType set to MAC and creates lots of ledgers.\n2. user notices that MAC is slower than CRC32 and decides to change digestType.\n3. more ledgers created with CRC32.\n4. user tries to read old and new ledgers\n-> now old ledgers cannot be read because of the digest type mismatch.\n\nAuthor: Andrey Yegorov <ayegorov@salesforce.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #52 from dlg99/fix/BOOKKEEPER-938-digest-autodetect","tree":{"sha":"13c72b0dd1a7701f57ce84b339cb6cd9571cde9a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/13c72b0dd1a7701f57ce84b339cb6cd9571cde9a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/64f596f4563436b3e4cfe0f57714fc3012778b4c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/64f596f4563436b3e4cfe0f57714fc3012778b4c","html_url":"https://github.com/apache/bookkeeper/commit/64f596f4563436b3e4cfe0f57714fc3012778b4c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/64f596f4563436b3e4cfe0f57714fc3012778b4c/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"c43858b5095318b50f4c7f86fc33b0a9e454bee5","url":"https://api.github.com/repos/apache/bookkeeper/commits/c43858b5095318b50f4c7f86fc33b0a9e454bee5","html_url":"https://github.com/apache/bookkeeper/commit/c43858b5095318b50f4c7f86fc33b0a9e454bee5"}],"stats":{"total":245,"additions":238,"deletions":7},"files":[{"sha":"6cf2721c88bed1042068a1168dcc84be83e0203f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":12,"deletions":7,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/64f596f4563436b3e4cfe0f57714fc3012778b4c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/64f596f4563436b3e4cfe0f57714fc3012778b4c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=64f596f4563436b3e4cfe0f57714fc3012778b4c","patch":"@@ -48,18 +48,20 @@\n     final Object ctx;\n     LedgerHandle lh;\n     final byte[] passwd;\n-    final DigestType digestType;\n     boolean doRecovery = true;\n     boolean administrativeOpen = false;\n     long startTime;\n     OpStatsLogger openOpLogger;\n+    \n+    final DigestType suggestedDigestType;\n+    final boolean enableDigestAutodetection;\n \n     /**\n      * Constructor.\n      *\n      * @param bk\n      * @param ledgerId\n-     * @param digestType\n+     * @param digestType. Ignored if conf.getEnableDigestTypeAutodetection() is true\n      * @param passwd\n      * @param cb\n      * @param ctx\n@@ -71,7 +73,8 @@ public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[]\n         this.passwd = passwd;\n         this.cb = cb;\n         this.ctx = ctx;\n-        this.digestType = digestType;\n+        this.enableDigestAutodetection = bk.conf.getEnableDigestTypeAutodetection();\n+        this.suggestedDigestType = digestType;\n     }\n \n     public LedgerOpenOp(BookKeeper bk, long ledgerId, OpenCallback cb, Object ctx) {\n@@ -81,8 +84,9 @@ public LedgerOpenOp(BookKeeper bk, long ledgerId, OpenCallback cb, Object ctx) {\n         this.ctx = ctx;\n \n         this.passwd = bk.getConf().getBookieRecoveryPasswd();\n-        this.digestType = bk.getConf().getBookieRecoveryDigestType();\n         this.administrativeOpen = true;\n+        this.enableDigestAutodetection = false;\n+        this.suggestedDigestType = bk.conf.getBookieRecoveryDigestType();\n     }\n \n     /**\n@@ -119,8 +123,10 @@ public void operationComplete(int rc, LedgerMetadata metadata) {\n         }\n \n         final byte[] passwd;\n-        final DigestType digestType;\n-\n+        DigestType digestType = enableDigestAutodetection \n+                                    ? metadata.getDigestType() \n+                                    : suggestedDigestType;\n+\t\t\t\t\t\t\t\t\t\t\n         /* For an administrative open, the default passwords\n          * are read from the configuration, but if the metadata\n          * already contains passwords, use these instead. */\n@@ -129,7 +135,6 @@ public void operationComplete(int rc, LedgerMetadata metadata) {\n             digestType = metadata.getDigestType();\n         } else {\n             passwd = this.passwd;\n-            digestType = this.digestType;\n \n             if (metadata.hasPassword()) {\n                 if (!Arrays.equals(passwd, metadata.getPassword())) {"},{"sha":"57c3790b3e6a12a5227346977d910db1ab6ed206","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/64f596f4563436b3e4cfe0f57714fc3012778b4c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/64f596f4563436b3e4cfe0f57714fc3012778b4c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=64f596f4563436b3e4cfe0f57714fc3012778b4c","patch":"@@ -43,6 +43,8 @@\n \n     // Digest Type\n     protected final static String DIGEST_TYPE = \"digestType\";\n+    protected final static String ENABLE_DIGEST_TYPE_AUTODETECTION = \"enableDigestTypeAutodetection\";\n+\n     // Passwd\n     protected final static String PASSWD = \"passwd\";\n \n@@ -131,6 +133,29 @@ public ClientConfiguration setThrottleValue(int throttle) {\n         return this;\n     }\n \n+    /**\n+     * Get autodetection of digest type.\n+     * Ignores provided digestType, if enabled and uses one from ledger metadata instead.\n+     * Incompatible with ledger created by bookie versions < 4.2\n+     *\n+     * @return flag to enable/disable autodetection of digest type.\n+     */\n+    public boolean getEnableDigestTypeAutodetection() {\n+        return getBoolean(ENABLE_DIGEST_TYPE_AUTODETECTION, false);\n+    }\n+\n+    /**\n+     * Enable autodetection of digest type.\n+     * Ignores provided digestType, if enabled and uses one from ledger metadata instead.\n+     * Incompatible with ledger created by bookie versions < 4.2\n+     *\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setEnableDigestTypeAutodetection(boolean enable) {\n+        this.setProperty(ENABLE_DIGEST_TYPE_AUTODETECTION, enable);\n+        return this;\n+    }\n+    \n     /**\n      * Get digest type used in bookkeeper admin\n      *"},{"sha":"3b28db06c0643f7519a4cfedfbbcc7ee3743553a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgersWithDifferentDigestsTest.java","status":"added","additions":201,"deletions":0,"changes":201,"blob_url":"https://github.com/apache/bookkeeper/blob/64f596f4563436b3e4cfe0f57714fc3012778b4c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgersWithDifferentDigestsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/64f596f4563436b3e4cfe0f57714fc3012778b4c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgersWithDifferentDigestsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgersWithDifferentDigestsTest.java?ref=64f596f4563436b3e4cfe0f57714fc3012778b4c","patch":"@@ -0,0 +1,201 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Random;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Verify reads from ledgers with different digest types.\n+ * This can happen as result of clients using different settings\n+ * yet reading each other data or configuration change roll out.\n+ */\n+public class BookieWriteLedgersWithDifferentDigestsTest extends\n+        MultiLedgerManagerMultiDigestTestCase implements AddCallback {\n+\n+    private final static Logger LOG = LoggerFactory\n+            .getLogger(BookieWriteLedgersWithDifferentDigestsTest.class);\n+\n+    byte[] ledgerPassword = \"aaa\".getBytes();\n+    LedgerHandle lh, lh2;\n+    Enumeration<LedgerEntry> ls;\n+\n+    // test related variables\n+    final int numEntriesToWrite = 20;\n+    int maxInt = Integer.MAX_VALUE;\n+    Random rng;\n+    ArrayList<byte[]> entries1; // generated entries\n+    ArrayList<byte[]> entries2; // generated entries\n+\n+    DigestType digestType;\n+\n+    private static class SyncObj {\n+        volatile int counter;\n+        volatile int rc;\n+\n+        public SyncObj() {\n+            counter = 0;\n+        }\n+    }\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+        // Number Generator\n+        entries1 = new ArrayList<byte[]>(); // initialize the entries list\n+        entries2 = new ArrayList<byte[]>(); // initialize the entries list\n+    }\n+\n+    public BookieWriteLedgersWithDifferentDigestsTest(String ledgerManagerFactory,\n+            DigestType digestType) {\n+        super(3);\n+        this.digestType = digestType;\n+        // set ledger manager\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testLedgersWithDifferentDigestTypesNoAutodetection() throws Exception {\n+    \tbkc.conf.setEnableDigestTypeAutodetection(false);\n+        // Create ledgers\n+        lh = bkc.createLedgerAdv(3, 2, 2, DigestType.MAC, ledgerPassword);\n+        \n+        final long id = lh.ledgerId;\n+\n+        LOG.info(\"Ledger ID-1: \" + lh.getId());\n+        SyncObj syncObj1 = new SyncObj();\n+        for (int i = numEntriesToWrite - 1; i >= 0; i--) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            entries1.add(0, entry.array());\n+            lh.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj1);\n+        }\n+\n+        // Wait for all entries to be acknowledged\n+        waitForEntriesAddition(syncObj1, numEntriesToWrite);\n+\n+        // Reads here work ok because ledger uses digest type set during create\n+        readEntries(lh, entries1);\n+        lh.close();\n+        \n+        try {\n+\t        bkc.openLedgerNoRecovery(id, DigestType.CRC32, ledgerPassword).close();\n+\t        fail(\"digest mismatch error is expected\");\n+        } catch (BKException bke) {\n+        \t// expected\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testLedgersWithDifferentDigestTypesWithAutodetection() throws Exception {\n+    \tbkc.conf.setEnableDigestTypeAutodetection(true);\n+        // Create ledgers\n+        lh = bkc.createLedgerAdv(3, 2, 2, DigestType.MAC, ledgerPassword);\n+        lh2 = bkc.createLedgerAdv(3, 2, 2, DigestType.CRC32, ledgerPassword);\n+        \n+        final long id = lh.ledgerId;\n+        final long id2 = lh2.ledgerId;\n+\n+        LOG.info(\"Ledger ID-1: \" + lh.getId());\n+        LOG.info(\"Ledger ID-2: \" + lh2.getId());\n+        SyncObj syncObj1 = new SyncObj();\n+        SyncObj syncObj2 = new SyncObj();\n+        for (int i = numEntriesToWrite - 1; i >= 0; i--) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            entries1.add(0, entry.array());\n+            entries2.add(0, entry.array());\n+            lh.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj1);\n+            lh2.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj2);\n+        }\n+\n+        // Wait for all entries to be acknowledged\n+        waitForEntriesAddition(syncObj1, numEntriesToWrite);\n+        waitForEntriesAddition(syncObj2, numEntriesToWrite);\n+\n+        // Reads here work ok because ledger uses digest type set during create\n+        readEntries(lh, entries1);\n+        readEntries(lh2, entries2);\n+        lh.close();\n+        lh2.close();\n+        \n+        // open here would fail if provided digest type is used\n+        // it passes because ledger just uses digest type from its metadata/autodetects it\n+        lh = bkc.openLedgerNoRecovery(id, DigestType.CRC32, ledgerPassword);\n+        lh2 = bkc.openLedgerNoRecovery(id2, DigestType.MAC, ledgerPassword);\n+        readEntries(lh, entries1);\n+        readEntries(lh2, entries2);\n+        lh.close();\n+        lh2.close();\n+    }\n+    \n+\tprivate void waitForEntriesAddition(SyncObj syncObj, int numEntriesToWrite) throws InterruptedException {\n+\t\tsynchronized (syncObj) {\n+            while (syncObj.counter < numEntriesToWrite) {\n+                syncObj.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj.rc);\n+        }\n+\t}\n+\n+    private void readEntries(LedgerHandle lh, ArrayList<byte[]> entries) throws InterruptedException, BKException {\n+        ls = lh.readEntries(0, numEntriesToWrite - 1);\n+        int index = 0;\n+        while (ls.hasMoreElements()) {\n+            ByteBuffer origbb = ByteBuffer.wrap(entries.get(index++));\n+            Integer origEntry = origbb.getInt();\n+            ByteBuffer result = ByteBuffer.wrap(ls.nextElement().getEntry());\n+            LOG.debug(\"Length of result: \" + result.capacity());\n+            LOG.debug(\"Original entry: \" + origEntry);\n+            Integer retrEntry = result.getInt();\n+            LOG.debug(\"Retrieved entry: \" + retrEntry);\n+            assertTrue(\"Checking entry \" + index + \" for equality\", origEntry\n+                    .equals(retrEntry));\n+        }\n+    }\n+\n+    @Override\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        SyncObj x = (SyncObj) ctx;\n+        synchronized (x) {\n+            x.rc = rc;\n+            x.counter++;\n+            x.notify();\n+        }\n+    }\n+}"}]}

