{"sha":"653dd6d733e9022a6189a2c8546bb8e3afa22715","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2NTNkZDZkNzMzZTkwMjJhNjE4OWEyYzg1NDZiYjhlM2FmYTIyNzE1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-02-21T18:01:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-02-21T18:01:17Z"},"message":"BOOKKEEPER-654: Bookkeeper client operations are allowed even after its closure, bk#close() (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1570647 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4cdc5225d81aafa5d3ccceffb1d14590b5a873c2","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4cdc5225d81aafa5d3ccceffb1d14590b5a873c2"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/653dd6d733e9022a6189a2c8546bb8e3afa22715","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/653dd6d733e9022a6189a2c8546bb8e3afa22715","html_url":"https://github.com/apache/bookkeeper/commit/653dd6d733e9022a6189a2c8546bb8e3afa22715","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/653dd6d733e9022a6189a2c8546bb8e3afa22715/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f19744d30ed879022a66de885cb1236d54582d2b","url":"https://api.github.com/repos/apache/bookkeeper/commits/f19744d30ed879022a66de885cb1236d54582d2b","html_url":"https://github.com/apache/bookkeeper/commit/f19744d30ed879022a66de885cb1236d54582d2b"}],"stats":{"total":1494,"additions":1316,"deletions":178},"files":[{"sha":"2a6384517de2f4d6a02be5391f551f5e3111154a","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -166,6 +166,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-724: Shade introduces RAT error (sijie via fpj)\n \n+        BOOKKEEPER-654: Bookkeeper client operations are allowed even after its closure, bk#close() (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"c5be32d543da38655f09cff31a15cfe124e73e4f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -90,6 +90,8 @@ public static BKException create(int code) {\n             return new BKWriteOnReadOnlyBookieException();\n         case Code.ReplicationException:\n             return new BKReplicationException();\n+        case Code.ClientClosedException:\n+            return new BKClientClosedException();\n         case Code.IllegalOpException:\n             return new BKIllegalOpException();\n         default:\n@@ -121,6 +123,7 @@ public static BKException create(int code) {\n         int ProtocolVersionException = -16;\n         int MetadataVersionException = -17;\n         int MetaStoreException = -18;\n+        int ClientClosedException = -19;\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n@@ -193,6 +196,8 @@ public static String getMessage(int code) {\n             return \"Attempting to write on ReadOnly bookie\";\n         case Code.ReplicationException:\n             return \"Errors in replication pipeline\";\n+        case Code.ClientClosedException:\n+            return \"BookKeeper client is closed\";\n         case Code.IllegalOpException:\n             return \"Invalid operation\";\n         default:\n@@ -349,4 +354,11 @@ public BKReplicationException() {\n             super(Code.ReplicationException);\n         }\n     }\n+\n+    public static class BKClientClosedException extends BKException {\n+        public BKClientClosedException() {\n+            super(Code.ClientClosedException);\n+        }\n+    }\n+\n }"},{"sha":"49d8e5915d762dc2971d70dbf28517ffbe705e10","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":106,"deletions":45,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -25,13 +25,14 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.IsClosedCallback;\n-import org.apache.bookkeeper.client.BKException.Code;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.meta.CleanupLedgerManager;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.proto.BookieClient;\n@@ -71,8 +72,6 @@\n     static final Logger LOG = LoggerFactory.getLogger(BookKeeper.class);\n \n     final ZooKeeper zk;\n-    final CountDownLatch connectLatch = new CountDownLatch(1);\n-    final static int zkConnectTimeoutMs = 5000;\n     final ClientSocketChannelFactory channelFactory;\n \n     // The stats logger for this client.\n@@ -105,10 +104,9 @@\n \n     final ClientConfiguration conf;\n \n-    interface ZKConnectCallback {\n-        public void connected();\n-        public void connectionFailed(int code);\n-    }\n+    // Close State\n+    boolean closed = false;\n+    final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n \n     public static class Builder {\n         final ClientConfiguration conf;\n@@ -187,7 +185,7 @@ public BookKeeper(String servers) throws IOException, InterruptedException,\n \n     /**\n      * Create a bookkeeper client using a configuration object.\n-     * A zookeeper client and a client socket factory will be \n+     * A zookeeper client and a client socket factory will be\n      * instantiated as part of this constructor.\n      *\n      * @param conf\n@@ -222,7 +220,7 @@ public BookKeeper(final ClientConfiguration conf)\n         bookieWatcher.readBookiesBlocking();\n \n         ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n-        ledgerManager = ledgerManagerFactory.newLedgerManager();\n+        ledgerManager = new CleanupLedgerManager(ledgerManagerFactory.newLedgerManager());\n \n         ownChannelFactory = true;\n         ownZKHandle = true;\n@@ -308,7 +306,7 @@ private BookKeeper(ClientConfiguration conf, ZooKeeper zk,\n         bookieWatcher.readBookiesBlocking();\n \n         ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, zk);\n-        ledgerManager = ledgerManagerFactory.newLedgerManager();\n+        ledgerManager = new CleanupLedgerManager(ledgerManagerFactory.newLedgerManager());\n     }\n \n     private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf)\n@@ -321,6 +319,18 @@ private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfigur\n         }\n     }\n \n+    int getReturnRc(int rc) {\n+        if (BKException.Code.OK == rc) {\n+            return rc;\n+        } else {\n+            if (bookieClient.isClosed()) {\n+                return BKException.Code.ClientClosedException;\n+            } else {\n+                return rc;\n+            }\n+        }\n+    }\n+\n     LedgerManager getLedgerManager() {\n         return ledgerManager;\n     }\n@@ -334,7 +344,7 @@ LedgerManager getLedgerManager() {\n      */\n     public enum DigestType {\n         MAC, CRC32\n-    };\n+    }\n \n     ZooKeeper getZkHandle() {\n         return zk;\n@@ -427,9 +437,18 @@ public void asyncCreateLedger(final int ensSize,\n         if (writeQuorumSize < ackQuorumSize) {\n             throw new IllegalArgumentException(\"Write quorum must be larger than ack quorum\");\n         }\n-        new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize,\n-                           ackQuorumSize, digestType, passwd, cb, ctx)\n-            .initiate();\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.createComplete(BKException.Code.ClientClosedException, null, ctx);\n+                return;\n+            }\n+            new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize,\n+                               ackQuorumSize, digestType, passwd, cb, ctx)\n+                .initiate();\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n \n@@ -451,7 +470,7 @@ public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n \n     /**\n      * Synchronous call to create ledger. Parameters match those of\n-     * {@link #asyncCreateLedger(int, int, DigestType, byte[], \n+     * {@link #asyncCreateLedger(int, int, DigestType, byte[],\n      *                           AsyncCallback.CreateCallback, Object)}\n      *\n      * @param ensSize\n@@ -510,19 +529,19 @@ public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorum\n \n     /**\n      * Open existing ledger asynchronously for reading.\n-     * \n-     * Opening a ledger with this method invokes fencing and recovery on the ledger \n-     * if the ledger has not been closed. Fencing will block all other clients from \n-     * writing to the ledger. Recovery will make sure that the ledger is closed \n-     * before reading from it. \n      *\n-     * Recovery also makes sure that any entries which reached one bookie, but not a \n+     * Opening a ledger with this method invokes fencing and recovery on the ledger\n+     * if the ledger has not been closed. Fencing will block all other clients from\n+     * writing to the ledger. Recovery will make sure that the ledger is closed\n+     * before reading from it.\n+     *\n+     * Recovery also makes sure that any entries which reached one bookie, but not a\n      * quorum, will be replicated to a quorum of bookies. This occurs in cases were\n      * the writer of a ledger crashes after sending a write request to one bookie but\n-     * before being able to send it to the rest of the bookies in the quorum. \n+     * before being able to send it to the rest of the bookies in the quorum.\n      *\n      * If the ledger is already closed, neither fencing nor recovery will be applied.\n-     * \n+     *\n      * @see LedgerHandle#asyncClose\n      *\n      * @param lId\n@@ -536,7 +555,16 @@ public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorum\n      */\n     public void asyncOpenLedger(final long lId, final DigestType digestType, final byte passwd[],\n                                 final OpenCallback cb, final Object ctx) {\n-        new LedgerOpenOp(BookKeeper.this, lId, digestType, passwd, cb, ctx).initiate();\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.openComplete(BKException.Code.ClientClosedException, null, ctx);\n+                return;\n+            }\n+            new LedgerOpenOp(BookKeeper.this, lId, digestType, passwd, cb, ctx).initiate();\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n     /**\n@@ -546,14 +574,14 @@ public void asyncOpenLedger(final long lId, final DigestType digestType, final b\n      * unsealed forever if there is no external mechanism to detect the failure\n      * of the writer and the ledger is not open in a safe manner, invoking the\n      * recovery procedure.\n-     * \n+     *\n      * Opening a ledger without recovery does not fence the ledger. As such, other\n-     * clients can continue to write to the ledger. \n+     * clients can continue to write to the ledger.\n      *\n-     * This method returns a read only ledger handle. It will not be possible \n-     * to add entries to the ledger. Any attempt to add entries will throw an \n+     * This method returns a read only ledger handle. It will not be possible\n+     * to add entries to the ledger. Any attempt to add entries will throw an\n      * exception.\n-     * \n+     *\n      * Reads from the returned ledger will only be able to read entries up until\n      * the lastConfirmedEntry at the point in time at which the ledger was opened.\n      *\n@@ -568,7 +596,16 @@ public void asyncOpenLedger(final long lId, final DigestType digestType, final b\n      */\n     public void asyncOpenLedgerNoRecovery(final long lId, final DigestType digestType, final byte passwd[],\n                                           final OpenCallback cb, final Object ctx) {\n-        new LedgerOpenOp(BookKeeper.this, lId, digestType, passwd, cb, ctx).initiateWithoutRecovery();\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.openComplete(BKException.Code.ClientClosedException, null, ctx);\n+                return;\n+            }\n+            new LedgerOpenOp(BookKeeper.this, lId, digestType, passwd, cb, ctx).initiateWithoutRecovery();\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n \n@@ -654,7 +691,16 @@ public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte p\n      *            optional control object\n      */\n     public void asyncDeleteLedger(final long lId, final DeleteCallback cb, final Object ctx) {\n-        new LedgerDeleteOp(BookKeeper.this, lId, cb, ctx).initiate();\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.deleteComplete(BKException.Code.ClientClosedException, ctx);\n+                return;\n+            }\n+            new LedgerDeleteOp(BookKeeper.this, lId, cb, ctx).initiate();\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n \n@@ -680,11 +726,11 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n             throw BKException.create(counter.getrc());\n         }\n     }\n-    \n+\n     /**\n      * Check asynchronously whether the ledger with identifier <i>lId</i>\n      * has been closed.\n-     * \n+     *\n      * @param lId   ledger identifier\n      * @param cb    callback method\n      */\n@@ -699,11 +745,11 @@ public void operationComplete(int rc, LedgerMetadata lm){\n             }\n         });\n     }\n-    \n+\n     /**\n      * Check whether the ledger with identifier <i>lId</i>\n      * has been closed.\n-     * \n+     *\n      * @param lId\n      * @return boolean true if ledger has been closed\n      * @throws BKException\n@@ -730,16 +776,16 @@ public void isClosedComplete(int rc, boolean isClosed, Object ctx){\n          * Call asynchronous version of isClosed\n          */\n         asyncIsClosed(lId, cb, null);\n-        \n+\n         /*\n          * Wait for callback\n          */\n         result.notifier.await();\n-        \n+\n         if (result.rc != BKException.Code.OK) {\n             throw BKException.create(result.rc);\n         }\n-        \n+\n         return result.isClosed;\n     }\n \n@@ -748,23 +794,38 @@ public void isClosedComplete(int rc, boolean isClosed, Object ctx){\n      *\n      */\n     public void close() throws InterruptedException, BKException {\n-        scheduler.shutdown();\n-        if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {\n-            LOG.warn(\"The scheduler did not shutdown cleanly\");\n-        }\n-        mainWorkerPool.shutdown();\n-        if (!mainWorkerPool.awaitTermination(10, TimeUnit.SECONDS)) {\n-            LOG.warn(\"The mainWorkerPool did not shutdown cleanly\");\n+        closeLock.writeLock().lock();\n+        try {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        } finally {\n+            closeLock.writeLock().unlock();\n         }\n \n+        // Close bookie client so all pending bookie requests would be failed\n+        // which will reject any incoming bookie requests.\n         bookieClient.close();\n         try {\n+            // Close ledger manage so all pending metadata requests would be failed\n+            // which will reject any incoming metadata requests.\n             ledgerManager.close();\n             ledgerManagerFactory.uninitialize();\n         } catch (IOException ie) {\n             LOG.error(\"Failed to close ledger manager : \", ie);\n         }\n \n+        // Close the scheduler\n+        scheduler.shutdown();\n+        if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {\n+            LOG.warn(\"The scheduler did not shutdown cleanly\");\n+        }\n+        mainWorkerPool.shutdown();\n+        if (!mainWorkerPool.awaitTermination(10, TimeUnit.SECONDS)) {\n+            LOG.warn(\"The mainWorkerPool did not shutdown cleanly\");\n+        }\n+\n         if (ownChannelFactory) {\n             channelFactory.releaseExternalResources();\n         }"},{"sha":"26e87587bcbb438792fc5c62754b0e6171ff41c9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -468,7 +468,7 @@ private void getActiveLedgers(final BookieSocketAddress bookieSrc, final BookieS\n \n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n-                cb.recoverComplete(rc, ctx);\n+                cb.recoverComplete(bkc.getReturnRc(rc), ctx);\n             }\n         }\n \n@@ -708,7 +708,7 @@ public void replicateLedgerFragment(LedgerHandle lh,\n         asyncRecoverLedgerFragment(lh, ledgerFragment, cb, targetBookieAddress);\n         syncCounter.block(0);\n         if (syncCounter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(syncCounter.getrc());\n+            throw BKException.create(bkc.getReturnRc(syncCounter.getrc()));\n         }\n     }\n "},{"sha":"204f0dc8c19307efd5c7996a2f7da628c22225bc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n@@ -143,7 +144,11 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n         if (rc != KeeperException.Code.OK.intValue()) {\n             //logger.error(\"Error while reading bookies\", KeeperException.create(Code.get(rc), path));\n             // try the read after a second again\n-            scheduler.schedule(reReadTask, ZK_CONNECT_BACKOFF_SEC, TimeUnit.SECONDS);\n+            try {\n+                scheduler.schedule(reReadTask, ZK_CONNECT_BACKOFF_SEC, TimeUnit.SECONDS);\n+            } catch (RejectedExecutionException ree) {\n+                logger.warn(\"Failed to schedule reading bookies task : \", ree);\n+            }\n             return;\n         }\n "},{"sha":"28e23d66d6c3d1770ee7c5328f748662c87964b0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -156,7 +156,10 @@ public void readEntryComplete(int rc, long ledgerId, long entryId,\n         }\n \n         public void operationComplete(int rc, LedgerFragment result) {\n-            if (rc != BKException.Code.OK) {\n+            if (rc == BKException.Code.ClientClosedException) {\n+                cb.operationComplete(BKException.Code.ClientClosedException, badFragments);\n+                return;\n+            } else if (rc != BKException.Code.OK) {\n                 badFragments.add(result);\n             }\n             if (numFragments.decrementAndGet() == 0) {"},{"sha":"4501524ae849472ae8405afdbc940f4ad0341a89","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -247,7 +247,7 @@ private void recoverLedgerFragmentEntry(final Long entryId,\n             @Override\n             public void readComplete(int rc, LedgerHandle lh,\n                     Enumeration<LedgerEntry> seq, Object ctx) {\n-                if (rc != Code.OK.intValue()) {\n+                if (rc != BKException.Code.OK) {\n                     LOG.error(\"BK error reading ledger entry: \" + entryId,\n                             BKException.create(rc));\n                     ledgerFragmentEntryMcb.processResult(rc, null, null);\n@@ -270,7 +270,7 @@ public void readComplete(int rc, LedgerHandle lh,\n                             public void writeComplete(int rc, long ledgerId,\n                                     long entryId, BookieSocketAddress addr,\n                                     Object ctx) {\n-                                if (rc != Code.OK.intValue()) {\n+                                if (rc != BKException.Code.OK) {\n                                     LOG.error(\n                                             \"BK error writing entry for ledgerId: \"\n                                                     + ledgerId + \", entryId: \"\n@@ -322,7 +322,7 @@ public void writeComplete(int rc, long ledgerId,\n \n         @Override\n         public void processResult(int rc, String path, Object ctx) {\n-            if (rc != Code.OK.intValue()) {\n+            if (rc != BKException.Code.OK) {\n                 LOG.error(\"BK error replicating ledger fragments for ledger: \"\n                         + lh.getId(), BKException.create(rc));\n                 ledgerFragmentsMcb.processResult(rc, null, null);"},{"sha":"e9cf911ea56a5e076aa694f7c0cf95d1e648eab3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":19,"deletions":7,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -28,6 +28,7 @@\n import java.util.Enumeration;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n@@ -239,12 +240,23 @@ public void close()\n      *          callback implementation\n      * @param ctx\n      *          control object\n-     * @throws InterruptedException\n      */\n     public void asyncClose(CloseCallback cb, Object ctx) {\n         asyncCloseInternal(cb, ctx, BKException.Code.LedgerClosedException);\n     }\n \n+    void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {\n+        try {\n+            doAsyncCloseInternal(cb, ctx, rc);\n+        } catch (RejectedExecutionException re) {\n+            LOG.debug(\"Failed to close ledger {} : \", ledgerId, re);\n+            synchronized (this) {\n+                errorOutPendingAdds(bk.getReturnRc(rc));\n+            }\n+            cb.closeComplete(bk.getReturnRc(BKException.Code.InterruptedException), this, ctx);\n+        }\n+    }\n+\n     /**\n      * Same as public version of asyncClose except that this one takes an\n      * additional parameter which is the return code to hand to all the pending\n@@ -254,7 +266,7 @@ public void asyncClose(CloseCallback cb, Object ctx) {\n      * @param ctx\n      * @param rc\n      */\n-    void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {\n+    void doAsyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {\n         bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n@@ -276,9 +288,9 @@ public void safeRun() {\n                     // error out pending adds first\n                     errorOutPendingAdds(rc);\n \n-                    // synchronized on LedgerHandle.this to ensure that \n-                    // lastAddPushed can not be updated after the metadata \n-                    // is closed. \n+                    // synchronized on LedgerHandle.this to ensure that\n+                    // lastAddPushed can not be updated after the metadata\n+                    // is closed.\n                     metadata.setLength(length);\n                     metadata.close(lastAddConfirmed);\n                     lastAddPushed = lastAddConfirmed;\n@@ -529,8 +541,8 @@ public void safeRun() {\n                     op.initiate(toSend, length);\n                 }\n             });\n-        } catch (RuntimeException e) {\n-            cb.addComplete(BKException.Code.InterruptedException,\n+        } catch (RejectedExecutionException e) {\n+            cb.addComplete(bk.getReturnRc(BKException.Code.InterruptedException),\n                     LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n         }\n     }"},{"sha":"4df89ea24bf3604d6aa113c73c53ca4e01944d27","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -173,7 +173,7 @@ public void safeOperationComplete(int rc, Void result) {\n                     } else if (rc == BKException.Code.UnauthorizedAccessException) {\n                         openComplete(BKException.Code.UnauthorizedAccessException, null);\n                     } else {\n-                        openComplete(BKException.Code.LedgerRecoveryException, null);\n+                        openComplete(bk.getReturnRc(BKException.Code.LedgerRecoveryException), null);\n                     }\n                 }\n             });\n@@ -183,7 +183,7 @@ public void safeOperationComplete(int rc, Void result) {\n                 public void readLastConfirmedComplete(int rc,\n                         long lastConfirmed, Object ctx) {\n                     if (rc != BKException.Code.OK) {\n-                        openComplete(BKException.Code.ReadException, null);\n+                        openComplete(bk.getReturnRc(BKException.Code.ReadException), null);\n                     } else {\n                         lh.lastAddConfirmed = lh.lastAddPushed = lastConfirmed;\n                         openComplete(BKException.Code.OK, lh);"},{"sha":"1b92d093792b56ae7ebb55c7f3debf8b6cd61055","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -152,6 +152,10 @@ public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddre\n         case BKException.Code.OK:\n             // continue\n             break;\n+        case BKException.Code.ClientClosedException:\n+            // bookie client is closed.\n+            lh.errorOutPendingAdds(rc);\n+            return;\n         case BKException.Code.LedgerFencedException:\n             LOG.warn(\"Fencing exception on write: L{} E{} on {}\",\n                      new Object[] { ledgerId, entryId, addr });"},{"sha":"fb36b909e92338c8f57c88b9c43b306e96fd4a0c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":26,"deletions":19,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -29,6 +29,7 @@\n import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n@@ -284,28 +285,34 @@ public void initiate() throws InterruptedException {\n         ArrayList<BookieSocketAddress> ensemble = null;\n \n         if (speculativeReadTimeout > 0) {\n-            speculativeTask = scheduler.scheduleWithFixedDelay(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        int x = 0;\n-                        for (LedgerEntryRequest r : seq) {\n-                            if (!r.isComplete()) {\n-                                if (null == r.maybeSendSpeculativeRead(heardFromHosts)) {\n-                                    // Subsequent speculative read will not materialize anyway\n-                                    cancelSpeculativeTask(false);\n-                                } else {\n-                                    LOG.debug(\"Send speculative read for {}. Hosts heard are {}.\",\n-                                              r, heardFromHosts);\n-                                    ++x;\n-                                }\n+            Runnable readTask = new Runnable() {\n+                public void run() {\n+                    int x = 0;\n+                    for (LedgerEntryRequest r : seq) {\n+                        if (!r.isComplete()) {\n+                            if (null == r.maybeSendSpeculativeRead(heardFromHosts)) {\n+                                // Subsequent speculative read will not materialize anyway\n+                                cancelSpeculativeTask(false);\n+                            } else {\n+                                LOG.debug(\"Send speculative read for {}. Hosts heard are {}.\",\n+                                          r, heardFromHosts);\n+                                ++x;\n                             }\n                         }\n-                        if (x > 0) {\n-                            LOG.debug(\"Send {} speculative reads for ledger {} ({}, {}). Hosts heard are {}.\",\n-                                      new Object[] { x, lh.getId(), startEntryId, endEntryId, heardFromHosts });\n-                        }\n                     }\n-                }, speculativeReadTimeout, speculativeReadTimeout, TimeUnit.MILLISECONDS);\n+                    if (x > 0) {\n+                        LOG.debug(\"Send {} speculative reads for ledger {} ({}, {}). Hosts heard are {}.\",\n+                                  new Object[] { x, lh.getId(), startEntryId, endEntryId, heardFromHosts });\n+                    }\n+                }\n+            };\n+            try {\n+                speculativeTask = scheduler.scheduleWithFixedDelay(readTask,\n+                        speculativeReadTimeout, speculativeReadTimeout, TimeUnit.MILLISECONDS);\n+            } catch (RejectedExecutionException re) {\n+                LOG.debug(\"Failed to schedule speculative reads for ledger {} ({}, {}) : \",\n+                    new Object[] { lh.getId(), startEntryId, endEntryId, re });\n+            }\n         }\n \n         do {"},{"sha":"af21f442dba35d8761247d9766a6a1f7a38a89f0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -35,6 +35,7 @@\n     int numResponsesPending;\n     RecoveryData maxRecoveredData;\n     volatile boolean completed = false;\n+    int lastSeenError = BKException.Code.ReadException;\n \n     LastConfirmedDataCallback cb;\n     final DistributionSchedule.QuorumCoverageSet coverageSet;\n@@ -104,6 +105,11 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n             cb.readLastConfirmedDataComplete(rc, maxRecoveredData);\n             completed = true;\n         }\n+\n+        if (!heardValidResponse && BKException.Code.OK != rc) {\n+            lastSeenError = rc;\n+        }\n+\n         // other return codes dont count as valid responses\n         if (heardValidResponse\n             && coverageSet.addBookieAndCheckCovered(bookieIndex)\n@@ -119,7 +125,7 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n         if (numResponsesPending == 0 && !completed) {\n             // Have got all responses back but was still not enough, just fail the operation\n             LOG.error(\"While readLastConfirmed ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n-            cb.readLastConfirmedDataComplete(BKException.Code.LedgerRecoveryException, maxRecoveredData);\n+            cb.readLastConfirmedDataComplete(lastSeenError, maxRecoveredData);\n         }\n \n     }"},{"sha":"a8731124807ff59eab8566e91376e8d1a1937e7a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","status":"added","additions":226,"deletions":0,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -0,0 +1,226 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.LedgerMetadataListener;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.zookeeper.AsyncCallback;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class CleanupLedgerManager implements LedgerManager {\n+\n+    private class CleanupGenericCallback<T> implements GenericCallback<T> {\n+\n+        private final GenericCallback<T> cb;\n+\n+        CleanupGenericCallback(GenericCallback<T> cb) {\n+            this.cb = cb;\n+            addCallback(cb);\n+        }\n+\n+        @Override\n+        public void operationComplete(int rc, T result) {\n+            closeLock.readLock().lock();\n+            try {\n+                if (!closed && null != removeCallback(cb)) {\n+                    cb.operationComplete(rc, result);\n+                }\n+            } finally {\n+                closeLock.readLock().unlock();\n+            }\n+        }\n+    }\n+\n+    private static class ClosedLedgerRangeIterator implements LedgerRangeIterator {\n+\n+        @Override\n+        public boolean hasNext() throws IOException {\n+            throw new IOException(\"Ledger manager is closed.\");\n+        }\n+\n+        @Override\n+        public LedgerRange next() throws IOException {\n+            throw new IOException(\"Ledger manager is closed.\");\n+        }\n+    }\n+\n+    private final LedgerManager underlying;\n+    private final ConcurrentMap<GenericCallback, GenericCallback> callbacks =\n+        new ConcurrentHashMap<GenericCallback, GenericCallback>();\n+    private boolean closed = false;\n+    private final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n+\n+    public CleanupLedgerManager(LedgerManager lm) {\n+        this.underlying = lm;\n+    }\n+\n+    private void addCallback(GenericCallback callback) {\n+        callbacks.put(callback, callback);\n+    }\n+\n+    @Override\n+    public void registerLedgerMetadataListener(long ledgerId, LedgerMetadataListener listener) {\n+        underlying.registerLedgerMetadataListener(ledgerId, listener);\n+    }\n+\n+    @Override\n+    public void unregisterLedgerMetadataListener(long ledgerId, LedgerMetadataListener listener) {\n+        underlying.unregisterLedgerMetadataListener(ledgerId, listener);\n+    }\n+\n+    private GenericCallback removeCallback(GenericCallback callback) {\n+        return callbacks.remove(callback);\n+    }\n+\n+    @Override\n+    public void createLedger(LedgerMetadata metadata,\n+                             GenericCallback<Long> cb) {\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.operationComplete(BKException.Code.ClientClosedException, null);\n+                return;\n+            }\n+            underlying.createLedger(metadata, new CleanupGenericCallback<Long>(cb));\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void removeLedgerMetadata(long ledgerId, Version version,\n+                                     GenericCallback<Void> vb) {\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                vb.operationComplete(BKException.Code.ClientClosedException, null);\n+                return;\n+            }\n+            underlying.removeLedgerMetadata(ledgerId, version,\n+                    new CleanupGenericCallback<Void>(vb));\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void readLedgerMetadata(long ledgerId,\n+                                   GenericCallback<LedgerMetadata> readCb) {\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                readCb.operationComplete(BKException.Code.ClientClosedException, null);\n+                return;\n+            }\n+            underlying.readLedgerMetadata(ledgerId, new CleanupGenericCallback<LedgerMetadata>(readCb));\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void writeLedgerMetadata(long ledgerId, LedgerMetadata metadata,\n+                                    GenericCallback<Void> cb) {\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.operationComplete(BKException.Code.ClientClosedException, null);\n+                return;\n+            }\n+            underlying.writeLedgerMetadata(ledgerId, metadata,\n+                    new CleanupGenericCallback<Void>(cb));\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void asyncProcessLedgers(Processor<Long> processor,\n+                                    final AsyncCallback.VoidCallback finalCb, final Object context,\n+                                    final int successRc, final int failureRc) {\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                finalCb.processResult(failureRc, null, context);\n+                return;\n+            }\n+            final GenericCallback<Void> stub = new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(int rc, Void result) {\n+                    finalCb.processResult(failureRc, null, context);\n+                }\n+            };\n+            addCallback(stub);\n+            underlying.asyncProcessLedgers(processor, new AsyncCallback.VoidCallback() {\n+                @Override\n+                public void processResult(int rc, String path, Object ctx) {\n+                    if (null != removeCallback(stub)) {\n+                        finalCb.processResult(rc, path, ctx);\n+                    }\n+                }\n+            }, context, successRc, failureRc);\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public LedgerRangeIterator getLedgerRanges() {\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                return new ClosedLedgerRangeIterator();\n+            }\n+            return underlying.getLedgerRanges();\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void close() throws IOException {\n+        Set<GenericCallback> keys;\n+        closeLock.writeLock().lock();\n+        try {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            keys = new HashSet<GenericCallback>(callbacks.keySet());\n+        } finally {\n+            closeLock.writeLock().unlock();\n+        }\n+        for (GenericCallback key : keys) {\n+            GenericCallback callback = callbacks.remove(key);\n+            if (null != callback) {\n+                callback.operationComplete(BKException.Code.ClientClosedException, null);\n+            }\n+        }\n+    }\n+}"},{"sha":"29496083909ad307ca17a31dae08484a4b761f90","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":126,"deletions":74,"changes":200,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -27,6 +27,7 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -86,7 +87,19 @@ public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channel\n         this.statsLogger = statsLogger;\n     }\n \n-    public PerChannelBookieClient lookupClient(BookieSocketAddress addr) {\n+    private int getRc(int rc) {\n+        if (BKException.Code.OK == rc) {\n+            return rc;\n+        } else {\n+            if (closed) {\n+                return BKException.Code.ClientClosedException;\n+            } else {\n+                return rc;\n+            }\n+        }\n+    }\n+\n+    private PerChannelBookieClient lookupClient(BookieSocketAddress addr) {\n         PerChannelBookieClient channel = channels.get(addr);\n \n         if (channel == null) {\n@@ -110,52 +123,67 @@ public PerChannelBookieClient lookupClient(BookieSocketAddress addr) {\n     }\n \n     public void closeClients(Set<BookieSocketAddress> addrs) {\n-        final HashSet<PerChannelBookieClient> clients = new HashSet<PerChannelBookieClient>();\n-        for (BookieSocketAddress a : addrs) {\n-            PerChannelBookieClient c = channels.get(a);\n-            if (c != null) {\n-                clients.add(c);\n+        closeLock.readLock().lock();\n+        try {\n+            final HashSet<PerChannelBookieClient> clients = new HashSet<PerChannelBookieClient>();\n+            for (BookieSocketAddress a : addrs) {\n+                PerChannelBookieClient c = channels.get(a);\n+                if (c != null) {\n+                    clients.add(c);\n+                }\n             }\n-        }\n \n-        if (clients.size() == 0) {\n-            return;\n-        }\n-        executor.submit(new SafeRunnable() {\n-                @Override\n-                public void safeRun() {\n-                    for (PerChannelBookieClient c : clients) {\n-                        c.disconnect();\n+            if (clients.size() == 0) {\n+                return;\n+            }\n+            executor.submit(new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        for (PerChannelBookieClient c : clients) {\n+                            c.disconnect();\n+                        }\n                     }\n-                }\n-            });\n+                });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n     public void addEntry(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n             final long entryId,\n             final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n-        final PerChannelBookieClient client = lookupClient(addr);\n-        if (client == null) {\n-            cb.writeComplete(BKException.Code.BookieHandleNotAvailableException,\n-                             ledgerId, entryId, addr, ctx);\n-            return;\n-        }\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClient client = lookupClient(addr);\n+            if (client == null) {\n+                cb.writeComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n+                                 ledgerId, entryId, addr, ctx);\n+                return;\n+            }\n \n-        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n-            @Override\n-            public void operationComplete(final int rc, Void result) {\n-                if (rc != BKException.Code.OK) {\n-                    executor.submitOrdered(ledgerId, new SafeRunnable() {\n-                        @Override\n-                        public void safeRun() {\n-                            cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(final int rc, Void result) {\n+                    if (rc != BKException.Code.OK) {\n+                        try {\n+                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                                @Override\n+                                public void safeRun() {\n+                                    cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+                                }\n+                            });\n+                        } catch (RejectedExecutionException re) {\n+                            cb.writeComplete(getRc(BKException.Code.InterruptedException),\n+                                    ledgerId, entryId, addr, ctx);\n                         }\n-                    });\n-                    return;\n+                        return;\n+                    }\n+                    client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n                 }\n-                client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n-            }\n-        });\n+            });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n     public void readEntryAndFenceLedger(final BookieSocketAddress addr,\n@@ -164,54 +192,78 @@ public void readEntryAndFenceLedger(final BookieSocketAddress addr,\n                                         final long entryId,\n                                         final ReadEntryCallback cb,\n                                         final Object ctx) {\n-        final PerChannelBookieClient client = lookupClient(addr);\n-        if (client == null) {\n-            cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n-                                 ledgerId, entryId, null, ctx);\n-            return;\n-        }\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClient client = lookupClient(addr);\n+            if (client == null) {\n+                cb.readEntryComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n+                                     ledgerId, entryId, null, ctx);\n+                return;\n+            }\n \n-        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n-            @Override\n-            public void operationComplete(final int rc, Void result) {\n-                if (rc != BKException.Code.OK) {\n-                    executor.submitOrdered(ledgerId, new SafeRunnable() {\n-                        @Override\n-                        public void safeRun() {\n-                            cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(final int rc, Void result) {\n+                    if (rc != BKException.Code.OK) {\n+                        try {\n+                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                                @Override\n+                                public void safeRun() {\n+                                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                                }\n+                            });\n+                        } catch (RejectedExecutionException re) {\n+                            cb.readEntryComplete(getRc(BKException.Code.InterruptedException),\n+                                    ledgerId, entryId, null, ctx);\n                         }\n-                    });\n-                    return;\n+                        return;\n+                    }\n+                    client.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n                 }\n-                client.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n-            }\n-        });\n+            });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n     }\n \n     public void readEntry(final BookieSocketAddress addr, final long ledgerId, final long entryId,\n                           final ReadEntryCallback cb, final Object ctx) {\n-        final PerChannelBookieClient client = lookupClient(addr);\n-        if (client == null) {\n-            cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n-                                 ledgerId, entryId, null, ctx);\n-            return;\n-        }\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClient client = lookupClient(addr);\n+            if (client == null) {\n+                cb.readEntryComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n+                                     ledgerId, entryId, null, ctx);\n+                return;\n+            }\n \n-        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n-            @Override\n-            public void operationComplete(final int rc, Void result) {\n-                if (rc != BKException.Code.OK) {\n-                    executor.submitOrdered(ledgerId, new SafeRunnable() {\n-                        @Override\n-                        public void safeRun() {\n-                            cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(final int rc, Void result) {\n+                    if (rc != BKException.Code.OK) {\n+                        try {\n+                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                                @Override\n+                                public void safeRun() {\n+                                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                                }\n+                            });\n+                        } catch (RejectedExecutionException re) {\n+                            cb.readEntryComplete(getRc(BKException.Code.InterruptedException),\n+                                    ledgerId, entryId, null, ctx);\n                         }\n-                    });\n-                    return;\n+                        return;\n+                    }\n+                    client.readEntry(ledgerId, entryId, cb, ctx);\n                 }\n-                client.readEntry(ledgerId, entryId, cb, ctx);\n-            }\n-        });\n+            });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return closed;\n     }\n \n     public void close() {"},{"sha":"a10f7d5efd214d20496f6cfb1b97fefe6bcc52d7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":42,"deletions":10,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -25,6 +25,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n@@ -70,7 +71,6 @@\n \n     static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);\n \n-    static final long maxMemory = Runtime.getRuntime().maxMemory() / 5;\n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n \n     BookieSocketAddress addr;\n@@ -104,9 +104,10 @@ public void run() {\n \n     enum ConnectionState {\n         DISCONNECTED, CONNECTING, CONNECTED, CLOSED\n-    };\n+    }\n \n     volatile ConnectionState state;\n+    final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n     private final ClientConfiguration conf;\n \n     /**\n@@ -190,6 +191,19 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         }\n     }\n \n+    private void completeOperation(GenericCallback<Void> op, int rc) {\n+        closeLock.readLock().lock();\n+        try {\n+            if (ConnectionState.CLOSED == state) {\n+                op.operationComplete(BKException.Code.ClientClosedException, null);\n+            } else {\n+                op.operationComplete(rc, null);\n+            }\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n     private void connect() {\n         LOG.info(\"Connecting to bookie: {}\", addr);\n \n@@ -247,7 +261,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 }\n \n                 for (GenericCallback<Void> pendingOp : oldPendingOps) {\n-                    pendingOp.operationComplete(rc, null);\n+                    completeOperation(pendingOp, rc);\n                 }\n             }\n         });\n@@ -292,7 +306,7 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n         }\n \n         if (completeOpNow) {\n-            op.operationComplete(opRc, null);\n+            completeOperation(op, opRc);\n         }\n \n     }\n@@ -445,6 +459,16 @@ public void disconnect() {\n      * Closes the bookie client permanently. It cannot be reused.\n      */\n     public void close() {\n+        closeLock.writeLock().lock();\n+        try {\n+            if (ConnectionState.CLOSED == state) {\n+                return;\n+            }\n+            state = ConnectionState.CLOSED;\n+            errorOutOutstandingEntries(BKException.Code.ClientClosedException);\n+        } finally {\n+            closeLock.writeLock().unlock();\n+        }\n         closeInternal(true);\n     }\n \n@@ -474,6 +498,10 @@ private ChannelFuture closeChannel(Channel c) {\n     }\n \n     void errorOutReadKey(final CompletionKey key) {\n+        errorOutReadKey(key, BKException.Code.BookieHandleNotAvailableException);\n+    }\n+\n+    void errorOutReadKey(final CompletionKey key, final int rc) {\n         executor.submitOrdered(key.ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n@@ -490,7 +518,7 @@ public void safeRun() {\n                               + \" ledger-id: {} bookie: {}\",\n                               new Object[] { key.entryId, key.ledgerId, bAddress });\n \n-                    readCompletion.cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n+                    readCompletion.cb.readEntryComplete(rc,\n                                                         key.ledgerId, key.entryId, null, readCompletion.ctx);\n                 }\n             }\n@@ -499,6 +527,10 @@ public void safeRun() {\n     }\n \n     void errorOutAddKey(final CompletionKey key) {\n+        errorOutAddKey(key, BKException.Code.BookieHandleNotAvailableException);\n+    }\n+\n+    void errorOutAddKey(final CompletionKey key, final int rc) {\n         executor.submitOrdered(key.ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n@@ -514,7 +546,7 @@ public void safeRun() {\n                     LOG.debug(\"Could not write request for adding entry: {} ledger-id: {} bookie: {}\",\n                               new Object[] { key.entryId, key.ledgerId, bAddress });\n \n-                    addCompletion.cb.writeComplete(BKException.Code.BookieHandleNotAvailableException, key.ledgerId,\n+                    addCompletion.cb.writeComplete(rc, key.ledgerId,\n                                                    key.entryId, addr, addCompletion.ctx);\n                     LOG.debug(\"Invoked callback method: {}\", key.entryId);\n                 }\n@@ -531,7 +563,7 @@ public void safeRun() {\n      * here.\n      */\n \n-    void errorOutOutstandingEntries() {\n+    void errorOutOutstandingEntries(int rc) {\n \n         // DO NOT rewrite these using Map.Entry iterations. We want to iterate\n         // on keys and see if we are successfully able to remove the key from\n@@ -541,11 +573,11 @@ void errorOutOutstandingEntries() {\n         // calling the application callback.\n \n         for (CompletionKey key : addCompletions.keySet()) {\n-            errorOutAddKey(key);\n+            errorOutAddKey(key, rc);\n         }\n \n         for (CompletionKey key : readCompletions.keySet()) {\n-            errorOutReadKey(key);\n+            errorOutReadKey(key, rc);\n         }\n     }\n \n@@ -580,7 +612,7 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n             closeChannel(c);\n         }\n \n-        errorOutOutstandingEntries();\n+        errorOutOutstandingEntries(BKException.Code.BookieHandleNotAvailableException);\n \n         synchronized (this) {\n             if (this.channel == c"},{"sha":"597c88662b8e799ab4f2379f84d1a4dd62840a5d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":53,"deletions":13,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.util;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,17 +15,21 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.util;\n \n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.commons.lang.StringUtils;\n-\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * This class provides 2 things over the java {@link ScheduledExecutorService}.\n@@ -45,12 +47,13 @@\n  *\n  */\n public class OrderedSafeExecutor {\n-    ExecutorService threads[];\n-    Random rand = new Random();\n+    final ExecutorService threads[];\n+    final long threadIds[];\n+    final Random rand = new Random();\n \n     /**\n      * Constructs Safe executor\n-     * \n+     *\n      * @param numThreads\n      *            - number of threads\n      * @param threadName\n@@ -65,6 +68,7 @@ public OrderedSafeExecutor(int numThreads, String threadName) {\n             threadName = \"OrderedSafeExecutor\";\n         }\n         threads = new ExecutorService[numThreads];\n+        threadIds = new long[numThreads];\n         for (int i = 0; i < numThreads; i++) {\n             StringBuilder thName = new StringBuilder(threadName);\n             thName.append(\"-\");\n@@ -73,6 +77,19 @@ public OrderedSafeExecutor(int numThreads, String threadName) {\n             ThreadFactoryBuilder tfb = new ThreadFactoryBuilder()\n                     .setNameFormat(thName.toString());\n             threads[i] = Executors.newSingleThreadExecutor(tfb.build());\n+            final int tid = i;\n+            try {\n+                threads[i].submit(new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        threadIds[tid] = Thread.currentThread().getId();\n+                    }\n+                }).get();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Couldn't start thread \" + i, e);\n+            } catch (ExecutionException e) {\n+                throw new RuntimeException(\"Couldn't start thread \" + i, e);\n+            }\n         }\n     }\n \n@@ -112,6 +129,15 @@ public void submitOrdered(Object orderingKey, SafeRunnable r) {\n         chooseThread(orderingKey).submit(r);\n     }\n \n+    private long getThreadID(Object orderingKey) {\n+        // skip hashcode generation in this special case\n+        if (threadIds.length == 1) {\n+            return threadIds[0];\n+        }\n+\n+        return threadIds[MathUtils.signSafeMod(orderingKey.hashCode(), threadIds.length)];\n+    }\n+\n     public void shutdown() {\n         for (int i = 0; i < threads.length; i++) {\n             threads[i].shutdown();\n@@ -132,6 +158,8 @@ public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedE\n      */\n     public static abstract class OrderedSafeGenericCallback<T>\n             implements GenericCallback<T> {\n+        private final Logger LOG = LoggerFactory.getLogger(OrderedSafeGenericCallback.class);\n+\n         private final OrderedSafeExecutor executor;\n         private final Object orderingKey;\n \n@@ -147,12 +175,24 @@ public OrderedSafeGenericCallback(OrderedSafeExecutor executor, Object orderingK\n \n         @Override\n         public final void operationComplete(final int rc, final T result) {\n-            executor.submitOrdered(orderingKey, new SafeRunnable() {\n-                    @Override\n-                    public void safeRun() {\n-                        safeOperationComplete(rc, result);\n-                    }\n-                });\n+            // during closing, callbacks that are error out might try to submit to\n+            // the scheduler again. if the submission will go to same thread, we\n+            // don't need to submit to executor again. this is also an optimization for\n+            // callback submission\n+            if (Thread.currentThread().getId() == executor.getThreadID(orderingKey)) {\n+                safeOperationComplete(rc, result);\n+            } else {\n+                try {\n+                    executor.submitOrdered(orderingKey, new SafeRunnable() {\n+                            @Override\n+                            public void safeRun() {\n+                                safeOperationComplete(rc, result);\n+                            }\n+                        });\n+                } catch (RejectedExecutionException re) {\n+                    LOG.warn(\"Failed to submit callback for {} : \", orderingKey, re);\n+                }\n+            }\n         }\n \n         public abstract void safeOperationComplete(int rc, T result);"},{"sha":"ce4a2271626b10c326f6589ff9b200d0d166cd0e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","status":"added","additions":676,"deletions":0,"changes":676,"blob_url":"https://github.com/apache/bookkeeper/blob/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/653dd6d733e9022a6189a2c8546bb8e3afa22715/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperCloseTest.java?ref=653dd6d733e9022a6189a2c8546bb8e3afa22715","patch":"@@ -0,0 +1,676 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BKException.BKClientClosedException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Enumeration;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This unit test verifies the behavior of bookkeeper apis, where the operations\n+ * are being executed through a closed bookkeeper client\n+ */\n+public class BookKeeperCloseTest extends BookKeeperClusterTestCase {\n+\n+    // Depending on the taste, select the amount of logging\n+    // by decommenting one of the two lines below\n+    // static Logger LOG = Logger.getRootLogger();\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(BookKeeperCloseTest.class);\n+    private DigestType digestType = DigestType.CRC32;\n+    private static final String PASSWORD = \"testPasswd\";\n+\n+    public BookKeeperCloseTest() {\n+        super(3);\n+    }\n+\n+    private void restartBookieSlow() throws Exception{\n+        ServerConfiguration conf = killBookie(0);\n+\n+        Bookie delayBookie = new Bookie(conf) {\n+                @Override\n+                public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb,\n+                                             Object ctx, byte[] masterKey)\n+                        throws IOException, BookieException {\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException ie) {\n+                        // ignore, only interrupted if shutting down,\n+                        // and an exception would spam the logs\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    super.recoveryAddEntry(entry, cb, ctx, masterKey);\n+                }\n+\n+                @Override\n+                public void addEntry(ByteBuffer entry, WriteCallback cb,\n+                                     Object ctx, byte[] masterKey)\n+                        throws IOException, BookieException {\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException ie) {\n+                        // ignore, only interrupted if shutting down,\n+                        // and an exception would spam the logs\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    super.addEntry(entry, cb, ctx, masterKey);\n+                }\n+\n+                @Override\n+                public ByteBuffer readEntry(long ledgerId, long entryId)\n+                        throws IOException, NoLedgerException {\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException ie) {\n+                        // ignore, only interrupted if shutting down,\n+                        // and an exception would spam the logs\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    return super.readEntry(ledgerId, entryId);\n+                }\n+            };\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf, delayBookie));\n+    }\n+\n+    /**\n+     * Test that createledger using bookkeeper client which is closed should\n+     * throw ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testCreateLedger() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Closing bookkeeper client\");\n+        bk.close();\n+        try {\n+            bk.createLedger(digestType, PASSWORD.getBytes());\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        // using async, because this could trigger an assertion\n+        final AtomicInteger returnCode = new AtomicInteger(0);\n+        final CountDownLatch openLatch = new CountDownLatch(1);\n+        CreateCallback cb = new CreateCallback() {\n+            @Override\n+            public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n+                returnCode.set(rc);\n+                openLatch.countDown();\n+            }\n+        };\n+        bk.asyncCreateLedger(3, 2, digestType, PASSWORD.getBytes(), cb,\n+                             openLatch);\n+\n+        LOG.info(\"Waiting to finish the ledger creation\");\n+        // wait for creating the ledger\n+        assertTrue(\"create ledger call should have completed\",\n+                openLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\"Succesfully created ledger through closed bkclient!\",\n+                BKException.Code.ClientClosedException, returnCode.get());\n+    }\n+\n+    /**\n+     * Test that opening a ledger using bookkeeper client which is closed should\n+     * throw ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testFenceLedger() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 100);\n+        LOG.info(\"Closing bookkeeper client\");\n+\n+        restartBookieSlow();\n+\n+        // using async, because this could trigger an assertion\n+        final AtomicInteger preCloseReturnCode = new AtomicInteger(0);\n+        final CountDownLatch preCloseOpenLatch = new CountDownLatch(1);\n+        AsyncCallback.OpenCallback preCloseCb = new AsyncCallback.OpenCallback() {\n+            public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+                preCloseReturnCode.set(rc);\n+                preCloseOpenLatch.countDown();\n+            }\n+        };\n+        bk.asyncOpenLedger(lh.getId(), digestType, PASSWORD.getBytes(),\n+                           preCloseCb, null);\n+        bk.close();\n+\n+        LOG.info(\"Waiting to open the ledger asynchronously\");\n+        assertTrue(\"Open call should have completed\",\n+                   preCloseOpenLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\"Open should not have succeeded through closed bkclient!\",\n+                     BKException.Code.ClientClosedException, preCloseReturnCode.get());\n+\n+        try {\n+            bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        try {\n+            bk.openLedgerNoRecovery(lh.getId(), digestType, PASSWORD.getBytes());\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        final AtomicInteger returnCode = new AtomicInteger(0);\n+        final CountDownLatch openLatch = new CountDownLatch(1);\n+        AsyncCallback.OpenCallback cb = new AsyncCallback.OpenCallback() {\n+            public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+                returnCode.set(rc);\n+                openLatch.countDown();\n+            }\n+        };\n+        bk.asyncOpenLedger(lh.getId(), digestType, PASSWORD.getBytes(), cb,\n+                           openLatch);\n+\n+        LOG.info(\"Waiting to open the ledger asynchronously\");\n+        assertTrue(\"Open call should have completed\",\n+                openLatch.await(20, TimeUnit.SECONDS));\n+        assertTrue(\"Open should not have succeeded through closed bkclient!\",\n+                   BKException.Code.ClientClosedException == returnCode.get());\n+    }\n+\n+    /**\n+     * Test that deleting a ledger using bookkeeper client which is closed\n+     * should throw ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testDeleteLedger() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 100);\n+        LOG.info(\"Closing bookkeeper client\");\n+        bk.close();\n+        try {\n+            bk.deleteLedger(lh.getId());\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        // using async, because this could trigger an assertion\n+        final AtomicInteger returnCode = new AtomicInteger(0);\n+        final CountDownLatch openLatch = new CountDownLatch(1);\n+        AsyncCallback.DeleteCallback cb = new AsyncCallback.DeleteCallback() {\n+            public void deleteComplete(int rc, Object ctx) {\n+                returnCode.set(rc);\n+                openLatch.countDown();\n+            }\n+        };\n+        bk.asyncDeleteLedger(lh.getId(), cb, openLatch);\n+\n+        LOG.info(\"Waiting to delete the ledger asynchronously\");\n+        assertTrue(\"Delete call should have completed\",\n+                openLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\"Delete should not have succeeded through closed bkclient!\",\n+                     BKException.Code.ClientClosedException, returnCode.get());\n+    }\n+\n+    /**\n+     * Test that adding entry to a ledger using bookkeeper client which is\n+     * closed should throw ClientClosedException\n+     */\n+    @Test//(timeout = 60000)\n+    public void testAddLedgerEntry() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 1);\n+        LOG.info(\"Closing bookkeeper client\");\n+\n+        restartBookieSlow();\n+\n+        final CountDownLatch preCloseCompleteLatch = new CountDownLatch(1);\n+        final AtomicInteger preCloseRc = new AtomicInteger(BKException.Code.OK);\n+\n+        lh.asyncAddEntry(\"foobar\".getBytes(), new AddCallback() {\n+                public void addComplete(int rccb, LedgerHandle lh, long entryId,\n+                                        Object ctx) {\n+                    preCloseRc.set(rccb);\n+                    preCloseCompleteLatch.countDown();\n+                }\n+            }, null);\n+\n+        bk.close();\n+\n+        LOG.info(\"Waiting to finish adding another entry asynchronously\");\n+        assertTrue(\"Add entry to ledger call should have completed\",\n+                   preCloseCompleteLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"Add enrty to ledger should have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, preCloseRc.get());\n+\n+        try {\n+            lh.addEntry(\"foobar\".getBytes());\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        final CountDownLatch completeLatch = new CountDownLatch(1);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        lh.asyncAddEntry(\"foobar\".getBytes(), new AddCallback() {\n+                public void addComplete(int rccb, LedgerHandle lh, long entryId,\n+                                        Object ctx) {\n+                    rc.set(rccb);\n+                    completeLatch.countDown();\n+                }\n+            }, null);\n+\n+        LOG.info(\"Waiting to finish adding another entry asynchronously\");\n+        assertTrue(\"Add entry to ledger call should have completed\",\n+                completeLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"Add entry to ledger should not have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, rc.get());\n+    }\n+\n+    /**\n+     * Test that closing a ledger using bookkeeper client which is closed should\n+     * throw ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testCloseLedger() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 100);\n+        LedgerHandle lh2 = createLedgerWithEntries(bk, 100);\n+\n+        LOG.info(\"Closing bookkeeper client\");\n+        bk.close();\n+\n+        try {\n+            lh.close();\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        final CountDownLatch completeLatch = new CountDownLatch(1);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        lh2.asyncClose(new CloseCallback() {\n+                public void closeComplete(int rccb, LedgerHandle lh, Object ctx) {\n+                    rc.set(rccb);\n+                    completeLatch.countDown();\n+                }\n+            }, null);\n+\n+        LOG.info(\"Waiting to finish adding another entry asynchronously\");\n+        assertTrue(\"Close ledger call should have completed\",\n+                completeLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"Close ledger should have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, rc.get());\n+    }\n+\n+    /**\n+     * Test that reading entry from a ledger using bookkeeper client which is\n+     * closed should throw ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testReadLedgerEntry() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        int numOfEntries = 100;\n+        LedgerHandle lh = createLedgerWithEntries(bk, numOfEntries);\n+        LOG.info(\"Closing bookkeeper client\");\n+\n+        restartBookieSlow();\n+        final CountDownLatch preCloseReadLatch = new CountDownLatch(1);\n+        final AtomicInteger preCloseRc = new AtomicInteger(BKException.Code.OK);\n+        ReadCallback preCloseCb = new ReadCallback() {\n+            @Override\n+            public void readComplete(int rccb, LedgerHandle lh,\n+                    Enumeration<LedgerEntry> seq, Object ctx) {\n+                preCloseRc.set(rccb);\n+                preCloseReadLatch.countDown();\n+            }\n+        };\n+        lh.asyncReadEntries(0, numOfEntries - 1, preCloseCb, null);\n+\n+        bk.close();\n+\n+        assertTrue(\"Read entry ledger call should have completed\",\n+                   preCloseReadLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"Read entry ledger should have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, preCloseRc.get());\n+\n+        try {\n+            lh.readEntries(0, numOfEntries - 1);\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+\n+        final CountDownLatch readLatch = new CountDownLatch(1);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        ReadCallback cb = new ReadCallback() {\n+            @Override\n+            public void readComplete(int rccb, LedgerHandle lh,\n+                    Enumeration<LedgerEntry> seq, Object ctx) {\n+                rc.set(rccb);\n+                readLatch.countDown();\n+            }\n+        };\n+        lh.asyncReadEntries(0, numOfEntries - 1, cb, readLatch);\n+\n+        LOG.info(\"Waiting to finish reading the entries asynchronously\");\n+        assertTrue(\"Read entry ledger call should have completed\",\n+                readLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"Read entry ledger should have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, rc.get());\n+    }\n+\n+    /**\n+     * Test that readlastconfirmed entry from a ledger using bookkeeper client\n+     * which is closed should throw ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testReadLastConfirmed() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 100);\n+        LOG.info(\"Closing bookkeeper client\");\n+\n+        // make all bookies slow\n+        restartBookieSlow();\n+        restartBookieSlow();\n+        restartBookieSlow();\n+\n+        final CountDownLatch preCloseReadLatch = new CountDownLatch(1);\n+        final AtomicInteger preCloseRc = new AtomicInteger(BKException.Code.OK);\n+        AsyncCallback.ReadLastConfirmedCallback preCloseCb\n+            = new AsyncCallback.ReadLastConfirmedCallback() {\n+\n+            @Override\n+            public void readLastConfirmedComplete(int rccb, long lastConfirmed,\n+                    Object ctx) {\n+                preCloseRc.set(rccb);\n+                preCloseReadLatch.countDown();\n+            }\n+        };\n+        lh.asyncReadLastConfirmed(preCloseCb, null);\n+\n+        bk.close();\n+\n+        assertTrue(\"ReadLastConfirmed call should have completed\",\n+                   preCloseReadLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"ReadLastConfirmed should have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, preCloseRc.get());\n+\n+        final CountDownLatch readLatch = new CountDownLatch(1);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        AsyncCallback.ReadLastConfirmedCallback cb = new AsyncCallback.ReadLastConfirmedCallback() {\n+\n+            @Override\n+            public void readLastConfirmedComplete(int rccb, long lastConfirmed,\n+                    Object ctx) {\n+                rc.set(rccb);\n+                readLatch.countDown();\n+            }\n+        };\n+        lh.asyncReadLastConfirmed(cb, readLatch);\n+\n+        LOG.info(\"Waiting to finish reading last confirmed entry asynchronously\");\n+        assertTrue(\"ReadLastConfirmed call should have completed\",\n+                readLatch.await(20, TimeUnit.SECONDS));\n+        assertEquals(\n+                \"ReadLastConfirmed should have succeeded through closed bkclient!\",\n+                BKException.Code.ClientClosedException, rc.get());\n+\n+        try {\n+            lh.readLastConfirmed();\n+            fail(\"should have failed, client is closed\");\n+        } catch (BKClientClosedException e) {\n+            // correct\n+        }\n+    }\n+\n+    /**\n+     * Test that checking a ledger using a closed BK client will\n+     * throw a ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCheck() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 100);\n+        LOG.info(\"Closing bookkeeper client\");\n+\n+        restartBookieSlow();\n+        final CountDownLatch preLatch = new CountDownLatch(1);\n+        final AtomicInteger preRc = new AtomicInteger(BKException.Code.OK);\n+        LedgerChecker lc = new LedgerChecker(bk);\n+        lc.checkLedger(lh, new GenericCallback<Set<LedgerFragment>>() {\n+                @Override\n+                public void operationComplete(int rc, Set<LedgerFragment> result) {\n+                    preRc.set(rc);\n+                    preLatch.countDown();\n+                }\n+            });\n+        bk.close();\n+\n+        assertTrue(\"checkLedger should have finished\", preLatch.await(30, TimeUnit.SECONDS));\n+        assertEquals(\"Should have client closed exception\",\n+                     preRc.get(), BKException.Code.ClientClosedException);\n+\n+        final CountDownLatch postLatch = new CountDownLatch(1);\n+        final AtomicInteger postRc = new AtomicInteger(BKException.Code.OK);\n+        lc.checkLedger(lh, new GenericCallback<Set<LedgerFragment>>() {\n+                @Override\n+                public void operationComplete(int rc, Set<LedgerFragment> result) {\n+                    postRc.set(rc);\n+                    postLatch.countDown();\n+                }\n+            });\n+        assertTrue(\"checkLedger should have finished\", postLatch.await(30, TimeUnit.SECONDS));\n+        assertEquals(\"Should have client closed exception\",\n+                     postRc.get(), BKException.Code.ClientClosedException);\n+    }\n+\n+    private static class CheckerCb implements GenericCallback<Set<LedgerFragment>> {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        int rc = BKException.Code.OK;\n+        Set<LedgerFragment> result = null;\n+\n+        @Override\n+        public void operationComplete(int rc, Set<LedgerFragment> result) {\n+            this.rc = rc;\n+            this.result = result;\n+            latch.countDown();\n+        }\n+\n+        int getRc(int time, TimeUnit unit) throws Exception {\n+            if (latch.await(time, unit)) {\n+                return rc;\n+            } else {\n+                throw new Exception(\"Didn't complete\");\n+            }\n+        }\n+\n+        Set<LedgerFragment> getResult(int time, TimeUnit unit) throws Exception {\n+            if (latch.await(time, unit)) {\n+                return result;\n+            } else {\n+                throw new Exception(\"Didn't complete\");\n+            }\n+        }\n+    }\n+    /**\n+     * Test that BookKeeperAdmin operationg using a closed BK client will\n+     * throw a ClientClosedException\n+     */\n+    @Test(timeout = 60000)\n+    public void testBookKeeperAdmin() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        BookKeeperAdmin bkadmin = new BookKeeperAdmin(bk);\n+\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh1 = createLedgerWithEntries(bk, 100);\n+        LedgerHandle lh2 = createLedgerWithEntries(bk, 100);\n+        LedgerHandle lh3 = createLedgerWithEntries(bk, 100);\n+        lh3.close();\n+\n+        BookieSocketAddress bookieToKill = getBookie(0);\n+        killBookie(bookieToKill);\n+        startNewBookie();\n+        BookieSocketAddress newBookie = getBookie(2);\n+\n+        CheckerCb checkercb = new CheckerCb();\n+        LedgerChecker lc = new LedgerChecker(bk);\n+        lc.checkLedger(lh3, checkercb);\n+        assertEquals(\"Should have completed\",\n+                     checkercb.getRc(30, TimeUnit.SECONDS), BKException.Code.OK);\n+        assertEquals(\"Should have a missing fragment\",\n+                     1, checkercb.getResult(30, TimeUnit.SECONDS).size());\n+\n+        // make sure a bookie in each quorum is slow\n+        restartBookieSlow();\n+        restartBookieSlow();\n+\n+        final CountDownLatch latch1 = new CountDownLatch(1);\n+        final CountDownLatch latch2 = new CountDownLatch(1);\n+        final CountDownLatch latch3 = new CountDownLatch(1);\n+\n+        final AtomicInteger rc1 = new AtomicInteger(BKException.Code.OK);\n+        final AtomicInteger rc2 = new AtomicInteger(BKException.Code.OK);\n+        final AtomicInteger rc3 = new AtomicInteger(BKException.Code.OK);\n+\n+        bkadmin.asyncOpenLedger(lh1.getId(), new AsyncCallback.OpenCallback() {\n+                @Override\n+                public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+                    rc1.set(rc);\n+                    latch1.countDown();\n+                }\n+            }, null);\n+        bkadmin.asyncOpenLedgerNoRecovery(lh2.getId(), new AsyncCallback.OpenCallback() {\n+                @Override\n+                public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+                    rc2.set(rc);\n+                    latch2.countDown();\n+                }\n+            }, null);\n+\n+        bkadmin.asyncRecoverBookieData(bookieToKill, newBookie,\n+                new AsyncCallback.RecoverCallback() {\n+                    @Override\n+                    public void recoverComplete(int rc, Object ctx) {\n+                        rc3.set(rc);\n+                        latch3.countDown();\n+                    }\n+                }, null);\n+        bk.close();\n+\n+        assertTrue(\"Request1 should have completed\", latch1.await(10, TimeUnit.SECONDS));\n+        assertTrue(\"Request2 should have completed\", latch2.await(10, TimeUnit.SECONDS));\n+        assertTrue(\"Request3 should have completed\", latch3.await(10, TimeUnit.SECONDS));\n+        assertEquals(\"Should have noticed the handle was closed\",\n+                     BKException.Code.ClientClosedException, rc1.get());\n+        assertEquals(\"Should have noticed the handle was closed\",\n+                     BKException.Code.ClientClosedException, rc2.get());\n+        assertEquals(\"Should have noticed the handle was closed\",\n+                     BKException.Code.ClientClosedException, rc3.get());\n+\n+        try {\n+            bkadmin.openLedger(lh1.getId());\n+            fail(\"Shouldn't be able to open with a closed client\");\n+        } catch (BKException.BKClientClosedException cce) {\n+            // correct behaviour\n+        }\n+\n+        try {\n+            bkadmin.openLedgerNoRecovery(lh1.getId());\n+            fail(\"Shouldn't be able to open with a closed client\");\n+        } catch (BKException.BKClientClosedException cce) {\n+            // correct behaviour\n+        }\n+\n+        try {\n+            bkadmin.recoverBookieData(bookieToKill, newBookie);\n+            fail(\"Shouldn't be able to recover with a closed client\");\n+        } catch (BKException.BKClientClosedException cce) {\n+            // correct behaviour\n+        }\n+\n+        try {\n+            bkadmin.replicateLedgerFragment(lh3,\n+                    checkercb.getResult(10, TimeUnit.SECONDS).iterator().next(), newBookie);\n+            fail(\"Shouldn't be able to replicate with a closed client\");\n+        } catch (BKException.BKClientClosedException cce) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    private LedgerHandle createLedgerWithEntries(BookKeeper bk, int numOfEntries)\n+            throws Exception {\n+        LedgerHandle lh = bk\n+                .createLedger(3, 3, digestType, PASSWORD.getBytes());\n+\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        final CountDownLatch latch = new CountDownLatch(numOfEntries);\n+\n+        final AddCallback cb = new AddCallback() {\n+                public void addComplete(int rccb, LedgerHandle lh, long entryId,\n+                                        Object ctx) {\n+                    rc.compareAndSet(BKException.Code.OK, rccb);\n+                    latch.countDown();\n+                }\n+            };\n+        for (int i = 0; i < numOfEntries; i++) {\n+            lh.asyncAddEntry(\"foobar\".getBytes(), cb, null);\n+        }\n+        if (!latch.await(30, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Entries took too long to add\");\n+        }\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+        return lh;\n+    }\n+\n+}"}]}

