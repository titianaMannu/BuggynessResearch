{"sha":"678143fc4a03563dbb75af173f8029e4eff07c63","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2NzgxNDNmYzRhMDM1NjNkYmI3NWFmMTczZjgwMjllNGVmZjA3YzYz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-06-07T10:44:24Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-06-07T10:44:24Z"},"message":"BOOKKEEPER-581: Ledger recovery doesn't work correctly when recovery adds force changing ensembles. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1490578 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a01abe4a95c960562ecd11cdb10e5c778cce648c","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a01abe4a95c960562ecd11cdb10e5c778cce648c"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/678143fc4a03563dbb75af173f8029e4eff07c63","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/678143fc4a03563dbb75af173f8029e4eff07c63","html_url":"https://github.com/apache/bookkeeper/commit/678143fc4a03563dbb75af173f8029e4eff07c63","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/678143fc4a03563dbb75af173f8029e4eff07c63/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"30452d072bbf919fb1a602556fbcc7078a74bd36","url":"https://api.github.com/repos/apache/bookkeeper/commits/30452d072bbf919fb1a602556fbcc7078a74bd36","html_url":"https://github.com/apache/bookkeeper/commit/30452d072bbf919fb1a602556fbcc7078a74bd36"}],"stats":{"total":193,"additions":150,"deletions":43},"files":[{"sha":"3ea9470e12afdf093972592f44c3021751c49465","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/678143fc4a03563dbb75af173f8029e4eff07c63/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/678143fc4a03563dbb75af173f8029e4eff07c63/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=678143fc4a03563dbb75af173f8029e4eff07c63","patch":"@@ -14,6 +14,8 @@ Release 4.2.2 - Unreleased\n \n         BOOKKEEPER-585: Auditor logs noisily when a ledger has been deleted (ivank)\n \n+        BOOKKEEPER-581: Ledger recovery doesn't work correctly when recovery adds force changing ensembles. (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-579: TestSubAfterCloseSub was put in a wrong package (sijie via ivank)"},{"sha":"aef7dd51de1931633c7d11dfabf17052c5d4c2f2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=678143fc4a03563dbb75af173f8029e4eff07c63","patch":"@@ -18,13 +18,16 @@\n  * limitations under the License.\n  */\n \n+import static com.google.common.base.Charsets.UTF_8;\n+\n import java.io.BufferedReader;\n import java.io.StringReader;\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.SortedMap;\n import java.util.TreeMap;\n import java.util.Arrays;\n@@ -96,6 +99,30 @@ public LedgerMetadata(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n         this.hasPassword = true;\n     }\n \n+    /**\n+     * Copy Constructor.\n+     */\n+    LedgerMetadata(LedgerMetadata other) {\n+        this.ensembleSize = other.ensembleSize;\n+        this.writeQuorumSize = other.writeQuorumSize;\n+        this.ackQuorumSize = other.ackQuorumSize;\n+        this.length = other.length;\n+        this.lastEntryId = other.lastEntryId;\n+        this.metadataFormatVersion = other.metadataFormatVersion;\n+        this.state = other.state;\n+        this.version = other.version;\n+        this.hasPassword = other.hasPassword;\n+        this.digestType = other.digestType;\n+        this.password = new byte[other.password.length];\n+        System.arraycopy(other.password, 0, this.password, 0, other.password.length);\n+        // copy the ensembles\n+        for (Entry<Long, ArrayList<InetSocketAddress>> entry : other.ensembles.entrySet()) {\n+            long startEntryId = entry.getKey();\n+            ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>(entry.getValue());\n+            this.addEnsemble(startEntryId, newEnsemble);\n+        }\n+    }\n+\n     private LedgerMetadata() {\n         this(0, 0, 0, BookKeeper.DigestType.MAC, new byte[] {});\n         this.hasPassword = false;"},{"sha":"3262e5c1aecc7165d55eb2fa30a358593c4f54f4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":36,"deletions":22,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=678143fc4a03563dbb75af173f8029e4eff07c63","patch":"@@ -19,21 +19,16 @@\n  */\n \n import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n-import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n-import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-\n import org.apache.zookeeper.KeeperException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.buffer.ChannelBuffer;\n \n /**\n  * This class encapsulated the ledger recovery operation. It first does a read\n@@ -51,9 +46,25 @@\n     long maxAddPushed = LedgerHandle.INVALID_ENTRY_ID;\n     long maxAddConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n     long maxLength = 0;\n+    // keep a copy of metadata for recovery.\n+    LedgerMetadata metadataForRecovery;\n \n     GenericCallback<Void> cb;\n \n+    class RecoveryReadOp extends PendingReadOp {\n+\n+        RecoveryReadOp(LedgerHandle lh, ScheduledExecutorService scheduler, long startEntryId,\n+                long endEntryId, ReadCallback cb, Object ctx) {\n+            super(lh, scheduler, startEntryId, endEntryId, cb, ctx);\n+        }\n+\n+        @Override\n+        protected LedgerMetadata getLedgerMetadata() {\n+            return metadataForRecovery;\n+        }\n+\n+    }\n+\n     public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n         this.cb = cb;\n         this.lh = lh;\n@@ -63,17 +74,20 @@ public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n     public void initiate() {\n         ReadLastConfirmedOp rlcop = new ReadLastConfirmedOp(lh,\n                 new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n-                public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n-                    if (rc == BKException.Code.OK) {\n-                        lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n-                        lh.length = data.length;\n-                        doRecoveryRead();\n-                    } else if (rc == BKException.Code.UnauthorizedAccessException) {\n-                        cb.operationComplete(rc, null);\n-                    } else {\n-                        cb.operationComplete(BKException.Code.ReadException, null);\n+                    public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n+                        if (rc == BKException.Code.OK) {\n+                            lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n+                            lh.length = data.length;\n+                            // keep a copy of ledger metadata before proceeding\n+                            // ledger recovery\n+                            metadataForRecovery = new LedgerMetadata(lh.getLedgerMetadata());\n+                            doRecoveryRead();\n+                        } else if (rc == BKException.Code.UnauthorizedAccessException) {\n+                            cb.operationComplete(rc, null);\n+                        } else {\n+                            cb.operationComplete(BKException.Code.ReadException, null);\n+                        }\n                     }\n-                }\n                 });\n \n         /**\n@@ -88,14 +102,16 @@ public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n      * Try to read past the last confirmed.\n      */\n     private void doRecoveryRead() {\n-        lh.lastAddConfirmed++;\n-        lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, this, null);\n+        long nextEntry = lh.lastAddConfirmed + 1;\n+        try {\n+            new RecoveryReadOp(lh, lh.bk.scheduler, nextEntry, nextEntry, this, null).initiate();\n+        } catch (InterruptedException e) {\n+            readComplete(BKException.Code.InterruptedException, lh, null, null);\n+        }\n     }\n \n     @Override\n     public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-        // get back to prev value\n-        lh.lastAddConfirmed--;\n         if (rc == BKException.Code.OK) {\n             LedgerEntry entry = seq.nextElement();\n             byte[] data = entry.getEntry();\n@@ -145,9 +161,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n             cb.operationComplete(rc, null);\n             return;\n         }\n-\n         doRecoveryRead();\n-\n     }\n \n }"},{"sha":"12925b74ee79c2a21bae1fdf496442b1dbbceb5b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":20,"deletions":17,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=678143fc4a03563dbb75af173f8029e4eff07c63","patch":"@@ -21,27 +21,27 @@\n  *\n  */\n import java.net.InetSocketAddress;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.ArrayList;\n+import java.util.BitSet;\n import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.NoSuchElementException;\n import java.util.Queue;\n-import java.util.BitSet;\n import java.util.Set;\n-import java.util.HashSet;\n-import java.util.List;\n-\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.buffer.ChannelBufferInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Sequence of entries of a ledger that represents a pending read operation.\n@@ -128,7 +128,7 @@ private boolean readsOutstanding() {\n          * @return host we sent to if we sent. null otherwise.\n          */\n         synchronized InetSocketAddress maybeSendSpeculativeRead(Set<InetSocketAddress> heardFromHosts) {\n-            if (nextReplicaIndexToReadFrom >= lh.getLedgerMetadata().getWriteQuorumSize()) {\n+            if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 return null;\n             }\n \n@@ -146,7 +146,7 @@ synchronized InetSocketAddress maybeSendSpeculativeRead(Set<InetSocketAddress> h\n         }\n \n         synchronized InetSocketAddress sendNextRead() {\n-            if (nextReplicaIndexToReadFrom >= lh.metadata.getWriteQuorumSize()) {\n+            if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 // we are done, the read has failed from all replicas, just fail the\n                 // read\n \n@@ -251,11 +251,16 @@ public String toString() {\n         this.endEntryId = endEntryId;\n         this.scheduler = scheduler;\n         numPendingEntries = endEntryId - startEntryId + 1;\n-        maxMissedReadsAllowed = lh.metadata.getWriteQuorumSize() - lh.metadata.getAckQuorumSize();\n+        maxMissedReadsAllowed = getLedgerMetadata().getWriteQuorumSize()\n+                - getLedgerMetadata().getAckQuorumSize();\n         speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n         heardFromHosts = new HashSet<InetSocketAddress>();\n     }\n \n+    protected LedgerMetadata getLedgerMetadata() {\n+        return lh.metadata;\n+    }\n+\n     public void initiate() throws InterruptedException {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n \n@@ -283,11 +288,9 @@ public void run() {\n         }\n \n         do {\n-            LOG.debug(\"Acquiring lock: {}\", i);\n-\n             if (i == nextEnsembleChange) {\n-                ensemble = lh.metadata.getEnsemble(i);\n-                nextEnsembleChange = lh.metadata.getNextEnsembleChange(i);\n+                ensemble = getLedgerMetadata().getEnsemble(i);\n+                nextEnsembleChange = getLedgerMetadata().getNextEnsembleChange(i);\n             }\n             LedgerEntryRequest entry = new LedgerEntryRequest(ensemble, lh.ledgerId, i);\n             seq.add(entry);"},{"sha":"cb92a0aac75fc2d87c396ceb2542e9af531474bc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","status":"modified","additions":65,"deletions":4,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/678143fc4a03563dbb75af173f8029e4eff07c63/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java?ref=678143fc4a03563dbb75af173f8029e4eff07c63","patch":"@@ -24,20 +24,18 @@\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n-import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.junit.*;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.test.BaseTestCase;\n+import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -356,4 +354,67 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n         assertEquals(\"Fenced ledger should have correct lastAddConfirmed\",\n                      lhbefore.getLastAddConfirmed(), lhafter.getLastAddConfirmed());\n     }\n+\n+    /**\n+     * Verify that it doesn't break the recovery when changing ensemble in\n+     * recovery add.\n+     */\n+    @Test(timeout = 60000)\n+    public void testEnsembleChangeDuringRecovery() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(numBookies, 2, 2, digestType, \"\".getBytes());\n+        int numEntries = (numBookies * 3) + 1;\n+        final AtomicInteger numPendingAdds = new AtomicInteger(numEntries);\n+        final CountDownLatch addDone = new CountDownLatch(1);\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.asyncAddEntry(\"data\".getBytes(), new AddCallback() {\n+\n+                @Override\n+                public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    if (BKException.Code.OK != rc) {\n+                        addDone.countDown();\n+                        return;\n+                    }\n+                    if (numPendingAdds.decrementAndGet() == 0) {\n+                        addDone.countDown();\n+                    }\n+                }\n+\n+            }, null);\n+        }\n+        addDone.await(10, TimeUnit.SECONDS);\n+        if (numPendingAdds.get() > 0) {\n+            fail(\"Failed to add \" + numEntries + \" to ledger handle \" + lh.getId());\n+        }\n+        // kill first 2 bookies to replace bookies\n+        InetSocketAddress bookie1 = lh.getLedgerMetadata().currentEnsemble.get(0);\n+        ServerConfiguration conf1 = killBookie(bookie1);\n+        InetSocketAddress bookie2 = lh.getLedgerMetadata().currentEnsemble.get(1);\n+        ServerConfiguration conf2 = killBookie(bookie2);\n+\n+        // replace these two bookies\n+        startDeadBookie(conf1);\n+        startDeadBookie(conf2);\n+        // kick in two brand new bookies\n+        startNewBookie();\n+        startNewBookie();\n+\n+        // two dead bookies are put in the ensemble which would cause ensemble\n+        // change\n+        LedgerHandle recoveredLh = bkc.openLedger(lh.getId(), digestType, \"\".getBytes());\n+        assertEquals(\"Fenced ledger should have correct lastAddConfirmed\", lh.getLastAddConfirmed(),\n+                recoveredLh.getLastAddConfirmed());\n+    }\n+\n+    private void startDeadBookie(ServerConfiguration conf) throws Exception {\n+        Bookie rBookie = new Bookie(conf) {\n+            @Override\n+            public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n+                    throws IOException, BookieException {\n+                // drop request to simulate a dead bookie\n+                throw new IOException(\"Couldn't write entries for some reason\");\n+            }\n+        };\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf, rBookie));\n+    }\n }"}]}

