{"sha":"682a23fb23c8de7756d5ef226fd6e97dd8d4e561","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ODJhMjNmYjIzYzhkZTc3NTZkNWVmMjI2ZmQ2ZTk3ZGQ4ZDRlNTYx","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T08:58:51Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T08:58:51Z"},"message":"BOOKKEEPER-112: Bookie Recovery on an open ledger will cause LedgerHandle#close on that ledger to fail (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1307743 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ba890e7a88896051ca2206d43c03c8103f6b9760","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ba890e7a88896051ca2206d43c03c8103f6b9760"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","html_url":"https://github.com/apache/bookkeeper/commit/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"235bc1fec4d60567d113202b44f6fb4c1616d1ce","url":"https://api.github.com/repos/apache/bookkeeper/commits/235bc1fec4d60567d113202b44f6fb4c1616d1ce","html_url":"https://github.com/apache/bookkeeper/commit/235bc1fec4d60567d113202b44f6fb4c1616d1ce"}],"stats":{"total":484,"additions":426,"deletions":58},"files":[{"sha":"2ddb099d00d81037dc0e014ef03fd8d3ace754c4","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -74,6 +74,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-198: replaying entries of deleted ledgers would exhaust ledger cache. (sijie)\n \n+        BOOKKEEPER-112: Bookie Recovery on an open ledger will cause LedgerHandle#close on that ledger to fail (sijie)\n+\n       hedwig-server/\n       \n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)"},{"sha":"b9cd624a4310bc79c69f7a4e93c487b347f21b70","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":73,"deletions":11,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -36,6 +36,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -83,7 +84,6 @@\n     private DigestType DIGEST_TYPE;\n     private byte[] PASSWD;\n \n-    \n     /**\n      * Constructor that takes in a ZooKeeper servers connect string so we know\n      * how to connect to ZooKeeper to retrieve information about the BookKeeper\n@@ -426,8 +426,8 @@ private void recoverLedger(final InetSocketAddress bookieSrc, final long lId,\n          * ledger fragments are stored on. Check if any of the ledger fragments\n          * for the current ledger are stored on the input dead bookie.\n          */\n-        DigestType digestType = getLedgerDigestType(lId);\n-        byte[] passwd = getLedgerPasswd(lId);\n+        final DigestType digestType = getLedgerDigestType(lId);\n+        final byte[] passwd = getLedgerPasswd(lId);\n         bkc.asyncOpenLedgerNoRecovery(lId, digestType, passwd, new OpenCallback() {\n             @Override\n             public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n@@ -436,6 +436,39 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                     ledgerIterCb.processResult(rc, null, null);\n                     return;\n                 }\n+\n+                LedgerMetadata lm = lh.getLedgerMetadata();\n+                if (!lm.isClosed() &&\n+                    lm.getEnsembles().size() > 0) {\n+                    Long lastKey = lm.getEnsembles().lastKey();\n+                    ArrayList<InetSocketAddress> lastEnsemble = lm.getEnsembles().get(lastKey);\n+                    // the original write has not removed faulty bookie from\n+                    // current ledger ensemble. to avoid data loss issue in\n+                    // the case of concurrent updates to the ensemble composition,\n+                    // the recovery tool should first close the ledger\n+                    if (lastEnsemble.contains(bookieSrc)) {\n+                        // close opened non recovery ledger handle\n+                        try {\n+                            lh.close();\n+                        } catch (Exception ie) {\n+                            LOG.warn(\"Error closing non recovery ledger handle for ledger \" + lId, ie);\n+                        }\n+                        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n+                            @Override\n+                            public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n+                                if (newrc != Code.OK.intValue()) {\n+                                    LOG.error(\"BK error close ledger: \" + lId, BKException.create(newrc));\n+                                    ledgerIterCb.processResult(newrc, null, null);\n+                                    return;\n+                                }\n+                                // do recovery\n+                                recoverLedger(bookieSrc, lId, ledgerIterCb, availableBookies);\n+                            }\n+                        }, null);\n+                        return;\n+                    }\n+                }\n+\n                 /*\n                  * This List stores the ledger fragments to recover indexed by\n                  * the start entry ID for the range. The ensembles TreeMap is\n@@ -465,6 +498,12 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                         ledgerFragmentsToRecover.add(entry.getKey());\n                     }\n                 }\n+                // add last ensemble otherwise if the failed bookie existed in\n+                // the last ensemble of a closed ledger. the entries belonged to\n+                // last ensemble would not be replicated.\n+                if (curEntryId != null) {\n+                    ledgerFragmentsRange.put(curEntryId, lh.getLastAddConfirmed());\n+                }\n                 /*\n                  * See if this current ledger contains any ledger fragment that\n                  * needs to be re-replicated. If not, then just invoke the\n@@ -503,7 +542,6 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                                   + \",\" + endEntryId + \"] of ledger \" + lh.getId()\n                                   + \" to \" + newBookie);\n                     }\n-\n                     try {\n                         SingleFragmentCallback cb = new SingleFragmentCallback(\n                                                                                ledgerFragmentsMcb, lh, startEntryId, bookieSrc, newBookie);\n@@ -551,6 +589,12 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n             cb.processResult(BKException.Code.OK, null, null);\n             return;\n         }\n+        if (startEntryId > endEntryId) {\n+            // for open ledger which there is no entry, the start entry id is 0, the end entry id is -1.\n+            // we can return immediately to trigger forward read\n+            cb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n \n         ArrayList<InetSocketAddress> curEnsemble = lh.getLedgerMetadata().getEnsembles().get(startEntryId);\n         int bookieIndex = 0;\n@@ -603,7 +647,7 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n      *            entries that were stored on the failed bookie.\n      */\n     private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n-                                            final MultiCallback ledgerFragmentEntryMcb, \n+                                            final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,\n                                             final InetSocketAddress newBookie) throws InterruptedException {\n         /*\n          * Read the ledger entry using the LedgerHandle. This will allow us to\n@@ -659,13 +703,14 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n      * be a multicallback responsible for all fragments in a single ledger\n      */\n     class SingleFragmentCallback implements AsyncCallback.VoidCallback {\n-        final MultiCallback ledgerFragmentsMcb;\n+        final AsyncCallback.VoidCallback ledgerFragmentsMcb;\n         final LedgerHandle lh;\n         final long fragmentStartId;\n         final InetSocketAddress oldBookie;\n         final InetSocketAddress newBookie;\n \n-        SingleFragmentCallback(MultiCallback ledgerFragmentsMcb, LedgerHandle lh, \n+        SingleFragmentCallback(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n+                               LedgerHandle lh,\n                                long fragmentStartId,\n                                InetSocketAddress oldBookie,\n                                InetSocketAddress newBookie) {\n@@ -684,6 +729,10 @@ public void processResult(int rc, String path, Object ctx) {\n                 ledgerFragmentsMcb.processResult(rc, null, null);\n                 return;\n             }\n+            writeLedgerConfig();\n+        }\n+\n+        protected void writeLedgerConfig() {\n             /*\n              * Update the ledger metadata's ensemble info to point\n              * to the new bookie.\n@@ -693,20 +742,32 @@ public void processResult(int rc, String path, Object ctx) {\n             int deadBookieIndex = ensemble.indexOf(oldBookie);\n             ensemble.remove(deadBookieIndex);\n             ensemble.add(deadBookieIndex, newBookie);\n-            \n-            \n+\n             lh.writeLedgerConfig(new WriteCb(), null);\n         }\n         \n         private class WriteCb implements AsyncCallback.StatCallback {\n             @Override\n-            public void processResult(int rc, String path, Object ctx, Stat stat) {\n+            public void processResult(int rc, final String path, Object ctx, Stat stat) {\n                 if (rc == Code.BADVERSION.intValue()) {\n                     LOG.warn(\"Two fragments attempted update at once; ledger id: \" + lh.getId() \n                              + \" startid: \" + fragmentStartId);\n                     // try again, the previous success (with which this has conflicted)\n                     // will have updated the stat\n-                    lh.writeLedgerConfig(new WriteCb(), null);\n+                    // other operations such as (addEnsemble) would update it too.\n+                    lh.rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                        @Override\n+                        public void operationComplete(int rc, LedgerMetadata newMeta) {\n+                            if (rc != BKException.Code.OK) {\n+                                LOG.error(\"Error reading updated ledger metadata for ledger \" + lh.getId(),\n+                                          KeeperException.create(KeeperException.Code.get(rc), path));\n+                                ledgerFragmentsMcb.processResult(rc, null, null);\n+                            } else {\n+                                lh.metadata = newMeta;\n+                                writeLedgerConfig();\n+                            }\n+                        }\n+                    });\n                     return;\n                 } else if (rc != Code.OK.intValue()) {\n                     LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n@@ -725,4 +786,5 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n             }\n         };\n     }\n+\n }"},{"sha":"e576792c9132f6a98e9c04c2b2eff3a45a2137c7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":95,"deletions":30,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -20,6 +20,7 @@\n  * under the License.\n  *\n  */\n+\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n@@ -253,15 +254,20 @@ void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc)\n         bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n+                final long prevClose;\n+                final long prevLength;\n+\n                 synchronized(LedgerHandle.this) {\n+                    prevClose = metadata.close;\n+                    prevLength = metadata.length;\n+\n                     // synchronized on LedgerHandle.this to ensure that \n                     // lastAddPushed can not be updated after the metadata \n                     // is closed. \n                     metadata.length = length;\n \n                     // Close operation is idempotent, so no need to check if we are\n                     // already closed\n-\n                     metadata.close(lastAddConfirmed);\n                     errorOutPendingAdds(rc);\n                     lastAddPushed = lastAddConfirmed;\n@@ -272,11 +278,37 @@ public void safeRun() {\n                               + metadata.close + \" with this many bytes: \" + metadata.length);\n                 }\n \n-                writeLedgerConfig(new StatCallback() {\n+                final class CloseCb implements StatCallback {\n                     @Override\n-                    public void processResult(int rc, String path, Object subctx,\n-                                              Stat stat) {\n-                        if (rc != KeeperException.Code.OK.intValue()) {\n+                    public void processResult(final int rc, String path, Object subctx,\n+                                              final Stat stat) {\n+                        if (rc == KeeperException.Code.BadVersion) {\n+                            rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                                @Override\n+                                public void operationComplete(int newrc, LedgerMetadata newMeta) {\n+                                    if (newrc != BKException.Code.OK) {\n+                                        LOG.error(\"Error reading new metadata from ledger \" + ledgerId\n+                                                  + \" when closing, code=\" + newrc);\n+                                        cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this, ctx);\n+                                    } else {\n+                                        metadata.close(prevClose);\n+                                        metadata.length = prevLength;\n+                                        if (metadata.resolveConflict(newMeta)) {\n+                                            metadata.length = length;\n+                                            metadata.close(lastAddConfirmed);\n+                                            writeLedgerConfig(new CloseCb(), null);\n+                                            return;\n+                                        } else {\n+                                            metadata.length = length;\n+                                            metadata.close(lastAddConfirmed);\n+                                            LOG.warn(\"Conditional write failed: \"\n+                                                     + KeeperException.Code.get(KeeperException.Code.BadVersion));\n+                                            cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this, ctx);\n+                                        }\n+                                    }\n+                                }\n+                            });\n+                        } else if (rc != KeeperException.Code.OK.intValue()) {\n                             LOG.warn(\"Conditional write failed: \" + KeeperException.Code.get(rc));\n                             cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n                                              ctx);\n@@ -285,7 +317,9 @@ public void processResult(int rc, String path, Object subctx,\n                             cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n                         }\n                     }\n-                }, null);\n+                };\n+\n+                writeLedgerConfig(new CloseCb(), null);\n \n             }\n         });\n@@ -639,16 +673,43 @@ void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n                       + (lastAddConfirmed + 1));\n         }\n \n-        metadata.addEnsemble(lastAddConfirmed + 1, newEnsemble);\n+        final long newEnsembleStartEntry = lastAddConfirmed + 1;\n+        metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n \n-        writeLedgerConfig(new StatCallback() {\n+        final class ChangeEnsembleCb implements StatCallback {\n             @Override\n             public void processResult(final int rc, String path, Object ctx, final Stat stat) {\n \n                 bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n                     @Override\n                     public void safeRun() {\n-                        if (rc != KeeperException.Code.OK.intValue()) {\n+                        if (rc == KeeperException.Code.BadVersion) {\n+                            rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                                @Override\n+                                public void operationComplete(int newrc, LedgerMetadata newMeta) {\n+                                    if (newrc != BKException.Code.OK) {\n+                                        LOG.error(\"Error reading new metadata from ledger after changing ensemble, code=\" + newrc);\n+                                        handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                                    } else {\n+                                        // a new ensemble is added only when the start entry is larger than zero\n+                                        if (newEnsembleStartEntry > 0) {\n+                                            metadata.getEnsembles().remove(newEnsembleStartEntry);\n+                                        }\n+                                        if (metadata.resolveConflict(newMeta)) {\n+                                            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n+                                            writeLedgerConfig(new ChangeEnsembleCb(), null);\n+                                            return;\n+                                        } else {\n+                                            LOG.error(\"Could not resolve ledger metadata confliction while changing ensemble to: \"\n+                                                      + newEnsemble + \", old meta data is \\n\" + new String(metadata.serialize())\n+                                                      + \"\\n, new meta data is \\n\" + new String(newMeta.serialize()) + \"\\n ,closing ledger\");\n+                                            handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                                        }\n+                                    }\n+                                }\n+                            });\n+                            return;\n+                        } else if (rc != KeeperException.Code.OK.intValue()) {\n                             LOG\n                             .error(\"Could not persist ledger metadata while changing ensemble to: \"\n                                    + newEnsemble + \" , closing ledger\");\n@@ -664,30 +725,33 @@ public void safeRun() {\n                 });\n \n             }\n-        }, null);\n+        };\n+\n+        writeLedgerConfig(new ChangeEnsembleCb(), null);\n \n     }\n \n-    void rereadMetadata(final GenericCallback<Void> cb) {\n+    void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n         bk.getZkHandle().getData(bk.getLedgerManager().getLedgerPath(ledgerId), false,\n-                new DataCallback() {\n-                    public void processResult(int rc, String path,\n-                                              Object ctx, byte[] data, Stat stat) {\n-                        if (rc != KeeperException.Code.OK.intValue()) {\n-                            LOG.error(\"Error reading metadata from ledger, code =\" + rc);\n-                            cb.operationComplete(BKException.Code.ZKException, null);\n-                            return;\n-                        }\n-                        \n-                        try {\n-                            metadata = LedgerMetadata.parseConfig(data, stat.getVersion());\n-                        } catch (IOException e) {\n-                            LOG.error(\"Error parsing ledger metadata for ledger\", e);\n-                            cb.operationComplete(BKException.Code.ZKException, null);\n-                        }\n-                        cb.operationComplete(BKException.Code.OK, null);\n+            new DataCallback() {\n+                public void processResult(int rc, String path,\n+                                          Object ctx, byte[] data, Stat stat) {\n+                    if (rc != KeeperException.Code.OK.intValue()) {\n+                        LOG.error(\"Error reading metadata from ledger, code =\" + rc);\n+                        cb.operationComplete(BKException.Code.ZKException, null);\n+                        return;\n                     }\n-                }, null);\n+\n+                    try {\n+                        LedgerMetadata newMeta = LedgerMetadata.parseConfig(data, stat.getVersion());\n+                        cb.operationComplete(BKException.Code.OK, newMeta);\n+                    } catch (IOException e) {\n+                        LOG.error(\"Error parsing ledger metadata for ledger\", e);\n+                        cb.operationComplete(BKException.Code.ZKException, null);\n+                        return;\n+                    }\n+                }\n+        }, null);\n     }\n \n     void recover(final GenericCallback<Void> cb) {\n@@ -713,12 +777,13 @@ void recover(final GenericCallback<Void> cb) {\n             @Override\n             public void processResult(final int rc, String path, Object ctx, Stat stat) {\n                 if (rc == KeeperException.Code.BadVersion) {\n-                    rereadMetadata(new GenericCallback<Void>() {\n+                    rereadMetadata(new GenericCallback<LedgerMetadata>() {\n                             @Override\n-                            public void operationComplete(int rc, Void result) {\n+                            public void operationComplete(int rc, LedgerMetadata newMeta) {\n                                 if (rc != BKException.Code.OK) {\n                                     cb.operationComplete(rc, null);\n                                 } else {\n+                                    metadata = newMeta;\n                                     recover(cb);\n                                 }\n                             }"},{"sha":"2dcf0e4a441825c9c7f2788ca077ee3ee9ea7487","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -21,6 +21,7 @@\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.Map;\n import java.util.SortedMap;\n import java.util.TreeMap;\n@@ -259,4 +260,47 @@ public void updateZnodeStatus(int znodeVersion) {\n     public int getZnodeVersion() {\n         return this.znodeVersion;\n     }\n+\n+    /**\n+     * Resolve conflict with new updated metadata.\n+     *\n+     * @param newMeta\n+     *          Re-read metadata\n+     * @return true if the confliction is resolved, otherwise false.\n+     */\n+    boolean resolveConflict(LedgerMetadata newMeta) {\n+        // length & close is changed means other one open the ledger\n+        // can't resolve this confliction\n+        if (metadataFormatVersion != newMeta.metadataFormatVersion ||\n+            ensembleSize != newMeta.ensembleSize ||\n+            quorumSize != newMeta.quorumSize ||\n+            length != newMeta.length ||\n+            close != newMeta.close) {\n+            return false;\n+        }\n+        // new meta znode version should be larger than old one\n+        if (znodeVersion > newMeta.znodeVersion) {\n+            return false;\n+        }\n+        // ensemble size should be same\n+        if (ensembles.size() != newMeta.ensembles.size()) {\n+            return false;\n+        }\n+        // ensemble distribution should be same\n+        // we don't check the detail ensemble, since new bookie will be set\n+        // using recovery tool.\n+        Iterator<Long> keyIter = ensembles.keySet().iterator();\n+        Iterator<Long> newMetaKeyIter = newMeta.ensembles.keySet().iterator();\n+        for (int i=0; i<ensembles.size(); i++) {\n+            Long curKey = keyIter.next();\n+            Long newMetaKey = newMetaKeyIter.next();\n+            if (curKey != newMetaKey) {\n+                return false;\n+            }\n+        }\n+        // if the confliction could be resolved, update ensembles and znode version\n+        ensembles = newMeta.ensembles;\n+        znodeVersion = newMeta.znodeVersion;\n+        return true;\n+    }\n }"},{"sha":"bb656a52dc27263b36edaa4e281895c585d5fafc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -126,7 +126,7 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n         }\n \n         // otherwise, some other error, we can't handle\n-        LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + lh.lastAddConfirmed + 1\n+        LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + (lh.lastAddConfirmed + 1)\n                   + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n         cb.operationComplete(rc, null);\n         return;\n@@ -137,7 +137,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if (rc != BKException.Code.OK) {\n             // Give up, we can't recover from this error\n \n-            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + lh.lastAddConfirmed + 1\n+            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + (lh.lastAddConfirmed + 1)\n                       + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n             cb.operationComplete(rc, null);\n             return;"},{"sha":"4cf4a9396cea9fe2859271db0529e645533653a9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -121,6 +121,21 @@ void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n     public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n         final LedgerEntry entry = (LedgerEntry) ctx;\n \n+        // if we just read only one entry, and this entry is not existed (in recoveryRead case)\n+        // we don't need to do ReattemptRead, otherwise we could not handle following case:\n+        //\n+        // an empty ledger with quorum (bk1, bk2), bk2 is failed forever.\n+        // bk1 return NoLedgerException, client do ReattemptRead to bk2 but bk2 isn't connected\n+        // so the read 0 entry would failed. this ledger could never be closed.\n+        if (startEntryId == endEntryId) {\n+            if (BKException.Code.NoSuchLedgerExistsException == rc ||\n+                BKException.Code.NoSuchEntryException == rc) {\n+                lh.opCounterSem.release();\n+                submitCallback(rc);\n+                return;\n+            }\n+        }\n+\n         if (rc != BKException.Code.OK) {\n             logErrorAndReattemptRead(entry, \"Error: \" + BKException.getMessage(rc), rc);\n             return;"},{"sha":"6135250a16e6d0fcf39e163c79d008f61ed79c43","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":155,"deletions":5,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -33,6 +33,7 @@\n import java.util.HashMap;\n import java.util.Collections;\n import java.util.Random;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.jboss.netty.buffer.ChannelBuffer;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -41,6 +42,7 @@\n import org.apache.bookkeeper.test.BaseTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -159,6 +161,15 @@ public void tearDown() throws Exception {\n         return lhs;\n     }\n \n+    private List<LedgerHandle> openLedgers(List<LedgerHandle> oldLhs)\n+            throws Exception {\n+        List<LedgerHandle> newLhs = new ArrayList<LedgerHandle>();\n+        for (LedgerHandle oldLh : oldLhs) {\n+            newLhs.add(bkc.openLedger(oldLh.getId(), digestType, baseClientConf.getBookieRecoveryPasswd()));\n+        }\n+        return newLhs;\n+    }\n+\n     /**\n      * Helper method to write dummy ledger entries to all of the ledgers passed.\n      *\n@@ -171,15 +182,22 @@ public void tearDown() throws Exception {\n      * @throws BKException\n      * @throws InterruptedException\n      */\n-    private void writeEntriestoLedgers(int numEntries, long startEntryId, List<LedgerHandle> lhs) throws BKException,\n-        InterruptedException {\n+    private void writeEntriestoLedgers(int numEntries, long startEntryId,\n+                                       List<LedgerHandle> lhs)\n+        throws BKException, InterruptedException {\n         for (LedgerHandle lh : lhs) {\n             for (int i = 0; i < numEntries; i++) {\n                 lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (startEntryId + i)).getBytes());\n             }\n         }\n     }\n \n+    private void closeLedgers(List<LedgerHandle> lhs) throws BKException, InterruptedException {\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+    }\n+\n     /**\n      * Helper method to verify that we can read the recovered ledger entries.\n      *\n@@ -507,6 +525,140 @@ private boolean findDupesInEnsembles(List<LedgerHandle> lhs) throws Exception {\n         return numDupes > 0;\n     }\n \n+    /**\n+     * Test recoverying the closed ledgers when the failed bookie server is in the last ensemble\n+     */\n+    @Test\n+    public void testBookieRecoveryOnClosedLedgers() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n+\n+        // Write the entries for the ledgers with dummy values\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        closeLedgers(lhs);\n+\n+        // Shutdown last bookie server in last ensemble\n+        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+                                                       .entrySet().iterator().next().getValue();\n+        InetSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n+        killBookie(bookieToKill);\n+\n+        // start a new bookie\n+        startNewBookie();\n+\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieToKill\n+               + \") and replicate it to a random available one\");\n+\n+        bkAdmin.recoverBookieData(bookieToKill, bookieDest);\n+        for (LedgerHandle lh : lhs) {\n+            assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs));\n+            lh.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testBookieRecoveryOnOpenedLedgers() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n+\n+        // Write the entries for the ledgers with dummy values\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+                                                       .entrySet().iterator().next().getValue();\n+        InetSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n+        killBookie(bookieToKill);\n+\n+        // start a new bookie\n+        startNewBookie();\n+\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieToKill\n+               + \") and replicate it to a random available one\");\n+\n+        bkAdmin.recoverBookieData(bookieToKill, bookieDest);\n+\n+        for (LedgerHandle lh : lhs) {\n+            assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs));\n+        }\n+\n+        try {\n+            // we can't write entries\n+            writeEntriestoLedgers(numMsgs, 0, lhs);\n+            fail(\"should not reach here\");\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testBookieRecoveryOnInRecoveryLedger() throws Exception {\n+        int numMsgs = 10;\n+        // Create the ledgers\n+        int numLedgers = 1;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, 2, 2);\n+\n+        // Write the entries for the ledgers with dummy values\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+                                                       .entrySet().iterator().next().getValue();\n+        // removed bookie\n+        InetSocketAddress bookieToKill = lastEnsemble.get(0);\n+        killBookie(bookieToKill);\n+        // temp failure\n+        InetSocketAddress bookieToKill2 = lastEnsemble.get(1);\n+        ServerConfiguration conf2 = killBookie(bookieToKill2);\n+\n+        // start a new bookie\n+        startNewBookie();\n+\n+        // open these ledgers\n+        for (LedgerHandle oldLh : lhs) {\n+            try {\n+                bkc.openLedger(oldLh.getId(), digestType, baseClientConf.getBookieRecoveryPasswd());\n+                fail(\"Should have thrown exception\");\n+            } catch (Exception e) {\n+            }\n+        }\n+\n+        try {\n+            bkAdmin.recoverBookieData(bookieToKill, null);\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKLedgerRecoveryException bke) {\n+            // correct behaviour\n+        }\n+\n+        // restart failed bookie\n+        bs.add(startBookie(conf2));\n+        bsConfs.add(conf2);\n+\n+        // recover them\n+        bkAdmin.recoverBookieData(bookieToKill, null);\n+\n+        for (LedgerHandle lh : lhs) {\n+            assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs));\n+        }\n+\n+        // open ledgers to read metadata\n+        List<LedgerHandle> newLhs = openLedgers(lhs);\n+        for (LedgerHandle newLh : newLhs) {\n+            // first ensemble should contains bookieToKill2 and not contain bookieToKill\n+            Map.Entry<Long, ArrayList<InetSocketAddress>> entry =\n+                newLh.getLedgerMetadata().getEnsembles().entrySet().iterator().next();\n+            assertFalse(entry.getValue().contains(bookieToKill));\n+            assertTrue(entry.getValue().contains(bookieToKill2));\n+        }\n+\n+    }\n+\n     @Test\n     public void testAsyncBookieRecoveryToRandomBookiesNotEnoughBookies() throws Exception {\n         // Create the ledgers\n@@ -575,9 +727,7 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n             writeEntriestoLedgers(numMsgs, numMsgs*2, lhs);\n             for (LedgerHandle lh : lhs) {\n                 assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs*3));\n-                // TODO (BOOKKEEPER-112) this throws an exception at the moment \n-                // because recovering a ledger updates the ledger znode\n-                //lh.close();\n+                lh.close();\n             }\n         }\n     }"},{"sha":"c5350ada9d10381641b620aeab98d1f4fa623fab","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -269,16 +269,18 @@ public void testFencingInteractionWithBookieRecovery() throws Exception {\n         InetSocketAddress bookieToKill \n             = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n         killBookie(bookieToKill);\n+\n+        // write entries to change ensemble\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n         admin.recoverBookieData(bookieToKill, null);\n         \n-        /* TODO: uncomment this when BOOKKEEPER-112 is\n-           fixed\n-           \n         for (int i = 0; i < numEntries; i++) {\n             writelh.addEntry(tmp.getBytes());\n         }\n-        */\n-        \n+\n         LedgerHandle readlh = bkc.openLedger(writelh.getId(), \n                                              digestType, \"testPasswd\".getBytes());\n         try {"},{"sha":"c172224b82f3f65f64344ce7520d68ed12ffe519","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":8,"deletions":5,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -169,9 +169,10 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n      *\n      * @param addr\n      *          Socket Address\n+     * @return the configuration of killed bookie\n      * @throws InterruptedException\n      */\n-    public void killBookie(InetSocketAddress addr) throws InterruptedException {\n+    public ServerConfiguration killBookie(InetSocketAddress addr) throws InterruptedException {\n         BookieServer toRemove = null;\n         int toRemoveIndex = 0;\n         for (BookieServer server : bs) {\n@@ -184,26 +185,28 @@ public void killBookie(InetSocketAddress addr) throws InterruptedException {\n         }\n         if (toRemove != null) {\n             bs.remove(toRemove);\n-            bsConfs.remove(toRemoveIndex);\n+            return bsConfs.remove(toRemoveIndex);\n         }\n+        return null;\n     }\n \n     /**\n      * Kill a bookie by index\n      *\n      * @param index\n      *          Bookie Index\n+     * @return the configuration of killed bookie\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public void killBookie(int index) throws InterruptedException, IOException {\n+    public ServerConfiguration killBookie(int index) throws InterruptedException, IOException {\n         if (index >= bs.size()) {\n             throw new IOException(\"Bookie does not exist\");\n         }\n         BookieServer server = bs.get(index);\n         server.shutdown();\n         bs.remove(server);\n-        bsConfs.remove(index);\n+        return bsConfs.remove(index);\n     }\n \n     /**\n@@ -318,7 +321,7 @@ public int startNewBookie()\n      *            Server Configuration Object\n      *\n      */\n-    private BookieServer startBookie(ServerConfiguration conf)\n+    protected BookieServer startBookie(ServerConfiguration conf)\n             throws IOException, InterruptedException, KeeperException, BookieException {\n         BookieServer server = new BookieServer(conf);\n         server.start();"},{"sha":"eaea75e2cddd8d7137a9ba1742055eff755c7c81","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java?ref=682a23fb23c8de7756d5ef226fd6e97dd8d4e561","patch":"@@ -72,4 +72,29 @@ public void testClose() throws Exception {\n             lh[i].close();\n         }\n     }\n+\n+    @Test\n+    public void testCloseByOthers() throws Exception {\n+\n+        int numLedgers = 1;\n+        int numMsgs = 10;\n+\n+        LedgerHandle lh = bkc.createLedger(digestType, \"\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+\n+        /*\n+         * Write 10 entries to lh.\n+         */\n+        for (int i = 0; i < numMsgs; i++) {\n+            lh.addEntry(tmp.getBytes());\n+        }\n+\n+        // other one close the entries\n+        LedgerHandle lh2 = bkc.openLedger(lh.getId(), digestType, \"\".getBytes());\n+\n+        // so the ledger would be closed, the metadata is changed\n+        // the original ledger handle should be able to close it successfully\n+        lh2.close();\n+    }\n }"}]}

