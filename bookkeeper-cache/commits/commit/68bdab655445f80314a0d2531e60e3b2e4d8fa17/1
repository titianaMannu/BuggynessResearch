{"sha":"68bdab655445f80314a0d2531e60e3b2e4d8fa17","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2OGJkYWI2NTU0NDVmODAzMTRhMGQyNTMxZTYwZTNiMmU0ZDhmYTE3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-10-27T16:26:18Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-10-27T16:26:18Z"},"message":"BOOKKEEPER-89: Bookkeeper API changes for initial Bookkeeper release (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1189842 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"09c24a016b25e26d5c4aa969a0cc5dcbea768cf5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/09c24a016b25e26d5c4aa969a0cc5dcbea768cf5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/68bdab655445f80314a0d2531e60e3b2e4d8fa17","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/68bdab655445f80314a0d2531e60e3b2e4d8fa17","html_url":"https://github.com/apache/bookkeeper/commit/68bdab655445f80314a0d2531e60e3b2e4d8fa17","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/68bdab655445f80314a0d2531e60e3b2e4d8fa17/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c898d53ab269fbd64cb00919808c7bb0c52c53a6","url":"https://api.github.com/repos/apache/bookkeeper/commits/c898d53ab269fbd64cb00919808c7bb0c52c53a6","html_url":"https://github.com/apache/bookkeeper/commit/c898d53ab269fbd64cb00919808c7bb0c52c53a6"}],"stats":{"total":1797,"additions":912,"deletions":885},"files":[{"sha":"ee539c2889476ce02c44ddd687ff4c072e9a47f2","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -54,6 +54,8 @@ BUGFIXES:\n \n   BOOKKEEPER-83: Added versioning and flags to the bookie protocol (ivank)\n \n+  BOOKKEEPER-89: Bookkeeper API changes for initial Bookkeeper release (ivank)\n+\n  hedwig-server/\n \n   BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)"},{"sha":"600dff0bd73fb35b2ad9908883cff856bd7a1113","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"modified","additions":4,"deletions":6,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -111,7 +111,7 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         void deleteComplete(int rc, Object ctx);\n     }\n \n-    public interface RecoverCallback {\n+    public interface ReadLastConfirmedCallback {\n         /**\n          * Callback definition for bookie recover operations\n          *\n@@ -120,10 +120,10 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n          * @param ctx\n          *          control object\n          */\n-        void recoverComplete(int rc, Object ctx);\n+        void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n     }\n \n-    public interface ReadLastConfirmedCallback {\n+    public interface RecoverCallback {\n         /**\n          * Callback definition for bookie recover operations\n          *\n@@ -132,8 +132,6 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n          * @param ctx\n          *          control object\n          */\n-        void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n+        void recoverComplete(int rc, Object ctx);\n     }\n-\n-\n }"},{"sha":"a1fbab7ee7385500f4ac8d750c1d3c158c0df0a2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":73,"deletions":62,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -51,7 +51,7 @@\n  *\n  */\n \n-public class BookKeeper implements OpenCallback, CreateCallback, DeleteCallback {\n+public class BookKeeper {\n \n     static final Logger LOG = Logger.getLogger(BookKeeper.class);\n \n@@ -154,7 +154,7 @@ public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n         MAC, CRC32\n     };\n \n-    public ZooKeeper getZkHandle() {\n+    ZooKeeper getZkHandle() {\n         return zk;\n     }\n \n@@ -163,7 +163,7 @@ public ZooKeeper getZkHandle() {\n      *\n      * @return BookieClient for the BookKeeper instance.\n      */\n-    public BookieClient getBookieClient() {\n+    BookieClient getBookieClient() {\n         return bookieClient;\n     }\n \n@@ -198,22 +198,6 @@ public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,\n \n     }\n \n-    /**\n-     * Create callback implementation for synchronous create call.\n-     *\n-     * @param rc\n-     *          return code\n-     * @param lh\n-     *          ledger handle object\n-     * @param ctx\n-     *          optional control object\n-     */\n-    public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n-        SyncCounter counter = (SyncCounter) ctx;\n-        counter.setLh(lh);\n-        counter.setrc(rc);\n-        counter.dec();\n-    }\n \n     /**\n      * Creates a new ledger. Default of 3 servers, and quorum of 2 servers.\n@@ -223,12 +207,11 @@ public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n      * @param passwd\n      *          password\n      * @return\n-     * @throws KeeperException\n      * @throws InterruptedException\n      * @throws BKException\n      */\n     public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n-            throws KeeperException, BKException, InterruptedException, IOException {\n+            throws BKException, InterruptedException {\n         return createLedger(3, 2, digestType, passwd);\n     }\n \n@@ -241,20 +224,19 @@ public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n      * @param digestType\n      * @param passwd\n      * @return\n-     * @throws KeeperException\n      * @throws InterruptedException\n-     * @throws IOException\n      * @throws BKException\n      */\n     public LedgerHandle createLedger(int ensSize, int qSize,\n-                                     DigestType digestType, byte passwd[]) throws KeeperException,\n-        InterruptedException, IOException, BKException {\n+                                     DigestType digestType, byte passwd[]) \n+            throws InterruptedException, BKException {\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n         /*\n          * Calls asynchronous version\n          */\n-        asyncCreateLedger(ensSize, qSize, digestType, passwd, this, counter);\n+        asyncCreateLedger(ensSize, qSize, digestType, passwd, \n+                          new SyncCreateCallback(), counter);\n \n         /*\n          * Wait\n@@ -312,25 +294,6 @@ public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte pass\n \n     }\n \n-    /**\n-     * Callback method for synchronous open operation\n-     *\n-     * @param rc\n-     *          return code\n-     * @param lh\n-     *          ledger handle\n-     * @param ctx\n-     *          optional control object\n-     */\n-    public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n-        SyncCounter counter = (SyncCounter) ctx;\n-        counter.setLh(lh);\n-\n-        LOG.debug(\"Open complete: \" + rc);\n-\n-        counter.setrc(rc);\n-        counter.dec();\n-    }\n \n     /**\n      * Synchronous open ledger call\n@@ -354,7 +317,7 @@ public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n         /*\n          * Calls async open ledger\n          */\n-        asyncOpenLedger(lId, digestType, passwd, this, counter);\n+        asyncOpenLedger(lId, digestType, passwd, new SyncOpenCallback(), counter);\n \n         /*\n          * Wait\n@@ -388,7 +351,8 @@ public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte p\n         /*\n          * Calls async open ledger\n          */\n-        asyncOpenLedgerNoRecovery(lId, digestType, passwd, this, counter);\n+        asyncOpenLedgerNoRecovery(lId, digestType, passwd,\n+                                  new SyncOpenCallback(), counter);\n \n         /*\n          * Wait\n@@ -414,19 +378,6 @@ public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) {\n         new LedgerDeleteOp(this, lId, cb, ctx).initiate();\n     }\n \n-    /**\n-     * Delete callback implementation for synchronous delete call.\n-     *\n-     * @param rc\n-     *            return code\n-     * @param ctx\n-     *            optional control object\n-     */\n-    public void deleteComplete(int rc, Object ctx) {\n-        SyncCounter counter = (SyncCounter) ctx;\n-        counter.setrc(rc);\n-        counter.dec();\n-    }\n \n     /**\n      * Synchronous call to delete a ledger. Parameters match those of\n@@ -441,7 +392,7 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n         // Call asynchronous version\n-        asyncDeleteLedger(lId, this, counter);\n+        asyncDeleteLedger(lId, new SyncDeleteCallback(), counter);\n         // Wait\n         counter.block(0);\n         if (counter.getrc() != KeeperException.Code.OK.intValue()) {\n@@ -454,7 +405,7 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n      * Shuts down client.\n      *\n      */\n-    public void halt() throws InterruptedException {\n+    public void close() throws InterruptedException, BKException {\n         bookieClient.close();\n         bookieWatcher.halt();\n         if (ownChannelFactory) {\n@@ -466,4 +417,64 @@ public void halt() throws InterruptedException {\n         callbackWorker.shutdown();\n         mainWorkerPool.shutdown();\n     }\n+\n+    private static class SyncCreateCallback implements CreateCallback {\n+        /**\n+         * Create callback implementation for synchronous create call.\n+         *\n+         * @param rc\n+         *          return code\n+         * @param lh\n+         *          ledger handle object\n+         * @param ctx\n+         *          optional control object\n+         */\n+        public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n+            SyncCounter counter = (SyncCounter) ctx;\n+            counter.setLh(lh);\n+            counter.setrc(rc);\n+            counter.dec();\n+        }\n+    }\n+\n+    private static class SyncOpenCallback implements OpenCallback {\n+        /**\n+         * Callback method for synchronous open operation\n+         *\n+         * @param rc\n+         *          return code\n+         * @param lh\n+         *          ledger handle\n+         * @param ctx\n+         *          optional control object\n+         */\n+        public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+            SyncCounter counter = (SyncCounter) ctx;\n+            counter.setLh(lh);\n+            \n+            LOG.debug(\"Open complete: \" + rc);\n+            \n+            counter.setrc(rc);\n+            counter.dec();\n+        }\n+    }\n+\n+    private static class SyncDeleteCallback implements DeleteCallback {\n+        /**\n+         * Delete callback implementation for synchronous delete call.\n+         *\n+         * @param rc\n+         *            return code\n+         * @param ctx\n+         *            optional control object\n+         */\n+        public void deleteComplete(int rc, Object ctx) {\n+            SyncCounter counter = (SyncCounter) ctx;\n+            counter.setrc(rc);\n+            counter.dec();\n+        }\n+    }\n+\n+\n+\n }"},{"sha":"b3eb5b986c970d616f834945731ce0aa57049734","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"added","additions":714,"deletions":0,"changes":714,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -0,0 +1,714 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.data.Stat;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * Admin client for BookKeeper clusters\n+ */\n+public class BookKeeperAdmin {\n+    private static Logger LOG = Logger.getLogger(BookKeeperAdmin.class);\n+\n+    static final String COLON = \":\";\n+\n+    // ZK client instance\n+    private ZooKeeper zk;\n+    // ZK ledgers related String constants\n+    static final String LEDGERS_PATH = \"/ledgers\";\n+    static final String LEDGER_NODE_PREFIX = \"L\";\n+    static final String AVAILABLE_NODE = \"available\";\n+    static final String BOOKIES_PATH = LEDGERS_PATH + \"/\" + AVAILABLE_NODE;\n+\n+    // BookKeeper client instance\n+    private BookKeeper bkc;\n+\n+    /*\n+     * Random number generator used to choose an available bookie server to\n+     * replicate data from a dead bookie.\n+     */\n+    private Random rand = new Random();\n+\n+    /*\n+     * For now, assume that all ledgers were created with the same DigestType\n+     * and password. In the future, this admin tool will need to know for each\n+     * ledger, what was the DigestType and password used to create it before it\n+     * can open it. These values will come from System properties, though hard\n+     * coded defaults are defined here.\n+     */\n+    private DigestType DIGEST_TYPE = DigestType.valueOf(System.getProperty(\"digestType\", DigestType.CRC32.toString()));\n+    private byte[] PASSWD = System.getProperty(\"passwd\", \"\").getBytes();\n+\n+    /**\n+     * Constructor that takes in a ZooKeeper servers connect string so we know\n+     * how to connect to ZooKeeper to retrieve information about the BookKeeper\n+     * cluster. We need this before we can do any type of admin operations on\n+     * the BookKeeper cluster.\n+     *\n+     * @param zkServers\n+     *            Comma separated list of hostname:port pairs for the ZooKeeper\n+     *            servers cluster.\n+     * @throws IOException\n+     *             throws this exception if there is an error instantiating the\n+     *             ZooKeeper client.\n+     * @throws InterruptedException\n+     *             Throws this exception if there is an error instantiating the\n+     *             BookKeeper client.\n+     * @throws KeeperException\n+     *             Throws this exception if there is an error instantiating the\n+     *             BookKeeper client.\n+     */\n+    public BookKeeperAdmin(String zkServers) throws IOException, InterruptedException, KeeperException {\n+        // Create the ZooKeeper client instance\n+        zk = new ZooKeeper(zkServers, 10000, new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n+                }\n+            }\n+        });\n+        // Create the BookKeeper client instance\n+        bkc = new BookKeeper(zk);\n+    }\n+\n+    /**\n+     * Gracefully release resources that this client uses.\n+     *\n+     * @throws InterruptedException\n+     *             if there is an error shutting down the clients that this\n+     *             class uses.\n+     */\n+    public void close() throws InterruptedException, BKException {\n+        bkc.close();\n+        zk.close();\n+    }\n+\n+    /**\n+     * This is a multi callback object for bookie recovery that waits for all of\n+     * the multiple async operations to complete. If any fail, then we invoke\n+     * the final callback with a BK LedgerRecoveryException.\n+     */\n+    class MultiCallback implements AsyncCallback.VoidCallback {\n+        // Number of expected callbacks\n+        final int expected;\n+        // Final callback and the corresponding context to invoke\n+        final AsyncCallback.VoidCallback cb;\n+        final Object context;\n+        // This keeps track of how many operations have completed\n+        final AtomicInteger done = new AtomicInteger();\n+        // List of the exceptions from operations that completed unsuccessfully\n+        final LinkedBlockingQueue<Integer> exceptions = new LinkedBlockingQueue<Integer>();\n+\n+        MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context) {\n+            this.expected = expected;\n+            this.cb = cb;\n+            this.context = context;\n+            if (expected == 0) {\n+                cb.processResult(Code.OK.intValue(), null, context);\n+            }\n+        }\n+\n+        private void tick() {\n+            if (done.incrementAndGet() == expected) {\n+                if (exceptions.isEmpty()) {\n+                    cb.processResult(Code.OK.intValue(), null, context);\n+                } else {\n+                    cb.processResult(BKException.Code.LedgerRecoveryException, null, context);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void processResult(int rc, String path, Object ctx) {\n+            if (rc != Code.OK.intValue()) {\n+                LOG.error(\"BK error recovering ledger data\", BKException.create(rc));\n+                exceptions.add(rc);\n+            }\n+            tick();\n+        }\n+\n+    }\n+\n+    /**\n+     * Method to get the input ledger's digest type. For now, this is just a\n+     * placeholder function since there is no way we can get this information\n+     * easily. In the future, BookKeeper should store this ledger metadata\n+     * somewhere such that an admin tool can access it.\n+     *\n+     * @param ledgerId\n+     *            LedgerId we are retrieving the digestType for.\n+     * @return DigestType for the input ledger\n+     */\n+    private DigestType getLedgerDigestType(long ledgerId) {\n+        return DIGEST_TYPE;\n+    }\n+\n+    /**\n+     * Method to get the input ledger's password. For now, this is just a\n+     * placeholder function since there is no way we can get this information\n+     * easily. In the future, BookKeeper should store this ledger metadata\n+     * somewhere such that an admin tool can access it.\n+     *\n+     * @param ledgerId\n+     *            LedgerId we are retrieving the password for.\n+     * @return Password for the input ledger\n+     */\n+    private byte[] getLedgerPasswd(long ledgerId) {\n+        return PASSWD;\n+    }\n+\n+    // Object used for calling async methods and waiting for them to complete.\n+    class SyncObject {\n+        boolean value;\n+\n+        public SyncObject() {\n+            value = false;\n+        }\n+    }\n+\n+    /**\n+     * Synchronous method to rebuild and recover the ledger fragments data that\n+     * was stored on the source bookie. That bookie could have failed completely\n+     * and now the ledger data that was stored on it is under replicated. An\n+     * optional destination bookie server could be given if we want to copy all\n+     * of the ledger fragments data on the failed source bookie to it.\n+     * Otherwise, we will just randomly distribute the ledger fragments to the\n+     * active set of bookies, perhaps based on load. All ZooKeeper ledger\n+     * metadata will be updated to point to the new bookie(s) that contain the\n+     * replicated ledger fragments.\n+     *\n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     */\n+    public void recoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest)\n+            throws InterruptedException {\n+        SyncObject sync = new SyncObject();\n+        // Call the async method to recover bookie data.\n+        asyncRecoverBookieData(bookieSrc, bookieDest, new RecoverCallback() {\n+            @Override\n+            public void recoverComplete(int rc, Object ctx) {\n+                LOG.info(\"Recover bookie operation completed with rc: \" + rc);\n+                SyncObject syncObj = (SyncObject) ctx;\n+                synchronized (syncObj) {\n+                    syncObj.value = true;\n+                    syncObj.notify();\n+                }\n+            }\n+        }, sync);\n+\n+        // Wait for the async method to complete.\n+        synchronized (sync) {\n+            while (sync.value == false) {\n+                sync.wait();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Async method to rebuild and recover the ledger fragments data that was\n+     * stored on the source bookie. That bookie could have failed completely and\n+     * now the ledger data that was stored on it is under replicated. An\n+     * optional destination bookie server could be given if we want to copy all\n+     * of the ledger fragments data on the failed source bookie to it.\n+     * Otherwise, we will just randomly distribute the ledger fragments to the\n+     * active set of bookies, perhaps based on load. All ZooKeeper ledger\n+     * metadata will be updated to point to the new bookie(s) that contain the\n+     * replicated ledger fragments.\n+     *\n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     * @param cb\n+     *            RecoverCallback to invoke once all of the data on the dead\n+     *            bookie has been recovered and replicated.\n+     * @param context\n+     *            Context for the RecoverCallback to call.\n+     */\n+    public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+                                       final RecoverCallback cb, final Object context) {\n+        // Sync ZK to make sure we're reading the latest bookie/ledger data.\n+        zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error syncing: \", KeeperException.create(KeeperException.Code.get(rc), path));\n+                    cb.recoverComplete(BKException.Code.ZKException, context);\n+                    return;\n+                }\n+                getAvailableBookies(bookieSrc, bookieDest, cb, context);\n+            };\n+        }, null);\n+    }\n+\n+    /**\n+     * This method asynchronously gets the set of available Bookies that the\n+     * dead input bookie's data will be copied over into. If the user passed in\n+     * a specific destination bookie, then just use that one. Otherwise, we'll\n+     * randomly pick one of the other available bookies to use for each ledger\n+     * fragment we are replicating.\n+     *\n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     * @param cb\n+     *            RecoverCallback to invoke once all of the data on the dead\n+     *            bookie has been recovered and replicated.\n+     * @param context\n+     *            Context for the RecoverCallback to call.\n+     */\n+    private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+                                     final RecoverCallback cb, final Object context) {\n+        final List<InetSocketAddress> availableBookies = new LinkedList<InetSocketAddress>();\n+        if (bookieDest != null) {\n+            availableBookies.add(bookieDest);\n+            // Now poll ZK to get the active ledgers\n+            getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n+        } else {\n+            zk.getChildren(BOOKIES_PATH, null, new AsyncCallback.ChildrenCallback() {\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, List<String> children) {\n+                    if (rc != Code.OK.intValue()) {\n+                        LOG.error(\"ZK error getting bookie nodes: \", KeeperException.create(KeeperException.Code\n+                                  .get(rc), path));\n+                        cb.recoverComplete(BKException.Code.ZKException, context);\n+                        return;\n+                    }\n+                    for (String bookieNode : children) {\n+                        String parts[] = bookieNode.split(COLON);\n+                        if (parts.length < 2) {\n+                            LOG.error(\"Bookie Node retrieved from ZK has invalid name format: \" + bookieNode);\n+                            cb.recoverComplete(BKException.Code.ZKException, context);\n+                            return;\n+                        }\n+                        availableBookies.add(new InetSocketAddress(parts[0], Integer.parseInt(parts[1])));\n+                    }\n+                    // Now poll ZK to get the active ledgers\n+                    getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n+                }\n+            }, null);\n+        }\n+    }\n+\n+    /**\n+     * This method asynchronously polls ZK to get the current set of active\n+     * ledgers. From this, we can open each ledger and look at the metadata to\n+     * determine if any of the ledger fragments for it were stored at the dead\n+     * input bookie.\n+     *\n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     * @param cb\n+     *            RecoverCallback to invoke once all of the data on the dead\n+     *            bookie has been recovered and replicated.\n+     * @param context\n+     *            Context for the RecoverCallback to call.\n+     * @param availableBookies\n+     *            List of Bookie Servers that are available to use for\n+     *            replicating data on the failed bookie. This could contain a\n+     *            single bookie server if the user explicitly chose a bookie\n+     *            server to replicate data to.\n+     */\n+    private void getActiveLedgers(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+                                  final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n+        zk.getChildren(LEDGERS_PATH, null, new AsyncCallback.ChildrenCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, List<String> children) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error getting ledger nodes: \", KeeperException.create(KeeperException.Code.get(rc),\n+                              path));\n+                    cb.recoverComplete(BKException.Code.ZKException, context);\n+                    return;\n+                }\n+                // Wrapper class around the RecoverCallback so it can be used\n+                // as the final VoidCallback to invoke within the MultiCallback.\n+                class RecoverCallbackWrapper implements AsyncCallback.VoidCallback {\n+                    final RecoverCallback cb;\n+\n+                    RecoverCallbackWrapper(RecoverCallback cb) {\n+                        this.cb = cb;\n+                    }\n+\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx) {\n+                        cb.recoverComplete(rc, ctx);\n+                    }\n+                }\n+                // Recover each of the ledgers asynchronously\n+                MultiCallback ledgerMcb = new MultiCallback(children.size(), new RecoverCallbackWrapper(cb), context);\n+                for (final String ledgerNode : children) {\n+                    recoverLedger(bookieSrc, ledgerNode, ledgerMcb, availableBookies);\n+                }\n+            }\n+        }, null);\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a given ledger if any of the ledger\n+     * entries were stored on the failed bookie.\n+     *\n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param ledgerNode\n+     *            Ledger Node name as retrieved from ZooKeeper we want to\n+     *            recover.\n+     * @param ledgerMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger.\n+     * @param availableBookies\n+     *            List of Bookie Servers that are available to use for\n+     *            replicating data on the failed bookie. This could contain a\n+     *            single bookie server if the user explicitly chose a bookie\n+     *            server to replicate data to.\n+     */\n+    private void recoverLedger(final InetSocketAddress bookieSrc, final String ledgerNode,\n+                               final MultiCallback ledgerMcb, final List<InetSocketAddress> availableBookies) {\n+        /*\n+         * The available node is also stored in this path so ignore that. That\n+         * node is the path for the set of available Bookie Servers.\n+         */\n+        if (ledgerNode.equals(AVAILABLE_NODE)) {\n+            ledgerMcb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n+        // Parse out the ledgerId from the ZK ledger node.\n+        String parts[] = ledgerNode.split(LEDGER_NODE_PREFIX);\n+        if (parts.length < 2) {\n+            LOG.error(\"Ledger Node retrieved from ZK has invalid name format: \" + ledgerNode);\n+            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n+            return;\n+        }\n+        final long lId;\n+        try {\n+            lId = Long.parseLong(parts[parts.length - 1]);\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Error retrieving ledgerId from ledgerNode: \" + ledgerNode, e);\n+            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n+            return;\n+        }\n+        /*\n+         * For the current ledger, open it to retrieve the LedgerHandle. This\n+         * will contain the LedgerMetadata indicating which bookie servers the\n+         * ledger fragments are stored on. Check if any of the ledger fragments\n+         * for the current ledger are stored on the input dead bookie.\n+         */\n+        DigestType digestType = getLedgerDigestType(lId);\n+        byte[] passwd = getLedgerPasswd(lId);\n+        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n+            @Override\n+            public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"BK error opening ledger: \" + lId, BKException.create(rc));\n+                    ledgerMcb.processResult(rc, null, null);\n+                    return;\n+                }\n+                /*\n+                 * This List stores the ledger fragments to recover indexed by\n+                 * the start entry ID for the range. The ensembles TreeMap is\n+                 * keyed off this.\n+                 */\n+                final List<Long> ledgerFragmentsToRecover = new LinkedList<Long>();\n+                /*\n+                 * This Map will store the start and end entry ID values for\n+                 * each of the ledger fragment ranges. The only exception is the\n+                 * current active fragment since it has no end yet. In the event\n+                 * of a bookie failure, a new ensemble is created so the current\n+                 * ensemble should not contain the dead bookie we are trying to\n+                 * recover.\n+                 */\n+                Map<Long, Long> ledgerFragmentsRange = new HashMap<Long, Long>();\n+                Long curEntryId = null;\n+                for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n+                .entrySet()) {\n+                    if (curEntryId != null)\n+                        ledgerFragmentsRange.put(curEntryId, entry.getKey() - 1);\n+                    curEntryId = entry.getKey();\n+                    if (entry.getValue().contains(bookieSrc)) {\n+                        /*\n+                         * Current ledger fragment has entries stored on the\n+                         * dead bookie so we'll need to recover them.\n+                         */\n+                        ledgerFragmentsToRecover.add(entry.getKey());\n+                    }\n+                }\n+                /*\n+                 * See if this current ledger contains any ledger fragment that\n+                 * needs to be re-replicated. If not, then just invoke the\n+                 * multiCallback and return.\n+                 */\n+                if (ledgerFragmentsToRecover.size() == 0) {\n+                    ledgerMcb.processResult(BKException.Code.OK, null, null);\n+                    return;\n+                }\n+                /*\n+                 * We have ledger fragments that need to be re-replicated to a\n+                 * new bookie. Choose one randomly from the available set of\n+                 * bookies.\n+                 */\n+                final InetSocketAddress newBookie = availableBookies.get(rand.nextInt(availableBookies.size()));\n+\n+                /*\n+                 * Wrapper class around the ledger MultiCallback. Once all\n+                 * ledger fragments for the ledger have been replicated to a new\n+                 * bookie, we need to update ZK with this new metadata to point\n+                 * to the new bookie instead of the old dead one. That should be\n+                 * done at the end prior to invoking the ledger MultiCallback.\n+                 */\n+                class LedgerMultiCallbackWrapper implements AsyncCallback.VoidCallback {\n+                    final MultiCallback ledgerMcb;\n+\n+                    LedgerMultiCallbackWrapper(MultiCallback ledgerMcb) {\n+                        this.ledgerMcb = ledgerMcb;\n+                    }\n+\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"BK error replicating ledger fragments for ledger: \" + lId, BKException\n+                                      .create(rc));\n+                            ledgerMcb.processResult(rc, null, null);\n+                            return;\n+                        }\n+                        /*\n+                         * Update the ledger metadata's ensemble info to point\n+                         * to the new bookie.\n+                         */\n+                        for (final Long startEntryId : ledgerFragmentsToRecover) {\n+                            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().get(\n+                                    startEntryId);\n+                            int deadBookieIndex = ensemble.indexOf(bookieSrc);\n+                            ensemble.remove(deadBookieIndex);\n+                            ensemble.add(deadBookieIndex, newBookie);\n+                        }\n+                        \n+                        lh.writeLedgerConfig(new AsyncCallback.StatCallback() {\n+                            @Override\n+                            public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                                if (rc != Code.OK.intValue()) {\n+                                    LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n+                                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                                } else {\n+                                    lh.getLedgerMetadata().updateZnodeStatus(stat);\n+                                    LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId()\n+                                             + \") to point ledger fragments from old dead bookie: (\" + bookieSrc\n+                                             + \") to new bookie: (\" + newBookie + \")\");\n+                                }\n+                                /*\n+                                 * Pass the return code result up the chain with\n+                                 * the parent callback.\n+                                 */\n+                                ledgerMcb.processResult(rc, null, null);\n+                            }\n+                        }, null);\n+                    }\n+                }\n+\n+                /*\n+                 * Now recover all of the necessary ledger fragments\n+                 * asynchronously using a MultiCallback for every fragment.\n+                 */\n+                MultiCallback ledgerFragmentMcb = new MultiCallback(ledgerFragmentsToRecover.size(),\n+                        new LedgerMultiCallbackWrapper(ledgerMcb), null);\n+                for (final Long startEntryId : ledgerFragmentsToRecover) {\n+                    Long endEntryId = ledgerFragmentsRange.get(startEntryId);\n+                    try {\n+                        recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, ledgerFragmentMcb, newBookie);\n+                    } catch(InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        return;\n+                    }\n+                }\n+            }\n+        }, null);\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a ledger fragment which is a\n+     * contiguous portion of a ledger that was stored in an ensemble that\n+     * included the failed bookie.\n+     *\n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param startEntryId\n+     *            Start entry Id for the ledger fragment\n+     * @param endEntryId\n+     *            End entry Id for the ledger fragment\n+     * @param ledgerFragmentMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger fragment.\n+     * @param newBookie\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final LedgerHandle lh,\n+                                       final Long startEntryId, final Long endEntryId, final MultiCallback ledgerFragmentMcb,\n+                                       final InetSocketAddress newBookie) throws InterruptedException {\n+        if (endEntryId == null) {\n+            /*\n+             * Ideally this should never happen if bookie failure is taken care\n+             * of properly. Nothing we can do though in this case.\n+             */\n+            LOG.warn(\"Dead bookie (\" + bookieSrc + \") is still part of the current active ensemble for ledgerId: \"\n+                     + lh.getId());\n+            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n+\n+        ArrayList<InetSocketAddress> curEnsemble = lh.getLedgerMetadata().getEnsembles().get(startEntryId);\n+        int bookieIndex = 0;\n+        for (int i = 0; i < curEnsemble.size(); i++) {\n+            if (curEnsemble.get(i).equals(bookieSrc)) {\n+                bookieIndex = i;\n+                break;\n+            }\n+        }\n+        /*\n+         * Loop through all entries in the current ledger fragment range and\n+         * find the ones that were stored on the dead bookie.\n+         */\n+        List<Long> entriesToReplicate = new LinkedList<Long>();\n+        for (long i = startEntryId; i <= endEntryId; i++) {\n+            if (lh.getDistributionSchedule().getReplicaIndex(i, bookieIndex) >= 0) {\n+                /*\n+                 * Current entry is stored on the dead bookie so we'll need to\n+                 * read it and replicate it to a new bookie.\n+                 */\n+                entriesToReplicate.add(i);\n+            }\n+        }\n+        /*\n+         * Now asynchronously replicate all of the entries for the ledger\n+         * fragment that were on the dead bookie.\n+         */\n+        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(entriesToReplicate.size(), ledgerFragmentMcb, null);\n+        for (final Long entryId : entriesToReplicate) {\n+            recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb, newBookie);\n+        }\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a specific ledger entry by reading\n+     * the values via the BookKeeper Client (which would read it from the other\n+     * replicas) and then writing it to the chosen new bookie.\n+     *\n+     * @param entryId\n+     *            Ledger Entry ID to recover.\n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param ledgerFragmentEntryMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger entry.\n+     * @param newBookie\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n+                                            final MultiCallback ledgerFragmentEntryMcb, \n+                                            final InetSocketAddress newBookie) throws InterruptedException {\n+        /*\n+         * Read the ledger entry using the LedgerHandle. This will allow us to\n+         * read the entry from one of the other replicated bookies other than\n+         * the dead one.\n+         */\n+        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {\n+            @Override\n+            public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"BK error reading ledger entry: \" + entryId, BKException.create(rc));\n+                    ledgerFragmentEntryMcb.processResult(rc, null, null);\n+                    return;\n+                }\n+                /*\n+                 * Now that we've read the ledger entry, write it to the new\n+                 * bookie we've selected.\n+                 */\n+                LedgerEntry entry = seq.nextElement();\n+                byte[] data = entry.getEntry();\n+                ChannelBuffer toSend = lh.getDigestManager().computeDigestAndPackageForSending(entryId,\n+                                       lh.getLastAddConfirmed(), entry.getLength(), data, 0, data.length);\n+                bkc.getBookieClient().addEntry(newBookie, lh.getId(), lh.getLedgerKey(), entryId, toSend,\n+                new WriteCallback() {\n+                    @Override\n+                    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr,\n+                    Object ctx) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n+                                      + entryId + \", bookie: \" + addr, BKException.create(rc));\n+                        } else {\n+                            LOG.debug(\"Success writing ledger entry to a new bookie!\");\n+                        }\n+                        /*\n+                         * Pass the return code result up the chain with\n+                         * the parent callback.\n+                         */\n+                        ledgerFragmentEntryMcb.processResult(rc, null, null);\n+                    }\n+                }, null);\n+            }\n+        }, null);\n+    }\n+}"},{"sha":"97552e65a2e53e1ee64c2453f5f3ce20f9e093a3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -35,7 +35,7 @@\n  * for the packet. Currently 2 types of digests are supported: MAC (based on SHA-1) and CRC32\n  */\n \n-public abstract class DigestManager {\n+abstract class DigestManager {\n     static final Logger logger = Logger.getLogger(DigestManager.class);\n \n     static final int METADATA_LENGTH = 32;"},{"sha":"f2ed6bd15c6b2308d706e7164d69f91143f0c612","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -28,7 +28,7 @@\n  * to.\n  */\n \n-public interface DistributionSchedule {\n+interface DistributionSchedule {\n \n     /**\n      *"},{"sha":"350518b1cded5c4c4d0a7fd69fa52ae93ea05179","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":84,"deletions":78,"changes":162,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -52,7 +52,7 @@\n  * Ledger handle contains ledger metadata and is used to access the read and\n  * write operations to a ledger.\n  */\n-public class LedgerHandle implements ReadCallback, AddCallback, CloseCallback, ReadLastConfirmedCallback {\n+public class LedgerHandle {\n     final static Logger LOG = Logger.getLogger(LedgerHandle.class);\n     final static long LAST_ADD_CONFIRMED = -1;\n \n@@ -140,7 +140,7 @@ public long getLastAddPushed() {\n      *\n      * @return LedgerMetadata for the LedgerHandle\n      */\n-    public LedgerMetadata getLedgerMetadata() {\n+    LedgerMetadata getLedgerMetadata() {\n         return metadata;\n     }\n \n@@ -149,7 +149,7 @@ public LedgerMetadata getLedgerMetadata() {\n      *\n      * @return DigestManager for the LedgerHandle\n      */\n-    public DigestManager getDigestManager() {\n+    DigestManager getDigestManager() {\n         return macManager;\n     }\n \n@@ -187,11 +187,11 @@ public long getLength() {\n      *\n      * @return DistributionSchedule for the LedgerHandle\n      */\n-    public DistributionSchedule getDistributionSchedule() {\n+    DistributionSchedule getDistributionSchedule() {\n         return distributionSchedule;\n     }\n \n-    public void writeLedgerConfig(StatCallback callback, Object ctx) {\n+    void writeLedgerConfig(StatCallback callback, Object ctx) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Writing metadata to ZooKeeper: \" + this.ledgerId + \", \" + metadata.getZnodeVersion());\n         }\n@@ -210,7 +210,7 @@ public void close()\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n \n-        asyncClose(this, counter);\n+        asyncClose(new SyncCloseCallback(), counter);\n \n         counter.block(0);\n         if (counter.getrc() != BKException.Code.OK) {\n@@ -291,7 +291,7 @@ public void processResult(int rc, String path, Object subctx,\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n \n-        asyncReadEntries(firstEntry, lastEntry, this, counter);\n+        asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(), counter);\n \n         counter.block(0);\n         if (counter.getrc() != BKException.Code.OK) {\n@@ -336,8 +336,8 @@ public void asyncReadEntries(long firstEntry, long lastEntry,\n      * @param data\n      *         array of bytes to be written to the ledger\n      */\n-    public long addEntry(byte[] data) throws InterruptedException, BKException {\n-        return addEntry(data, 0, data.length);\n+    public void addEntry(byte[] data) throws InterruptedException, BKException {\n+        addEntry(data, 0, data.length);\n     }\n \n     /**\n@@ -350,16 +350,18 @@ public long addEntry(byte[] data) throws InterruptedException, BKException {\n      * @param length\n      *          number of bytes to take from data\n      */\n-    public long addEntry(byte[] data, int offset, int length)\n+    public void addEntry(byte[] data, int offset, int length)\n             throws InterruptedException, BKException {\n         LOG.debug(\"Adding entry \" + data);\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n \n-        asyncAddEntry(data, offset, length, this, counter);\n+        asyncAddEntry(data, offset, length, new SyncAddCallback(), counter);\n         counter.block(0);\n \n-        return counter.getrc();\n+        if(counter.getrc() != BKException.Code.OK) {\n+            throw BKException.create(counter.getrc());\n+        }\n     }\n \n     /**\n@@ -482,7 +484,7 @@ boolean ready() {\n     public long readLastConfirmed()\n             throws InterruptedException, BKException {\n         LastConfirmedCtx ctx = new LastConfirmedCtx();\n-        asyncReadLastConfirmed(this, ctx);\n+        asyncReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);\n         synchronized(ctx) {\n             while(!ctx.ready()) {\n                 ctx.wait();\n@@ -599,80 +601,84 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n             // noop\n         }\n     }\n+    \n+    private static class SyncReadCallback implements ReadCallback {\n+        /**\n+         * Implementation of callback interface for synchronous read method.\n+         *\n+         * @param rc\n+         *          return code\n+         * @param leder\n+         *          ledger identifier\n+         * @param seq\n+         *          sequence of entries\n+         * @param ctx\n+         *          control object\n+         */\n+        public void readComplete(int rc, LedgerHandle lh,\n+                                 Enumeration<LedgerEntry> seq, Object ctx) {\n+            \n+            SyncCounter counter = (SyncCounter) ctx;\n+            synchronized (counter) {\n+                counter.setSequence(seq);\n+                counter.setrc(rc);\n+                counter.dec();\n+                counter.notify();\n+            }\n+        }\n+    }\n \n-    /**\n-     * Implementation of callback interface for synchronous read method.\n-     *\n-     * @param rc\n-     *          return code\n-     * @param leder\n-     *          ledger identifier\n-     * @param seq\n-     *          sequence of entries\n-     * @param ctx\n-     *          control object\n-     */\n-    public void readComplete(int rc, LedgerHandle lh,\n-                             Enumeration<LedgerEntry> seq, Object ctx) {\n-\n-        SyncCounter counter = (SyncCounter) ctx;\n-        synchronized (counter) {\n-            counter.setSequence(seq);\n+    private static class SyncAddCallback implements AddCallback {\n+        /**\n+         * Implementation of callback interface for synchronous read method.\n+         *\n+         * @param rc\n+         *          return code\n+         * @param leder\n+         *          ledger identifier\n+         * @param entry\n+         *          entry identifier\n+         * @param ctx\n+         *          control object\n+         */\n+        public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n+            SyncCounter counter = (SyncCounter) ctx;\n+            \n             counter.setrc(rc);\n             counter.dec();\n-            counter.notify();\n         }\n     }\n \n-    /**\n-     * Implementation of callback interface for synchronous read method.\n-     *\n-     * @param rc\n-     *          return code\n-     * @param leder\n-     *          ledger identifier\n-     * @param entry\n-     *          entry identifier\n-     * @param ctx\n-     *          control object\n-     */\n-    public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n-        SyncCounter counter = (SyncCounter) ctx;\n-\n-        counter.setrc(rc);\n-        counter.dec();\n-    }\n-\n-\n-\n-    /**\n-     * Implementation of  callback interface for synchronous read last confirmed method.\n-     */\n-    public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n-        LastConfirmedCtx lcCtx = (LastConfirmedCtx) ctx;\n-\n-        synchronized(lcCtx) {\n-            lcCtx.setRC(rc);\n-            lcCtx.setLastConfirmed(lastConfirmed);\n-            lcCtx.notify();\n+    private static class SyncReadLastConfirmedCallback implements ReadLastConfirmedCallback {\n+        /**\n+         * Implementation of  callback interface for synchronous read last confirmed method.\n+         */\n+        public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n+            LastConfirmedCtx lcCtx = (LastConfirmedCtx) ctx;\n+            \n+            synchronized(lcCtx) {\n+                lcCtx.setRC(rc);\n+                lcCtx.setLastConfirmed(lastConfirmed);\n+                lcCtx.notify();\n+            }\n         }\n     }\n \n-    /**\n-     * Close callback method\n-     *\n-     * @param rc\n-     * @param lh\n-     * @param ctx\n-     */\n-    public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n-\n-        SyncCounter counter = (SyncCounter) ctx;\n-        counter.setrc(rc);\n-        synchronized (counter) {\n-            counter.dec();\n-            counter.notify();\n+    private static class SyncCloseCallback implements CloseCallback {\n+        /**\n+         * Close callback method\n+         *\n+         * @param rc\n+         * @param lh\n+         * @param ctx\n+         */\n+        public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n+            SyncCounter counter = (SyncCounter) ctx;\n+            counter.setrc(rc);\n+            synchronized (counter) {\n+                counter.dec();\n+                counter.notify();\n+            }\n         }\n-\n     }\n }"},{"sha":"a3ed9f3f15d1b4d5e7fd9a5b12e846e98849eca5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -25,7 +25,7 @@\n import javax.crypto.Mac;\n import javax.crypto.spec.SecretKeySpec;\n \n-public class MacDigestManager extends DigestManager {\n+class MacDigestManager extends DigestManager {\n     public static String DIGEST_ALGORITHM = \"SHA-1\";\n     public static String KEY_ALGORITHM = \"HmacSHA1\";\n     Mac mac;"},{"sha":"e15f0a4348a09f4752877c846717bba5175a8ca6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"modified","additions":10,"deletions":685,"changes":695,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -22,698 +22,21 @@\n  */\n \n import java.io.IOException;\n+import org.apache.zookeeper.KeeperException;\n import java.net.InetSocketAddress;\n-import java.util.ArrayList;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+\n import org.apache.log4j.Logger;\n-import org.apache.zookeeper.AsyncCallback;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.KeeperException.Code;\n-import org.apache.zookeeper.data.Stat;\n-import org.jboss.netty.buffer.ChannelBuffer;\n \n /**\n  * Provides Admin Tools to manage the BookKeeper cluster.\n  *\n  */\n public class BookKeeperTools {\n-\n     private static Logger LOG = Logger.getLogger(BookKeeperTools.class);\n \n-    // ZK client instance\n-    private ZooKeeper zk;\n-    // ZK ledgers related String constants\n-    static final String LEDGERS_PATH = \"/ledgers\";\n-    static final String LEDGER_NODE_PREFIX = \"L\";\n-    static final String AVAILABLE_NODE = \"available\";\n-    static final String BOOKIES_PATH = LEDGERS_PATH + \"/\" + AVAILABLE_NODE;\n-    static final String COLON = \":\";\n-\n-    // BookKeeper client instance\n-    private BookKeeper bkc;\n-\n-    /*\n-     * Random number generator used to choose an available bookie server to\n-     * replicate data from a dead bookie.\n-     */\n-    private Random rand = new Random();\n-\n-    /*\n-     * For now, assume that all ledgers were created with the same DigestType\n-     * and password. In the future, this admin tool will need to know for each\n-     * ledger, what was the DigestType and password used to create it before it\n-     * can open it. These values will come from System properties, though hard\n-     * coded defaults are defined here.\n-     */\n-    private DigestType DIGEST_TYPE = DigestType.valueOf(System.getProperty(\"digestType\", DigestType.CRC32.toString()));\n-    private byte[] PASSWD = System.getProperty(\"passwd\", \"\").getBytes();\n-\n-    /**\n-     * Constructor that takes in a ZooKeeper servers connect string so we know\n-     * how to connect to ZooKeeper to retrieve information about the BookKeeper\n-     * cluster. We need this before we can do any type of admin operations on\n-     * the BookKeeper cluster.\n-     *\n-     * @param zkServers\n-     *            Comma separated list of hostname:port pairs for the ZooKeeper\n-     *            servers cluster.\n-     * @throws IOException\n-     *             Throws this exception if there is an error instantiating the\n-     *             ZooKeeper client.\n-     * @throws InterruptedException\n-     *             Throws this exception if there is an error instantiating the\n-     *             BookKeeper client.\n-     * @throws KeeperException\n-     *             Throws this exception if there is an error instantiating the\n-     *             BookKeeper client.\n-     */\n-    public BookKeeperTools(String zkServers) throws IOException, InterruptedException, KeeperException {\n-        // Create the ZooKeeper client instance\n-        zk = new ZooKeeper(zkServers, 10000, new Watcher() {\n-            @Override\n-            public void process(WatchedEvent event) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n-                }\n-            }\n-        });\n-        // Create the BookKeeper client instance\n-        bkc = new BookKeeper(zk);\n-    }\n-\n-    /**\n-     * Shutdown method to gracefully release resources that this class uses.\n-     *\n-     * @throws InterruptedException\n-     *             if there is an error shutting down the clients that this\n-     *             class uses.\n-     */\n-    public void shutdown() throws InterruptedException {\n-        bkc.halt();\n-        zk.close();\n-    }\n-\n-    /**\n-     * This is a multi callback object for bookie recovery that waits for all of\n-     * the multiple async operations to complete. If any fail, then we invoke\n-     * the final callback with a BK LedgerRecoveryException.\n-     */\n-    class MultiCallback implements AsyncCallback.VoidCallback {\n-        // Number of expected callbacks\n-        final int expected;\n-        // Final callback and the corresponding context to invoke\n-        final AsyncCallback.VoidCallback cb;\n-        final Object context;\n-        // This keeps track of how many operations have completed\n-        final AtomicInteger done = new AtomicInteger();\n-        // List of the exceptions from operations that completed unsuccessfully\n-        final LinkedBlockingQueue<Integer> exceptions = new LinkedBlockingQueue<Integer>();\n-\n-        MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context) {\n-            this.expected = expected;\n-            this.cb = cb;\n-            this.context = context;\n-            if (expected == 0) {\n-                cb.processResult(Code.OK.intValue(), null, context);\n-            }\n-        }\n-\n-        private void tick() {\n-            if (done.incrementAndGet() == expected) {\n-                if (exceptions.isEmpty()) {\n-                    cb.processResult(Code.OK.intValue(), null, context);\n-                } else {\n-                    cb.processResult(BKException.Code.LedgerRecoveryException, null, context);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void processResult(int rc, String path, Object ctx) {\n-            if (rc != Code.OK.intValue()) {\n-                LOG.error(\"BK error recovering ledger data\", BKException.create(rc));\n-                exceptions.add(rc);\n-            }\n-            tick();\n-        }\n-\n-    }\n-\n-    /**\n-     * Method to get the input ledger's digest type. For now, this is just a\n-     * placeholder function since there is no way we can get this information\n-     * easily. In the future, BookKeeper should store this ledger metadata\n-     * somewhere such that an admin tool can access it.\n-     *\n-     * @param ledgerId\n-     *            LedgerId we are retrieving the digestType for.\n-     * @return DigestType for the input ledger\n-     */\n-    private DigestType getLedgerDigestType(long ledgerId) {\n-        return DIGEST_TYPE;\n-    }\n-\n-    /**\n-     * Method to get the input ledger's password. For now, this is just a\n-     * placeholder function since there is no way we can get this information\n-     * easily. In the future, BookKeeper should store this ledger metadata\n-     * somewhere such that an admin tool can access it.\n-     *\n-     * @param ledgerId\n-     *            LedgerId we are retrieving the password for.\n-     * @return Password for the input ledger\n-     */\n-    private byte[] getLedgerPasswd(long ledgerId) {\n-        return PASSWD;\n-    }\n-\n-    // Object used for calling async methods and waiting for them to complete.\n-    class SyncObject {\n-        boolean value;\n-\n-        public SyncObject() {\n-            value = false;\n-        }\n-    }\n-\n-    /**\n-     * Synchronous method to rebuild and recover the ledger fragments data that\n-     * was stored on the source bookie. That bookie could have failed completely\n-     * and now the ledger data that was stored on it is under replicated. An\n-     * optional destination bookie server could be given if we want to copy all\n-     * of the ledger fragments data on the failed source bookie to it.\n-     * Otherwise, we will just randomly distribute the ledger fragments to the\n-     * active set of bookies, perhaps based on load. All ZooKeeper ledger\n-     * metadata will be updated to point to the new bookie(s) that contain the\n-     * replicated ledger fragments.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n-     * @param bookieDest\n-     *            Optional destination bookie that if passed, we will copy all\n-     *            of the ledger fragments from the source bookie over to it.\n-     */\n-    public void recoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest)\n-            throws InterruptedException {\n-        SyncObject sync = new SyncObject();\n-        // Call the async method to recover bookie data.\n-        asyncRecoverBookieData(bookieSrc, bookieDest, new RecoverCallback() {\n-            @Override\n-            public void recoverComplete(int rc, Object ctx) {\n-                LOG.info(\"Recover bookie operation completed with rc: \" + rc);\n-                SyncObject syncObj = (SyncObject) ctx;\n-                synchronized (syncObj) {\n-                    syncObj.value = true;\n-                    syncObj.notify();\n-                }\n-            }\n-        }, sync);\n-\n-        // Wait for the async method to complete.\n-        synchronized (sync) {\n-            while (sync.value == false) {\n-                sync.wait();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Async method to rebuild and recover the ledger fragments data that was\n-     * stored on the source bookie. That bookie could have failed completely and\n-     * now the ledger data that was stored on it is under replicated. An\n-     * optional destination bookie server could be given if we want to copy all\n-     * of the ledger fragments data on the failed source bookie to it.\n-     * Otherwise, we will just randomly distribute the ledger fragments to the\n-     * active set of bookies, perhaps based on load. All ZooKeeper ledger\n-     * metadata will be updated to point to the new bookie(s) that contain the\n-     * replicated ledger fragments.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n-     * @param bookieDest\n-     *            Optional destination bookie that if passed, we will copy all\n-     *            of the ledger fragments from the source bookie over to it.\n-     * @param cb\n-     *            RecoverCallback to invoke once all of the data on the dead\n-     *            bookie has been recovered and replicated.\n-     * @param context\n-     *            Context for the RecoverCallback to call.\n-     */\n-    public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-                                       final RecoverCallback cb, final Object context) {\n-        // Sync ZK to make sure we're reading the latest bookie/ledger data.\n-        zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n-            @Override\n-            public void processResult(int rc, String path, Object ctx) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"ZK error syncing: \", KeeperException.create(KeeperException.Code.get(rc), path));\n-                    cb.recoverComplete(BKException.Code.ZKException, context);\n-                    return;\n-                }\n-                getAvailableBookies(bookieSrc, bookieDest, cb, context);\n-            };\n-        }, null);\n-    }\n-\n-    /**\n-     * This method asynchronously gets the set of available Bookies that the\n-     * dead input bookie's data will be copied over into. If the user passed in\n-     * a specific destination bookie, then just use that one. Otherwise, we'll\n-     * randomly pick one of the other available bookies to use for each ledger\n-     * fragment we are replicating.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n-     * @param bookieDest\n-     *            Optional destination bookie that if passed, we will copy all\n-     *            of the ledger fragments from the source bookie over to it.\n-     * @param cb\n-     *            RecoverCallback to invoke once all of the data on the dead\n-     *            bookie has been recovered and replicated.\n-     * @param context\n-     *            Context for the RecoverCallback to call.\n-     */\n-    private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-                                     final RecoverCallback cb, final Object context) {\n-        final List<InetSocketAddress> availableBookies = new LinkedList<InetSocketAddress>();\n-        if (bookieDest != null) {\n-            availableBookies.add(bookieDest);\n-            // Now poll ZK to get the active ledgers\n-            getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n-        } else {\n-            zk.getChildren(BOOKIES_PATH, null, new AsyncCallback.ChildrenCallback() {\n-                @Override\n-                public void processResult(int rc, String path, Object ctx, List<String> children) {\n-                    if (rc != Code.OK.intValue()) {\n-                        LOG.error(\"ZK error getting bookie nodes: \", KeeperException.create(KeeperException.Code\n-                                  .get(rc), path));\n-                        cb.recoverComplete(BKException.Code.ZKException, context);\n-                        return;\n-                    }\n-                    for (String bookieNode : children) {\n-                        String parts[] = bookieNode.split(COLON);\n-                        if (parts.length < 2) {\n-                            LOG.error(\"Bookie Node retrieved from ZK has invalid name format: \" + bookieNode);\n-                            cb.recoverComplete(BKException.Code.ZKException, context);\n-                            return;\n-                        }\n-                        availableBookies.add(new InetSocketAddress(parts[0], Integer.parseInt(parts[1])));\n-                    }\n-                    // Now poll ZK to get the active ledgers\n-                    getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n-                }\n-            }, null);\n-        }\n-    }\n-\n-    /**\n-     * This method asynchronously polls ZK to get the current set of active\n-     * ledgers. From this, we can open each ledger and look at the metadata to\n-     * determine if any of the ledger fragments for it were stored at the dead\n-     * input bookie.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n-     * @param bookieDest\n-     *            Optional destination bookie that if passed, we will copy all\n-     *            of the ledger fragments from the source bookie over to it.\n-     * @param cb\n-     *            RecoverCallback to invoke once all of the data on the dead\n-     *            bookie has been recovered and replicated.\n-     * @param context\n-     *            Context for the RecoverCallback to call.\n-     * @param availableBookies\n-     *            List of Bookie Servers that are available to use for\n-     *            replicating data on the failed bookie. This could contain a\n-     *            single bookie server if the user explicitly chose a bookie\n-     *            server to replicate data to.\n-     */\n-    private void getActiveLedgers(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-                                  final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n-        zk.getChildren(LEDGERS_PATH, null, new AsyncCallback.ChildrenCallback() {\n-            @Override\n-            public void processResult(int rc, String path, Object ctx, List<String> children) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"ZK error getting ledger nodes: \", KeeperException.create(KeeperException.Code.get(rc),\n-                              path));\n-                    cb.recoverComplete(BKException.Code.ZKException, context);\n-                    return;\n-                }\n-                // Wrapper class around the RecoverCallback so it can be used\n-                // as the final VoidCallback to invoke within the MultiCallback.\n-                class RecoverCallbackWrapper implements AsyncCallback.VoidCallback {\n-                    final RecoverCallback cb;\n-\n-                    RecoverCallbackWrapper(RecoverCallback cb) {\n-                        this.cb = cb;\n-                    }\n-\n-                    @Override\n-                    public void processResult(int rc, String path, Object ctx) {\n-                        cb.recoverComplete(rc, ctx);\n-                    }\n-                }\n-                // Recover each of the ledgers asynchronously\n-                MultiCallback ledgerMcb = new MultiCallback(children.size(), new RecoverCallbackWrapper(cb), context);\n-                for (final String ledgerNode : children) {\n-                    recoverLedger(bookieSrc, ledgerNode, ledgerMcb, availableBookies);\n-                }\n-            }\n-        }, null);\n-    }\n-\n-    /**\n-     * This method asynchronously recovers a given ledger if any of the ledger\n-     * entries were stored on the failed bookie.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n-     * @param ledgerNode\n-     *            Ledger Node name as retrieved from ZooKeeper we want to\n-     *            recover.\n-     * @param ledgerMcb\n-     *            MultiCallback to invoke once we've recovered the current\n-     *            ledger.\n-     * @param availableBookies\n-     *            List of Bookie Servers that are available to use for\n-     *            replicating data on the failed bookie. This could contain a\n-     *            single bookie server if the user explicitly chose a bookie\n-     *            server to replicate data to.\n-     */\n-    private void recoverLedger(final InetSocketAddress bookieSrc, final String ledgerNode,\n-                               final MultiCallback ledgerMcb, final List<InetSocketAddress> availableBookies) {\n-        /*\n-         * The available node is also stored in this path so ignore that. That\n-         * node is the path for the set of available Bookie Servers.\n-         */\n-        if (ledgerNode.equals(AVAILABLE_NODE)) {\n-            ledgerMcb.processResult(BKException.Code.OK, null, null);\n-            return;\n-        }\n-        // Parse out the ledgerId from the ZK ledger node.\n-        String parts[] = ledgerNode.split(LEDGER_NODE_PREFIX);\n-        if (parts.length < 2) {\n-            LOG.error(\"Ledger Node retrieved from ZK has invalid name format: \" + ledgerNode);\n-            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n-            return;\n-        }\n-        final long lId;\n-        try {\n-            lId = Long.parseLong(parts[parts.length - 1]);\n-        } catch (NumberFormatException e) {\n-            LOG.error(\"Error retrieving ledgerId from ledgerNode: \" + ledgerNode, e);\n-            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n-            return;\n-        }\n-        /*\n-         * For the current ledger, open it to retrieve the LedgerHandle. This\n-         * will contain the LedgerMetadata indicating which bookie servers the\n-         * ledger fragments are stored on. Check if any of the ledger fragments\n-         * for the current ledger are stored on the input dead bookie.\n-         */\n-        DigestType digestType = getLedgerDigestType(lId);\n-        byte[] passwd = getLedgerPasswd(lId);\n-        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n-            @Override\n-            public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"BK error opening ledger: \" + lId, BKException.create(rc));\n-                    ledgerMcb.processResult(rc, null, null);\n-                    return;\n-                }\n-                /*\n-                 * This List stores the ledger fragments to recover indexed by\n-                 * the start entry ID for the range. The ensembles TreeMap is\n-                 * keyed off this.\n-                 */\n-                final List<Long> ledgerFragmentsToRecover = new LinkedList<Long>();\n-                /*\n-                 * This Map will store the start and end entry ID values for\n-                 * each of the ledger fragment ranges. The only exception is the\n-                 * current active fragment since it has no end yet. In the event\n-                 * of a bookie failure, a new ensemble is created so the current\n-                 * ensemble should not contain the dead bookie we are trying to\n-                 * recover.\n-                 */\n-                Map<Long, Long> ledgerFragmentsRange = new HashMap<Long, Long>();\n-                Long curEntryId = null;\n-                for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n-                .entrySet()) {\n-                    if (curEntryId != null)\n-                        ledgerFragmentsRange.put(curEntryId, entry.getKey() - 1);\n-                    curEntryId = entry.getKey();\n-                    if (entry.getValue().contains(bookieSrc)) {\n-                        /*\n-                         * Current ledger fragment has entries stored on the\n-                         * dead bookie so we'll need to recover them.\n-                         */\n-                        ledgerFragmentsToRecover.add(entry.getKey());\n-                    }\n-                }\n-                /*\n-                 * See if this current ledger contains any ledger fragment that\n-                 * needs to be re-replicated. If not, then just invoke the\n-                 * multiCallback and return.\n-                 */\n-                if (ledgerFragmentsToRecover.size() == 0) {\n-                    ledgerMcb.processResult(BKException.Code.OK, null, null);\n-                    return;\n-                }\n-                /*\n-                 * We have ledger fragments that need to be re-replicated to a\n-                 * new bookie. Choose one randomly from the available set of\n-                 * bookies.\n-                 */\n-                final InetSocketAddress newBookie = availableBookies.get(rand.nextInt(availableBookies.size()));\n-\n-                /*\n-                 * Wrapper class around the ledger MultiCallback. Once all\n-                 * ledger fragments for the ledger have been replicated to a new\n-                 * bookie, we need to update ZK with this new metadata to point\n-                 * to the new bookie instead of the old dead one. That should be\n-                 * done at the end prior to invoking the ledger MultiCallback.\n-                 */\n-                class LedgerMultiCallbackWrapper implements AsyncCallback.VoidCallback {\n-                    final MultiCallback ledgerMcb;\n-\n-                    LedgerMultiCallbackWrapper(MultiCallback ledgerMcb) {\n-                        this.ledgerMcb = ledgerMcb;\n-                    }\n-\n-                    @Override\n-                    public void processResult(int rc, String path, Object ctx) {\n-                        if (rc != Code.OK.intValue()) {\n-                            LOG.error(\"BK error replicating ledger fragments for ledger: \" + lId, BKException\n-                                      .create(rc));\n-                            ledgerMcb.processResult(rc, null, null);\n-                            return;\n-                        }\n-                        /*\n-                         * Update the ledger metadata's ensemble info to point\n-                         * to the new bookie.\n-                         */\n-                        for (final Long startEntryId : ledgerFragmentsToRecover) {\n-                            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().get(\n-                                    startEntryId);\n-                            int deadBookieIndex = ensemble.indexOf(bookieSrc);\n-                            ensemble.remove(deadBookieIndex);\n-                            ensemble.add(deadBookieIndex, newBookie);\n-                        }\n-                        \n-                        lh.writeLedgerConfig(new AsyncCallback.StatCallback() {\n-                            @Override\n-                            public void processResult(int rc, String path, Object ctx, Stat stat) {\n-                                if (rc != Code.OK.intValue()) {\n-                                    LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n-                                              KeeperException.create(KeeperException.Code.get(rc), path));\n-                                } else {\n-                                    lh.getLedgerMetadata().updateZnodeStatus(stat);\n-                                    LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId()\n-                                             + \") to point ledger fragments from old dead bookie: (\" + bookieSrc\n-                                             + \") to new bookie: (\" + newBookie + \")\");\n-                                }\n-                                /*\n-                                 * Pass the return code result up the chain with\n-                                 * the parent callback.\n-                                 */\n-                                ledgerMcb.processResult(rc, null, null);\n-                            }\n-                        }, null);\n-                    }\n-                }\n-\n-                /*\n-                 * Now recover all of the necessary ledger fragments\n-                 * asynchronously using a MultiCallback for every fragment.\n-                 */\n-                MultiCallback ledgerFragmentMcb = new MultiCallback(ledgerFragmentsToRecover.size(),\n-                        new LedgerMultiCallbackWrapper(ledgerMcb), null);\n-                for (final Long startEntryId : ledgerFragmentsToRecover) {\n-                    Long endEntryId = ledgerFragmentsRange.get(startEntryId);\n-                    try {\n-                        recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, ledgerFragmentMcb, newBookie);\n-                    } catch(InterruptedException e) {\n-                        Thread.currentThread().interrupt();\n-                        return;\n-                    }\n-                }\n-            }\n-        }, null);\n-    }\n-\n-    /**\n-     * This method asynchronously recovers a ledger fragment which is a\n-     * contiguous portion of a ledger that was stored in an ensemble that\n-     * included the failed bookie.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n-     * @param lh\n-     *            LedgerHandle for the ledger\n-     * @param startEntryId\n-     *            Start entry Id for the ledger fragment\n-     * @param endEntryId\n-     *            End entry Id for the ledger fragment\n-     * @param ledgerFragmentMcb\n-     *            MultiCallback to invoke once we've recovered the current\n-     *            ledger fragment.\n-     * @param newBookie\n-     *            New bookie we want to use to recover and replicate the ledger\n-     *            entries that were stored on the failed bookie.\n-     */\n-    private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final LedgerHandle lh,\n-                                       final Long startEntryId, final Long endEntryId, final MultiCallback ledgerFragmentMcb,\n-                                       final InetSocketAddress newBookie) throws InterruptedException {\n-        if (endEntryId == null) {\n-            /*\n-             * Ideally this should never happen if bookie failure is taken care\n-             * of properly. Nothing we can do though in this case.\n-             */\n-            LOG.warn(\"Dead bookie (\" + bookieSrc + \") is still part of the current active ensemble for ledgerId: \"\n-                     + lh.getId());\n-            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n-            return;\n-        }\n-\n-        ArrayList<InetSocketAddress> curEnsemble = lh.getLedgerMetadata().getEnsembles().get(startEntryId);\n-        int bookieIndex = 0;\n-        for (int i = 0; i < curEnsemble.size(); i++) {\n-            if (curEnsemble.get(i).equals(bookieSrc)) {\n-                bookieIndex = i;\n-                break;\n-            }\n-        }\n-        /*\n-         * Loop through all entries in the current ledger fragment range and\n-         * find the ones that were stored on the dead bookie.\n-         */\n-        List<Long> entriesToReplicate = new LinkedList<Long>();\n-        for (long i = startEntryId; i <= endEntryId; i++) {\n-            if (lh.getDistributionSchedule().getReplicaIndex(i, bookieIndex) >= 0) {\n-                /*\n-                 * Current entry is stored on the dead bookie so we'll need to\n-                 * read it and replicate it to a new bookie.\n-                 */\n-                entriesToReplicate.add(i);\n-            }\n-        }\n-        /*\n-         * Now asynchronously replicate all of the entries for the ledger\n-         * fragment that were on the dead bookie.\n-         */\n-        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(entriesToReplicate.size(), ledgerFragmentMcb, null);\n-        for (final Long entryId : entriesToReplicate) {\n-            recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb, newBookie);\n-        }\n-    }\n-\n-    /**\n-     * This method asynchronously recovers a specific ledger entry by reading\n-     * the values via the BookKeeper Client (which would read it from the other\n-     * replicas) and then writing it to the chosen new bookie.\n-     *\n-     * @param entryId\n-     *            Ledger Entry ID to recover.\n-     * @param lh\n-     *            LedgerHandle for the ledger\n-     * @param ledgerFragmentEntryMcb\n-     *            MultiCallback to invoke once we've recovered the current\n-     *            ledger entry.\n-     * @param newBookie\n-     *            New bookie we want to use to recover and replicate the ledger\n-     *            entries that were stored on the failed bookie.\n-     */\n-    private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n-                                            final MultiCallback ledgerFragmentEntryMcb, final InetSocketAddress newBookie) throws InterruptedException {\n-        /*\n-         * Read the ledger entry using the LedgerHandle. This will allow us to\n-         * read the entry from one of the other replicated bookies other than\n-         * the dead one.\n-         */\n-        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {\n-            @Override\n-            public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"BK error reading ledger entry: \" + entryId, BKException.create(rc));\n-                    ledgerFragmentEntryMcb.processResult(rc, null, null);\n-                    return;\n-                }\n-                /*\n-                 * Now that we've read the ledger entry, write it to the new\n-                 * bookie we've selected.\n-                 */\n-                LedgerEntry entry = seq.nextElement();\n-                byte[] data = entry.getEntry();\n-                ChannelBuffer toSend = lh.getDigestManager().computeDigestAndPackageForSending(entryId,\n-                                       lh.getLastAddConfirmed(), entry.getLength(), data, 0, data.length);\n-                bkc.getBookieClient().addEntry(newBookie, lh.getId(), lh.getLedgerKey(), entryId, toSend,\n-                new WriteCallback() {\n-                    @Override\n-                    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr,\n-                    Object ctx) {\n-                        if (rc != Code.OK.intValue()) {\n-                            LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n-                                      + entryId + \", bookie: \" + addr, BKException.create(rc));\n-                        } else {\n-                            LOG.debug(\"Success writing ledger entry to a new bookie!\");\n-                        }\n-                        /*\n-                         * Pass the return code result up the chain with\n-                         * the parent callback.\n-                         */\n-                        ledgerFragmentEntryMcb.processResult(rc, null, null);\n-                    }\n-                }, null);\n-            }\n-        }, null);\n-    }\n-\n     /**\n      * Main method so we can invoke the bookie recovery via command line.\n      *\n@@ -727,16 +50,18 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n      * @throws InterruptedException\n      * @throws IOException\n      * @throws KeeperException\n+     * @throws BKException\n      */\n-    public static void main(String[] args) throws InterruptedException, IOException, KeeperException {\n+    public static void main(String[] args) \n+            throws InterruptedException, IOException, KeeperException, BKException {\n         // Validate the inputs\n         if (args.length < 2) {\n             System.err.println(\"USAGE: BookKeeperTools zkServers bookieSrc [bookieDest]\");\n             return;\n         }\n         // Parse out the input arguments\n         String zkServers = args[0];\n-        String bookieSrcString[] = args[1].split(COLON);\n+        String bookieSrcString[] = args[1].split(\":\");\n         if (bookieSrcString.length < 2) {\n             System.err.println(\"BookieSrc inputted has invalid name format (host:port expected): \" + bookieSrcString);\n             return;\n@@ -745,7 +70,7 @@ public static void main(String[] args) throws InterruptedException, IOException,\n                 .parseInt(bookieSrcString[1]));\n         InetSocketAddress bookieDest = null;\n         if (args.length < 3) {\n-            String bookieDestString[] = args[2].split(COLON);\n+            String bookieDestString[] = args[2].split(\":\");\n             if (bookieDestString.length < 2) {\n                 System.err.println(\"BookieDest inputted has invalid name format (host:port expected): \"\n                                    + bookieDestString);\n@@ -756,11 +81,11 @@ public static void main(String[] args) throws InterruptedException, IOException,\n \n         // Create the BookKeeperTools instance and perform the bookie recovery\n         // synchronously.\n-        BookKeeperTools bkTools = new BookKeeperTools(zkServers);\n+        BookKeeperAdmin bkTools = new BookKeeperAdmin(zkServers);\n         bkTools.recoverBookieData(bookieSrc, bookieDest);\n \n         // Shutdown the resources used in the BookKeeperTools instance.\n-        bkTools.shutdown();\n+        bkTools.close();\n     }\n \n }"},{"sha":"39334af7b991cac73175841e53b4dd0c2d2ef66f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -48,6 +48,10 @@ public BookKeeperTestClient(String servers)\n         super(servers);\n     }\n \n+    public ZooKeeper getZkHandle() {\n+        return super.getZkHandle();\n+    }\n+\n     /**\n      * Force a read to zookeeper to get list of bookies.\n      *"},{"sha":"07639aa378e08744d2126fea1254f8365451cbbe","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -19,7 +19,7 @@\n  *\n  */\n \n-package org.apache.bookkeeper.test;\n+package org.apache.bookkeeper.client;\n \n import java.io.File;\n import java.io.IOException;","previous_filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java"},{"sha":"20701c727d090380501c48f558e47463726bb69e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -130,7 +130,7 @@ public void tearDown() throws Exception {\n         LOG.info(\"TearDown\");\n \n         if (bkc != null) {\n-            bkc.halt();;\n+            bkc.close();;\n         }\n \n         for (BookieServer server : bs) {"},{"sha":"8dbae67e45a81ca91bbab7b3106721d32a95dba4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -190,7 +190,7 @@ void auxTestReadWriteAsyncSingleClient(BookieServer bs) throws IOException {\n             // *** WRITING PART COMPLETE // READ PART BEGINS ***\n \n             // open ledger\n-            bkc.halt();\n+            bkc.close();\n             bkc = new BookKeeperTestClient(\"127.0.0.1\");\n             lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n             LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));"},{"sha":"18c6952dfc0658747f87e79832ad13cbbeb042ce","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":0,"deletions":37,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -233,9 +233,6 @@ public void testReadWriteAsyncSingleClient() throws IOException {\n             assertTrue(\"Checking number of read entries\", i == numEntriesToWrite);\n \n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -363,9 +360,6 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n             assertTrue(\"Checking number of read entries\", i == numEntries);\n \n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -497,9 +491,6 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n             LOG.debug(\"*** READ COMPLETE ***\");\n \n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -572,9 +563,6 @@ public void testSyncReadAsyncWriteStringsSingleClient() throws IOException {\n             assertTrue(\"Checking number of read entries\", i == numEntriesToWrite);\n \n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -619,9 +607,6 @@ public void testReadWriteSyncSingleClient() throws IOException {\n                 assertTrue(\"Checking entry \" + i + \" for equality\", origEntry.equals(retrEntry));\n             }\n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -666,9 +651,6 @@ public void testReadWriteZero() throws IOException {\n                 assertTrue(\"Checking if entry \" + i + \" has zero bytes\", result.capacity() == 0);\n             }\n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -725,9 +707,6 @@ public void testMultiLedger() throws IOException {\n                 assertTrue(\"Checking if entry \" + i + \" has zero bytes\", result.capacity() == 0);\n             }\n             lh2.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -777,9 +756,6 @@ public void testReadWriteAsyncLength() throws IOException {\n \n \n             lh.close();\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -828,9 +804,6 @@ public void testShutdown() throws IOException {\n             for(int i = 0; i < lhArray.length; i++) {\n                 lhArray[i].close();\n             }\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -902,11 +875,6 @@ public void testReadFromOpenLedger() throws IOException {\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n-\n-\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -975,11 +943,6 @@ public void testLastConfirmedAdd() throws IOException {\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n-\n-\n-        } catch (KeeperException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to ZooKeeper exception\");\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");"},{"sha":"ac54d9abf9b69fb93811720e2642337986586e58","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -35,7 +35,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookieServer;\n-import org.apache.bookkeeper.tools.BookKeeperTools;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.KeeperException.Code;\n@@ -79,7 +79,7 @@ public void recoverComplete(int rc, Object ctx) {\n     DigestType digestType;\n     SyncObject sync;\n     BookieRecoverCallback bookieRecoverCb;\n-    BookKeeperTools bkTools;\n+    BookKeeperAdmin bkAdmin;\n \n     // Constructor\n     public BookieRecoveryTest(DigestType digestType) {\n@@ -96,14 +96,14 @@ public void setUp() throws Exception {\n         System.setProperty(\"passwd\", \"\");\n         sync = new SyncObject();\n         bookieRecoverCb = new BookieRecoverCallback();\n-        bkTools = new BookKeeperTools(HOSTPORT);\n+        bkAdmin = new BookKeeperAdmin(HOSTPORT);\n     }\n \n     @After\n     @Override\n     public void tearDown() throws Exception {\n         // Release any resources used by the BookKeeperTools instance.\n-        bkTools.shutdown();\n+        bkAdmin.close();\n         super.tearDown();\n     }\n \n@@ -246,7 +246,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n                  + bookieDest + \")\");\n         // Initiate the sync object\n         sync.value = false;\n-        bkTools.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n+        bkAdmin.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n \n         // Wait for the async method to complete.\n         synchronized (sync) {\n@@ -301,7 +301,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n                  + \") and replicate it to a random available one\");\n         // Initiate the sync object\n         sync.value = false;\n-        bkTools.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n+        bkAdmin.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n \n         // Wait for the async method to complete.\n         synchronized (sync) {\n@@ -351,7 +351,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n                  + bookieDest + \")\");\n-        bkTools.recoverBookieData(bookieSrc, bookieDest);\n+        bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n \n         // Verify the recovered ledger entries are okay.\n         verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n@@ -397,7 +397,7 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n         InetSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n                  + \") and replicate it to a random available one\");\n-        bkTools.recoverBookieData(bookieSrc, bookieDest);\n+        bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n \n         // Verify the recovered ledger entries are okay.\n         verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);"},{"sha":"b3229a18fcb90c4699d7c29bc5e9a72d5db1bd71","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -80,7 +80,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n \n     @Override\n     public void tearDown() throws Exception {\n-        bk.halt();\n+        bk.close();\n     }\n \n "},{"sha":"cf56c73627a9656877b3a676e3286485962b1c99","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -31,6 +31,7 @@\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.KeeperException;\n@@ -219,9 +220,11 @@ public void shutdown() {\n             if (zk != null)\n                 zk.close();\n             if (bk != null)\n-                bk.halt();\n+                bk.close();\n         } catch (InterruptedException e) {\n             logger.error(\"Error while closing ZooKeeper client!\");\n+        } catch (BKException bke) {\n+            logger.error(\"Error while closing BookKeeper client\");\n         }\n \n         // Stop the RegionManager."},{"sha":"d154ce096c2f54a044e8fab2d54c26c65509f6d4","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -121,7 +121,7 @@ public void tearDown() throws Exception {\n             LOG.error(\"Error tearing down\", e);\n         }\n         // Close the BookKeeper client\n-        bk.halt();\n+        bk.close();\n         super.tearDown();\n     }\n "},{"sha":"d0c78c9dcdb616fc71a87a576b54749c3c733202","filename":"pom.xml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/68bdab655445f80314a0d2531e60e3b2e4d8fa17/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/68bdab655445f80314a0d2531e60e3b2e4d8fa17/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/pom.xml?ref=68bdab655445f80314a0d2531e60e3b2e4d8fa17","patch":"@@ -59,6 +59,7 @@\n         <artifactId>maven-javadoc-plugin</artifactId>\n         <version>2.8</version>\n \t<configuration>\n+\t  <subpackages>org.apache.bookkeeper.client</subpackages>\n           <groups>\n \t    <group>\n               <title>Bookkeeper</title>"}]}

