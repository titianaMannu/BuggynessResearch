{"sha":"69620e6561196975295752175b01354877a9fdde","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2OTYyMGU2NTYxMTk2OTc1Mjk1NzUyMTc1YjAxMzU0ODc3YTlmZGRl","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-08-02T18:02:06Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-08-02T18:02:06Z"},"message":"BOOKEEPER-697. stats collection on bookkeeper server (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1615338 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d73e6050bec15c1a02f072bf7bf842464d3258f3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d73e6050bec15c1a02f072bf7bf842464d3258f3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/69620e6561196975295752175b01354877a9fdde","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/69620e6561196975295752175b01354877a9fdde","html_url":"https://github.com/apache/bookkeeper/commit/69620e6561196975295752175b01354877a9fdde","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/69620e6561196975295752175b01354877a9fdde/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"4ec0bf11c3fdb78e390c5c889140d8fbf87ce60b","url":"https://api.github.com/repos/apache/bookkeeper/commits/4ec0bf11c3fdb78e390c5c889140d8fbf87ce60b","html_url":"https://github.com/apache/bookkeeper/commit/4ec0bf11c3fdb78e390c5c889140d8fbf87ce60b"}],"stats":{"total":760,"additions":600,"deletions":160},"files":[{"sha":"fa6e550f078f735c0d8d0dc9a8acc224761257f2","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -298,6 +298,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-739: Test timeouts mostly ignored (sijie via fpj)\n \n+      BOOKKEEPER-697: stats collection on bookkeeper server (sijie via fpj)\n+\n     NEW FEATURE:\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)"},{"sha":"e38ea2b83a72f024637cdf090ea4eefbbb598c33","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bk_server.conf?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -272,3 +272,6 @@ zkTimeout=10000\n # When false, bookie will use its ipaddress for the registration.\n # Defaults to false.\n #useHostNameAsBookieID=false\n+\n+# Stats Provider Class\n+#statsProviderClass=org.apache.bookkeeper.stats.CodahaleMetricsProvider"},{"sha":"cdc5fc4d6670541d431f41b94f968dcb633108ba","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":48,"deletions":16,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -50,6 +50,10 @@\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.Gauge;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.IOUtils;\n import org.apache.bookkeeper.util.MathUtils;\n@@ -71,11 +75,16 @@\n \n import com.google.common.annotations.VisibleForTesting;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_LEDGER_SCOPE;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_INDEX_SCOPE;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_BYTES;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SERVER_STATUS;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_BYTES;\n+\n /**\n  * Implements a bookie.\n  *\n  */\n-\n public class Bookie extends BookieCriticalThread {\n \n     private final static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n@@ -121,6 +130,10 @@\n \n     final private AtomicBoolean readOnly = new AtomicBoolean(false);\n \n+    // Expose Stats\n+    private final Counter writeBytes;\n+    private final Counter readBytes;\n+\n     public static class NoLedgerException extends IOException {\n         private static final long serialVersionUID = 1L;\n         private final long ledgerId;\n@@ -290,7 +303,7 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n             boolean newEnv = false;\n             List<File> missedCookieDirs = new ArrayList<File>();\n             Cookie journalCookie = null;\n-            // try to read cookie from journal directory. \n+            // try to read cookie from journal directory.\n             try {\n                 journalCookie = Cookie.readFromDirectory(journalDirectory);\n                 if (journalCookie.isBookieHostCreatedFromIp()) {\n@@ -312,7 +325,7 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n                 masterCookie.verify(zkCookie);\n             } catch (KeeperException.NoNodeException nne) {\n                 // can occur in cases:\n-                // 1) new environment or \n+                // 1) new environment or\n                 // 2) done only metadata format and started bookie server.\n             }\n             checkDirectoryStructure(journalDirectory);\n@@ -424,19 +437,25 @@ public static File getCurrentDirectory(File dir) {\n         return currentDirs;\n     }\n \n-\n     public Bookie(ServerConfiguration conf)\n             throws IOException, KeeperException, InterruptedException, BookieException {\n+        this(conf, NullStatsLogger.INSTANCE);\n+    }\n+\n+    public Bookie(ServerConfiguration conf, StatsLogger statsLogger)\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n         super(\"Bookie-\" + conf.getBookiePort());\n         this.bookieRegistrationPath = conf.getZkAvailableBookiesPath() + \"/\";\n         this.conf = conf;\n         this.journalDirectory = getCurrentDirectory(conf.getJournalDir());\n-        this.ledgerDirsManager = new LedgerDirsManager(conf, conf.getLedgerDirs());\n+        this.ledgerDirsManager = new LedgerDirsManager(conf, conf.getLedgerDirs(),\n+                statsLogger.scope(LD_LEDGER_SCOPE));\n         File[] idxDirs = conf.getIndexDirs();\n         if (null == idxDirs) {\n             this.indexDirsManager = this.ledgerDirsManager;\n         } else {\n-            this.indexDirsManager = new LedgerDirsManager(conf, idxDirs);\n+            this.indexDirsManager = new LedgerDirsManager(conf, idxDirs,\n+                    statsLogger.scope(LD_INDEX_SCOPE));\n         }\n \n         // instantiate zookeeper client to initialize ledger manager\n@@ -456,11 +475,11 @@ public Bookie(ServerConfiguration conf)\n         if (conf.getSortedLedgerStorageEnabled()) {\n             ledgerStorage = new SortedLedgerStorage(conf, ledgerManager,\n                                                     ledgerDirsManager, indexDirsManager,\n-                                                    journal);\n+                                                    journal, statsLogger);\n         } else {\n             ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager,\n                                                          ledgerDirsManager, indexDirsManager,\n-                                                         journal);\n+                                                         journal, statsLogger);\n         }\n         syncThread = new SyncThread(conf, getLedgerDirsListener(),\n                                     ledgerStorage, journal);\n@@ -471,6 +490,22 @@ public Bookie(ServerConfiguration conf)\n         String myID = getMyId();\n         zkBookieRegPath = this.bookieRegistrationPath + myID;\n         zkBookieReadOnlyPath = this.bookieRegistrationPath + BookKeeperConstants.READONLY + \"/\" + myID;\n+\n+        // Expose Stats\n+        writeBytes = statsLogger.getCounter(WRITE_BYTES);\n+        readBytes = statsLogger.getCounter(READ_BYTES);\n+        // 1 : up, 0 : readonly\n+        statsLogger.registerGauge(SERVER_STATUS, new Gauge<Number>() {\n+            @Override\n+            public Number getDefaultValue() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public Number getSample() {\n+                return readOnly.get() ? 0 : 1;\n+            }\n+        });\n     }\n \n     private String getMyId() throws UnknownHostException {\n@@ -1029,13 +1064,6 @@ private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey)\n         return l;\n     }\n \n-    protected void addEntryByLedgerId(long ledgerId, ByteBuffer entry)\n-        throws IOException, BookieException {\n-        byte[] key = ledgerStorage.readMasterKey(ledgerId);\n-        LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n-        handle.addEntry(entry);\n-    }\n-\n     /**\n      * Add an entry to a ledger as specified by handle.\n      */\n@@ -1046,6 +1074,8 @@ private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCa\n         long entryId = handle.addEntry(entry);\n \n         entry.rewind();\n+        writeBytes.add(entry.remaining());\n+\n         LOG.trace(\"Adding {}@{}\", entryId, ledgerId);\n         journal.logAddEntry(entry, cb, ctx);\n     }\n@@ -1124,7 +1154,9 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n             throws IOException, NoLedgerException {\n         LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n         LOG.trace(\"Reading {}@{}\", entryId, ledgerId);\n-        return handle.readEntry(entryId);\n+        ByteBuffer entry = handle.readEntry(entryId);\n+        readBytes.add(entry.remaining());\n+        return entry;\n     }\n \n     // The rest of the code is test stuff"},{"sha":"9fbe866fc0404985601e487f1ecdcbfdfa9261f0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","status":"modified","additions":75,"deletions":15,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -27,12 +27,22 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.concurrent.ConcurrentSkipListMap;\n \n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_FLUSH_BYTES;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_GET_ENTRY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_PUT_ENTRY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_SNAPSHOT;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SKIP_LIST_THROTTLING;\n+\n /**\n  * The EntryMemTable holds in-memory representation to the entries not-yet flushed.\n  * When asked to flush, current EntrySkipList is moved to snapshot and is cleared.\n@@ -101,11 +111,19 @@ private EntrySkipList newSkipList() {\n         return new EntrySkipList(checkpointSource.newCheckpoint());\n     }\n \n+    // Stats\n+    private final OpStatsLogger snapshotStats;\n+    private final OpStatsLogger putEntryStats;\n+    private final OpStatsLogger getEntryStats;\n+    private final Counter flushBytesCounter;\n+    private final Counter throttlingCounter;\n+\n     /**\n     * Constructor.\n     * @param conf Server configuration\n     */\n-    public EntryMemTable(final ServerConfiguration conf, final CheckpointSource source) {\n+    public EntryMemTable(final ServerConfiguration conf, final CheckpointSource source,\n+                         final StatsLogger statsLogger) {\n         this.checkpointSource = source;\n         this.kvmap = newSkipList();\n         this.snapshot = EntrySkipList.EMPTY_VALUE;\n@@ -114,6 +132,13 @@ public EntryMemTable(final ServerConfiguration conf, final CheckpointSource sour\n         this.allocator = new SkipListArena(conf);\n         // skip list size limit\n         this.skipListSizeLimit = conf.getSkipListSizeLimit();\n+\n+        // Stats\n+        this.snapshotStats = statsLogger.getOpStatsLogger(SKIP_LIST_SNAPSHOT);\n+        this.putEntryStats = statsLogger.getOpStatsLogger(SKIP_LIST_PUT_ENTRY);\n+        this.getEntryStats = statsLogger.getOpStatsLogger(SKIP_LIST_GET_ENTRY);\n+        this.flushBytesCounter = statsLogger.getCounter(SKIP_LIST_FLUSH_BYTES);\n+        this.throttlingCounter = statsLogger.getCounter(SKIP_LIST_THROTTLING);\n     }\n \n     void dump() {\n@@ -143,6 +168,7 @@ Checkpoint snapshot(Checkpoint oldCp) throws IOException {\n         // No-op if snapshot currently has entries\n         if (this.snapshot.isEmpty() &&\n                 this.kvmap.compareTo(oldCp) < 0) {\n+            final long startTimeNanos = MathUtils.nowInNano();\n             this.lock.writeLock().lock();\n             try {\n                 if (this.snapshot.isEmpty() && !this.kvmap.isEmpty()\n@@ -159,6 +185,12 @@ Checkpoint snapshot(Checkpoint oldCp) throws IOException {\n             } finally {\n                 this.lock.writeLock().unlock();\n             }\n+\n+            if (null != cp) {\n+                snapshotStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            } else {\n+                snapshotStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            }\n         }\n         return cp;\n     }\n@@ -207,6 +239,7 @@ private long flushSnapshot(final SkipListFlusher flusher, Checkpoint checkpoint)\n                             }\n                         }\n                     }\n+                    flushBytesCounter.add(size);\n                     clearSnapshot(keyValues);\n                 }\n             }\n@@ -242,6 +275,7 @@ private void throttleWriters() {\n         } catch (InterruptedException e) {\n             Thread.currentThread().interrupt();\n         }\n+        throttlingCounter.inc();\n     }\n \n     /**\n@@ -252,24 +286,34 @@ private void throttleWriters() {\n     public long addEntry(long ledgerId, long entryId, final ByteBuffer entry, final CacheCallback cb)\n             throws IOException {\n         long size = 0;\n-        if (isSizeLimitReached()) {\n-            Checkpoint cp = snapshot();\n-            if (null != cp) {\n-                cb.onSizeLimitReached();\n-            } else {\n-                throttleWriters();\n+        long startTimeNanos = MathUtils.nowInNano();\n+        boolean success = false;\n+        try {\n+            if (isSizeLimitReached()) {\n+                Checkpoint cp = snapshot();\n+                if (null != cp) {\n+                    cb.onSizeLimitReached();\n+                } else {\n+                    throttleWriters();\n+                }\n             }\n-        }\n \n-        this.lock.readLock().lock();\n-        try {\n-            EntryKeyValue toAdd = cloneWithAllocator(ledgerId, entryId, entry);\n-            size = internalAdd(toAdd);\n+            this.lock.readLock().lock();\n+            try {\n+                EntryKeyValue toAdd = cloneWithAllocator(ledgerId, entryId, entry);\n+                size = internalAdd(toAdd);\n+            } finally {\n+                this.lock.readLock().unlock();\n+            }\n+            success = true;\n+            return size;\n         } finally {\n-            this.lock.readLock().unlock();\n+            if (success) {\n+                putEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            } else {\n+                putEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            }\n         }\n-\n-        return size;\n     }\n \n     /**\n@@ -326,14 +370,22 @@ private EntryKeyValue cloneWithAllocator(long ledgerId, long entryId, final Byte\n     public EntryKeyValue getEntry(long ledgerId, long entryId) throws IOException {\n         EntryKey key = new EntryKey(ledgerId, entryId);\n         EntryKeyValue value = null;\n+        long startTimeNanos = MathUtils.nowInNano();\n+        boolean success = false;\n         this.lock.readLock().lock();\n         try {\n             value = this.kvmap.get(key);\n             if (value == null) {\n                 value = this.snapshot.get(key);\n             }\n+            success = true;\n         } finally {\n             this.lock.readLock().unlock();\n+            if (success) {\n+                getEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            } else {\n+                getEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            }\n         }\n \n         return value;\n@@ -347,14 +399,22 @@ public EntryKeyValue getEntry(long ledgerId, long entryId) throws IOException {\n     public EntryKeyValue getLastEntry(long ledgerId) throws IOException {\n         EntryKey result = null;\n         EntryKey key = new EntryKey(ledgerId, Long.MAX_VALUE);\n+        long startTimeNanos = MathUtils.nowInNano();\n+        boolean success = false;\n         this.lock.readLock().lock();\n         try {\n             result = this.kvmap.floorKey(key);\n             if (result == null || result.getLedgerId() != ledgerId) {\n                 result = this.snapshot.floorKey(key);\n             }\n+            success = true;\n         } finally {\n             this.lock.readLock().unlock();\n+            if (success) {\n+                getEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            } else {\n+                getEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            }\n         }\n \n         if (result == null || result.getLedgerId() != ledgerId) {"},{"sha":"454a38335c8fb3ddaca268ece564c6ae171fef1f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","status":"modified","additions":18,"deletions":1,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -21,6 +21,8 @@\n package org.apache.bookkeeper.bookie;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.stats.Gauge;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -39,6 +41,8 @@\n import java.util.concurrent.ConcurrentSkipListSet;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_INDEX_PAGES;\n+\n class IndexInMemPageMgr {\n     private final static Logger LOG = LoggerFactory.getLogger(IndexInMemPageMgr.class);\n     private final static ConcurrentHashMap<Long, LedgerEntryPage> EMPTY_PAGE_MAP\n@@ -321,7 +325,8 @@ public void onSetDirty(LedgerEntryPage lep) {\n     public IndexInMemPageMgr(int pageSize,\n                              int entriesPerPage,\n                              ServerConfiguration conf,\n-                             IndexPersistenceMgr indexPersistenceManager) {\n+                             IndexPersistenceMgr indexPersistenceManager,\n+                             StatsLogger statsLogger) {\n         this.pageSize = pageSize;\n         this.entriesPerPage = entriesPerPage;\n         this.indexPersistenceManager = indexPersistenceManager;\n@@ -335,6 +340,18 @@ public IndexInMemPageMgr(int pageSize,\n         }\n         LOG.info(\"maxMemory = {}, pageSize = {}, pageLimit = {}\", new Object[] { Runtime.getRuntime().maxMemory(),\n                         pageSize, pageLimit });\n+        // Expose Stats\n+        statsLogger.registerGauge(NUM_INDEX_PAGES, new Gauge<Number>() {\n+            @Override\n+            public Number getDefaultValue() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public Number getSample() {\n+                return getNumUsedPages();\n+            }\n+        });\n     }\n \n     /**"},{"sha":"60b409951cef808ec8718fba4984c6042615f07f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":26,"deletions":4,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -23,7 +23,6 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.LinkedList;\n@@ -35,12 +34,18 @@\n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.Gauge;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.SnapshotMap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.common.annotations.VisibleForTesting;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_NUM_EVICTED_LEDGERS;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_OPEN_LEDGERS;\n+\n public class IndexPersistenceMgr {\n     private final static Logger LOG = LoggerFactory.getLogger(IndexPersistenceMgr.class);\n \n@@ -72,11 +77,15 @@ public static final String getLedgerName(long ledgerId) {\n     private LedgerDirsManager ledgerDirsManager;\n     final LinkedList<Long> openLedgers = new LinkedList<Long>();\n \n+    // Stats\n+    private final Counter evictedLedgersCounter;\n+\n     public IndexPersistenceMgr(int pageSize,\n                                int entriesPerPage,\n                                ServerConfiguration conf,\n                                SnapshotMap<Long, Boolean> activeLedgers,\n-                               LedgerDirsManager ledgerDirsManager) throws IOException {\n+                               LedgerDirsManager ledgerDirsManager,\n+                               StatsLogger statsLogger) throws IOException {\n         this.openFileLimit = conf.getOpenFileLimit();\n         this.activeLedgers = activeLedgers;\n         this.ledgerDirsManager = ledgerDirsManager;\n@@ -86,6 +95,20 @@ public IndexPersistenceMgr(int pageSize,\n         // Retrieve all of the active ledgers.\n         getActiveLedgers();\n         ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n+\n+        // Expose Stats\n+        evictedLedgersCounter = statsLogger.getCounter(LEDGER_CACHE_NUM_EVICTED_LEDGERS);\n+        statsLogger.registerGauge(NUM_OPEN_LEDGERS, new Gauge<Integer>() {\n+            @Override\n+            public Integer getDefaultValue() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public Integer getSample() {\n+                return getNumOpenLedgers();\n+            }\n+        });\n     }\n \n     FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n@@ -270,8 +293,7 @@ private void evictFileInfoIfNecessary() throws IOException {\n                 // was executing.\n                 return;\n             }\n-            // TODO Add a statistic here, we don't care really which\n-            // ledger is evicted, but the rate at which they get evicted\n+            evictedLedgersCounter.inc();\n             FileInfo fi = fileInfoCache.remove(ledgerToRemove);\n             if (null == fi) {\n                 // Seems like someone else already closed the file."},{"sha":"1a69692207b6b1a65a8590a99fa8596febd3e81c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":46,"deletions":8,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -27,16 +27,22 @@\n \n import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogListener;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.SnapshotMap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.STORAGE_GET_ENTRY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.STORAGE_GET_OFFSET;\n+\n /**\n  * Interleave ledger storage\n  * This ledger storage implementation stores all entries in a single\n@@ -82,24 +88,31 @@ protected synchronized Checkpoint getLastCheckpoint() {\n     // this indicates that a write has happened since the last flush\n     private volatile boolean somethingWritten = false;\n \n+    // Expose Stats\n+    private final OpStatsLogger getOffsetStats;\n+    private final OpStatsLogger getEntryStats;\n+\n     InterleavedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n                              LedgerDirsManager ledgerDirsManager, CheckpointSource checkpointSource)\n             throws IOException {\n-        this(conf, ledgerManager, ledgerDirsManager, ledgerDirsManager, checkpointSource);\n+        this(conf, ledgerManager, ledgerDirsManager, ledgerDirsManager, checkpointSource, NullStatsLogger.INSTANCE);\n     }\n \n     InterleavedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n                              LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n-                             CheckpointSource checkpointSource)\n+                             CheckpointSource checkpointSource, StatsLogger statsLogger)\n             throws IOException {\n         activeLedgers = new SnapshotMap<Long, Boolean>();\n         this.checkpointSource = checkpointSource;\n         entryLogger = new EntryLogger(conf, ledgerDirsManager, this);\n         ledgerCache = new LedgerCacheImpl(conf, activeLedgers,\n-                null == indexDirsManager ? ledgerDirsManager : indexDirsManager);\n+                null == indexDirsManager ? ledgerDirsManager : indexDirsManager, statsLogger);\n         gcThread = new GarbageCollectorThread(conf, ledgerCache, entryLogger,\n                 activeLedgers, ledgerManager);\n         ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n+        // Expose Stats\n+        getOffsetStats = statsLogger.getOpStatsLogger(STORAGE_GET_OFFSET);\n+        getEntryStats = statsLogger.getOpStatsLogger(STORAGE_GET_ENTRY);\n     }\n \n     private LedgerDirsListener getLedgerDirsListener() {\n@@ -208,11 +221,36 @@ public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n             entryId = ledgerCache.getLastEntry(ledgerId);\n         }\n \n-        offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n-        if (offset == 0) {\n-            throw new Bookie.NoEntryException(ledgerId, entryId);\n+        // Get Offset\n+        long startTimeNanos = MathUtils.nowInNano();\n+        boolean success = false;\n+        try {\n+            offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n+            if (offset == 0) {\n+                throw new Bookie.NoEntryException(ledgerId, entryId);\n+            }\n+            success = true;\n+        } finally {\n+            if (success) {\n+                getOffsetStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            } else {\n+                getOffsetStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            }\n+        }\n+        // Get Entry\n+        startTimeNanos = MathUtils.nowInNano();\n+        success = false;\n+        try {\n+            byte[] retBytes = entryLogger.readEntry(ledgerId, entryId, offset);\n+            success = true;\n+            return ByteBuffer.wrap(retBytes);\n+        } finally {\n+            if (success) {\n+                getEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            } else {\n+                getEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            }\n         }\n-        return ByteBuffer.wrap(entryLogger.readEntry(ledgerId, entryId, offset));\n     }\n \n     private void flushOrCheckpoint(boolean isCheckpointFlush)"},{"sha":"ad48386ca666eb7fbde98f469ad0edd5801e6935","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":68,"deletions":2,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -35,16 +35,23 @@\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n \n+import com.google.common.base.Stopwatch;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.DaemonThreadFactory;\n import org.apache.bookkeeper.util.IOUtils;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.ZeroBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.*;\n+\n /**\n  * Provide journal related management.\n  */\n@@ -287,7 +294,7 @@ public void callback() {\n         }\n     }\n \n-    private class ForceWriteRequest extends BookieCriticalThread {\n+    private class ForceWriteRequest implements Runnable {\n         private final JournalChannel logFile;\n         private final LinkedList<QueueEntry> forceWriteWaiters;\n         private boolean shouldClose;\n@@ -301,16 +308,17 @@ private ForceWriteRequest(JournalChannel logFile,\n                           LinkedList<QueueEntry> forceWriteWaiters,\n                           boolean shouldClose,\n                           boolean isMarker) {\n-            super(\"ForceWriteRequestThread\");\n             this.forceWriteWaiters = forceWriteWaiters;\n             this.logFile = logFile;\n             this.logId = logId;\n             this.lastFlushedPosition = lastFlushedPosition;\n             this.shouldClose = shouldClose;\n             this.isMarker = isMarker;\n+            forceWriteQueueSize.inc();\n         }\n \n         public int process(boolean shouldForceWrite) throws IOException {\n+            forceWriteQueueSize.dec();\n             if (isMarker) {\n                 return 0;\n             }\n@@ -334,6 +342,7 @@ public int process(boolean shouldForceWrite) throws IOException {\n         @Override\n         public void run() {\n             for (QueueEntry e : this.forceWriteWaiters) {\n+                journalAddEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(e.enqueueTime));\n                 e.callback();    // Process cbs inline\n             }\n         }\n@@ -397,6 +406,7 @@ public void run() {\n                             // the last force write and then reset the counter so we can accumulate\n                             // requests in the write we are about to issue\n                             if (numReqInLastForceWrite > 0) {\n+                                forceWriteGroupingCountStats.registerSuccessfulEvent(numReqInLastForceWrite);\n                                 numReqInLastForceWrite = 0;\n                             }\n                         }\n@@ -506,7 +516,25 @@ static void writePaddingBytes(JournalChannel jc, ByteBuffer paddingBuffer, int j\n     volatile boolean running = true;\n     private final LedgerDirsManager ledgerDirsManager;\n \n+    // Expose Stats\n+    private final OpStatsLogger journalAddEntryStats;\n+    private final OpStatsLogger journalCreationStats;\n+    private final OpStatsLogger journalFlushStats;\n+    private final OpStatsLogger forceWriteGroupingCountStats;\n+    private final OpStatsLogger forceWriteBatchEntriesStats;\n+    private final OpStatsLogger forceWriteBatchBytesStats;\n+    private final Counter journalQueueSize;\n+    private final Counter forceWriteQueueSize;\n+    private final Counter flushMaxWaitCounter;\n+    private final Counter flushMaxOutstandingBytesCounter;\n+    private final Counter flushEmptyQueueCounter;\n+    private final Counter journalWriteBytes;\n+\n     public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager) {\n+        this(conf, ledgerDirsManager, NullStatsLogger.INSTANCE);\n+    }\n+\n+    public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager, StatsLogger statsLogger) {\n         super(\"BookieJournal-\" + conf.getBookiePort());\n         this.ledgerDirsManager = ledgerDirsManager;\n         this.conf = conf;\n@@ -530,6 +558,20 @@ public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager) {\n         // read last log mark\n         lastLogMark.readLog();\n         LOG.debug(\"Last Log Mark : {}\", lastLogMark.getCurMark());\n+\n+        // Expose Stats\n+        journalAddEntryStats = statsLogger.getOpStatsLogger(JOURNAL_ADD_ENTRY);\n+        journalCreationStats = statsLogger.getOpStatsLogger(JOURNAL_CREATION_LATENCY);\n+        journalFlushStats = statsLogger.getOpStatsLogger(JOURNAL_FLUSH_LATENCY);\n+        forceWriteGroupingCountStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_GROUPING_COUNT);\n+        forceWriteBatchEntriesStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_BATCH_ENTRIES);\n+        forceWriteBatchBytesStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_BATCH_BYTES);\n+        journalQueueSize = statsLogger.getCounter(JOURNAL_QUEUE_SIZE);\n+        forceWriteQueueSize = statsLogger.getCounter(JOURNAL_FORCE_WRITE_QUEUE_SIZE);\n+        flushMaxWaitCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_MAX_WAIT);\n+        flushMaxOutstandingBytesCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES);\n+        flushEmptyQueueCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_EMPTY_QUEUE);\n+        journalWriteBytes = statsLogger.getCounter(JOURNAL_WRITE_BYTES);\n     }\n \n     LastLogMark getLastLogMark() {\n@@ -703,6 +745,7 @@ public void logAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx) {\n         long ledgerId = entry.getLong();\n         long entryId = entry.getLong();\n         entry.rewind();\n+        journalQueueSize.inc();\n         queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx, MathUtils.nowInNano()));\n     }\n \n@@ -738,6 +781,9 @@ public void run() {\n         ZeroBuffer.put(paddingBuff);\n         JournalChannel logFile = null;\n         forceWriteThread.start();\n+        Stopwatch journalCreationWatcher = new Stopwatch();\n+        Stopwatch journalFlushWatcher = new Stopwatch();\n+        long batchSize = 0;\n         try {\n             List<Long> journalIds = listJournalIds(journalDirectory, null);\n             // Should not use MathUtils.now(), which use System.nanoTime() and\n@@ -753,13 +799,18 @@ public void run() {\n                 // new journal file to write\n                 if (null == logFile) {\n                     logId = logId + 1;\n+\n+                    journalCreationWatcher.reset().start();\n                     logFile = new JournalChannel(journalDirectory,\n                                         logId,\n                                         journalPreAllocSize,\n                                         journalWriteBufferSize,\n                                         conf.getJournalAlignmentSize(),\n                                         removePagesFromCache,\n                                         conf.getJournalFormatVersionToWrite());\n+                    journalCreationStats.registerSuccessfulEvent(\n+                            journalCreationWatcher.stop().elapsedTime(TimeUnit.MILLISECONDS));\n+\n                     bc = logFile.getBufferedChannel();\n \n                     lastFlushPosition = bc.position();\n@@ -787,26 +838,32 @@ public void run() {\n                             // b) limit the number of entries to group\n                             groupWhenTimeout = false;\n                             shouldFlush = true;\n+                            flushMaxWaitCounter.inc();\n                         } else if (qe != null &&\n                                 ((bufferedEntriesThreshold > 0 && toFlush.size() > bufferedEntriesThreshold) ||\n                                  (bc.position() > lastFlushPosition + bufferedWritesThreshold))) {\n                             // 2. If we have buffered more than the buffWriteThreshold or bufferedEntriesThreshold\n                             shouldFlush = true;\n+                            flushMaxOutstandingBytesCounter.inc();\n                         } else if (qe == null) {\n                             // We should get here only if we flushWhenQueueEmpty is true else we would wait\n                             // for timeout that would put is past the maxWait threshold\n                             // 3. If the queue is empty i.e. no benefit of grouping. This happens when we have one\n                             // publish at a time - common case in tests.\n                             shouldFlush = true;\n+                            flushEmptyQueueCounter.inc();\n                         }\n \n                         // toFlush is non null and not empty so should be safe to access getFirst\n                         if (shouldFlush) {\n                             if (conf.getJournalFormatVersionToWrite() >= JournalChannel.V5) {\n                                 writePaddingBytes(logFile, paddingBuff, conf.getJournalAlignmentSize());\n                             }\n+                            journalFlushWatcher.reset().start();\n                             bc.flush(false);\n                             lastFlushPosition = bc.position();\n+                            journalFlushStats.registerSuccessfulEvent(\n+                                    journalFlushWatcher.stop().elapsedTime(TimeUnit.MILLISECONDS));\n \n                             // Trace the lifetime of entries through persistence\n                             if (LOG.isDebugEnabled()) {\n@@ -815,8 +872,12 @@ public void run() {\n                                 }\n                             }\n \n+                            forceWriteBatchEntriesStats.registerSuccessfulEvent(toFlush.size());\n+                            forceWriteBatchBytesStats.registerSuccessfulEvent(batchSize);\n+\n                             forceWriteRequests.put(new ForceWriteRequest(logFile, logId, lastFlushPosition, toFlush, (lastFlushPosition > maxJournalSize), false));\n                             toFlush = new LinkedList<QueueEntry>();\n+                            batchSize = 0L;\n                             // check whether journal file is over file limit\n                             if (bc.position() > maxJournalSize) {\n                                 logFile = null;\n@@ -835,6 +896,11 @@ public void run() {\n                     continue;\n                 }\n \n+                journalWriteBytes.add(qe.entry.remaining());\n+                journalQueueSize.dec();\n+\n+                batchSize += (4 + qe.entry.remaining());\n+\n                 lenBuff.clear();\n                 lenBuff.putInt(qe.entry.remaining());\n                 lenBuff.flip();"},{"sha":"e6d2edd92d43d15205b8919cfef3e9582a79a905","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":11,"deletions":3,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -24,6 +24,8 @@\n import java.io.IOException;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.SnapshotMap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -41,12 +43,18 @@\n     private final int entriesPerPage;\n \n     public LedgerCacheImpl(ServerConfiguration conf, SnapshotMap<Long, Boolean> activeLedgers,\n-                    LedgerDirsManager ledgerDirsManager) throws IOException {\n+                           LedgerDirsManager ledgerDirsManager) throws IOException {\n+        this(conf, activeLedgers, ledgerDirsManager, NullStatsLogger.INSTANCE);\n+    }\n+\n+    public LedgerCacheImpl(ServerConfiguration conf, SnapshotMap<Long, Boolean> activeLedgers,\n+                           LedgerDirsManager ledgerDirsManager, StatsLogger statsLogger) throws IOException {\n         this.pageSize = conf.getPageSize();\n         this.entriesPerPage = pageSize / 8;\n         this.indexPersistenceManager = new IndexPersistenceMgr(pageSize, entriesPerPage, conf, activeLedgers,\n-                        ledgerDirsManager);\n-        this.indexPageManager = new IndexInMemPageMgr(pageSize, entriesPerPage, conf, indexPersistenceManager);\n+                ledgerDirsManager, statsLogger);\n+        this.indexPageManager = new IndexInMemPageMgr(pageSize, entriesPerPage, conf,\n+                indexPersistenceManager, statsLogger);\n     }\n \n     IndexPersistenceMgr getIndexPersistenceManager() {"},{"sha":"935befb2fd73d07ce2bee150773f9a9705b0df35","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"modified","additions":51,"deletions":5,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -26,8 +26,13 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.stats.Gauge;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.DiskChecker;\n import org.apache.bookkeeper.util.DiskChecker.DiskErrorException;\n import org.apache.bookkeeper.util.DiskChecker.DiskOutOfSpaceException;\n@@ -37,6 +42,8 @@\n \n import com.google.common.annotations.VisibleForTesting;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_WRITABLE_DIRS;\n+\n /**\n  * This class manages ledger directories used by the bookie.\n  */\n@@ -51,15 +58,48 @@\n     private final List<LedgerDirsListener> listeners;\n     private final LedgerDirsMonitor monitor;\n     private final Random rand = new Random();\n+    private final ConcurrentMap<File, Float> diskUsages =\n+            new ConcurrentHashMap<File, Float>();\n \n     public LedgerDirsManager(ServerConfiguration conf, File[] dirs) {\n+        this(conf, dirs, NullStatsLogger.INSTANCE);\n+    }\n+\n+    LedgerDirsManager(ServerConfiguration conf, File[] dirs, StatsLogger statsLogger) {\n         this.ledgerDirectories = Arrays.asList(Bookie\n                 .getCurrentDirectories(dirs));\n         this.writableLedgerDirectories = new ArrayList<File>(ledgerDirectories);\n         this.filledDirs = new ArrayList<File>();\n-        listeners = new ArrayList<LedgerDirsManager.LedgerDirsListener>();\n+        listeners = new ArrayList<LedgerDirsListener>();\n         diskChecker = new DiskChecker(conf.getDiskUsageThreshold(), conf.getDiskUsageWarnThreshold());\n         monitor = new LedgerDirsMonitor(conf.getDiskCheckInterval());\n+        for (File dir : dirs) {\n+            diskUsages.put(dir, 0f);\n+            String statName = \"dir_\" + dir.getPath().replace('/', '_') + \"_usage\";\n+            final File targetDir = dir;\n+            statsLogger.registerGauge(statName, new Gauge<Number>() {\n+                @Override\n+                public Number getDefaultValue() {\n+                    return 0;\n+                }\n+\n+                @Override\n+                public Number getSample() {\n+                    return diskUsages.get(targetDir) * 100;\n+                }\n+            });\n+        }\n+        statsLogger.registerGauge(LD_WRITABLE_DIRS, new Gauge<Number>() {\n+            @Override\n+            public Number getDefaultValue() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public Number getSample() {\n+                return writableLedgerDirectories.size();\n+            }\n+        });\n     }\n \n     /**\n@@ -192,7 +232,7 @@ public void addLedgerDirsListener(LedgerDirsListener listener) {\n \n     /**\n      * Sweep through all the directories to check disk errors or disk full.\n-     * \n+     *\n      * @throws DiskErrorException\n      *             If disk having errors\n      * @throws NoWritableLedgerDirException\n@@ -246,18 +286,22 @@ public void run() {\n                 // Check all writable dirs disk space usage.\n                 for (File dir : writableDirs) {\n                     try {\n-                        diskChecker.checkDir(dir);\n+                        diskUsages.put(dir, diskChecker.checkDir(dir));\n                     } catch (DiskErrorException e) {\n+                        LOG.error(\"Ledger directory {} failed on disk checking : \", dir, e);\n                         // Notify disk failure to all listeners\n                         for (LedgerDirsListener listener : listeners) {\n-                            LOG.warn(\"{} has errors.\", dir, e);\n                             listener.diskFailed(dir);\n                         }\n                     } catch (DiskWarnThresholdException e) {\n+                        LOG.warn(\"Ledger directory {} is almost full.\", dir);\n+                        diskUsages.put(dir, e.getUsage());\n                         for (LedgerDirsListener listener : listeners) {\n                             listener.diskAlmostFull(dir);\n                         }\n                     } catch (DiskOutOfSpaceException e) {\n+                        LOG.error(\"Ledger directory {} is out-of-space.\", dir);\n+                        diskUsages.put(dir, e.getUsage());\n                         // Notify disk full to all listeners\n                         addToFilledDirs(dir);\n                     }\n@@ -266,18 +310,20 @@ public void run() {\n                 // Check all full-filled disk space usage\n                 for (File dir : fullfilledDirs) {\n                     try {\n-                        diskChecker.checkDir(dir);\n+                        diskUsages.put(dir, diskChecker.checkDir(dir));\n                         addToWritableDirs(dir, true);\n                     } catch (DiskErrorException e) {\n                         //Notify disk failure to all the listeners\n                         for (LedgerDirsListener listener : listeners) {\n                             listener.diskFailed(dir);\n                         }\n                     } catch (DiskWarnThresholdException e) {\n+                        diskUsages.put(dir, e.getUsage());\n                         // the full-filled dir become writable but still above warn threshold\n                         addToWritableDirs(dir, false);\n                     } catch (DiskOutOfSpaceException e) {\n                         // the full-filled dir is still full-filled\n+                        diskUsages.put(dir, e.getUsage());\n                     }\n                 }\n                 try {"},{"sha":"0a3884c2636fed66618af2ab9a8c3bf87abf8bbc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -31,6 +31,7 @@\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -43,10 +44,10 @@\n \n     public SortedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n                                LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n-                               final CheckpointSource checkpointSource)\n+                               final CheckpointSource checkpointSource, StatsLogger statsLogger)\n                                        throws IOException {\n-        super(conf, ledgerManager, ledgerDirsManager, indexDirsManager, null);\n-        this.memTable = new EntryMemTable(conf, checkpointSource);\n+        super(conf, ledgerManager, ledgerDirsManager, indexDirsManager, null, statsLogger);\n+        this.memTable = new EntryMemTable(conf, checkpointSource, statsLogger);\n         this.scheduler = Executors.newSingleThreadScheduledExecutor(\n                 new ThreadFactoryBuilder()\n                 .setNameFormat(\"SortedLedgerStorage-%d\")"},{"sha":"fcde43fb7a7d74d57eda192d2253b5a94b43e3ea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":54,"deletions":21,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -21,6 +21,9 @@\n import java.util.List;\n \n import com.google.common.annotations.Beta;\n+import org.apache.bookkeeper.stats.NullStatsProvider;\n+import org.apache.bookkeeper.stats.StatsProvider;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.lang.StringUtils;\n \n@@ -76,8 +79,6 @@\n     // Zookeeper Parameters\n     protected final static String ZK_TIMEOUT = \"zkTimeout\";\n     protected final static String ZK_SERVERS = \"zkServers\";\n-    // Statistics Parameters\n-    protected final static String ENABLE_STATISTICS = \"enableStatistics\";\n     protected final static String OPEN_LEDGER_REREPLICATION_GRACE_PERIOD = \"openLedgerRereplicationGracePeriod\";\n     //ReadOnly mode support on all disk full\n     protected final static String READ_ONLY_MODE_ENABLED = \"readOnlyModeEnabled\";\n@@ -104,6 +105,10 @@\n     protected final static String SKIP_LIST_CHUNK_SIZE_ENTRY = \"skipListArenaChunkSize\";\n     protected final static String SKIP_LIST_MAX_ALLOC_ENTRY = \"skipListArenaMaxAllocSize\";\n \n+    // Statistics Parameters\n+    protected final static String ENABLE_STATISTICS = \"enableStatistics\";\n+    protected final static String STATS_PROVIDER_CLASS = \"statsProviderClass\";\n+\n     /**\n      * Construct a default configuration object\n      */\n@@ -1286,26 +1291,10 @@ public ServerConfiguration setJournalRemovePagesFromCache(boolean enabled) {\n         return this;\n     }\n \n-    /**\n-     * Validate the configuration.\n-     * @throws ConfigurationException\n-     */\n-    public void validate() throws ConfigurationException {\n-        if (getSkipListArenaChunkSize() < getSkipListArenaMaxAllocSize()) {\n-            throw new ConfigurationException(\"Arena max allocation size should be smaller than the chunk size.\");\n-        }\n-        if (getJournalAlignmentSize() < 512 || getJournalAlignmentSize() % 512 != 0) {\n-            throw new ConfigurationException(\"Invalid journal alignment size : \" + getJournalAlignmentSize());\n-        }\n-        if (getJournalAlignmentSize() > getJournalPreAllocSizeMB() * 1024 * 1024) {\n-            throw new ConfigurationException(\"Invalid preallocation size : \" + getJournalPreAllocSizeMB() + \" MB\");\n-        }\n-    }\n-\n     /**\n      * Get whether bookie is using hostname for registration and in ledger\n      * metadata. Defaults to false.\n-     * \n+     *\n      * @return true, then bookie will be registered with its hostname and\n      *         hostname will be used in ledger metadata. Otherwise bookie will\n      *         use its ipaddress\n@@ -1317,12 +1306,56 @@ public boolean getUseHostNameAsBookieID() {\n     /**\n      * Configure the bookie to use its hostname to register with the\n      * co-ordination service(eg: zookeeper) and in ledger metadata\n-     * \n+     *\n      * @see #getUseHostNameAsBookieID\n      * @param useHostName\n      *            whether to use hostname for registration and in ledgermetadata\n+     * @return server configuration\n      */\n-    public void setUseHostNameAsBookieID(boolean useHostName) {\n+    public ServerConfiguration setUseHostNameAsBookieID(boolean useHostName) {\n         setProperty(USE_HOST_NAME_AS_BOOKIE_ID, useHostName);\n+        return this;\n     }\n+\n+    /**\n+     * Get the stats provider used by bookie.\n+     *\n+     * @return stats provider class\n+     * @throws ConfigurationException\n+     */\n+    public Class<? extends StatsProvider> getStatsProviderClass()\n+        throws ConfigurationException {\n+        return ReflectionUtils.getClass(this, STATS_PROVIDER_CLASS,\n+                                        NullStatsProvider.class, StatsProvider.class,\n+                                        defaultLoader);\n+    }\n+\n+    /**\n+     * Set the stats provider used by bookie.\n+     *\n+     * @param providerClass\n+     *          stats provider class\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setStatsProviderClass(Class<? extends StatsProvider> providerClass) {\n+        setProperty(STATS_PROVIDER_CLASS, providerClass.getName());\n+        return this;\n+    }\n+\n+    /**\n+     * Validate the configuration.\n+     * @throws ConfigurationException\n+     */\n+    public void validate() throws ConfigurationException {\n+        if (getSkipListArenaChunkSize() < getSkipListArenaMaxAllocSize()) {\n+            throw new ConfigurationException(\"Arena max allocation size should be smaller than the chunk size.\");\n+        }\n+        if (getJournalAlignmentSize() < 512 || getJournalAlignmentSize() % 512 != 0) {\n+            throw new ConfigurationException(\"Invalid journal alignment size : \" + getJournalAlignmentSize());\n+        }\n+        if (getJournalAlignmentSize() > getJournalPreAllocSizeMB() * 1024 * 1024) {\n+            throw new ConfigurationException(\"Invalid preallocation size : \" + getJournalPreAllocSizeMB() + \" MB\");\n+        }\n+    }\n+\n }"},{"sha":"9fec15fa6bc0e3a0c5cb62c7b160be9a90b7094b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -26,25 +26,31 @@\n \n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.processor.RequestProcessor;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.ADD_ENTRY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.ADD_ENTRY_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_REQUEST;\n+\n public class BookieRequestProcessor implements RequestProcessor {\n \n     private final static Logger LOG = LoggerFactory.getLogger(BookieRequestProcessor.class);\n     /**\n      * The server configuration. We use this for getting the number of add and read\n      * worker threads.\n      */\n-    private ServerConfiguration serverCfg;\n+    private final ServerConfiguration serverCfg;\n \n     /**\n      * This is the Bookie instance that is used to handle all read and write requests.\n      */\n-    private Bookie bookie;\n+    final Bookie bookie;\n \n     /**\n      * The threadpool used to execute all read entry requests issued to this server.\n@@ -56,10 +62,16 @@\n      */\n     private final ExecutorService writeThreadPool;\n \n+    // Expose Stats\n     private final BKStats bkStats = BKStats.getInstance();\n     private final boolean statsEnabled;\n+    final OpStatsLogger addRequestStats;\n+    final OpStatsLogger addEntryStats;\n+    final OpStatsLogger readRequestStats;\n+    final OpStatsLogger readEntryStats;\n \n-    public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie) {\n+    public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n+                                  StatsLogger statsLogger) {\n         this.serverCfg = serverCfg;\n         this.bookie = bookie;\n         this.readThreadPool =\n@@ -68,7 +80,12 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie) {\n         this.writeThreadPool =\n             createExecutor(this.serverCfg.getNumAddWorkerThreads(),\n                            \"BookieWriteThread-\" + serverCfg.getBookiePort() + \"-%d\");\n+        // Expose Stats\n         this.statsEnabled = serverCfg.isStatisticsEnabled();\n+        this.addEntryStats = statsLogger.getOpStatsLogger(ADD_ENTRY);\n+        this.addRequestStats = statsLogger.getOpStatsLogger(ADD_ENTRY_REQUEST);\n+        this.readEntryStats = statsLogger.getOpStatsLogger(READ_ENTRY);\n+        this.readRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_REQUEST);\n     }\n \n     @Override\n@@ -138,7 +155,7 @@ public void processRequest(Object msg, Channel c) {\n     }\n \n     private void processAddRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n-        WriteEntryProcessorV3 write = new WriteEntryProcessorV3(r, c, bookie);\n+        WriteEntryProcessorV3 write = new WriteEntryProcessorV3(r, c, this);\n         if (null == writeThreadPool) {\n             write.run();\n         } else {\n@@ -147,7 +164,7 @@ private void processAddRequestV3(final BookkeeperProtocol.Request r, final Chann\n     }\n \n     private void processReadRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n-        ReadEntryProcessorV3 read = new ReadEntryProcessorV3(r, c, bookie);\n+        ReadEntryProcessorV3 read = new ReadEntryProcessorV3(r, c, this);\n         if (null == readThreadPool) {\n             read.run();\n         } else {\n@@ -156,7 +173,7 @@ private void processReadRequestV3(final BookkeeperProtocol.Request r, final Chan\n     }\n \n     private void processAddRequest(final BookieProtocol.Request r, final Channel c) {\n-        WriteEntryProcessor write = new WriteEntryProcessor(r, c, bookie);\n+        WriteEntryProcessor write = new WriteEntryProcessor(r, c, this);\n         if (null == writeThreadPool) {\n             write.run();\n         } else {\n@@ -165,7 +182,7 @@ private void processAddRequest(final BookieProtocol.Request r, final Channel c)\n     }\n \n     private void processReadRequest(final BookieProtocol.Request r, final Channel c) {\n-        ReadEntryProcessor read = new ReadEntryProcessor(r, c, bookie);\n+        ReadEntryProcessor read = new ReadEntryProcessor(r, c, this);\n         if (null == readThreadPool) {\n             read.run();\n         } else {"},{"sha":"836ccb727a12e42a85713f16cc0113489bbba35a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":29,"deletions":3,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -36,6 +36,10 @@\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.stats.StatsProvider;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.commons.cli.BasicParser;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.HelpFormatter;\n@@ -48,6 +52,9 @@\n \n import com.google.common.annotations.VisibleForTesting;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIE_SCOPE;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.SERVER_SCOPE;\n+\n /**\n  * Implements the server-side part of the BookKeeper protocol.\n  *\n@@ -70,12 +77,23 @@\n     // request processor\n     private final RequestProcessor requestProcessor;\n \n+    // Expose Stats\n+    private final StatsLogger statsLogger;\n+\n     public BookieServer(ServerConfiguration conf) throws IOException,\n             KeeperException, InterruptedException, BookieException,\n             UnavailableException, CompatibilityException {\n+        this(conf, NullStatsLogger.INSTANCE);\n+    }\n+\n+    public BookieServer(ServerConfiguration conf, StatsLogger statsLogger)\n+            throws IOException, KeeperException, InterruptedException,\n+            BookieException, UnavailableException, CompatibilityException {\n         this.conf = conf;\n+        this.statsLogger = statsLogger;\n         this.bookie = newBookie(conf);\n-        this.requestProcessor = new BookieRequestProcessor(conf, bookie);\n+        this.requestProcessor = new BookieRequestProcessor(conf, bookie,\n+                statsLogger.scope(SERVER_SCOPE));\n         this.nettyServer = new BookieNettyServer(this.conf, requestProcessor);\n         isAutoRecoveryDaemonEnabled = conf.isAutoRecoveryDaemonEnabled();\n         if (isAutoRecoveryDaemonEnabled) {\n@@ -85,7 +103,7 @@ public BookieServer(ServerConfiguration conf) throws IOException,\n \n     protected Bookie newBookie(ServerConfiguration conf)\n         throws IOException, KeeperException, InterruptedException, BookieException {\n-        return new Bookie(conf);\n+        return new Bookie(conf, statsLogger.scope(BOOKIE_SCOPE));\n     }\n \n     public void start() throws IOException, UnavailableException {\n@@ -349,7 +367,13 @@ public static void main(String[] args) {\n                            conf.getJournalDirName(), sb);\n         LOG.info(hello);\n         try {\n-            final BookieServer bs = new BookieServer(conf);\n+            // Initialize Stats Provider\n+            Class<? extends StatsProvider> statsProviderClass =\n+                    conf.getStatsProviderClass();\n+            final StatsProvider statsProvider = ReflectionUtils.newInstance(statsProviderClass);\n+            statsProvider.start(conf);\n+\n+            final BookieServer bs = new BookieServer(conf, statsProvider.getStatsLogger(\"\"));\n             bs.start();\n             Runtime.getRuntime().addShutdownHook(new Thread() {\n                 @Override\n@@ -361,6 +385,8 @@ public void run() {\n             LOG.info(\"Register shutdown hook successfully\");\n             bs.join();\n \n+            statsProvider.stop();\n+            LOG.info(\"Stop stats provider\");\n             System.exit(bs.getExitCode());\n         } catch (Exception e) {\n             LOG.error(\"Exception running bookie server : \", e);"},{"sha":"b247616839d306e645899fdb7f6724911547ae24","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","status":"modified","additions":20,"deletions":5,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -17,8 +17,10 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.proto.BookieProtocol.Request;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -27,12 +29,14 @@\n     private final static Logger logger = LoggerFactory.getLogger(PacketProcessorBase.class);\n     final Request request;\n     final Channel channel;\n-    final Bookie bookie;\n+    final BookieRequestProcessor requestProcessor;\n+    final long enqueueNanos;\n \n-    PacketProcessorBase(Request request, Channel channel, Bookie bookie) {\n+    PacketProcessorBase(Request request, Channel channel, BookieRequestProcessor requestProcessor) {\n         this.request = request;\n         this.channel = channel;\n-        this.bookie = bookie;\n+        this.requestProcessor = requestProcessor;\n+        this.enqueueNanos = MathUtils.nowInNano();\n     }\n \n     protected boolean isVersionCompatible() {\n@@ -48,10 +52,21 @@ protected boolean isVersionCompatible() {\n         return true;\n     }\n \n+    protected void sendResponse(int rc, Object response, OpStatsLogger statsLogger) {\n+        channel.write(response);\n+        if (BookieProtocol.EOK == rc) {\n+            statsLogger.registerSuccessfulEvent(MathUtils.elapsedMSec(enqueueNanos));\n+        } else {\n+            statsLogger.registerFailedEvent(MathUtils.elapsedMSec(enqueueNanos));\n+        }\n+    }\n+\n     @Override\n     public void run() {\n         if (!isVersionCompatible()) {\n-            channel.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, request));\n+            sendResponse(BookieProtocol.EBADVERSION,\n+                         ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, request),\n+                         requestProcessor.readRequestStats);\n             return;\n         }\n         processPacket();"},{"sha":"ebff52608470235d93f5ca984653b38f81665631","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","status":"modified","additions":18,"deletions":4,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -20,22 +20,36 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.channel.Channel;\n \n public abstract class PacketProcessorBaseV3 {\n \n     final Request request;\n     final Channel channel;\n-    final Bookie  bookie;\n+    final BookieRequestProcessor requestProcessor;\n+    final long enqueueNanos;\n \n-    public PacketProcessorBaseV3(Request request, Channel channel, Bookie bookie) {\n+    public PacketProcessorBaseV3(Request request, Channel channel,\n+                                 BookieRequestProcessor requestProcessor) {\n         this.request = request;\n         this.channel = channel;\n-        this.bookie = bookie;\n+        this.requestProcessor = requestProcessor;\n+        this.enqueueNanos = MathUtils.nowInNano();\n+    }\n+\n+    protected void sendResponse(StatusCode code, Object response, OpStatsLogger statsLogger) {\n+        channel.write(response);\n+        if (StatusCode.EOK == code) {\n+            statsLogger.registerSuccessfulEvent(MathUtils.elapsedMSec(enqueueNanos));\n+        } else {\n+            statsLogger.registerFailedEvent(MathUtils.elapsedMSec(enqueueNanos));\n+        }\n     }\n \n     protected boolean isVersionCompatible() {"},{"sha":"385cf022b7b362efdac561fc8bbd8a8e8fc1ec6b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -35,8 +35,9 @@\n class ReadEntryProcessor extends PacketProcessorBase {\n     private final static Logger LOG = LoggerFactory.getLogger(ReadEntryProcessor.class);\n \n-    public ReadEntryProcessor(Request request, Channel channel, Bookie bookie) {\n-        super(request, channel, bookie);\n+    public ReadEntryProcessor(Request request, Channel channel,\n+                              BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n     }\n \n     @Override\n@@ -46,22 +47,21 @@ protected void processPacket() {\n \n         LOG.debug(\"Received new read request: {}\", request);\n         int errorCode = BookieProtocol.EIO;\n-        long startTime = MathUtils.now();\n+        long startTimeNanos = MathUtils.nowInNano();\n         ByteBuffer data = null;\n         try {\n             Future<Boolean> fenceResult = null;\n             if (read.isFencingRequest()) {\n                 LOG.warn(\"Ledger \" + request.getLedgerId() + \" fenced by \" + channel.getRemoteAddress());\n \n                 if (read.hasMasterKey()) {\n-                    fenceResult = bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n+                    fenceResult = requestProcessor.bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n                 } else {\n                     LOG.error(\"Password not provided, Not safe to fence {}\", read.getLedgerId());\n-                    BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n                     throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n                 }\n             }\n-            data = bookie.readEntry(request.getLedgerId(), request.getEntryId());\n+            data = requestProcessor.bookie.readEntry(request.getLedgerId(), request.getEntryId());\n             LOG.debug(\"##### Read entry ##### {}\", data.remaining());\n             if (null != fenceResult) {\n                 // TODO:\n@@ -120,14 +120,14 @@ protected void processPacket() {\n         LOG.trace(\"Read entry rc = {} for {}\",\n                 new Object[] { errorCode, read });\n         if (errorCode == BookieProtocol.EOK) {\n-            assert data != null;\n+            requestProcessor.readEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            sendResponse(errorCode, ResponseBuilder.buildReadResponse(data, read),\n+                         requestProcessor.readRequestStats);\n \n-            channel.write(ResponseBuilder.buildReadResponse(data, read));\n-            long elapsedTime = MathUtils.now() - startTime;\n-            BKStats.getInstance().getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n         } else {\n-            channel.write(ResponseBuilder.buildErrorResponse(errorCode, read));\n-            BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+            requestProcessor.readEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            sendResponse(errorCode, ResponseBuilder.buildErrorResponse(errorCode, read),\n+                         requestProcessor.readRequestStats);\n         }\n     }\n }"},{"sha":"03517789625a5c17e474dec00579a6d69b6f6d82","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","status":"modified","additions":15,"deletions":11,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -42,12 +42,13 @@\n \n     private final static Logger LOG = LoggerFactory.getLogger(ReadEntryProcessorV3.class);\n \n-    public ReadEntryProcessorV3(Request request, Channel channel, Bookie bookie) {\n-        super(request, channel, bookie);\n+    public ReadEntryProcessorV3(Request request, Channel channel,\n+                                BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n     }\n \n     private ReadResponse getReadResponse() {\n-        long startTime = MathUtils.now();\n+        long startTimeNanos = MathUtils.nowInNano();\n         ReadRequest readRequest = request.getReadRequest();\n         long ledgerId = readRequest.getLedgerId();\n         long entryId = readRequest.getEntryId();\n@@ -58,7 +59,6 @@ private ReadResponse getReadResponse() {\n \n         if (!isVersionCompatible()) {\n             readResponse.setStatus(StatusCode.EBADVERSION);\n-            BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n             return readResponse.build();\n         }\n \n@@ -73,15 +73,14 @@ private ReadResponse getReadResponse() {\n \n                 if (readRequest.hasMasterKey()) {\n                     byte[] masterKey = readRequest.getMasterKey().toByteArray();\n-                    fenceResult = bookie.fenceLedger(ledgerId, masterKey);\n+                    fenceResult = requestProcessor.bookie.fenceLedger(ledgerId, masterKey);\n                 } else {\n                     LOG.error(\"Fence ledger request received without master key for ledger:{} from address: {}\",\n                               ledgerId, channel.getRemoteAddress());\n-                    BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n                     throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n                 }\n             }\n-            entryBody = bookie.readEntry(ledgerId, entryId);\n+            entryBody = requestProcessor.bookie.readEntry(ledgerId, entryId);\n             if (null != fenceResult) {\n                 // TODO:\n                 // currently we don't have readCallback to run in separated read\n@@ -135,10 +134,9 @@ private ReadResponse getReadResponse() {\n         }\n \n         if (status == StatusCode.EOK) {\n-            long elapsedTime = MathUtils.now() - startTime;\n-            BKStats.getInstance().getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n+            requestProcessor.readEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n         } else {\n-            BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+            requestProcessor.readEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n         }\n \n         // Finally set status and return. The body would have been updated if\n@@ -150,11 +148,17 @@ private ReadResponse getReadResponse() {\n     @Override\n     public void run() {\n         ReadResponse readResponse = getReadResponse();\n+        sendResponse(readResponse);\n+    }\n+\n+    private void sendResponse(ReadResponse readResponse) {\n         Response.Builder response = Response.newBuilder()\n                 .setHeader(getHeader())\n                 .setStatus(readResponse.getStatus())\n                 .setReadResponse(readResponse);\n-        channel.write(response.build());\n+        sendResponse(response.getStatus(),\n+                     response.build(),\n+                     requestProcessor.readRequestStats);\n     }\n }\n "},{"sha":"719c937dea9baefc44edd87b85026ef37439b25f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","status":"modified","additions":23,"deletions":22,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -19,7 +19,6 @@\n \n import java.io.IOException;\n \n-import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieProtocol.Request;\n@@ -36,34 +35,36 @@\n \n     private final static Logger LOG = LoggerFactory.getLogger(WriteEntryProcessor.class);\n \n-    long startTime;\n+    long startTimeNanos;\n \n-    public WriteEntryProcessor(Request request, Channel channel, Bookie bookie) {\n-        super(request, channel, bookie);\n+    public WriteEntryProcessor(Request request, Channel channel,\n+                               BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n     }\n \n     @Override\n     protected void processPacket() {\n         assert (request instanceof BookieProtocol.AddRequest);\n         BookieProtocol.AddRequest add = (BookieProtocol.AddRequest) request;\n \n-        if (bookie.isReadOnly()) {\n+        if (requestProcessor.bookie.isReadOnly()) {\n             LOG.warn(\"BookieServer is running in readonly mode,\"\n                     + \" so rejecting the request from the client!\");\n-            channel.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add));\n-            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            sendResponse(BookieProtocol.EREADONLY,\n+                         ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add),\n+                         requestProcessor.addRequestStats);\n             return;\n         }\n \n-        startTime = MathUtils.now();\n+        startTimeNanos = MathUtils.nowInNano();\n         int rc = BookieProtocol.EOK;\n         try {\n             if (add.isRecoveryAdd()) {\n-                bookie.recoveryAddEntry(add.getDataAsByteBuffer(),\n-                                        this, channel, add.getMasterKey());\n+                requestProcessor.bookie.recoveryAddEntry(add.getDataAsByteBuffer(),\n+                                                         this, channel, add.getMasterKey());\n             } else {\n-                bookie.addEntry(add.getDataAsByteBuffer(),\n-                                this, channel, add.getMasterKey());\n+                requestProcessor.bookie.addEntry(add.getDataAsByteBuffer(),\n+                                                 this, channel, add.getMasterKey());\n             }\n         } catch (IOException e) {\n             LOG.error(\"Error writing \" + add, e);\n@@ -76,23 +77,23 @@ protected void processPacket() {\n             rc = BookieProtocol.EUA;\n         }\n         if (rc != BookieProtocol.EOK) {\n-            channel.write(ResponseBuilder.buildErrorResponse(rc, add));\n-            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            requestProcessor.addEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+            sendResponse(rc,\n+                         ResponseBuilder.buildErrorResponse(rc, add),\n+                         requestProcessor.addRequestStats);\n         }\n     }\n \n     @Override\n     public void writeComplete(int rc, long ledgerId, long entryId,\n                               BookieSocketAddress addr, Object ctx) {\n-        channel.write(ResponseBuilder.buildAddResponse(request));\n-\n-        // compute the latency\n-        if (0 == rc) {\n-            // for add operations, we compute latency in writeComplete callbacks.\n-            long elapsedTime = MathUtils.now() - startTime;\n-            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n+        if (BookieProtocol.EOK == rc) {\n+            requestProcessor.addEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n         } else {\n-            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            requestProcessor.addEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n         }\n+        sendResponse(rc,\n+                     ResponseBuilder.buildAddResponse(request),\n+                     requestProcessor.addRequestStats);\n     }\n }"},{"sha":"28c96496317487c7a7f330379a01e130857ea072","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","status":"modified","additions":17,"deletions":8,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -23,27 +23,29 @@\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n-import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n class WriteEntryProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n     private final static Logger logger = LoggerFactory.getLogger(WriteEntryProcessorV3.class);\n \n-    public WriteEntryProcessorV3(Request request, Channel channel, Bookie bookie) {\n-        super(request, channel, bookie);\n+    public WriteEntryProcessorV3(Request request, Channel channel,\n+                                 BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n     }\n \n     // Returns null if there is no exception thrown\n     private AddResponse getAddResponse() {\n+        final long startTimeNanos = MathUtils.nowInNano();\n         AddRequest addRequest = request.getAddRequest();\n         long ledgerId = addRequest.getLedgerId();\n         long entryId = addRequest.getEntryId();\n@@ -57,7 +59,7 @@ private AddResponse getAddResponse() {\n             return addResponse.build();\n         }\n \n-        if (bookie.isReadOnly()) {\n+        if (requestProcessor.bookie.isReadOnly()) {\n             logger.warn(\"BookieServer is running as readonly mode, so rejecting the request from the client!\");\n             addResponse.setStatus(StatusCode.EREADONLY);\n             return addResponse.build();\n@@ -67,6 +69,12 @@ private AddResponse getAddResponse() {\n             @Override\n             public void writeComplete(int rc, long ledgerId, long entryId,\n                                       BookieSocketAddress addr, Object ctx) {\n+                if (BookieProtocol.EOK == rc) {\n+                    requestProcessor.addEntryStats.registerSuccessfulEvent(MathUtils.elapsedMSec(startTimeNanos));\n+                } else {\n+                    requestProcessor.addEntryStats.registerFailedEvent(MathUtils.elapsedMSec(startTimeNanos));\n+                }\n+\n                 Channel conn = (Channel) ctx;\n                 StatusCode status;\n                 switch (rc) {\n@@ -86,17 +94,17 @@ public void writeComplete(int rc, long ledgerId, long entryId,\n                         .setStatus(addResponse.getStatus())\n                         .setAddResponse(addResponse);\n                 Response resp = response.build();\n-                conn.write(resp);\n+                sendResponse(status, resp, requestProcessor.addRequestStats);\n             }\n         };\n         StatusCode status = null;\n         byte[] masterKey = addRequest.getMasterKey().toByteArray();\n         ByteBuffer entryToAdd = addRequest.getBody().asReadOnlyByteBuffer();\n         try {\n             if (addRequest.hasFlag() && addRequest.getFlag().equals(AddRequest.Flag.RECOVERY_ADD)) {\n-                bookie.recoveryAddEntry(entryToAdd, wcb, channel, masterKey);\n+                requestProcessor.bookie.recoveryAddEntry(entryToAdd, wcb, channel, masterKey);\n             } else {\n-                bookie.addEntry(entryToAdd, wcb, channel, masterKey);\n+                requestProcessor.bookie.addEntry(entryToAdd, wcb, channel, masterKey);\n             }\n             status = StatusCode.EOK;\n         } catch (IOException e) {\n@@ -137,7 +145,8 @@ public void run() {\n                     .setStatus(addResponse.getStatus())\n                     .setAddResponse(addResponse);\n             Response resp = response.build();\n-            channel.write(resp);\n+            sendResponse(addResponse.getStatus(), resp,\n+                         requestProcessor.addRequestStats);\n         }\n     }\n }"},{"sha":"75902c9e8c93f874b589357e94d7d98e7c9e7310","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","status":"modified","additions":35,"deletions":9,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/69620e6561196975295752175b01354877a9fdde/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java?ref=69620e6561196975295752175b01354877a9fdde","patch":"@@ -22,11 +22,16 @@\n import java.io.IOException;\n \n import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Class that provides utility functions for checking disk problems\n  */\n public class DiskChecker {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DiskChecker.class);\n+\n     private float diskUsageThreshold;\n     private float diskUsageWarnThreshold;\n \n@@ -47,16 +52,30 @@ public DiskErrorException(String msg) {\n     public static class DiskOutOfSpaceException extends DiskException {\n         private static final long serialVersionUID = 160898797915906860L;\n \n-        public DiskOutOfSpaceException(String msg) {\n+        private final float usage;\n+\n+        public DiskOutOfSpaceException(String msg, float usage) {\n             super(msg);\n+            this.usage = usage;\n+        }\n+\n+        public float getUsage() {\n+            return usage;\n         }\n     }\n \n     public static class DiskWarnThresholdException extends DiskException {\n         private static final long serialVersionUID = -1629284987500841657L;\n \n-        public DiskWarnThresholdException(String msg) {\n+        private final float usage;\n+\n+        public DiskWarnThresholdException(String msg, float usage) {\n             super(msg);\n+            this.usage = usage;\n+        }\n+\n+        public float getUsage() {\n+            return usage;\n         }\n     }\n \n@@ -106,26 +125,32 @@ private static boolean mkdirsWithExistsCheck(File dir) {\n      *             less than threshhold.\n      */\n     @VisibleForTesting\n-    void checkDiskFull(File dir) throws DiskOutOfSpaceException, DiskWarnThresholdException {\n+    float checkDiskFull(File dir) throws DiskOutOfSpaceException, DiskWarnThresholdException {\n         if (null == dir) {\n-            return;\n+            return 0f;\n         }\n         if (dir.exists()) {\n             long usableSpace = dir.getUsableSpace();\n             long totalSpace = dir.getTotalSpace();\n             float free = (float) usableSpace / (float) totalSpace;\n             float used = 1f - free;\n             if (used > diskUsageThreshold) {\n+                LOG.error(\"Space left on device {} : {}, Used space fraction: {} < threshold {}.\",\n+                        new Object[] { dir, usableSpace, used, diskUsageThreshold });\n                 throw new DiskOutOfSpaceException(\"Space left on device \"\n-                        + usableSpace + \" Used space fraction:\" + used + \" < threshhold \" + diskUsageThreshold);\n+                        + usableSpace + \" Used space fraction:\" + used + \" < threshold \" + diskUsageThreshold, used);\n             }\n             // Warn should be triggered only if disk usage threshold doesn't trigger first.\n             if (used > diskUsageWarnThreshold) {\n+                LOG.warn(\"Space left on device {} : {}, Used space fraction: {} < WarnThreshold {}.\",\n+                        new Object[] { dir, usableSpace, used, diskUsageThreshold });\n                 throw new DiskWarnThresholdException(\"Space left on device:\"\n-                        + usableSpace + \" Used space fraction:\" + used +\" < WarnThreshold:\" + diskUsageWarnThreshold);\n+                        + usableSpace + \" Used space fraction:\" + used +\" < WarnThreshold:\" + diskUsageWarnThreshold,\n+                        used);\n             }\n+            return used;\n         } else {\n-            checkDiskFull(dir.getParentFile());\n+            return checkDiskFull(dir.getParentFile());\n         }\n     }\n \n@@ -141,9 +166,9 @@ void checkDiskFull(File dir) throws DiskOutOfSpaceException, DiskWarnThresholdEx\n      * @throws DiskOutOfSpaceException\n      *             If disk is full or having less space than threshhold\n      */\n-    public void checkDir(File dir) throws DiskErrorException,\n+    public float checkDir(File dir) throws DiskErrorException,\n             DiskOutOfSpaceException, DiskWarnThresholdException {\n-        checkDiskFull(dir);\n+        float usage = checkDiskFull(dir);\n         if (!mkdirsWithExistsCheck(dir))\n             throw new DiskErrorException(\"can not create directory: \"\n                     + dir.toString());\n@@ -158,6 +183,7 @@ public void checkDir(File dir) throws DiskErrorException,\n         if (!dir.canWrite())\n             throw new DiskErrorException(\"directory is not writable: \"\n                     + dir.toString());\n+        return usage;\n     }\n \n     /**"}]}

