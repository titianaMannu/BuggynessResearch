{"sha":"69af0463e916456c5610415b9a60b710d14d1132","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2OWFmMDQ2M2U5MTY0NTZjNTYxMDQxNWI5YTYwYjcxMGQxNGQxMTMy","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-07-13T00:02:24Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-07-13T00:02:24Z"},"message":"BOOKKEEPER-618: Better resolution of bookie address (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1502728 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"01353e887819826e624fa8da894f40eba205ec35","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/01353e887819826e624fa8da894f40eba205ec35"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/69af0463e916456c5610415b9a60b710d14d1132","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/69af0463e916456c5610415b9a60b710d14d1132","html_url":"https://github.com/apache/bookkeeper/commit/69af0463e916456c5610415b9a60b710d14d1132","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/69af0463e916456c5610415b9a60b710d14d1132/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"b046f0cd3f6b4c246db5041a2726e80fead1af77","url":"https://api.github.com/repos/apache/bookkeeper/commits/b046f0cd3f6b4c246db5041a2726e80fead1af77","html_url":"https://github.com/apache/bookkeeper/commit/b046f0cd3f6b4c246db5041a2726e80fead1af77"}],"stats":{"total":546,"additions":492,"deletions":54},"files":[{"sha":"89ceae5bd7485a34e877a40d1c17f87504da9c88","filename":"CHANGES.txt","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -54,6 +54,9 @@ Release 4.2.2 - Unreleased\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj via ivank)\n \n+\t\n+    IMPROVEMENT:\n+      BOOKKEEPER-618: Better resolution of bookie address (ivank via fpj)\n \n Release 4.2.1 - 2013-02-19\n "},{"sha":"686e5cce491fd55155bb02fb3e4c340f72900e8f","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bk_server.conf?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -25,6 +25,23 @@\n # Port that bookie server listen on\n bookiePort=3181\n \n+# Set the network interface that the bookie should listen on.\n+# If not set, the bookie will listen on all interfaces.\n+#listeningInterface=eth0\n+\n+# Whether the bookie allowed to use a loopback interface as its primary\n+# interface(i.e. the interface it uses to establish its identity)?\n+# By default, loopback interfaces are not allowed as the primary\n+# interface.\n+# Using a loopback interface as the primary interface usually indicates\n+# a configuration error. For example, its fairly common in some VPS setups\n+# to not configure a hostname, or to have the hostname resolve to\n+# 127.0.0.1. If this is the case, then all bookies in the cluster will\n+# establish their identities as 127.0.0.1:3181, and only one will be able\n+# to join the cluster. For VPSs configured like this, you should explicitly\n+# set the listening interface.\n+#allowLoopback=false\n+\n # Directory Bookkeeper outputs its write ahead log\n journalDirectory=/tmp/bk-txn\n "},{"sha":"327cb034941dc2e9ecd3636903b736bd005909d8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":16,"deletions":4,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -56,6 +56,7 @@\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.net.DNS;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n@@ -479,8 +480,20 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n      */\n     public static InetSocketAddress getBookieAddress(ServerConfiguration conf)\n             throws UnknownHostException {\n-        return new InetSocketAddress(InetAddress.getLocalHost()\n-                .getHostAddress(), conf.getBookiePort());\n+        String iface = conf.getListeningInterface();\n+        if (iface == null) {\n+            iface = \"default\";\n+        }\n+        InetSocketAddress addr = new InetSocketAddress(\n+                DNS.getDefaultHost(iface),\n+                conf.getBookiePort());\n+        if (addr.getAddress().isLoopbackAddress()\n+            && !conf.getAllowLoopback()) {\n+            throw new UnknownHostException(\"Trying to listen on loopback address, \"\n+                    + addr + \" but this is forbidden by default \"\n+                    + \"(see ServerConfiguration#getAllowLoopback())\");\n+        }\n+        return addr;\n     }\n \n     private String getInstanceId(ZooKeeper zk) throws KeeperException,\n@@ -545,8 +558,7 @@ public Bookie(ServerConfiguration conf)\n     }\n \n     private String getMyId() throws UnknownHostException {\n-        return InetAddress.getLocalHost().getHostAddress() + \":\"\n-                + conf.getBookiePort();\n+        return StringUtils.addrToString(Bookie.getBookieAddress(conf));\n     }\n \n     void readJournal() throws IOException, BookieException {"},{"sha":"67e3c4f8c11df6f6c978b4adfe5c6fed17d91f9a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -266,7 +266,7 @@ long getNextEnsembleChange(long entryId) {\n             LedgerMetadataFormat.Segment.Builder segmentBuilder = LedgerMetadataFormat.Segment.newBuilder();\n             segmentBuilder.setFirstEntryId(entry.getKey());\n             for (InetSocketAddress addr : entry.getValue()) {\n-                segmentBuilder.addEnsembleMember(addr.getAddress().getHostAddress() + \":\" + addr.getPort());\n+                segmentBuilder.addEnsembleMember(StringUtils.addrToString(addr));\n             }\n             builder.addSegment(segmentBuilder.build());\n         }"},{"sha":"994786c87390538ae4b42fc2184b3ce20ef43f3a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -48,6 +48,9 @@\n     protected final static String MAX_BACKUP_JOURNALS = \"journalMaxBackups\";\n     // Bookie Parameters\n     protected final static String BOOKIE_PORT = \"bookiePort\";\n+    protected final static String LISTENING_INTERFACE = \"listeningInterface\";\n+    protected final static String ALLOW_LOOPBACK = \"allowLoopback\";\n+\n     protected final static String JOURNAL_DIR = \"journalDirectory\";\n     protected final static String LEDGER_DIRS = \"ledgerDirectories\";\n     // NIO Parameters\n@@ -283,6 +286,64 @@ public ServerConfiguration setBookiePort(int port) {\n         return this;\n     }\n \n+    /**\n+     * Get the network interface that the bookie should\n+     * listen for connections on. If this is null, then the bookie\n+     * will listen for connections on all interfaces.\n+     *\n+     * @return the network interface to listen on, e.g. eth0, or\n+     *         null if none is specified\n+     */\n+    public String getListeningInterface() {\n+        return this.getString(LISTENING_INTERFACE);\n+    }\n+\n+    /**\n+     * Set the network interface that the bookie should listen on.\n+     * If not set, the bookie will listen on all interfaces.\n+     *\n+     * @param iface the interface to listen on\n+     */\n+    public ServerConfiguration setListeningInterface(String iface) {\n+        this.setProperty(LISTENING_INTERFACE, iface);\n+        return this;\n+    }\n+\n+    /**\n+     * Is the bookie allowed to use a loopback interface as its primary\n+     * interface(i.e. the interface it uses to establish its identity)?\n+     *\n+     * By default, loopback interfaces are not allowed as the primary\n+     * interface.\n+     *\n+     * Using a loopback interface as the primary interface usually indicates\n+     * a configuration error. For example, its fairly common in some VPS setups\n+     * to not configure a hostname, or to have the hostname resolve to\n+     * 127.0.0.1. If this is the case, then all bookies in the cluster will\n+     * establish their identities as 127.0.0.1:3181, and only one will be able\n+     * to join the cluster. For VPSs configured like this, you should explicitly\n+     * set the listening interface.\n+     *\n+     * @see #setListeningInterface(String)\n+     * @return whether a loopback interface can be used as the primary interface\n+     */\n+    public boolean getAllowLoopback() {\n+        return this.getBoolean(ALLOW_LOOPBACK, false);\n+    }\n+\n+    /**\n+     * Configure the bookie to allow loopback interfaces to be used\n+     * as the primary bookie interface.\n+     *\n+     * @see #getAllowLoopback\n+     * @param allow whether to allow loopback interfaces\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setAllowLoopback(boolean allow) {\n+        this.setProperty(ALLOW_LOOPBACK, allow);\n+        return this;\n+    }\n+\n     /**\n      * Get dir name to store journal files\n      *"},{"sha":"4f0f927a4e66ff090ed12c58a7a117c8f94f7051","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -23,6 +23,8 @@\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.net.DNS;\n+\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;\n import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n@@ -114,7 +116,7 @@ public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc\n \n         LockDataFormat.Builder lockDataBuilder = LockDataFormat.newBuilder();\n         try {\n-            lockDataBuilder.setBookieId(InetAddress.getLocalHost().getHostAddress().toString());\n+            lockDataBuilder.setBookieId(DNS.getDefaultHost(\"default\"));\n         } catch (UnknownHostException uhe) {\n             // if we cant get the address, ignore. it's optional\n             // in the data structure in any case"},{"sha":"e6846e737e58237d75299f5bdc15a5fcd6a34a85","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","status":"added","additions":356,"deletions":0,"changes":356,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+// This code has been copied from hadoop-common 2.0.4-alpha\n+package org.apache.bookkeeper.net;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.LinkedHashSet;\n+import java.util.Vector;\n+\n+import javax.naming.NamingException;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+\n+/**\n+ *\n+ * A class that provides direct and reverse lookup functionalities, allowing\n+ * the querying of specific network interfaces or nameservers.\n+ *\n+ *\n+ */\n+public class DNS {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DNS.class);\n+\n+    /**\n+     * The cached hostname -initially null.\n+     */\n+\n+    private static final String cachedHostname = resolveLocalHostname();\n+    private static final String cachedHostAddress = resolveLocalHostIPAddress();\n+    private static final String LOCALHOST = \"localhost\";\n+\n+    /**\n+     * Returns the hostname associated with the specified IP address by the\n+     * provided nameserver.\n+     *\n+     * Loopback addresses\n+     * @param hostIp The address to reverse lookup\n+     * @param ns The host name of a reachable DNS server\n+     * @return The host name associated with the provided IP\n+     * @throws NamingException If a NamingException is encountered\n+     */\n+    public static String reverseDns(InetAddress hostIp, String ns)\n+            throws NamingException {\n+        //\n+        // Builds the reverse IP lookup form\n+        // This is formed by reversing the IP numbers and appending in-addr.arpa\n+        //\n+        String[] parts = hostIp.getHostAddress().split(\"\\\\.\");\n+        String reverseIP = parts[3] + \".\" + parts[2] + \".\" + parts[1] + \".\"\n+            + parts[0] + \".in-addr.arpa\";\n+\n+        DirContext ictx = new InitialDirContext();\n+        Attributes attribute;\n+        try {\n+            attribute = ictx.getAttributes(\"dns://\"               // Use \"dns:///\" if the default\n+                                           + ((ns == null) ? \"\" : ns) +\n+                                           // nameserver is to be used\n+                                           \"/\" + reverseIP, new String[] { \"PTR\" });\n+        } finally {\n+            ictx.close();\n+        }\n+\n+        return attribute.get(\"PTR\").get().toString();\n+    }\n+\n+    /**\n+     * @return NetworkInterface for the given subinterface name (eg eth0:0)\n+     *    or null if no interface with the given name can be found\n+     */\n+    private static NetworkInterface getSubinterface(String strInterface)\n+            throws SocketException {\n+        Enumeration<NetworkInterface> nifs =\n+            NetworkInterface.getNetworkInterfaces();\n+\n+        while (nifs.hasMoreElements()) {\n+            Enumeration<NetworkInterface> subNifs =\n+                nifs.nextElement().getSubInterfaces();\n+\n+            while (subNifs.hasMoreElements()) {\n+                NetworkInterface nif = subNifs.nextElement();\n+                if (nif.getName().equals(strInterface)) {\n+                    return nif;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param nif network interface to get addresses for\n+     * @return set containing addresses for each subinterface of nif,\n+     *    see below for the rationale for using an ordered set\n+     */\n+    private static LinkedHashSet<InetAddress> getSubinterfaceInetAddrs(\n+                                                                       NetworkInterface nif) {\n+        LinkedHashSet<InetAddress> addrs = new LinkedHashSet<InetAddress>();\n+        Enumeration<NetworkInterface> subNifs = nif.getSubInterfaces();\n+        while (subNifs.hasMoreElements()) {\n+            NetworkInterface subNif = subNifs.nextElement();\n+            addrs.addAll(Collections.list(subNif.getInetAddresses()));\n+        }\n+        return addrs;\n+    }\n+\n+    /**\n+     * Like {@link DNS#getIPs(String, boolean), but returns all\n+     * IPs associated with the given interface and its subinterfaces.\n+     */\n+    public static String[] getIPs(String strInterface)\n+            throws UnknownHostException {\n+        return getIPs(strInterface, true);\n+    }\n+\n+    /**\n+     * Returns all the IPs associated with the provided interface, if any, in\n+     * textual form.\n+     *\n+     * @param strInterface\n+     *            The name of the network interface or sub-interface to query\n+     *            (eg eth0 or eth0:0) or the string \"default\"\n+     * @param returnSubinterfaces\n+     *            Whether to return IPs associated with subinterfaces of\n+     *            the given interface\n+     * @return A string vector of all the IPs associated with the provided\n+     *         interface. The local host IP is returned if the interface\n+     *         name \"default\" is specified or there is an I/O error looking\n+     *         for the given interface.\n+     * @throws UnknownHostException\n+     *             If the given interface is invalid\n+     *\n+     */\n+    public static String[] getIPs(String strInterface,\n+                                  boolean returnSubinterfaces) throws UnknownHostException {\n+        if (\"default\".equals(strInterface)) {\n+            return new String[] { cachedHostAddress };\n+        }\n+        NetworkInterface netIf;\n+        try {\n+            netIf = NetworkInterface.getByName(strInterface);\n+            if (netIf == null) {\n+                netIf = getSubinterface(strInterface);\n+            }\n+        } catch (SocketException e) {\n+            LOG.warn(\"I/O error finding interface \" + strInterface +\n+                     \": \" + e.getMessage());\n+            return new String[] { cachedHostAddress };\n+        }\n+        if (netIf == null) {\n+            throw new UnknownHostException(\"No such interface \" + strInterface);\n+        }\n+\n+        // NB: Using a LinkedHashSet to preserve the order for callers\n+        // that depend on a particular element being 1st in the array.\n+        // For example, getDefaultIP always returns the first element.\n+        LinkedHashSet<InetAddress> allAddrs = new LinkedHashSet<InetAddress>();\n+        allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n+        if (!returnSubinterfaces) {\n+            allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n+        }\n+\n+        String ips[] = new String[allAddrs.size()];\n+        int i = 0;\n+        for (InetAddress addr : allAddrs) {\n+            ips[i++] = addr.getHostAddress();\n+        }\n+        return ips;\n+    }\n+\n+\n+    /**\n+     * Returns the first available IP address associated with the provided\n+     * network interface or the local host IP if \"default\" is given.\n+     *\n+     * @param strInterface\n+     *            The name of the network interface or subinterface to query\n+     *             (e.g. eth0 or eth0:0) or the string \"default\"\n+     * @return The IP address in text form, the local host IP is returned\n+     *         if the interface name \"default\" is specified\n+     * @throws UnknownHostException\n+     *             If the given interface is invalid\n+     */\n+    public static String getDefaultIP(String strInterface)\n+            throws UnknownHostException {\n+        String[] ips = getIPs(strInterface);\n+        return ips[0];\n+    }\n+\n+    /**\n+     * Returns all the host names associated by the provided nameserver with the\n+     * address bound to the specified network interface\n+     *\n+     * @param strInterface\n+     *            The name of the network interface or subinterface to query\n+     *            (e.g. eth0 or eth0:0)\n+     * @param nameserver\n+     *            The DNS host name\n+     * @return A string vector of all host names associated with the IPs tied to\n+     *         the specified interface\n+     * @throws UnknownHostException if the given interface is invalid\n+     */\n+    public static String[] getHosts(String strInterface, String nameserver)\n+            throws UnknownHostException {\n+        String[] ips = getIPs(strInterface);\n+        Vector<String> hosts = new Vector<String>();\n+        for (int ctr = 0; ctr < ips.length; ctr++) {\n+            try {\n+                hosts.add(reverseDns(InetAddress.getByName(ips[ctr]),\n+                                     nameserver));\n+            } catch (UnknownHostException ignored) {\n+            } catch (NamingException ignored) {\n+            }\n+        }\n+        if (hosts.isEmpty()) {\n+            LOG.warn(\"Unable to determine hostname for interface \" + strInterface);\n+            return new String[] { cachedHostname };\n+        } else {\n+            return hosts.toArray(new String[hosts.size()]);\n+        }\n+    }\n+\n+\n+    /**\n+     * Determine the local hostname; retrieving it from cache if it is known\n+     * If we cannot determine our host name, return \"localhost\"\n+     * @return the local hostname or \"localhost\"\n+     */\n+    private static String resolveLocalHostname() {\n+        String localhost;\n+        try {\n+            localhost = InetAddress.getLocalHost().getCanonicalHostName();\n+        } catch (UnknownHostException e) {\n+            LOG.warn(\"Unable to determine local hostname \"\n+                     + \"-falling back to \\\"\" + LOCALHOST + \"\\\"\", e);\n+            localhost = LOCALHOST;\n+        }\n+        return localhost;\n+    }\n+\n+\n+    /**\n+     * Get the IPAddress of the local host as a string.\n+     * This will be a loop back value if the local host address cannot be\n+     * determined.\n+     * If the loopback address of \"localhost\" does not resolve, then the system's\n+     * network is in such a state that nothing is going to work. A message is\n+     * logged at the error level and a null pointer returned, a pointer\n+     * which will trigger failures later on the application\n+     * @return the IPAddress of the local host or null for a serious problem.\n+     */\n+    private static String resolveLocalHostIPAddress() {\n+        String address;\n+        try {\n+            address = InetAddress.getLocalHost().getHostAddress();\n+        } catch (UnknownHostException e) {\n+            LOG.warn(\"Unable to determine address of the host\"\n+                     + \"-falling back to \\\"\" + LOCALHOST + \"\\\" address\", e);\n+            try {\n+                address = InetAddress.getByName(LOCALHOST).getHostAddress();\n+            } catch (UnknownHostException noLocalHostAddressException) {\n+                //at this point, deep trouble\n+                LOG.error(\"Unable to determine local loopback address \"\n+                          + \"of \\\"\" + LOCALHOST + \"\\\" \" +\n+                          \"-this system's network configuration is unsupported\", e);\n+                address = null;\n+            }\n+        }\n+        return address;\n+    }\n+\n+    /**\n+     * Returns all the host names associated by the default nameserver with the\n+     * address bound to the specified network interface\n+     *\n+     * @param strInterface\n+     *            The name of the network interface to query (e.g. eth0)\n+     * @return The list of host names associated with IPs bound to the network\n+     *         interface\n+     * @throws UnknownHostException\n+     *             If one is encountered while querying the default interface\n+     *\n+     */\n+    public static String[] getHosts(String strInterface)\n+            throws UnknownHostException {\n+        return getHosts(strInterface, null);\n+    }\n+\n+    /**\n+     * Returns the default (first) host name associated by the provided\n+     * nameserver with the address bound to the specified network interface\n+     *\n+     * @param strInterface\n+     *            The name of the network interface to query (e.g. eth0)\n+     * @param nameserver\n+     *            The DNS host name\n+     * @return The default host names associated with IPs bound to the network\n+     *         interface\n+     * @throws UnknownHostException\n+     *             If one is encountered while querying the default interface\n+     */\n+    public static String getDefaultHost(String strInterface, String nameserver)\n+            throws UnknownHostException {\n+        if (\"default\".equals(strInterface)) {\n+            return cachedHostname;\n+        }\n+\n+        if (\"default\".equals(nameserver)) {\n+            return getDefaultHost(strInterface);\n+        }\n+\n+        String[] hosts = getHosts(strInterface, nameserver);\n+        return hosts[0];\n+    }\n+\n+    /**\n+     * Returns the default (first) host name associated by the default\n+     * nameserver with the address bound to the specified network interface\n+     *\n+     * @param strInterface\n+     *            The name of the network interface to query (e.g. eth0).\n+     *            Must not be null.\n+     * @return The default host name associated with IPs bound to the network\n+     *         interface\n+     * @throws UnknownHostException\n+     *             If one is encountered while querying the default interface\n+     */\n+    public static String getDefaultHost(String strInterface)\n+            throws UnknownHostException {\n+        return getDefaultHost(strInterface, null);\n+    }\n+\n+}"},{"sha":"c9c9dbd58dc992cf2c503359fc65a1654a23e87a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -113,6 +113,7 @@ public void start() throws IOException, UnavailableException {\n         registerJMX();\n     }\n \n+    @VisibleForTesting\n     public InetSocketAddress getLocalAddress() {\n         try {\n             return Bookie.getBookieAddress(conf);"},{"sha":"0c3fc2e4521b84b32dae5c354c10dba52c8756f3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -34,6 +34,7 @@\n import java.util.Set;\n import java.util.concurrent.LinkedBlockingQueue;\n \n+import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n \n import org.slf4j.Logger;\n@@ -85,7 +86,13 @@ public NIOServerFactory(ServerConfiguration conf, PacketProcessor processor) thr\n         this.processor = processor;\n         this.conf = conf;\n         this.ss = ServerSocketChannel.open();\n-        ss.socket().bind(new InetSocketAddress(conf.getBookiePort()));\n+        if (conf.getListeningInterface() == null) {\n+            // listen on all interfaces\n+            ss.socket().bind(new InetSocketAddress(conf.getBookiePort()));\n+        } else {\n+            ss.socket().bind(Bookie.getBookieAddress(conf));\n+        }\n+        \n         ss.configureBlocking(false);\n         ss.register(selector, SelectionKey.OP_ACCEPT);\n     }"},{"sha":"76d89ad83bb765e29140e4a57e5f27185bc0230d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -147,6 +147,7 @@ private void runBookies(ServerConfiguration baseConf) throws IOException,\n                                   + ZooKeeperDefaultPort);\n             bsConfs[i].setJournalDirName(tmpDirs[i].getPath());\n             bsConfs[i].setLedgerDirNames(new String[] { tmpDirs[i].getPath() });\n+            bsConfs[i].setAllowLoopback(true);\n \n             bs[i] = new BookieServer(bsConfs[i]);\n             bs[i].start();"},{"sha":"a1592ac660d1aeebd8dec59014a0f013f2c87f37","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -454,7 +454,7 @@ public void testClosedSingleEntryLedger() throws Exception {\n     }\n \n     private void killBookie(ArrayList<InetSocketAddress> firstEnsemble,\n-            InetSocketAddress ensemble) throws InterruptedException {\n+            InetSocketAddress ensemble) throws Exception {\n         LOG.info(\"Killing \" + ensemble + \" from ensemble=\" + firstEnsemble);\n         killBookie(ensemble);\n     }"},{"sha":"05a9dec56caf68cc8e2a64725b0c4bd351e73132","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -59,7 +59,7 @@ public TestPerChannelBookieClient() {\n      * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-485}.\n      */\n     @Test(timeout=60000)\n-    public void testConnectCloseRace() {\n+    public void testConnectCloseRace() throws Exception {\n         ClientSocketChannelFactory channelFactory\n             = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n                                                 Executors.newCachedThreadPool());\n@@ -89,7 +89,7 @@ public void operationComplete(int rc, Void result) {\n      * correctly, this causes the netty channel to get orphaned.\n      */\n     @Test(timeout=60000)\n-    public void testConnectRace() {\n+    public void testConnectRace() throws Exception {\n         GenericCallback<Void> nullop = new GenericCallback<Void>() {\n             @Override\n             public void operationComplete(int rc, Void result) {"},{"sha":"6a0589c3362ca6f355f971bd2cafbc58dfaa5358","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"modified","additions":3,"deletions":5,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -253,17 +253,15 @@ private void stopAuditorElectors() throws Exception {\n         }\n     }\n \n-    private BookieServer verifyAuditor() throws KeeperException,\n-            InterruptedException {\n+    private BookieServer verifyAuditor() throws Exception {\n         List<BookieServer> auditors = getAuditorBookie();\n         Assert.assertEquals(\"Multiple Bookies acting as Auditor!\", 1, auditors\n                 .size());\n         LOG.debug(\"Bookie running as Auditor:\" + auditors.get(0));\n         return auditors.get(0);\n     }\n \n-    private List<BookieServer> getAuditorBookie() throws KeeperException,\n-            InterruptedException {\n+    private List<BookieServer> getAuditorBookie() throws Exception {\n         List<BookieServer> auditors = new LinkedList<BookieServer>();\n         byte[] data = zkc.getData(electionPath, false, null);\n         Assert.assertNotNull(\"Auditor election failed\", data);\n@@ -286,7 +284,7 @@ private void shutdownBookie(BookieServer bkServer) throws Exception {\n     }\n \n     private BookieServer waitForNewAuditor(BookieServer auditor)\n-            throws InterruptedException, KeeperException {\n+            throws Exception {\n         BookieServer newAuditor = null;\n         int retryCount = 8;\n         while (retryCount > 0) {"},{"sha":"c290989759f08e43fa4f6c304fa4c49f88418c9c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -322,8 +322,7 @@ private void doLedgerRereplication(Long... ledgerIds)\n         }\n     }\n \n-    private String shutdownBookie(int bkShutdownIndex) throws IOException,\n-            InterruptedException {\n+    private String shutdownBookie(int bkShutdownIndex) throws Exception {\n         BookieServer bkServer = bs.get(bkShutdownIndex);\n         String bookieAddr = StringUtils.addrToString(bkServer.getLocalAddress());\n         LOG.debug(\"Shutting down bookie:\" + bookieAddr);"},{"sha":"d2e21200d136496b9bbafdaf738642fc5fd3d510","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -358,7 +358,7 @@ private int getReplicaIndexInLedger(LedgerHandle lh,\n \n     private void verifyLedgerEnsembleMetadataAfterReplication(\n             BookieServer newBookieServer, LedgerHandle lh,\n-            int ledgerReplicaIndex) throws BKException, InterruptedException {\n+            int ledgerReplicaIndex) throws Exception {\n         LedgerHandle openLedger = bkc\n                 .openLedger(lh.getId(), digestType, PASSWD);\n "},{"sha":"087a832dfd9727a68a8cf0cafeecfd4aea24c667","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -527,7 +527,7 @@ public void testRWZKSessionLost() throws Exception {\n     }\n \n     private void killAllBookies(LedgerHandle lh, InetSocketAddress excludeBK)\n-            throws InterruptedException {\n+            throws Exception {\n         // Killing all bookies except newly replicated bookie\n         Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().entrySet();"},{"sha":"cec07d71b0d72df986f673b89689b8ad5402d8b1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":16,"deletions":35,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/69af0463e916456c5610415b9a60b710d14d1132/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=69af0463e916456c5610415b9a60b710d14d1132","patch":"@@ -175,7 +175,7 @@ protected void stopBKCluster() throws Exception {\n         }\n     }\n \n-    protected ServerConfiguration newServerConfiguration() throws IOException {\n+    protected ServerConfiguration newServerConfiguration() throws Exception {\n         File f = File.createTempFile(\"bookie\", \"test\");\n         tmpDirs.add(f);\n         f.delete();\n@@ -191,6 +191,7 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n         conf.setBookiePort(port);\n         conf.setZkServers(zkServers);\n         conf.setJournalDirName(journalDir.getPath());\n+        conf.setAllowLoopback(true);\n         String[] ledgerDirNames = new String[ledgerDirs.length];\n         for (int i=0; i<ledgerDirs.length; i++) {\n             ledgerDirNames[i] = ledgerDirs[i].getPath();\n@@ -202,7 +203,7 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n     /**\n      * Get bookie address for bookie at index\n      */\n-    public InetSocketAddress getBookie(int index) throws IllegalArgumentException {\n+    public InetSocketAddress getBookie(int index) throws Exception {\n         if (bs.size() <= index || index < 0) {\n             throw new IllegalArgumentException(\"Invalid index, there are only \" + bs.size()\n                                                + \" bookies. Asked for \" + index);\n@@ -219,7 +220,7 @@ public InetSocketAddress getBookie(int index) throws IllegalArgumentException {\n      * @return the configuration of killed bookie\n      * @throws InterruptedException\n      */\n-    public ServerConfiguration killBookie(InetSocketAddress addr) throws InterruptedException {\n+    public ServerConfiguration killBookie(InetSocketAddress addr) throws Exception {\n         BookieServer toRemove = null;\n         int toRemoveIndex = 0;\n         for (BookieServer server : bs) {\n@@ -248,7 +249,7 @@ public ServerConfiguration killBookie(InetSocketAddress addr) throws Interrupted\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public ServerConfiguration killBookie(int index) throws InterruptedException, IOException {\n+    public ServerConfiguration killBookie(int index) throws Exception {\n         if (index >= bs.size()) {\n             throw new IOException(\"Bookie does not exist\");\n         }\n@@ -271,7 +272,7 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n      * @throws IOException\n      */\n     public CountDownLatch sleepBookie(InetSocketAddress addr, final int seconds)\n-            throws InterruptedException, IOException {\n+            throws Exception {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {\n                 final CountDownLatch l = new CountDownLatch(1);\n@@ -306,7 +307,7 @@ public void run() {\n      * @throws IOException\n      */\n     public void sleepBookie(InetSocketAddress addr, final CountDownLatch l)\n-            throws InterruptedException, IOException {\n+            throws Exception {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {\n                 Thread sleeper = new Thread() {\n@@ -337,8 +338,7 @@ public void run() {\n      * @throws BookieException\n      */\n     public void restartBookies()\n-            throws InterruptedException, IOException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         restartBookies(null);\n     }\n \n@@ -354,8 +354,7 @@ public void restartBookies()\n      * @throws BookieException\n      */\n     public void restartBookies(ServerConfiguration newConf)\n-            throws InterruptedException, IOException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         // shut down bookie server\n         for (BookieServer server : bs) {\n             server.shutdown();\n@@ -384,8 +383,7 @@ public void restartBookies(ServerConfiguration newConf)\n      * @throws IOException\n      */\n     public int startNewBookie()\n-            throws IOException, InterruptedException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         ServerConfiguration conf = newServerConfiguration();\n         bsConfs.add(conf);\n         bs.add(startBookie(conf));\n@@ -402,8 +400,7 @@ public int startNewBookie()\n      *\n      */\n     protected BookieServer startBookie(ServerConfiguration conf)\n-            throws IOException, InterruptedException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         BookieServer server = new BookieServer(conf);\n         server.start();\n \n@@ -430,8 +427,7 @@ protected BookieServer startBookie(ServerConfiguration conf)\n      * recovery for this bookie, if isAutoRecoveryEnabled is true.\n      */\n     protected BookieServer startBookie(ServerConfiguration conf, final Bookie b)\n-            throws IOException, InterruptedException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         BookieServer server = new BookieServer(conf) {\n             @Override\n             protected Bookie newBookie(ServerConfiguration conf) {\n@@ -486,9 +482,7 @@ public boolean isAutoRecoveryEnabled() {\n     }\n \n     private void startAutoRecovery(BookieServer bserver,\n-            ServerConfiguration conf) throws CompatibilityException,\n-            KeeperException, InterruptedException, IOException,\n-            UnavailableException {\n+                                   ServerConfiguration conf) throws Exception {\n         if (isAutoRecoveryEnabled()) {\n             AutoRecoveryMain autoRecoveryProcess = new AutoRecoveryMain(conf);\n             autoRecoveryProcess.start();\n@@ -498,7 +492,7 @@ private void startAutoRecovery(BookieServer bserver,\n         }\n     }\n \n-    private void stopAutoRecoveryService(BookieServer toRemove) {\n+    private void stopAutoRecoveryService(BookieServer toRemove) throws Exception {\n         AutoRecoveryMain autoRecoveryMain = autoRecoveryProcesses\n                 .remove(toRemove);\n         if (null != autoRecoveryMain && isAutoRecoveryEnabled()) {\n@@ -512,21 +506,8 @@ private void stopAutoRecoveryService(BookieServer toRemove) {\n      * Will starts the auto recovery process for the bookie servers. One auto\n      * recovery process per each bookie server, if isAutoRecoveryEnabled is\n      * enabled.\n-     *\n-     * @throws CompatibilityException\n-     *             - Compatibility error\n-     * @throws KeeperException\n-     *             - ZK exception\n-     * @throws InterruptedException\n-     *             - interrupted exception\n-     * @throws IOException\n-     *             - IOException\n-     * @throws UnavailableException\n-     *             - replication service has become unavailable\n      */\n-    public void startReplicationService() throws CompatibilityException,\n-            KeeperException, InterruptedException, IOException,\n-            UnavailableException {\n+    public void startReplicationService() throws Exception {\n         int index = -1;\n         for (BookieServer bserver : bs) {\n             startAutoRecovery(bserver, bsConfs.get(++index));\n@@ -537,7 +518,7 @@ public void startReplicationService() throws CompatibilityException,\n      * Will stops all the auto recovery processes for the bookie cluster, if\n      * isAutoRecoveryEnabled is true.\n      */\n-    public void stopReplicationService() {\n+    public void stopReplicationService() throws Exception {\n         if(false == isAutoRecoveryEnabled()){\n             return;\n         }"}]}

