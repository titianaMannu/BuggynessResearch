{"sha":"6b44bc232811e379463f71a27293c3f31ed398ba","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2YjQ0YmMyMzI4MTFlMzc5NDYzZjcxYTI3MjkzYzNmMzFlZDM5OGJh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-27T15:43:59Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-27T15:43:59Z"},"message":"BOOKKEEPER-272: Provide automatic mechanism to know bookie failures (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1377716 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"eebe0a4df730c077e1268569c26ba800ac8ae021","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/eebe0a4df730c077e1268569c26ba800ac8ae021"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6b44bc232811e379463f71a27293c3f31ed398ba","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6b44bc232811e379463f71a27293c3f31ed398ba","html_url":"https://github.com/apache/bookkeeper/commit/6b44bc232811e379463f71a27293c3f31ed398ba","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6b44bc232811e379463f71a27293c3f31ed398ba/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d930b579a1e96757e1698bf91bc1c99ac1cb5f35","url":"https://api.github.com/repos/apache/bookkeeper/commits/d930b579a1e96757e1698bf91bc1c99ac1cb5f35","html_url":"https://github.com/apache/bookkeeper/commit/d930b579a1e96757e1698bf91bc1c99ac1cb5f35"}],"stats":{"total":1134,"additions":1134,"deletions":0},"files":[{"sha":"320e67596883f7f2813e93d1036c20e3b93f4fcb","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/6b44bc232811e379463f71a27293c3f31ed398ba/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/6b44bc232811e379463f71a27293c3f31ed398ba/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=6b44bc232811e379463f71a27293c3f31ed398ba","patch":"@@ -104,6 +104,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-304: Prepare bookie vs ledgers cache and will be used by the Auditor (rakeshr via ivank)\n \n+        BOOKKEEPER-272: Provide automatic mechanism to know bookie failures (rakeshr via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"8cd35b90013f186b02027a803ffb4b21d342e28e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"added","additions":234,"deletions":0,"changes":234,"blob_url":"https://github.com/apache/bookkeeper/blob/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=6b44bc232811e379463f71a27293c3f31ed398ba","patch":"@@ -0,0 +1,234 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n+import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Auditor is a single entity in the entire Bookie cluster and will be watching\n+ * all the bookies under 'ledgerrootpath/available' zkpath. When any of the\n+ * bookie failed or disconnected from zk, he will start initiating the\n+ * re-replication activities by keeping all the corresponding ledgers of the\n+ * failed bookie as underreplicated znode in zk.\n+ */\n+public class Auditor extends Thread implements Watcher {\n+    private static final Logger LOG = LoggerFactory.getLogger(Auditor.class);\n+    private final LinkedBlockingQueue<EventType> bookieNotifications = new LinkedBlockingQueue<EventType>();\n+    private final AbstractConfiguration conf;\n+    private final ZooKeeper zkc;\n+    private BookieLedgerIndexer bookieLedgerIndexer;\n+    private LedgerUnderreplicationManager ledgerUnderreplicationManager;\n+    private volatile boolean running = true;\n+\n+    public Auditor(String bookieIdentifier, AbstractConfiguration conf,\n+            ZooKeeper zkc) throws UnavailableException {\n+        setName(\"AuditorBookie-\" + bookieIdentifier);\n+        setDaemon(true);\n+        this.conf = conf;\n+        this.zkc = zkc;\n+        initialize(conf, zkc);\n+    }\n+\n+    private void initialize(AbstractConfiguration conf, ZooKeeper zkc)\n+            throws UnavailableException {\n+        try {\n+            LedgerManagerFactory ledgerManagerFactory = LedgerManagerFactory\n+                    .newLedgerManagerFactory(conf, zkc);\n+\n+            this.bookieLedgerIndexer = new BookieLedgerIndexer(\n+                    ledgerManagerFactory.newLedgerManager());\n+\n+            this.ledgerUnderreplicationManager = ledgerManagerFactory\n+                    .newLedgerUnderreplicationManager();\n+\n+        } catch (CompatibilityException ce) {\n+            throw new UnavailableException(\n+                    \"CompatibilityException while initializing Auditor\", ce);\n+        } catch (IOException ioe) {\n+            throw new UnavailableException(\n+                    \"IOException while initializing Auditor\", ioe);\n+        } catch (KeeperException ke) {\n+            throw new UnavailableException(\n+                    \"KeeperException while initializing Auditor\", ke);\n+        } catch (InterruptedException ie) {\n+            throw new UnavailableException(\n+                    \"Interrupted while initializing Auditor\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        LOG.info(\"I'm starting as Auditor Bookie\");\n+        try {\n+            // on startup watching available bookie and based on the\n+            // available bookies determining the bookie failures.\n+            List<String> knownBookies = getAvailableBookies();\n+            auditingBookies(knownBookies);\n+\n+            while (true) {\n+                // wait for bookie join/failure notifications\n+                bookieNotifications.take();\n+                List<String> availableBookies = getAvailableBookies();\n+\n+                // casting to String, as knownBookies and availableBookies\n+                // contains only String values\n+                // find new bookies(if any) and update the known bookie list\n+                Collection<String> newBookies = CollectionUtils.subtract(\n+                        availableBookies, knownBookies);\n+                knownBookies.addAll(newBookies);\n+\n+                // find lost bookies(if any)\n+                Collection<String> lostBookies = CollectionUtils.subtract(\n+                        knownBookies, availableBookies);\n+\n+                if (lostBookies.size() > 0) {\n+                    knownBookies.removeAll(lostBookies);\n+                    Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n+                    handleLostBookies(lostBookies, ledgerDetails);\n+                }\n+            }\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Exception while watching available bookies\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            LOG.error(\"Interrupted while watching available bookies \", ie);\n+        } catch (BKAuditException bke) {\n+            LOG.error(\"Exception while watching available bookies\", bke);\n+        }\n+\n+        shutdown();\n+    }\n+\n+    private List<String> getAvailableBookies() throws KeeperException,\n+            InterruptedException {\n+        return zkc.getChildren(conf.getZkAvailableBookiesPath(), this);\n+    }\n+\n+    private void auditingBookies(List<String> availableBookies)\n+            throws BKAuditException, KeeperException, InterruptedException {\n+\n+        Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n+\n+        // find lost bookies\n+        Set<String> knownBookies = ledgerDetails.keySet();\n+        Collection<String> lostBookies = CollectionUtils.subtract(knownBookies,\n+                availableBookies);\n+\n+        if (lostBookies.size() > 0)\n+            handleLostBookies(lostBookies, ledgerDetails);\n+    }\n+\n+    private Map<String, Set<Long>> generateBookie2LedgersIndex()\n+            throws BKAuditException {\n+        return bookieLedgerIndexer.getBookieToLedgerIndex();\n+    }\n+\n+    private void handleLostBookies(Collection<String> lostBookies,\n+            Map<String, Set<Long>> ledgerDetails) throws BKAuditException,\n+            KeeperException, InterruptedException {\n+        LOG.info(\"Following are the failed bookies: \" + lostBookies\n+                + \" and searching its ledgers for re-replication\");\n+\n+        for (String bookieIP : lostBookies) {\n+            // identify all the ledgers in bookieIP and publishing these ledgers\n+            // as under-replicated.\n+            publishSuspectedLedgers(bookieIP, ledgerDetails.get(bookieIP));\n+        }\n+    }\n+\n+    private void publishSuspectedLedgers(String bookieIP, Set<Long> ledgers)\n+            throws KeeperException, InterruptedException, BKAuditException {\n+        if (null == ledgers || ledgers.size() == 0) {\n+            // there is no ledgers available for this bookie and just\n+            // ignoring the bookie failures\n+            LOG.info(\"There is no ledgers for the failed bookie: \" + bookieIP);\n+            return;\n+        }\n+        LOG.info(\"Following ledgers: \" + ledgers + \" of bookie: \" + bookieIP\n+                + \" are identified as underreplicated\");\n+        for (Long ledgerId : ledgers) {\n+            try {\n+                ledgerUnderreplicationManager.markLedgerUnderreplicated(\n+                        ledgerId, bookieIP);\n+            } catch (UnavailableException ue) {\n+                throw new BKAuditException(\n+                        \"Failed to publish underreplicated ledger: \" + ledgerId\n+                                + \" of bookie: \" + bookieIP, ue);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void process(WatchedEvent event) {\n+        // listen children changed event from ZooKeeper\n+        if (event.getType() == EventType.NodeChildrenChanged) {\n+            if (running)\n+                bookieNotifications.add(event.getType());\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the auditor\n+     */\n+    public void shutdown() {\n+        if (!running) {\n+            return;\n+        }\n+        running = false;\n+        LOG.info(\"Shutting down \" + getName());\n+        this.interrupt();\n+        try {\n+            this.join();\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            LOG.warn(\"Interrupted while shutting down auditor bookie\", ie);\n+        }\n+    }\n+\n+    /**\n+     * Return true if auditor is running otherwise return false\n+     * \n+     * @return auditor status\n+     */\n+    public boolean isRunning() {\n+        return running;\n+    }\n+}"},{"sha":"d517d198184cdf91539cfa3b6c184ec0d6283fb1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","status":"added","additions":269,"deletions":0,"changes":269,"blob_url":"https://github.com/apache/bookkeeper/blob/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","raw_url":"https://github.com/apache/bookkeeper/raw/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java?ref=6b44bc232811e379463f71a27293c3f31ed398ba","patch":"@@ -0,0 +1,269 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.io.Serializable;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Performing auditor election using Apache ZooKeeper. Using ZooKeeper as a\n+ * coordination service, when a bookie bids for auditor, it creates an ephemeral\n+ * sequential file (znode) on ZooKeeper and considered as their vote. Vote\n+ * format is 'V_sequencenumber'. Election will be done by comparing the\n+ * ephemeral sequential numbers and the bookie which has created the least znode\n+ * will be elected as Auditor. All the other bookies will be watching on their\n+ * predecessor znode according to the ephemeral sequence numbers.\n+ */\n+public class AuditorElector {\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(AuditorElector.class);\n+    // Represents the index of the auditor node\n+    private static final int AUDITOR_INDEX = 0;\n+    // Represents vote prefix\n+    private static final String VOTE_PREFIX = \"V_\";\n+    // Represents path Separator\n+    private static final String PATH_SEPARATOR = \"/\";\n+    // Represents urLedger path in zk\n+    private final String basePath;\n+    // Represents auditor election path in zk\n+    private final String electionPath;\n+\n+    private final String bookieId;\n+    private final AbstractConfiguration conf;\n+    private final ZooKeeper zkc;\n+\n+    private String myVote;\n+    private Auditor auditor;\n+    private volatile boolean running = true;\n+\n+    /**\n+     * AuditorElector for performing the auditor election\n+     * \n+     * @param bookieId\n+     *            - bookie identifier, comprises HostAddress:Port\n+     * @param conf\n+     *            - configuration\n+     * @param zkc\n+     *            - ZK instance\n+     * @throws UnavailableException\n+     *             throws unavailable exception while initializing the elector\n+     */\n+    public AuditorElector(String bookieId, AbstractConfiguration conf,\n+            ZooKeeper zkc) throws UnavailableException {\n+        this.bookieId = bookieId;\n+        this.conf = conf;\n+        this.zkc = zkc;\n+        basePath = conf.getZkLedgersRootPath() + \"/underreplication\";\n+        electionPath = basePath + \"/auditorelection\";\n+        createElectorPath();\n+    }\n+\n+    /**\n+     * Performing the auditor election using the ZooKeeper ephemeral sequential\n+     * znode. The bookie which has created the least sequential will be elect as\n+     * Auditor.\n+     * \n+     * @throws UnavailableException\n+     *             when performing auditor election\n+     * \n+     */\n+    public void doElection() throws UnavailableException {\n+        try {\n+            // creating my vote in zk. Vote format is 'V_numeric'\n+            createMyVote();\n+            List<String> children = zkc.getChildren(getVotePath(\"\"), false);\n+\n+            if (0 >= children.size()) {\n+                throw new IllegalArgumentException(\n+                        \"Atleast one bookie server should present to elect the Auditor!\");\n+            }\n+\n+            // sorting in ascending order of sequential number\n+            Collections.sort(children, new ElectionComparator());\n+            String voteNode = StringUtils.substringAfterLast(myVote,\n+                    PATH_SEPARATOR);\n+\n+            // starting Auditing service\n+            if (children.get(AUDITOR_INDEX).equals(voteNode)) {\n+                // update the auditor bookie id in the election path. This is\n+                // done for debugging purpose\n+                zkc.setData(getVotePath(\"\"), bookieId.getBytes(), -1);\n+                auditor = new Auditor(bookieId, conf, zkc);\n+                auditor.start();\n+            } else {\n+                // If not an auditor, will be watching to my predecessor and\n+                // looking the previous node deletion.\n+                Watcher electionWatcher = new ElectionWatcher();\n+                int myIndex = children.indexOf(voteNode);\n+                int prevNodeIndex = myIndex - 1;\n+                if (null == zkc.exists(getVotePath(PATH_SEPARATOR)\n+                        + children.get(prevNodeIndex), electionWatcher)) {\n+                    // While adding, the previous znode doesn't exists.\n+                    // Again going to election.\n+                    doElection();\n+                }\n+            }\n+        } catch (KeeperException e) {\n+            throw new UnavailableException(\n+                    \"Exception while performing auditor election\", e);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new UnavailableException(\n+                    \"Interrupted while performing auditor election\", e);\n+        }\n+    }\n+\n+    private void createMyVote() throws KeeperException, InterruptedException {\n+        if (null == myVote || null == zkc.exists(myVote, false)) {\n+            myVote = zkc.create(getVotePath(PATH_SEPARATOR + VOTE_PREFIX),\n+                    bookieId.getBytes(), Ids.OPEN_ACL_UNSAFE,\n+                    CreateMode.EPHEMERAL_SEQUENTIAL);\n+        }\n+    }\n+\n+    private String getVotePath(String vote) {\n+        return electionPath + vote;\n+    }\n+\n+    private void createElectorPath() throws UnavailableException {\n+        try {\n+            if (zkc.exists(basePath, false) == null) {\n+                try {\n+                    zkc.create(basePath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                            CreateMode.PERSISTENT);\n+                } catch (KeeperException.NodeExistsException nee) {\n+                    // do nothing, someone else could have created it\n+                }\n+            }\n+            if (zkc.exists(getVotePath(\"\"), false) == null) {\n+                try {\n+                    zkc.create(getVotePath(\"\"), new byte[0],\n+                            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+                } catch (KeeperException.NodeExistsException nee) {\n+                    // do nothing, someone else could have created it\n+                }\n+            }\n+        } catch (KeeperException ke) {\n+            throw new UnavailableException(\n+                    \"Failed to initialize Auditor Elector\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new UnavailableException(\n+                    \"Failed to initialize Auditor Elector\", ie);\n+        }\n+    }\n+\n+    /**\n+     * Watching the predecessor bookies and will do election on predecessor node\n+     * deletion or expiration.\n+     */\n+    private class ElectionWatcher implements Watcher {\n+\n+        @Override\n+        public void process(WatchedEvent event) {\n+            if (event.getType() == EventType.NodeDeleted) {\n+                try {\n+                    doElection();\n+                } catch (UnavailableException e) {\n+                    LOG.error(\"Exception when performing Auditor re-election\",\n+                            e);\n+                    shutdown();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutting down AuditorElector\n+     */\n+    public void shutdown() {\n+        if (!running) {\n+            return;\n+        }\n+        running = false;\n+        LOG.info(\"Shutting down AuditorElector\");\n+        try {\n+            zkc.delete(myVote, -1);\n+        } catch (InterruptedException ie) {\n+            LOG.warn(\"InterruptedException while deleting myVote: \" + myVote,\n+                    ie);\n+        } catch (KeeperException ke) {\n+            LOG.warn(\"Exception while deleting myVote:\" + myVote, ke);\n+        }\n+        if (auditor != null) {\n+            auditor.shutdown();\n+            auditor = null;\n+        }\n+    }\n+\n+    /**\n+     * If current bookie is running as auditor, return the status of the\n+     * auditor. Otherwise return the status of elector.\n+     * \n+     * @return\n+     */\n+    public boolean isRunning() {\n+        if (auditor != null) {\n+            return auditor.isRunning();\n+        }\n+        return running;\n+    }\n+\n+    /**\n+     * Compare the votes in the ascending order of the sequence number. Vote\n+     * format is 'V_sequencenumber', comparator will do sorting based on the\n+     * numeric sequence value.\n+     */\n+    private static class ElectionComparator\n+        implements Comparator<String>, Serializable {\n+        /**\n+         * Return -1 if the first vote is less than second. Return 1 if the\n+         * first vote is greater than second. Return 0 if the votes are equal.\n+         */\n+        public int compare(String vote1, String vote2) {\n+            long voteSeqId1 = getVoteSequenceId(vote1);\n+            long voteSeqId2 = getVoteSequenceId(vote2);\n+            int result = voteSeqId1 < voteSeqId2 ? -1\n+                    : (voteSeqId1 > voteSeqId2 ? 1 : 0);\n+            return result;\n+        }\n+\n+        private long getVoteSequenceId(String vote) {\n+            String voteId = StringUtils.substringAfter(vote, VOTE_PREFIX);\n+            return Long.parseLong(voteId);\n+        }\n+    }\n+}"},{"sha":"fcc46949dad9779d8a5e7e5c416b02bbbce270b6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"added","additions":277,"deletions":0,"changes":277,"blob_url":"https://github.com/apache/bookkeeper/blob/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=6b44bc232811e379463f71a27293c3f31ed398ba","patch":"@@ -0,0 +1,277 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This test verifies the auditor bookie scenarios which will be monitoring the\n+ * bookie failures\n+ */\n+public class AuditorBookieTest extends BookKeeperClusterTestCase {\n+    // Depending on the taste, select the amount of logging\n+    // by decommenting one of the two lines below\n+    // static Logger LOG = Logger.getRootLogger();\n+    private final static Logger LOG = LoggerFactory\n+            .getLogger(AuditorBookieTest.class);\n+    private String electionPath;\n+    private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n+\n+    public AuditorBookieTest() {\n+        super(6);\n+        electionPath = baseConf.getZkLedgersRootPath()\n+                + \"/underreplication/auditorelection\";\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        startAuditorElectors();\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        stopAuditorElectors();\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Test should ensure only one should act as Auditor. Starting/shutdown\n+     * other than auditor bookie shouldn't initiate re-election and multiple\n+     * auditors.\n+     */\n+    @Test\n+    public void testEnsureOnlySingleAuditor() throws Exception {\n+        BookieServer auditor = verifyAuditor();\n+\n+        // shutdown bookie which is not an auditor\n+        int indexOf = bs.indexOf(auditor);\n+        int bkIndexDownBookie;\n+        if (indexOf < bs.size() - 1) {\n+            bkIndexDownBookie = indexOf + 1;\n+        } else {\n+            bkIndexDownBookie = indexOf - 1;\n+        }\n+        shudownBookie(bs.get(bkIndexDownBookie));\n+\n+        startNewBookie();\n+        startNewBookie();\n+        // grace period for the auditor re-election if any\n+        BookieServer newAuditor = waitForNewAuditor(auditor);\n+        Assert.assertSame(\n+                \"Auditor re-election is not happened for auditor failure!\",\n+                auditor, newAuditor);\n+    }\n+\n+    /**\n+     * Test Auditor crashes should trigger re-election and another bookie should\n+     * take over the auditor ship\n+     */\n+    @Test\n+    public void testSuccessiveAuditorCrashes() throws Exception {\n+        BookieServer auditor = verifyAuditor();\n+        shudownBookie(auditor);\n+\n+        BookieServer newAuditor1 = waitForNewAuditor(auditor);\n+        bs.remove(auditor);\n+\n+        shudownBookie(newAuditor1);\n+        BookieServer newAuditor2 = waitForNewAuditor(newAuditor1);\n+        Assert.assertNotSame(\n+                \"Auditor re-election is not happened for auditor failure!\",\n+                auditor, newAuditor2);\n+        bs.remove(newAuditor1);\n+    }\n+\n+    /**\n+     * Test restarting the entire bookie cluster. It shouldn't create multiple\n+     * bookie auditors\n+     */\n+    @Test\n+    public void testBookieClusterRestart() throws Exception {\n+        BookieServer auditor = verifyAuditor();\n+        for (AuditorElector auditorElector : auditorElectors.values()) {\n+            assertTrue(\"Auditor elector is not running!\", auditorElector\n+                    .isRunning());\n+        }\n+        stopBKCluster();\n+        stopAuditorElectors();\n+\n+        startBKCluster();\n+        startAuditorElectors();\n+        BookieServer newAuditor = waitForNewAuditor(auditor);\n+        Assert.assertNotSame(\n+                \"Auditor re-election is not happened for auditor failure!\",\n+                auditor, newAuditor);\n+    }\n+\n+    /**\n+     * Test the vote is deleting from the ZooKeeper during shutdown.\n+     */\n+    @Test\n+    public void testShutdown() throws Exception {\n+        BookieServer auditor = verifyAuditor();\n+        shudownBookie(auditor);\n+\n+        // waiting for new auditor\n+        BookieServer newAuditor = waitForNewAuditor(auditor);\n+        Assert.assertNotSame(\n+                \"Auditor re-election is not happened for auditor failure!\",\n+                auditor, newAuditor);\n+        int indexOfDownBookie = bs.indexOf(auditor);\n+        bs.remove(indexOfDownBookie);\n+        bsConfs.remove(indexOfDownBookie);\n+        tmpDirs.remove(indexOfDownBookie);\n+        List<String> children = zkc.getChildren(electionPath, false);\n+        for (String child : children) {\n+            byte[] data = zkc.getData(electionPath + '/' + child, false, null);\n+            String bookieIP = new String(data);\n+            StringBuilder addr = new StringBuilder();\n+            StringUtils.addrToString(addr, auditor.getLocalAddress());\n+            Assert.assertFalse(\"AuditorElection cleanup fails\", bookieIP\n+                    .contains(addr));\n+        }\n+    }\n+\n+    /**\n+     * Test restart of the previous Auditor bookie shouldn't initiate\n+     * re-election and should create new vote after restarting.\n+     */\n+    @Test\n+    public void testRestartAuditorBookieAfterCrashing() throws Exception {\n+        BookieServer auditor = verifyAuditor();\n+\n+        shudownBookie(auditor);\n+\n+        // restarting Bookie with same configurations.\n+        int indexOfDownBookie = bs.indexOf(auditor);\n+        ServerConfiguration serverConfiguration = bsConfs\n+                .get(indexOfDownBookie);\n+        bs.remove(indexOfDownBookie);\n+        bsConfs.remove(indexOfDownBookie);\n+        tmpDirs.remove(indexOfDownBookie);\n+        startBookie(serverConfiguration);\n+        // starting corresponding auditor elector\n+        StringBuilder sb = new StringBuilder();\n+        StringUtils.addrToString(sb, auditor.getLocalAddress());\n+        LOG.debug(\"Performing Auditor Election:\" + sb.toString());\n+        auditorElectors.get(sb.toString()).doElection();\n+\n+        // waiting for new auditor to come\n+        BookieServer newAuditor = waitForNewAuditor(auditor);\n+        Assert.assertNotSame(\n+                \"Auditor re-election is not happened for auditor failure!\",\n+                auditor, newAuditor);\n+        Assert.assertFalse(\"No relection after old auditor rejoins\", auditor\n+                .getLocalAddress().getPort() == newAuditor.getLocalAddress()\n+                .getPort());\n+    }\n+\n+    private void startAuditorElectors() throws UnavailableException {\n+        for (BookieServer bserver : bs) {\n+            StringBuilder sb = new StringBuilder();\n+            StringBuilder addr = StringUtils.addrToString(sb, bserver\n+                    .getLocalAddress());\n+            AuditorElector auditorElector = new AuditorElector(addr.toString(),\n+                    baseClientConf, zkc);\n+            auditorElectors.put(addr.toString(), auditorElector);\n+            auditorElector.doElection();\n+            LOG.debug(\"Starting Auditor Elector\");\n+        }\n+    }\n+\n+    private void stopAuditorElectors() {\n+        for (AuditorElector auditorElector : auditorElectors.values()) {\n+            auditorElector.shutdown();\n+            LOG.debug(\"Stopping Auditor Elector!\");\n+        }\n+    }\n+\n+    private BookieServer verifyAuditor() throws KeeperException,\n+            InterruptedException {\n+        List<BookieServer> auditors = getAuditorBookie();\n+        Assert.assertEquals(\"Multiple Bookies acting as Auditor!\", 1, auditors\n+                .size());\n+        LOG.debug(\"Bookie running as Auditor:\" + auditors.get(0));\n+        return auditors.get(0);\n+    }\n+\n+    private List<BookieServer> getAuditorBookie() throws KeeperException,\n+            InterruptedException {\n+        List<BookieServer> auditors = new LinkedList<BookieServer>();\n+        byte[] data = zkc.getData(electionPath, false, null);\n+        Assert.assertNotNull(\"Auditor election failed\", data);\n+        for (BookieServer bks : bs) {\n+            if (new String(data).contains(bks.getLocalAddress().getPort() + \"\")) {\n+                auditors.add(bks);\n+            }\n+        }\n+        return auditors;\n+    }\n+\n+    private void shudownBookie(BookieServer bkServer) {\n+        StringBuilder sb = new StringBuilder();\n+        StringUtils.addrToString(sb, bkServer.getLocalAddress());\n+        LOG.debug(\"Shutting down bookie:\" + sb.toString());\n+\n+        // shutdown bookie which is an auditor\n+        bkServer.shutdown();\n+        // stopping corresponding auditor elector\n+        auditorElectors.get(sb.toString()).shutdown();\n+    }\n+\n+    private BookieServer waitForNewAuditor(BookieServer auditor)\n+            throws InterruptedException, KeeperException {\n+        BookieServer newAuditor = null;\n+        int retryCount = 8;\n+        while (retryCount > 0) {\n+            List<BookieServer> auditors = getAuditorBookie();\n+            if (auditors.size() > 0) {\n+                newAuditor = auditors.get(0);\n+                if (auditor == newAuditor) {\n+                    Thread.sleep(500);\n+                } else {\n+                    break;\n+                }\n+            }\n+            retryCount--;\n+        }\n+        Assert.assertNotNull(\n+                \"New Auditor is not reelected after auditor crashes\",\n+                newAuditor);\n+        verifyAuditor();\n+        return newAuditor;\n+    }\n+}"},{"sha":"ddf67037a4befe6dd8a7477639fffac9e2db7e03","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"added","additions":352,"deletions":0,"changes":352,"blob_url":"https://github.com/apache/bookkeeper/blob/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/6b44bc232811e379463f71a27293c3f31ed398ba/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=6b44bc232811e379463f71a27293c3f31ed398ba","patch":"@@ -0,0 +1,352 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Tests publishing of under replicated ledgers by the Auditor bookie node when\n+ * corresponding bookies identifes as not running\n+ */\n+public class AuditorLedgerCheckerTest extends MultiLedgerManagerTestCase {\n+\n+    // Depending on the taste, select the amount of logging\n+    // by decommenting one of the two lines below\n+    // static Logger LOG = Logger.getRootLogger();\n+    private final static Logger LOG = LoggerFactory\n+            .getLogger(AuditorLedgerCheckerTest.class);\n+\n+    private static final byte[] ledgerPassword = \"aaa\".getBytes();\n+    private Random rng; // Random Number Generator\n+\n+    private DigestType digestType;\n+\n+    private final String UNDERREPLICATED_PATH = baseClientConf\n+            .getZkLedgersRootPath()\n+            + \"/underreplication/ledgers\";\n+    private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n+    private LedgerUnderreplicationManager urLedgerMgr;\n+    private Set<Long> urLedgerList;\n+    private Map<Long, String> urLedgerData;\n+    private List<Long> ledgerList;\n+\n+    public AuditorLedgerCheckerTest(String ledgerManagerFactoryClass)\n+            throws IOException, KeeperException, InterruptedException,\n+            CompatibilityException {\n+        super(3);\n+        LOG.info(\"Running test case using ledger manager : \"\n+                + ledgerManagerFactoryClass);\n+        this.digestType = DigestType.CRC32;\n+        // set ledger manager name\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactoryClass);\n+        baseClientConf\n+                .setLedgerManagerFactoryClassName(ledgerManagerFactoryClass);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        urLedgerMgr = new ZkLedgerUnderreplicationManager(baseClientConf, zkc);\n+        startAuditorElectors();\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+        urLedgerList = new HashSet<Long>();\n+        urLedgerData = new HashMap<Long, String>();\n+        ledgerList = new ArrayList<Long>(2);\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        stopAuditorElectors();\n+    }\n+\n+    private void startAuditorElectors() throws UnavailableException {\n+        for (BookieServer bserver : bs) {\n+            StringBuilder sb = new StringBuilder();\n+            StringBuilder addr = StringUtils.addrToString(sb, bserver\n+                    .getLocalAddress());\n+            AuditorElector auditorElector = new AuditorElector(addr.toString(),\n+                    baseClientConf, zkc);\n+            auditorElectors.put(addr.toString(), auditorElector);\n+            auditorElector.doElection();\n+            LOG.debug(\"Starting Auditor Elector\");\n+        }\n+    }\n+\n+    private void stopAuditorElectors() {\n+        for (AuditorElector auditorElector : auditorElectors.values()) {\n+            auditorElector.shutdown();\n+            LOG.debug(\"Stopping Auditor Elector!\");\n+        }\n+    }\n+\n+    /**\n+     * Test publishing of under replicated ledgers by the auditor bookie\n+     */\n+    @Test\n+    public void testSimpleLedger() throws Exception {\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        int bkShutdownIndex = bs.size() - 1;\n+        String shutdownBookie = shutdownBookie(bkShutdownIndex);\n+\n+        // grace period for publishing the bk-ledger\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        underReplicaLatch.await(5, TimeUnit.SECONDS);\n+\n+        assertEquals(\"Missed identifying under replicated ledgers\", 1,\n+                urLedgerList.size());\n+\n+        /*\n+         * Sample data format present in the under replicated ledger path\n+         * \n+         * {4=replica: \"10.18.89.153:5002\"}\n+         */\n+        assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                urLedgerList.contains(ledgerId));\n+        String data = urLedgerData.get(ledgerId);\n+        assertTrue(\"Bookie \" + shutdownBookie\n+                + \"is not listed in the ledger as missing replica :\" + data,\n+                data.contains(shutdownBookie));\n+    }\n+\n+    /**\n+     * Test once published under replicated ledger should exists even after\n+     * restarting respective bookie\n+     */\n+    @Test\n+    public void testRestartBookie() throws Exception {\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        ledgerList.add(lh1.getId());\n+        LedgerHandle lh2 = createAndAddEntriesToLedger();\n+        ledgerList.add(lh2.getId());\n+        LOG.debug(\"Created following ledgers : \" + ledgerList);\n+\n+        // 2 is added to the latch, since after the ledger reformation, again\n+        // the reformed bookie is stopped. So auditor will modify the zk\n+        // underreplicated metadata\n+        int count = ledgerList.size() + 2;\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(count);\n+\n+        int bkShutdownIndex = bs.size() - 1;\n+        ServerConfiguration bookieConf1 = bsConfs.get(bkShutdownIndex);\n+        String shutdownBookie = shutdownBookie(bkShutdownIndex);\n+\n+        // restart the failed bookie and simulate previously listed ledgers are\n+        // rereplicated\n+        bs.add(startBookie(bookieConf1));\n+\n+        // grace period for publishing the bk-ledger\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        underReplicaLatch.await(5, TimeUnit.SECONDS);\n+\n+        assertEquals(\"Missed identifying under replicated ledgers\", 2,\n+                urLedgerList.size());\n+\n+        /*\n+         * Sample data format present in the under replicated ledger path\n+         * \n+         * {4=replica: \"10.18.89.153:5002\", 5=replica: \"10.18.89.153:5003\"}\n+         */\n+        for (Long ledgerId : ledgerList) {\n+            assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                    urLedgerList.contains(ledgerId));\n+            String data = urLedgerData.get(ledgerId);\n+            assertTrue(\"Bookie \" + shutdownBookie\n+                    + \" is not listed in the ledger as missing \" + data, data\n+                    .contains(shutdownBookie));\n+        }\n+    }\n+\n+    /**\n+     * Test publishing of under replicated ledgers when multiple bookie failures\n+     * one after another.\n+     */\n+    @Test\n+    public void testMultipleBookieFailures() throws Exception {\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        ledgerList.add(lh1.getId());\n+        LedgerHandle lh2 = createAndAddEntriesToLedger();\n+        ledgerList.add(lh2.getId());\n+        LOG.debug(\"Created following ledgers : \" + ledgerList);\n+\n+        // failing first bookie\n+        shutdownBookie(bs.size() - 1);\n+        // simulate re-replication\n+        doLedgerRereplication(lh1.getId());\n+        doLedgerRereplication(lh2.getId());\n+\n+        // failing another bookie\n+        CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+        String shutdownBookie = shutdownBookie(bs.size() - 1);\n+\n+        // grace period for publishing the bk-ledger\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        underReplicaLatch.await(5, TimeUnit.SECONDS);\n+\n+        assertEquals(\"Missed identifying under replicated ledgers\", 2,\n+                urLedgerList.size());\n+\n+        /*\n+         * Sample data format present in the under replicated ledger path\n+         * {4=replica: \"10.18.89.153:5002\", 5=replica: \"10.18.89.153:5003\"}\n+         */\n+        for (Long ledgerId : ledgerList) {\n+            assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                    urLedgerList.contains(ledgerId));\n+            String data = urLedgerData.get(ledgerId);\n+            assertTrue(\"Bookie \" + shutdownBookie\n+                    + \" is not listed in the ledger as missing \" + data, data\n+                    .contains(shutdownBookie));\n+        }\n+    }\n+\n+    private CountDownLatch registerUrLedgerWatcher(int count)\n+            throws KeeperException, InterruptedException {\n+        final CountDownLatch underReplicaLatch = new CountDownLatch(count);\n+        for (Long ledgerId : ledgerList) {\n+            Watcher urLedgerWatcher = new ChildWatcher(underReplicaLatch);\n+            String znode = String.format(\"%s/urL%010d\", getParentZnodePath(\n+                    UNDERREPLICATED_PATH, ledgerId), ledgerId);\n+            zkc.exists(znode, urLedgerWatcher);\n+        }\n+        return underReplicaLatch;\n+    }\n+\n+    private void doLedgerRereplication(long ledgerId)\n+            throws UnavailableException {\n+        urLedgerMgr.getLedgerToRereplicate();\n+        urLedgerMgr.markLedgerReplicated(ledgerId);\n+        urLedgerMgr.releaseUnderreplicatedLedger(ledgerId);\n+        urLedgerData.clear();\n+    }\n+\n+    private String shutdownBookie(int bkShutdownIndex) throws IOException,\n+            InterruptedException {\n+        StringBuilder bookieAddr = new StringBuilder();\n+        BookieServer bkServer = bs.get(bkShutdownIndex);\n+        StringUtils.addrToString(bookieAddr, bkServer.getLocalAddress());\n+        LOG.debug(\"Shutting down bookie:\" + bookieAddr.toString());\n+        killBookie(bkShutdownIndex);\n+        auditorElectors.get(bookieAddr.toString()).shutdown();\n+        auditorElectors.remove(bookieAddr.toString());\n+        return bookieAddr.toString();\n+    }\n+\n+    private LedgerHandle createAndAddEntriesToLedger() throws BKException,\n+            InterruptedException {\n+        int numEntriesToWrite = 100;\n+        // Create a ledger\n+        LedgerHandle lh = bkc.createLedger(digestType, ledgerPassword);\n+        LOG.info(\"Ledger ID: \" + lh.getId());\n+        addEntry(numEntriesToWrite, lh);\n+        return lh;\n+    }\n+\n+    private void addEntry(int numEntriesToWrite, LedgerHandle lh)\n+            throws InterruptedException, BKException {\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(Integer.MAX_VALUE));\n+            entry.position(0);\n+            lh.addEntry(entry.array());\n+        }\n+    }\n+\n+    private String getParentZnodePath(String base, long ledgerId) {\n+        String subdir1 = String.format(\"%04x\", ledgerId >> 48 & 0xffff);\n+        String subdir2 = String.format(\"%04x\", ledgerId >> 32 & 0xffff);\n+        String subdir3 = String.format(\"%04x\", ledgerId >> 16 & 0xffff);\n+        String subdir4 = String.format(\"%04x\", ledgerId & 0xffff);\n+\n+        return String.format(\"%s/%s/%s/%s/%s\", base, subdir1, subdir2, subdir3,\n+                subdir4);\n+    }\n+\n+    private class ChildWatcher implements Watcher {\n+        private final CountDownLatch underReplicaLatch;\n+\n+        public ChildWatcher(CountDownLatch underReplicaLatch) {\n+            this.underReplicaLatch = underReplicaLatch;\n+        }\n+\n+        @Override\n+        public void process(WatchedEvent event) {\n+            LOG.debug(\"Recieved notification for the ledger path : \"\n+                    + event.getPath());\n+            for (Long ledgerId : ledgerList) {\n+                if (event.getPath().contains(ledgerId + \"\")) {\n+                    urLedgerList.add(Long.valueOf(ledgerId));\n+                    try {\n+                        byte[] data = zkc.getData(event.getPath(), this, null);\n+                        urLedgerData.put(ledgerId, new String(data));\n+                    } catch (KeeperException e) {\n+                        LOG.error(\"Exception while reading data from znode :\"\n+                                + event.getPath());\n+                    } catch (InterruptedException e) {\n+                        LOG.error(\"Exception while reading data from znode :\"\n+                                + event.getPath());\n+                    }\n+                }\n+            }\n+            LOG.debug(\"Count down and waiting for next notification\");\n+            // count down and waiting for next notification\n+            underReplicaLatch.countDown();\n+        }\n+    }\n+}"}]}

