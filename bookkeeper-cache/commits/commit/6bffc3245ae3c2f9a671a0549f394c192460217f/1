{"sha":"6bffc3245ae3c2f9a671a0549f394c192460217f","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2YmZmYzMyNDVhZTNjMmY5YTY3MWEwNTQ5ZjM5NGMxOTI0NjAyMTdm","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-09-13T13:52:24Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-09-13T13:52:24Z"},"message":" BOOKKEEPER-392: Racey ConcurrentMap usage in java hedwig-client (Stu Hood via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1384336 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cddfb7a9d333aac4bd06753cd9cc3a7842516b6b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/cddfb7a9d333aac4bd06753cd9cc3a7842516b6b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6bffc3245ae3c2f9a671a0549f394c192460217f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6bffc3245ae3c2f9a671a0549f394c192460217f","html_url":"https://github.com/apache/bookkeeper/commit/6bffc3245ae3c2f9a671a0549f394c192460217f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6bffc3245ae3c2f9a671a0549f394c192460217f/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"420a6e5e6cab583929622d190d2cd3b360cbd102","url":"https://api.github.com/repos/apache/bookkeeper/commits/420a6e5e6cab583929622d190d2cd3b360cbd102","html_url":"https://github.com/apache/bookkeeper/commit/420a6e5e6cab583929622d190d2cd3b360cbd102"}],"stats":{"total":142,"additions":70,"deletions":72},"files":[{"sha":"bb06304ff09ca981dd85123fa599e506bab68bb6","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -96,6 +96,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-371: NPE in hedwig hub client causes hedwig hub to shut down. (Aniruddha via sijie)\n \n+        BOOKKEEPER-392: Racey ConcurrentMap usage in java hedwig-client (Stu Hood via sijie)\n+\n       hedwig-server:\n \n         BOOKKEEPER-302: No more messages delivered when hub server scans messages over two ledgers. (sijie via ivank)"},{"sha":"7ad626545648deeab9ed0139bdcde215865f4ebc","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -314,7 +314,7 @@ protected synchronized void messageConsumed(Message message) {\n         // outstanding message limit was reached. For now, only turn the\n         // delivery back on if there are no more outstanding messages to\n         // consume. We could make this a configurable parameter if needed.\n-        if (!subscribeChannel.isReadable() && outstandingMsgSet.size() == 0) {\n+        if (!subscribeChannel.isReadable() && outstandingMsgSet.isEmpty()) {\n             if (logger.isDebugEnabled())\n                 logger\n                 .debug(\"Message consumption has caught up so okay to turn off throttling of messages on the subscribe channel for topic: \""},{"sha":"e3d46ca47a4207f52f7037d095f5ca032cb8485d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"modified","additions":23,"deletions":18,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -18,11 +18,10 @@\n package org.apache.hedwig.client.netty;\n \n import java.net.InetSocketAddress;\n-import java.util.LinkedList;\n-import java.util.List;\n import java.util.Timer;\n import java.util.TimerTask;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.Executors;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -76,7 +75,8 @@\n     // also want to remove all topic mappings the host was responsible for.\n     // The second Map is used as the inverted version of the first one.\n     protected final ConcurrentMap<ByteString, InetSocketAddress> topic2Host = new ConcurrentHashMap<ByteString, InetSocketAddress>();\n-    private final ConcurrentMap<InetSocketAddress, List<ByteString>> host2Topics = new ConcurrentHashMap<InetSocketAddress, List<ByteString>>();\n+    private final ConcurrentMap<InetSocketAddress, ConcurrentLinkedQueue<ByteString>> host2Topics =\n+        new ConcurrentHashMap<InetSocketAddress, ConcurrentLinkedQueue<ByteString>>();\n \n     // Each client instantiation will have a Timer for running recurring\n     // threads. One such timer task thread to is to timeout long running\n@@ -292,23 +292,27 @@ protected void storeTopic2HostMapping(PubSubData pubSubData, Channel channel) {\n         // server statuses, we consider that as a successful connection to the\n         // correct topic master.\n         InetSocketAddress host = getHostFromChannel(channel);\n-        if (topic2Host.containsKey(pubSubData.topic) && topic2Host.get(pubSubData.topic).equals(host)) {\n+        InetSocketAddress existingHost = topic2Host.get(pubSubData.topic);\n+        if (existingHost != null && existingHost.equals(host)) {\n             // Entry in map exists for the topic but it is the same as the\n             // current host. In this case there is nothing to do.\n             return;\n         }\n \n         // Store the relevant mappings for this topic and host combination.\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Storing info for topic: \" + pubSubData.topic.toStringUtf8() + \", old host: \"\n-                         + topic2Host.get(pubSubData.topic) + \", new host: \" + host);\n-        topic2Host.put(pubSubData.topic, host);\n-        if (host2Topics.containsKey(host)) {\n-            host2Topics.get(host).add(pubSubData.topic);\n-        } else {\n-            LinkedList<ByteString> topicsList = new LinkedList<ByteString>();\n-            topicsList.add(pubSubData.topic);\n-            host2Topics.put(host, topicsList);\n+        if (topic2Host.putIfAbsent(pubSubData.topic, host) == null) {\n+            if (logger.isDebugEnabled())\n+                logger.debug(\"Stored info for topic: \" + pubSubData.topic.toStringUtf8() + \", old host: \"\n+                            + existingHost + \", new host: \" + host);\n+            ConcurrentLinkedQueue<ByteString> topicsForHost = host2Topics.get(host);\n+            if (topicsForHost == null) {\n+                ConcurrentLinkedQueue<ByteString> newTopicsList = new ConcurrentLinkedQueue<ByteString>();\n+                topicsForHost = host2Topics.putIfAbsent(host, newTopicsList);\n+                if (topicsForHost == null) {\n+                  topicsForHost = newTopicsList;\n+                }\n+            }\n+            topicsForHost.add(pubSubData.topic);\n         }\n     }\n \n@@ -360,14 +364,15 @@ public void clearAllTopicsForHost(InetSocketAddress host) {\n             logger.debug(\"Clearing all topics for host: \" + host);\n         // For each of the topics that the host was responsible for,\n         // remove it from the topic2Host mapping.\n-        if (host2Topics.containsKey(host)) {\n-            for (ByteString topic : host2Topics.get(host)) {\n+        ConcurrentLinkedQueue<ByteString> topicsForHost = host2Topics.get(host);\n+        if (topicsForHost != null) {\n+            for (ByteString topic : topicsForHost) {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Removing mapping for topic: \" + topic.toStringUtf8() + \" from host: \" + host);\n-                topic2Host.remove(topic);\n+                topic2Host.remove(topic, host);\n             }\n             // Now it is safe to remove the host2Topics mapping entry.\n-            host2Topics.remove(host);\n+            host2Topics.remove(host, topicsForHost);\n         }\n     }\n "},{"sha":"06ff4faa1c3de8412d9b66c3075ae2fdccdcda1a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"modified","additions":11,"deletions":10,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -135,14 +135,15 @@ private void asyncPublishWithResponseImpl(ByteString topic, Message msg,\n         // Check if we already have a Channel connection set up to the server\n         // for the given Topic.\n         PubSubData pubSubData = new PubSubData(topic, msg, null, OperationType.PUBLISH, null, callback, context);\n-        if (client.topic2Host.containsKey(topic)) {\n-            InetSocketAddress host = client.topic2Host.get(topic);\n-            if (host2Channel.containsKey(host)) {\n+        InetSocketAddress host = client.topic2Host.get(topic);\n+        if (host != null) {\n+            Channel channel = host2Channel.get(host);\n+            if (channel != null) {\n                 // We already have the Channel connection for the server host so\n                 // do the publish directly. We will deal with redirect logic\n                 // later on if that server is no longer the current host for\n                 // the topic.\n-                doPublish(pubSubData, host2Channel.get(host));\n+                doPublish(pubSubData, channel);\n             } else {\n                 // We have a mapping for the topic to host but don't have a\n                 // Channel for that server. This can happen if the Channel\n@@ -155,10 +156,11 @@ private void asyncPublishWithResponseImpl(ByteString topic, Message msg,\n             // default server host/port as defined in the configs. This should\n             // point to the server VIP which would redirect to a random server\n             // (which might not be the server hosting the topic).\n-            InetSocketAddress host = cfg.getDefaultServerHost();\n-            if (host2Channel.containsKey(host)) {\n+            host = cfg.getDefaultServerHost();\n+            Channel channel = host2Channel.get(host);\n+            if (channel != null) {\n                 // if there is a channel to default server, use it!\n-                doPublish(pubSubData, host2Channel.get(host));\n+                doPublish(pubSubData, channel);\n                 return;\n             }\n             client.doConnect(pubSubData, host);\n@@ -226,10 +228,9 @@ protected void doPublish(PubSubData pubSubData, Channel channel) {\n     // RemoteAddress tied to it.\n     protected synchronized void storeHost2ChannelMapping(Channel channel) {\n         InetSocketAddress host = HedwigClientImpl.getHostFromChannel(channel);\n-        if (!closed && !host2Channel.containsKey(host)) {\n+        if (!closed && host2Channel.putIfAbsent(host, channel) == null) {\n             if (logger.isDebugEnabled())\n-                logger.debug(\"Storing a new Channel mapping for host: \" + host);\n-            host2Channel.put(host, channel);\n+                logger.debug(\"Stored a new Channel mapping for host: \" + host);\n         } else {\n             // If we've reached here, that means we already have a Channel\n             // mapping for the given host. This should ideally not happen"},{"sha":"5bcf786821785d9fc35c4276f79141e2439188bb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":20,"deletions":20,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -84,7 +84,7 @@\n \n     protected final HedwigClientImpl client;\n     protected final ClientConfiguration cfg;\n-    private Object closeLock = new Object();\n+    private final Object closeLock = new Object();\n     private boolean closed = false;\n \n     public HedwigSubscriber(HedwigClientImpl client) {\n@@ -175,14 +175,17 @@ private void asyncSubUnsub(ByteString topic, ByteString subscriberId,\n         // subscribing to.\n         PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, options, callback,\n                                                context);\n-        if (client.topic2Host.containsKey(topic)) {\n-            InetSocketAddress host = client.topic2Host.get(topic);\n-            if (operationType.equals(OperationType.UNSUBSCRIBE) && client.getPublisher().host2Channel.containsKey(host)) {\n+\n+        InetSocketAddress host = client.topic2Host.get(topic);\n+        if (host != null) {\n+            Channel existingChannel = null;\n+            if (operationType.equals(OperationType.UNSUBSCRIBE) &&\n+                (existingChannel = client.getPublisher().host2Channel.get(host)) != null) {\n                 // For unsubscribes, we can reuse the channel connections to the\n                 // server host that are cached for publishes. For publish and\n                 // unsubscribe flows, we will thus use the same Channels and\n                 // will cache and store them during the ConnectCallback.\n-                doSubUnsub(pubSubData, client.getPublisher().host2Channel.get(host));\n+                doSubUnsub(pubSubData, existingChannel);\n             } else {\n                 // We know which server host is the master for the topic so\n                 // connect to that first. For subscribes, we want a new channel\n@@ -348,15 +351,16 @@ public void consume(ByteString topic, ByteString subscriberId, MessageSeqId mess\n                          + subscriberId.toStringUtf8() + \", messageSeqId: \" + messageSeqId);\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n         // Check that this topic subscription on the client side exists.\n-        if (!topicSubscriber2Channel.containsKey(topicSubscriber)) {\n+        Channel channel = topicSubscriber2Channel.get(topicSubscriber);\n+        if (channel == null) {\n             throw new ClientNotSubscribedException(\n                 \"Cannot send consume message since client is not subscribed to topic: \" + topic.toStringUtf8()\n                 + \", subscriberId: \" + subscriberId.toStringUtf8());\n         }\n         PubSubData pubSubData = new PubSubData(topic, null, subscriberId, OperationType.CONSUME, null, null, null);\n         // Send the consume message to the server using the same subscribe\n         // channel that the topic subscription uses.\n-        doConsume(pubSubData, topicSubscriber2Channel.get(topicSubscriber), messageSeqId);\n+        doConsume(pubSubData, channel, messageSeqId);\n     }\n \n     /**\n@@ -586,20 +590,16 @@ private void startDelivery(final ByteString topic, final ByteString subscriberId\n         // exists. The assumption is that the client should have in memory the\n         // Channel created for the TopicSubscriber once the server has sent\n         // an ack response to the initial subscribe request.\n-        if (!topicSubscriber2Channel.containsKey(topicSubscriber)) {\n+        Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n+        if (topicSubscriberChannel == null) {\n             logger.error(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n                          + subscriberId.toStringUtf8());\n             throw new ClientNotSubscribedException(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8()\n                                                    + \", subscriberId: \" + subscriberId.toStringUtf8());\n         }\n \n-        // Register the MessageHandler with the subscribe Channel's\n-        // Response Handler.\n-        Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n-\n         // Need to ensure the setting of handler and the readability of channel is in sync\n         // as there's a race condition that connection recovery and user might call this at the same time\n-\n         MessageHandler existedMsgHandler = topicSubscriber2MessageHandler.get(topicSubscriber);\n         if (restart) {\n             // restart using existing msg handler \n@@ -620,7 +620,7 @@ private void startDelivery(final ByteString topic, final ByteString subscriberId\n             .setMessageHandler(messageHandler);\n         } catch (NoResponseHandlerException e) {\n             // We did not find a response handler. So remove this subscription handler and throw an exception.\n-            topicSubscriber2MessageHandler.remove(topicSubscriber);\n+            topicSubscriber2MessageHandler.remove(topicSubscriber, existedMsgHandler);\n             asyncCloseSubscription(topic, subscriberId, new Callback<Void>() {\n                 @Override\n                 public void operationFinished(Object ctx, Void resultOfOperation) {\n@@ -664,7 +664,8 @@ public void stopDelivery(final ByteString topic, final ByteString subscriberId)\n         // exists. The assumption is that the client should have in memory the\n         // Channel created for the TopicSubscriber once the server has sent\n         // an ack response to the initial subscribe request.\n-        if (!topicSubscriber2Channel.containsKey(topicSubscriber)) {\n+        Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n+        if (topicSubscriberChannel == null) {\n             logger.error(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n                          + subscriberId.toStringUtf8());\n             throw new ClientNotSubscribedException(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8()\n@@ -673,7 +674,6 @@ public void stopDelivery(final ByteString topic, final ByteString subscriberId)\n \n         // Unregister the MessageHandler for the subscribe Channel's\n         // Response Handler.\n-        Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n         try {\n             HedwigClientImpl.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n                 .setMessageHandler(null);\n@@ -729,10 +729,9 @@ private void doAsyncCloseSubscription(final ByteString topic, final ByteString s\n             logger.debug(\"Closing subscription asynchronously for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n                          + subscriberId.toStringUtf8());\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n-        if (topicSubscriber2Channel.containsKey(topicSubscriber)) {\n-            // Remove all cached references for the TopicSubscriber\n-            Channel channel = topicSubscriber2Channel.get(topicSubscriber);\n-            topicSubscriber2Channel.remove(topicSubscriber);\n+        // Remove all cached references for the TopicSubscriber\n+        Channel channel = topicSubscriber2Channel.remove(topicSubscriber);\n+        if (channel != null) {\n             // Close the subscribe channel asynchronously.\n             try {\n                 HedwigClientImpl.getResponseHandlerFromChannel(channel).handleChannelClosedExplicitly();\n@@ -779,6 +778,7 @@ public void setChannelAndPreferencesForTopic(TopicSubscriber topic, Channel chan\n             }\n             Channel oldc = topicSubscriber2Channel.putIfAbsent(topic, channel);\n             if (oldc != null) {\n+                logger.warn(\"Dropping new channel for \" + topic + \", due to existing channel: \" + oldc);\n                 channel.close();\n             }\n             if (null != preferences) {"},{"sha":"075705ab7fc26d075090f0b8530514fcfdd62e1f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","status":"modified","additions":11,"deletions":14,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -127,20 +127,15 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n \n         // Response is an ack to a prior PubSubRequest so first retrieve the\n         // PubSub data for this txn.\n-        PubSubData pubSubData = txn2PubSubData.containsKey(response.getTxnId()) ? txn2PubSubData.get(response\n-                                .getTxnId()) : null;\n-        // Validate that the PubSub data for this txn is stored. If not, just\n+        PubSubData pubSubData = txn2PubSubData.remove(response.getTxnId());\n+        // Validate that the PubSub data for this txn was stored. If not, just\n         // log an error message and return since we don't know how to handle\n         // this.\n         if (pubSubData == null) {\n             logger.error(\"PubSub Data was not found for PubSubResponse: \" + response);\n             return;\n         }\n \n-        // Now that we've retrieved the PubSubData for this specific Txn ID, we\n-        // can remove it from the Map.\n-        txn2PubSubData.remove(response.getTxnId());\n-\n         // Store the topic2Host mapping if this wasn't a server redirect. We'll\n         // assume that if the server was able to have an open Channel connection\n         // to the client, and responded with an ack message other than the\n@@ -242,8 +237,8 @@ public void handleRedirectResponse(PubSubResponse response, PubSubData pubSubDat\n \n         // Check if we already have a Channel open to the redirected server\n         // host.\n-        boolean redirectedHostChannelExists = pub.host2Channel.containsKey(redirectedHost) ? true : false;\n-        if (pubSubData.operationType.equals(OperationType.SUBSCRIBE) || !redirectedHostChannelExists) {\n+        Channel redirectedHostChannel = pub.host2Channel.get(redirectedHost);\n+        if (pubSubData.operationType.equals(OperationType.SUBSCRIBE) || redirectedHostChannel == null) {\n             // We don't have an existing channel to the redirected host OR this\n             // is a redirected Subscribe request. For Subscribe requests, we\n             // always want to create a new unique Channel connection to the\n@@ -254,9 +249,9 @@ public void handleRedirectResponse(PubSubResponse response, PubSubData pubSubDat\n             // request again directly on the existing cached redirected host\n             // channel.\n             if (pubSubData.operationType.equals(OperationType.PUBLISH)) {\n-                pub.doPublish(pubSubData, pub.host2Channel.get(redirectedHost));\n+                pub.doPublish(pubSubData, redirectedHostChannel);\n             } else if (pubSubData.operationType.equals(OperationType.UNSUBSCRIBE)) {\n-                sub.doSubUnsub(pubSubData, pub.host2Channel.get(redirectedHost));\n+                sub.doSubUnsub(pubSubData, redirectedHostChannel);\n             }\n         }\n     }\n@@ -295,12 +290,14 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n             // Due to race concurrency situations, it is possible to\n             // create multiple channels to the same host for publish\n             // and unsubscribe requests.\n-            if (pub.host2Channel.containsKey(host) && pub.host2Channel.get(host).equals(ctx.getChannel())) {\n+            Channel channel = pub.host2Channel.get(host);\n+            if (channel != null && channel.equals(ctx.getChannel())) {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Disconnected channel for host: \" + host\n                                  + \" was for Publish/Unsubscribe requests so remove all references to it.\");\n-                pub.host2Channel.remove(host);\n-                client.clearAllTopicsForHost(host);\n+                if (pub.host2Channel.remove(host, channel)) {\n+                    client.clearAllTopicsForHost(host);\n+                }\n             }\n         } else {\n             // Subscribe channel disconnected so first close and clear all"},{"sha":"2611bc0ffe85ca3ea7ae6e7993f576b2f2f835ed","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","status":"modified","additions":2,"deletions":9,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","raw_url":"https://github.com/apache/bookkeeper/raw/6bffc3245ae3c2f9a671a0549f394c192460217f/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java?ref=6bffc3245ae3c2f9a671a0549f394c192460217f","patch":"@@ -26,20 +26,13 @@\n     // TODO: how to release references when strings are no longer used. weak\n     // references?\n \n-    private static ConcurrentMap<ByteString, ByteString> map = new ConcurrentHashMap<ByteString, ByteString>();\n+    private static final ConcurrentMap<ByteString, ByteString> map = new ConcurrentHashMap<ByteString, ByteString>();\n \n     public static ByteString intern(ByteString in) {\n-        ByteString presentValueInMap = map.get(in);\n+        ByteString presentValueInMap = map.putIfAbsent(in, in);\n         if (presentValueInMap != null) {\n             return presentValueInMap;\n         }\n-\n-        presentValueInMap = map.putIfAbsent(in, in);\n-        if (presentValueInMap != null) {\n-            return presentValueInMap;\n-        }\n-\n         return in;\n-\n     }\n }"}]}

