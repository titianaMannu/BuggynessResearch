{"sha":"6e3b195d16ef4b24618d7bb13b3eede6b9126e74","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ZTNiMTk1ZDE2ZWY0YjI0NjE4ZDdiYjEzYjNlZWRlNmI5MTI2ZTc0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-08T18:09:49Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-08T18:09:49Z"},"message":"BOOKKEEPER-80: subscription msg queue race condition in hedwig c++ client (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1199372 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1d669ad72d40860430659a408cadfbcf4a30245f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1d669ad72d40860430659a408cadfbcf4a30245f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6e3b195d16ef4b24618d7bb13b3eede6b9126e74","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6e3b195d16ef4b24618d7bb13b3eede6b9126e74","html_url":"https://github.com/apache/bookkeeper/commit/6e3b195d16ef4b24618d7bb13b3eede6b9126e74","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"2ea2fd09f2bbbea18e183c8af8e82e81eee9fe79","url":"https://api.github.com/repos/apache/bookkeeper/commits/2ea2fd09f2bbbea18e183c8af8e82e81eee9fe79","html_url":"https://github.com/apache/bookkeeper/commit/2ea2fd09f2bbbea18e183c8af8e82e81eee9fe79"}],"stats":{"total":165,"additions":160,"deletions":5},"files":[{"sha":"95d3489d23eeda74396aec6687c0b9a468ff71c8","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=6e3b195d16ef4b24618d7bb13b3eede6b9126e74","patch":"@@ -81,6 +81,8 @@ BUGFIXES:\n   BOOKKEEPER-71: hedwig c++ client does not build . (ivank)\n \n   BOOKKEEPER-107: memory leak in HostAddress of hedwig c++ client (Sijie Guo via ivank)\n+ \n+  BOOKKEEPER-80: subscription msg queue race condition in hedwig c++ client (Sijie Guo via ivank)\n \n IMPROVEMENTS:\n "},{"sha":"e9450c826f2bfa746d6c872ec1446ef749fa8a7a","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=6e3b195d16ef4b24618d7bb13b3eede6b9126e74","patch":"@@ -155,6 +155,7 @@ SubscriberClientChannelHandler::~SubscriberClientChannelHandler() {\n \n void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) {\n   if (m->has_message()) {\n+    boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n     LOG4CXX_DEBUG(logger, \"Message received (topic:\" << origData->getTopic() << \", subscriberId:\" << origData->getSubscriberId() << \")\");\n \n     if (this->handler.get()) {\n@@ -234,8 +235,16 @@ void SubscriberClientChannelHandler::channelDisconnected(const DuplexChannelPtr&\n }\n \n void SubscriberClientChannelHandler::startDelivery(const MessageHandlerCallbackPtr& handler) {\n+  boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n+\n   this->handler = handler;\n-  \n+\n+  if (!(this->handler.get())) {\n+    // no message handler callback\n+    LOG4CXX_WARN(logger, \"Handler \" << this << \" try to start an empty message handler\");\n+    return;\n+  }\n+\n   while (!queue.empty()) {    \n     PubSubResponsePtr m = queue.front();\n     queue.pop_front();\n@@ -250,6 +259,7 @@ void SubscriberClientChannelHandler::startDelivery(const MessageHandlerCallbackP\n void SubscriberClientChannelHandler::stopDelivery() {\n   channel->stopReceiving();\n \n+  boost::lock_guard<boost::shared_mutex> lock(queue_lock);\n   this->handler = MessageHandlerCallbackPtr();\n }\n "},{"sha":"1cad98483d010011a1507abe9bee444a374be28e","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=6e3b195d16ef4b24618d7bb13b3eede6b9126e74","patch":"@@ -128,8 +128,9 @@ namespace Hedwig {\n   private:\n \n     SubscriberImpl& subscriber;\n+    boost::shared_mutex queue_lock;\n     std::deque<PubSubResponsePtr> queue;\n-    \n+\n     MessageHandlerCallbackPtr handler;\n     PubSubDataPtr origData;\n     DuplexChannelPtr channel;"},{"sha":"7008cead2640511b1e1dee2813cd86eb15ae4524","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"modified","additions":137,"deletions":1,"changes":138,"blob_url":"https://github.com/apache/bookkeeper/blob/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=6e3b195d16ef4b24618d7bb13b3eede6b9126e74","patch":"@@ -19,6 +19,8 @@\n #include <config.h>\n #endif\n \n+#include <sstream>\n+\n #include <cppunit/Test.h>\n #include <cppunit/TestSuite.h>\n #include <cppunit/extensions/HelperMacros.h>\n@@ -39,6 +41,7 @@ static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n class PubSubTestSuite : public CppUnit::TestFixture {\n private:\n   CPPUNIT_TEST_SUITE( PubSubTestSuite );\n+  CPPUNIT_TEST(testPubSubOrderChecking);\n   CPPUNIT_TEST(testPubSubContinuousOverClose);\n   //  CPPUNIT_TEST(testPubSubContinuousOverServerDown);\n   CPPUNIT_TEST(testMultiTopic);\n@@ -96,7 +99,140 @@ class PubSubTestSuite : public CppUnit::TestFixture {\n     std::string topic;\n     std::string subscriberId;\n   };\n- \n+\n+  // order checking callback\n+  class MyOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n+  public:\n+    MyOrderCheckingMessageHandlerCallback(const std::string& topic, const std::string& subscriberId, const int startMsgId, const int sleepTimeInConsume)\n+      : messagesReceived(0), topic(topic), subscriberId(subscriberId), startMsgId(startMsgId), \n+        isInOrder(true), sleepTimeInConsume(sleepTimeInConsume) {\n+    }\n+\n+    virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                         const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+      if (topic == this->topic && subscriberId == this->subscriberId) {\n+        boost::lock_guard<boost::mutex> lock(mutex);\n+            \n+        messagesReceived++;\n+\n+        int newMsgId = atoi(msg.body().c_str());\n+        // checking msgId\n+        LOG4CXX_DEBUG(logger, \"received message \" << newMsgId);\n+        if (isInOrder) {\n+          if (newMsgId != startMsgId + 1) {\n+            LOG4CXX_ERROR(logger, \"received out-of-order message : expected \" << (startMsgId + 1) << \", actual \" << newMsgId);\n+            isInOrder = false;\n+          } else {\n+            startMsgId = newMsgId;\n+          }\n+        }\n+        callback->operationComplete();\n+        sleep(sleepTimeInConsume);\n+      }\n+    }\n+    \n+    int numMessagesReceived() {\n+      boost::lock_guard<boost::mutex> lock(mutex);\n+      int i = messagesReceived;\n+      return i;\n+    }    \n+\n+    bool inOrder() {\n+      boost::lock_guard<boost::mutex> lock(mutex);\n+      return isInOrder;\n+    }\n+    \n+  protected:\n+    boost::mutex mutex;\n+    int messagesReceived;\n+    std::string topic;\n+    std::string subscriberId;\n+    int startMsgId;\n+    bool isInOrder;\n+    int sleepTimeInConsume;\n+  };\n+\n+  class PubForOrderChecking {\n+  public:\n+    PubForOrderChecking(std::string &topic, int startMsgId, int numMsgs, int sleepTime, Hedwig::Publisher &pub)\n+      : topic(topic), startMsgId(startMsgId), numMsgs(numMsgs), sleepTime(sleepTime), pub(pub) {\n+    }\n+\n+    void operator()() {\n+      for (int i=0; i<numMsgs; i++) {\n+        int msg = startMsgId + i;\n+        std::stringstream ss;\n+        ss << msg;\n+        pub.publish(topic, ss.str());\n+        sleep(sleepTime);\n+      }\n+    }\n+\n+\n+  private:\n+    std::string topic;\n+    int startMsgId;\n+    int numMsgs;\n+    int sleepTime;\n+    Hedwig::Publisher& pub;\n+  };\n+\n+  // check message ordering\n+  void testPubSubOrderChecking() {\n+    std::string topic = \"orderCheckingTopic\";\n+    std::string sid = \"mysub-0\";\n+\n+    int numMessages = 5;\n+    int sleepTimeInConsume = 1;\n+    // sync timeout\n+    int syncTimeout = 10000;\n+\n+    // in order to guarantee message order, message queue should be locked\n+    // so message received in io thread would be blocked, which also block\n+    // sent operations (publish). because we have only one io thread now\n+    // so increase sync timeout to 10s, which is more than numMessages * sleepTimeInConsume\n+    Hedwig::Configuration* conf = new TestServerConfiguration(syncTimeout);\n+    std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+    Hedwig::Subscriber& sub = client->getSubscriber();\n+    Hedwig::Publisher& pub = client->getPublisher();\n+\n+    sub.subscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+    \n+    // we don't start delivery first, so the message will be queued\n+    // publish ${numMessages} messages, so the messages will be queued\n+    for (int i=0; i<numMessages; i++) {\n+      std::stringstream ss;\n+      ss << i;\n+      pub.publish(topic, ss.str()); \n+    }\n+\n+    MyOrderCheckingMessageHandlerCallback* cb = new MyOrderCheckingMessageHandlerCallback(topic, sid, -1, sleepTimeInConsume);\n+    Hedwig::MessageHandlerCallbackPtr handler(cb);\n+\n+    // create a thread to publish another ${numMessages} messages\n+    boost::thread pubThread(PubForOrderChecking(topic, numMessages, numMessages, sleepTimeInConsume, pub));\n+\n+    // start delivery will consumed the queued messages\n+    // new message will recevied and the queued message should be consumed\n+    // hedwig should ensure the message are received in order\n+    sub.startDelivery(topic, sid, handler);\n+\n+    // wait until message are all published\n+    pubThread.join();\n+\n+    for (int i = 0; i < 10; i++) {\n+      sleep(3);\n+      if (cb->numMessagesReceived() == 2 * numMessages) {\n+        break;\n+      }\n+    }\n+    CPPUNIT_ASSERT(cb->inOrder());\n+  }\n+\n   void testPubSubContinuousOverClose() {\n     std::string topic = \"pubSubTopic\";\n     std::string sid = \"MySubscriberid-1\";"},{"sha":"6d10a5ceecb47db93a72ff262d82901945cb1c6f","filename":"hedwig-client/src/main/cpp/test/util.h","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/6e3b195d16ef4b24618d7bb13b3eede6b9126e74/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=6e3b195d16ef4b24618d7bb13b3eede6b9126e74","patch":"@@ -95,9 +95,14 @@ class TestCallback : public Hedwig::OperationCallback {\n \n class TestServerConfiguration : public Hedwig::Configuration {\n public:\n-  TestServerConfiguration() : address(\"localhost:4081\") {}\n+  TestServerConfiguration() : address(\"localhost:4081\"), syncTimeout(10000) {}\n+\n+  TestServerConfiguration(int syncTimeout) : address(\"localhost:4081\"), syncTimeout(syncTimeout) {}\n   \n-  virtual int getInt(const std::string& /*key*/, int defaultVal) const {\n+  virtual int getInt(const std::string& key, int defaultVal) const {\n+    if (key == Configuration::SYNC_REQUEST_TIMEOUT) {\n+      return syncTimeout;\n+    }\n     return defaultVal;\n   }\n \n@@ -115,6 +120,7 @@ class TestServerConfiguration : public Hedwig::Configuration {\n   \n private:\n   const std::string address;\n+  const int syncTimeout;\n };\n \n "}]}

