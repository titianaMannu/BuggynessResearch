{"sha":"6e738d0c02ebe6710a24aad505e2fd9386bb8821","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ZTczOGQwYzAyZWJlNjcxMGEyNGFhZDUwNWUyZmQ5Mzg2YmI4ODIx","commit":{"author":{"name":"Charan Reddy Guttapalem","email":"cguttapalem@salesforce.com","date":"2016-12-21T00:48:48Z"},"committer":{"name":"JV","email":"vjujjuri@salesforce.com","date":"2016-12-21T00:48:48Z"},"message":"BOOKKEEPER-986: Handle memtable flush failure\n\n- If the memtable flush is failed previously then\nfor the next addEntry call it will try to flush the\nexisting snapshot\n\nAuthor: Charan Reddy Guttapalem <cguttapalem@salesforce.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #92 from reddycharan/handlememtableflushfailure","tree":{"sha":"1868d413d75da93b57ad48616ef10b6956012f43","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1868d413d75da93b57ad48616ef10b6956012f43"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6e738d0c02ebe6710a24aad505e2fd9386bb8821","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6e738d0c02ebe6710a24aad505e2fd9386bb8821","html_url":"https://github.com/apache/bookkeeper/commit/6e738d0c02ebe6710a24aad505e2fd9386bb8821","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6e738d0c02ebe6710a24aad505e2fd9386bb8821/comments","author":{"login":"reddycharan","id":13989266,"node_id":"MDQ6VXNlcjEzOTg5MjY2","avatar_url":"https://avatars.githubusercontent.com/u/13989266?v=4","gravatar_id":"","url":"https://api.github.com/users/reddycharan","html_url":"https://github.com/reddycharan","followers_url":"https://api.github.com/users/reddycharan/followers","following_url":"https://api.github.com/users/reddycharan/following{/other_user}","gists_url":"https://api.github.com/users/reddycharan/gists{/gist_id}","starred_url":"https://api.github.com/users/reddycharan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reddycharan/subscriptions","organizations_url":"https://api.github.com/users/reddycharan/orgs","repos_url":"https://api.github.com/users/reddycharan/repos","events_url":"https://api.github.com/users/reddycharan/events{/privacy}","received_events_url":"https://api.github.com/users/reddycharan/received_events","type":"User","site_admin":false},"committer":{"login":"jvrao","id":41390,"node_id":"MDQ6VXNlcjQxMzkw","avatar_url":"https://avatars.githubusercontent.com/u/41390?v=4","gravatar_id":"","url":"https://api.github.com/users/jvrao","html_url":"https://github.com/jvrao","followers_url":"https://api.github.com/users/jvrao/followers","following_url":"https://api.github.com/users/jvrao/following{/other_user}","gists_url":"https://api.github.com/users/jvrao/gists{/gist_id}","starred_url":"https://api.github.com/users/jvrao/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jvrao/subscriptions","organizations_url":"https://api.github.com/users/jvrao/orgs","repos_url":"https://api.github.com/users/jvrao/repos","events_url":"https://api.github.com/users/jvrao/events{/privacy}","received_events_url":"https://api.github.com/users/jvrao/received_events","type":"User","site_admin":false},"parents":[{"sha":"9a506c261d3702ddd3f39556f4331b91da952a6e","url":"https://api.github.com/repos/apache/bookkeeper/commits/9a506c261d3702ddd3f39556f4331b91da952a6e","html_url":"https://github.com/apache/bookkeeper/commit/9a506c261d3702ddd3f39556f4331b91da952a6e"}],"stats":{"total":124,"additions":116,"deletions":8},"files":[{"sha":"ff14d039034fd0006a00610f6eb61fe8bdafbdb4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","status":"modified","additions":26,"deletions":7,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/6e738d0c02ebe6710a24aad505e2fd9386bb8821/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/6e738d0c02ebe6710a24aad505e2fd9386bb8821/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java?ref=6e738d0c02ebe6710a24aad505e2fd9386bb8821","patch":"@@ -23,6 +23,7 @@\n \n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.concurrent.ConcurrentSkipListMap;\n@@ -106,6 +107,9 @@ public boolean equals(Object o) {\n     final long skipListSizeLimit;\n \n     SkipListArena allocator;\n+    \n+    // flag indicating the status of the previous flush call\n+    private final AtomicBoolean previousFlushSucceeded;\n \n     private EntrySkipList newSkipList() {\n         return new EntrySkipList(checkpointSource.newCheckpoint());\n@@ -130,6 +134,7 @@ public EntryMemTable(final ServerConfiguration conf, final CheckpointSource sour\n         this.conf = conf;\n         this.size = new AtomicLong(0);\n         this.allocator = new SkipListArena(conf);\n+        this.previousFlushSucceeded = new AtomicBoolean(true);\n         // skip list size limit\n         this.skipListSizeLimit = conf.getSkipListSizeLimit();\n \n@@ -199,7 +204,14 @@ Checkpoint snapshot(Checkpoint oldCp) throws IOException {\n      * Flush snapshot and clear it.\n      */\n     long flush(final SkipListFlusher flusher) throws IOException {\n-        return flushSnapshot(flusher, Checkpoint.MAX);\n+        try {\n+            long flushSize = flushSnapshot(flusher, Checkpoint.MAX);\n+            previousFlushSucceeded.set(true);\n+            return flushSize;\n+        } catch (IOException ioe) {\n+            previousFlushSucceeded.set(false);\n+            throw ioe;\n+        }\n     }\n \n     /**\n@@ -209,11 +221,17 @@ long flush(final SkipListFlusher flusher) throws IOException {\n      *          all data before this checkpoint need to be flushed.\n      */\n     public long flush(SkipListFlusher flusher, Checkpoint checkpoint) throws IOException {\n-        long size = flushSnapshot(flusher, checkpoint);\n-        if (null != snapshot(checkpoint)) {\n-            size += flushSnapshot(flusher, checkpoint);\n+        try {\n+            long size = flushSnapshot(flusher, checkpoint);\n+            if (null != snapshot(checkpoint)) {\n+                size += flushSnapshot(flusher, checkpoint);\n+            }\n+            previousFlushSucceeded.set(true);\n+            return size;\n+        } catch (IOException ioe) {\n+            previousFlushSucceeded.set(false);\n+            throw ioe;\n         }\n-        return size;\n     }\n \n     /**\n@@ -282,16 +300,17 @@ private void throttleWriters() {\n     * Write an update\n     * @param entry\n     * @return approximate size of the passed key and value.\n+     * @throws IOException \n     */\n     public long addEntry(long ledgerId, long entryId, final ByteBuffer entry, final CacheCallback cb)\n             throws IOException {\n         long size = 0;\n         long startTimeNanos = MathUtils.nowInNano();\n         boolean success = false;\n         try {\n-            if (isSizeLimitReached()) {\n+            if (isSizeLimitReached() || (!previousFlushSucceeded.get())) {\n                 Checkpoint cp = snapshot();\n-                if (null != cp) {\n+                if ((null != cp) || (!previousFlushSucceeded.get())) {\n                     cb.onSizeLimitReached();\n                 } else {\n                     throttleWriters();"},{"sha":"27fb5f7cac0354e1a1a21f7a4d09bea518e1c19c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/6e738d0c02ebe6710a24aad505e2fd9386bb8821/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/6e738d0c02ebe6710a24aad505e2fd9386bb8821/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java?ref=6e738d0c02ebe6710a24aad505e2fd9386bb8821","patch":"@@ -39,7 +39,7 @@\n         implements LedgerStorage, CacheCallback, SkipListFlusher {\n     private final static Logger LOG = LoggerFactory.getLogger(SortedLedgerStorage.class);\n \n-    private EntryMemTable memTable;\n+    EntryMemTable memTable;\n     private ScheduledExecutorService scheduler;\n \n     public SortedLedgerStorage() {"},{"sha":"b63806e0400e53cdb9a086c97b750b14792e6d56","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/6e738d0c02ebe6710a24aad505e2fd9386bb8821/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/6e738d0c02ebe6710a24aad505e2fd9386bb8821/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=6e738d0c02ebe6710a24aad505e2fd9386bb8821","patch":"@@ -28,10 +28,14 @@\n import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.SnapshotMap;\n import org.apache.bookkeeper.util.IOUtils;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.ArrayList;\n@@ -447,6 +451,91 @@ public void run() {\n         flushThread.interrupt();\n     }\n \n+    // Mock SortedLedgerStorage to simulate flush failure (Dependency Fault Injection)\n+    static class FlushTestSortedLedgerStorage extends SortedLedgerStorage {\n+        final AtomicBoolean injectMemTableSizeLimitReached;\n+        final AtomicBoolean injectFlushException;\n+\n+        public FlushTestSortedLedgerStorage() {\n+            super();\n+            injectMemTableSizeLimitReached = new AtomicBoolean();\n+            injectFlushException = new AtomicBoolean();\n+        }\n+\n+        public void setInjectMemTableSizeLimitReached(boolean setValue) {\n+            injectMemTableSizeLimitReached.set(setValue);\n+        }\n+\n+        public void setInjectFlushException(boolean setValue) {\n+            injectFlushException.set(setValue);\n+        }\n+\n+        @Override\n+        public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n+                LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n+                final CheckpointSource checkpointSource, StatsLogger statsLogger) throws IOException {\n+            super.initialize(conf, ledgerManager, ledgerDirsManager, indexDirsManager, checkpointSource, statsLogger);\n+            this.memTable = new EntryMemTable(conf, checkpointSource, statsLogger) {\n+                @Override\n+                boolean isSizeLimitReached() {\n+                    return (injectMemTableSizeLimitReached.get() || super.isSizeLimitReached());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public void process(long ledgerId, long entryId, ByteBuffer buffer) throws IOException {\n+            if (injectFlushException.get()) {\n+                throw new IOException(\"Injected Exception\");\n+            }\n+            super.process(ledgerId, entryId, buffer);\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEntryMemTableFlushFailure() throws Exception {\n+        File tmpDir = createTempDir(\"bkTest\", \".dir\");\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+\n+        int gcWaitTime = 1000;\n+        ServerConfiguration conf = TestBKConfiguration.newServerConfiguration();\n+        conf.setGcWaitTime(gcWaitTime);\n+        conf.setLedgerDirNames(new String[] { tmpDir.toString() });\n+        conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName());\n+\n+        Bookie bookie = new Bookie(conf);\n+        FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage;\n+        EntryMemTable memTable = flushTestSortedLedgerStorage.memTable;\n+\n+        // this bookie.addEntry call is required. FileInfo for Ledger 1 would be created with this call.\n+        // without the fileinfo, 'flushTestSortedLedgerStorage.addEntry' calls will fail because of BOOKKEEPER-965 change.\n+        bookie.addEntry(generateEntry(1, 1), new Bookie.NopWriteCallback(), null, \"passwd\".getBytes());\n+        \n+        flushTestSortedLedgerStorage.addEntry(generateEntry(1, 2));\n+        assertFalse(\"Bookie is expected to be in ReadWrite mode\", bookie.isReadOnly());\n+        assertTrue(\"EntryMemTable SnapShot is expected to be empty\", memTable.snapshot.isEmpty());\n+\n+        // set flags, so that FlushTestSortedLedgerStorage simulates FlushFailure scenario\n+        flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true);\n+        flushTestSortedLedgerStorage.setInjectFlushException(true);\n+        flushTestSortedLedgerStorage.addEntry(generateEntry(1, 2));\n+        Thread.sleep(1000);\n+\n+        // since we simulated sizeLimitReached, snapshot shouldn't be empty\n+        assertFalse(\"EntryMemTable SnapShot is not expected to be empty\", memTable.snapshot.isEmpty());\n+\n+        // set the flags to false, so flush will succeed this time\n+        flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(false);\n+        flushTestSortedLedgerStorage.setInjectFlushException(false);\n+\n+        flushTestSortedLedgerStorage.addEntry(generateEntry(1, 3));\n+        Thread.sleep(1000);\n+        // since we expect memtable flush to succeed, memtable snapshot should be empty\n+        assertTrue(\"EntryMemTable SnapShot is expected to be empty, because of successful flush\",\n+                memTable.snapshot.isEmpty());\n+    }\n+    \n     private ByteBuffer generateEntry(long ledger, long entry) {\n         byte[] data = (\"ledger-\" + ledger + \"-\" + entry).getBytes();\n         ByteBuffer bb = ByteBuffer.wrap(new byte[8 + 8 + data.length]);"}]}

