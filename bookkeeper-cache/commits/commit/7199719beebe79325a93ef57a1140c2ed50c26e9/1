{"sha":"7199719beebe79325a93ef57a1140c2ed50c26e9","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3MTk5NzE5YmVlYmU3OTMyNWE5M2VmNTdhMTE0MGMyZWQ1MGMyNmU5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T13:09:07Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T13:09:07Z"},"message":"BOOKKEEPER-175: Bookie code is very coupled (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1302870 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"40f6b80b9f4f9d7dfe5a6f4063ae733c1394b94e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/40f6b80b9f4f9d7dfe5a6f4063ae733c1394b94e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7199719beebe79325a93ef57a1140c2ed50c26e9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7199719beebe79325a93ef57a1140c2ed50c26e9","html_url":"https://github.com/apache/bookkeeper/commit/7199719beebe79325a93ef57a1140c2ed50c26e9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7199719beebe79325a93ef57a1140c2ed50c26e9/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"841e7dc187b17e6cf4c437fc211f9e285191dd7c","url":"https://api.github.com/repos/apache/bookkeeper/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c","html_url":"https://github.com/apache/bookkeeper/commit/841e7dc187b17e6cf4c437fc211f9e285191dd7c"}],"stats":{"total":532,"additions":333,"deletions":199},"files":[{"sha":"be2da39f5be3630f2ee025cee7d96745c38ee8e8","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -92,6 +92,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-187: Create well defined interface for LedgerCache (ivank)\n \n+        BOOKKEEPER-175: Bookie code is very coupled (ivank)\n+\n       hedwig-server/\n \n         BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)"},{"sha":"ad41ba5334081b076b1505cb6e1b3cdbf8b45e41","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":43,"deletions":90,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -39,6 +39,7 @@\n import java.nio.channels.FileChannel;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Map;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -67,7 +68,6 @@\n  */\n \n public class Bookie extends Thread {\n-    HashMap<Long, LedgerDescriptor> ledgers = new HashMap<Long, LedgerDescriptor>();\n     static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n \n     final static long MB = 1024 * 1024L;\n@@ -84,6 +84,7 @@\n \n     final SyncThread syncThread;\n     final LedgerManager ledgerManager;\n+    final HandleFactory handles;\n \n     static final long METAENTRY_ID_LEDGER_KEY = -0x1000;\n \n@@ -106,6 +107,8 @@\n     BookieBean jmxBookieBean;\n     LedgerCacheBean jmxLedgerCacheBean;\n \n+    Map<Long, byte[]> masterKeyCache = Collections.synchronizedMap(new HashMap<Long, byte[]>());\n+\n     public static class NoLedgerException extends IOException {\n         private static final long serialVersionUID = 1L;\n         private long ledgerId;\n@@ -402,8 +405,9 @@ public Bookie(ServerConfiguration conf)\n         entryLogger = new EntryLogger(conf);\n         ledgerCache = new LedgerCacheImpl(conf, ledgerManager);\n         gcThread = new GarbageCollectorThread(conf, this.zk, ledgerCache, entryLogger,\n-                                              ledgerManager,\n-                                              new EntryLogCompactionScanner());\n+                ledgerManager, new EntryLogCompactionScanner());\n+        handles = new HandleFactoryImpl(entryLogger, ledgerCache);\n+\n         // replay journals\n         readJournal();\n     }\n@@ -471,29 +475,29 @@ public boolean accept(long journalId) {\n                 recBuff.flip();\n                 long ledgerId = recBuff.getLong();\n                 long entryId = recBuff.getLong();\n-                LedgerDescriptor handle;\n                 try {\n-                    handle = getHandle(ledgerId);\n-                    LOG.debug(\"Relay journal - ledger id : {}, entry id : {}.\", ledgerId, entryId);\n+                    LOG.debug(\"Replay journal - ledger id : {}, entry id : {}.\", ledgerId, entryId);\n                     if (entryId == METAENTRY_ID_LEDGER_KEY) {\n                         if (recLog.getFormatVersion() >= 3) {\n                             int masterKeyLen = recBuff.getInt();\n                             byte[] masterKey = new byte[masterKeyLen];\n+\n                             recBuff.get(masterKey);\n-                            handle.checkAccess(masterKey);\n-                            putHandle(handle);\n+                            masterKeyCache.put(ledgerId, masterKey);\n                         } else {\n                             throw new IOException(\"Invalid journal. Contains journalKey \"\n                                     + \" but layout version (\" + recLog.getFormatVersion()\n                                     + \") is too old to hold this\");\n                         }\n                     } else {\n-                        try {\n-                            recBuff.rewind();\n-                            handle.addEntry(recBuff);\n-                        } finally {\n-                            putHandle(handle);\n+                        byte[] key = masterKeyCache.get(ledgerId);\n+                        if (key == null) {\n+                            key = ledgerCache.readMasterKey(ledgerId);\n                         }\n+                        LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n+\n+                        recBuff.rewind();\n+                        handle.addEntry(recBuff);\n                     }\n                 } catch (NoLedgerException nsle) {\n                     LOG.debug(\"Skip replaying entries of ledger {} since it was deleted.\", ledgerId);\n@@ -697,46 +701,6 @@ private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException\n         }\n         return total;\n     }\n-    private void putHandle(LedgerDescriptor handle) {\n-        synchronized (ledgers) {\n-            handle.decRef();\n-        }\n-    }\n-\n-    private LedgerDescriptor getHandle(long ledgerId, boolean readonly, byte[] masterKey) \n-            throws IOException, BookieException {\n-        LedgerDescriptor handle = null;\n-        synchronized (ledgers) {\n-            handle = ledgers.get(ledgerId);\n-            if (handle == null) {\n-                if (readonly) {\n-                    throw new NoLedgerException(ledgerId);\n-                }\n-                handle = createHandle(ledgerId);\n-                ledgers.put(ledgerId, handle);\n-            }\n-            handle.checkAccess(masterKey);\n-            handle.incRef();\n-        }\n-        return handle;\n-    }\n-\n-    private LedgerDescriptor getHandle(long ledgerId) throws IOException {\n-        LedgerDescriptor handle = null;\n-        synchronized (ledgers) {\n-            handle = ledgers.get(ledgerId);\n-            if (handle == null) {\n-                handle = createHandle(ledgerId);\n-                ledgers.put(ledgerId, handle);\n-            }\n-            handle.incRef();\n-        }\n-        return handle;\n-    }\n-\n-    private LedgerDescriptor createHandle(long ledgerId) throws IOException {\n-        return new LedgerDescriptor(ledgerId, entryLogger, ledgerCache);\n-    }\n \n     static class QueueEntry {\n         QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n@@ -970,9 +934,7 @@ synchronized int shutdown(int exitCode) {\n                 this.interrupt();\n                 this.join();\n                 syncThread.shutdown();\n-                for(LedgerDescriptor d: ledgers.values()) {\n-                    d.close();\n-                }\n+\n                 // Shutdown the EntryLogger which has the GarbageCollector Thread running\n                 entryLogger.shutdown();\n                 // close Ledger Manager\n@@ -996,8 +958,8 @@ synchronized int shutdown(int exitCode) {\n     private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey) \n             throws IOException, BookieException {\n         long ledgerId = entry.getLong();\n-        LedgerDescriptor l = getHandle(ledgerId, false, masterKey);\n-        if (!l.isMasterKeyPersisted()) {\n+        LedgerDescriptor l = handles.getHandle(ledgerId, masterKey);\n+        if (!masterKeyCache.containsKey(ledgerId)) {\n             // new handle, we should add the key to journal ensure we can rebuild\n             ByteBuffer bb = ByteBuffer.allocate(8 + 8 + 4 + masterKey.length);\n             bb.putLong(ledgerId);\n@@ -1015,19 +977,16 @@ public void writeComplete(int rc, long ledgerId,\n                                              // do nothing\n                                          }\n                                      }, null));\n-            l.setMasterKeyPersisted();\n+            masterKeyCache.put(ledgerId, masterKey);\n         }\n         return l;\n     }\n \n     protected void addEntryByLedgerId(long ledgerId, ByteBuffer entry)\n         throws IOException, BookieException {\n-        LedgerDescriptor handle = getHandle(ledgerId);\n-        try {\n-            handle.addEntry(entry);\n-        } finally {\n-            putHandle(handle);\n-        }\n+        byte[] key = ledgerCache.readMasterKey(ledgerId);\n+        LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n+        handle.addEntry(entry);\n     }\n \n     /**\n@@ -1056,11 +1015,7 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n             throws IOException, BookieException {\n         LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n         synchronized (handle) {\n-            try {\n-                addEntryInternal(handle, entry, cb, ctx);\n-            } finally {\n-                putHandle(handle);\n-            }\n+            addEntryInternal(handle, entry, cb, ctx);\n         }\n     }\n     \n@@ -1072,15 +1027,11 @@ public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] mast\n             throws IOException, BookieException {\n         LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n         synchronized (handle) {\n-            try {\n-                if (handle.isFenced()) {\n-                    throw BookieException.create(BookieException.Code.LedgerFencedException);\n-                }\n-                \n-                addEntryInternal(handle, entry, cb, ctx);\n-            } finally {\n-                putHandle(handle);\n+            if (handle.isFenced()) {\n+                throw BookieException.create(BookieException.Code.LedgerFencedException);\n             }\n+\n+            addEntryInternal(handle, entry, cb, ctx);\n         }\n     }\n \n@@ -1092,22 +1043,24 @@ public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] mast\n      * never be unfenced. Fencing a fenced ledger has no effect.\n      */\n     public void fenceLedger(long ledgerId) throws IOException {\n-        LedgerDescriptor handle = getHandle(ledgerId);\n-        synchronized (handle) {\n-            handle.setFenced();\n+        try {\n+            byte[] key = ledgerCache.readMasterKey(ledgerId);\n+            LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n+            synchronized (handle) {\n+                handle.setFenced();\n+            }\n+        } catch (BookieException e) {\n+            throw new IOException(\"Error fencing\", e);\n         }\n     }\n \n-    public ByteBuffer readEntry(long ledgerId, long entryId) throws IOException {\n-        LedgerDescriptor handle = getHandle(ledgerId);\n-        try {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Reading \" + entryId + \"@\" + ledgerId);\n-            }\n-            return handle.readEntry(entryId);\n-        } finally {\n-            putHandle(handle);\n+    public ByteBuffer readEntry(long ledgerId, long entryId)\n+            throws IOException, NoLedgerException {\n+        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Reading \" + entryId + \"@\" + ledgerId);\n         }\n+        return handle.readEntry(entryId);\n     }\n \n     // The rest of the code is test stuff"},{"sha":"ee5f8f81eedf737a0b1736a5d6b0f9d7bb9c83e1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -0,0 +1,32 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+\n+interface HandleFactory {\n+    LedgerDescriptor getHandle(long ledgerId, byte[] masterKey)\n+            throws IOException, BookieException;\n+\n+    LedgerDescriptor getReadOnlyHandle(long ledgerId)\n+            throws IOException, Bookie.NoLedgerException;\n+}\n\\ No newline at end of file"},{"sha":"c240682de8ce69f8f40226032f966f0018d5c370","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -0,0 +1,69 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+\n+class HandleFactoryImpl implements HandleFactory {\n+    HashMap<Long, LedgerDescriptor> ledgers = new HashMap<Long, LedgerDescriptor>();\n+    HashMap<Long, LedgerDescriptor> readOnlyLedgers\n+        = new HashMap<Long, LedgerDescriptor>();\n+\n+    final EntryLogger entryLogger;\n+    final LedgerCache ledgerCache;\n+\n+    HandleFactoryImpl(EntryLogger entryLogger, LedgerCache ledgerCache) {\n+        this.entryLogger = entryLogger;\n+        this.ledgerCache = ledgerCache;\n+    }\n+\n+    @Override\n+    public LedgerDescriptor getHandle(long ledgerId, byte[] masterKey)\n+            throws IOException, BookieException {\n+        LedgerDescriptor handle = null;\n+        synchronized (ledgers) {\n+            handle = ledgers.get(ledgerId);\n+            if (handle == null) {\n+                handle = LedgerDescriptor.create(masterKey, ledgerId,\n+                                                 entryLogger, ledgerCache);\n+                ledgers.put(ledgerId, handle);\n+            }\n+            handle.checkAccess(masterKey);\n+        }\n+        return handle;\n+    }\n+\n+    @Override\n+    public LedgerDescriptor getReadOnlyHandle(long ledgerId)\n+            throws IOException, Bookie.NoLedgerException {\n+        LedgerDescriptor handle = null;\n+        synchronized (ledgers) {\n+            handle = readOnlyLedgers.get(ledgerId);\n+            if (handle == null) {\n+                handle = LedgerDescriptor.createReadOnly(ledgerId, entryLogger, ledgerCache);\n+                readOnlyLedgers.put(ledgerId, handle);\n+            }\n+        }\n+        return handle;\n+    }\n+}\n\\ No newline at end of file"},{"sha":"1e464df2fd306fcded82c46ca9e7b50372bac76e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":21,"deletions":109,"changes":130,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -28,125 +28,37 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-\n-\n /**\n  * Implements a ledger inside a bookie. In particular, it implements operations\n  * to write entries to a ledger and read entries from a ledger.\n- *\n  */\n-public class LedgerDescriptor {\n-    final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n-    LedgerCacheImpl ledgerCache;\n-    LedgerDescriptor(long ledgerId, EntryLogger entryLogger, LedgerCache ledgerCache) {\n-        this.ledgerId = ledgerId;\n-        this.entryLogger = entryLogger;\n-        // This cast is only here until ledgerDescriptor changes go in to make it\n-        // unnecessary\n-        this.ledgerCache = (LedgerCacheImpl)ledgerCache;\n+public abstract class LedgerDescriptor {\n+    static LedgerDescriptor create(byte[] masterKey,\n+                                   long ledgerId,\n+                                   EntryLogger entryLogger,\n+                                   LedgerCache ledgerCache) throws IOException {\n+        LedgerDescriptor ledger = new LedgerDescriptorImpl(masterKey, ledgerId, entryLogger, ledgerCache);\n+        ledgerCache.setMasterKey(ledgerId, masterKey);\n+        return ledger;\n     }\n \n-    private byte[] masterKey = null;\n-    volatile private boolean fenced = false;\n-    private boolean masterKeyPersisted = false;\n-\n-    synchronized boolean isMasterKeyPersisted() {\n-        if (masterKeyPersisted) {\n-            return true;\n-        }\n-\n-        try {\n-            FileInfo fi = ledgerCache.getFileInfo(ledgerId, masterKey);\n-            fi.readHeader();\n-            masterKeyPersisted = true;\n-            return true;\n-        } catch (IOException ioe) {\n-            return false;\n+    static LedgerDescriptor createReadOnly(long ledgerId,\n+                                           EntryLogger entryLogger,\n+                                           LedgerCache ledgerCache)\n+            throws IOException, Bookie.NoLedgerException {\n+        if (!ledgerCache.ledgerExists(ledgerId)) {\n+            throw new Bookie.NoLedgerException(ledgerId);\n         }\n+        return new LedgerDescriptorReadOnlyImpl(ledgerId, entryLogger, ledgerCache);\n     }\n \n-    void setMasterKeyPersisted() {\n-        masterKeyPersisted = true;\n-    }\n+    abstract void checkAccess(byte masterKey[]) throws BookieException, IOException;\n \n-    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n-        if (this.masterKey == null) {\n-            FileInfo fi = ledgerCache.getFileInfo(ledgerId, masterKey);\n-            try {\n-                if (fi == null) {\n-                    throw new IOException(ledgerId + \" does not exist\");\n-                }\n-                this.masterKey = fi.getMasterKey();\n-            } finally {\n-                fi.release();\n-            }\n-        }\n-        if (!Arrays.equals(this.masterKey, masterKey)) {\n-            throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n-        }\n-    } \n+    abstract long getLedgerId();\n \n-    private long ledgerId;\n-    public long getLedgerId() {\n-        return ledgerId;\n-    }\n+    abstract void setFenced() throws IOException;\n+    abstract boolean isFenced();\n \n-    EntryLogger entryLogger;\n-    private int refCnt;\n-    synchronized public void incRef() {\n-        refCnt++;\n-    }\n-    synchronized public void decRef() {\n-        refCnt--;\n-    }\n-    synchronized public int getRefCnt() {\n-        return refCnt;\n-    }\n-    \n-    void setFenced() {\n-        fenced = true;\n-    }\n-    \n-    boolean isFenced() {\n-        return fenced;\n-    }\n-\n-    long addEntry(ByteBuffer entry) throws IOException {\n-        long ledgerId = entry.getLong();\n-\n-        if (ledgerId != this.ledgerId) {\n-            throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n-        }\n-        long entryId = entry.getLong();\n-        entry.rewind();\n-\n-        /*\n-         * Log the entry\n-         */\n-        long pos = entryLogger.addEntry(ledgerId, entry);\n-\n-\n-        /*\n-         * Set offset of entry id to be the current ledger position\n-         */\n-        ledgerCache.putEntryOffset(ledgerId, entryId, pos);\n-        return entryId;\n-    }\n-    ByteBuffer readEntry(long entryId) throws IOException {\n-        long offset;\n-        /*\n-         * If entryId is -1, then return the last written.\n-         */\n-        if (entryId == -1) {\n-            entryId = ledgerCache.getLastEntry(ledgerId);\n-        }\n-\n-        offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n-        if (offset == 0) {\n-            throw new Bookie.NoEntryException(ledgerId, entryId);\n-        }\n-        return ByteBuffer.wrap(entryLogger.readEntry(ledgerId, entryId, offset));\n-    }\n-    void close() {\n-    }\n+    abstract long addEntry(ByteBuffer entry) throws IOException;\n+    abstract ByteBuffer readEntry(long entryId) throws IOException;\n }"},{"sha":"f79b43253dd8a25a0121316ed2cac234bba26e6a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -0,0 +1,113 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements a ledger inside a bookie. In particular, it implements operations\n+ * to write entries to a ledger and read entries from a ledger.\n+ *\n+ */\n+public class LedgerDescriptorImpl extends LedgerDescriptor {\n+    final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n+    LedgerCache ledgerCache;\n+    private long ledgerId;\n+    EntryLogger entryLogger;\n+\n+    volatile private boolean fenced = false;\n+    final byte[] masterKey;\n+\n+    LedgerDescriptorImpl(byte[] masterKey, long ledgerId, EntryLogger entryLogger, LedgerCache ledgerCache) {\n+        this.masterKey = masterKey;\n+        this.ledgerId = ledgerId;\n+        this.entryLogger = entryLogger;\n+        this.ledgerCache = ledgerCache;\n+    }\n+\n+    @Override\n+    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n+        if (!Arrays.equals(this.masterKey, masterKey)) {\n+            throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+        }\n+    }\n+\n+    @Override\n+    public long getLedgerId() {\n+        return ledgerId;\n+    }\n+\n+    @Override\n+    void setFenced() throws IOException {\n+        fenced = true;\n+    }\n+\n+    @Override\n+    boolean isFenced() {\n+        return fenced;\n+    }\n+\n+    @Override\n+    long addEntry(ByteBuffer entry) throws IOException {\n+        long ledgerId = entry.getLong();\n+\n+        if (ledgerId != this.ledgerId) {\n+            throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n+        }\n+        long entryId = entry.getLong();\n+        entry.rewind();\n+\n+        /*\n+         * Log the entry\n+         */\n+        long pos = entryLogger.addEntry(ledgerId, entry);\n+\n+\n+        /*\n+         * Set offset of entry id to be the current ledger position\n+         */\n+        ledgerCache.putEntryOffset(ledgerId, entryId, pos);\n+        return entryId;\n+    }\n+\n+    @Override\n+    ByteBuffer readEntry(long entryId) throws IOException {\n+        long offset;\n+        /*\n+         * If entryId is -1, then return the last written.\n+         */\n+        if (entryId == -1) {\n+            entryId = ledgerCache.getLastEntry(ledgerId);\n+        }\n+\n+        offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n+        if (offset == 0) {\n+            throw new Bookie.NoEntryException(ledgerId, entryId);\n+        }\n+        return ByteBuffer.wrap(entryLogger.readEntry(ledgerId, entryId, offset));\n+    }\n+}"},{"sha":"bda0b5902a9bf5e9c532959ca2d0c585ac068f83","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/7199719beebe79325a93ef57a1140c2ed50c26e9/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java?ref=7199719beebe79325a93ef57a1140c2ed50c26e9","patch":"@@ -0,0 +1,53 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+/**\n+ * Implements a ledger inside a bookie. In particular, it implements operations\n+ * to write entries to a ledger and read entries from a ledger.\n+ */\n+public class LedgerDescriptorReadOnlyImpl extends LedgerDescriptorImpl {\n+    LedgerDescriptorReadOnlyImpl(long ledgerId, EntryLogger entryLogger,\n+            LedgerCache ledgerCache) {\n+        super(null, ledgerId, entryLogger, ledgerCache);\n+    }\n+\n+    @Override\n+    void setFenced() throws IOException {\n+        assert false;\n+        throw new IOException(\"Invalid action on read only descriptor\");\n+    }\n+\n+    @Override\n+    long addEntry(ByteBuffer entry) throws IOException {\n+        assert false;\n+        throw new IOException(\"Invalid action on read only descriptor\");\n+    }\n+\n+    @Override\n+    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n+        assert false;\n+        throw new IOException(\"Invalid action on read only descriptor\");\n+    }\n+}"}]}

