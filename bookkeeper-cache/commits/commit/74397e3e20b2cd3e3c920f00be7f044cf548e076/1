{"sha":"74397e3e20b2cd3e3c920f00be7f044cf548e076","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3NDM5N2UzZTIwYjJjZDNlM2M5MjBmMDBiZTdmMDQ0Y2Y1NDhlMDc2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-07-28T18:33:52Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-07-28T18:33:52Z"},"message":"BOOKKEEPER-11: Read from open ledger (fpj via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1151958 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"afd8c973c666e86d37806854186c9984e4c2a421","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/afd8c973c666e86d37806854186c9984e4c2a421"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/74397e3e20b2cd3e3c920f00be7f044cf548e076","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/74397e3e20b2cd3e3c920f00be7f044cf548e076","html_url":"https://github.com/apache/bookkeeper/commit/74397e3e20b2cd3e3c920f00be7f044cf548e076","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/74397e3e20b2cd3e3c920f00be7f044cf548e076/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"45aeb04735d120d3aa9a0110becf3ba2d7ef6afc","url":"https://api.github.com/repos/apache/bookkeeper/commits/45aeb04735d120d3aa9a0110becf3ba2d7ef6afc","html_url":"https://github.com/apache/bookkeeper/commit/45aeb04735d120d3aa9a0110becf3ba2d7ef6afc"}],"stats":{"total":512,"additions":487,"deletions":25},"files":[{"sha":"0ba4a9cc3e8b4f122fcffb986d8d0c024c51d7c9","filename":"CHANGES.txt","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -20,3 +20,4 @@ BUGFIXES:\n \n   BOOKKEEPER-30: Test are too noisy (ivank via fpj)\n \n+  BOOKKEEPER-11: Read from open ledger (fpj via ivank)"},{"sha":"4e6dda113144274a789cef382223ddc18b7eb861","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -122,5 +122,18 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n        */\n       void recoverComplete(int rc, Object ctx);\n     }\n+  \n+  public interface ReadLastConfirmedCallback {\n+      /**\n+       * Callback definition for bookie recover operations\n+       * \n+       * @param rc\n+       *          return code\n+       * @param ctx\n+       *          control object\n+       */\n+      void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n+    }\n+  \n \n }"},{"sha":"f5640b566bdf6e5afb65041993bd5f0a9086c685","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":60,"deletions":1,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -283,10 +283,35 @@ public LedgerHandle createLedger(int ensSize, int qSize,\n   public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n       OpenCallback cb, Object ctx) {\n \n-    new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiate();\n+      new LedgerOpenOp(this, lId, digestType, passwd, false, cb, ctx).initiate();\n \n   }\n \n+  /**\n+   * Open existing ledger asynchronously for reading, but it does not try to\n+   * recover the ledger if it is not yet closed. The application needs to use\n+   * it carefully, since the writer might have crash and ledger will remain \n+   * unsealed forever if there is no external mechanism to detect the failure \n+   * of the writer and the ledger is not open in a safe manner, invoking the\n+   * recovery procedure.\n+   * \n+   * @param lId\n+   *          ledger identifier\n+   * @param digestType\n+   *          digest type, either MAC or CRC32\n+   * @param passwd\n+   *          password\n+   * @param ctx\n+   *          optional control object\n+   */\n+  \n+  public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte passwd[],\n+          OpenCallback cb, Object ctx) {\n+\n+      new LedgerOpenOp(this, lId, digestType, passwd, true, cb, ctx).initiate();\n+\n+  }\n+  \n   /**\n    * Callback method for synchronous open operation\n    * \n@@ -341,6 +366,40 @@ public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n     return counter.getLh();\n   }\n \n+  /**\n+   * Synchronous, unsafe open ledger call\n+   * \n+   * @param lId\n+   *          ledger identifier\n+   * @param digestType\n+   *          digest type, either MAC or CRC32\n+   * @param passwd\n+   *          password\n+   * @return\n+   * @throws InterruptedException\n+   * @throws BKException\n+   */\n+\n+  public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte passwd[])\n+  throws BKException, InterruptedException {\n+      SyncCounter counter = new SyncCounter();\n+      counter.inc();\n+\n+      /*\n+       * Calls async open ledger\n+       */\n+      asyncOpenLedgerNoRecovery(lId, digestType, passwd, this, counter);\n+\n+      /*\n+       * Wait\n+       */\n+      counter.block(0);\n+      if (counter.getrc() != BKException.Code.OK)\n+          throw BKException.create(counter.getrc());\n+\n+      return counter.getLh();\n+  }\n+  \n   /**\n    * Deletes a ledger asynchronously.\n    * "},{"sha":"905512abce395c5b0f11d41334358dafd07063fd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":77,"deletions":2,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -29,6 +29,7 @@\n import java.util.Queue;\n import java.util.concurrent.Semaphore;\n \n+import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n@@ -51,9 +52,10 @@\n  * Ledger handle contains ledger metadata and is used to access the read and\n  * write operations to a ledger.\n  */\n-public class LedgerHandle implements ReadCallback, AddCallback, CloseCallback {\n+public class LedgerHandle implements ReadCallback, AddCallback, CloseCallback, ReadLastConfirmedCallback {\n   final static Logger LOG = Logger.getLogger(LedgerHandle.class);\n-\n+  final static long LAST_ADD_CONFIRMED = -1;\n+  \n   final byte[] ledgerKey;\n   final LedgerMetadata metadata;\n   final BookKeeper bk;\n@@ -381,6 +383,64 @@ public void safeRun() {\n       }\n   }\n \n+  /**\n+   * Obtains last confirmed write from a quorum of bookies.\n+   * \n+   * @param cb\n+   * @param ctx\n+   */\n+  \n+  public void asyncReadLastConfirmed(ReadLastConfirmedCallback cb, Object ctx){\n+      new ReadLastConfirmedOp(this, cb, ctx).initiate();\n+  }\n+  \n+  \n+  /**\n+   * Context objects for synchronous call to read last confirmed. \n+   */\n+  class LastConfirmedCtx {\n+      long response;\n+      int rc;\n+      \n+      LastConfirmedCtx(){\n+          this.response = -1;\n+      }\n+      \n+      void setLastConfirmed(long lastConfirmed){\n+          this.response = lastConfirmed;\n+      }\n+      \n+      long getlastConfirmed(){\n+          return this.response;\n+      }\n+      \n+      void setRC(int rc){\n+          this.rc = rc;\n+      }\n+      \n+      int getRC(){\n+          return this.rc;\n+      }\n+      \n+      boolean ready(){\n+          return (this.response != -1);\n+      }\n+  }\n+  \n+  public long readLastConfirmed()\n+  throws InterruptedException, BKException {   \n+      LastConfirmedCtx ctx = new LastConfirmedCtx();\n+      asyncReadLastConfirmed(this, ctx);\n+      synchronized(ctx){\n+          while(!ctx.ready()){\n+              ctx.wait();\n+          }\n+      }\n+      \n+      if(ctx.getRC() != BKException.Code.OK) throw BKException.create(ctx.getRC());\n+      return ctx.getlastConfirmed();\n+  }\n+  \n   // close the ledger and send fails to all the adds in the pipeline\n   void handleUnrecoverableErrorDuringAdd(int rc) {\n     asyncClose(NoopCloseCallback.instance, null, rc);\n@@ -527,6 +587,21 @@ public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n     counter.dec();\n   }\n \n+  \n+\n+  /**\n+   * Implementation of  callback interface for synchronous read last confirmed method.\n+   */\n+  public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n+      LastConfirmedCtx lcCtx = (LastConfirmedCtx) ctx;\n+      \n+      synchronized(lcCtx){\n+          lcCtx.setRC(rc);\n+          lcCtx.setLastConfirmed(lastConfirmed);\n+          lcCtx.notify();\n+      }\n+  }\n+  \n   /**\n    * Close callback method\n    * "},{"sha":"ebb55daa86b630a7b29abc42f878dc1a50399637","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":18,"deletions":15,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -39,13 +39,14 @@\n class LedgerOpenOp implements DataCallback {\n     static final Logger LOG = Logger.getLogger(LedgerOpenOp.class);\n     \n-    BookKeeper bk;\n-    long ledgerId;\n-    OpenCallback cb;\n-    Object ctx;\n+    final BookKeeper bk;\n+    final long ledgerId;\n+    final OpenCallback cb;\n+    final Object ctx;\n     LedgerHandle lh;\n-    byte[] passwd;\n-    DigestType digestType;\n+    final byte[] passwd;\n+    final DigestType digestType;\n+    final boolean unsafe;\n     \n     /**\n      * Constructor.\n@@ -58,13 +59,14 @@\n      * @param ctx\n      */\n     \n-    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, OpenCallback cb, Object ctx) {\n+    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, boolean unsafe, OpenCallback cb, Object ctx) {\n         this.bk = bk;\n         this.ledgerId = ledgerId;\n         this.passwd = passwd;\n         this.cb = cb;\n         this.ctx = ctx;\n         this.digestType = digestType;\n+        this.unsafe = unsafe;\n     }\n \n     /**\n@@ -126,15 +128,16 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n             return;\n         }\n \n-        lh.recover(new GenericCallback<Void>() {\n-            @Override\n-            public void operationComplete(int rc, Void result) {\n-                if (rc != BKException.Code.OK) {\n-                    cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n-                } else {\n+        if(!unsafe)\n+            lh.recover(new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(int rc, Void result) {\n+                    if (rc != BKException.Code.OK) {\n+                        cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n+                    } else {\n                     cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n+                    }\n                 }\n-            }\n-        });\n+            });\n     }\n }"},{"sha":"689b2b048e6752f35f6587852115b5010d8ec95b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -32,9 +32,10 @@\n \n /**\n  * This class encapsulated the ledger recovery operation. It first does a read\n- * with entry-id of -1 to all bookies. Then starting from the last confirmed\n- * entry (from hints in the ledger entries), it reads forward until it is not\n- * able to find a particular entry. It closes the ledger at that entry.\n+ * with entry-id of -1 (LedgerHandle.LAST_ADD_CONFIRMED) to all bookies. Then \n+ * starting from the last confirmed entry (from hints in the ledger entries), \n+ * it reads forward until it is not able to find a particular entry. It closes\n+ * the ledger at that entry.\n  * \n  */\n class LedgerRecoveryOp implements ReadEntryCallback, ReadCallback, AddCallback {\n@@ -56,7 +57,7 @@ public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n \n     public void initiate() {\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, -1, this, i);\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, this, i);\n         }\n     }\n "},{"sha":"38cd88b76229b34ad0bc51931563b283ababe926","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -0,0 +1,101 @@\n+package org.apache.bookkeeper.client;\n+/* Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.util.Enumeration;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n+import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;\n+import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * This class encapsulated the read last confirmed operation. \n+ * \n+ */\n+class ReadLastConfirmedOp implements ReadEntryCallback {\n+    static final Logger LOG = Logger.getLogger(LedgerRecoveryOp.class);\n+    LedgerHandle lh;\n+    Object ctx; \n+    int numResponsesPending;\n+    int validResponses;\n+    long maxAddConfirmed; \n+    long maxLength = 0;\n+    volatile boolean notComplete = true;\n+\n+    ReadLastConfirmedCallback cb;\n+\n+    public ReadLastConfirmedOp(LedgerHandle lh, ReadLastConfirmedCallback cb, Object ctx) {\n+        this.cb = cb;\n+        this.ctx = ctx;\n+        this.lh = lh;\n+        this.validResponses = 0;\n+        this.numResponsesPending = lh.metadata.ensembleSize;\n+    }\n+\n+    public void initiate() {\n+        for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, this, i);\n+        }\n+    }\n+\n+    public synchronized void readEntryComplete(final int rc, final long ledgerId, final long entryId,\n+            final ChannelBuffer buffer, final Object ctx) {\n+        int bookieIndex = (Integer) ctx;\n+        \n+        numResponsesPending--;\n+        \n+        if (rc == BKException.Code.OK) {\n+            try {\n+                RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n+                maxAddConfirmed = Math.max(maxAddConfirmed, recoveryData.lastAddConfirmed);\n+                validResponses++;\n+            } catch (BKDigestMatchException e) {\n+                // Too bad, this bookie didn't give us a valid answer, we\n+                // still might be able to recover though so continue\n+                LOG.error(\"Mac mismatch while reading last entry from bookie: \"\n+                        + lh.metadata.currentEnsemble.get(bookieIndex));\n+            }\n+        }\n+        \n+        if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n+            // this still counts as a valid response, e.g., if the client crashed without writing any entry\n+            validResponses++;\n+        }\n+\n+        // other return codes dont count as valid responses\n+        if ((validResponses >= lh.metadata.quorumSize) &&\n+                notComplete) {\n+            notComplete = false;\n+            cb.readLastConfirmedComplete(BKException.Code.OK, maxAddConfirmed, this.ctx);\n+            return;\n+        }\n+\n+        if (numResponsesPending == 0) {\n+            // Have got all responses back but was still not enough, just fail the operation\n+            LOG.error(\"While recovering ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n+            cb.readLastConfirmedComplete(BKException.Code.LedgerRecoveryException, maxAddConfirmed, ctx);\n+        }\n+        \n+    }\n+}"},{"sha":"2ee53bc897f0d9b6af0576c75f4c7f853899e345","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":166,"deletions":2,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -36,11 +36,12 @@\n \n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.streaming.LedgerInputStream;\n import org.apache.bookkeeper.streaming.LedgerOutputStream;\n@@ -58,7 +59,8 @@\n  * \n  */\n \n-public class BookieReadWriteTest extends BaseTestCase implements AddCallback, ReadCallback {\n+public class BookieReadWriteTest extends BaseTestCase \n+implements AddCallback, ReadCallback, ReadLastConfirmedCallback {\n \n     // Depending on the taste, select the amount of logging\n     // by decommenting one of the two lines below\n@@ -88,11 +90,13 @@ public BookieReadWriteTest(DigestType digestType){\n     Set<Object> syncObjs;\n \n     class SyncObj {\n+        long lastConfirmed;\n         volatile int counter;\n         boolean value;\n \n         public SyncObj() {\n             counter = 0;\n+            lastConfirmed = -1;\n             value = false;\n         }\n     }\n@@ -714,6 +718,157 @@ public void testShutdown() throws IOException {\n         }\n     }\n     \n+    public void testReadFromOpenLedger() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.addEntry(entry.array());\n+                if(i == numEntriesToWrite/2){\n+                    LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n+                    Enumeration<LedgerEntry> readEntry = lh.readEntries(i, i);\n+                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n+                }\n+            }\n+\n+            long last = lh.readLastConfirmed();\n+            assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n+            \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+            /*\n+             * Asynchronous call to read last confirmed entry\n+             */\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.addEntry(entry.array());\n+            }\n+\n+            \n+            SyncObj sync = new SyncObj();\n+            lh.asyncReadLastConfirmed(this, sync);\n+            \n+            // Wait for for last confirmed\n+            synchronized (sync) {\n+                while (sync.lastConfirmed == -1) {\n+                    LOG.debug(\"Counter = \" + sync.lastConfirmed);\n+                    sync.wait();\n+                }\n+            }\n+            \n+            assertTrue(\"Last confirmed add: \" + sync.lastConfirmed, sync.lastConfirmed == (numEntriesToWrite - 2));\n+            \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+            \n+\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+    \n+    \n+    @Test\n+    public void testLastConfirmedAdd() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.addEntry(entry.array());\n+            }\n+\n+            long last = lh.readLastConfirmed();\n+            assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n+            \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+            /*\n+             * Asynchronous call to read last confirmed entry\n+             */\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.addEntry(entry.array());\n+            }\n+\n+            \n+            SyncObj sync = new SyncObj();\n+            lh.asyncReadLastConfirmed(this, sync);\n+            \n+            // Wait for for last confirmed\n+            synchronized (sync) {\n+                while (sync.lastConfirmed == -1) {\n+                    LOG.debug(\"Counter = \" + sync.lastConfirmed);\n+                    sync.wait();\n+                }\n+            }\n+            \n+            assertTrue(\"Last confirmed add: \" + sync.lastConfirmed, sync.lastConfirmed == (numEntriesToWrite - 2));\n+            \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+            \n+\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+    \n     \n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n@@ -737,6 +892,15 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         }\n     }\n \n+    public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n+        SyncObj sync = (SyncObj) ctx;\n+        \n+        synchronized(sync){\n+            sync.lastConfirmed = lastConfirmed;\n+            sync.notify();\n+        }\n+    }\n+    \n     @Before\n     public void setUp() throws Exception{\n         super.setUp();"},{"sha":"4ab29812cd74729d152138613ed0fbb430cf9918","filename":"doc/bookkeeperProgrammer.textile","status":"modified","additions":46,"deletions":1,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/74397e3e20b2cd3e3c920f00be7f044cf548e076/doc/bookkeeperProgrammer.textile","raw_url":"https://github.com/apache/bookkeeper/raw/74397e3e20b2cd3e3c920f00be7f044cf548e076/doc/bookkeeperProgrammer.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperProgrammer.textile?ref=74397e3e20b2cd3e3c920f00be7f044cf548e076","patch":"@@ -145,7 +145,7 @@ p. To read from a ledger, a client must open it first. The following methods bel\n \n  @public LedgerHandle openLedger(long lId, DigestType type, byte passwd[]) throws InterruptedException, BKException @ \n \n-*  @ledgerId@ is the ledger identifier; \n+*  @lId@ is the ledger identifier; \n *  @type@ is the type of digest used with entries: either MAC or CRC32. \n *  @passwd@ is a password to access the ledger (used only in the case of @VERIFIABLE@ ledgers); \n \n@@ -164,6 +164,30 @@ p. where:\n *  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n *  @ctx@ is control object used for accountability purposes. \n \n+p. The two calls above to open a ledger recover the ledger if it has not been closed properly before it reads entries from it. It is also possible to open a ledger and read from it without triggering the recovery process with the following methods of @org.apache.bookkeeper.client.BookKeeper@ . \n+\n+ _Synchronous open:_ \n+\n+ @public LedgerHandle openLedgerNoRecovery(long lId, DigestType type, byte passwd[]) throws InterruptedException, BKException @ \n+\n+*  @lId@ is the ledger identifier; \n+*  @type@ is the type of digest used with entries: either MAC or CRC32. \n+*  @passwd@ is a password to access the ledger (used only in the case of @VERIFIABLE@ ledgers); \n+\n+\n+ _Asynchronous open:_ \n+\n+ @public void asyncOpenLedgerNoRecovery(long lId, DigestType type, byte passwd[], OpenCallback cb, Object ctx) @ \n+\n+p. It also takes a a ledger identifier and a password. Additionaly, it takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @OpenCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @openComplete@ that has the following signature: \n+\n+ @public void openComplete(int rc, LedgerHandle lh, Object ctx) @ \n+\n+p. where: \n+\n+*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n+*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n+*  @ctx@ is control object used for accountability purposes. \n \n h1.  Reading from ledger \n \n@@ -217,3 +241,24 @@ p. where:\n *  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n *  @ctx@ is control object used for accountability purposes. \n \n+h1.  Reading the last confirmed entry from a ledger \n+\n+p. When reading from an open ledger (opening without recovery enables it), it is often necessary to read the last confirmed hint that the writer client writes along with every entry. The general idea is to obtain the hint from a quorum and return the largest value. The following methods belong to @org.apache.bookkeeper.client.BookKeeper@ . \n+\n+ _Synchronous read:_ \n+\n+ @public long readLastConfirmed() @ \n+\n+ _Asynchronous read:_ \n+\n+ @public void asyncReadLastConfirmed(ReadLastConfirmedComplete cb, Object ctx) @ \n+ \n+p. It takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @ReadLastConfirmedCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @readLastConfirmedComplete@ that has the following signature: \n+\n+@public void readLastConfirmedComplete (int rc, long lastConfirmed, Object ctx) @\n+\n+p. where: \n+\n+*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n+*  @lastConfirmed@ is the maximum last confirmed hint received among a quorum of bookies; \n+*  @ctx@ is control object used for accountability purposes. \n\\ No newline at end of file"}]}

