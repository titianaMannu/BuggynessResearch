{"sha":"744edf07394472d3146e57831592a69d5a86616c","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3NDRlZGYwNzM5NDQ3MmQzMTQ2ZTU3ODMxNTkyYTY5ZDVhODY2MTZj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-06-27T13:35:11Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-06-27T13:35:11Z"},"message":"BOOKKEEPER-303: LedgerMetadata should serialized using protobufs (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1354492 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a766f00dff402dff2bae0291fc7470c1a142702e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a766f00dff402dff2bae0291fc7470c1a142702e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/744edf07394472d3146e57831592a69d5a86616c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/744edf07394472d3146e57831592a69d5a86616c","html_url":"https://github.com/apache/bookkeeper/commit/744edf07394472d3146e57831592a69d5a86616c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/744edf07394472d3146e57831592a69d5a86616c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d193780cc404c2e3694c82385d7f422accc416f3","url":"https://api.github.com/repos/apache/bookkeeper/commits/d193780cc404c2e3694c82385d7f422accc416f3","html_url":"https://github.com/apache/bookkeeper/commit/d193780cc404c2e3694c82385d7f422accc416f3"}],"stats":{"total":7443,"additions":5956,"deletions":1487},"files":[{"sha":"8c8af6ef3278eaa1d28c174ec4b643ac2b815702","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -8,6 +8,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-203: improve ledger manager interface to remove zookeeper dependency on metadata operations. (sijie via ivank)\n \n+      BOOKKEEPER-303: LedgerMetadata should serialized using protobufs (ivank)\n+\n   Backward compatible changes:\n \n     BUGFIXES:"},{"sha":"4810640be61a36a533b09421adb47c4ec98d6e93","filename":"bookkeeper-server/pom.xml","status":"modified","additions":30,"deletions":1,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/pom.xml?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -34,7 +34,7 @@\n     <dependency>\n       <groupId>com.google.protobuf</groupId>\n       <artifactId>protobuf-java</artifactId>\n-      <version>2.3.0</version>\n+      <version>2.4.1</version>\n       <scope>compile</scope>\n     </dependency>\n     <dependency>\n@@ -165,4 +165,33 @@\n       </plugin>\n     </plugins>\n   </build>\n+  <profiles>\n+    <profile>\n+      <id>protobuf</id>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <artifactId>maven-antrun-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <phase>generate-sources</phase>\n+                <id>default-cli</id>\n+                <configuration>\n+                  <target>\n+                    <exec executable=\"protoc\" failonerror=\"true\">\n+                      <arg value=\"--java_out=src/main/java\" />\n+                      <arg value=\"src/main/proto/DataFormats.proto\" />\n+                    </exec>\n+                  </target>\n+                </configuration>\n+                <goals>\n+                  <goal>run</goal>\n+                </goals>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+      </build>\n+    </profile>\n+  </profiles>\n </project>"},{"sha":"1a2ee3095b4d1c380e206c3c98d43aa6d93dc24f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -90,7 +90,7 @@ public void initiate() {\n \n         ArrayList<InetSocketAddress> ensemble;\n         try {\n-            ensemble = bk.bookieWatcher.getNewBookies(metadata.ensembleSize);\n+            ensemble = bk.bookieWatcher.getNewBookies(metadata.getEnsembleSize());\n         } catch (BKNotEnoughBookiesException e) {\n             LOG.error(\"Not enough bookies to create ledger\");\n             cb.createComplete(e.getCode(), null, this.ctx);"},{"sha":"85277a353d1f753c7d044932f5d77e42bbc29e81","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":21,"deletions":14,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -41,6 +41,7 @@\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State;\n import org.apache.bookkeeper.util.SafeRunnable;\n \n import org.slf4j.Logger;\n@@ -83,8 +84,8 @@\n         this.metadata = metadata;\n \n         if (metadata.isClosed()) {\n-            lastAddConfirmed = lastAddPushed = metadata.close;\n-            length = metadata.length;\n+            lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n+            length = metadata.getLength();\n         } else {\n             lastAddConfirmed = lastAddPushed = INVALID_ENTRY_ID;\n             length = 0;\n@@ -98,7 +99,7 @@\n         macManager = DigestManager.instantiate(ledgerId, password, digestType);\n         this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n         distributionSchedule = new RoundRobinDistributionSchedule(\n-            metadata.quorumSize, metadata.ensembleSize);\n+                metadata.getQuorumSize(), metadata.getEnsembleSize());\n     }\n \n     /**\n@@ -256,17 +257,19 @@ void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc)\n         bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n-                final long prevClose;\n+                final long prevLastEntryId;\n                 final long prevLength;\n+                final State prevState;\n \n                 synchronized(LedgerHandle.this) {\n-                    prevClose = metadata.close;\n-                    prevLength = metadata.length;\n+                    prevState = metadata.getState();\n+                    prevLastEntryId = metadata.getLastEntryId();\n+                    prevLength = metadata.getLength();\n \n                     // synchronized on LedgerHandle.this to ensure that \n                     // lastAddPushed can not be updated after the metadata \n                     // is closed. \n-                    metadata.length = length;\n+                    metadata.setLength(length);\n \n                     // Close operation is idempotent, so no need to check if we are\n                     // already closed\n@@ -277,7 +280,7 @@ public void safeRun() {\n \n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n-                              + metadata.close + \" with this many bytes: \" + metadata.length);\n+                              + metadata.getLastEntryId() + \" with this many bytes: \" + metadata.getLength());\n                 }\n \n                 final class CloseCb implements GenericCallback<Void> {\n@@ -292,15 +295,19 @@ public void operationComplete(int newrc, LedgerMetadata newMeta) {\n                                                   + \" when closing, code=\" + newrc);\n                                         cb.closeComplete(rc, LedgerHandle.this, ctx);\n                                     } else {\n-                                        metadata.close(prevClose);\n-                                        metadata.length = prevLength;\n+                                        metadata.setState(prevState);\n+                                        if (prevState.equals(State.CLOSED)) {\n+                                            metadata.close(prevLastEntryId);\n+                                        }\n+\n+                                        metadata.setLength(prevLength);\n                                         if (metadata.resolveConflict(newMeta)) {\n-                                            metadata.length = length;\n+                                            metadata.setLength(length);\n                                             metadata.close(lastAddConfirmed);\n                                             writeLedgerConfig(new CloseCb());\n                                             return;\n                                         } else {\n-                                            metadata.length = length;\n+                                            metadata.setLength(length);\n                                             metadata.close(lastAddConfirmed);\n                                             LOG.warn(\"Conditional update ledger metadata for ledger \" + ledgerId + \" failed.\");\n                                             cb.closeComplete(rc, LedgerHandle.this, ctx);\n@@ -735,8 +742,8 @@ void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n \n     synchronized void recover(final GenericCallback<Void> cb) {\n         if (metadata.isClosed()) {\n-            lastAddConfirmed = lastAddPushed = metadata.close;\n-            length = metadata.length;\n+            lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n+            length = metadata.getLength();\n \n             // We are already closed, nothing to do\n             cb.operationComplete(BKException.Code.OK, null);"},{"sha":"24add1e27d4053eed458ef128768acf6500fb139","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":153,"deletions":51,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -18,6 +18,8 @@\n  * limitations under the License.\n  */\n \n+import java.io.BufferedReader;\n+import java.io.StringReader;\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n@@ -27,6 +29,8 @@\n import java.util.TreeMap;\n \n import org.apache.bookkeeper.versioning.Version;\n+import com.google.protobuf.TextFormat;\n+import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat;\n import org.apache.bookkeeper.util.StringUtils;\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n@@ -46,19 +50,21 @@\n \n     // can't use -1 for NOTCLOSED because that is reserved for a closed, empty\n     // ledger\n-    public static final int NOTCLOSED = -101;\n-    public static final int IN_RECOVERY = -102;\n+    private static final int NOTCLOSED = -101;\n+    private static final int IN_RECOVERY = -102;\n \n     public static final int LOWEST_COMPAT_METADATA_FORMAT_VERSION = 0;\n-    public static final int CURRENT_METADATA_FORMAT_VERSION = 1;\n+    public static final int CURRENT_METADATA_FORMAT_VERSION = 2;\n     public static final String VERSION_KEY = \"BookieMetadataFormatVersion\";\n \n-    int metadataFormatVersion = 0;\n+    private int metadataFormatVersion = 0;\n \n-    int ensembleSize;\n-    int quorumSize;\n-    long length;\n-    long close;\n+    private int ensembleSize;\n+    private int quorumSize;\n+    private long length;\n+    private long lastEntryId;\n+\n+    private LedgerMetadataFormat.State state;\n     private SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = new TreeMap<Long, ArrayList<InetSocketAddress>>();\n     ArrayList<InetSocketAddress> currentEnsemble;\n     volatile Version version = null;\n@@ -72,7 +78,8 @@ public LedgerMetadata(int ensembleSize, int quorumSize) {\n          * we read it in LedgerRecoveryOp.readComplete.\n          */\n         this.length = 0;\n-        this.close = NOTCLOSED;\n+        this.state = LedgerMetadataFormat.State.OPEN;\n+        this.lastEntryId = LedgerHandle.INVALID_ENTRY_ID;\n         this.metadataFormatVersion = CURRENT_METADATA_FORMAT_VERSION;\n     };\n \n@@ -91,21 +98,49 @@ private LedgerMetadata() {\n         return ensembles;\n     }\n \n-    boolean isClosed() {\n-        return close != NOTCLOSED \n-            && close != IN_RECOVERY;\n+    public int getEnsembleSize() {\n+        return ensembleSize;\n+    }\n+\n+    public int getQuorumSize() {\n+        return quorumSize;\n+    }\n+\n+    public long getLastEntryId() {\n+        return lastEntryId;\n+    }\n+\n+    public long getLength() {\n+        return length;\n+    }\n+\n+    void setLength(long length) {\n+        this.length = length;\n+    }\n+\n+    public boolean isClosed() {\n+        return state == LedgerMetadataFormat.State.CLOSED;\n+    }\n+\n+    public boolean isInRecovery() {\n+        return state == LedgerMetadataFormat.State.IN_RECOVERY;\n+    }\n+\n+    LedgerMetadataFormat.State getState() {\n+        return state;\n     }\n \n-    boolean isInRecovery() {\n-        return IN_RECOVERY == close;\n+    void setState(LedgerMetadataFormat.State state) {\n+        this.state = state;\n     }\n-    \n+\n     void markLedgerInRecovery() {\n-        close = IN_RECOVERY;\n+        state = LedgerMetadataFormat.State.IN_RECOVERY;\n     }\n \n     void close(long entryId) {\n-        close = entryId;\n+        lastEntryId = entryId;\n+        state = LedgerMetadataFormat.State.CLOSED;\n     }\n \n     void addEnsemble(long startEntryId, ArrayList<InetSocketAddress> ensemble) {\n@@ -144,6 +179,31 @@ long getNextEnsembleChange(long entryId) {\n      * @return the metadata serialized into a byte array\n      */\n     public byte[] serialize() {\n+        if (metadataFormatVersion == 1) {\n+            return serializeVersion1();\n+        }\n+        LedgerMetadataFormat.Builder builder = LedgerMetadataFormat.newBuilder();\n+        builder.setQuorumSize(quorumSize).setEnsembleSize(ensembleSize).setLength(length)\n+            .setState(state).setLastEntryId(lastEntryId);\n+        for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : ensembles.entrySet()) {\n+            LedgerMetadataFormat.Segment.Builder segmentBuilder = LedgerMetadataFormat.Segment.newBuilder();\n+            segmentBuilder.setFirstEntryId(entry.getKey());\n+            for (InetSocketAddress addr : entry.getValue()) {\n+                segmentBuilder.addEnsembleMember(addr.getAddress().getHostAddress() + \":\" + addr.getPort());\n+            }\n+            builder.addSegment(segmentBuilder.build());\n+        }\n+\n+        StringBuilder s = new StringBuilder();\n+        s.append(VERSION_KEY).append(tSplitter).append(CURRENT_METADATA_FORMAT_VERSION).append(lSplitter);\n+        s.append(TextFormat.printToString(builder.build()));\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Serialized config: \" + s.toString());\n+        }\n+        return s.toString().getBytes();\n+    }\n+\n+    private byte[] serializeVersion1() {\n         StringBuilder s = new StringBuilder();\n         s.append(VERSION_KEY).append(tSplitter).append(metadataFormatVersion).append(lSplitter);\n         s.append(quorumSize).append(lSplitter).append(ensembleSize).append(lSplitter).append(length);\n@@ -156,8 +216,10 @@ long getNextEnsembleChange(long entryId) {\n             }\n         }\n \n-        if (close != NOTCLOSED) {\n-            s.append(lSplitter).append(close).append(tSplitter).append(closed);\n+        if (state == LedgerMetadataFormat.State.IN_RECOVERY) {\n+            s.append(lSplitter).append(IN_RECOVERY).append(tSplitter).append(closed);\n+        } else if (state == LedgerMetadataFormat.State.CLOSED) {\n+            s.append(lSplitter).append(getLastEntryId()).append(tSplitter).append(closed);\n         }\n \n         if (LOG.isDebugEnabled()) {\n@@ -170,7 +232,7 @@ long getNextEnsembleChange(long entryId) {\n     /**\n      * Parses a given byte array and transforms into a LedgerConfig object\n      *\n-     * @param array\n+     * @param bytes\n      *            byte array to parse\n      * @param version\n      *            version of the ledger metadata\n@@ -179,61 +241,97 @@ long getNextEnsembleChange(long entryId) {\n      *             if the given byte[] cannot be parsed\n      */\n     public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws IOException {\n-\n         LedgerMetadata lc = new LedgerMetadata();\n+        lc.version = version;\n+\n         String config = new String(bytes);\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Parsing Config: \" + config);\n         }\n-        \n-        String lines[] = config.split(lSplitter);\n-        \n-        try {\n-            int i = 0;\n-            if (lines[0].startsWith(VERSION_KEY)) {\n-                String parts[] = lines[0].split(tSplitter);\n-                lc.metadataFormatVersion = new Integer(parts[1]);\n-                i++;\n-            } else {\n-                lc.metadataFormatVersion = 0;\n-            }\n-            \n-            if (lc.metadataFormatVersion < LOWEST_COMPAT_METADATA_FORMAT_VERSION\n-                || lc.metadataFormatVersion > CURRENT_METADATA_FORMAT_VERSION) {\n-                throw new IOException(\"Metadata version not compatible. Expected between \"\n-                        + LOWEST_COMPAT_METADATA_FORMAT_VERSION + \" and \" + CURRENT_METADATA_FORMAT_VERSION\n-                        + \", but got \" + lc.metadataFormatVersion);\n-            }\n-            if ((lines.length+i) < 2) {\n-                throw new IOException(\"Quorum size or ensemble size absent from config: \" + config);\n+        BufferedReader reader = new BufferedReader(new StringReader(config));\n+        String versionLine = reader.readLine();\n+\n+        int i = 0;\n+        if (versionLine.startsWith(VERSION_KEY)) {\n+            String parts[] = versionLine.split(tSplitter);\n+            lc.metadataFormatVersion = new Integer(parts[1]);\n+        } else {\n+            // if no version is set, take it to be version 1\n+            // as the parsing is the same as what we had before\n+            // we introduce versions\n+            lc.metadataFormatVersion = 1;\n+            // reset the reader\n+            reader.close();\n+            reader = new BufferedReader(new StringReader(config));\n+        }\n+\n+        if (lc.metadataFormatVersion < LOWEST_COMPAT_METADATA_FORMAT_VERSION\n+            || lc.metadataFormatVersion > CURRENT_METADATA_FORMAT_VERSION) {\n+            throw new IOException(\"Metadata version not compatible. Expected between \"\n+                    + LOWEST_COMPAT_METADATA_FORMAT_VERSION + \" and \" + CURRENT_METADATA_FORMAT_VERSION\n+                                  + \", but got \" + lc.metadataFormatVersion);\n+        }\n+\n+        if (lc.metadataFormatVersion == 1) {\n+            return parseVersion1Config(lc, reader);\n+        }\n+\n+        LedgerMetadataFormat.Builder builder = LedgerMetadataFormat.newBuilder();\n+        TextFormat.merge(reader, builder);\n+        LedgerMetadataFormat data = builder.build();\n+        lc.quorumSize = data.getQuorumSize();\n+        lc.ensembleSize = data.getEnsembleSize();\n+        lc.length = data.getLength();\n+        lc.state = data.getState();\n+        lc.lastEntryId = data.getLastEntryId();\n+\n+        for (LedgerMetadataFormat.Segment s : data.getSegmentList()) {\n+            ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n+            for (String member : s.getEnsembleMemberList()) {\n+                addrs.add(StringUtils.parseAddr(member));\n             }\n+            lc.addEnsemble(s.getFirstEntryId(), addrs);\n+        }\n+        return lc;\n+    }\n \n-            lc.version = version;\n-            lc.quorumSize = new Integer(lines[i++]);\n-            lc.ensembleSize = new Integer(lines[i++]);\n-            lc.length = new Long(lines[i++]);\n+    static LedgerMetadata parseVersion1Config(LedgerMetadata lc,\n+                                              BufferedReader reader) throws IOException {\n+        try {\n+            lc.quorumSize = new Integer(reader.readLine());\n+            lc.ensembleSize = new Integer(reader.readLine());\n+            lc.length = new Long(reader.readLine());\n \n-            for (; i < lines.length; i++) {\n-                String parts[] = lines[i].split(tSplitter);\n+            String line = reader.readLine();\n+            while (line != null) {\n+                String parts[] = line.split(tSplitter);\n \n                 if (parts[1].equals(closed)) {\n-                    lc.close = new Long(parts[0]);\n+                    Long l = new Long(parts[0]);\n+                    if (l == IN_RECOVERY) {\n+                        lc.state = LedgerMetadataFormat.State.IN_RECOVERY;\n+                    } else {\n+                        lc.state = LedgerMetadataFormat.State.CLOSED;\n+                        lc.lastEntryId = l;\n+                    }\n                     break;\n+                } else {\n+                    lc.state = LedgerMetadataFormat.State.OPEN;\n                 }\n \n                 ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n                 for (int j = 1; j < parts.length; j++) {\n                     addrs.add(StringUtils.parseAddr(parts[j]));\n                 }\n                 lc.addEnsemble(new Long(parts[0]), addrs);\n+                line = reader.readLine();\n             }\n         } catch (NumberFormatException e) {\n             throw new IOException(e);\n         }\n         return lc;\n     }\n-    \n \n     /**\n      * Updates the version of this metadata.\n@@ -270,7 +368,11 @@ boolean resolveConflict(LedgerMetadata newMeta) {\n             ensembleSize != newMeta.ensembleSize ||\n             quorumSize != newMeta.quorumSize ||\n             length != newMeta.length ||\n-            close != newMeta.close) {\n+            state != newMeta.state) {\n+            return false;\n+        }\n+        if (state == LedgerMetadataFormat.State.CLOSED\n+            && lastEntryId != newMeta.lastEntryId) {\n             return false;\n         }\n         // new meta znode version should be larger than old one"},{"sha":"3ecf14d96c2d62f49b04691cee1f1f3554ee9a43","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -57,7 +57,7 @@\n     public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n         this.cb = cb;\n         this.lh = lh;\n-        numResponsesPending = lh.metadata.ensembleSize;\n+        numResponsesPending = lh.metadata.getEnsembleSize();\n     }\n \n     public void initiate() {"},{"sha":"c9cd24d5588f2736a5ebd9642346baa9211e3755","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -53,7 +53,7 @@\n         this.ctx = ctx;\n         this.entryId = LedgerHandle.INVALID_ENTRY_ID;\n         \n-        successesSoFar = new boolean[lh.metadata.quorumSize];\n+        successesSoFar = new boolean[lh.metadata.getQuorumSize()];\n         numResponsesPending = successesSoFar.length;\n     }\n "},{"sha":"a654640ffb302e42d5cd46f7dd5020dc38a86da8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -94,7 +94,7 @@ public void initiate() throws InterruptedException {\n     }\n \n     void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int lastErrorCode) {\n-        if (entry.nextReplicaIndexToReadFrom >= lh.metadata.quorumSize) {\n+        if (entry.nextReplicaIndexToReadFrom >= lh.metadata.getQuorumSize()) {\n             // we are done, the read has failed from all replicas, just fail the\n             // read\n             lh.opCounterSem.release();"},{"sha":"e891d2f784d86fd238802e431f42f8e246ee56bf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -51,7 +51,7 @@ public ReadLastConfirmedOp(LedgerHandle lh, LastConfirmedDataCallback cb) {\n         this.cb = cb;\n         this.maxRecoveredData = new RecoveryData(LedgerHandle.INVALID_ENTRY_ID, 0);\n         this.lh = lh;\n-        this.numResponsesPending = lh.metadata.ensembleSize;\n+        this.numResponsesPending = lh.metadata.getEnsembleSize();\n         this.coverageSet = lh.distributionSchedule.getCoverageSet();\n     }\n "},{"sha":"3b200d7ebb9af7bcec9a9960c66a67afe4f1f163","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","status":"added","additions":1493,"deletions":0,"changes":1493,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -0,0 +1,1493 @@\n+// Generated by the protocol buffer compiler.  DO NOT EDIT!\n+// source: src/main/proto/DataFormats.proto\n+\n+package org.apache.bookkeeper.proto;\n+\n+public final class DataFormats {\n+  private DataFormats() {}\n+  public static void registerAllExtensions(\n+      com.google.protobuf.ExtensionRegistry registry) {\n+  }\n+  public interface LedgerMetadataFormatOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required int32 quorumSize = 1;\n+    boolean hasQuorumSize();\n+    int getQuorumSize();\n+    \n+    // required int32 ensembleSize = 2;\n+    boolean hasEnsembleSize();\n+    int getEnsembleSize();\n+    \n+    // required int64 length = 3;\n+    boolean hasLength();\n+    long getLength();\n+    \n+    // optional int64 lastEntryId = 4;\n+    boolean hasLastEntryId();\n+    long getLastEntryId();\n+    \n+    // required .LedgerMetadataFormat.State state = 5 [default = OPEN];\n+    boolean hasState();\n+    org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State getState();\n+    \n+    // repeated .LedgerMetadataFormat.Segment segment = 6;\n+    java.util.List<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment> \n+        getSegmentList();\n+    org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment getSegment(int index);\n+    int getSegmentCount();\n+    java.util.List<? extends org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder> \n+        getSegmentOrBuilderList();\n+    org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder getSegmentOrBuilder(\n+        int index);\n+  }\n+  public static final class LedgerMetadataFormat extends\n+      com.google.protobuf.GeneratedMessage\n+      implements LedgerMetadataFormatOrBuilder {\n+    // Use LedgerMetadataFormat.newBuilder() to construct.\n+    private LedgerMetadataFormat(Builder builder) {\n+      super(builder);\n+    }\n+    private LedgerMetadataFormat(boolean noInit) {}\n+    \n+    private static final LedgerMetadataFormat defaultInstance;\n+    public static LedgerMetadataFormat getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public LedgerMetadataFormat getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_fieldAccessorTable;\n+    }\n+    \n+    public enum State\n+        implements com.google.protobuf.ProtocolMessageEnum {\n+      OPEN(0, 1),\n+      IN_RECOVERY(1, 2),\n+      CLOSED(2, 3),\n+      ;\n+      \n+      public static final int OPEN_VALUE = 1;\n+      public static final int IN_RECOVERY_VALUE = 2;\n+      public static final int CLOSED_VALUE = 3;\n+      \n+      \n+      public final int getNumber() { return value; }\n+      \n+      public static State valueOf(int value) {\n+        switch (value) {\n+          case 1: return OPEN;\n+          case 2: return IN_RECOVERY;\n+          case 3: return CLOSED;\n+          default: return null;\n+        }\n+      }\n+      \n+      public static com.google.protobuf.Internal.EnumLiteMap<State>\n+          internalGetValueMap() {\n+        return internalValueMap;\n+      }\n+      private static com.google.protobuf.Internal.EnumLiteMap<State>\n+          internalValueMap =\n+            new com.google.protobuf.Internal.EnumLiteMap<State>() {\n+              public State findValueByNumber(int number) {\n+                return State.valueOf(number);\n+              }\n+            };\n+      \n+      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+          getValueDescriptor() {\n+        return getDescriptor().getValues().get(index);\n+      }\n+      public final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptorForType() {\n+        return getDescriptor();\n+      }\n+      public static final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.getDescriptor().getEnumTypes().get(0);\n+      }\n+      \n+      private static final State[] VALUES = {\n+        OPEN, IN_RECOVERY, CLOSED, \n+      };\n+      \n+      public static State valueOf(\n+          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+        if (desc.getType() != getDescriptor()) {\n+          throw new java.lang.IllegalArgumentException(\n+            \"EnumValueDescriptor is not for this type.\");\n+        }\n+        return VALUES[desc.getIndex()];\n+      }\n+      \n+      private final int index;\n+      private final int value;\n+      \n+      private State(int index, int value) {\n+        this.index = index;\n+        this.value = value;\n+      }\n+      \n+      // @@protoc_insertion_point(enum_scope:LedgerMetadataFormat.State)\n+    }\n+    \n+    public interface SegmentOrBuilder\n+        extends com.google.protobuf.MessageOrBuilder {\n+      \n+      // repeated string ensembleMember = 1;\n+      java.util.List<String> getEnsembleMemberList();\n+      int getEnsembleMemberCount();\n+      String getEnsembleMember(int index);\n+      \n+      // required int64 firstEntryId = 2;\n+      boolean hasFirstEntryId();\n+      long getFirstEntryId();\n+    }\n+    public static final class Segment extends\n+        com.google.protobuf.GeneratedMessage\n+        implements SegmentOrBuilder {\n+      // Use Segment.newBuilder() to construct.\n+      private Segment(Builder builder) {\n+        super(builder);\n+      }\n+      private Segment(boolean noInit) {}\n+      \n+      private static final Segment defaultInstance;\n+      public static Segment getDefaultInstance() {\n+        return defaultInstance;\n+      }\n+      \n+      public Segment getDefaultInstanceForType() {\n+        return defaultInstance;\n+      }\n+      \n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_Segment_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_Segment_fieldAccessorTable;\n+      }\n+      \n+      private int bitField0_;\n+      // repeated string ensembleMember = 1;\n+      public static final int ENSEMBLEMEMBER_FIELD_NUMBER = 1;\n+      private com.google.protobuf.LazyStringList ensembleMember_;\n+      public java.util.List<String>\n+          getEnsembleMemberList() {\n+        return ensembleMember_;\n+      }\n+      public int getEnsembleMemberCount() {\n+        return ensembleMember_.size();\n+      }\n+      public String getEnsembleMember(int index) {\n+        return ensembleMember_.get(index);\n+      }\n+      \n+      // required int64 firstEntryId = 2;\n+      public static final int FIRSTENTRYID_FIELD_NUMBER = 2;\n+      private long firstEntryId_;\n+      public boolean hasFirstEntryId() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public long getFirstEntryId() {\n+        return firstEntryId_;\n+      }\n+      \n+      private void initFields() {\n+        ensembleMember_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+        firstEntryId_ = 0L;\n+      }\n+      private byte memoizedIsInitialized = -1;\n+      public final boolean isInitialized() {\n+        byte isInitialized = memoizedIsInitialized;\n+        if (isInitialized != -1) return isInitialized == 1;\n+        \n+        if (!hasFirstEntryId()) {\n+          memoizedIsInitialized = 0;\n+          return false;\n+        }\n+        memoizedIsInitialized = 1;\n+        return true;\n+      }\n+      \n+      public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                          throws java.io.IOException {\n+        getSerializedSize();\n+        for (int i = 0; i < ensembleMember_.size(); i++) {\n+          output.writeBytes(1, ensembleMember_.getByteString(i));\n+        }\n+        if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+          output.writeInt64(2, firstEntryId_);\n+        }\n+        getUnknownFields().writeTo(output);\n+      }\n+      \n+      private int memoizedSerializedSize = -1;\n+      public int getSerializedSize() {\n+        int size = memoizedSerializedSize;\n+        if (size != -1) return size;\n+      \n+        size = 0;\n+        {\n+          int dataSize = 0;\n+          for (int i = 0; i < ensembleMember_.size(); i++) {\n+            dataSize += com.google.protobuf.CodedOutputStream\n+              .computeBytesSizeNoTag(ensembleMember_.getByteString(i));\n+          }\n+          size += dataSize;\n+          size += 1 * getEnsembleMemberList().size();\n+        }\n+        if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+          size += com.google.protobuf.CodedOutputStream\n+            .computeInt64Size(2, firstEntryId_);\n+        }\n+        size += getUnknownFields().getSerializedSize();\n+        memoizedSerializedSize = size;\n+        return size;\n+      }\n+      \n+      private static final long serialVersionUID = 0L;\n+      @java.lang.Override\n+      protected java.lang.Object writeReplace()\n+          throws java.io.ObjectStreamException {\n+        return super.writeReplace();\n+      }\n+      \n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(\n+          com.google.protobuf.ByteString data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return newBuilder().mergeFrom(data).buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(\n+          com.google.protobuf.ByteString data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return newBuilder().mergeFrom(data, extensionRegistry)\n+                 .buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(byte[] data)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return newBuilder().mergeFrom(data).buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(\n+          byte[] data,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        return newBuilder().mergeFrom(data, extensionRegistry)\n+                 .buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        return newBuilder().mergeFrom(input).buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return newBuilder().mergeFrom(input, extensionRegistry)\n+                 .buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseDelimitedFrom(java.io.InputStream input)\n+          throws java.io.IOException {\n+        Builder builder = newBuilder();\n+        if (builder.mergeDelimitedFrom(input)) {\n+          return builder.buildParsed();\n+        } else {\n+          return null;\n+        }\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseDelimitedFrom(\n+          java.io.InputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        Builder builder = newBuilder();\n+        if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+          return builder.buildParsed();\n+        } else {\n+          return null;\n+        }\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(\n+          com.google.protobuf.CodedInputStream input)\n+          throws java.io.IOException {\n+        return newBuilder().mergeFrom(input).buildParsed();\n+      }\n+      public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment parseFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        return newBuilder().mergeFrom(input, extensionRegistry)\n+                 .buildParsed();\n+      }\n+      \n+      public static Builder newBuilder() { return Builder.create(); }\n+      public Builder newBuilderForType() { return newBuilder(); }\n+      public static Builder newBuilder(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment prototype) {\n+        return newBuilder().mergeFrom(prototype);\n+      }\n+      public Builder toBuilder() { return newBuilder(this); }\n+      \n+      @java.lang.Override\n+      protected Builder newBuilderForType(\n+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+        Builder builder = new Builder(parent);\n+        return builder;\n+      }\n+      public static final class Builder extends\n+          com.google.protobuf.GeneratedMessage.Builder<Builder>\n+         implements org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder {\n+        public static final com.google.protobuf.Descriptors.Descriptor\n+            getDescriptor() {\n+          return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_Segment_descriptor;\n+        }\n+        \n+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+            internalGetFieldAccessorTable() {\n+          return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_Segment_fieldAccessorTable;\n+        }\n+        \n+        // Construct using org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.newBuilder()\n+        private Builder() {\n+          maybeForceBuilderInitialization();\n+        }\n+        \n+        private Builder(BuilderParent parent) {\n+          super(parent);\n+          maybeForceBuilderInitialization();\n+        }\n+        private void maybeForceBuilderInitialization() {\n+          if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+          }\n+        }\n+        private static Builder create() {\n+          return new Builder();\n+        }\n+        \n+        public Builder clear() {\n+          super.clear();\n+          ensembleMember_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          firstEntryId_ = 0L;\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          return this;\n+        }\n+        \n+        public Builder clone() {\n+          return create().mergeFrom(buildPartial());\n+        }\n+        \n+        public com.google.protobuf.Descriptors.Descriptor\n+            getDescriptorForType() {\n+          return org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.getDescriptor();\n+        }\n+        \n+        public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment getDefaultInstanceForType() {\n+          return org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.getDefaultInstance();\n+        }\n+        \n+        public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment build() {\n+          org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(result);\n+          }\n+          return result;\n+        }\n+        \n+        private org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment buildParsed()\n+            throws com.google.protobuf.InvalidProtocolBufferException {\n+          org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment result = buildPartial();\n+          if (!result.isInitialized()) {\n+            throw newUninitializedMessageException(\n+              result).asInvalidProtocolBufferException();\n+          }\n+          return result;\n+        }\n+        \n+        public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment buildPartial() {\n+          org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment result = new org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment(this);\n+          int from_bitField0_ = bitField0_;\n+          int to_bitField0_ = 0;\n+          if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+            ensembleMember_ = new com.google.protobuf.UnmodifiableLazyStringList(\n+                ensembleMember_);\n+            bitField0_ = (bitField0_ & ~0x00000001);\n+          }\n+          result.ensembleMember_ = ensembleMember_;\n+          if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n+            to_bitField0_ |= 0x00000001;\n+          }\n+          result.firstEntryId_ = firstEntryId_;\n+          result.bitField0_ = to_bitField0_;\n+          onBuilt();\n+          return result;\n+        }\n+        \n+        public Builder mergeFrom(com.google.protobuf.Message other) {\n+          if (other instanceof org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment) {\n+            return mergeFrom((org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment)other);\n+          } else {\n+            super.mergeFrom(other);\n+            return this;\n+          }\n+        }\n+        \n+        public Builder mergeFrom(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment other) {\n+          if (other == org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.getDefaultInstance()) return this;\n+          if (!other.ensembleMember_.isEmpty()) {\n+            if (ensembleMember_.isEmpty()) {\n+              ensembleMember_ = other.ensembleMember_;\n+              bitField0_ = (bitField0_ & ~0x00000001);\n+            } else {\n+              ensureEnsembleMemberIsMutable();\n+              ensembleMember_.addAll(other.ensembleMember_);\n+            }\n+            onChanged();\n+          }\n+          if (other.hasFirstEntryId()) {\n+            setFirstEntryId(other.getFirstEntryId());\n+          }\n+          this.mergeUnknownFields(other.getUnknownFields());\n+          return this;\n+        }\n+        \n+        public final boolean isInitialized() {\n+          if (!hasFirstEntryId()) {\n+            \n+            return false;\n+          }\n+          return true;\n+        }\n+        \n+        public Builder mergeFrom(\n+            com.google.protobuf.CodedInputStream input,\n+            com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+            throws java.io.IOException {\n+          com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+            com.google.protobuf.UnknownFieldSet.newBuilder(\n+              this.getUnknownFields());\n+          while (true) {\n+            int tag = input.readTag();\n+            switch (tag) {\n+              case 0:\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              default: {\n+                if (!parseUnknownField(input, unknownFields,\n+                                       extensionRegistry, tag)) {\n+                  this.setUnknownFields(unknownFields.build());\n+                  onChanged();\n+                  return this;\n+                }\n+                break;\n+              }\n+              case 10: {\n+                ensureEnsembleMemberIsMutable();\n+                ensembleMember_.add(input.readBytes());\n+                break;\n+              }\n+              case 16: {\n+                bitField0_ |= 0x00000002;\n+                firstEntryId_ = input.readInt64();\n+                break;\n+              }\n+            }\n+          }\n+        }\n+        \n+        private int bitField0_;\n+        \n+        // repeated string ensembleMember = 1;\n+        private com.google.protobuf.LazyStringList ensembleMember_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+        private void ensureEnsembleMemberIsMutable() {\n+          if (!((bitField0_ & 0x00000001) == 0x00000001)) {\n+            ensembleMember_ = new com.google.protobuf.LazyStringArrayList(ensembleMember_);\n+            bitField0_ |= 0x00000001;\n+           }\n+        }\n+        public java.util.List<String>\n+            getEnsembleMemberList() {\n+          return java.util.Collections.unmodifiableList(ensembleMember_);\n+        }\n+        public int getEnsembleMemberCount() {\n+          return ensembleMember_.size();\n+        }\n+        public String getEnsembleMember(int index) {\n+          return ensembleMember_.get(index);\n+        }\n+        public Builder setEnsembleMember(\n+            int index, String value) {\n+          if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  ensureEnsembleMemberIsMutable();\n+          ensembleMember_.set(index, value);\n+          onChanged();\n+          return this;\n+        }\n+        public Builder addEnsembleMember(String value) {\n+          if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  ensureEnsembleMemberIsMutable();\n+          ensembleMember_.add(value);\n+          onChanged();\n+          return this;\n+        }\n+        public Builder addAllEnsembleMember(\n+            java.lang.Iterable<String> values) {\n+          ensureEnsembleMemberIsMutable();\n+          super.addAll(values, ensembleMember_);\n+          onChanged();\n+          return this;\n+        }\n+        public Builder clearEnsembleMember() {\n+          ensembleMember_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+          onChanged();\n+          return this;\n+        }\n+        void addEnsembleMember(com.google.protobuf.ByteString value) {\n+          ensureEnsembleMemberIsMutable();\n+          ensembleMember_.add(value);\n+          onChanged();\n+        }\n+        \n+        // required int64 firstEntryId = 2;\n+        private long firstEntryId_ ;\n+        public boolean hasFirstEntryId() {\n+          return ((bitField0_ & 0x00000002) == 0x00000002);\n+        }\n+        public long getFirstEntryId() {\n+          return firstEntryId_;\n+        }\n+        public Builder setFirstEntryId(long value) {\n+          bitField0_ |= 0x00000002;\n+          firstEntryId_ = value;\n+          onChanged();\n+          return this;\n+        }\n+        public Builder clearFirstEntryId() {\n+          bitField0_ = (bitField0_ & ~0x00000002);\n+          firstEntryId_ = 0L;\n+          onChanged();\n+          return this;\n+        }\n+        \n+        // @@protoc_insertion_point(builder_scope:LedgerMetadataFormat.Segment)\n+      }\n+      \n+      static {\n+        defaultInstance = new Segment(true);\n+        defaultInstance.initFields();\n+      }\n+      \n+      // @@protoc_insertion_point(class_scope:LedgerMetadataFormat.Segment)\n+    }\n+    \n+    private int bitField0_;\n+    // required int32 quorumSize = 1;\n+    public static final int QUORUMSIZE_FIELD_NUMBER = 1;\n+    private int quorumSize_;\n+    public boolean hasQuorumSize() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public int getQuorumSize() {\n+      return quorumSize_;\n+    }\n+    \n+    // required int32 ensembleSize = 2;\n+    public static final int ENSEMBLESIZE_FIELD_NUMBER = 2;\n+    private int ensembleSize_;\n+    public boolean hasEnsembleSize() {\n+      return ((bitField0_ & 0x00000002) == 0x00000002);\n+    }\n+    public int getEnsembleSize() {\n+      return ensembleSize_;\n+    }\n+    \n+    // required int64 length = 3;\n+    public static final int LENGTH_FIELD_NUMBER = 3;\n+    private long length_;\n+    public boolean hasLength() {\n+      return ((bitField0_ & 0x00000004) == 0x00000004);\n+    }\n+    public long getLength() {\n+      return length_;\n+    }\n+    \n+    // optional int64 lastEntryId = 4;\n+    public static final int LASTENTRYID_FIELD_NUMBER = 4;\n+    private long lastEntryId_;\n+    public boolean hasLastEntryId() {\n+      return ((bitField0_ & 0x00000008) == 0x00000008);\n+    }\n+    public long getLastEntryId() {\n+      return lastEntryId_;\n+    }\n+    \n+    // required .LedgerMetadataFormat.State state = 5 [default = OPEN];\n+    public static final int STATE_FIELD_NUMBER = 5;\n+    private org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State state_;\n+    public boolean hasState() {\n+      return ((bitField0_ & 0x00000010) == 0x00000010);\n+    }\n+    public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State getState() {\n+      return state_;\n+    }\n+    \n+    // repeated .LedgerMetadataFormat.Segment segment = 6;\n+    public static final int SEGMENT_FIELD_NUMBER = 6;\n+    private java.util.List<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment> segment_;\n+    public java.util.List<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment> getSegmentList() {\n+      return segment_;\n+    }\n+    public java.util.List<? extends org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder> \n+        getSegmentOrBuilderList() {\n+      return segment_;\n+    }\n+    public int getSegmentCount() {\n+      return segment_.size();\n+    }\n+    public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment getSegment(int index) {\n+      return segment_.get(index);\n+    }\n+    public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder getSegmentOrBuilder(\n+        int index) {\n+      return segment_.get(index);\n+    }\n+    \n+    private void initFields() {\n+      quorumSize_ = 0;\n+      ensembleSize_ = 0;\n+      length_ = 0L;\n+      lastEntryId_ = 0L;\n+      state_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State.OPEN;\n+      segment_ = java.util.Collections.emptyList();\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasQuorumSize()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!hasEnsembleSize()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!hasLength()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!hasState()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      for (int i = 0; i < getSegmentCount(); i++) {\n+        if (!getSegment(i).isInitialized()) {\n+          memoizedIsInitialized = 0;\n+          return false;\n+        }\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeInt32(1, quorumSize_);\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        output.writeInt32(2, ensembleSize_);\n+      }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        output.writeInt64(3, length_);\n+      }\n+      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        output.writeInt64(4, lastEntryId_);\n+      }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n+        output.writeEnum(5, state_.getNumber());\n+      }\n+      for (int i = 0; i < segment_.size(); i++) {\n+        output.writeMessage(6, segment_.get(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(1, quorumSize_);\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(2, ensembleSize_);\n+      }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt64Size(3, length_);\n+      }\n+      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt64Size(4, lastEntryId_);\n+      }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeEnumSize(5, state_.getNumber());\n+      }\n+      for (int i = 0; i < segment_.size(); i++) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(6, segment_.get(i));\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormatOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerMetadataFormat_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+          getSegmentFieldBuilder();\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        quorumSize_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        ensembleSize_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        length_ = 0L;\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        lastEntryId_ = 0L;\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        state_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State.OPEN;\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        if (segmentBuilder_ == null) {\n+          segment_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000020);\n+        } else {\n+          segmentBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.getDescriptor();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat getDefaultInstanceForType() {\n+        return org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.getDefaultInstance();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat build() {\n+        org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat buildPartial() {\n+        org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat result = new org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.quorumSize_ = quorumSize_;\n+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.ensembleSize_ = ensembleSize_;\n+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        result.length_ = length_;\n+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        result.lastEntryId_ = lastEntryId_;\n+        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        result.state_ = state_;\n+        if (segmentBuilder_ == null) {\n+          if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+            segment_ = java.util.Collections.unmodifiableList(segment_);\n+            bitField0_ = (bitField0_ & ~0x00000020);\n+          }\n+          result.segment_ = segment_;\n+        } else {\n+          result.segment_ = segmentBuilder_.build();\n+        }\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat) {\n+          return mergeFrom((org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat other) {\n+        if (other == org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.getDefaultInstance()) return this;\n+        if (other.hasQuorumSize()) {\n+          setQuorumSize(other.getQuorumSize());\n+        }\n+        if (other.hasEnsembleSize()) {\n+          setEnsembleSize(other.getEnsembleSize());\n+        }\n+        if (other.hasLength()) {\n+          setLength(other.getLength());\n+        }\n+        if (other.hasLastEntryId()) {\n+          setLastEntryId(other.getLastEntryId());\n+        }\n+        if (other.hasState()) {\n+          setState(other.getState());\n+        }\n+        if (segmentBuilder_ == null) {\n+          if (!other.segment_.isEmpty()) {\n+            if (segment_.isEmpty()) {\n+              segment_ = other.segment_;\n+              bitField0_ = (bitField0_ & ~0x00000020);\n+            } else {\n+              ensureSegmentIsMutable();\n+              segment_.addAll(other.segment_);\n+            }\n+            onChanged();\n+          }\n+        } else {\n+          if (!other.segment_.isEmpty()) {\n+            if (segmentBuilder_.isEmpty()) {\n+              segmentBuilder_.dispose();\n+              segmentBuilder_ = null;\n+              segment_ = other.segment_;\n+              bitField0_ = (bitField0_ & ~0x00000020);\n+              segmentBuilder_ = \n+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?\n+                   getSegmentFieldBuilder() : null;\n+            } else {\n+              segmentBuilder_.addAllMessages(other.segment_);\n+            }\n+          }\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasQuorumSize()) {\n+          \n+          return false;\n+        }\n+        if (!hasEnsembleSize()) {\n+          \n+          return false;\n+        }\n+        if (!hasLength()) {\n+          \n+          return false;\n+        }\n+        if (!hasState()) {\n+          \n+          return false;\n+        }\n+        for (int i = 0; i < getSegmentCount(); i++) {\n+          if (!getSegment(i).isInitialized()) {\n+            \n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 8: {\n+              bitField0_ |= 0x00000001;\n+              quorumSize_ = input.readInt32();\n+              break;\n+            }\n+            case 16: {\n+              bitField0_ |= 0x00000002;\n+              ensembleSize_ = input.readInt32();\n+              break;\n+            }\n+            case 24: {\n+              bitField0_ |= 0x00000004;\n+              length_ = input.readInt64();\n+              break;\n+            }\n+            case 32: {\n+              bitField0_ |= 0x00000008;\n+              lastEntryId_ = input.readInt64();\n+              break;\n+            }\n+            case 40: {\n+              int rawValue = input.readEnum();\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State value = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State.valueOf(rawValue);\n+              if (value == null) {\n+                unknownFields.mergeVarintField(5, rawValue);\n+              } else {\n+                bitField0_ |= 0x00000010;\n+                state_ = value;\n+              }\n+              break;\n+            }\n+            case 50: {\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder subBuilder = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.newBuilder();\n+              input.readMessage(subBuilder, extensionRegistry);\n+              addSegment(subBuilder.buildPartial());\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required int32 quorumSize = 1;\n+      private int quorumSize_ ;\n+      public boolean hasQuorumSize() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public int getQuorumSize() {\n+        return quorumSize_;\n+      }\n+      public Builder setQuorumSize(int value) {\n+        bitField0_ |= 0x00000001;\n+        quorumSize_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearQuorumSize() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        quorumSize_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // required int32 ensembleSize = 2;\n+      private int ensembleSize_ ;\n+      public boolean hasEnsembleSize() {\n+        return ((bitField0_ & 0x00000002) == 0x00000002);\n+      }\n+      public int getEnsembleSize() {\n+        return ensembleSize_;\n+      }\n+      public Builder setEnsembleSize(int value) {\n+        bitField0_ |= 0x00000002;\n+        ensembleSize_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearEnsembleSize() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        ensembleSize_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // required int64 length = 3;\n+      private long length_ ;\n+      public boolean hasLength() {\n+        return ((bitField0_ & 0x00000004) == 0x00000004);\n+      }\n+      public long getLength() {\n+        return length_;\n+      }\n+      public Builder setLength(long value) {\n+        bitField0_ |= 0x00000004;\n+        length_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearLength() {\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        length_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional int64 lastEntryId = 4;\n+      private long lastEntryId_ ;\n+      public boolean hasLastEntryId() {\n+        return ((bitField0_ & 0x00000008) == 0x00000008);\n+      }\n+      public long getLastEntryId() {\n+        return lastEntryId_;\n+      }\n+      public Builder setLastEntryId(long value) {\n+        bitField0_ |= 0x00000008;\n+        lastEntryId_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearLastEntryId() {\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        lastEntryId_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // required .LedgerMetadataFormat.State state = 5 [default = OPEN];\n+      private org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State state_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State.OPEN;\n+      public boolean hasState() {\n+        return ((bitField0_ & 0x00000010) == 0x00000010);\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State getState() {\n+        return state_;\n+      }\n+      public Builder setState(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State value) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        bitField0_ |= 0x00000010;\n+        state_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearState() {\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        state_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State.OPEN;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // repeated .LedgerMetadataFormat.Segment segment = 6;\n+      private java.util.List<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment> segment_ =\n+        java.util.Collections.emptyList();\n+      private void ensureSegmentIsMutable() {\n+        if (!((bitField0_ & 0x00000020) == 0x00000020)) {\n+          segment_ = new java.util.ArrayList<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment>(segment_);\n+          bitField0_ |= 0x00000020;\n+         }\n+      }\n+      \n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder> segmentBuilder_;\n+      \n+      public java.util.List<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment> getSegmentList() {\n+        if (segmentBuilder_ == null) {\n+          return java.util.Collections.unmodifiableList(segment_);\n+        } else {\n+          return segmentBuilder_.getMessageList();\n+        }\n+      }\n+      public int getSegmentCount() {\n+        if (segmentBuilder_ == null) {\n+          return segment_.size();\n+        } else {\n+          return segmentBuilder_.getCount();\n+        }\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment getSegment(int index) {\n+        if (segmentBuilder_ == null) {\n+          return segment_.get(index);\n+        } else {\n+          return segmentBuilder_.getMessage(index);\n+        }\n+      }\n+      public Builder setSegment(\n+          int index, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment value) {\n+        if (segmentBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSegmentIsMutable();\n+          segment_.set(index, value);\n+          onChanged();\n+        } else {\n+          segmentBuilder_.setMessage(index, value);\n+        }\n+        return this;\n+      }\n+      public Builder setSegment(\n+          int index, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder builderForValue) {\n+        if (segmentBuilder_ == null) {\n+          ensureSegmentIsMutable();\n+          segment_.set(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          segmentBuilder_.setMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      public Builder addSegment(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment value) {\n+        if (segmentBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSegmentIsMutable();\n+          segment_.add(value);\n+          onChanged();\n+        } else {\n+          segmentBuilder_.addMessage(value);\n+        }\n+        return this;\n+      }\n+      public Builder addSegment(\n+          int index, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment value) {\n+        if (segmentBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          ensureSegmentIsMutable();\n+          segment_.add(index, value);\n+          onChanged();\n+        } else {\n+          segmentBuilder_.addMessage(index, value);\n+        }\n+        return this;\n+      }\n+      public Builder addSegment(\n+          org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder builderForValue) {\n+        if (segmentBuilder_ == null) {\n+          ensureSegmentIsMutable();\n+          segment_.add(builderForValue.build());\n+          onChanged();\n+        } else {\n+          segmentBuilder_.addMessage(builderForValue.build());\n+        }\n+        return this;\n+      }\n+      public Builder addSegment(\n+          int index, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder builderForValue) {\n+        if (segmentBuilder_ == null) {\n+          ensureSegmentIsMutable();\n+          segment_.add(index, builderForValue.build());\n+          onChanged();\n+        } else {\n+          segmentBuilder_.addMessage(index, builderForValue.build());\n+        }\n+        return this;\n+      }\n+      public Builder addAllSegment(\n+          java.lang.Iterable<? extends org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment> values) {\n+        if (segmentBuilder_ == null) {\n+          ensureSegmentIsMutable();\n+          super.addAll(values, segment_);\n+          onChanged();\n+        } else {\n+          segmentBuilder_.addAllMessages(values);\n+        }\n+        return this;\n+      }\n+      public Builder clearSegment() {\n+        if (segmentBuilder_ == null) {\n+          segment_ = java.util.Collections.emptyList();\n+          bitField0_ = (bitField0_ & ~0x00000020);\n+          onChanged();\n+        } else {\n+          segmentBuilder_.clear();\n+        }\n+        return this;\n+      }\n+      public Builder removeSegment(int index) {\n+        if (segmentBuilder_ == null) {\n+          ensureSegmentIsMutable();\n+          segment_.remove(index);\n+          onChanged();\n+        } else {\n+          segmentBuilder_.remove(index);\n+        }\n+        return this;\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder getSegmentBuilder(\n+          int index) {\n+        return getSegmentFieldBuilder().getBuilder(index);\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder getSegmentOrBuilder(\n+          int index) {\n+        if (segmentBuilder_ == null) {\n+          return segment_.get(index);  } else {\n+          return segmentBuilder_.getMessageOrBuilder(index);\n+        }\n+      }\n+      public java.util.List<? extends org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder> \n+           getSegmentOrBuilderList() {\n+        if (segmentBuilder_ != null) {\n+          return segmentBuilder_.getMessageOrBuilderList();\n+        } else {\n+          return java.util.Collections.unmodifiableList(segment_);\n+        }\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder addSegmentBuilder() {\n+        return getSegmentFieldBuilder().addBuilder(\n+            org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.getDefaultInstance());\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder addSegmentBuilder(\n+          int index) {\n+        return getSegmentFieldBuilder().addBuilder(\n+            index, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.getDefaultInstance());\n+      }\n+      public java.util.List<org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder> \n+           getSegmentBuilderList() {\n+        return getSegmentFieldBuilder().getBuilderList();\n+      }\n+      private com.google.protobuf.RepeatedFieldBuilder<\n+          org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder> \n+          getSegmentFieldBuilder() {\n+        if (segmentBuilder_ == null) {\n+          segmentBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder, org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder>(\n+                  segment_,\n+                  ((bitField0_ & 0x00000020) == 0x00000020),\n+                  getParentForChildren(),\n+                  isClean());\n+          segment_ = null;\n+        }\n+        return segmentBuilder_;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:LedgerMetadataFormat)\n+    }\n+    \n+    static {\n+      defaultInstance = new LedgerMetadataFormat(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:LedgerMetadataFormat)\n+  }\n+  \n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_LedgerMetadataFormat_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_LedgerMetadataFormat_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_LedgerMetadataFormat_Segment_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_LedgerMetadataFormat_Segment_fieldAccessorTable;\n+  \n+  public static com.google.protobuf.Descriptors.FileDescriptor\n+      getDescriptor() {\n+    return descriptor;\n+  }\n+  private static com.google.protobuf.Descriptors.FileDescriptor\n+      descriptor;\n+  static {\n+    java.lang.String[] descriptorData = {\n+      \"\\n src/main/proto/DataFormats.proto\\\"\\260\\002\\n\\024L\" +\n+      \"edgerMetadataFormat\\022\\022\\n\\nquorumSize\\030\\001 \\002(\\005\\022\" +\n+      \"\\024\\n\\014ensembleSize\\030\\002 \\002(\\005\\022\\016\\n\\006length\\030\\003 \\002(\\003\\022\\023\\n\" +\n+      \"\\013lastEntryId\\030\\004 \\001(\\003\\0220\\n\\005state\\030\\005 \\002(\\0162\\033.Ledg\" +\n+      \"erMetadataFormat.State:\\004OPEN\\022.\\n\\007segment\\030\" +\n+      \"\\006 \\003(\\0132\\035.LedgerMetadataFormat.Segment\\0327\\n\\007\" +\n+      \"Segment\\022\\026\\n\\016ensembleMember\\030\\001 \\003(\\t\\022\\024\\n\\014first\" +\n+      \"EntryId\\030\\002 \\002(\\003\\\".\\n\\005State\\022\\010\\n\\004OPEN\\020\\001\\022\\017\\n\\013IN_R\" +\n+      \"ECOVERY\\020\\002\\022\\n\\n\\006CLOSED\\020\\003B\\037\\n\\033org.apache.book\" +\n+      \"keeper.protoH\\001\"\n+    };\n+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n+      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n+        public com.google.protobuf.ExtensionRegistry assignDescriptors(\n+            com.google.protobuf.Descriptors.FileDescriptor root) {\n+          descriptor = root;\n+          internal_static_LedgerMetadataFormat_descriptor =\n+            getDescriptor().getMessageTypes().get(0);\n+          internal_static_LedgerMetadataFormat_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_LedgerMetadataFormat_descriptor,\n+              new java.lang.String[] { \"QuorumSize\", \"EnsembleSize\", \"Length\", \"LastEntryId\", \"State\", \"Segment\", },\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.class,\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Builder.class);\n+          internal_static_LedgerMetadataFormat_Segment_descriptor =\n+            internal_static_LedgerMetadataFormat_descriptor.getNestedTypes().get(0);\n+          internal_static_LedgerMetadataFormat_Segment_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_LedgerMetadataFormat_Segment_descriptor,\n+              new java.lang.String[] { \"EnsembleMember\", \"FirstEntryId\", },\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.class,\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder.class);\n+          return null;\n+        }\n+      };\n+    com.google.protobuf.Descriptors.FileDescriptor\n+      .internalBuildGeneratedFileFrom(descriptorData,\n+        new com.google.protobuf.Descriptors.FileDescriptor[] {\n+        }, assigner);\n+  }\n+  \n+  // @@protoc_insertion_point(outer_class_scope)\n+}"},{"sha":"8703bfca395a7285ef377f594adf9034979ac6f6","filename":"bookkeeper-server/src/main/proto/DataFormats.proto","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/proto/DataFormats.proto","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/proto/DataFormats.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/proto/DataFormats.proto?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -0,0 +1,42 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+option java_package = \"org.apache.bookkeeper.proto\";\n+option optimize_for = SPEED;\n+\n+/**\n+* Metadata format for storing ledger information\n+*/\n+message LedgerMetadataFormat {\n+    required int32 quorumSize = 1;\n+    required int32 ensembleSize = 2;\n+    required int64 length = 3;\n+    optional int64 lastEntryId = 4;\n+\n+    enum State {\n+        OPEN = 1;\n+        IN_RECOVERY = 2;\n+        CLOSED = 3;\n+    }\n+    required State state = 5 [default = OPEN];\n+\n+    message Segment {\n+        repeated string ensembleMember = 1;\n+        required int64 firstEntryId = 2; \n+    }\n+    repeated Segment segment = 6;\n+}\n\\ No newline at end of file"},{"sha":"129943423fb222d7a9fa659efe3007f3692d0a3b","filename":"bookkeeper-server/src/main/resources/LICENSE.bin.txt","status":"modified","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/resources/LICENSE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/resources/LICENSE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/resources/LICENSE.bin.txt?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -226,6 +226,43 @@ For lib/slf4j-*.jar\n  OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n+------------------------------------------------------------------------------------\n+For lib/protobuf-java-*.jar\n+\n+Copyright 2008, Google Inc.\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    * Redistributions of source code must retain the above copyright\n+notice, this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above\n+copyright notice, this list of conditions and the following disclaimer\n+in the documentation and/or other materials provided with the\n+distribution.\n+    * Neither the name of Google Inc. nor the names of its\n+contributors may be used to endorse or promote products derived from\n+this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+Code generated by the Protocol Buffer compiler is owned by the owner\n+of the input file used when generating it.  This code is not\n+standalone and requires a support library to be linked with it.  This\n+support library is itself covered by the above license.\n+\n ------------------------------------------------------------------------------------\n For lib/jline-*.jar\n "},{"sha":"2aa0e2dffdcfd099c4c1c49badea69a188d85c62","filename":"bookkeeper-server/src/main/resources/NOTICE.bin.txt","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/resources/NOTICE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/main/resources/NOTICE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/resources/NOTICE.bin.txt?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -30,4 +30,4 @@ This project includes:\n   SLF4J LOG4J-12 Binding under MIT License\n   The Netty Project under Apache License, Version 2.0\n   ZooKeeper under Apache License, Version 2.0\n-\n+  Protocol Buffer Java API under New BSD license"},{"sha":"74437db243f2f7e6c8cde8549538c951053002f4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -469,7 +469,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n         ranges.put(keyList.get(keyList.size()-1), untilEntry);\n \n         for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : ensembles.entrySet()) {\n-            int quorum = md.quorumSize;\n+            int quorum = md.getQuorumSize();\n             long startEntryId = e.getKey();\n             long endEntryId = ranges.get(startEntryId);\n             long expectedSuccess = quorum*(endEntryId-startEntryId);"},{"sha":"4ed36117e0ae346fa023c39846fc9184c1786986","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","status":"modified","additions":85,"deletions":31,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -26,6 +26,9 @@\n import java.util.Arrays;\n import java.net.InetAddress;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import org.junit.Test;\n import org.junit.Before;\n import org.junit.After;\n@@ -34,6 +37,8 @@\n import org.apache.bookkeeper.bookie.FileSystemUpgrade;\n \n public class TestBackwardCompat {\n+    static Logger LOG = LoggerFactory.getLogger(TestBackwardCompat.class);\n+\n     private static ZooKeeperUtil zkUtil = new ZooKeeperUtil();;\n     private static int nextPort = 3181;\n     private static byte[] ENTRY_DATA = \"ThisIsAnEntry\".getBytes();\n@@ -140,11 +145,14 @@ long readAll() throws Exception {\n         }\n \n         void close() throws Exception {\n-            if (lh != null) {\n-                lh.close();\n-            }\n-            if (bk != null) {\n-                bk.close();\n+            try {\n+                if (lh != null) {\n+                    lh.close();\n+                }\n+            } finally {\n+                if (bk != null) {\n+                    bk.close();\n+                }\n             }\n         }\n     }\n@@ -234,11 +242,14 @@ long readAll() throws Exception {\n         }\n \n         void close() throws Exception {\n-            if (lh != null) {\n-                lh.close();\n-            }\n-            if (bk != null) {\n-                bk.close();\n+            try {\n+                if (lh != null) {\n+                    lh.close();\n+                }\n+            } finally {\n+                if (bk != null) {\n+                    bk.close();\n+                }\n             }\n         }\n     }\n@@ -328,11 +339,14 @@ long readAll() throws Exception {\n         }\n \n         void close() throws Exception {\n-            if (lh != null) {\n-                lh.close();\n-            }\n-            if (bk != null) {\n-                bk.close();\n+            try {\n+                if (lh != null) {\n+                    lh.close();\n+                }\n+            } finally {\n+                if (bk != null) {\n+                    bk.close();\n+                }\n             }\n         }\n     }\n@@ -417,16 +431,8 @@ public void testCompat400() throws Exception {\n             // correct behaviour\n         }\n         lcur.write100();\n-        try {\n-            // Unfortunately, as the 4.0.0 client doesn't know that it should\n-            // be checking for a password. It puts the ledger metadata in recover\n-            // mode. This means we're not able to close, as our metadata znode is\n-            // out of date\n-            lcur.close();\n+        lcur.close();\n \n-            fail(\"Shouldn't be able to close cleanly\");\n-        } catch (Exception e) {\n-        }\n         lcur = LedgerCurrent.openLedger(fenceLedgerId);\n         assertEquals(200, lcur.readAll());\n         lcur.close();\n@@ -436,7 +442,9 @@ public void testCompat400() throws Exception {\n \n     /**\n      * Test compatability between version 4.1.0 and the current version.\n-     * Should be 100% compatible.\n+     *  - A 4.1.0 client is not able to open a ledger created by the current\n+     *    version due to a change in the ledger metadata format.\n+     *  - Otherwise, they should be compatible.\n      */\n     @Test\n     public void testCompat410() throws Exception {\n@@ -478,6 +486,51 @@ public void testCompat410() throws Exception {\n         l410.write100();\n         l410.close();\n \n+        // check that an old client can fence an old client\n+        l410 = Ledger410.newLedger();\n+        l410.write100();\n+\n+        Ledger410 l410f = Ledger410.openLedger(l410.getId());\n+        try {\n+            l410.write100();\n+            fail(\"Shouldn't be able to write\");\n+        } catch (Exception e) {\n+            // correct behaviour\n+        }\n+        l410f.close();\n+        try {\n+            l410.close();\n+            fail(\"Shouldn't be able to close\");\n+        } catch (Exception e) {\n+            // correct\n+        }\n+\n+        // check that a new client can fence an old client\n+        // and the old client can continue to read that ledger\n+        l410 = Ledger410.newLedger();\n+        l410.write100();\n+\n+        oldLedgerId = l410.getId();\n+        lcur = LedgerCurrent.openLedger(oldLedgerId);\n+        try {\n+            l410.write100();\n+            fail(\"Shouldn't be able to write\");\n+        } catch (Exception e) {\n+            // correct behaviour\n+        }\n+        try {\n+            l410.close();\n+            fail(\"Shouldn't be able to close\");\n+        } catch (Exception e) {\n+            // correct\n+        }\n+        lcur.close();\n+\n+        l410 = Ledger410.openLedger(oldLedgerId);\n+\n+        assertEquals(100, l410.readAll());\n+        l410.close();\n+\n         // check that current client can read old ledger\n         lcur = LedgerCurrent.openLedger(oldLedgerId);\n         assertEquals(100, lcur.readAll());\n@@ -488,18 +541,19 @@ public void testCompat410() throws Exception {\n         assertEquals(100, lcur.readAll());\n         lcur.close();\n \n-        // check that old client can fence a current client\n-        // due to lack of password\n+        // check that old client can not fence a current client\n+        // since it cannot open a new ledger due to the format changes\n         lcur = LedgerCurrent.newLedger();\n         lcur.write100();\n         long fenceLedgerId = lcur.getId();\n-        l410 = Ledger410.openLedger(fenceLedgerId);\n         try {\n-            lcur.write100();\n-            fail(\"Fencing should have prevented this write\");\n+            l410 = Ledger410.openLedger(fenceLedgerId);\n+            fail(\"Shouldn't be able to open ledger\");\n         } catch (Exception e) {\n+            // correct behaviour\n         }\n-        assertEquals(100, l410.readAll());\n+        lcur.write100();\n+        lcur.close();\n \n         scur.stop();\n     }"},{"sha":"6e73a2238b8d58a5a4f8b65a96ac8f2c23a0a40b","filename":"hedwig-protocol/pom.xml","status":"modified","additions":32,"deletions":20,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/hedwig-protocol/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/hedwig-protocol/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/pom.xml?ref=744edf07394472d3146e57831592a69d5a86616c","patch":"@@ -32,7 +32,7 @@\n     <dependency>\n       <groupId>com.google.protobuf</groupId>\n       <artifactId>protobuf-java</artifactId>\n-      <version>2.3.0</version>\n+      <version>2.4.1</version>\n       <scope>compile</scope>\n     </dependency>\n     <dependency>\n@@ -65,25 +65,37 @@\n \t  </excludes>\n \t</configuration>\n       </plugin>\n-      <plugin>\n-        <artifactId>maven-antrun-plugin</artifactId>\n-        <executions>\n-          <execution>\n-            <id>default-cli</id>\n-            <configuration>\n-              <tasks>\n-                <exec executable=\"protoc\" failonerror=\"true\">\n-                  <arg value=\"--java_out=src/main/java\" />\n-                  <arg value=\"src/main/protobuf/PubSubProtocol.proto\" />\n-                </exec>\n-              </tasks>\n-            </configuration>\n-            <goals>\n-              <goal>run</goal>\n-            </goals>\n-          </execution>\n-        </executions>\n-      </plugin>\n     </plugins>\n   </build>\n+  <profiles>\n+    <profile>\n+      <id>protobuf</id>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <artifactId>maven-antrun-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <phase>generate-sources</phase>\n+                <id>default-cli</id>\n+                <configuration>\n+                  <target>\n+\t\t    <echo message=\"foo\" />\n+                    <exec executable=\"protoc\" failonerror=\"true\">\n+                      <arg value=\"--java_out=src/main/java\" />\n+                      <arg value=\"src/main/protobuf/PubSubProtocol.proto\" />\n+                    </exec>\n+\t\t    <echo message=\"bar\" />\n+                  </target>\n+                </configuration>\n+                <goals>\n+                  <goal>run</goal>\n+                </goals>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+      </build>\n+    </profile>\n+  </profiles>\n </project>"},{"sha":"a37f945367e11bc6f34f5b0c884f726e13f155b6","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":4054,"deletions":1363,"changes":5417,"blob_url":"https://github.com/apache/bookkeeper/blob/744edf07394472d3146e57831592a69d5a86616c/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/744edf07394472d3146e57831592a69d5a86616c/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=744edf07394472d3146e57831592a69d5a86616c"}]}

