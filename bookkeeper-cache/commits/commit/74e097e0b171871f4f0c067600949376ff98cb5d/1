{"sha":"74e097e0b171871f4f0c067600949376ff98cb5d","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3NGUwOTdlMGIxNzE4NzFmNGYwYzA2NzYwMDk0OTM3NmZmOThjYjVk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-14T09:40:34Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-14T09:40:34Z"},"message":"BOOKKEEPER-246: Recording of underreplication of ledger entries (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1372808 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"906af0fe13ecbd5b377497b9b16a7d1939589901","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/906af0fe13ecbd5b377497b9b16a7d1939589901"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/74e097e0b171871f4f0c067600949376ff98cb5d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/74e097e0b171871f4f0c067600949376ff98cb5d","html_url":"https://github.com/apache/bookkeeper/commit/74e097e0b171871f4f0c067600949376ff98cb5d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/74e097e0b171871f4f0c067600949376ff98cb5d/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"391f9246890b416398e48886fe5ed3c4d2e866ab","url":"https://api.github.com/repos/apache/bookkeeper/commits/391f9246890b416398e48886fe5ed3c4d2e866ab","html_url":"https://github.com/apache/bookkeeper/commit/391f9246890b416398e48886fe5ed3c4d2e866ab"}],"stats":{"total":1771,"additions":1748,"deletions":23},"files":[{"sha":"1724adc8267993090e434cb53a7a957039855cf7","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -80,6 +80,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-317: Exceptions for replication (ivank via sijie)\n \n+        BOOKKEEPER-246: Recording of underreplication of ledger entries (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"cafc1a7462a714c944d9d5adc9c7d9a866d653c4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -20,6 +20,8 @@\n \n import java.io.IOException;\n \n+import org.apache.zookeeper.KeeperException;\n+import org.apache.bookkeeper.replication.ReplicationException;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.zookeeper.ZooKeeper;\n \n@@ -69,4 +71,9 @@ public ActiveLedgerManager newActiveLedgerManager() {\n         return new FlatLedgerManager(conf, zk);\n     }\n \n+    @Override\n+    public LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n+            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {\n+        return new ZkLedgerUnderreplicationManager(conf, zk);\n+    }\n }"},{"sha":"bb28edeb6598a0f0857f94d309aa39d08f9badaa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -20,6 +20,8 @@\n \n import java.io.IOException;\n \n+import org.apache.zookeeper.KeeperException;\n+import org.apache.bookkeeper.replication.ReplicationException;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.zookeeper.ZooKeeper;\n \n@@ -69,4 +71,9 @@ public ActiveLedgerManager newActiveLedgerManager() {\n         return new HierarchicalLedgerManager(conf, zk);\n     }\n \n+    @Override\n+    public LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n+            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException{\n+        return new ZkLedgerUnderreplicationManager(conf, zk);\n+    }\n }"},{"sha":"57870e3acdc9951b8aa20f6b61e734de4ac5d0df","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -23,6 +23,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import org.apache.bookkeeper.replication.ReplicationException;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.zookeeper.KeeperException;\n@@ -81,6 +82,17 @@ public abstract LedgerManagerFactory initialize(final AbstractConfiguration conf\n      */\n     public abstract ActiveLedgerManager newActiveLedgerManager();\n \n+    /**\n+     * Return a ledger underreplication manager, which is used to \n+     * mark ledgers as unreplicated, and to retrieve a ledger which\n+     * is underreplicated so that it can be rereplicated.\n+     *\n+     * @return ledger underreplication manager\n+     * @see LedgerUnderreplicationManager\n+     */\n+    public abstract LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n+            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException;\n+\n     /**\n      * Create new Ledger Manager Factory.\n      *"},{"sha":"0572fedf10a4ceabbbe197e4d6b464d542520ca3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import org.apache.bookkeeper.replication.ReplicationException;\n+\n+/**\n+ * Interface for marking ledgers which need to be rereplicated\n+ */\n+public interface LedgerUnderreplicationManager {\n+    /**\n+     * Mark a ledger as underreplicated. The replication should\n+     * then check which fragments are underreplicated and rereplicate them\n+     */\n+    void markLedgerUnderreplicated(long ledgerId, String missingReplica)\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Mark a ledger as fully replicated. If the ledger is not\n+     * already marked as underreplicated, this is a noop.\n+     */\n+    void markLedgerReplicated(long ledgerId)\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Acquire a underreplicated ledger for rereplication. The ledger\n+     * should be locked, so that no other agent will receive the ledger\n+     * from this call.\n+     * The ledger should remain locked until either #markLedgerComplete\n+     * or #releaseLedger are called.\n+     * This call is blocking, so will not return until a ledger is\n+     * available for rereplication.\n+     */\n+    long getLedgerToRereplicate()\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Release a previously acquired ledger. This allows others to acquire\n+     * the ledger\n+     */\n+    void releaseUnderreplicatedLedger(long ledgerId)\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Release all resources held by the ledger underreplication manager\n+     */\n+    void close()\n+            throws ReplicationException.UnavailableException;\n+}"},{"sha":"36f3a824685cfde6ced67624db6d5851f80d597b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"added","additions":394,"deletions":0,"changes":394,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -0,0 +1,394 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import org.apache.bookkeeper.replication.ReplicationException;\n+import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;\n+import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+\n+import com.google.protobuf.TextFormat;\n+\n+import java.nio.charset.Charset;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.Collections;\n+\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * ZooKeeper implementation of underreplication manager.\n+ * This is implemented in a heirarchical fashion, so it'll work with\n+ * FlatLedgerManagerFactory and HierarchicalLedgerManagerFactory.\n+ *\n+ * Layout is:\n+ * /root/underreplication/ LAYOUT\n+ *                         ledgers/(hierarchicalpath)/urL(ledgerId)\n+ *                         locks/(ledgerId)\n+ *\n+ * The hierarchical path is created by splitting the ledger into 4 2byte\n+ * segments which are represented in hexidecimal.\n+ * e.g. For ledger id 0xcafebeef0000feed, the path is\n+ *  cafe/beef/0000/feed/\n+ */\n+public class ZkLedgerUnderreplicationManager implements LedgerUnderreplicationManager {\n+    static final Logger LOG = LoggerFactory.getLogger(ZkLedgerUnderreplicationManager.class);\n+    static final Charset UTF8 = Charset.forName(\"UTF-8\");\n+\n+    static final String LAYOUT=\"BASIC\";\n+    static final int LAYOUT_VERSION=1;\n+\n+    private static class Lock {\n+        private final String lockZNode;\n+        private final int ledgerZNodeVersion;\n+\n+        Lock(String lockZNode, int ledgerZNodeVersion) {\n+            this.lockZNode = lockZNode;\n+            this.ledgerZNodeVersion = ledgerZNodeVersion;\n+        }\n+\n+        String getLockZNode() { return lockZNode; }\n+        int getLedgerZNodeVersion() { return ledgerZNodeVersion; }\n+    };\n+    private final Map<Long, Lock> heldLocks = new ConcurrentHashMap<Long, Lock>();\n+    private final Pattern idExtractionPattern;\n+\n+    private final String basePath;\n+    private final String urLedgerPath;\n+    private final String urLockPath;\n+    private final String layoutZNode;\n+\n+    private final ZooKeeper zkc;\n+\n+    public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc)\n+            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {\n+        basePath = conf.getZkLedgersRootPath() + \"/underreplication\";\n+        layoutZNode = basePath + \"/LAYOUT\";\n+        urLedgerPath = basePath + \"/ledgers\";\n+        urLockPath = basePath + \"/locks\";\n+\n+        idExtractionPattern = Pattern.compile(\"urL(\\\\d+)$\");\n+        this.zkc = zkc;\n+\n+        checkLayout();\n+    }\n+\n+    private void createOptimistic(String path, byte[] data) throws KeeperException, InterruptedException {\n+        try {\n+            zkc.create(path, data,\n+                       Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        } catch (KeeperException.NoNodeException nne) {\n+            int lastSlash = path.lastIndexOf('/');\n+            if (lastSlash <= 0) {\n+                throw nne;\n+            }\n+            String parent = path.substring(0, lastSlash);\n+            createOptimistic(parent, new byte[0]);\n+            zkc.create(path, data,\n+                       Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }        \n+    }\n+\n+    private void checkLayout()\n+            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {\n+        if (zkc.exists(basePath, false) == null) {\n+            try {\n+                zkc.create(basePath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            } catch (KeeperException.NodeExistsException nee) {\n+                // do nothing, someone each could have created it\n+            }\n+        }\n+        while (true) {\n+            if (zkc.exists(layoutZNode, false) == null) {\n+                LedgerRereplicationLayoutFormat.Builder builder\n+                    = LedgerRereplicationLayoutFormat.newBuilder();\n+                builder.setType(LAYOUT).setVersion(LAYOUT_VERSION);\n+                try {\n+                    zkc.create(layoutZNode, TextFormat.printToString(builder.build()).getBytes(UTF8),\n+                               Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+                } catch (KeeperException.NodeExistsException nne) {\n+                    // someone else managed to create it\n+                    continue;\n+                }\n+            } else {\n+                byte[] layoutData = zkc.getData(layoutZNode, false, null);\n+\n+                LedgerRereplicationLayoutFormat.Builder builder\n+                    = LedgerRereplicationLayoutFormat.newBuilder();\n+\n+                try {\n+                    TextFormat.merge(new String(layoutData, UTF8), builder);\n+                    LedgerRereplicationLayoutFormat layout = builder.build();\n+                    if (!layout.getType().equals(LAYOUT)\n+                            || layout.getVersion() != LAYOUT_VERSION) {\n+                        throw new ReplicationException.CompatibilityException(\n+                                \"Incompatible layout found (\" + LAYOUT + \":\" + LAYOUT_VERSION + \")\");\n+                    }\n+                } catch (TextFormat.ParseException pe) {\n+                    throw new ReplicationException.CompatibilityException(\n+                            \"Invalid data found\", pe);\n+                }\n+                break;\n+            }\n+        }\n+        if (zkc.exists(urLedgerPath, false) == null) {\n+            try {\n+                zkc.create(urLedgerPath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            } catch (KeeperException.NodeExistsException nee) {\n+                // do nothing, someone each could have created it\n+            }\n+        }\n+        if (zkc.exists(urLockPath, false) == null) {\n+            try {\n+                zkc.create(urLockPath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            } catch (KeeperException.NodeExistsException nee) {\n+                // do nothing, someone each could have created it\n+            }\n+        }\n+    }\n+\n+    private long getLedgerId(String path) throws NumberFormatException {\n+        Matcher m = idExtractionPattern.matcher(path);\n+        if (m.find()) {\n+            return Long.valueOf(m.group(1));\n+        } else {\n+            throw new NumberFormatException(\"Couldn't find ledgerid in path\");\n+        }\n+    }\n+\n+    private String getParentZnodePath(String base, long ledgerId) {\n+        String subdir1 = String.format(\"%04x\", ledgerId >> 48 & 0xffff);\n+        String subdir2 = String.format(\"%04x\", ledgerId >> 32 & 0xffff);\n+        String subdir3 = String.format(\"%04x\", ledgerId >> 16 & 0xffff);\n+        String subdir4 = String.format(\"%04x\", ledgerId & 0xffff);\n+        \n+        return String.format(\"%s/%s/%s/%s/%s\",\n+                             base, subdir1, subdir2, subdir3, subdir4);\n+    }\n+\n+    private String getUrLedgerZnode(long ledgerId) {\n+        return String.format(\"%s/urL%010d\", getParentZnodePath(urLedgerPath, ledgerId), ledgerId);\n+    }\n+\n+\n+    @Override\n+    public void markLedgerUnderreplicated(long ledgerId, String missingReplica)\n+            throws ReplicationException.UnavailableException {\n+        LOG.debug(\"markLedgerUnderreplicated {} {}\", ledgerId, missingReplica);\n+        try {\n+            String znode = getUrLedgerZnode(ledgerId);\n+            while (true) {\n+                UnderreplicatedLedgerFormat.Builder builder = UnderreplicatedLedgerFormat.newBuilder();\n+                try {\n+                    builder.addReplica(missingReplica);\n+                    createOptimistic(znode,\n+                                     TextFormat.printToString(builder.build()).getBytes(UTF8));\n+                } catch (KeeperException.NodeExistsException nee) {\n+                    Stat s = zkc.exists(znode, false);\n+                    if (s == null) {\n+                        continue;\n+                    }\n+                    try {\n+                        byte[] bytes = zkc.getData(znode, false, s);\n+                        TextFormat.merge(new String(bytes, UTF8), builder);\n+                        UnderreplicatedLedgerFormat data = builder.build();\n+                        for (String r : data.getReplicaList()) {\n+                            if (r.equals(missingReplica)) {\n+                                break; // nothing to add\n+                            }\n+                        }\n+                        builder.addReplica(missingReplica);\n+                        zkc.setData(znode,\n+                                    TextFormat.printToString(builder.build()).getBytes(UTF8),\n+                                    s.getVersion());\n+                    } catch (KeeperException.NoNodeException nne) {\n+                        continue;\n+                    } catch (KeeperException.BadVersionException bve) {\n+                        continue;\n+                    } catch (TextFormat.ParseException pe) {\n+                        throw new ReplicationException.UnavailableException(\n+                                \"Invalid data found\", pe);\n+                    }\n+                }\n+                break;\n+            }\n+        } catch (KeeperException ke) {\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while contacting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void markLedgerReplicated(long ledgerId) throws ReplicationException.UnavailableException {\n+        LOG.debug(\"markLedgerReplicated(ledgerId={})\", ledgerId);\n+        try {\n+            Lock l = heldLocks.get(ledgerId);\n+            if (l != null) {\n+                zkc.delete(getUrLedgerZnode(ledgerId), l.getLedgerZNodeVersion());\n+            }\n+        } catch (KeeperException.NoNodeException nne) {\n+            // this is ok\n+        } catch (KeeperException.BadVersionException bve) {\n+            // if this is the case, some has marked the ledger\n+            // for rereplication again. Leave the underreplicated\n+            // znode in place, so the ledger is checked.\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error deleting underreplicated ledger znode\", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while contacting zookeeper\", ie);\n+        } finally {\n+            releaseUnderreplicatedLedger(ledgerId);\n+        }\n+    }\n+\n+    private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watcher w)\n+            throws KeeperException, InterruptedException {\n+        if (depth == 4) {\n+            List<String> children = zkc.getChildren(parent, w);\n+            Collections.shuffle(children);\n+\n+            while (children.size() > 0) {\n+                String tryChild = children.get(0);\n+                try {\n+                    String lockPath = urLockPath + \"/\" + tryChild;\n+                    if (zkc.exists(lockPath, w) != null) {\n+                        children.remove(tryChild);\n+                        continue;\n+                    }\n+\n+                    Stat stat = zkc.exists(parent + \"/\" + tryChild, false);\n+                    if (stat == null) {\n+                        LOG.debug(\"{}/{} doesn't exist\", parent, tryChild);\n+                        children.remove(tryChild);\n+                        continue;\n+                    }\n+\n+                    long ledgerId = getLedgerId(tryChild);\n+                    zkc.create(lockPath, new byte[0],\n+                               Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+                    heldLocks.put(ledgerId, new Lock(lockPath, stat.getVersion()));\n+                    return ledgerId;\n+                } catch (KeeperException.NodeExistsException nee) {\n+                    children.remove(tryChild);\n+                } catch (NumberFormatException nfe) {\n+                    children.remove(tryChild);\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        List<String> children = zkc.getChildren(parent, w);\n+        Collections.shuffle(children);\n+\n+        while (children.size() > 0) {\n+            String tryChild = children.get(0);\n+            String tryPath = parent + \"/\" + tryChild;\n+            long ledger = getLedgerToRereplicateFromHierarchy(tryPath, depth + 1, w);\n+            if (ledger != -1) {\n+                return ledger;\n+            }\n+            children.remove(tryChild);\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    public long getLedgerToRereplicate() throws ReplicationException.UnavailableException {\n+        LOG.debug(\"getLedgerToRereplicate()\");\n+        try {\n+            while (true) {\n+                final CountDownLatch changedLatch = new CountDownLatch(1);\n+                Watcher w = new Watcher() {\n+                        public void process(WatchedEvent e) {\n+                            if (e.getType() == Watcher.Event.EventType.NodeChildrenChanged\n+                                || e.getType() == Watcher.Event.EventType.NodeDeleted) {\n+                                changedLatch.countDown();\n+                            }\n+                        }\n+                    };\n+                long ledger = getLedgerToRereplicateFromHierarchy(urLedgerPath, 0, w);\n+                if (ledger != -1) {\n+                    return ledger;\n+                }\n+                // nothing found, wait for a watcher to trigger\n+                changedLatch.await();\n+            }\n+        } catch (KeeperException ke) {\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while conecting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void releaseUnderreplicatedLedger(long ledgerId) throws ReplicationException.UnavailableException {\n+        LOG.debug(\"releaseLedger(ledgerId={})\", ledgerId);\n+        try {\n+            Lock l = heldLocks.remove(ledgerId);\n+            if (l != null) {\n+                zkc.delete(l.getLockZNode(), -1);\n+            }\n+        } catch (KeeperException.NoNodeException nne) {\n+            // this is ok\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error deleting underreplicated ledger lock\", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while conecting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws ReplicationException.UnavailableException {\n+        LOG.debug(\"close()\");\n+        try {\n+            for (Map.Entry<Long, Lock> e : heldLocks.entrySet()) {\n+                zkc.delete(e.getValue().getLockZNode(), -1);\n+            }\n+        } catch (KeeperException.NoNodeException nne) {\n+            // this is ok\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error deleting underreplicated ledger lock\", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while conecting zookeeper\", ie);\n+        }\n+    }\n+}"},{"sha":"b0df99ccf8ca1c4e34db090c25bdbcbcbb23fb10","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","status":"modified","additions":867,"deletions":2,"changes":869,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -1624,6 +1624,843 @@ public Builder clearPassword() {\n     // @@protoc_insertion_point(class_scope:LedgerMetadataFormat)\n   }\n   \n+  public interface LedgerRereplicationLayoutFormatOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required string type = 1;\n+    boolean hasType();\n+    String getType();\n+    \n+    // required int32 version = 2;\n+    boolean hasVersion();\n+    int getVersion();\n+  }\n+  public static final class LedgerRereplicationLayoutFormat extends\n+      com.google.protobuf.GeneratedMessage\n+      implements LedgerRereplicationLayoutFormatOrBuilder {\n+    // Use LedgerRereplicationLayoutFormat.newBuilder() to construct.\n+    private LedgerRereplicationLayoutFormat(Builder builder) {\n+      super(builder);\n+    }\n+    private LedgerRereplicationLayoutFormat(boolean noInit) {}\n+    \n+    private static final LedgerRereplicationLayoutFormat defaultInstance;\n+    public static LedgerRereplicationLayoutFormat getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public LedgerRereplicationLayoutFormat getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerRereplicationLayoutFormat_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerRereplicationLayoutFormat_fieldAccessorTable;\n+    }\n+    \n+    private int bitField0_;\n+    // required string type = 1;\n+    public static final int TYPE_FIELD_NUMBER = 1;\n+    private java.lang.Object type_;\n+    public boolean hasType() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public String getType() {\n+      java.lang.Object ref = type_;\n+      if (ref instanceof String) {\n+        return (String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs = \n+            (com.google.protobuf.ByteString) ref;\n+        String s = bs.toStringUtf8();\n+        if (com.google.protobuf.Internal.isValidUtf8(bs)) {\n+          type_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    private com.google.protobuf.ByteString getTypeBytes() {\n+      java.lang.Object ref = type_;\n+      if (ref instanceof String) {\n+        com.google.protobuf.ByteString b = \n+            com.google.protobuf.ByteString.copyFromUtf8((String) ref);\n+        type_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+    \n+    // required int32 version = 2;\n+    public static final int VERSION_FIELD_NUMBER = 2;\n+    private int version_;\n+    public boolean hasVersion() {\n+      return ((bitField0_ & 0x00000002) == 0x00000002);\n+    }\n+    public int getVersion() {\n+      return version_;\n+    }\n+    \n+    private void initFields() {\n+      type_ = \"\";\n+      version_ = 0;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasType()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!hasVersion()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeBytes(1, getTypeBytes());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        output.writeInt32(2, version_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(1, getTypeBytes());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(2, version_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormatOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerRereplicationLayoutFormat_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_LedgerRereplicationLayoutFormat_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        type_ = \"\";\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        version_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat.getDescriptor();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat getDefaultInstanceForType() {\n+        return org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat.getDefaultInstance();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat build() {\n+        org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat buildPartial() {\n+        org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat result = new org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.type_ = type_;\n+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.version_ = version_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat) {\n+          return mergeFrom((org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat other) {\n+        if (other == org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat.getDefaultInstance()) return this;\n+        if (other.hasType()) {\n+          setType(other.getType());\n+        }\n+        if (other.hasVersion()) {\n+          setVersion(other.getVersion());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasType()) {\n+          \n+          return false;\n+        }\n+        if (!hasVersion()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 10: {\n+              bitField0_ |= 0x00000001;\n+              type_ = input.readBytes();\n+              break;\n+            }\n+            case 16: {\n+              bitField0_ |= 0x00000002;\n+              version_ = input.readInt32();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required string type = 1;\n+      private java.lang.Object type_ = \"\";\n+      public boolean hasType() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public String getType() {\n+        java.lang.Object ref = type_;\n+        if (!(ref instanceof String)) {\n+          String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();\n+          type_ = s;\n+          return s;\n+        } else {\n+          return (String) ref;\n+        }\n+      }\n+      public Builder setType(String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000001;\n+        type_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearType() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        type_ = getDefaultInstance().getType();\n+        onChanged();\n+        return this;\n+      }\n+      void setType(com.google.protobuf.ByteString value) {\n+        bitField0_ |= 0x00000001;\n+        type_ = value;\n+        onChanged();\n+      }\n+      \n+      // required int32 version = 2;\n+      private int version_ ;\n+      public boolean hasVersion() {\n+        return ((bitField0_ & 0x00000002) == 0x00000002);\n+      }\n+      public int getVersion() {\n+        return version_;\n+      }\n+      public Builder setVersion(int value) {\n+        bitField0_ |= 0x00000002;\n+        version_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearVersion() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        version_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:LedgerRereplicationLayoutFormat)\n+    }\n+    \n+    static {\n+      defaultInstance = new LedgerRereplicationLayoutFormat(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:LedgerRereplicationLayoutFormat)\n+  }\n+  \n+  public interface UnderreplicatedLedgerFormatOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // repeated string replica = 1;\n+    java.util.List<String> getReplicaList();\n+    int getReplicaCount();\n+    String getReplica(int index);\n+  }\n+  public static final class UnderreplicatedLedgerFormat extends\n+      com.google.protobuf.GeneratedMessage\n+      implements UnderreplicatedLedgerFormatOrBuilder {\n+    // Use UnderreplicatedLedgerFormat.newBuilder() to construct.\n+    private UnderreplicatedLedgerFormat(Builder builder) {\n+      super(builder);\n+    }\n+    private UnderreplicatedLedgerFormat(boolean noInit) {}\n+    \n+    private static final UnderreplicatedLedgerFormat defaultInstance;\n+    public static UnderreplicatedLedgerFormat getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public UnderreplicatedLedgerFormat getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.bookkeeper.proto.DataFormats.internal_static_UnderreplicatedLedgerFormat_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.bookkeeper.proto.DataFormats.internal_static_UnderreplicatedLedgerFormat_fieldAccessorTable;\n+    }\n+    \n+    // repeated string replica = 1;\n+    public static final int REPLICA_FIELD_NUMBER = 1;\n+    private com.google.protobuf.LazyStringList replica_;\n+    public java.util.List<String>\n+        getReplicaList() {\n+      return replica_;\n+    }\n+    public int getReplicaCount() {\n+      return replica_.size();\n+    }\n+    public String getReplica(int index) {\n+      return replica_.get(index);\n+    }\n+    \n+    private void initFields() {\n+      replica_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      for (int i = 0; i < replica_.size(); i++) {\n+        output.writeBytes(1, replica_.getByteString(i));\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      {\n+        int dataSize = 0;\n+        for (int i = 0; i < replica_.size(); i++) {\n+          dataSize += com.google.protobuf.CodedOutputStream\n+            .computeBytesSizeNoTag(replica_.getByteString(i));\n+        }\n+        size += dataSize;\n+        size += 1 * getReplicaList().size();\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormatOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_UnderreplicatedLedgerFormat_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.bookkeeper.proto.DataFormats.internal_static_UnderreplicatedLedgerFormat_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        replica_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat.getDescriptor();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat getDefaultInstanceForType() {\n+        return org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat.getDefaultInstance();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat build() {\n+        org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat buildPartial() {\n+        org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat result = new org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat(this);\n+        int from_bitField0_ = bitField0_;\n+        if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+          replica_ = new com.google.protobuf.UnmodifiableLazyStringList(\n+              replica_);\n+          bitField0_ = (bitField0_ & ~0x00000001);\n+        }\n+        result.replica_ = replica_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat) {\n+          return mergeFrom((org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat other) {\n+        if (other == org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat.getDefaultInstance()) return this;\n+        if (!other.replica_.isEmpty()) {\n+          if (replica_.isEmpty()) {\n+            replica_ = other.replica_;\n+            bitField0_ = (bitField0_ & ~0x00000001);\n+          } else {\n+            ensureReplicaIsMutable();\n+            replica_.addAll(other.replica_);\n+          }\n+          onChanged();\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 10: {\n+              ensureReplicaIsMutable();\n+              replica_.add(input.readBytes());\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // repeated string replica = 1;\n+      private com.google.protobuf.LazyStringList replica_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+      private void ensureReplicaIsMutable() {\n+        if (!((bitField0_ & 0x00000001) == 0x00000001)) {\n+          replica_ = new com.google.protobuf.LazyStringArrayList(replica_);\n+          bitField0_ |= 0x00000001;\n+         }\n+      }\n+      public java.util.List<String>\n+          getReplicaList() {\n+        return java.util.Collections.unmodifiableList(replica_);\n+      }\n+      public int getReplicaCount() {\n+        return replica_.size();\n+      }\n+      public String getReplica(int index) {\n+        return replica_.get(index);\n+      }\n+      public Builder setReplica(\n+          int index, String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  ensureReplicaIsMutable();\n+        replica_.set(index, value);\n+        onChanged();\n+        return this;\n+      }\n+      public Builder addReplica(String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  ensureReplicaIsMutable();\n+        replica_.add(value);\n+        onChanged();\n+        return this;\n+      }\n+      public Builder addAllReplica(\n+          java.lang.Iterable<String> values) {\n+        ensureReplicaIsMutable();\n+        super.addAll(values, replica_);\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearReplica() {\n+        replica_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        onChanged();\n+        return this;\n+      }\n+      void addReplica(com.google.protobuf.ByteString value) {\n+        ensureReplicaIsMutable();\n+        replica_.add(value);\n+        onChanged();\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:UnderreplicatedLedgerFormat)\n+    }\n+    \n+    static {\n+      defaultInstance = new UnderreplicatedLedgerFormat(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:UnderreplicatedLedgerFormat)\n+  }\n+  \n   private static com.google.protobuf.Descriptors.Descriptor\n     internal_static_LedgerMetadataFormat_descriptor;\n   private static\n@@ -1634,6 +2471,16 @@ public Builder clearPassword() {\n   private static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_LedgerMetadataFormat_Segment_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_LedgerRereplicationLayoutFormat_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_LedgerRereplicationLayoutFormat_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_UnderreplicatedLedgerFormat_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_UnderreplicatedLedgerFormat_fieldAccessorTable;\n   \n   public static com.google.protobuf.Descriptors.FileDescriptor\n       getDescriptor() {\n@@ -1654,8 +2501,10 @@ public Builder clearPassword() {\n       \"\\026\\n\\016ensembleMember\\030\\001 \\003(\\t\\022\\024\\n\\014firstEntryId\\030\" +\n       \"\\002 \\002(\\003\\\".\\n\\005State\\022\\010\\n\\004OPEN\\020\\001\\022\\017\\n\\013IN_RECOVERY\\020\",\n       \"\\002\\022\\n\\n\\006CLOSED\\020\\003\\\"!\\n\\nDigestType\\022\\t\\n\\005CRC32\\020\\001\\022\\010\" +\n-      \"\\n\\004HMAC\\020\\002B\\037\\n\\033org.apache.bookkeeper.protoH\" +\n-      \"\\001\"\n+      \"\\n\\004HMAC\\020\\002\\\"@\\n\\037LedgerRereplicationLayoutFor\" +\n+      \"mat\\022\\014\\n\\004type\\030\\001 \\002(\\t\\022\\017\\n\\007version\\030\\002 \\002(\\005\\\".\\n\\033Un\" +\n+      \"derreplicatedLedgerFormat\\022\\017\\n\\007replica\\030\\001 \\003\" +\n+      \"(\\tB\\037\\n\\033org.apache.bookkeeper.protoH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -1678,6 +2527,22 @@ public Builder clearPassword() {\n               new java.lang.String[] { \"EnsembleMember\", \"FirstEntryId\", },\n               org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.class,\n               org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Segment.Builder.class);\n+          internal_static_LedgerRereplicationLayoutFormat_descriptor =\n+            getDescriptor().getMessageTypes().get(1);\n+          internal_static_LedgerRereplicationLayoutFormat_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_LedgerRereplicationLayoutFormat_descriptor,\n+              new java.lang.String[] { \"Type\", \"Version\", },\n+              org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat.class,\n+              org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat.Builder.class);\n+          internal_static_UnderreplicatedLedgerFormat_descriptor =\n+            getDescriptor().getMessageTypes().get(2);\n+          internal_static_UnderreplicatedLedgerFormat_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_UnderreplicatedLedgerFormat_descriptor,\n+              new java.lang.String[] { \"Replica\", },\n+              org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat.class,\n+              org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat.Builder.class);\n           return null;\n         }\n       };"},{"sha":"49b99b9a11b7c45c99cd85f06fadd563f1d3433c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -21,7 +21,7 @@\n /**\n  * Exceptions for use within the replication service\n  */\n-abstract class ReplicationException extends Exception {\n+public abstract class ReplicationException extends Exception {\n     protected ReplicationException(String message, Throwable cause) {\n         super(message, cause);\n     }\n@@ -33,14 +33,14 @@ protected ReplicationException(String message) {\n     /**\n      * The replication service has become unavailable\n      */\n-    static class UnavailableException extends ReplicationException {\n+    public static class UnavailableException extends ReplicationException {\n         private static final long serialVersionUID = 31872209L;\n \n-        UnavailableException(String message, Throwable cause) {\n+        public UnavailableException(String message, Throwable cause) {\n             super(message, cause);\n         }\n \n-        UnavailableException(String message) {\n+        public UnavailableException(String message) {\n             super(message);\n         }\n     }\n@@ -49,14 +49,14 @@ protected ReplicationException(String message) {\n      * Compatibility error. This version of the code, doesn't know how to\n      * deal with the metadata it has found.\n      */\n-    static class CompatibilityException extends ReplicationException {\n+    public static class CompatibilityException extends ReplicationException {\n         private static final long serialVersionUID = 98551903L;\n \n-        CompatibilityException(String message, Throwable cause) {\n+        public CompatibilityException(String message, Throwable cause) {\n             super(message, cause);\n         }\n \n-        CompatibilityException(String message) {\n+        public CompatibilityException(String message) {\n             super(message);\n         }\n     }"},{"sha":"18b4e7f28237e5e8967dfc43d3e533028a17a385","filename":"bookkeeper-server/src/main/proto/DataFormats.proto","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/proto/DataFormats.proto","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/main/proto/DataFormats.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/proto/DataFormats.proto?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -46,4 +46,13 @@ message LedgerMetadataFormat {\n     }\n     optional DigestType digestType = 7;\n     optional bytes password = 8;\n+}\n+\n+message LedgerRereplicationLayoutFormat {\n+    required string type = 1;\n+    required int32 version = 2;\n+}\n+ \n+message UnderreplicatedLedgerFormat {\n+    repeated string replica = 1;\n }\n\\ No newline at end of file"},{"sha":"c743190dc05deb43e1e9b318a61dce3b5542ea35","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","status":"added","additions":359,"deletions":0,"changes":359,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -0,0 +1,359 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.replication;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.test.ZooKeeperUtil;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Test;\n+import org.junit.Before;\n+import org.junit.After;\n+import static org.junit.Assert.*;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+\n+/**\n+ * Test the zookeeper implementation of the ledger replication manager\n+ */\n+public class TestLedgerUnderreplicationManager {\n+    static final Logger LOG = LoggerFactory.getLogger(TestLedgerUnderreplicationManager.class);\n+\n+    ZooKeeperUtil zkUtil = null;\n+\n+    ServerConfiguration conf = null;\n+    ExecutorService executor = null;\n+    LedgerManagerFactory lmf1 = null;\n+    LedgerManagerFactory lmf2 = null;\n+    ZooKeeper zkc1 = null;\n+    ZooKeeper zkc2 = null;\n+\n+    @Before\n+    public void setupZooKeeper() throws Exception {\n+        zkUtil = new ZooKeeperUtil();\n+        zkUtil.startServer();\n+\n+        conf = new ServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());\n+\n+        executor = Executors.newCachedThreadPool();\n+\n+        zkc1 = zkUtil.getNewZooKeeperClient();\n+        zkc2 = zkUtil.getNewZooKeeperClient();\n+        lmf1 = LedgerManagerFactory.newLedgerManagerFactory(conf, zkc1);\n+        lmf2 = LedgerManagerFactory.newLedgerManagerFactory(conf, zkc2);\n+    }\n+\n+    @After\n+    public void teardownZooKeeper() throws Exception {\n+        if (zkUtil != null) {\n+            zkUtil.killServer();\n+            zkUtil = null;\n+        }\n+        if (executor != null) {\n+            executor = null;\n+        }\n+        if (zkc1 != null) {\n+            zkc1.close();\n+            zkc1 = null;\n+        }\n+        if (zkc2 != null) {\n+            zkc2.close();\n+            zkc2 = null;\n+        }\n+        if (lmf1 != null) {\n+            lmf1.uninitialize();\n+            lmf1 = null;\n+        }\n+        if (lmf2 != null) {\n+            lmf2.uninitialize();\n+            lmf2 = null;\n+        }\n+    }\n+\n+    private Future<Long> getLedgerToReplicate(final LedgerUnderreplicationManager m) {\n+        return executor.submit(new Callable<Long>() {\n+                public Long call() {\n+                    try {\n+                        return m.getLedgerToRereplicate();\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error getting ledger id\", e);\n+                        return -1L;\n+                    }\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Test basic interactions with the ledger underreplication\n+     * manager.\n+     * Mark some ledgers as underreplicated.\n+     * Ensure that getLedgerToReplicate will block until it a ledger\n+     * becomes available.\n+     */\n+    @Test\n+    public void testBasicInteraction() throws Exception {\n+        Set<Long> ledgers = new HashSet<Long>();\n+        ledgers.add(0xdeadbeefL);\n+        ledgers.add(0xbeefcafeL);\n+        ledgers.add(0xffffbeefL);\n+        ledgers.add(0xfacebeefL);\n+        String missingReplica = \"localhost:3181\";\n+\n+        int count = 0;\n+        LedgerUnderreplicationManager m = lmf1.newLedgerUnderreplicationManager();\n+        Iterator<Long> iter = ledgers.iterator();\n+        while (iter.hasNext()) {\n+            m.markLedgerUnderreplicated(iter.next(), missingReplica);\n+            count++;\n+        }\n+\n+        List<Future<Long>> futures = new ArrayList<Future<Long>>();\n+        for (int i = 0; i < count; i++) {\n+            futures.add(getLedgerToReplicate(m));\n+        }\n+\n+        for (Future<Long> f : futures) {\n+            Long l = f.get(5, TimeUnit.SECONDS);\n+            assertTrue(ledgers.remove(l));\n+        }\n+\n+        Future f = getLedgerToReplicate(m);\n+        try {\n+            f.get(5, TimeUnit.SECONDS);\n+            fail(\"Shouldn't be able to find a ledger to replicate\");\n+        } catch (TimeoutException te) {\n+            // correct behaviour\n+        }\n+        Long newl = 0xfefefefefefeL;\n+        m.markLedgerUnderreplicated(newl, missingReplica);\n+        assertEquals(\"Should have got the one just added\", newl, f.get(5, TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Test locking for ledger unreplication manager.\n+     * If there's only one ledger marked for rereplication,\n+     * and one client has it, it should be locked; another\n+     * client shouldn't be able to get it. If the first client dies\n+     * however, the second client should be able to get it.\n+     */\n+    @Test\n+    public void testLocking() throws Exception {\n+        String missingReplica = \"localhost:3181\";\n+\n+        LedgerUnderreplicationManager m1 = lmf1.newLedgerUnderreplicationManager();\n+        LedgerUnderreplicationManager m2 = lmf2.newLedgerUnderreplicationManager();\n+\n+        Long ledger = 0xfeadeefdacL;\n+        m1.markLedgerUnderreplicated(ledger, missingReplica);\n+        Future<Long> f = getLedgerToReplicate(m1);\n+        Long l = f.get(5, TimeUnit.SECONDS);\n+        assertEquals(\"Should be the ledger I just marked\", ledger, l);\n+\n+        f = getLedgerToReplicate(m2);\n+        try {\n+            f.get(5, TimeUnit.SECONDS);\n+            fail(\"Shouldn't be able to find a ledger to replicate\");\n+        } catch (TimeoutException te) {\n+            // correct behaviour\n+        }\n+        zkc1.close(); // should kill the lock\n+        zkc1 = null;\n+\n+        l = f.get(5, TimeUnit.SECONDS);\n+        assertEquals(\"Should be the ledger I marked\", ledger, l);\n+    }\n+\n+\n+    /**\n+     * Test that when a ledger has been marked as replicated, it\n+     * will not be offered to anther client.\n+     * This test checked that by marking two ledgers, and acquiring\n+     * them on a single client. It marks one as replicated and then\n+     * the client is killed. We then check that another client can\n+     * acquire a ledger, and that it's not the one that was previously\n+     * marked as replicated.\n+     */\n+    @Test\n+    public void testMarkingAsReplicated() throws Exception {\n+        String missingReplica = \"localhost:3181\";\n+\n+        LedgerUnderreplicationManager m1 = lmf1.newLedgerUnderreplicationManager();\n+        LedgerUnderreplicationManager m2 = lmf2.newLedgerUnderreplicationManager();\n+\n+        Long ledgerA = 0xfeadeefdacL;\n+        Long ledgerB = 0xdefadebL;\n+        m1.markLedgerUnderreplicated(ledgerA, missingReplica);\n+        m1.markLedgerUnderreplicated(ledgerB, missingReplica);\n+\n+        Future<Long> fA = getLedgerToReplicate(m1);\n+        Future<Long> fB = getLedgerToReplicate(m1);\n+\n+        Long lA = fA.get(5, TimeUnit.SECONDS);\n+        Long lB = fB.get(5, TimeUnit.SECONDS);\n+\n+        assertTrue(\"Should be the ledgers I just marked\",\n+                   (lA.equals(ledgerA) && lB.equals(ledgerB))\n+                   || (lA.equals(ledgerB) && lB.equals(ledgerA)));\n+\n+        Future<Long> f = getLedgerToReplicate(m2);\n+        try {\n+            f.get(5, TimeUnit.SECONDS);\n+            fail(\"Shouldn't be able to find a ledger to replicate\");\n+        } catch (TimeoutException te) {\n+            // correct behaviour\n+        }\n+        m1.markLedgerReplicated(lA);\n+        zkc1.close(); // should kill the lock\n+        zkc1 = null;\n+\n+        Long l = f.get(5, TimeUnit.SECONDS);\n+        assertEquals(\"Should be the ledger I marked\", lB, l);\n+    }\n+\n+    /**\n+     * Test releasing of a ledger\n+     * A ledger is released when a client decides it does not want\n+     * to replicate it (or cannot at the moment).\n+     * When a client releases a previously acquired ledger, another\n+     * client should then be able to acquire it.\n+     */\n+    @Test\n+    public void testRelease() throws Exception {\n+        String missingReplica = \"localhost:3181\";\n+\n+        LedgerUnderreplicationManager m1 = lmf1.newLedgerUnderreplicationManager();\n+        LedgerUnderreplicationManager m2 = lmf2.newLedgerUnderreplicationManager();\n+\n+        Long ledgerA = 0xfeadeefdacL;\n+        Long ledgerB = 0xdefadebL;\n+        m1.markLedgerUnderreplicated(ledgerA, missingReplica);\n+        m1.markLedgerUnderreplicated(ledgerB, missingReplica);\n+\n+        Future<Long> fA = getLedgerToReplicate(m1);\n+        Future<Long> fB = getLedgerToReplicate(m1);\n+\n+        Long lA = fA.get(5, TimeUnit.SECONDS);\n+        Long lB = fB.get(5, TimeUnit.SECONDS);\n+\n+        assertTrue(\"Should be the ledgers I just marked\",\n+                   (lA.equals(ledgerA) && lB.equals(ledgerB))\n+                   || (lA.equals(ledgerB) && lB.equals(ledgerA)));\n+\n+        Future<Long> f = getLedgerToReplicate(m2);\n+        try {\n+            f.get(5, TimeUnit.SECONDS);\n+            fail(\"Shouldn't be able to find a ledger to replicate\");\n+        } catch (TimeoutException te) {\n+            // correct behaviour\n+        }\n+        m1.markLedgerReplicated(lA);\n+        m1.releaseUnderreplicatedLedger(lB);\n+\n+        Long l = f.get(5, TimeUnit.SECONDS);\n+        assertEquals(\"Should be the ledger I marked\", lB, l);\n+    }\n+\n+    /**\n+     * Test that when a failure occurs on a ledger, while the ledger\n+     * is already being rereplicated, the ledger will still be in the\n+     * under replicated ledger list when first rereplicating client marks\n+     * it as replicated.\n+     */\n+    @Test\n+    public void testManyFailures() throws Exception {\n+        String missingReplica1 = \"localhost:3181\";\n+        String missingReplica2 = \"localhost:3182\";\n+\n+        LedgerUnderreplicationManager m1 = lmf1.newLedgerUnderreplicationManager();\n+        LedgerUnderreplicationManager m2 = lmf2.newLedgerUnderreplicationManager();\n+\n+        Long ledgerA = 0xfeadeefdacL;\n+        m1.markLedgerUnderreplicated(ledgerA, missingReplica1);\n+\n+        Future<Long> fA = getLedgerToReplicate(m1);\n+        Long lA = fA.get(5, TimeUnit.SECONDS);\n+\n+        m1.markLedgerUnderreplicated(ledgerA, missingReplica2);\n+\n+        assertEquals(\"Should be the ledger I just marked\",\n+                     lA, ledgerA);\n+        m1.markLedgerReplicated(lA);\n+\n+        Future<Long> f = getLedgerToReplicate(m1);\n+        lA = f.get(5, TimeUnit.SECONDS);\n+        assertEquals(\"Should be the ledger I had marked previously\",\n+                     lA, ledgerA);\n+    }\n+\n+    /**\n+     * Test that when a ledger is marked as underreplicated with\n+     * the same missing replica twice, only marking as replicated\n+     * will be enough to remove it from the list.\n+     */\n+    @Test\n+    public void test2reportSame() throws Exception {\n+        String missingReplica1 = \"localhost:3181\";\n+\n+        LedgerUnderreplicationManager m1 = lmf1.newLedgerUnderreplicationManager();\n+        LedgerUnderreplicationManager m2 = lmf2.newLedgerUnderreplicationManager();\n+\n+        Long ledgerA = 0xfeadeefdacL;\n+        m1.markLedgerUnderreplicated(ledgerA, missingReplica1);\n+        m2.markLedgerUnderreplicated(ledgerA, missingReplica1);\n+\n+        Future<Long> fA = getLedgerToReplicate(m1);\n+        Long lA = fA.get(5, TimeUnit.SECONDS);\n+\n+        assertEquals(\"Should be the ledger I just marked\",\n+                     lA, ledgerA);\n+        m1.markLedgerReplicated(lA);\n+\n+        Future<Long> f = getLedgerToReplicate(m2);\n+        try {\n+            f.get(5, TimeUnit.SECONDS);\n+            fail(\"Shouldn't be able to find a ledger to replicate\");\n+        } catch (TimeoutException te) {\n+            // correct behaviour\n+        }\n+    }\n+}"},{"sha":"0e52d9ed66de2be5a7d453dda6e7206bc047b0a4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","status":"modified","additions":20,"deletions":14,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/74e097e0b171871f4f0c067600949376ff98cb5d/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java?ref=74e097e0b171871f4f0c067600949376ff98cb5d","patch":"@@ -72,6 +72,25 @@ public ZooKeeper getZooKeeperClient() {\n         return zkc;\n     }\n \n+    public ZooKeeper getNewZooKeeperClient() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        ZooKeeper zkc = new ZooKeeper(getZooKeeperConnectString(), 10000,\n+                new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        // handle session disconnects and expires\n+                        if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n+                            latch.countDown();\n+                        }\n+                    }\n+                });\n+        if (!latch.await(10000, TimeUnit.MILLISECONDS)) {\n+            zkc.close();\n+            fail(\"Could not connect to zookeeper server\");\n+        }\n+        return zkc;\n+    }\n+\n     public String getZooKeeperConnectString() {\n         return connectString;\n     }\n@@ -97,20 +116,7 @@ public void startServer() throws Exception {\n         // create a zookeeper client\n         LOG.debug(\"Instantiate ZK Client\");\n         final CountDownLatch latch = new CountDownLatch(1);\n-        zkc = new ZooKeeper(getZooKeeperConnectString(), 10000,\n-                            new Watcher() {\n-                                @Override\n-                                public void process(WatchedEvent event) {\n-                                    // handle session disconnects and expires\n-                                    if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n-                                        latch.countDown();\n-                                    }\n-                                }\n-                            });\n-        if (!latch.await(10000, TimeUnit.MILLISECONDS)) {\n-            zkc.close();\n-            fail(\"Could not connect to zookeeper server\");\n-        }\n+        zkc = getNewZooKeeperClient();\n \n         // initialize the zk client with values\n         zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);"}]}

