{"sha":"75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3NWRiZjY5OWI5MGRkMDFiMGRkNDRlNGJkZGE2MGU3MTc2YjNlZTEy","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2011-11-15T18:42:58Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2011-11-15T18:42:58Z"},"message":"BOOKKEEPER-106: recoveryBookieData can select a recovery bookie which is already in the ledgers ensemble\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1202370 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8d2a7d3f09d04d1a678b8043ddb4772989e566db","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8d2a7d3f09d04d1a678b8043ddb4772989e566db"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","html_url":"https://github.com/apache/bookkeeper/commit/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"cc467bd5880c2879e6c0355469d51759f89bbabc","url":"https://api.github.com/repos/apache/bookkeeper/commits/cc467bd5880c2879e6c0355469d51759f89bbabc","html_url":"https://github.com/apache/bookkeeper/commit/cc467bd5880c2879e6c0355469d51759f89bbabc"}],"stats":{"total":442,"additions":356,"deletions":86},"files":[{"sha":"285274ac606bfeace84fe36da42c98588c885d67","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":126,"deletions":67,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","patch":"@@ -207,9 +207,11 @@ private DigestType getLedgerDigestType(long ledgerId) {\n     // Object used for calling async methods and waiting for them to complete.\n     class SyncObject {\n         boolean value;\n+        int rc;\n \n         public SyncObject() {\n             value = false;\n+            rc = BKException.Code.OK;\n         }\n     }\n \n@@ -232,7 +234,7 @@ public SyncObject() {\n      *            of the ledger fragments from the source bookie over to it.\n      */\n     public void recoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest)\n-            throws InterruptedException {\n+            throws InterruptedException, BKException {\n         SyncObject sync = new SyncObject();\n         // Call the async method to recover bookie data.\n         asyncRecoverBookieData(bookieSrc, bookieDest, new RecoverCallback() {\n@@ -241,6 +243,7 @@ public void recoverComplete(int rc, Object ctx) {\n                 LOG.info(\"Recover bookie operation completed with rc: \" + rc);\n                 SyncObject syncObj = (SyncObject) ctx;\n                 synchronized (syncObj) {\n+                    syncObj.rc = rc;\n                     syncObj.value = true;\n                     syncObj.notify();\n                 }\n@@ -253,6 +256,9 @@ public void recoverComplete(int rc, Object ctx) {\n                 sync.wait();\n             }\n         }\n+        if (sync.rc != BKException.Code.OK) {\n+            throw BKException.create(sync.rc);\n+        }\n     }\n \n     /**\n@@ -403,6 +409,22 @@ public void processResult(int rc, String path, Object ctx) {\n         }, null);\n     }\n \n+    /**\n+     * Get a new random bookie, but ensure that it isn't one that is already\n+     * in the ensemble for the ledger.\n+     */\n+    private InetSocketAddress getNewBookie(final List<InetSocketAddress> bookiesAlreadyInEnsemble, \n+                                           final List<InetSocketAddress> availableBookies) \n+            throws BKException.BKNotEnoughBookiesException {\n+        ArrayList<InetSocketAddress> candidates = new ArrayList<InetSocketAddress>();\n+        candidates.addAll(availableBookies);\n+        candidates.removeAll(bookiesAlreadyInEnsemble);\n+        if (candidates.size() == 0) {\n+            throw new BKException.BKNotEnoughBookiesException();\n+        }\n+        return candidates.get(rand.nextInt(candidates.size()));\n+    }\n+\n     /**\n      * This method asynchronously recovers a given ledger if any of the ledger\n      * entries were stored on the failed bookie.\n@@ -501,79 +523,38 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                     ledgerMcb.processResult(BKException.Code.OK, null, null);\n                     return;\n                 }\n-                /*\n-                 * We have ledger fragments that need to be re-replicated to a\n-                 * new bookie. Choose one randomly from the available set of\n-                 * bookies.\n-                 */\n-                final InetSocketAddress newBookie = availableBookies.get(rand.nextInt(availableBookies.size()));\n \n                 /*\n-                 * Wrapper class around the ledger MultiCallback. Once all\n-                 * ledger fragments for the ledger have been replicated to a new\n-                 * bookie, we need to update ZK with this new metadata to point\n-                 * to the new bookie instead of the old dead one. That should be\n-                 * done at the end prior to invoking the ledger MultiCallback.\n+                 * Multicallback for ledger. Once all fragments for the ledger have been recovered\n+                 * trigger the ledgerMcb \n                  */\n-                class LedgerMultiCallbackWrapper implements AsyncCallback.VoidCallback {\n-                    final MultiCallback ledgerMcb;\n-\n-                    LedgerMultiCallbackWrapper(MultiCallback ledgerMcb) {\n-                        this.ledgerMcb = ledgerMcb;\n-                    }\n-\n-                    @Override\n-                    public void processResult(int rc, String path, Object ctx) {\n-                        if (rc != Code.OK.intValue()) {\n-                            LOG.error(\"BK error replicating ledger fragments for ledger: \" + lId, BKException\n-                                      .create(rc));\n-                            ledgerMcb.processResult(rc, null, null);\n-                            return;\n-                        }\n-                        /*\n-                         * Update the ledger metadata's ensemble info to point\n-                         * to the new bookie.\n-                         */\n-                        for (final Long startEntryId : ledgerFragmentsToRecover) {\n-                            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().get(\n-                                    startEntryId);\n-                            int deadBookieIndex = ensemble.indexOf(bookieSrc);\n-                            ensemble.remove(deadBookieIndex);\n-                            ensemble.add(deadBookieIndex, newBookie);\n-                        }\n-                        \n-                        lh.writeLedgerConfig(new AsyncCallback.StatCallback() {\n-                            @Override\n-                            public void processResult(int rc, String path, Object ctx, Stat stat) {\n-                                if (rc != Code.OK.intValue()) {\n-                                    LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n-                                              KeeperException.create(KeeperException.Code.get(rc), path));\n-                                } else {\n-                                    lh.getLedgerMetadata().updateZnodeStatus(stat);\n-                                    LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId()\n-                                             + \") to point ledger fragments from old dead bookie: (\" + bookieSrc\n-                                             + \") to new bookie: (\" + newBookie + \")\");\n-                                }\n-                                /*\n-                                 * Pass the return code result up the chain with\n-                                 * the parent callback.\n-                                 */\n-                                ledgerMcb.processResult(rc, null, null);\n-                            }\n-                        }, null);\n-                    }\n-                }\n+                MultiCallback ledgerFragmentsMcb = new MultiCallback(ledgerFragmentsToRecover.size(), ledgerMcb, null);\n \n                 /*\n                  * Now recover all of the necessary ledger fragments\n                  * asynchronously using a MultiCallback for every fragment.\n                  */\n-                MultiCallback ledgerFragmentMcb = new MultiCallback(ledgerFragmentsToRecover.size(),\n-                        new LedgerMultiCallbackWrapper(ledgerMcb), null);\n                 for (final Long startEntryId : ledgerFragmentsToRecover) {\n                     Long endEntryId = ledgerFragmentsRange.get(startEntryId);\n+                    InetSocketAddress newBookie = null;\n+                    try {\n+                        newBookie = getNewBookie(lh.getLedgerMetadata().getEnsembles().get(startEntryId),\n+                                                 availableBookies);\n+                    } catch (BKException.BKNotEnoughBookiesException bke) {\n+                        ledgerFragmentsMcb.processResult(BKException.Code.NotEnoughBookiesException, null, null);\n+                        continue;\n+                    }\n+                    \n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Replicating fragment from [\" + startEntryId \n+                                  + \",\" + endEntryId + \"] of ledger \" + lh.getId()\n+                                  + \" to \" + newBookie);\n+                    }\n+\n                     try {\n-                        recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, ledgerFragmentMcb, newBookie);\n+                        SingleFragmentCallback cb = new SingleFragmentCallback(ledgerFragmentsMcb, lh, startEntryId, \n+                                                                               bookieSrc, newBookie);\n+                        recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, cb, newBookie);\n                     } catch(InterruptedException e) {\n                         Thread.currentThread().interrupt();\n                         return;\n@@ -605,7 +586,7 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n      *            entries that were stored on the failed bookie.\n      */\n     private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final LedgerHandle lh,\n-                                       final Long startEntryId, final Long endEntryId, final MultiCallback ledgerFragmentMcb,\n+                                       final Long startEntryId, final Long endEntryId, final SingleFragmentCallback cb,\n                                        final InetSocketAddress newBookie) throws InterruptedException {\n         if (endEntryId == null) {\n             /*\n@@ -614,7 +595,7 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n              */\n             LOG.warn(\"Dead bookie (\" + bookieSrc + \") is still part of the current active ensemble for ledgerId: \"\n                      + lh.getId());\n-            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n+            cb.processResult(BKException.Code.OK, null, null);\n             return;\n         }\n \n@@ -644,7 +625,7 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n          * Now asynchronously replicate all of the entries for the ledger\n          * fragment that were on the dead bookie.\n          */\n-        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(entriesToReplicate.size(), ledgerFragmentMcb, null);\n+        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(entriesToReplicate.size(), cb, null);\n         for (final Long entryId : entriesToReplicate) {\n             recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb, newBookie);\n         }\n@@ -699,7 +680,10 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n                             LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n                                       + entryId + \", bookie: \" + addr, BKException.create(rc));\n                         } else {\n-                            LOG.debug(\"Success writing ledger entry to a new bookie!\");\n+                            if (LOG.isDebugEnabled()) {\n+                                LOG.debug(\"Success writing ledger id \" +ledgerId + \", entry id \"\n+                                          + entryId + \" to a new bookie \" + addr + \"!\");\n+                            }\n                         }\n                         /*\n                          * Pass the return code result up the chain with\n@@ -711,4 +695,79 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             }\n         }, null);\n     }\n+\n+    /*\n+     * Callback for recovery of a single ledger fragment.\n+     * Once the fragment has had all entries replicated, update the ensemble \n+     * in zookeeper.\n+     * Once finished propogate callback up to ledgerFragmentsMcb which should\n+     * be a multicallback responsible for all fragments in a single ledger\n+     */\n+    class SingleFragmentCallback implements AsyncCallback.VoidCallback {\n+        final MultiCallback ledgerFragmentsMcb;\n+        final LedgerHandle lh;\n+        final long fragmentStartId;\n+        final InetSocketAddress oldBookie;\n+        final InetSocketAddress newBookie;\n+\n+        SingleFragmentCallback(MultiCallback ledgerFragmentsMcb, LedgerHandle lh, \n+                               long fragmentStartId,\n+                               InetSocketAddress oldBookie,\n+                               InetSocketAddress newBookie) {\n+            this.ledgerFragmentsMcb = ledgerFragmentsMcb;\n+            this.lh = lh;\n+            this.fragmentStartId = fragmentStartId;\n+            this.newBookie = newBookie;\n+            this.oldBookie = oldBookie;\n+        }\n+        \n+        @Override\n+        public void processResult(int rc, String path, Object ctx) {\n+            if (rc != Code.OK.intValue()) {\n+                LOG.error(\"BK error replicating ledger fragments for ledger: \" + lh.getId(), \n+                          BKException.create(rc));\n+                ledgerFragmentsMcb.processResult(rc, null, null);\n+                return;\n+            }\n+            /*\n+             * Update the ledger metadata's ensemble info to point\n+             * to the new bookie.\n+             */\n+            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().get(\n+                    fragmentStartId);\n+            int deadBookieIndex = ensemble.indexOf(oldBookie);\n+            ensemble.remove(deadBookieIndex);\n+            ensemble.add(deadBookieIndex, newBookie);\n+            \n+            \n+            lh.writeLedgerConfig(new WriteCb(), null);\n+        }\n+        \n+        private class WriteCb implements AsyncCallback.StatCallback {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                if (rc == Code.BADVERSION.intValue()) {\n+                    LOG.warn(\"Two fragments attempted update at once; ledger id: \" + lh.getId() \n+                             + \" startid: \" + fragmentStartId);\n+                    // try again, the previous success (with which this has conflicted)\n+                    // will have updated the stat\n+                    lh.writeLedgerConfig(new WriteCb(), null);\n+                    return;\n+                } else if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n+                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                } else {\n+                    lh.getLedgerMetadata().updateZnodeStatus(stat);\n+                    LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId() + \" : \" + fragmentStartId \n+                             + \") to point ledger fragments from old dead bookie: (\" + oldBookie\n+                             + \") to new bookie: (\" + newBookie + \")\");\n+                }\n+                /*\n+                 * Pass the return code result up the chain with\n+                 * the parent callback.\n+                 */\n+                ledgerFragmentsMcb.processResult(rc, null, null);\n+            }\n+        };\n+    }\n }"},{"sha":"282f0771702c3b145a0913ee245ce8ddd2f1111f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","patch":"@@ -23,7 +23,9 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n import java.nio.ByteBuffer;\n \n import org.apache.bookkeeper.bookie.Bookie;\n@@ -56,6 +58,14 @@ public void start() throws IOException {\n         deathWatcher.start();\n     }\n \n+    public InetSocketAddress getLocalAddress() {\n+        try {\n+            return new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), port);\n+        } catch (UnknownHostException uhe) {\n+            return nioServerFactory.getLocalAddress();\n+        }\n+    }\n+\n     public synchronized void shutdown() throws InterruptedException {\n         if (!running) {\n             return;"},{"sha":"bc362b1863f747b33acf4a429d4372d351b13cee","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"renamed","additions":209,"deletions":8,"changes":217,"blob_url":"https://github.com/apache/bookkeeper/blob/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","patch":"@@ -1,4 +1,4 @@\n-package org.apache.bookkeeper.test;\n+package org.apache.bookkeeper.client;\n \n /*\n  *\n@@ -28,15 +28,28 @@\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.List;\n-\n+import java.util.Map;\n+import java.util.HashSet;\n+import java.util.HashMap;\n+import java.util.Collections;\n+import java.util.Random;\n+\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.test.BaseTestCase;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.apache.log4j.Logger;\n+import org.apache.zookeeper.data.Stat;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.KeeperException.Code;\n import org.apache.zookeeper.WatchedEvent;\n@@ -113,16 +126,28 @@ public void tearDown() throws Exception {\n      * @param numLedgers\n      *            Number of ledgers to create\n      * @return List of LedgerHandles for each of the ledgers created\n-     * @throws BKException\n-     * @throws KeeperException\n-     * @throws IOException\n-     * @throws InterruptedException\n      */\n-    private List<LedgerHandle> createLedgers(int numLedgers) throws BKException, KeeperException, IOException,\n+    private List<LedgerHandle> createLedgers(int numLedgers) \n+            throws BKException, KeeperException, IOException, InterruptedException \n+    {\n+        return createLedgers(numLedgers, 3, 2);\n+    }\n+\n+    /**\n+     * Helper method to create a number of ledgers\n+     *\n+     * @param numLedgers\n+     *            Number of ledgers to create\n+     * @param ensemble Ensemble size for ledgers\n+     * @param quorum Quorum size for ledgers\n+     * @return List of LedgerHandles for each of the ledgers created\n+     */\n+    private List<LedgerHandle> createLedgers(int numLedgers, int ensemble, int quorum) \n+            throws BKException, KeeperException, IOException,\n         InterruptedException {\n         List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n         for (int i = 0; i < numLedgers; i++) {\n-            lhs.add(bkc.createLedger(digestType, System.getProperty(\"passwd\").getBytes()));\n+            lhs.add(bkc.createLedger(ensemble, quorum, digestType, System.getProperty(\"passwd\").getBytes()));\n         }\n         return lhs;\n     }\n@@ -403,4 +428,180 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n         verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n     }\n \n+    private static class ReplicationVerificationCallback implements ReadEntryCallback {\n+        final CountDownLatch latch;\n+        final AtomicLong numSuccess;\n+\n+        ReplicationVerificationCallback(int numRequests) {\n+            latch = new CountDownLatch(numRequests);\n+            numSuccess = new AtomicLong(0);\n+        }\n+\n+        public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n+            if (LOG.isDebugEnabled()) {\n+                InetSocketAddress addr = (InetSocketAddress)ctx;\n+                LOG.debug(\"Got \" + rc + \" for ledger \" + ledgerId + \" entry \" + entryId + \" from \" + ctx);\n+            }\n+            if (rc == BKException.Code.OK) {\n+                numSuccess.incrementAndGet();\n+            }\n+            latch.countDown();\n+        }\n+\n+        long await() throws InterruptedException {\n+            if (latch.await(60, TimeUnit.SECONDS) == false) {\n+                LOG.warn(\"Didn't get all responses in verification\");\n+                return 0;\n+            } else {\n+                return numSuccess.get();\n+            }\n+        }\n+    }\n+\n+    private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws Exception {\n+        String znodepath = StringUtils.getLedgerNodePath(lh.getId());\n+        Stat stat = bkc.getZkHandle().exists(znodepath, false);\n+        assertNotNull(stat);\n+        byte[] mdbytes = bkc.getZkHandle().getData(znodepath, false, stat); \n+        LedgerMetadata md = LedgerMetadata.parseConfig(mdbytes, stat.getVersion()); \n+\n+        Map<Long, ArrayList<InetSocketAddress>> ensembles = md.getEnsembles();\n+\n+        HashMap<Long, Long> ranges = new HashMap<Long, Long>();\n+        ArrayList<Long> keyList = Collections.list(\n+                Collections.enumeration(ensembles.keySet()));\n+        Collections.sort(keyList);\n+        for (int i = 0; i < keyList.size() - 1; i++) {\n+            ranges.put(keyList.get(i), keyList.get(i+1));\n+        }\n+        ranges.put(keyList.get(keyList.size()-1), untilEntry);\n+        \n+        for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : ensembles.entrySet()) {\n+            int quorum = md.quorumSize;\n+            long startEntryId = e.getKey();\n+            long endEntryId = ranges.get(startEntryId);\n+            long expectedSuccess = quorum*(endEntryId-startEntryId);\n+            int numRequests = e.getValue().size()*((int)(endEntryId-startEntryId));\n+\n+            ReplicationVerificationCallback cb = new ReplicationVerificationCallback(numRequests);\n+            for (long i = startEntryId; i < endEntryId; i++) {\n+                for (InetSocketAddress addr : e.getValue()) {\n+                    bkc.bookieClient.readEntry(addr, lh.getId(), i, cb, addr);\n+                }\n+            }\n+\n+            long numSuccess = cb.await();\n+            if (numSuccess < expectedSuccess) {\n+                LOG.warn(\"Fragment not fully replicated ledgerId = \" + lh.getId()\n+                         + \" startEntryId = \" + startEntryId\n+                         + \" endEntryId = \" + endEntryId \n+                         + \" expectedSuccess = \" + expectedSuccess\n+                         + \" gotSuccess = \" + numSuccess);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean findDupesInEnsembles(List<LedgerHandle> lhs) throws Exception {\n+        long numDupes = 0;\n+        for (LedgerHandle lh : lhs) {\n+            String znodepath = StringUtils.getLedgerNodePath(lh.getId());\n+            Stat stat = bkc.getZkHandle().exists(znodepath, false);\n+            assertNotNull(stat);\n+            byte[] mdbytes = bkc.getZkHandle().getData(znodepath, false, stat); \n+            LedgerMetadata md = LedgerMetadata.parseConfig(mdbytes, stat.getVersion()); \n+            \n+            for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : md.getEnsembles().entrySet()) {\n+                HashSet<InetSocketAddress> set = new HashSet<InetSocketAddress>();\n+                long fragment = e.getKey();\n+                \n+                for (InetSocketAddress addr : e.getValue()) {\n+                    if (set.contains(addr)) {\n+                        LOG.error(\"Dupe \" + addr + \" found in ensemble for fragment \" + fragment\n+                                + \" of ledger \" + lh.getId());\n+                        numDupes++;\n+                    }\n+                    set.add(addr);\n+                }\n+            }\n+        }\n+        return numDupes > 0;\n+    }\n+\n+    @Test\n+    public void testAsyncBookieRecoveryToRandomBookiesNotEnoughBookies() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n+\n+        // Write the entries for the ledgers with dummy values.\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+\n+        // Call the async recover bookie method.\n+        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n+                 + \") and replicate it to a random available one\");\n+        // Initiate the sync object\n+        sync.value = false;\n+        try {\n+            bkAdmin.recoverBookieData(bookieSrc, null);\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKLedgerRecoveryException bke) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    @Test\n+    public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exception {\n+        Random r = new Random();\n+        for (int i = 0; i < 10; i++) {\n+            // Create the ledgers\n+            int numLedgers = 3;\n+            List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n+            \n+            // Write the entries for the ledgers with dummy values.\n+            int numMsgs = 100;\n+            writeEntriestoLedgers(numMsgs, 0, lhs);\n+            \n+            // Shutdown the first bookie server\n+            LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n+            int removeIndex = r.nextInt(bs.size());\n+            InetSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n+            bs.get(removeIndex).shutdown();\n+            bs.remove(removeIndex);\n+            \n+            // Startup three new bookie servers\n+            int newBookiePort = initialPort + numBookies + i;\n+            startNewBookie(newBookiePort);\n+            \n+            // Write some more entries for the ledgers so a new ensemble will be\n+            // created for them.\n+            writeEntriestoLedgers(numMsgs, numMsgs, lhs);\n+            \n+            // Call the async recover bookie method.\n+            LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n+                     + \") and replicate it to a random available one\");\n+            // Initiate the sync object\n+            sync.value = false;\n+            bkAdmin.recoverBookieData(bookieSrc, null);\n+            assertFalse(\"Dupes exist in ensembles\", findDupesInEnsembles(lhs));\n+\n+            // Write some more entries to ensure fencing hasn't broken stuff\n+            writeEntriestoLedgers(numMsgs, numMsgs*2, lhs);\n+            for (LedgerHandle lh : lhs) {\n+                assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs*3));\n+                // TODO (BOOKKEEPER-112) this throws an exception at the moment \n+                // because recovering a ledger updates the ledger znode\n+                //lh.close();\n+            }\n+        }\n+    }\n }","previous_filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java"},{"sha":"31e0431e11258dbb30e491b44109b5014671e709","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/75dbf699b90dd01b0dd44e4bdda60e7176b3ee12/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=75dbf699b90dd01b0dd44e4bdda60e7176b3ee12","patch":"@@ -53,19 +53,19 @@\n public abstract class BaseTestCase extends TestCase {\n     static final Logger LOG = Logger.getLogger(BaseTestCase.class);\n     // ZooKeeper related variables\n-    static final String HOSTPORT = \"127.0.0.1:2181\";\n-    static Integer ZooKeeperDefaultPort = 2181;\n-    ZooKeeperServer zks;\n-    ZooKeeper zkc; // zookeeper client\n-    NIOServerCnxnFactory serverFactory;\n-    File ZkTmpDir;\n+    protected static final String HOSTPORT = \"127.0.0.1:2181\";\n+    protected static Integer ZooKeeperDefaultPort = 2181;\n+    protected ZooKeeperServer zks;\n+    protected ZooKeeper zkc; // zookeeper client\n+    protected NIOServerCnxnFactory serverFactory;\n+    protected File ZkTmpDir;\n \n     // BookKeeper\n-    List<File> tmpDirs = new ArrayList<File>();\n-    List<BookieServer> bs = new ArrayList<BookieServer>();\n-    Integer initialPort = 5000;\n-    int numBookies;\n-    BookKeeperTestClient bkc;\n+    protected List<File> tmpDirs = new ArrayList<File>();\n+    protected List<BookieServer> bs = new ArrayList<BookieServer>();\n+    protected Integer initialPort = 5000;\n+    protected int numBookies;\n+    protected BookKeeperTestClient bkc;\n \n     public BaseTestCase(int numBookies) {\n         this.numBookies = numBookies;"}]}

