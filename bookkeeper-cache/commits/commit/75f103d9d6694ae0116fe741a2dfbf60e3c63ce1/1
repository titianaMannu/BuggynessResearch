{"sha":"75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3NWYxMDNkOWQ2Njk0YWUwMTE2ZmU3NDFhMmRmYmY2MGUzYzYzY2Ux","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-01-21T04:19:09Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-01-21T04:19:09Z"},"message":"BOOKKEEPER-696: stats collection on bookkeeper client (Aniruddha, ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1559918 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a24158365e07fe9910cbcadc530dabc6b0e307da","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a24158365e07fe9910cbcadc530dabc6b0e307da"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","html_url":"https://github.com/apache/bookkeeper/commit/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","url":"https://api.github.com/repos/apache/bookkeeper/commits/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","html_url":"https://github.com/apache/bookkeeper/commit/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc"}],"stats":{"total":516,"additions":431,"deletions":85},"files":[{"sha":"bbf13fedc3dcf493b34706d67bd4273086b6c8c8","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -140,6 +140,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-429: Provide separate read and write threads in the bookkeeper server (Aniruddha via sijie)\n \n+        BOOKKEEPER-696: stats collection on bookkeeper client (Aniruddha, ivank via sijie)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"fc86789179aa2cf9f6d5049c966dac32a8fc52dc","filename":"bookkeeper-server/pom.xml","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/pom.xml?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -32,6 +32,11 @@\n     <project.libdir>${basedir}/lib</project.libdir>\n   </properties>\n   <dependencies>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper.stats</groupId>\n+      <artifactId>bookkeeper-stats-api</artifactId>\n+      <version>${project.parent.version}</version>\n+    </dependency>\n     <dependency>\n       <groupId>com.google.protobuf</groupId>\n       <artifactId>protobuf-java</artifactId>\n@@ -255,5 +260,25 @@\n         </plugins>\n       </build>\n     </profile>\n+    <profile>\n+      <id>twitter-science-provider</id>\n+      <dependencies>\n+        <dependency>\n+          <groupId>org.apache.bookkeeper.stats</groupId>\n+          <artifactId>twitter-science-provider</artifactId>\n+          <version>${project.parent.version}</version>\n+        </dependency>\n+      </dependencies>\n+    </profile>\n+    <profile>\n+      <id>codahale-metrics-provider</id>\n+      <dependencies>\n+        <dependency>\n+          <groupId>org.apache.bookkeeper.stats</groupId>\n+          <artifactId>codahale-metrics-provider</artifactId>\n+          <version>${project.parent.version}</version>\n+        </dependency>\n+      </dependencies>\n+    </profile>\n   </profiles>\n </project>"},{"sha":"a91861cf6f675b1a7c8849be14f051637aa558ce","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":100,"deletions":3,"changes":103,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -36,6 +36,9 @@\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n@@ -72,6 +75,14 @@\n     final static int zkConnectTimeoutMs = 5000;\n     final ClientSocketChannelFactory channelFactory;\n \n+    // The stats logger for this client.\n+    private final StatsLogger statsLogger;\n+    private OpStatsLogger createOpLogger;\n+    private OpStatsLogger openOpLogger;\n+    private OpStatsLogger deleteOpLogger;\n+    private OpStatsLogger readOpLogger;\n+    private OpStatsLogger addOpLogger;\n+\n     // whether the socket factory is one we created, or is owned by whoever\n     // instantiated us\n     boolean ownChannelFactory = false;\n@@ -99,6 +110,63 @@\n         public void connectionFailed(int code);\n     }\n \n+    static class Builder {\n+        final ClientConfiguration conf;\n+\n+        ZooKeeper zk = null;\n+        ClientSocketChannelFactory channelFactory = null;\n+        StatsLogger statsLogger = NullStatsLogger.INSTANCE;\n+\n+        Builder(ClientConfiguration conf) {\n+            this.conf = conf;\n+        }\n+\n+        Builder setChannelFactory(ClientSocketChannelFactory f) {\n+            channelFactory = f;\n+            return this;\n+        }\n+\n+        Builder setZookeeper(ZooKeeper zk) {\n+            this.zk = zk;\n+            return this;\n+        }\n+\n+        Builder setStatsLogger(StatsLogger statsLogger) {\n+            this.statsLogger = statsLogger;\n+            return this;\n+        }\n+\n+        BookKeeper build() throws IOException, InterruptedException, KeeperException {\n+            boolean ownZK = false;\n+            boolean ownChannelFactory = false;\n+            if (zk == null) {\n+                ownZK = true;\n+                ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(conf.getZkTimeout());\n+                zk = ZkUtils.createConnectedZookeeperClient(conf.getZkServers(), w);\n+                w.waitForConnection();\n+            }\n+            if (channelFactory == null) {\n+                ownChannelFactory = true;\n+                ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n+                channelFactory = new NioClientSocketChannelFactory(\n+                        Executors.newCachedThreadPool(tfb.setNameFormat(\n+                                                              \"BookKeeper-NIOBoss-%d\").build()),\n+                        Executors.newCachedThreadPool(tfb.setNameFormat(\n+                                                              \"BookKeeper-NIOWorker-%d\").build()));\n+            }\n+\n+            BookKeeper bk = new BookKeeper(conf, zk, channelFactory, statsLogger);\n+            bk.ownZKHandle = ownZK;\n+            bk.ownChannelFactory = ownChannelFactory;\n+\n+            return bk;\n+        }\n+    }\n+\n+    public static Builder forConfig(final ClientConfiguration conf) {\n+        return new Builder(conf);\n+    }\n+\n     /**\n      * Create a bookkeeper client. A zookeeper client and a client socket factory\n      * will be instantiated as part of this constructor.\n@@ -142,6 +210,8 @@ public BookKeeper(final ClientConfiguration conf)\n                         \"BookKeeper-NIOWorker-%d\").build()));\n         this.scheduler = Executors.newSingleThreadScheduledExecutor(tfb\n                 .setNameFormat(\"BookKeeperClientScheduler-%d\").build());\n+        this.statsLogger = NullStatsLogger.INSTANCE;\n+        initOpLoggers(this.statsLogger);\n         // initialize the ensemble placement\n         this.placementPolicy = initializeEnsemblePlacementPolicy(conf);\n \n@@ -156,7 +226,7 @@ public BookKeeper(final ClientConfiguration conf)\n \n         ownChannelFactory = true;\n         ownZKHandle = true;\n-     }\n+    }\n \n     /**\n      * Create a bookkeeper client but use the passed in zookeeper client instead\n@@ -202,6 +272,15 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk)\n      */\n     public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n             throws IOException, InterruptedException, KeeperException {\n+        this(conf, zk, channelFactory, NullStatsLogger.INSTANCE);\n+    }\n+\n+    /**\n+     * Contructor for use with the builder. Other constructors also use it.\n+     */\n+    private BookKeeper(ClientConfiguration conf, ZooKeeper zk,\n+                       ClientSocketChannelFactory channelFactory, StatsLogger statsLogger)\n+            throws IOException, InterruptedException, KeeperException {\n         if (zk == null || channelFactory == null) {\n             throw new NullPointerException();\n         }\n@@ -216,12 +295,15 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n                 \"BookKeeperClientScheduler-%d\");\n         this.scheduler = Executors\n                 .newSingleThreadScheduledExecutor(tfb.build());\n+        this.statsLogger = statsLogger.scope(BookKeeperClientStats.CLIENT_SCOPE);\n+        initOpLoggers(this.statsLogger);\n+\n         // initialize the ensemble placement\n         this.placementPolicy = initializeEnsemblePlacementPolicy(conf);\n \n         mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads(),\n                 \"BookKeeperClientWorker\");\n-        bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n+        bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool, statsLogger);\n         bookieWatcher = new BookieWatcher(conf, scheduler, placementPolicy, this);\n         bookieWatcher.readBookiesBlocking();\n \n@@ -262,6 +344,10 @@ protected ClientConfiguration getConf() {\n         return conf;\n     }\n \n+    StatsLogger getStatsLogger() {\n+        return statsLogger;\n+    }\n+\n     /**\n      * Get the BookieClient, currently used for doing bookie recovery.\n      *\n@@ -747,6 +833,17 @@ public void deleteComplete(int rc, Object ctx) {\n         }\n     }\n \n+    private final void initOpLoggers(StatsLogger stats) {\n+        createOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.CREATE_OP);\n+        deleteOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.DELETE_OP);\n+        openOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.OPEN_OP);\n+        readOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_OP);\n+        addOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.ADD_OP);\n+    }\n \n-\n+    OpStatsLogger getCreateOpLogger() { return createOpLogger; }\n+    OpStatsLogger getOpenOpLogger() { return openOpLogger; }\n+    OpStatsLogger getDeleteOpLogger() { return deleteOpLogger; }\n+    OpStatsLogger getReadOpLogger() { return readOpLogger; }\n+    OpStatsLogger getAddOpLogger() { return addOpLogger; }\n }"},{"sha":"30948da50adc03b0aa7e721ab2151159244738bd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+public interface BookKeeperClientStats {\n+    public final static String CLIENT_SCOPE = \"bookkeeper_client\";\n+    public final static String CREATE_OP = \"LEDGER_CREATE\";\n+    public final static String DELETE_OP = \"LEDGER_DELETE\";\n+    public final static String OPEN_OP = \"LEDGER_OPEN\";\n+    public final static String ADD_OP = \"ADD_ENTRY\";\n+    public final static String READ_OP = \"READ_ENTRY\";\n+    public final static String PENDING_ADDS = \"NUM_PENDING_ADD\";\n+    public final static String ENSEMBLE_CHANGES = \"NUM_ENSEMBLE_CHANGE\";\n+\n+    // per channel stats\n+    public final static String CHANNEL_SCOPE = \"per_channel_bookie_client\";\n+\n+    public final static String CHANNEL_READ_OP = \"READ_ENTRY\";\n+    public final static String CHANNEL_TIMEOUT_READ = \"TIMEOUT_READ_ENTRY\";\n+    public final static String CHANNEL_ADD_OP = \"ADD_ENTRY\";\n+    public final static String CHANNEL_TIMEOUT_ADD = \"TIMEOUT_ADD_ENTRY\";\n+}"},{"sha":"2681f089d93c117299dccab0876bcb5d379ba7b1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":21,"deletions":7,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -29,7 +29,8 @@\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -48,6 +49,8 @@\n     byte[] passwd;\n     BookKeeper bk;\n     DigestType digestType;\n+    long startTime;\n+    OpStatsLogger createOpLogger;\n \n     /**\n      * Constructor\n@@ -78,6 +81,8 @@\n         this.passwd = passwd;\n         this.cb = cb;\n         this.ctx = ctx;\n+        this.startTime = MathUtils.nowInNano();\n+        this.createOpLogger = bk.getCreateOpLogger();\n     }\n \n     /**\n@@ -96,7 +101,7 @@ public void initiate() {\n                     .newEnsemble(metadata.getEnsembleSize(), metadata.getWriteQuorumSize());\n         } catch (BKNotEnoughBookiesException e) {\n             LOG.error(\"Not enough bookies to create ledger\");\n-            cb.createComplete(e.getCode(), null, this.ctx);\n+            createComplete(e.getCode(), null);\n             return;\n         }\n \n@@ -115,24 +120,33 @@ public void initiate() {\n     @Override\n     public void operationComplete(int rc, Long ledgerId) {\n         if (BKException.Code.OK != rc) {\n-            cb.createComplete(rc, null, this.ctx);\n+            createComplete(rc, null);\n             return;\n         }\n \n         try {\n             lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n         } catch (GeneralSecurityException e) {\n             LOG.error(\"Security exception while creating ledger: \" + ledgerId, e);\n-            cb.createComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);\n+            createComplete(BKException.Code.DigestNotInitializedException, null);\n             return;\n         } catch (NumberFormatException e) {\n             LOG.error(\"Incorrectly entered parameter throttle: \" + bk.getConf().getThrottleValue(), e);\n-            cb.createComplete(BKException.Code.IncorrectParameterException, null, this.ctx);\n+            createComplete(BKException.Code.IncorrectParameterException, null);\n             return;\n         }\n-\n         // return the ledger handle back\n-        cb.createComplete(BKException.Code.OK, lh, this.ctx);\n+        createComplete(BKException.Code.OK, lh);\n+    }\n+\n+    private void createComplete(int rc, LedgerHandle lh) {\n+        // Opened a new ledger\n+        if (BKException.Code.OK != rc) {\n+            createOpLogger.registerFailedEvent(MathUtils.elapsedMSec(startTime));\n+        } else {\n+            createOpLogger.registerSuccessfulEvent(MathUtils.elapsedMSec(startTime));\n+        }\n+        cb.createComplete(rc, lh, ctx);\n     }\n \n }"},{"sha":"f8caa5be03777deff259eaf24e8ae50e46a2adc9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -22,6 +22,8 @@\n package org.apache.bookkeeper.client;\n \n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n import org.apache.bookkeeper.versioning.Version;\n import org.slf4j.Logger;\n@@ -39,6 +41,8 @@\n     long ledgerId;\n     DeleteCallback cb;\n     Object ctx;\n+    long startTime;\n+    OpStatsLogger deleteOpLogger;\n \n     /**\n      * Constructor\n@@ -58,6 +62,8 @@\n         this.ledgerId = ledgerId;\n         this.cb = cb;\n         this.ctx = ctx;\n+        this.startTime = MathUtils.nowInNano();\n+        this.deleteOpLogger = bk.getDeleteOpLogger();\n     }\n \n     /**\n@@ -74,6 +80,11 @@ public void initiate() {\n      */\n     @Override\n     public void safeOperationComplete(int rc, Void result) {\n+        if (BKException.Code.OK != rc) {\n+            deleteOpLogger.registerFailedEvent(startTime);\n+        } else {\n+            deleteOpLogger.registerSuccessfulEvent(startTime);\n+        }\n         cb.deleteComplete(rc, this.ctx);\n     }\n }"},{"sha":"bf4bd97f28f033bcdb46ee0ba3dbb6d80cb256ae","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":40,"deletions":19,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -39,6 +39,8 @@\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.Gauge;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.jboss.netty.buffer.ChannelBuffer;\n@@ -75,6 +77,8 @@\n     final AtomicInteger blockAddCompletions = new AtomicInteger(0);\n     final Queue<PendingAddOp> pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n \n+    final Counter ensembleChangeCounter;\n+\n     LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n                  DigestType digestType, byte[] password)\n             throws GeneralSecurityException, NumberFormatException {\n@@ -97,6 +101,17 @@\n         this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n         distributionSchedule = new RoundRobinDistributionSchedule(\n                 metadata.getWriteQuorumSize(), metadata.getAckQuorumSize(), metadata.getEnsembleSize());\n+\n+        ensembleChangeCounter = bk.getStatsLogger().getCounter(BookKeeperClientStats.ENSEMBLE_CHANGES);\n+        bk.getStatsLogger().registerGauge(BookKeeperClientStats.PENDING_ADDS,\n+                                          new Gauge<Integer>() {\n+                                              public Integer getDefaultValue() {\n+                                                  return 0;\n+                                              }\n+                                              public Integer getSample() {\n+                                                  return pendingAddOps.size();\n+                                              }\n+                                          });\n     }\n \n     /**\n@@ -200,7 +215,7 @@ void writeLedgerConfig(GenericCallback<Void> writeCb) {\n      * Close this ledger synchronously.\n      * @see #asyncClose\n      */\n-    public void close() \n+    public void close()\n             throws InterruptedException, BKException {\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n@@ -215,11 +230,11 @@ public void close()\n \n     /**\n      * Asynchronous close, any adds in flight will return errors.\n-     * \n-     * Closing a ledger will ensure that all clients agree on what the last entry \n-     * of the ledger is. This ensures that, once the ledger has been closed, all \n-     * reads from the ledger will return the same set of entries. \n-     * \n+     *\n+     * Closing a ledger will ensure that all clients agree on what the last entry\n+     * of the ledger is. This ensures that, once the ledger has been closed, all\n+     * reads from the ledger will return the same set of entries.\n+     *\n      * @param cb\n      *          callback implementation\n      * @param ctx\n@@ -416,7 +431,7 @@ public long addEntry(byte[] data, int offset, int length)\n         SyncAddCallback callback = new SyncAddCallback();\n         asyncAddEntry(data, offset, length, callback, counter);\n         counter.block(0);\n-        \n+\n         if (counter.getrc() != BKException.Code.OK) {\n             throw BKException.create(counter.getrc());\n         }\n@@ -521,14 +536,14 @@ public void safeRun() {\n     }\n \n     /**\n-     * Obtains asynchronously the last confirmed write from a quorum of bookies. This \n+     * Obtains asynchronously the last confirmed write from a quorum of bookies. This\n      * call obtains the the last add confirmed each bookie has received for this ledger\n      * and returns the maximum. If the ledger has been closed, the value returned by this\n      * call may not correspond to the id of the last entry of the ledger, since it reads\n-     * the hint of bookies. Consequently, in the case the ledger has been closed, it may \n-     * return a different value than getLastAddConfirmed, which returns the local value \n+     * the hint of bookies. Consequently, in the case the ledger has been closed, it may\n+     * return a different value than getLastAddConfirmed, which returns the local value\n      * of the ledger handle.\n-     * \n+     *\n      * @see #getLastAddConfirmed()\n      *\n      * @param cb\n@@ -601,18 +616,17 @@ boolean ready() {\n      * obtains the the last add confirmed each bookie has received for this ledger\n      * and returns the maximum. If the ledger has been closed, the value returned by this\n      * call may not correspond to the id of the last entry of the ledger, since it reads\n-     * the hint of bookies. Consequently, in the case the ledger has been closed, it may \n-     * return a different value than getLastAddConfirmed, which returns the local value \n+     * the hint of bookies. Consequently, in the case the ledger has been closed, it may\n+     * return a different value than getLastAddConfirmed, which returns the local value\n      * of the ledger handle.\n-     * \n+     *\n      * @see #getLastAddConfirmed()\n-     * \n+     *\n      * @return The entry id of the last confirmed write or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}\n      *         if no entry has been confirmed\n      * @throws InterruptedException\n      * @throws BKException\n      */\n-    \n     public long readLastConfirmed()\n             throws InterruptedException, BKException {\n         LastConfirmedCtx ctx = new LastConfirmedCtx();\n@@ -745,6 +759,9 @@ public EnsembleInfo(ArrayList<InetSocketAddress> newEnsemble,\n         @Override\n         public void safeOperationComplete(final int rc, Void result) {\n             if (rc == BKException.Code.MetadataVersionException) {\n+                // We changed the ensemble, but got a version exception. We\n+                // should still consider this as an ensemble change\n+                ensembleChangeCounter.inc();\n                 rereadMetadata(new ReReadLedgerMetadataCb(rc,\n                                        ensembleInfo));\n                 return;\n@@ -758,6 +775,8 @@ public void safeOperationComplete(final int rc, Void result) {\n             }\n             blockAddCompletions.decrementAndGet();\n \n+            // We've successfully changed an ensemble\n+            ensembleChangeCounter.inc();\n             // the failed bookie has been replaced\n             unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n         }\n@@ -850,6 +869,8 @@ private boolean resolveConflict(LedgerMetadata newMeta) {\n                     return updateMetadataIfPossible(newMeta);\n                 }\n             } else {\n+                ensembleChangeCounter.inc();\n+                // We've successfully changed an ensemble\n                 // the failed bookie has been replaced\n                 blockAddCompletions.decrementAndGet();\n                 unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n@@ -948,7 +969,7 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n             // noop\n         }\n     }\n-    \n+\n     private static class SyncReadCallback implements ReadCallback {\n         /**\n          * Implementation of callback interface for synchronous read method.\n@@ -965,7 +986,7 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n         @Override\n         public void readComplete(int rc, LedgerHandle lh,\n                                  Enumeration<LedgerEntry> seq, Object ctx) {\n-            \n+\n             SyncCounter counter = (SyncCounter) ctx;\n             synchronized (counter) {\n                 counter.setSequence(seq);\n@@ -1008,7 +1029,7 @@ public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n         @Override\n         public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n             LastConfirmedCtx lcCtx = (LastConfirmedCtx) ctx;\n-            \n+\n             synchronized(lcCtx) {\n                 lcCtx.setRC(rc);\n                 lcCtx.setLastConfirmed(lastConfirmed);"},{"sha":"5b8a703271acc9233695a7afca7637170ec6ae05","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":37,"deletions":21,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -28,6 +28,8 @@\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n \n import org.slf4j.Logger;\n@@ -49,6 +51,8 @@\n     final DigestType digestType;\n     boolean doRecovery = true;\n     boolean administrativeOpen = false;\n+    long startTime;\n+    OpStatsLogger openOpLogger;\n \n     /**\n      * Constructor.\n@@ -85,6 +89,10 @@ public LedgerOpenOp(BookKeeper bk, long ledgerId, OpenCallback cb, Object ctx) {\n      * Inititates the ledger open operation\n      */\n     public void initiate() {\n+        startTime = MathUtils.nowInNano();\n+\n+        openOpLogger = bk.getOpenOpLogger();\n+\n         /**\n          * Asynchronously read the ledger metadata node.\n          */\n@@ -102,10 +110,11 @@ public void initiateWithoutRecovery() {\n     /**\n      * Implements Open Ledger Callback.\n      */\n+    @Override\n     public void operationComplete(int rc, LedgerMetadata metadata) {\n         if (BKException.Code.OK != rc) {\n             // open ledger failed.\n-            cb.openComplete(rc, null, this.ctx);\n+            openComplete(rc, null);\n             return;\n         }\n \n@@ -125,12 +134,12 @@ public void operationComplete(int rc, LedgerMetadata metadata) {\n             if (metadata.hasPassword()) {\n                 if (!Arrays.equals(passwd, metadata.getPassword())) {\n                     LOG.error(\"Provided passwd does not match that in metadata\");\n-                    cb.openComplete(BKException.Code.UnauthorizedAccessException, null, this.ctx);\n+                    openComplete(BKException.Code.UnauthorizedAccessException, null);\n                     return;\n                 }\n                 if (digestType != metadata.getDigestType()) {\n                     LOG.error(\"Provided digest does not match that in metadata\");\n-                    cb.openComplete(BKException.Code.DigestMatchException, null, this.ctx);\n+                    openComplete(BKException.Code.DigestMatchException, null);\n                     return;\n                 }\n             }\n@@ -141,49 +150,56 @@ public void operationComplete(int rc, LedgerMetadata metadata) {\n             lh = new ReadOnlyLedgerHandle(bk, ledgerId, metadata, digestType, passwd, !doRecovery);\n         } catch (GeneralSecurityException e) {\n             LOG.error(\"Security exception while opening ledger: \" + ledgerId, e);\n-            cb.openComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);\n+            openComplete(BKException.Code.DigestNotInitializedException, null);\n             return;\n         } catch (NumberFormatException e) {\n             LOG.error(\"Incorrectly entered parameter throttle: \" + bk.getConf().getThrottleValue(), e);\n-            cb.openComplete(BKException.Code.IncorrectParameterException, null, this.ctx);\n+            openComplete(BKException.Code.IncorrectParameterException, null);\n             return;\n         }\n \n         if (metadata.isClosed()) {\n             // Ledger was closed properly\n-            cb.openComplete(BKException.Code.OK, lh, this.ctx);\n+            openComplete(BKException.Code.OK, lh);\n             return;\n         }\n \n         if (doRecovery) {\n             lh.recover(new OrderedSafeGenericCallback<Void>(bk.mainWorkerPool, ledgerId) {\n-                    @Override\n-                    public void safeOperationComplete(int rc, Void result) {\n-                        if (rc == BKException.Code.OK) {\n-                            cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n-                        } else if (rc == BKException.Code.UnauthorizedAccessException) {\n-                            cb.openComplete(BKException.Code.UnauthorizedAccessException, null, LedgerOpenOp.this.ctx);\n-                        } else {\n-                            cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n-                        }\n+                @Override\n+                public void safeOperationComplete(int rc, Void result) {\n+                    if (rc == BKException.Code.OK) {\n+                        openComplete(BKException.Code.OK, lh);\n+                    } else if (rc == BKException.Code.UnauthorizedAccessException) {\n+                        openComplete(BKException.Code.UnauthorizedAccessException, null);\n+                    } else {\n+                        openComplete(BKException.Code.LedgerRecoveryException, null);\n                     }\n-                });\n+                }\n+            });\n         } else {\n             lh.asyncReadLastConfirmed(new ReadLastConfirmedCallback() {\n-\n                 @Override\n                 public void readLastConfirmedComplete(int rc,\n                         long lastConfirmed, Object ctx) {\n                     if (rc != BKException.Code.OK) {\n-                        cb.openComplete(BKException.Code.ReadException, null, LedgerOpenOp.this.ctx);\n+                        openComplete(BKException.Code.ReadException, null);\n                     } else {\n                         lh.lastAddConfirmed = lh.lastAddPushed = lastConfirmed;\n-                        cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n+                        openComplete(BKException.Code.OK, lh);\n                     }\n                 }\n-                \n             }, null);\n-            \n+\n+        }\n+    }\n+\n+    void openComplete(int rc, LedgerHandle lh) {\n+        if (BKException.Code.OK != rc) {\n+            openOpLogger.registerFailedEvent(startTime);\n+        } else {\n+            openOpLogger.registerSuccessfulEvent(startTime);\n         }\n+        cb.openComplete(rc, lh, ctx);\n     }\n }"},{"sha":"8f1f18a80e1686b13136846ff01c252cec96dc26","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":12,"deletions":2,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -23,6 +23,8 @@\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -51,14 +53,18 @@\n \n     LedgerHandle lh;\n     boolean isRecoveryAdd = false;\n+    long requestTimeMillis;\n+    OpStatsLogger addOpLogger;\n \n     PendingAddOp(LedgerHandle lh, AddCallback cb, Object ctx) {\n         this.lh = lh;\n         this.cb = cb;\n         this.ctx = ctx;\n         this.entryId = LedgerHandle.INVALID_ENTRY_ID;\n-        \n+\n         ackSet = lh.distributionSchedule.getAckSet();\n+\n+        addOpLogger = lh.bk.getAddOpLogger();\n     }\n \n     /**\n@@ -123,6 +129,7 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n     }\n \n     void initiate(ChannelBuffer toSend, int entryLength) {\n+        requestTimeMillis = MathUtils.now();\n         this.toSend = toSend;\n         this.entryLength = entryLength;\n         for (int bookieIndex : writeSet) {\n@@ -177,11 +184,14 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n     }\n \n     void submitCallback(final int rc) {\n+        long latencyMillis = MathUtils.now() - requestTimeMillis;\n         if (rc != BKException.Code.OK) {\n+            addOpLogger.registerFailedEvent(latencyMillis);\n             LOG.error(\"Write of ledger entry to quorum failed: L{} E{}\",\n                       lh.getId(), entryId);\n+        } else {\n+            addOpLogger.registerSuccessfulEvent(latencyMillis);\n         }\n-\n         cb.addComplete(rc, lh, entryId, ctx);\n     }\n "},{"sha":"6cf6c1bf9052fab15595acd2063f83e70db4bdfa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":31,"deletions":8,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,6 +18,8 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.client;\n+\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.BitSet;\n@@ -38,6 +38,8 @@\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.buffer.ChannelBufferInputStream;\n import org.slf4j.Logger;\n@@ -64,6 +66,9 @@\n     long numPendingEntries;\n     long startEntryId;\n     long endEntryId;\n+    long requestTimeMillis;\n+    OpStatsLogger readOpLogger;\n+\n     final int maxMissedReadsAllowed;\n \n     class LedgerEntryRequest extends LedgerEntry {\n@@ -238,6 +243,7 @@ boolean isComplete() {\n             return complete.get();\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\"L%d-E%d\", ledgerId, entryId);\n         }\n@@ -257,24 +263,37 @@ public String toString() {\n                 - getLedgerMetadata().getAckQuorumSize();\n         speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n         heardFromHosts = new HashSet<InetSocketAddress>();\n+\n+        readOpLogger = lh.bk.getReadOpLogger();\n     }\n \n     protected LedgerMetadata getLedgerMetadata() {\n         return lh.metadata;\n     }\n \n+    private void cancelSpeculativeTask(boolean mayInterruptIfRunning) {\n+        if (speculativeTask != null) {\n+            speculativeTask.cancel(mayInterruptIfRunning);\n+            speculativeTask = null;\n+        }\n+    }\n+\n     public void initiate() throws InterruptedException {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n-\n+        this.requestTimeMillis = MathUtils.now();\n         ArrayList<InetSocketAddress> ensemble = null;\n \n         if (speculativeReadTimeout > 0) {\n             speculativeTask = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                    @Override\n                     public void run() {\n                         int x = 0;\n                         for (LedgerEntryRequest r : seq) {\n                             if (!r.isComplete()) {\n-                                if (null != r.maybeSendSpeculativeRead(heardFromHosts)) {\n+                                if (null == r.maybeSendSpeculativeRead(heardFromHosts)) {\n+                                    // Subsequent speculative read will not materialize anyway\n+                                    cancelSpeculativeTask(false);\n+                                } else {\n                                     LOG.debug(\"Send speculative read for {}. Hosts heard are {}.\",\n                                               r, heardFromHosts);\n                                     ++x;\n@@ -343,10 +362,7 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n     }\n \n     private void submitCallback(int code) {\n-        if (speculativeTask != null) {\n-            speculativeTask.cancel(true);\n-            speculativeTask = null;\n-        }\n+        long latencyMillis = MathUtils.now() - requestTimeMillis;\n         if (code != BKException.Code.OK) {\n             long firstUnread = LedgerHandle.INVALID_ENTRY_ID;\n             for (LedgerEntryRequest req : seq) {\n@@ -357,13 +373,20 @@ private void submitCallback(int code) {\n             }\n             LOG.error(\"Read of ledger entry failed: L{} E{}-E{}, Heard from {}. First unread entry is {}\",\n                     new Object[] { lh.getId(), startEntryId, endEntryId, heardFromHosts, firstUnread });\n+            readOpLogger.registerFailedEvent(latencyMillis);\n+        } else {\n+            readOpLogger.registerSuccessfulEvent(latencyMillis);\n         }\n+        cancelSpeculativeTask(true);\n         cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);\n     }\n+\n+    @Override\n     public boolean hasMoreElements() {\n         return !seq.isEmpty();\n     }\n \n+    @Override\n     public LedgerEntry nextElement() throws NoSuchElementException {\n         return seq.remove();\n     }"},{"sha":"696bcc26cf7b3083b5bae84e9e42398737891ce6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -39,6 +39,8 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.jboss.netty.buffer.ChannelBuffer;\n@@ -70,13 +72,20 @@\n     private final ClientConfiguration conf;\n     private volatile boolean closed;\n     private final ReentrantReadWriteLock closeLock;\n+    private final StatsLogger statsLogger;\n \n     public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n+        this(conf, channelFactory, executor, NullStatsLogger.INSTANCE);\n+    }\n+\n+    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor,\n+                        StatsLogger statsLogger) {\n         this.conf = conf;\n         this.channelFactory = channelFactory;\n         this.executor = executor;\n         this.closed = false;\n         this.closeLock = new ReentrantReadWriteLock();\n+        this.statsLogger = statsLogger;\n     }\n \n     public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n@@ -89,7 +98,7 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n                     return null;\n                 }\n                 channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding,\n-                        timeoutExecutor);\n+                        timeoutExecutor, statsLogger);\n                 PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n                 if (prevChannel != null) {\n                     channel = prevChannel;"},{"sha":"d8ebaf61bd26d62021f8c3b0418b04b7cec9240d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":98,"deletions":23,"changes":121,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -28,10 +28,14 @@\n import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n@@ -69,6 +73,7 @@\n     static final long maxMemory = Runtime.getRuntime().maxMemory() / 5;\n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n \n+\n     InetSocketAddress addr;\n     AtomicLong totalBytesOutstanding;\n     ClientSocketChannelFactory channelFactory;\n@@ -78,6 +83,12 @@\n     ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n     ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n \n+    private final StatsLogger statsLogger;\n+    private final OpStatsLogger readEntryOpLogger;\n+    private final OpStatsLogger readTimeoutOpLogger;\n+    private final OpStatsLogger addEntryOpLogger;\n+    private final OpStatsLogger addTimeoutOpLogger;\n+\n     /**\n      * The following member variables do not need to be concurrent, or volatile\n      * because they are always updated under a lock\n@@ -108,17 +119,23 @@ private void errorOutTimedOutEntries() {\n         try {\n             for (CompletionKey key : addCompletions.keySet()) {\n                 total++;\n-                if (key.shouldTimeout(conf.getAddEntryTimeout() * 1000)) {\n-                    errorOutAddKey(key);\n-                    numAdd++;\n+                long elapsedTime = key.elapsedTime();\n+                if (elapsedTime < conf.getAddEntryTimeout() * 1000) {\n+                    continue;\n                 }\n+                errorOutAddKey(key);\n+                numAdd++;\n+                addTimeoutOpLogger.registerSuccessfulEvent(elapsedTime);\n             }\n             for (CompletionKey key : readCompletions.keySet()) {\n                 total++;\n-                if (key.shouldTimeout(conf.getReadEntryTimeout() * 1000)) {\n-                    errorOutReadKey(key);\n-                    numRead++;\n+                long elapsedTime = key.elapsedTime();\n+                if (elapsedTime < conf.getReadEntryTimeout() * 1000) {\n+                    continue;\n                 }\n+                errorOutReadKey(key);\n+                numRead++;\n+                readTimeoutOpLogger.registerSuccessfulEvent(elapsedTime);\n             }\n         } catch (Throwable t) {\n             LOG.error(\"Caught RuntimeException while erroring out timed out entries : \", t);\n@@ -133,23 +150,39 @@ private void errorOutTimedOutEntries() {\n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n                                   InetSocketAddress addr, AtomicLong totalBytesOutstanding,\n                                   ScheduledExecutorService timeoutExecutor) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, timeoutExecutor);\n+        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, timeoutExecutor,\n+                NullStatsLogger.INSTANCE);\n     }\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n                                   InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, null);\n+        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, null,\n+                NullStatsLogger.INSTANCE);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n                                   ClientSocketChannelFactory channelFactory, InetSocketAddress addr,\n-                                  AtomicLong totalBytesOutstanding, ScheduledExecutorService timeoutExecutor) {\n+                                  AtomicLong totalBytesOutstanding, ScheduledExecutorService timeoutExecutor,\n+                                  StatsLogger parentStatsLogger) {\n         this.conf = conf;\n         this.addr = addr;\n         this.executor = executor;\n         this.totalBytesOutstanding = totalBytesOutstanding;\n         this.channelFactory = channelFactory;\n         this.state = ConnectionState.DISCONNECTED;\n+\n+        StringBuilder nameBuilder = new StringBuilder();\n+        nameBuilder.append(addr.getHostName().replace('.', '_').replace('-', '_'))\n+            .append(\"_\").append(addr.getPort());\n+\n+        this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE)\n+            .scope(nameBuilder.toString());\n+\n+        readEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_OP);\n+        addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);\n+        readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);\n+        addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);\n+\n         this.timeoutExecutor = timeoutExecutor;\n         // scheudle the timeout task\n         if (null != this.timeoutExecutor) {\n@@ -282,7 +315,7 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n                 ledgerId, entryId, (short)options, masterKey, toSend);\n         final int entrySize = toSend.readableBytes();\n         final CompletionKey completionKey = new CompletionKey(ledgerId, entryId);\n-        addCompletions.put(completionKey, new AddCompletion(cb, entrySize, ctx));\n+        addCompletions.put(completionKey, new AddCompletion(addEntryOpLogger, cb, ctx));\n         final Channel c = channel;\n         if (c == null) {\n             errorOutAddKey(completionKey);\n@@ -318,7 +351,7 @@ public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n                                         final long entryId,\n                                         ReadEntryCallback cb, Object ctx) {\n         final CompletionKey key = new CompletionKey(ledgerId, entryId);\n-        readCompletions.put(key, new ReadCompletion(cb, ctx));\n+        readCompletions.put(key, new ReadCompletion(readEntryOpLogger, cb, ctx));\n \n         final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n                 BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n@@ -357,7 +390,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n         final CompletionKey key = new CompletionKey(ledgerId, entryId);\n-        readCompletions.put(key, new ReadCompletion(cb, ctx));\n+        readCompletions.put(key, new ReadCompletion(readEntryOpLogger, cb, ctx));\n \n         final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n                 BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n@@ -713,27 +746,69 @@ void handleReadResponse(BookieProtocol.ReadResponse rr) {\n      * Boiler-plate wrapper classes follow\n      *\n      */\n+\n     // visible for testing\n-    static class ReadCompletion {\n-        final ReadEntryCallback cb;\n+    static abstract class CompletionValue {\n         final Object ctx;\n \n-        public ReadCompletion(ReadEntryCallback cb, Object ctx) {\n-            this.cb = cb;\n+        public CompletionValue(Object ctx) {\n             this.ctx = ctx;\n         }\n     }\n \n     // visible for testing\n-    static class AddCompletion {\n+    static class ReadCompletion extends CompletionValue {\n+        final ReadEntryCallback cb;\n+\n+        public ReadCompletion(ReadEntryCallback cb, Object ctx) {\n+            this(null, cb, ctx);\n+        }\n+\n+        public ReadCompletion(final OpStatsLogger readEntryOpLogger,\n+                              final ReadEntryCallback originalCallback,\n+                              final Object originalCtx) {\n+            super(originalCtx);\n+            final long requestTimeMillis = MathUtils.now();\n+            this.cb = null == readEntryOpLogger ? originalCallback : new ReadEntryCallback() {\n+                @Override\n+                public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n+                    long latencyMillis = MathUtils.now() - requestTimeMillis;\n+                    if (rc != BKException.Code.OK) {\n+                        readEntryOpLogger.registerFailedEvent(latencyMillis);\n+                    } else {\n+                        readEntryOpLogger.registerSuccessfulEvent(latencyMillis);\n+                    }\n+                    originalCallback.readEntryComplete(rc, ledgerId, entryId, buffer, originalCtx);\n+                }\n+            };\n+        }\n+    }\n+\n+    // visible for testing\n+    static class AddCompletion extends CompletionValue {\n         final WriteCallback cb;\n-        //final long size;\n-        final Object ctx;\n \n-        public AddCompletion(WriteCallback cb, long size, Object ctx) {\n-            this.cb = cb;\n-            //this.size = size;\n-            this.ctx = ctx;\n+        public AddCompletion(WriteCallback cb, Object ctx) {\n+            this(null, cb, ctx);\n+        }\n+\n+        public AddCompletion(final OpStatsLogger addEntryOpLogger,\n+                             final WriteCallback originalCallback,\n+                             final Object originalCtx) {\n+            super(originalCtx);\n+            final long requestTimeMillis = MathUtils.now();\n+            this.cb = null == addEntryOpLogger ? originalCallback : new WriteCallback() {\n+                @Override\n+                public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+                    long latencyMillis = MathUtils.now() - requestTimeMillis;\n+                    if (rc != BKException.Code.OK) {\n+                        addEntryOpLogger.registerFailedEvent(latencyMillis);\n+                    } else {\n+                        addEntryOpLogger.registerSuccessfulEvent(latencyMillis);\n+                    }\n+                    originalCallback.writeComplete(rc, ledgerId, entryId, addr, originalCtx);\n+                }\n+            };\n         }\n     }\n "},{"sha":"5e55b29162ba7a9844d36853fd1aef1cd16e6e71","filename":"pom.xml","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/75f103d9d6694ae0116fe741a2dfbf60e3c63ce1/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/pom.xml?ref=75f103d9d6694ae0116fe741a2dfbf60e3c63ce1","patch":"@@ -35,9 +35,11 @@\n     <module>hedwig-client</module>\n     <module>hedwig-server</module>\n     <module>hedwig-protocol</module>\n+    <module>hedwig-client-jms</module>\n+    <module>bookkeeper-stats</module>\n     <module>bookkeeper-server</module>\n     <module>bookkeeper-benchmark</module>\n-    <module>hedwig-client-jms</module>\n+    <module>bookkeeper-stats-providers</module>\n   </modules>\n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>"}]}

