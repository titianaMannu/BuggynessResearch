{"sha":"77e68b5b033f306f8575b66278e8765784394413","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3N2U2OGI1YjAzM2YzMDZmODU3NWI2NjI3OGU4NzY1Nzg0Mzk0NDEz","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-09-10T22:41:28Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-09-10T22:41:28Z"},"message":"BOOKKEEPER-775: Improve MultipleThreadReadTest to reduce flakiness (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1624161 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4815d61e2601c872c2054d283f6338e3791ac9f7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4815d61e2601c872c2054d283f6338e3791ac9f7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/77e68b5b033f306f8575b66278e8765784394413","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/77e68b5b033f306f8575b66278e8765784394413","html_url":"https://github.com/apache/bookkeeper/commit/77e68b5b033f306f8575b66278e8765784394413","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/77e68b5b033f306f8575b66278e8765784394413/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"fb6324b064e5b367d48d59fc44381462431d500a","url":"https://api.github.com/repos/apache/bookkeeper/commits/fb6324b064e5b367d48d59fc44381462431d500a","html_url":"https://github.com/apache/bookkeeper/commit/fb6324b064e5b367d48d59fc44381462431d500a"}],"stats":{"total":185,"additions":100,"deletions":85},"files":[{"sha":"acddc1bf7106c0145c3f653eec8a80db87feeea9","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/77e68b5b033f306f8575b66278e8765784394413/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/77e68b5b033f306f8575b66278e8765784394413/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=77e68b5b033f306f8575b66278e8765784394413","patch":"@@ -226,6 +226,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-736: Stats for AutoRecovery (sijie)\n \n+\tBOOKKEEPER-775: Improve MultipleThreadReadTest to reduce flakiness (sijie via fpj)\n+\n       bookkeeper-benchmark:\n \n         BOOKKEEPER-768: fix typo 'seconds' to milliseconds in benchmark output (jialin via sijie)"},{"sha":"44cce6a50a38cd236819bc024f655c56938145a6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java","status":"modified","additions":98,"deletions":85,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/77e68b5b033f306f8575b66278e8765784394413/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/77e68b5b033f306f8575b66278e8765784394413/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java?ref=77e68b5b033f306f8575b66278e8765784394413","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.test;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,18 +18,18 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.test;\n \n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Enumeration;\n import java.util.List;\n import java.util.NoSuchElementException;\n-\n+import java.util.concurrent.atomic.AtomicBoolean;\n import org.apache.bookkeeper.client.AsyncCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.BookKeeperTestClient;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -41,31 +39,31 @@\n import org.slf4j.LoggerFactory;\n \n import static org.junit.Assert.*;\n+import static com.google.common.base.Charsets.UTF_8;\n \n public class MultipleThreadReadTest extends BookKeeperClusterTestCase {\n     static Logger LOG = LoggerFactory.getLogger(MultipleThreadReadTest.class);\n+\n     BookKeeper.DigestType digestType;\n-    byte[] ledgerPassword = \"aaa\".getBytes();\n+    byte [] ledgerPassword = \"aaa\".getBytes();\n     private int entriesPerLedger = 1000;\n     final SyncObj mainSyncObj = new SyncObj();\n \n     class SyncObj {\n         volatile int counter;\n-        boolean value;\n         boolean failed;\n-\n         public SyncObj() {\n             counter = 0;\n-            value = false;\n             failed = false;\n         }\n     }\n \n     final List<BookKeeperTestClient> clients = new ArrayList<BookKeeperTestClient>();\n \n     public MultipleThreadReadTest() {\n-        super(3);\n-        this.digestType = DigestType.CRC32;\n+        super(6);\n+        this.digestType = BookKeeper.DigestType.CRC32;\n+        baseClientConf.setAddEntryTimeout(20);\n     }\n \n     private void createClients(int numClients) {\n@@ -94,29 +92,25 @@ private void closeClientsAndClear() {\n         clients.clear();\n     }\n \n-    private Thread getWriterThread(final int tNo, final LedgerHandle lh) {\n+    private Thread getWriterThread(final int tNo, final LedgerHandle lh, final AtomicBoolean resultHolder) {\n         Thread t = new Thread(new Runnable() {\n             @Override\n             public void run() {\n                 final SyncObj tSync = new SyncObj();\n                 for (int j = 0; j < entriesPerLedger; j++) {\n-                    byte[] entry = (\"Entry-\" + tNo + \"-\" + j).getBytes();\n+                    final byte[] entry = (\"Entry-\" + tNo + \"-\" + j).getBytes();\n                     lh.asyncAddEntry(entry, new AsyncCallback.AddCallback() {\n                         @Override\n                         public void addComplete(int rc, LedgerHandle ledgerHandle, long eid, Object o) {\n-                            SyncObj syncObj = (SyncObj) o;\n-                            try {\n+                            SyncObj syncObj = (SyncObj)o;\n+                            synchronized (syncObj) {\n                                 if (rc != BKException.Code.OK) {\n-                                    fail(\"Add entries returned a code that is not OK. rc:\" + rc);\n-                                }\n-                                synchronized (syncObj) {\n-                                    syncObj.counter++;\n-                                    syncObj.notify();\n-                                }\n-                            } catch (AssertionError e) {\n-                                synchronized (syncObj) {\n+                                    LOG.error(\"Add entry {} failed : rc = {}\", new String(entry, UTF_8), rc);\n                                     syncObj.failed = true;\n                                     syncObj.notify();\n+                                } else {\n+                                    syncObj.counter++;\n+                                    syncObj.notify();\n                                 }\n                             }\n                         }\n@@ -130,20 +124,19 @@ public void addComplete(int rc, LedgerHandle ledgerHandle, long eid, Object o) {\n                             Thread.currentThread().interrupt();\n                         }\n                     }\n-                    if (tSync.failed) {\n-                        fail(\"Failed to add entries.\");\n-                    }\n+                    resultHolder.set(!tSync.failed);\n                 }\n                 // close this handle\n                 try {\n                     lh.close();\n-                } catch (Exception e) {\n-                    if (e instanceof InterruptedException) {\n-                        Thread.currentThread().interrupt();\n-                    }\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupted on closing ledger handle {} : \", lh.getId(), ie);\n+                    Thread.currentThread().interrupt();\n+                } catch (BKException bke) {\n+                    LOG.error(\"Error on closing ledger handle {} : \", lh.getId(), bke);\n                 }\n             }\n-        });\n+        }, \"WriteThread(Lid=\" + lh.getId() + \")\");\n         t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n             @Override\n             public void uncaughtException(Thread thread, Throwable throwable) {\n@@ -155,66 +148,73 @@ public void uncaughtException(Thread thread, Throwable throwable) {\n         return t;\n     }\n \n-    private Thread getReaderThread(final int tNo, final LedgerHandle lh, final int ledgerNumber) {\n+    private Thread getReaderThread(final int tNo, final LedgerHandle lh, final int ledgerNumber,\n+                                   final AtomicBoolean resultHolder) {\n         Thread t = new Thread(new Runnable() {\n             @Override\n             public void run() {\n-                try {\n-                    final SyncObj tSync = new SyncObj();\n-                    lh.asyncReadEntries(0, entriesPerLedger - 1, new AsyncCallback.ReadCallback() {\n-                        @Override\n-                        public void readComplete(int rc, LedgerHandle ledgerHandle, Enumeration<LedgerEntry> list,\n-                                        Object o) {\n-                            SyncObj syncObj = (SyncObj) o;\n+                //LedgerHandle lh = clientList.get(0).openLedger(ledgerIds.get(tNo % numLedgers), digestType, ledgerPassword);\n+                long startEntryId = 0;\n+                long endEntryId;\n+                long eid = 0;\n+                while (startEntryId <= entriesPerLedger - 1) {\n+                    endEntryId = Math.min(startEntryId + 50 - 1, entriesPerLedger - 1);\n+                    final long numEntries = (endEntryId - startEntryId) + 1;\n+                    boolean success = true;\n+                    try {\n+                        Enumeration<LedgerEntry> list = lh.readEntries(startEntryId, endEntryId);\n+                        for (int j = 0; j < numEntries; j++) {\n+                            LedgerEntry e;\n                             try {\n-                                if (rc != BKException.Code.OK) {\n-                                    fail(\"Read entries returned a code that is not OK. rc:\" + rc);\n-                                }\n-                                for (int j = 0; j < entriesPerLedger; j++) {\n-                                    LedgerEntry e = null;\n-                                    try {\n-                                        e = list.nextElement();\n-                                    } catch (NoSuchElementException exception) {\n-                                        fail(\"Short read for ledger:\" + ledgerHandle.getId());\n-                                    }\n-                                    byte[] data = e.getEntry();\n-                                    if (!Arrays.equals((\"Entry-\" + ledgerNumber + \"-\" + j).getBytes(), data)) {\n-                                        fail(\"Wrong entry while reading from ledger\");\n-                                    }\n-                                }\n-                                if (list.hasMoreElements()) {\n-                                    fail(\"Read more elements than we wrote for ledger:\" + ledgerHandle.getId());\n-                                }\n-                            } catch (AssertionError e) {\n-                                synchronized (syncObj) {\n-                                    syncObj.failed = true;\n-                                    syncObj.notify();\n-                                }\n-                            } finally {\n-                                synchronized (syncObj) {\n-                                    syncObj.value = true;\n-                                    syncObj.notify();\n-                                }\n+                                e = list.nextElement();\n+                            } catch (NoSuchElementException exception) {\n+                                success = false;\n+                                break;\n+                            }\n+                            long curEid = eid++;\n+                            if (e.getEntryId() != curEid) {\n+                                LOG.error(\"Expected entry id {} for ledger {} but {} found.\",\n+                                          new Object[] { curEid, lh.getId(), e.getEntryId() });\n+                                success = false;\n+                                break;\n+                            }\n+                            byte[] data = e.getEntry();\n+                            if (!Arrays.equals((\"Entry-\" + ledgerNumber + \"-\" + e.getEntryId()).getBytes(), data)) {\n+                                LOG.error(\"Expected entry data 'Entry-{}-{}' but {} found for ledger {}.\",\n+                                          new Object[] { ledgerNumber, e.getEntryId(), new String(data, UTF_8), lh.getId() });\n+                                success = false;\n+                                break;\n                             }\n                         }\n-                    }, tSync);\n-                    synchronized (tSync) {\n-                        while (!tSync.value) {\n-                            tSync.wait();\n-                        }\n-                        if (tSync.failed) {\n-                            fail(\"Invalid read while reading form ledger:\" + lh.getId());\n+                        if (success) {\n+                            success = !list.hasMoreElements();\n+                            if (!success) {\n+                                LOG.error(\"Found more entries returned on reading ({}-{}) from ledger {}.\",\n+                                          new Object[] { startEntryId, endEntryId, lh.getId() });\n+                            }\n                         }\n+                    } catch (InterruptedException ie) {\n+                        LOG.error(\"Interrupted on reading entries ({} - {}) from ledger {} : \",\n+                                  new Object[] { startEntryId, endEntryId, lh.getId(), ie });\n+                        Thread.currentThread().interrupt();\n+                        success = false;\n+                    } catch (BKException bke) {\n+                        LOG.error(\"Failed on reading entries ({} - {}) from ledger {} : \",\n+                                  new Object[] { startEntryId, endEntryId, lh.getId(), bke });\n+                        success = false;\n                     }\n-                } catch (InterruptedException e) {\n-                    fail(\"Interrupted while waiting for replies.\");\n-                    Thread.currentThread().interrupt();\n+                    resultHolder.set(success);\n+                    if (!success) {\n+                        break;\n+                    }\n+                    startEntryId = endEntryId + 1;\n                 }\n             }\n-        });\n+        }, \"ReadThread(Tid =\" + tNo  + \", Lid=\" + lh.getId() + \")\");\n         t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n             @Override\n             public void uncaughtException(Thread thread, Throwable throwable) {\n+                LOG.error(\"Uncaught exception in thread {} : \", thread.getName(), throwable);\n                 synchronized (mainSyncObj) {\n                     mainSyncObj.failed = true;\n                 }\n@@ -229,22 +229,25 @@ public void uncaughtException(Thread thread, Throwable throwable) {\n      * @throws java.io.IOException\n      */\n     public void multiLedgerMultiThreadRead(final int numLedgers,\n-                    final int numThreads) throws IOException {\n+                                           final int numThreads) throws IOException {\n         assertTrue(numLedgers != 0 && numThreads >= numLedgers && numThreads % numLedgers == 0);\n \n         // We create numThread/numLedger clients so that each client can be used to open a handle.\n         try {\n             final List<LedgerHandle> oldLedgerHandles = new ArrayList<LedgerHandle>();\n             final List<Long> ledgerIds = new ArrayList<Long>();\n             List<Thread> threadList = new ArrayList<Thread>();\n+            List<AtomicBoolean> writeResults = new ArrayList<AtomicBoolean>();\n             // Start write threads.\n             // Only one thread writes to a ledger, so just use numLedgers instead.\n             for (int i = 0; i < numLedgers; i++) {\n                 LedgerHandle lh = bkc.createLedger(digestType, ledgerPassword);\n                 oldLedgerHandles.add(lh);\n                 ledgerIds.add(lh.getId());\n+                AtomicBoolean writeResult = new AtomicBoolean(false);\n+                writeResults.add(writeResult);\n                 Thread t;\n-                threadList.add(t = getWriterThread(i, oldLedgerHandles.get(i)));\n+                threadList.add(t = getWriterThread(i, oldLedgerHandles.get(i), writeResult));\n                 t.start();\n             }\n             // Wait for the threads to complete\n@@ -253,9 +256,13 @@ public void multiLedgerMultiThreadRead(final int numLedgers,\n             }\n             synchronized (mainSyncObj) {\n                 if (mainSyncObj.failed) {\n-                    fail(\"Test failed because we couldn't add entries.\");\n+                    fail(\"Test failed because we encountered uncaught exception on adding entries.\");\n                 }\n             }\n+            for (int i = 0; i < numLedgers; i++) {\n+                assertTrue(\"Failed on adding entries for ledger \" + oldLedgerHandles.get(i).getId(),\n+                           writeResults.get(i).get());\n+            }\n             // Close the ledger handles.\n             for (LedgerHandle lh : oldLedgerHandles) {\n                 try {\n@@ -274,10 +281,13 @@ public void multiLedgerMultiThreadRead(final int numLedgers,\n             closeClientsAndClear();\n             createClients(numThreads / numLedgers);\n \n+            List<AtomicBoolean> readResults = new ArrayList<AtomicBoolean>();\n             for (int i = 0; i < numThreads; i++) {\n+                AtomicBoolean readResult = new AtomicBoolean(false);\n                 Thread t;\n                 threadList.add(t = getReaderThread(i, clients.get(i / numLedgers)\n-                    .openLedger(ledgerIds.get(i % numLedgers), digestType, ledgerPassword), i % numLedgers));\n+                        .openLedger(ledgerIds.get(i % numLedgers), digestType, ledgerPassword), i % numLedgers, readResult));\n+                readResults.add(readResult);\n                 t.start();\n             }\n             // Wait for the threads to complete.\n@@ -286,9 +296,12 @@ public void multiLedgerMultiThreadRead(final int numLedgers,\n             }\n             synchronized (mainSyncObj) {\n                 if (mainSyncObj.failed) {\n-                    fail(\"Test failed because we couldn't read entries\");\n+                    fail(\"Test failed because we encountered uncaught exception on reading entries\");\n                 }\n             }\n+            for (AtomicBoolean readResult : readResults) {\n+                assertTrue(\"Failed on read entries\", readResult.get());\n+            }\n         } catch (BKException e) {\n             LOG.error(\"Test failed\", e);\n             fail(\"Test failed due to BookKeeper exception\");\n@@ -298,17 +311,17 @@ public void multiLedgerMultiThreadRead(final int numLedgers,\n         }\n     }\n \n-    @Test\n+    @Test(timeout = 60000)\n     public void test10Ledgers20ThreadsRead() throws IOException {\n         multiLedgerMultiThreadRead(10, 20);\n     }\n \n-    @Test\n+    @Test(timeout = 60000)\n     public void test10Ledgers200ThreadsRead() throws IOException {\n         multiLedgerMultiThreadRead(10, 200);\n     }\n \n-    @Test\n+    @Test(timeout = 60000)\n     public void test1Ledger50ThreadsRead() throws IOException {\n         multiLedgerMultiThreadRead(1, 50);\n     }"}]}

