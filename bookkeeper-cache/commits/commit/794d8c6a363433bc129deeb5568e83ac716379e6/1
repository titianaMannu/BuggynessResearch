{"sha":"794d8c6a363433bc129deeb5568e83ac716379e6","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3OTRkOGM2YTM2MzQzM2JjMTI5ZGVlYjU1NjhlODNhYzcxNjM3OWU2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-18T14:40:30Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-18T14:40:30Z"},"message":"BOOKKEEPER-345: Detect IOExceptions on entrylogger and bookie should consider next ledger dir(if any) (Vinay via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1399680 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"05cb149cc5a08328ac9f9fa259012d5cbd56c8fe","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/05cb149cc5a08328ac9f9fa259012d5cbd56c8fe"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/794d8c6a363433bc129deeb5568e83ac716379e6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/794d8c6a363433bc129deeb5568e83ac716379e6","html_url":"https://github.com/apache/bookkeeper/commit/794d8c6a363433bc129deeb5568e83ac716379e6","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/794d8c6a363433bc129deeb5568e83ac716379e6/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","url":"https://api.github.com/repos/apache/bookkeeper/commits/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7","html_url":"https://github.com/apache/bookkeeper/commit/5f9f6ef0719a19e48815e8b021da43e8ad15f6f7"}],"stats":{"total":1125,"additions":1062,"deletions":63},"files":[{"sha":"7fd4b5a43754d5ceca31705ce5397775711bbc16","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -158,6 +158,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-315: Ledger entries should be replicated sequentially instead of parallel. (umamahesh via ivank)\n \n+        BOOKKEEPER-345: Detect IOExceptions on entrylogger and bookie should consider next ledger dir(if any) (Vinay via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"d3dd397989ad23257db734591de07b10e68db9a3","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bk_server.conf?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -159,3 +159,21 @@ zkTimeout=10000\n # the limitation of number of index pages.\n # pageLimit=-1\n \n+#If all ledger directories configured are full, then support only read \n+#requests for clients.\n+#If \"readOnlyModeEnabled=true\" then on all ledger disks full, bookie will be converted\n+#to read-only mode and serve only read requests. Else bookie will get shutdown.\n+#By default this will be disabled.\n+#readOnlyModeEnabled=false\n+\n+#For each ledger dir, maximum disk space which can be used.\n+#Default is 0.95f. i.e. 95% of disk can be used at most after which nothing will\n+#be written to that partition. If all ledger dir partions are full, then bookie\n+#will turn to readonly mode if 'readOnlyModeEnabled=true' is set, else it will\n+#shutdown.\n+#Valid values should be in between 0 and 1 (exclusive). \n+#diskUsageThreshold=0.95\n+\n+#Disk check interval in milli seconds, interval to check the ledger dirs usage.\n+#Default is 10000\n+#diskCheckInterval=10000"},{"sha":"30f197ddb3aff270bfdbb999a54fa30f4b04be70","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":175,"deletions":22,"changes":197,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -42,6 +42,8 @@\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n@@ -53,6 +55,7 @@\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException.NodeExistsException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n@@ -66,11 +69,11 @@\n \n public class Bookie extends Thread {\n     public static final String INSTANCEID = \"INSTANCEID\";\n+    public static final String READONLY = \"readonly\";\n \n     static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n \n     final File journalDirectory;\n-    final File ledgerDirectories[];\n     final ServerConfiguration conf;\n \n     final SyncThread syncThread;\n@@ -87,6 +90,8 @@\n     private final String bookieRegistrationPath;\n     static final String CURRENT_DIR = \"current\";\n \n+    private LedgerDirsManager ledgerDirsManager;\n+\n     // ZooKeeper client instance for the Bookie\n     ZooKeeper zk;\n     private volatile boolean isZkExpired = true;\n@@ -104,6 +109,10 @@\n \n     Map<Long, byte[]> masterKeyCache = Collections.synchronizedMap(new HashMap<Long, byte[]>());\n \n+    final private String zkBookieRegPath;\n+\n+    final private AtomicBoolean readOnly = new AtomicBoolean(false);\n+\n     public static class NoLedgerException extends IOException {\n         private static final long serialVersionUID = 1L;\n         private long ledgerId;\n@@ -208,6 +217,10 @@ public void run() {\n                 boolean flushFailed = false;\n                 try {\n                     ledgerStorage.flush();\n+                } catch (NoWritableLedgerDirException e) {\n+                    flushFailed = true;\n+                    flushing.set(false);\n+                    transitionToReadOnlyMode();\n                 } catch (IOException e) {\n                     LOG.error(\"Exception flushing Ledger\", e);\n                     flushFailed = true;\n@@ -216,8 +229,13 @@ public void run() {\n                 // if flush failed, we should not roll last mark, otherwise we would\n                 // have some ledgers are not flushed and their journal entries were lost\n                 if (!flushFailed) {\n-                    journal.rollLog();\n-                    journal.gcJournals();\n+                    try {\n+                        journal.rollLog();\n+                        journal.gcJournals();\n+                    } catch (NoWritableLedgerDirException e) {\n+                        flushing.set(false);\n+                        transitionToReadOnlyMode();\n+                    }\n                 }\n \n                 // clear flushing flag\n@@ -272,7 +290,7 @@ public boolean accept(File dir, String name) {\n     private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException {\n         if (zk == null) { // exists only for testing, just make sure directories are correct\n             checkDirectoryStructure(journalDirectory);\n-            for (File dir : ledgerDirectories) {\n+            for (File dir : ledgerDirsManager.getAllLedgerDirs()) {\n                     checkDirectoryStructure(dir);\n             }\n             return;\n@@ -300,7 +318,7 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n             } catch (FileNotFoundException fnf) {\n                 missedCookieDirs.add(journalDirectory);\n             }\n-            for (File dir : ledgerDirectories) {\n+            for (File dir : ledgerDirsManager.getAllLedgerDirs()) {\n                 checkDirectoryStructure(dir);\n                 try {\n                     Cookie c = Cookie.readFromDirectory(dir);\n@@ -319,7 +337,7 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n                 if (missedCookieDirs.size() > 0) {\n                     LOG.debug(\"Directories missing cookie file are {}\", missedCookieDirs);\n                     masterCookie.writeToDirectory(journalDirectory);\n-                    for (File dir : ledgerDirectories) {\n+                    for (File dir : ledgerDirsManager.getAllLedgerDirs()) {\n                         masterCookie.writeToDirectory(dir);\n                     }\n                 }\n@@ -353,6 +371,10 @@ private String getInstanceId(ZooKeeper zk) throws KeeperException,\n         return instanceId;\n     }\n \n+    public LedgerDirsManager getLedgerDirsManager() {\n+        return ledgerDirsManager;\n+    }\n+\n     public static File getCurrentDirectory(File dir) {\n         return new File(dir, CURRENT_DIR);\n     }\n@@ -372,7 +394,7 @@ public Bookie(ServerConfiguration conf)\n         this.bookieRegistrationPath = conf.getZkAvailableBookiesPath() + \"/\";\n         this.conf = conf;\n         this.journalDirectory = getCurrentDirectory(conf.getJournalDir());\n-        this.ledgerDirectories = getCurrentDirectories(conf.getLedgerDirs());\n+        this.ledgerDirsManager = new LedgerDirsManager(conf);\n \n         // instantiate zookeeper client to initialize ledger manager\n         this.zk = instantiateZookeeperClient(conf);\n@@ -382,10 +404,19 @@ public Bookie(ServerConfiguration conf)\n         activeLedgerManager = activeLedgerManagerFactory.newActiveLedgerManager();\n \n         syncThread = new SyncThread(conf);\n-        ledgerStorage = new InterleavedLedgerStorage(conf, activeLedgerManager);\n+        ledgerStorage = new InterleavedLedgerStorage(conf, activeLedgerManager,\n+                ledgerDirsManager);\n         handles = new HandleFactoryImpl(ledgerStorage);\n         // instantiate the journal\n-        journal = new Journal(conf);\n+        journal = new Journal(conf, ledgerDirsManager);\n+\n+        // ZK ephemeral node for this Bookie.\n+        zkBookieRegPath = this.bookieRegistrationPath + getMyId();\n+    }\n+\n+    private String getMyId() throws UnknownHostException {\n+        return InetAddress.getLocalHost().getHostAddress() + \":\"\n+                + conf.getBookiePort();\n     }\n \n     void readJournal() throws IOException, BookieException {\n@@ -443,6 +474,10 @@ synchronized public void start() {\n         // start bookie thread\n         super.start();\n \n+        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n+        //Start DiskChecker thread\n+        ledgerDirsManager.start();\n+\n         ledgerStorage.start();\n \n         syncThread.start();\n@@ -458,6 +493,38 @@ synchronized public void start() {\n         }\n     }\n \n+    /*\n+     * Get the DiskFailure listener for the bookie\n+     */\n+    private LedgerDirsListener getLedgerDirsListener() {\n+\n+        return new LedgerDirsListener() {\n+\n+            @Override\n+            public void diskFull(File disk) {\n+                // Nothing needs to be handled here.\n+            }\n+\n+            @Override\n+            public void diskFailed(File disk) {\n+                // Shutdown the bookie on disk failure.\n+                triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n+            }\n+\n+            @Override\n+            public void allDisksFull() {\n+                // Transition to readOnly mode on all disks full\n+                transitionToReadOnlyMode();\n+            }\n+\n+            @Override\n+            public void fatalError() {\n+                LOG.error(\"Fatal error reported by ledgerDirsManager\");\n+                triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n+            }\n+        };\n+    }\n+\n     /**\n      * Register jmx with parent\n      *\n@@ -525,9 +592,6 @@ protected void registerBookie(int port) throws IOException {\n             // zookeeper instance is null, means not register itself to zk\n             return;\n         }\n-        // ZK ephemeral node for this Bookie.\n-        String zkBookieRegPath = this.bookieRegistrationPath\n-                + InetAddress.getLocalHost().getHostAddress() + \":\" + port;\n         final CountDownLatch prevNodeLatch = new CountDownLatch(1);\n         try{\n             Watcher zkPrevRegNodewatcher = new Watcher() {\n@@ -573,6 +637,63 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n+    /*\n+     * Transition the bookie to readOnly mode\n+     */\n+    void transitionToReadOnlyMode() {\n+        if (!readOnly.compareAndSet(false, true)) {\n+            return;\n+        }\n+        if (!conf.isReadOnlyModeEnabled()) {\n+            LOG.warn(\"ReadOnly mode is not enabled. \"\n+                    + \"Can be enabled by configuring \"\n+                    + \"'readOnlyModeEnabled=true' in configuration.\"\n+                    + \"Shutting down bookie\");\n+            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n+            return;\n+        }\n+        LOG.info(\"Transitioning Bookie to ReadOnly mode,\"\n+                + \" and will serve only read requests from clients!\");\n+        try {\n+            if (null == zk\n+                    .exists(this.bookieRegistrationPath + READONLY, false)) {\n+                try {\n+                    zk.create(this.bookieRegistrationPath + READONLY,\n+                            new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                            CreateMode.PERSISTENT);\n+                } catch (NodeExistsException e) {\n+                    // this node is just now created by someone.\n+                }\n+            }\n+            // Clear the current registered node\n+            zk.delete(zkBookieRegPath, -1);\n+            // Create the readonly node\n+            zk.create(this.bookieRegistrationPath + READONLY + \"/\" + getMyId(),\n+                    new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+        } catch (IOException e) {\n+            LOG.error(\"Error in transition to ReadOnly Mode.\"\n+                    + \" Shutting down\", e);\n+            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n+            return;\n+        } catch (KeeperException e) {\n+            LOG.error(\"Error in transition to ReadOnly Mode.\"\n+                    + \" Shutting down\", e);\n+            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n+            return;\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            LOG.warn(\"Interrupted Exception while transitioning to ReadOnly Mode.\");\n+            return;\n+        }\n+    }\n+\n+    /*\n+     * Check whether Bookie is writable\n+     */\n+    public boolean isReadOnly() {\n+        return readOnly.get();\n+    }\n+\n     /**\n      * Create a new zookeeper client to zk cluster.\n      *\n@@ -643,7 +764,25 @@ public void run() {\n             // following add operations to it would hang unit client timeout\n             // so we should let bookie server exists\n             LOG.error(\"Journal manager quits unexpectedly.\");\n-            shutdown(ExitCode.BOOKIE_EXCEPTION);\n+            triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n+        }\n+    }\n+\n+    // Triggering the Bookie shutdown in its own thread,\n+    // because shutdown can be called from sync thread which would be\n+    // interrupted by shutdown call.\n+    void triggerBookieShutdown(final int exitCode) {\n+        Thread shutdownThread = new Thread() {\n+            public void run() {\n+                Bookie.this.shutdown(exitCode);\n+            }\n+        };\n+        shutdownThread.start();\n+        try {\n+            shutdownThread.join();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            LOG.debug(\"InterruptedException while waiting for shutdown. Not a problem!!\");\n         }\n     }\n \n@@ -665,6 +804,10 @@ synchronized int shutdown(int exitCode) {\n \n                 // Shutdown the ZK client\n                 if(zk != null) zk.close();\n+\n+                //Shutdown disk checker\n+                ledgerDirsManager.shutdown();\n+\n                 // Shutdown journal\n                 journal.shutdown();\n                 this.join();\n@@ -744,9 +887,14 @@ private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCa\n      */\n     public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey) \n             throws IOException, BookieException {\n-        LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n-        synchronized (handle) {\n-            addEntryInternal(handle, entry, cb, ctx);\n+        try {\n+            LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n+            synchronized (handle) {\n+                addEntryInternal(handle, entry, cb, ctx);\n+            }\n+        } catch (NoWritableLedgerDirException e) {\n+            transitionToReadOnlyMode();\n+            throw new IOException(e);\n         }\n     }\n     \n@@ -756,13 +904,18 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n      */\n     public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n             throws IOException, BookieException {\n-        LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n-        synchronized (handle) {\n-            if (handle.isFenced()) {\n-                throw BookieException.create(BookieException.Code.LedgerFencedException);\n+        try {\n+            LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n+            synchronized (handle) {\n+                if (handle.isFenced()) {\n+                    throw BookieException\n+                            .create(BookieException.Code.LedgerFencedException);\n+                }\n+                addEntryInternal(handle, entry, cb, ctx);\n             }\n-\n-            addEntryInternal(handle, entry, cb, ctx);\n+        } catch (NoWritableLedgerDirException e) {\n+            transitionToReadOnlyMode();\n+            throw new IOException(e);\n         }\n     }\n "},{"sha":"bc9294e0dbdacebfd33f0f6430e41548c001e9f6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -640,7 +640,7 @@ protected void scanEntryLog(long logId, EntryLogScanner scanner) throws IOExcept\n \n     private synchronized Journal getJournal() throws IOException {\n         if (null == journal) {\n-            journal = new Journal(bkConf);\n+            journal = new Journal(bkConf, new LedgerDirsManager(bkConf));\n         }\n         return journal;\n     }"},{"sha":"bd5c472b553b974eef3f798acad79ea022a90403","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":62,"deletions":19,"changes":81,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -34,16 +34,17 @@\n import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n-import java.util.Arrays;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.util.IOUtils;\n \n@@ -56,7 +57,10 @@\n  */\n public class EntryLogger {\n     private static final Logger LOG = LoggerFactory.getLogger(EntryLogger.class);\n-    private File dirs[];\n+\n+    volatile File currentDir;\n+    private LedgerDirsManager ledgerDirsManager;\n+    private AtomicBoolean shouldCreateNewEntryLog = new AtomicBoolean(false);\n \n     private long logId;\n     /**\n@@ -105,8 +109,9 @@\n      * Create an EntryLogger that stores it's log files in the given\n      * directories\n      */\n-    public EntryLogger(ServerConfiguration conf) throws IOException {\n-        this.dirs = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n+    public EntryLogger(ServerConfiguration conf,\n+            LedgerDirsManager ledgerDirsManager) throws IOException {\n+        this.ledgerDirsManager = ledgerDirsManager;\n         // log size limit\n         this.logSizeLimit = conf.getEntryLogSizeLimit();\n \n@@ -118,7 +123,7 @@ public EntryLogger(ServerConfiguration conf) throws IOException {\n         LOGFILE_HEADER.put(\"BKLO\".getBytes());\n         // Find the largest logId\n         logId = -1;\n-        for(File dir: dirs) {\n+        for (File dir : ledgerDirsManager.getAllLedgerDirs()) {\n             if (!dir.exists()) {\n                 throw new FileNotFoundException(\n                         \"Entry log directory does not exist\");\n@@ -142,16 +147,44 @@ synchronized long getCurrentLogId() {\n     }\n \n     protected void initialize() throws IOException {\n+        // Register listener for disk full notifications.\n+        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n         // create a new log to write\n         createNewLog();\n     }\n \n+    private LedgerDirsListener getLedgerDirsListener() {\n+        return new LedgerDirsListener() {\n+            @Override\n+            public void diskFull(File disk) {\n+                // If the current entry log disk is full, then create new entry\n+                // log.\n+                if (currentDir != null && currentDir.equals(disk)) {\n+                    shouldCreateNewEntryLog.set(true);\n+                }\n+            }\n+\n+            @Override\n+            public void diskFailed(File disk) {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n+\n+            @Override\n+            public void allDisksFull() {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n+\n+            @Override\n+            public void fatalError() {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n+        };\n+    }\n+\n     /**\n      * Creates a new log file\n      */\n     void createNewLog() throws IOException {\n-        List<File> list = Arrays.asList(dirs);\n-        Collections.shuffle(list);\n         if (logChannel != null) {\n             logChannel.flush(true);\n         }\n@@ -160,21 +193,23 @@ void createNewLog() throws IOException {\n         File newLogFile = null;\n         do {\n             String logFileName = Long.toHexString(++logId) + \".log\";\n-            for (File dir : list) {\n-                newLogFile = new File(dir, logFileName);\n-                if (newLogFile.exists()) {\n-                    LOG.warn(\"Found existed entry log \" + newLogFile\n-                           + \" when trying to create it as a new log.\");\n-                    newLogFile = null;\n-                    break;\n-                }\n+            File dir = ledgerDirsManager.pickRandomWritableDir();\n+            newLogFile = new File(dir, logFileName);\n+            currentDir = dir;\n+            if (newLogFile.exists()) {\n+                LOG.warn(\"Found existed entry log \" + newLogFile\n+                        + \" when trying to create it as a new log.\");\n+                newLogFile = null;\n+                continue;\n             }\n         } while (newLogFile == null);\n \n         logChannel = new BufferedChannel(new RandomAccessFile(newLogFile, \"rw\").getChannel(), 64*1024);\n         logChannel.write((ByteBuffer) LOGFILE_HEADER.clear());\n         channels.put(logId, logChannel);\n-        for(File f: dirs) {\n+\n+        List<File> listOfDirs = ledgerDirsManager.getWritableLedgerDirs();\n+        for (File f : listOfDirs) {\n             setLastLogId(f, logId);\n         }\n     }\n@@ -290,8 +325,16 @@ synchronized void flush() throws IOException {\n         }\n     }\n     synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n-        if (logChannel.position() + entry.remaining() + 4 > logSizeLimit) {\n+        // Create new log if logSizeLimit reached or current disk is full\n+        boolean createNewLog = shouldCreateNewEntryLog.get();\n+        if (createNewLog\n+                || (logChannel.position() + entry.remaining() + 4 > logSizeLimit)) {\n             createNewLog();\n+\n+            // Reset the flag\n+            if (createNewLog) {\n+                shouldCreateNewEntryLog.set(false);\n+            }\n         }\n         ByteBuffer buff = ByteBuffer.allocate(4);\n         buff.putInt(entry.remaining());\n@@ -374,7 +417,7 @@ private BufferedChannel getChannelForLogId(long entryLogId) throws IOException {\n      * Whether the log file exists or not.\n      */\n     boolean logExists(long logId) {\n-        for (File d : dirs) {\n+        for (File d : ledgerDirsManager.getAllLedgerDirs()) {\n             File f = new File(d, Long.toHexString(logId) + \".log\");\n             if (f.exists()) {\n                 return true;\n@@ -384,7 +427,7 @@ boolean logExists(long logId) {\n     }\n \n     private File findFile(long logId) throws FileNotFoundException {\n-        for(File d: dirs) {\n+        for (File d : ledgerDirsManager.getAllLedgerDirs()) {\n             File f = new File(d, Long.toHexString(logId)+\".log\");\n             if (f.exists()) {\n                 return f;"},{"sha":"b165f8cac29374b015f772fa7a4256217d7c4e0c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -40,8 +40,8 @@\n class InterleavedLedgerStorage implements LedgerStorage {\n     final static Logger LOG = LoggerFactory.getLogger(InterleavedLedgerStorage.class);\n \n-    private EntryLogger entryLogger;\n-    private LedgerCache ledgerCache;\n+    EntryLogger entryLogger;\n+    LedgerCache ledgerCache;\n     // This is the thread that garbage collects the entry logs that do not\n     // contain any active ledgers in them; and compacts the entry logs that\n     // has lower remaining percentage to reclaim disk space.\n@@ -50,9 +50,10 @@\n     // this indicates that a write has happened since the last flush\n     private volatile boolean somethingWritten = false;\n \n-    InterleavedLedgerStorage(ServerConfiguration conf, ActiveLedgerManager activeLedgerManager)\n-            throws IOException {\n-        entryLogger = new EntryLogger(conf);\n+    InterleavedLedgerStorage(ServerConfiguration conf,\n+            ActiveLedgerManager activeLedgerManager,\n+            LedgerDirsManager ledgerDirsManager) throws IOException {\n+        entryLogger = new EntryLogger(conf, ledgerDirsManager);\n         ledgerCache = new LedgerCacheImpl(conf, activeLedgerManager);\n         gcThread = new GarbageCollectorThread(conf, ledgerCache, entryLogger,\n                 activeLedgerManager, new EntryLogCompactionScanner());"},{"sha":"aefffd424a408716e54437aaff603bdce24cbc6f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":10,"deletions":7,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -32,6 +32,7 @@\n import java.util.List;\n import java.util.concurrent.LinkedBlockingQueue;\n \n+import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.IOUtils;\n@@ -111,7 +112,7 @@ synchronized long getTxnLogPosition() {\n             return txnLogPosition;\n         }\n \n-        synchronized void rollLog() {\n+        synchronized void rollLog() throws NoWritableLedgerDirException {\n             byte buff[] = new byte[16];\n             ByteBuffer bb = ByteBuffer.wrap(buff);\n             // we should record <logId, logPosition> marked in markLog\n@@ -120,7 +121,9 @@ synchronized void rollLog() {\n             bb.putLong(lastMark.getTxnLogId());\n             bb.putLong(lastMark.getTxnLogPosition());\n             LOG.debug(\"RollLog to persist last marked log : {}\", lastMark);\n-            for (File dir : ledgerDirectories) {\n+            List<File> writableLedgerDirs = ledgerDirsManager\n+                    .getWritableLedgerDirs();\n+            for (File dir : writableLedgerDirs) {\n                 File file = new File(dir, \"lastMark\");\n                 FileOutputStream fos = null;\n                 try {\n@@ -148,7 +151,7 @@ synchronized void rollLog() {\n         synchronized void readLog() {\n             byte buff[] = new byte[16];\n             ByteBuffer bb = ByteBuffer.wrap(buff);\n-            for(File dir: ledgerDirectories) {\n+            for(File dir: ledgerDirsManager.getAllLedgerDirs()) {\n                 File file = new File(dir, \"lastMark\");\n                 try {\n                     FileInputStream fis = new FileInputStream(file);\n@@ -250,7 +253,6 @@ public boolean accept(long journalId) {\n     final int maxBackupJournals;\n \n     final File journalDirectory;\n-    final File ledgerDirectories[];\n     final ServerConfiguration conf;\n \n     private LastLogMark lastLogMark = new LastLogMark(0, 0);\n@@ -259,12 +261,13 @@ public boolean accept(long journalId) {\n     LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n \n     volatile boolean running = true;\n+    private LedgerDirsManager ledgerDirsManager;\n \n-    public Journal(ServerConfiguration conf) {\n+    public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager) {\n         super(\"BookieJournal-\" + conf.getBookiePort());\n+        this.ledgerDirsManager = ledgerDirsManager;\n         this.conf = conf;\n         this.journalDirectory = Bookie.getCurrentDirectory(conf.getJournalDir());\n-        this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n         this.maxJournalSize = conf.getMaxJournalSize() * MB;\n         this.maxBackupJournals = conf.getMaxBackupJournals();\n \n@@ -314,7 +317,7 @@ public void markLog() {\n      * </p>\n      * @see #markLog()\n      */\n-    public void rollLog() {\n+    public void rollLog() throws NoWritableLedgerDirException {\n         lastLogMark.rollLog();\n     }\n "},{"sha":"514ef4fc61e8ba8218a6c8dfa7582608249cde55","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"added","additions":240,"deletions":0,"changes":240,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -0,0 +1,240 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.util.DiskChecker;\n+import org.apache.bookkeeper.util.DiskChecker.DiskErrorException;\n+import org.apache.bookkeeper.util.DiskChecker.DiskOutOfSpaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages ledger directories used by the bookie.\n+ */\n+public class LedgerDirsManager {\n+    private static Logger LOG = LoggerFactory\n+            .getLogger(LedgerDirsManager.class);\n+\n+    private volatile List<File> filledDirs;\n+    private final List<File> ledgerDirectories;\n+    private volatile List<File> writableLedgerDirectories;\n+    private DiskChecker diskChecker;\n+    private List<LedgerDirsListener> listeners;\n+    private LedgerDirsMonitor monitor;\n+    private final Random rand = new Random();\n+\n+    public LedgerDirsManager(ServerConfiguration conf) {\n+        this.ledgerDirectories = Arrays.asList(Bookie\n+                .getCurrentDirectories(conf.getLedgerDirs()));\n+        this.writableLedgerDirectories = new ArrayList<File>(ledgerDirectories);\n+        this.filledDirs = new ArrayList<File>();\n+        listeners = new ArrayList<LedgerDirsManager.LedgerDirsListener>();\n+        diskChecker = new DiskChecker(conf.getDiskUsageThreshold());\n+        monitor = new LedgerDirsMonitor(conf.getDiskCheckInterval());\n+    }\n+\n+    /**\n+     * Get all ledger dirs configured\n+     */\n+    public List<File> getAllLedgerDirs() {\n+        return ledgerDirectories;\n+    }\n+\n+    /**\n+     * Get only writable ledger dirs.\n+     */\n+    public List<File> getWritableLedgerDirs()\n+            throws NoWritableLedgerDirException {\n+        if (writableLedgerDirectories.isEmpty()) {\n+            String errMsg = \"All ledger directories are non writable\";\n+            NoWritableLedgerDirException e = new NoWritableLedgerDirException(\n+                    errMsg);\n+            LOG.error(errMsg, e);\n+            throw e;\n+        }\n+        return writableLedgerDirectories;\n+    }\n+\n+    /**\n+     * Get dirs, which are full more than threshold\n+     */\n+    public boolean isDirFull(File dir) {\n+        return filledDirs.contains(dir);\n+    }\n+\n+    /**\n+     * Add the dir to filled dirs list\n+     */\n+    // VisibleForTesting\n+    public void addToFilledDirs(File dir) {\n+        if (!filledDirs.contains(dir)) {\n+            LOG.warn(dir + \" is out of space.\"\n+                    + \" Adding it to filled dirs list\");\n+            // Update filled dirs list\n+            List<File> updatedFilledDirs = new ArrayList<File>(filledDirs);\n+            updatedFilledDirs.add(dir);\n+            filledDirs = updatedFilledDirs;\n+            // Update the writable ledgers list\n+            List<File> newDirs = new ArrayList<File>(writableLedgerDirectories);\n+            newDirs.removeAll(filledDirs);\n+            writableLedgerDirectories = newDirs;\n+            // Notify listeners about disk full\n+            for (LedgerDirsListener listener : listeners) {\n+                listener.diskFull(dir);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns one of the ledger dir from writable dirs list randomly.\n+     */\n+    File pickRandomWritableDir() throws NoWritableLedgerDirException {\n+        List<File> writableDirs = getWritableLedgerDirs();\n+        return writableDirs.get(rand.nextInt(writableDirs.size()));\n+    }\n+\n+    public void addLedgerDirsListener(LedgerDirsListener listener) {\n+        if (listener != null) {\n+            listeners.add(listener);\n+        }\n+    }\n+\n+    // start the daemon for disk monitoring\n+    public void start() {\n+        monitor.setDaemon(true);\n+        monitor.start();\n+    }\n+\n+    // shutdown disk monitoring daemon\n+    public void shutdown() {\n+        monitor.interrupt();\n+        try {\n+            monitor.join();\n+        } catch (InterruptedException e) {\n+            // Ignore\n+        }\n+    }\n+\n+    /**\n+     * Thread to monitor the disk space periodically.\n+     */\n+    private class LedgerDirsMonitor extends Thread {\n+        int interval;\n+\n+        public LedgerDirsMonitor(int interval) {\n+            this.interval = interval;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (true) {\n+                    List<File> writableDirs;\n+                    try {\n+                        writableDirs = getWritableLedgerDirs();\n+                    } catch (NoWritableLedgerDirException e) {\n+                        for (LedgerDirsListener listener : listeners) {\n+                            listener.allDisksFull();\n+                        }\n+                        break;\n+                    }\n+                    // Check all writable dirs disk space usage.\n+                    for (File dir : writableDirs) {\n+                        try {\n+                            diskChecker.checkDir(dir);\n+                        } catch (DiskErrorException e) {\n+                            // Notify disk failure to all listeners\n+                            for (LedgerDirsListener listener : listeners) {\n+                                listener.diskFailed(dir);\n+                            }\n+                        } catch (DiskOutOfSpaceException e) {\n+                            // Notify disk full to all listeners\n+                            addToFilledDirs(dir);\n+                        }\n+                    }\n+                    try {\n+                        Thread.sleep(interval);\n+                    } catch (InterruptedException e) {\n+                        LOG.info(\"LedgerDirsMonitor thread is interrupted\");\n+                        break;\n+                    }\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Error Occured while checking disks\", e);\n+                // Notify disk failure to all listeners\n+                for (LedgerDirsListener listener : listeners) {\n+                    listener.fatalError();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Indicates All configured ledger directories are full.\n+     */\n+    public static class NoWritableLedgerDirException extends IOException {\n+        private static final long serialVersionUID = -8696901285061448421L;\n+\n+        public NoWritableLedgerDirException(String errMsg) {\n+            super(errMsg);\n+        }\n+    }\n+\n+    /**\n+     * Listener for the disk check events will be notified from the\n+     * {@link LedgerDirsManager} whenever disk full/failure detected.\n+     */\n+    public static interface LedgerDirsListener {\n+        /**\n+         * This will be notified on disk failure/disk error\n+         * \n+         * @param disk\n+         *            Failed disk\n+         */\n+        void diskFailed(File disk);\n+\n+        /**\n+         * This will be notified on disk detected as full\n+         * \n+         * @param disk\n+         *            Filled disk\n+         */\n+        void diskFull(File disk);\n+\n+        /**\n+         * This will be notified whenever all disks are detected as full.\n+         */\n+        void allDisksFull();\n+\n+        /**\n+         * This will notify the fatal errors.\n+         */\n+        void fatalError();\n+    }\n+}"},{"sha":"e69a75fbcdc62f9b77d474124d5c85989021b2de","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -32,7 +32,7 @@\n public class ReadOnlyEntryLogger extends EntryLogger {\n \n     public ReadOnlyEntryLogger(ServerConfiguration conf) throws IOException {\n-        super(conf);\n+        super(conf, new LedgerDirsManager(conf));\n     }\n \n     @Override"},{"sha":"f557ad7b4b86644cfb8d4122f3251005e2d68d82","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -58,6 +58,10 @@\n     // Statistics Parameters\n     protected final static String ENABLE_STATISTICS = \"enableStatistics\";\n     protected final static String OPEN_LEDGER_REREPLICATION_GRACE_PERIOD = \"openLedgerRereplicationGracePeriod\";\n+    //ReadOnly mode support on all disk full\n+    protected final static String READ_ONLY_MODE_ENABLED = \"readOnlyModeEnabled\";\n+    protected final static String DISK_USAGE_THRESHOLD = \"diskUsageThreshold\";\n+    protected final static String DISK_CHECK_INTERVAL = \"diskCheckInterval\";\n \n     /**\n      * Construct a default configuration object\n@@ -573,4 +577,50 @@ public void setOpenLedgerRereplicationGracePeriod(String waitTime) {\n     public long getOpenLedgerRereplicationGracePeriod() {\n         return getLong(OPEN_LEDGER_REREPLICATION_GRACE_PERIOD, 30000);\n     }\n+\n+    /**\n+     * Set the ReadOnlyModeEnabled status\n+     */\n+    public ServerConfiguration setReadOnlyModeEnabled(boolean enabled) {\n+        setProperty(READ_ONLY_MODE_ENABLED, enabled);\n+        return this;\n+    }\n+\n+    /**\n+     * Get ReadOnlyModeEnabled status\n+     */\n+    public boolean isReadOnlyModeEnabled() {\n+        return getBoolean(READ_ONLY_MODE_ENABLED, false);\n+    }\n+\n+    /**\n+     * Set the Disk free space threshold in Bytes after which disk will be\n+     * considered as full during diskcheck.\n+     */\n+    public ServerConfiguration setDiskUsageThreshold(float threshold) {\n+        setProperty(DISK_USAGE_THRESHOLD, threshold);\n+        return this;\n+    }\n+\n+    /**\n+     * Returns disk free space threshold. By default 100MB\n+     */\n+    public float getDiskUsageThreshold() {\n+        return getFloat(DISK_USAGE_THRESHOLD, 0.95f);\n+    }\n+\n+    /**\n+     * Set the disk checker interval to monitor ledger disk space\n+     */\n+    public ServerConfiguration setDiskCheckInterval(int interval) {\n+        setProperty(DISK_CHECK_INTERVAL, interval);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the disk checker interval\n+     */\n+    public int getDiskCheckInterval() {\n+        return getInt(DISK_CHECK_INTERVAL, 10 * 1000);\n+    }\n }"},{"sha":"338fd6e85f6a8eda0951abd079bf5ffd2f3373eb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -165,6 +165,10 @@ short getFlags() {\n      */\n     public static final int EFENCED = 104;\n \n+    /**\n+     * The server is running as read-only mode\n+     */\n+    public static final int EREADONLY = 105;\n \n     public static final short FLAG_NONE = 0x0;\n     public static final short FLAG_DO_FENCING = 0x0001;"},{"sha":"573d50b73e291e43ed9b46288091b0fda70029c1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -104,6 +104,11 @@ public InetSocketAddress getLocalAddress() {\n         }\n     }\n \n+    //VisibleForTesting\n+    public Bookie getBookie() {\n+        return bookie;\n+    }\n+\n     public synchronized void shutdown() {\n         if (!running) {\n             return;\n@@ -361,6 +366,15 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n         switch (h.getOpCode()) {\n         case BookieProtocol.ADDENTRY:\n             statType = BKStats.STATS_ADD;\n+\n+            if (bookie.isReadOnly()) {\n+                LOG.warn(\"BookieServer is running as readonly mode,\"\n+                        + \" so rejecting the request from the client!\");\n+                src.sendResponse(buildResponse(BookieProtocol.EREADONLY,\n+                        h.getVersion(), h.getOpCode(), ledgerId, entryId));\n+                break;\n+            }\n+\n             try {\n                 TimedCnxn tsrc = new TimedCnxn(src, startTime);\n                 if ((flags & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {"},{"sha":"13cb6753ae96a70f468d12038475cc7f51852a28","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DiskChecker.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+/**\n+ * Class that provides utility functions for checking disk problems\n+ */\n+public class DiskChecker {\n+    private float diskUsageThreshold;\n+\n+    public static class DiskErrorException extends IOException {\n+        private static final long serialVersionUID = 9091606022449761729L;\n+\n+        public DiskErrorException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    public static class DiskOutOfSpaceException extends IOException {\n+        private static final long serialVersionUID = 160898797915906860L;\n+\n+        public DiskOutOfSpaceException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    public DiskChecker(float threshold) {\n+        validateThreshold(threshold);\n+        this.diskUsageThreshold = threshold;\n+    }\n+\n+    /**\n+     * The semantics of mkdirsWithExistsCheck method is different from the\n+     * mkdirs method provided in the Sun's java.io.File class in the following\n+     * way: While creating the non-existent parent directories, this method\n+     * checks for the existence of those directories if the mkdir fails at any\n+     * point (since that directory might have just been created by some other\n+     * process). If both mkdir() and the exists() check fails for any seemingly\n+     * non-existent directory, then we signal an error; Sun's mkdir would signal\n+     * an error (return false) if a directory it is attempting to create already\n+     * exists or the mkdir fails.\n+     * \n+     * @param dir\n+     * @return true on success, false on failure\n+     */\n+    private static boolean mkdirsWithExistsCheck(File dir) {\n+        if (dir.mkdir() || dir.exists()) {\n+            return true;\n+        }\n+        File canonDir = null;\n+        try {\n+            canonDir = dir.getCanonicalFile();\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        String parent = canonDir.getParent();\n+        return (parent != null)\n+                && (mkdirsWithExistsCheck(new File(parent)) && (canonDir\n+                        .mkdir() || canonDir.exists()));\n+    }\n+\n+    /**\n+     * Checks the disk space available.\n+     * \n+     * @param dir\n+     *            Directory to check for the disk space\n+     * @throws DiskOutOfSpaceException\n+     *             Throws {@link DiskOutOfSpaceException} if available space is\n+     *             less than threshhold.\n+     */\n+    // VisibleForTesting\n+    void checkDiskFull(File dir) throws DiskOutOfSpaceException {\n+        if (null == dir) {\n+            return;\n+        }\n+        if (dir.exists()) {\n+            long usableSpace = dir.getUsableSpace();\n+            long totalSpace = dir.getTotalSpace();\n+            float free = (float) usableSpace / (float) totalSpace;\n+            float used = 1f - free;\n+            if (used > diskUsageThreshold) {\n+                throw new DiskOutOfSpaceException(\"Space left on device \"\n+                        + usableSpace + \" < threshhold \" + diskUsageThreshold);\n+            }\n+        } else {\n+            checkDiskFull(dir.getParentFile());\n+        }\n+    }\n+\n+    /**\n+     * Create the directory if it doesn't exist and\n+     * \n+     * @param dir\n+     *            Directory to check for the disk error/full.\n+     * @throws DiskErrorException\n+     *             If disk having errors\n+     * @throws DiskOutOfSpaceException\n+     *             If disk is full or having less space than threshhold\n+     */\n+    public void checkDir(File dir) throws DiskErrorException,\n+            DiskOutOfSpaceException {\n+        checkDiskFull(dir);\n+        if (!mkdirsWithExistsCheck(dir))\n+            throw new DiskErrorException(\"can not create directory: \"\n+                    + dir.toString());\n+\n+        if (!dir.isDirectory())\n+            throw new DiskErrorException(\"not a directory: \" + dir.toString());\n+\n+        if (!dir.canRead())\n+            throw new DiskErrorException(\"directory is not readable: \"\n+                    + dir.toString());\n+\n+        if (!dir.canWrite())\n+            throw new DiskErrorException(\"directory is not writable: \"\n+                    + dir.toString());\n+    }\n+\n+    /**\n+     * Returns the disk space threshold.\n+     * \n+     * @return\n+     */\n+    // VisibleForTesting\n+    float getDiskSpaceThreshold() {\n+        return diskUsageThreshold;\n+    }\n+\n+    /**\n+     * Set the disk space threshold\n+     * \n+     * @param diskSpaceThreshold\n+     */\n+    // VisibleForTesting\n+    void setDiskSpaceThreshold(float diskSpaceThreshold) {\n+        validateThreshold(diskSpaceThreshold);\n+        this.diskUsageThreshold = diskSpaceThreshold;\n+    }\n+\n+    private void validateThreshold(float diskSpaceThreshold) {\n+        if (diskSpaceThreshold <= 0 || diskSpaceThreshold >= 1) {\n+            throw new IllegalArgumentException(\"Disk space threashold \"\n+                    + diskSpaceThreshold\n+                    + \" is not valid. Should be > 0 and < 1 \");\n+        }\n+    }\n+}"},{"sha":"2d9fa78ce76bbb1486549d7b8c330d6530600210","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","status":"modified","additions":51,"deletions":8,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -32,6 +32,7 @@\n import org.apache.bookkeeper.bookie.GarbageCollectorThread.ExtractionScanner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.junit.After;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n \n@@ -57,8 +58,9 @@ public void testCorruptEntryLog() throws Exception {\n         ServerConfiguration conf = new ServerConfiguration();\n         conf.setGcWaitTime(gcWaitTime);\n         conf.setLedgerDirNames(new String[] {tmpDir.toString()});\n+        Bookie bookie = new Bookie(conf);\n         // create some entries\n-        EntryLogger logger = new EntryLogger(conf);\n+        EntryLogger logger = ((InterleavedLedgerStorage)bookie.ledgerStorage).entryLogger;\n         logger.addEntry(1, generateEntry(1, 1));\n         logger.addEntry(3, generateEntry(3, 1));\n         logger.addEntry(2, generateEntry(2, 1));\n@@ -69,7 +71,7 @@ public void testCorruptEntryLog() throws Exception {\n         raf.setLength(raf.length()-10);\n         raf.close();\n         // now see which ledgers are in the log\n-        logger = new EntryLogger(conf);\n+        logger = new EntryLogger(conf, bookie.getLedgerDirsManager());\n \n         EntryLogMetadata meta = new EntryLogMetadata(0L);\n         ExtractionScanner scanner = new ExtractionScanner(meta);\n@@ -87,10 +89,11 @@ public void testCorruptEntryLog() throws Exception {\n     }\n \n     private ByteBuffer generateEntry(long ledger, long entry) {\n-        ByteBuffer bb = ByteBuffer.wrap(new byte[64]);\n+        byte[] data = (\"ledger-\" + ledger + \"-\" + entry).getBytes();\n+        ByteBuffer bb = ByteBuffer.wrap(new byte[8 + 8 + data.length]);\n         bb.putLong(ledger);\n         bb.putLong(entry);\n-        bb.put((\"ledger-\" + ledger + \"-\" + entry).getBytes());\n+        bb.put(data);\n         bb.flip();\n         return bb;\n     }\n@@ -105,14 +108,16 @@ public void testMissingLogId() throws Exception {\n \n         ServerConfiguration conf = new ServerConfiguration();\n         conf.setLedgerDirNames(new String[] {tmpDir.toString()});\n+        Bookie bookie = new Bookie(conf);\n         // create some entries\n         int numLogs = 3;\n         int numEntries = 10;\n         long[][] positions = new long[2*numLogs][];\n         for (int i=0; i<numLogs; i++) {\n             positions[i] = new long[numEntries];\n \n-            EntryLogger logger = new EntryLogger(conf);\n+            EntryLogger logger = new EntryLogger(conf,\n+                    bookie.getLedgerDirsManager());\n             for (int j=0; j<numEntries; j++) {\n                 positions[i][j] = logger.addEntry(i, generateEntry(i, j));\n             }\n@@ -126,14 +131,16 @@ public void testMissingLogId() throws Exception {\n         for (int i=numLogs; i<2*numLogs; i++) {\n             positions[i] = new long[numEntries];\n \n-            EntryLogger logger = new EntryLogger(conf);\n+            EntryLogger logger = new EntryLogger(conf,\n+                    bookie.getLedgerDirsManager());\n             for (int j=0; j<numEntries; j++) {\n                 positions[i][j] = logger.addEntry(i, generateEntry(i, j));\n             }\n             logger.flush();\n         }\n \n-        EntryLogger newLogger = new EntryLogger(conf);\n+        EntryLogger newLogger = new EntryLogger(conf,\n+                bookie.getLedgerDirsManager());\n         for (int i=0; i<(2*numLogs+1); i++) {\n             File logFile = new File(curDir, Long.toHexString(i) + \".log\");\n             assertTrue(logFile.exists());\n@@ -164,7 +171,7 @@ public void testEntryLoggerShouldThrowFNFEIfDirectoriesDoesNotExist()\n         conf.setLedgerDirNames(new String[] { tmpDir.toString() });\n         EntryLogger entryLogger = null;\n         try {\n-            entryLogger = new EntryLogger(conf);\n+            entryLogger = new EntryLogger(conf, new LedgerDirsManager(conf));\n             fail(\"Expecting FileNotFoundException\");\n         } catch (FileNotFoundException e) {\n             assertEquals(\"Entry log directory does not exist\", e\n@@ -176,6 +183,42 @@ public void testEntryLoggerShouldThrowFNFEIfDirectoriesDoesNotExist()\n         }\n     }\n \n+    /**\n+     * Test to verify the DiskFull during addEntry\n+     */\n+    @Test\n+    public void testAddEntryFailureOnDiskFull() throws Exception {\n+        File ledgerDir1 = File.createTempFile(\"bkTest\", \".dir\");\n+        ledgerDir1.delete();\n+        File ledgerDir2 = File.createTempFile(\"bkTest\", \".dir\");\n+        ledgerDir2.delete();\n+        ServerConfiguration conf = new ServerConfiguration();\n+        conf.setLedgerDirNames(new String[] { ledgerDir1.getAbsolutePath(),\n+                ledgerDir2.getAbsolutePath() });\n+        Bookie bookie = new Bookie(conf);\n+        EntryLogger entryLogger = new EntryLogger(conf,\n+                bookie.getLedgerDirsManager());\n+        InterleavedLedgerStorage ledgerStorage = ((InterleavedLedgerStorage) bookie.ledgerStorage);\n+        ledgerStorage.entryLogger = entryLogger;\n+        // Create ledgers\n+        ledgerStorage.setMasterKey(1, \"key\".getBytes());\n+        ledgerStorage.setMasterKey(2, \"key\".getBytes());\n+        ledgerStorage.setMasterKey(3, \"key\".getBytes());\n+        // Add entries\n+        ledgerStorage.addEntry(generateEntry(1, 1));\n+        ledgerStorage.addEntry(generateEntry(2, 1));\n+        // Add entry with disk full failure simulation\n+        bookie.getLedgerDirsManager().addToFilledDirs(entryLogger.currentDir);\n+        ledgerStorage.addEntry(generateEntry(3, 1));\n+        // Verify written entries\n+        Assert.assertArrayEquals(generateEntry(1, 1).array(), ledgerStorage\n+                .getEntry(1, 1).array());\n+        Assert.assertArrayEquals(generateEntry(2, 1).array(), ledgerStorage\n+                .getEntry(2, 1).array());\n+        Assert.assertArrayEquals(generateEntry(3, 1).array(), ledgerStorage\n+                .getEntry(3, 1).array());\n+    }\n+\n     @After\n     public void tearDown() throws Exception {\n     }"},{"sha":"548f51df525f80a4e97183e762da350c42aaf3c0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -0,0 +1,166 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.test;\n+\n+import java.io.File;\n+import java.util.Enumeration;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+\n+/**\n+ * Test to verify the readonly feature of bookies\n+ */\n+public class ReadOnlyBookieTest extends BookKeeperClusterTestCase {\n+\n+    public ReadOnlyBookieTest() {\n+        super(2);\n+    }\n+\n+    /**\n+     * Check readonly bookie\n+     */\n+    public void testBookieShouldServeAsReadOnly() throws Exception {\n+        killBookie(0);\n+        baseConf.setReadOnlyModeEnabled(true);\n+        startNewBookie();\n+        LedgerHandle ledger = bkc.createLedger(2, 2, DigestType.MAC,\n+                \"\".getBytes());\n+\n+        // Check new bookie with readonly mode enabled.\n+        File[] ledgerDirs = bsConfs.get(1).getLedgerDirs();\n+        assertEquals(\"Only one ledger dir should be present\", 1,\n+                ledgerDirs.length);\n+        Bookie bookie = bs.get(1).getBookie();\n+        LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+\n+        for (int i = 0; i < 10; i++) {\n+            ledger.addEntry(\"data\".getBytes());\n+        }\n+\n+        // Now add the current ledger dir to filled dirs list\n+        ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0], \"current\"));\n+\n+        try {\n+            ledger.addEntry(\"data\".getBytes());\n+        } catch (BKException.BKNotEnoughBookiesException e) {\n+            // Expected\n+        }\n+\n+        assertTrue(\"Bookie should be running and converted to readonly mode\",\n+                bookie.isRunning() && bookie.isReadOnly());\n+\n+        // Now kill the other bookie and read entries from the readonly bookie\n+        killBookie(0);\n+\n+        Enumeration<LedgerEntry> readEntries = ledger.readEntries(0, 9);\n+        while (readEntries.hasMoreElements()) {\n+            LedgerEntry entry = readEntries.nextElement();\n+            assertEquals(\"Entry should contain correct data\", \"data\",\n+                    new String(entry.getEntry()));\n+        }\n+    }\n+\n+    /**\n+     * check readOnlyModeEnabled=false\n+     */\n+    public void testBookieShutdownIfReadOnlyModeNotEnabled() throws Exception {\n+        File[] ledgerDirs = bsConfs.get(1).getLedgerDirs();\n+        assertEquals(\"Only one ledger dir should be present\", 1,\n+                ledgerDirs.length);\n+        Bookie bookie = bs.get(1).getBookie();\n+        LedgerHandle ledger = bkc.createLedger(2, 2, DigestType.MAC,\n+                \"\".getBytes());\n+        LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+\n+        for (int i = 0; i < 10; i++) {\n+            ledger.addEntry(\"data\".getBytes());\n+        }\n+\n+        // Now add the current ledger dir to filled dirs list\n+        ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0], \"current\"));\n+\n+        try {\n+            ledger.addEntry(\"data\".getBytes());\n+        } catch (BKException.BKNotEnoughBookiesException e) {\n+            // Expected\n+        }\n+\n+        assertFalse(\"Bookie should shutdown if readOnlyMode not enabled\",\n+                bookie.isAlive());\n+    }\n+\n+    /**\n+     * Check multiple ledger dirs\n+     */\n+    public void testBookieContinueWritingIfMultipleLedgersPresent()\n+            throws Exception {\n+        startNewBookieWithMultipleLedgerDirs(2);\n+\n+        File[] ledgerDirs = bsConfs.get(1).getLedgerDirs();\n+        assertEquals(\"Only one ledger dir should be present\", 2,\n+                ledgerDirs.length);\n+        Bookie bookie = bs.get(1).getBookie();\n+        LedgerHandle ledger = bkc.createLedger(2, 2, DigestType.MAC,\n+                \"\".getBytes());\n+        LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+\n+        for (int i = 0; i < 10; i++) {\n+            ledger.addEntry(\"data\".getBytes());\n+        }\n+\n+        // Now add the current ledger dir to filled dirs list\n+        ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0], \"current\"));\n+        for (int i = 0; i < 10; i++) {\n+            ledger.addEntry(\"data\".getBytes());\n+        }\n+        assertEquals(\"writable dirs should have one dir\", 1, ledgerDirsManager\n+                .getWritableLedgerDirs().size());\n+        assertTrue(\"Bookie should shutdown if readOnlyMode not enabled\",\n+                bookie.isAlive());\n+    }\n+\n+    private void startNewBookieWithMultipleLedgerDirs(int numOfLedgerDirs)\n+            throws Exception {\n+        ServerConfiguration conf = bsConfs.get(1);\n+        killBookie(1);\n+\n+        File[] ledgerDirs = new File[numOfLedgerDirs];\n+        for (int i = 0; i < numOfLedgerDirs; i++) {\n+            File dir = File.createTempFile(\"bookie\", \"test\");\n+            tmpDirs.add(dir);\n+            dir.delete();\n+            dir.mkdir();\n+            ledgerDirs[i] = dir;\n+        }\n+\n+        ServerConfiguration newConf = newServerConfiguration(\n+                conf.getBookiePort() + 1, zkUtil.getZooKeeperConnectString(),\n+                ledgerDirs[0], ledgerDirs);\n+        bsConfs.add(newConf);\n+        bs.add(startBookie(newConf));\n+    }\n+}"},{"sha":"5801b3d7724b323db1bccf1f66a65f7115b34c22","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/TestDiskChecker.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/util/TestDiskChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/794d8c6a363433bc129deeb5568e83ac716379e6/bookkeeper-server/src/test/java/org/apache/bookkeeper/util/TestDiskChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/util/TestDiskChecker.java?ref=794d8c6a363433bc129deeb5568e83ac716379e6","patch":"@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.util;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.util.DiskChecker.DiskErrorException;\n+import org.apache.bookkeeper.util.DiskChecker.DiskOutOfSpaceException;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Test to verify {@link DiskChecker}\n+ * \n+ */\n+public class TestDiskChecker {\n+\n+    DiskChecker diskChecker;\n+\n+    @Before\n+    public void setup() {\n+        diskChecker = new DiskChecker(0.95f);\n+    }\n+\n+    /**\n+     * Check the disk full\n+     */\n+    @Test(expected = DiskOutOfSpaceException.class)\n+    public void testCheckDiskFull() throws IOException {\n+        File file = File.createTempFile(\"DiskCheck\", \"test\");\n+        long usableSpace = file.getUsableSpace();\n+        long totalSpace = file.getTotalSpace();\n+        diskChecker\n+                .setDiskSpaceThreshold((1f - ((float) usableSpace / (float) totalSpace)) - 0.05f);\n+        diskChecker.checkDiskFull(file);\n+    }\n+\n+    /**\n+     * Check disk full on non exist file. in this case it should check for\n+     * parent file\n+     */\n+    @Test(expected = DiskOutOfSpaceException.class)\n+    public void testCheckDiskFullOnNonExistFile() throws IOException {\n+        File file = File.createTempFile(\"DiskCheck\", \"test\");\n+        long usableSpace = file.getUsableSpace();\n+        long totalSpace = file.getTotalSpace();\n+        diskChecker\n+                .setDiskSpaceThreshold((1f - ((float) usableSpace / (float) totalSpace)) - 0.05f);\n+        assertTrue(file.delete());\n+        diskChecker.checkDiskFull(file);\n+    }\n+\n+    /**\n+     * Check disk error for file\n+     */\n+    @Test(expected = DiskErrorException.class)\n+    public void testCheckDiskErrorForFile() throws Exception {\n+        File parent = File.createTempFile(\"DiskCheck\", \"test\");\n+        parent.delete();\n+        parent.mkdir();\n+        File child = File.createTempFile(\"DiskCheck\", \"test\", parent);\n+        diskChecker.checkDir(child);\n+    }\n+\n+    /**\n+     * Check disk error for valid dir.\n+     */\n+    @Test\n+    public void testCheckDiskErrorForDir() throws Exception {\n+        File parent = File.createTempFile(\"DiskCheck\", \"test\");\n+        parent.delete();\n+        parent.mkdir();\n+        File child = File.createTempFile(\"DiskCheck\", \"test\", parent);\n+        child.delete();\n+        child.mkdir();\n+        diskChecker.checkDir(child);\n+    }\n+}"}]}

