{"sha":"79a73f0f71be5701b44ab47c14f92945989b1417","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3OWE3M2YwZjcxYmU1NzAxYjQ0YWI0N2MxNGY5Mjk0NTk4OWIxNDE3","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-01-09T06:30:11Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-01-09T06:30:11Z"},"message":"BOOKKEEPER-714: Logging channel exceptions in PerChannelBookieClient (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1556732 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6f27922d9b0e252e514700192c3b3f2e0cf33cac","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6f27922d9b0e252e514700192c3b3f2e0cf33cac"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/79a73f0f71be5701b44ab47c14f92945989b1417","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/79a73f0f71be5701b44ab47c14f92945989b1417","html_url":"https://github.com/apache/bookkeeper/commit/79a73f0f71be5701b44ab47c14f92945989b1417","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/79a73f0f71be5701b44ab47c14f92945989b1417/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"5c3a30f8e423da51b1ee03173a336400335de3b8","url":"https://api.github.com/repos/apache/bookkeeper/commits/5c3a30f8e423da51b1ee03173a336400335de3b8","html_url":"https://github.com/apache/bookkeeper/commit/5c3a30f8e423da51b1ee03173a336400335de3b8"}],"stats":{"total":32,"additions":20,"deletions":12},"files":[{"sha":"4a3447244ac3afa9e494270f27e83e37b2a3eb44","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/79a73f0f71be5701b44ab47c14f92945989b1417/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/79a73f0f71be5701b44ab47c14f92945989b1417/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=79a73f0f71be5701b44ab47c14f92945989b1417","patch":"@@ -132,6 +132,8 @@ Trunk (unreleased changes)\n \n \tBOOKKEEPER-709: SlowBookieTest#testSlowBookie fails intermittently (Rakesh R via fpj)\n \n+        BOOKKEEPER-714: Logging channel exceptions in PerChannelBookieClient (sijie)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"ef67a58c6a0d071f731c6edfe6728dabd17fddbf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":18,"deletions":12,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/79a73f0f71be5701b44ab47c14f92945989b1417/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/79a73f0f71be5701b44ab47c14f92945989b1417/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=79a73f0f71be5701b44ab47c14f92945989b1417","patch":"@@ -19,16 +19,14 @@\n \n import java.io.IOException;\n import java.net.InetSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n-import java.util.Set;\n-import java.util.Collections;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import com.google.common.collect.ImmutableSet;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -55,10 +53,7 @@\n import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n-import org.jboss.netty.handler.timeout.ReadTimeoutException;\n import org.jboss.netty.handler.timeout.ReadTimeoutHandler;\n-import org.jboss.netty.util.HashedWheelTimer;\n-import org.jboss.netty.util.Timer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -200,8 +195,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         closeChannel(future.getChannel());\n                         return; // pendingOps should have been completed when other channel connected\n                     } else {\n-                        LOG.error(\"Could not connect to bookie: {}, current state {}\",\n-                                  future.getChannel(), state);\n+                        LOG.error(\"Could not connect to bookie: {}, current state {} : \",\n+                                  new Object[] { future.getChannel(), state, future.getCause() });\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n                         closeChannel(future.getChannel());\n                         channel = null;\n@@ -276,11 +271,10 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n      * @param ledgerId\n      * @param masterKey\n      * @param entryId\n-     * @param lastConfirmed\n-     * @param macCode\n-     * @param data\n+     * @param toSend\n      * @param cb\n      * @param ctx\n+     * @param options\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n@@ -306,6 +300,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                         }\n                         // totalBytesOutstanding.addAndGet(entrySize);\n                     } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing addEntry(lid={}, eid={}) to channel {} failed : \",\n+                                    new Object[] { ledgerId, entryId, c, future.getCause() });\n+                        }\n                         errorOutAddKey(completionKey);\n                     }\n                 }\n@@ -343,6 +341,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                                           r, c.getRemoteAddress());\n                             }\n                         } else {\n+                            if (!(future.getCause() instanceof ClosedChannelException)) {\n+                                LOG.warn(\"Writing readEntryAndFenceLedger(lid={}, eid={}) to channel {} failed : \",\n+                                        new Object[] { ledgerId, entryId, c, future.getCause() });\n+                            }\n                             errorOutReadKey(key);\n                         }\n                     }\n@@ -378,6 +380,10 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                                       r, c.getRemoteAddress());\n                         }\n                     } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing readEntry(lid={}, eid={}) to channel {} failed : \",\n+                                    new Object[] { ledgerId, entryId, c, future.getCause() });\n+                        }\n                         errorOutReadKey(key);\n                     }\n                 }\n@@ -689,7 +695,7 @@ void handleReadResponse(BookieProtocol.ReadResponse rr) {\n              * submits a read request with id -1, and receives a response with a\n              * different entry id.\n              */\n-            \n+\n             readCompletion = readCompletions.remove(new CompletionKey(rr.getLedgerId(),\n                                                                       BookieProtocol.LAST_ADD_CONFIRMED));\n         }"}]}

