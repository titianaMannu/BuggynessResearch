{"sha":"7dced572419c90b27b587eccc09d48032e7a6a9c","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3ZGNlZDU3MjQxOWM5MGIyN2I1ODdlY2NjMDlkNDgwMzJlN2E2YTlj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-25T14:50:05Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-25T14:50:05Z"},"message":"BOOKKEEPER-416: LedgerChecker returns underreplicated fragments for an closed ledger with no entries (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1402172 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7922179979a772cc84bddcafe277f642191fd51d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7922179979a772cc84bddcafe277f642191fd51d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7dced572419c90b27b587eccc09d48032e7a6a9c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7dced572419c90b27b587eccc09d48032e7a6a9c","html_url":"https://github.com/apache/bookkeeper/commit/7dced572419c90b27b587eccc09d48032e7a6a9c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7dced572419c90b27b587eccc09d48032e7a6a9c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"2c7236cf339a2de3cf3fbc0aaa8cd88cc4398ca0","url":"https://api.github.com/repos/apache/bookkeeper/commits/2c7236cf339a2de3cf3fbc0aaa8cd88cc4398ca0","html_url":"https://github.com/apache/bookkeeper/commit/2c7236cf339a2de3cf3fbc0aaa8cd88cc4398ca0"}],"stats":{"total":100,"additions":98,"deletions":2},"files":[{"sha":"469217770e6900f9281879504ffeb2a6fd1eb794","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/7dced572419c90b27b587eccc09d48032e7a6a9c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/7dced572419c90b27b587eccc09d48032e7a6a9c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=7dced572419c90b27b587eccc09d48032e7a6a9c","patch":"@@ -98,6 +98,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-424: Bookie start is failing intermittently when zkclient connection delays (rakeshr via ivank)\n \n+        BOOKKEEPER-416: LedgerChecker returns underreplicated fragments for an closed ledger with no entries (ivank)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"f2d863cf0dc3bcb5bd5243bc2d2842c39bc383ba","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/7dced572419c90b27b587eccc09d48032e7a6a9c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/7dced572419c90b27b587eccc09d48032e7a6a9c/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=7dced572419c90b27b587eccc09d48032e7a6a9c","patch":"@@ -192,7 +192,8 @@ public void checkLedger(LedgerHandle lh,\n \n         /* Checking the last segment of the ledger can be complicated in some cases.\n          * In the case that the ledger is closed, we can just check the fragments of\n-         * the segment as normal.\n+         * the segment as normal, except in the case that no entry was ever written,\n+         * to the ledger, in which case we check no fragments.\n          * In the case that the ledger is open, but enough entries have been written,\n          * for lastAddConfirmed to be set above the start entry of the segment, we\n          * can also check as normal.\n@@ -203,7 +204,9 @@ public void checkLedger(LedgerHandle lh,\n          * NoSuchEntry we can assume it was never written. If they respond with anything\n          * else, we must assume the entry has been written, so we run the check.\n          */\n-        if (curEntryId != null) {\n+        if (curEntryId != null\n+            && !(lh.getLastAddConfirmed() == LedgerHandle.INVALID_ENTRY_ID\n+                 && lh.getLedgerMetadata().isClosed())) {\n             long lastEntry = lh.getLastAddConfirmed();\n \n             if (lastEntry < curEntryId) {"},{"sha":"d9dfdd03ace2a600c6bc87cb1250d638e1d006c3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"modified","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/7dced572419c90b27b587eccc09d48032e7a6a9c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/7dced572419c90b27b587eccc09d48032e7a6a9c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=7dced572419c90b27b587eccc09d48032e7a6a9c","patch":"@@ -353,6 +353,97 @@ public void testSingleEntryAfterEnsembleChange() throws Exception {\n                 + result, 3, result.size());\n     }\n \n+    /**\n+     * Tests that LedgerChecker does not return any fragments\n+     * from a closed ledger with 0 entries.\n+     */\n+    @Test(timeout = 3000)\n+    public void testClosedEmptyLedger() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+        lh.close();\n+\n+        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(0);\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+\n+        //Open ledger separately for Ledger checker.\n+        LedgerHandle lh1 =bkc.openLedgerNoRecovery(lh.getId(), BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh1);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 0 fragment. But returned fragments are \"\n+                + result, 0, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker does not return any fragments\n+     * from a closed ledger with 0 entries.\n+     */\n+    @Test(timeout = 3000)\n+    public void testClosedSingleEntryLedger() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+            .getEnsembles().get(0L);\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        lh.close();\n+\n+        // kill bookie 2\n+        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(2);\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+\n+        //Open ledger separately for Ledger checker.\n+        LedgerHandle lh1 =bkc.openLedgerNoRecovery(lh.getId(), BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh1);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 0 fragment. But returned fragments are \"\n+                + result, 0, result.size());\n+        lh1.close();\n+\n+        // kill bookie 1\n+        lastBookieFromEnsemble = firstEnsemble.get(1);\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+        startNewBookie();\n+\n+        //Open ledger separately for Ledger checker.\n+        lh1 =bkc.openLedgerNoRecovery(lh.getId(), BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        result = getUnderReplicatedFragments(lh1);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 1 fragment. But returned fragments are \"\n+                + result, 1, result.size());\n+        lh1.close();\n+\n+        // kill bookie 0\n+        lastBookieFromEnsemble = firstEnsemble.get(0);\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+        startNewBookie();\n+\n+        //Open ledger separately for Ledger checker.\n+        lh1 =bkc.openLedgerNoRecovery(lh.getId(), BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        result = getUnderReplicatedFragments(lh1);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 2 fragment. But returned fragments are \"\n+                + result, 2, result.size());\n+        lh1.close();\n+    }\n+\n     private Set<LedgerFragment> getUnderReplicatedFragments(LedgerHandle lh)\n             throws InterruptedException {\n         LedgerChecker checker = new LedgerChecker(bkc);"}]}

