{"sha":"7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3ZGUzZWNiZDVkNTA1MjEzOGE5YzRhZGVkOTI1NmM1MDMwYWIyZjZk","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-12-24T05:23:12Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-12-24T05:23:12Z"},"message":"BOOKKEEPER-447: Bookie can fail to recover if index pages flushed before ledger flush acknowledged (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1425588 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b4a630d417c960590296a5e9286e8e472a0dbd6e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b4a630d417c960590296a5e9286e8e472a0dbd6e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","html_url":"https://github.com/apache/bookkeeper/commit/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"a0ae97c232caafa1fda9955f9aaa9f99564b74fe","url":"https://api.github.com/repos/apache/bookkeeper/commits/a0ae97c232caafa1fda9955f9aaa9f99564b74fe","html_url":"https://github.com/apache/bookkeeper/commit/a0ae97c232caafa1fda9955f9aaa9f99564b74fe"}],"stats":{"total":112,"additions":104,"deletions":8},"files":[{"sha":"c80907319df1f7a4d4aedd66dbc477ceeb37eec6","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","patch":"@@ -152,6 +152,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-520: BookieFailureTest hangs on precommit build (ivank via sijie)\n \n+        BOOKKEEPER-447: Bookie can fail to recover if index pages flushed before ledger flush acknowledged (ivank via sijie)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"effe9fad69cdcff1798b91e80dedf940357a2346","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","patch":"@@ -133,10 +133,15 @@ public long getLedgerId() {\n         private long ledgerId;\n         private long entryId;\n         public NoEntryException(long ledgerId, long entryId) {\n-            super(\"Entry \" + entryId + \" not found in \" + ledgerId);\n+            this(\"Entry \" + entryId + \" not found in \" + ledgerId, ledgerId, entryId);\n+        }\n+\n+        public NoEntryException(String msg, long ledgerId, long entryId) {\n+            super(msg);\n             this.ledgerId = ledgerId;\n             this.entryId = entryId;\n         }\n+\n         public long getLedger() {\n             return ledgerId;\n         }"},{"sha":"7b5dcbb7c6ef8c440fd081e174e089d39a330b89","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":13,"deletions":3,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","patch":"@@ -349,7 +349,7 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         return (logId << 32L) | pos;\n     }\n \n-    byte[] readEntry(long ledgerId, long entryId, long location) throws IOException {\n+    byte[] readEntry(long ledgerId, long entryId, long location) throws IOException, Bookie.NoEntryException {\n         long entryLogId = location >> 32L;\n         long pos = location & 0xffffffffL;\n         ByteBuffer sizeBuff = ByteBuffer.allocate(4);\n@@ -363,7 +363,8 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n             throw newe;\n         }\n         if (fc.read(sizeBuff, pos) != sizeBuff.capacity()) {\n-            throw new IOException(\"Short read from entrylog \" + entryLogId);\n+            throw new Bookie.NoEntryException(\"Short read from entrylog \" + entryLogId,\n+                                              ledgerId, entryId);\n         }\n         pos += 4;\n         sizeBuff.flip();\n@@ -377,7 +378,16 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         ByteBuffer buff = ByteBuffer.wrap(data);\n         int rc = fc.read(buff, pos);\n         if ( rc != data.length) {\n-            throw new IOException(\"Short read for \" + ledgerId + \"@\" + entryId + \" in \" + entryLogId + \"@\" + pos + \"(\"+rc+\"!=\"+data.length+\")\");\n+            // Note that throwing NoEntryException here instead of IOException is not\n+            // without risk. If all bookies in a quorum throw this same exception\n+            // the client will assume that it has reached the end of the ledger.\n+            // However, this may not be the case, as a very specific error condition\n+            // could have occurred, where the length of the entry was corrupted on all\n+            // replicas. However, the chance of this happening is very very low, so\n+            // returning NoEntryException is mostly safe.\n+            throw new Bookie.NoEntryException(\"Short read for \" + ledgerId + \"@\"\n+                                              + entryId + \" in \" + entryLogId + \"@\"\n+                                              + pos + \"(\"+rc+\"!=\"+data.length+\")\", ledgerId, entryId);\n         }\n         buff.flip();\n         long thisLedgerId = buff.getLong();"},{"sha":"235f47496184f1dc029f210650d0124bc2db0c81","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":83,"deletions":4,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","patch":"@@ -50,6 +50,7 @@\n     SnapshotMap<Long, Boolean> activeLedgers;\n     LedgerManagerFactory ledgerManagerFactory;\n     LedgerCache ledgerCache;\n+    Thread flushThread;\n     ServerConfiguration conf;\n     File txnDir, ledgerDir;\n \n@@ -82,6 +83,10 @@ public void setUp() throws Exception {\n     @Override\n     @After\n     public void tearDown() throws Exception {\n+        if (flushThread != null) {\n+            flushThread.interrupt();\n+            flushThread.join();\n+        }\n         bookie.ledgerStorage.shutdown();\n         ledgerManagerFactory.uninitialize();\n         FileUtils.deleteDirectory(txnDir);\n@@ -94,9 +99,26 @@ private void newLedgerCache() throws IOException {\n         }\n         ledgerCache = ((InterleavedLedgerStorage) bookie.ledgerStorage).ledgerCache = new LedgerCacheImpl(\n                 conf, activeLedgers, bookie.getLedgerDirsManager());\n+        flushThread = new Thread() {\n+                public void run() {\n+                    while (true) {\n+                        try {\n+                            sleep(conf.getFlushInterval());\n+                            ledgerCache.flushLedger(true);\n+                        } catch (InterruptedException ie) {\n+                            // killed by teardown\n+                            Thread.currentThread().interrupt();\n+                            return;\n+                        } catch (Exception e) {\n+                            LOG.error(\"Exception in flush thread\", e);\n+                        }\n+                    }\n+                }\n+            };\n+        flushThread.start();\n     }\n \n-    @Test\n+    @Test(timeout=30000)\n     public void testAddEntryException() throws IOException {\n         // set page limitation\n         conf.setPageLimit(10);\n@@ -117,7 +139,7 @@ public void testAddEntryException() throws IOException {\n         }\n     }\n \n-    @Test\n+    @Test(timeout=30000)\n     public void testLedgerEviction() throws Exception {\n         int numEntries = 10;\n         // limit open files & pages\n@@ -140,7 +162,7 @@ public void testLedgerEviction() throws Exception {\n         }\n     }\n \n-    @Test\n+    @Test(timeout=30000)\n     public void testDeleteLedger() throws Exception {\n         int numEntries = 10;\n         // limit open files & pages\n@@ -175,7 +197,7 @@ public void testDeleteLedger() throws Exception {\n         }\n     }\n \n-    @Test\n+    @Test(timeout=30000)\n     public void testPageEviction() throws Exception {\n         int numLedgers = 10;\n         byte[] masterKey = \"blah\".getBytes();\n@@ -226,6 +248,7 @@ public void testPageEviction() throws Exception {\n     /**\n      * Test Ledger Cache flush failure\n      */\n+    @Test(timeout=30000)\n     public void testLedgerCacheFlushFailureOnDiskFull() throws Exception {\n         File ledgerDir1 = File.createTempFile(\"bkTest\", \".dir\");\n         ledgerDir1.delete();\n@@ -266,6 +289,62 @@ public void testLedgerCacheFlushFailureOnDiskFull() throws Exception {\n         Assert.assertArrayEquals(generateEntry(1, 3).array(), ledgerStorage.getEntry(1, 3).array());\n     }\n \n+    /**\n+     * Test that if we are writing to more ledgers than there\n+     * are pages, then we will not flush the index before the\n+     * entries in the entrylogger have been persisted to disk.\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-447}\n+     */\n+    @Test(timeout=30000)\n+    public void testIndexPageEvictionWriteOrder() throws Exception {\n+        final int numLedgers = 10;\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() })\n+            .setFlushInterval(1000)\n+            .setPageLimit(1);\n+\n+        Bookie b = new Bookie(conf);\n+        b.start();\n+        for (int i = 1; i <= numLedgers; i++) {\n+            ByteBuffer packet = generateEntry(i, 1);\n+            b.addEntry(packet, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes());\n+        }\n+\n+        conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        b = new Bookie(conf);\n+        for (int i = 1; i <= numLedgers; i++) {\n+            try {\n+                b.readEntry(i, 1);\n+            } catch (Bookie.NoLedgerException nle) {\n+                // this is fine, means the ledger was never written to the index cache\n+                assertEquals(\"No ledger should only happen for the last ledger\",\n+                             i, numLedgers);\n+            } catch (Bookie.NoEntryException nee) {\n+                // this is fine, means the ledger was written to the index cache, but not\n+                // the entry log\n+            } catch (IOException ioe) {\n+                LOG.info(\"Shouldn't have received IOException\", ioe);\n+                fail(\"Shouldn't throw IOException, should say that entry is not found\");\n+            }\n+        }\n+    }\n+\n     private ByteBuffer generateEntry(long ledger, long entry) {\n         byte[] data = (\"ledger-\" + ledger + \"-\" + entry).getBytes();\n         ByteBuffer bb = ByteBuffer.wrap(new byte[8 + 8 + data.length]);"}]}

