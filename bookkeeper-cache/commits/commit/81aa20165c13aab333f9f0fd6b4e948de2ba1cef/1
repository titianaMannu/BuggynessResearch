{"sha":"81aa20165c13aab333f9f0fd6b4e948de2ba1cef","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MWFhMjAxNjVjMTNhYWIzMzNmOWYwZmQ2YjRlOTQ4ZGUyYmExY2Vm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-22T10:10:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-22T10:10:38Z"},"message":"BOOKKEEPER-435: Create SubscriptionChannelManager to manage all subscription channel (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1400827 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b1ef6b7531fff6037d0047449543dc23d4b8f30d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b1ef6b7531fff6037d0047449543dc23d4b8f30d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/81aa20165c13aab333f9f0fd6b4e948de2ba1cef","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/81aa20165c13aab333f9f0fd6b4e948de2ba1cef","html_url":"https://github.com/apache/bookkeeper/commit/81aa20165c13aab333f9f0fd6b4e948de2ba1cef","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"794d8c6a363433bc129deeb5568e83ac716379e6","url":"https://api.github.com/repos/apache/bookkeeper/commits/794d8c6a363433bc129deeb5568e83ac716379e6","html_url":"https://github.com/apache/bookkeeper/commit/794d8c6a363433bc129deeb5568e83ac716379e6"}],"stats":{"total":350,"additions":231,"deletions":119},"files":[{"sha":"48e903f6aa70b79f53f3ed0cc03a4ea1879112ff","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -186,6 +186,8 @@ Trunk (unreleased changes)\n \n \tBOOKKEEPER-422: Simplify AbstractSubscriptionManager (stu via fpj)\n \n+        BOOKKEEPER-435: Create SubscriptionChannelManager to manage all subscription channel (sijie via ivank)\n+\n       hedwig-client:\n \n         BOOKKEEPER-306: Change C++ client to use gtest for testing (ivank via sijie)"},{"sha":"e0f14873640e8af0eca4e274ee49d806537c79c8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","status":"modified","additions":5,"deletions":9,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -18,19 +18,15 @@\n \n package org.apache.hedwig.server.handlers;\n \n-import java.util.Map;\n-\n-import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.server.handlers.SubscriptionChannelManager;\n import org.apache.hedwig.server.jmx.HedwigMBeanInfo;\n \n public class NettyHandlerBean implements NettyHandlerMXBean, HedwigMBeanInfo {\n \n-    Map<OperationType, Handler> handlers;\n-    SubscribeHandler subHandler;\n+    SubscriptionChannelManager subChannelMgr;\n \n-    public NettyHandlerBean(Map<OperationType, Handler> handlers) {\n-        this.handlers = handlers;\n-        subHandler = (SubscribeHandler) this.handlers.get(OperationType.SUBSCRIBE);\n+   public NettyHandlerBean(SubscriptionChannelManager subChannelMgr) {\n+       this.subChannelMgr = subChannelMgr;\n     }\n \n     @Override\n@@ -45,7 +41,7 @@ public boolean isHidden() {\n \n     @Override\n     public int getNumSubscriptionChannels() {\n-        return subHandler.sub2Channel.size();\n+        return subChannelMgr.getNumSubscriptionChannels();\n     }\n \n }"},{"sha":"dfcde9fb22520cd4a42eaf7d09eecc29217e83ef","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"modified","additions":27,"deletions":86,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -17,8 +17,6 @@\n  */\n package org.apache.hedwig.server.handlers;\n \n-import java.util.concurrent.ConcurrentHashMap;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n@@ -54,53 +52,32 @@\n import org.apache.hedwig.server.subscriptions.AllToAllTopologyFilter;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n \n-public class SubscribeHandler extends BaseHandler implements ChannelDisconnectListener {\n+public class SubscribeHandler extends BaseHandler {\n     static Logger logger = LoggerFactory.getLogger(SubscribeHandler.class);\n \n-    private DeliveryManager deliveryMgr;\n-    private PersistenceManager persistenceMgr;\n-    private SubscriptionManager subMgr;\n-    ConcurrentHashMap<TopicSubscriber, Channel> sub2Channel;\n-    ConcurrentHashMap<Channel, TopicSubscriber> channel2sub;\n+    private final DeliveryManager deliveryMgr;\n+    private final PersistenceManager persistenceMgr;\n+    private final SubscriptionManager subMgr;\n+    private final SubscriptionChannelManager subChannelMgr;\n+\n     // op stats\n     private final OpStats subStats;\n \n-    private static ChannelFutureListener CLOSE_OLD_CHANNEL_LISTENER = new ChannelFutureListener() {\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (!future.isSuccess()) {\n-                logger.warn(\"Failed to close old subscription channel.\");\n-            } else {\n-                logger.debug(\"Close old subscription channel succeed.\");\n-            }\n-        }\n-    };\n-\n-    public SubscribeHandler(TopicManager topicMgr, DeliveryManager deliveryManager, PersistenceManager persistenceMgr,\n-                            SubscriptionManager subMgr, ServerConfiguration cfg) {\n+    public SubscribeHandler(ServerConfiguration cfg, TopicManager topicMgr,\n+                            DeliveryManager deliveryManager,\n+                            PersistenceManager persistenceMgr,\n+                            SubscriptionManager subMgr,\n+                            SubscriptionChannelManager subChannelMgr) {\n         super(topicMgr, cfg);\n         this.deliveryMgr = deliveryManager;\n         this.persistenceMgr = persistenceMgr;\n         this.subMgr = subMgr;\n-        sub2Channel = new ConcurrentHashMap<TopicSubscriber, Channel>();\n-        channel2sub = new ConcurrentHashMap<Channel, TopicSubscriber>();\n+        this.subChannelMgr = subChannelMgr;\n         subStats = ServerStats.getInstance().getOpStats(OperationType.SUBSCRIBE);\n     }\n \n-    public void channelDisconnected(Channel channel) {\n-        // Evils of synchronized programming: there is a race between a channel\n-        // getting disconnected, and us adding it to the maps when a subscribe\n-        // succeeds\n-        synchronized (channel) {\n-            TopicSubscriber topicSub = channel2sub.remove(channel);\n-            if (topicSub != null) {\n-                // remove entry only currently mapped to given value.\n-                sub2Channel.remove(topicSub, channel);\n-            }\n-        }\n-    }\n-\n     @Override\n     public void handleRequestAtOwner(final PubSubRequest request, final Channel channel) {\n \n@@ -192,56 +169,20 @@ public void operationFinished(Object ctx, SubscriptionData subData) {\n                     .addListener(ChannelFutureListener.CLOSE);\n                     return;\n                 }\n-                // race with channel getting disconnected while we are adding it\n-                // to the 2 maps\n-                synchronized (channel) {\n-                    boolean forceAttach = false;\n-                    if (subRequest.hasForceAttach()) {\n-                        forceAttach = subRequest.getForceAttach();\n-                    }\n-\n-                    Channel oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n-                    if (null != oldChannel) {\n-                        boolean subSuccess = false;\n-                        if (forceAttach) {\n-                            // it is safe to close old channel here since new channel will be put\n-                            // in sub2Channel / channel2Sub so there is no race between channel\n-                            // getting disconnected and it.\n-                            ChannelFuture future = oldChannel.close();\n-                            future.addListener(CLOSE_OLD_CHANNEL_LISTENER);\n-                            logger.info(\"New subscribe request (\" + request.getTxnId() + \") for (topic: \" + topic.toStringUtf8()\n-                                      + \", subscriber: \" + subscriberId.toStringUtf8() + \") from channel \" + channel.getRemoteAddress()\n-                                      + \" kills old channel \" + oldChannel.getRemoteAddress());\n-                            // try replace the oldChannel\n-                            // if replace failure, it migth caused because channelDisconnect callback\n-                            // has removed the old channel.\n-                            if (!sub2Channel.replace(topicSub, oldChannel, channel)) {\n-                                // try to add it now.\n-                                // if add failure, it means other one has obtained the channel\n-                                oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n-                                if (null == oldChannel) {\n-                                    subSuccess = true;\n-                                }\n-                            } else {\n-                                subSuccess = true;\n-                            }\n-                        }\n-                        if (!subSuccess) {\n-                            PubSubException pse = new PubSubException.TopicBusyException(\n-                                \"Subscriber \" + subscriberId.toStringUtf8() + \" for topic \" + topic.toStringUtf8()\n-                                + \" is already being served on a different channel \" + oldChannel.getRemoteAddress());\n-                            subStats.incrementFailedOps();\n-                            logger.error(\"Error serving subscribe request (\" + request.getTxnId() + \") for (topic: \" + topic.toStringUtf8()\n-                                       + \", subscriber: \" + subscriberId.toStringUtf8() + \") from channel \" + channel.getRemoteAddress()\n-                                       + \" since it already being served on a different channel \" + oldChannel.getRemoteAddress());\n-                            channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n-                            .addListener(ChannelFutureListener.CLOSE);\n-                            return;\n-                        }\n-                    }\n-                    // channel2sub is just a cache, so we can add to it\n-                    // without synchronization\n-                    channel2sub.put(channel, topicSub);\n+                boolean forceAttach = false;\n+                if (subRequest.hasForceAttach()) {\n+                    forceAttach = subRequest.getForceAttach();\n+                }\n+                // Try to store the subscription channel for the topic subscriber\n+                Channel oldChannel = subChannelMgr.put(topicSub, channel, forceAttach);\n+                if (null != oldChannel) {\n+                    PubSubException pse = new PubSubException.TopicBusyException(\n+                        \"Subscriber \" + subscriberId.toStringUtf8() + \" for topic \" + topic.toStringUtf8()\n+                        + \" is already being served on a different channel \" + oldChannel + \".\");\n+                    subStats.incrementFailedOps();\n+                    channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+                    return;\n                 }\n                 // First write success and then tell the delivery manager,\n                 // otherwise the first message might go out before the response"},{"sha":"2a8d0939d793dd95119a9c983e89dc68a9cb000f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -0,0 +1,153 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class SubscriptionChannelManager implements ChannelDisconnectListener {\n+\n+    static Logger logger = LoggerFactory.getLogger(SubscriptionChannelManager.class);\n+\n+    private static ChannelFutureListener CLOSE_OLD_CHANNEL_LISTENER =\n+    new ChannelFutureListener() {\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (!future.isSuccess()) {\n+                logger.warn(\"Failed to close old subscription channel.\");\n+            } else {\n+                logger.debug(\"Close old subscription channel succeed.\");\n+            }\n+        }\n+    };\n+\n+    final ConcurrentHashMap<TopicSubscriber, Channel> sub2Channel;\n+    final ConcurrentHashMap<Channel, TopicSubscriber> channel2sub;\n+\n+    public SubscriptionChannelManager() {\n+        sub2Channel = new ConcurrentHashMap<TopicSubscriber, Channel>();\n+        channel2sub = new ConcurrentHashMap<Channel, TopicSubscriber>();\n+    }\n+\n+    @Override\n+    public void channelDisconnected(Channel channel) {\n+        // Evils of synchronized programming: there is a race between a channel\n+        // getting disconnected, and us adding it to the maps when a subscribe\n+        // succeeds\n+        synchronized (channel) {\n+            TopicSubscriber topicSub = channel2sub.remove(channel);\n+            if (topicSub != null) {\n+                logger.info(\"Subscription channel {} for {} is disconnected.\",\n+                            va(channel.getRemoteAddress(), topicSub));\n+                // remove entry only currently mapped to given value.\n+                sub2Channel.remove(topicSub, channel);\n+            }\n+        }\n+    }\n+\n+    public int getNumSubscriptionChannels() {\n+        return channel2sub.size();\n+    }\n+\n+    public int getNumSubscriptions() {\n+        return sub2Channel.size();\n+    }\n+\n+    /**\n+     * Put <code>topicSub</code> on Channel <code>channel</code>.\n+     *\n+     * @param topicSub\n+     *          Topic Subscription\n+     * @param channel\n+     *          Netty channel\n+     * @param mode\n+     *          Create or Attach mode\n+     * @return null succeed, otherwise the old existed channel.\n+     */\n+    public Channel put(TopicSubscriber topicSub, Channel channel, boolean forceAttach) {\n+        // race with channel getting disconnected while we are adding it\n+        // to the 2 maps\n+        synchronized (channel) {\n+            Channel oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n+            if (null != oldChannel) {\n+                boolean subSuccess = false;\n+                if (forceAttach) {\n+                    // it is safe to close old channel here since new channel will be put\n+                    // in sub2Channel / channel2Sub so there is no race between channel\n+                    // getting disconnected and it.\n+                    ChannelFuture future = oldChannel.close();\n+                    future.addListener(CLOSE_OLD_CHANNEL_LISTENER);\n+                    logger.info(\"Subscribe request for ({}) from channel ({}) kills old channel ({}).\",\n+                                va(topicSub, channel, oldChannel));\n+                    // try replace the oldChannel\n+                    // if replace failure, it migth caused because channelDisconnect callback\n+                    // has removed the old channel.\n+                    if (!sub2Channel.replace(topicSub, oldChannel, channel)) {\n+                        // try to add it now.\n+                        // if add failure, it means other one has obtained the channel\n+                        oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n+                        if (null == oldChannel) {\n+                            subSuccess = true;\n+                        }\n+                    } else {\n+                        subSuccess = true;\n+                    }\n+                }\n+                if (!subSuccess) {\n+                    logger.error(\"Error serving subscribe request for ({}) from ({}) since it already served on ({}).\",\n+                                 va(topicSub, channel, oldChannel));\n+                    return oldChannel;\n+                }\n+            }\n+            // channel2sub is just a cache, so we can add to it\n+            // without synchronization\n+            channel2sub.put(channel, topicSub);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Remove <code>topicSub</code> from Channel <code>channel</code>\n+     *\n+     * @param topicSub\n+     *          Topic Subscription\n+     * @param channel\n+     *          Netty channel\n+     */\n+    public void remove(TopicSubscriber topicSub, Channel channel) {\n+        synchronized (channel) {\n+            if (!channel2sub.remove(channel, topicSub)) {\n+                logger.warn(\"Failed to remove subscription ({}) due to it isn't on channel ({}).\",\n+                            va(topicSub, channel));\n+            }\n+            if (!sub2Channel.remove(topicSub, channel)) {\n+                logger.warn(\"Failed to remove channel ({}) due to it isn't ({})'s channel.\",\n+                            va(channel, topicSub));\n+            }\n+        }\n+    }\n+}"},{"sha":"4c1b818ce678af0ff8abda1c3b94962063f5e8c9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":24,"deletions":13,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -61,6 +61,7 @@\n import org.apache.hedwig.server.handlers.NettyHandlerBean;\n import org.apache.hedwig.server.handlers.PublishHandler;\n import org.apache.hedwig.server.handlers.SubscribeHandler;\n+import org.apache.hedwig.server.handlers.SubscriptionChannelManager;\n import org.apache.hedwig.server.handlers.UnsubscribeHandler;\n import org.apache.hedwig.server.jmx.HedwigMBeanRegistry;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n@@ -218,24 +219,31 @@ protected TopicManager instantiateTopicManager() throws IOException {\n         return tm;\n     }\n \n-    protected Map<OperationType, Handler> initializeNettyHandlers(TopicManager tm, DeliveryManager dm,\n-            PersistenceManager pm, SubscriptionManager sm) {\n+   protected Map<OperationType, Handler> initializeNettyHandlers(\n+           TopicManager tm, DeliveryManager dm,\n+           PersistenceManager pm, SubscriptionManager sm,\n+           SubscriptionChannelManager subChannelMgr) {\n         Map<OperationType, Handler> handlers = new HashMap<OperationType, Handler>();\n         handlers.put(OperationType.PUBLISH, new PublishHandler(tm, pm, conf));\n-        handlers.put(OperationType.SUBSCRIBE, new SubscribeHandler(tm, dm, pm, sm, conf));\n+        handlers.put(OperationType.SUBSCRIBE,\n+                     new SubscribeHandler(conf, tm, dm, pm, sm, subChannelMgr));\n         handlers.put(OperationType.UNSUBSCRIBE, new UnsubscribeHandler(tm, conf, sm, dm));\n         handlers.put(OperationType.CONSUME, new ConsumeHandler(tm, sm, conf));\n         handlers = Collections.unmodifiableMap(handlers);\n         return handlers;\n     }\n \n-    protected void initializeNetty(SslServerContextFactory sslFactory, Map<OperationType, Handler> handlers) {\n+    protected void initializeNetty(SslServerContextFactory sslFactory,\n+                                   Map<OperationType, Handler> handlers,\n+                                   SubscriptionChannelManager subChannelMgr) {\n         boolean isSSLEnabled = (sslFactory != null) ? true : false;\n         InternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n         ServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n-        UmbrellaHandler umbrellaHandler = new UmbrellaHandler(allChannels, handlers, isSSLEnabled);\n-        PubSubServerPipelineFactory pipeline = new PubSubServerPipelineFactory(umbrellaHandler, sslFactory, conf\n-                .getMaximumMessageSize());\n+        UmbrellaHandler umbrellaHandler =\n+            new UmbrellaHandler(allChannels, handlers, subChannelMgr, isSSLEnabled);\n+        PubSubServerPipelineFactory pipeline =\n+            new PubSubServerPipelineFactory(umbrellaHandler, sslFactory,\n+                                            conf.getMaximumMessageSize());\n \n         bootstrap.setPipelineFactory(pipeline);\n         bootstrap.setOption(\"child.tcpNoDelay\", true);\n@@ -297,14 +305,14 @@ public void shutdown() {\n         unregisterJMX();\n     }\n \n-    protected void registerJMX(Map<OperationType, Handler> handlers) {\n+    protected void registerJMX(SubscriptionChannelManager subChannelMgr) {\n         try {\n             String jmxName = JMXNAME_PREFIX + conf.getServerPort() + \"_\"\n                                             + conf.getSSLServerPort();\n             jmxServerBean = new PubSubServerBean(jmxName);\n             HedwigMBeanRegistry.getInstance().register(jmxServerBean, null);\n             try {\n-                jmxNettyBean = new NettyHandlerBean(handlers);\n+                jmxNettyBean = new NettyHandlerBean(subChannelMgr);\n                 HedwigMBeanRegistry.getInstance().register(jmxNettyBean, jmxServerBean);\n             } catch (Exception e) {\n                 logger.warn(\"Failed to register with JMX\", e);\n@@ -408,14 +416,17 @@ public void run() {\n                     // Initialize the Netty Handlers (used by the\n                     // UmbrellaHandler) once so they can be shared by\n                     // both the SSL and non-SSL channels.\n-                    Map<OperationType, Handler> handlers = initializeNettyHandlers(tm, dm, pm, sm);\n+                    SubscriptionChannelManager subChannelMgr = new SubscriptionChannelManager();\n+                    Map<OperationType, Handler> handlers =\n+                        initializeNettyHandlers(tm, dm, pm, sm, subChannelMgr);\n                     // Initialize Netty for the regular non-SSL channels\n-                    initializeNetty(null, handlers);\n+                    initializeNetty(null, handlers, subChannelMgr);\n                     if (conf.isSSLEnabled()) {\n-                        initializeNetty(new SslServerContextFactory(conf), handlers);\n+                        initializeNetty(new SslServerContextFactory(conf),\n+                                        handlers, subChannelMgr);\n                     }\n                     // register jmx\n-                    registerJMX(handlers);\n+                    registerJMX(subChannelMgr);\n                 } catch (Exception e) {\n                     ConcurrencyUtils.put(queue, Either.right(e));\n                     return;"},{"sha":"65acc81787c889ab35691043ff75fc6319802e61","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -48,17 +48,18 @@\n public class UmbrellaHandler extends SimpleChannelHandler {\n     static Logger logger = LoggerFactory.getLogger(UmbrellaHandler.class);\n \n-    private Map<OperationType, Handler> handlers;\n-    private ChannelGroup allChannels;\n-    private ChannelDisconnectListener subscribeHandler;\n-    private boolean isSSLEnabled = false;\n+    private final Map<OperationType, Handler> handlers;\n+    private final ChannelGroup allChannels;\n+    private final ChannelDisconnectListener channelDisconnectListener;\n+    private final boolean isSSLEnabled; \n \n     public UmbrellaHandler(ChannelGroup allChannels, Map<OperationType, Handler> handlers,\n+                           ChannelDisconnectListener channelDisconnectListener,\n                            boolean isSSLEnabled) {\n         this.allChannels = allChannels;\n         this.isSSLEnabled = isSSLEnabled;\n         this.handlers = handlers;\n-        subscribeHandler = (ChannelDisconnectListener) handlers.get(OperationType.SUBSCRIBE);\n+        this.channelDisconnectListener = channelDisconnectListener;\n     }\n \n     @Override\n@@ -116,7 +117,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n         Channel channel = ctx.getChannel();\n         // subscribe handler needs to know about channel disconnects\n-        subscribeHandler.channelDisconnected(channel);\n+        channelDisconnectListener.channelDisconnected(channel);\n         channel.close();\n     }\n "},{"sha":"35f8b6433ff6b4b89f5c03d93642ed938e7fe0a8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -39,6 +39,7 @@\n import org.apache.hedwig.client.HedwigClient;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n import org.apache.hedwig.server.common.TerminateJVMExceptionHandler;\n+import org.apache.hedwig.server.handlers.ChannelDisconnectListener;\n import org.apache.hedwig.server.handlers.Handler;\n import org.apache.hedwig.server.netty.PubSubServer;\n import org.apache.hedwig.server.netty.PubSubServerPipelineFactory;\n@@ -112,7 +113,10 @@ protected void initializeNetty() {\n         InternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n         allChannels = new DefaultChannelGroup(\"hedwigproxy\");\n         ServerBootstrap bootstrap = new ServerBootstrap(serverSocketChannelFactory);\n-        UmbrellaHandler umbrellaHandler = new UmbrellaHandler(allChannels, handlers, false);\n+        ChannelDisconnectListener disconnectListener =\n+            (ChannelDisconnectListener) handlers.get(OperationType.SUBSCRIBE);\n+        UmbrellaHandler umbrellaHandler =\n+            new UmbrellaHandler(allChannels, handlers, disconnectListener, false);\n         PubSubServerPipelineFactory pipeline = new PubSubServerPipelineFactory(umbrellaHandler, null, cfg\n                 .getMaximumMessageSize());\n "},{"sha":"7b0caef9553ef5f5ba4d2f5521050316c8dad718","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/81aa20165c13aab333f9f0fd6b4e948de2ba1cef/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java?ref=81aa20165c13aab333f9f0fd6b4e948de2ba1cef","patch":"@@ -56,6 +56,7 @@\n     SubscribeHandler sh;\n     StubDeliveryManager dm;\n     StubSubscriptionManager sm;\n+    SubscriptionChannelManager subChannelMgr;\n     ByteString topic = ByteString.copyFromUtf8(\"topic\");\n     WriteRecordingChannel channel;\n \n@@ -75,7 +76,8 @@ protected void setUp() throws Exception {\n         dm = new StubDeliveryManager();\n         PersistenceManager pm = LocalDBPersistenceManager.instance();\n         sm = new StubSubscriptionManager(tm, pm, dm, conf, executor);\n-        sh = new SubscribeHandler(tm, dm, pm, sm, conf);\n+        subChannelMgr = new SubscriptionChannelManager();\n+        sh = new SubscribeHandler(conf, tm, dm, pm, sm, subChannelMgr);\n         channel = new WriteRecordingChannel();\n \n         subscriberId = ByteString.copyFromUtf8(\"subId\");\n@@ -105,8 +107,10 @@ public void testSuccessCase() {\n         assertEquals(StatusCode.SUCCESS, ((PubSubResponse) channel.getMessagesWritten().get(0)).getStatusCode());\n \n         // make sure the channel was put in the maps\n-        assertEquals(new TopicSubscriber(topic, subscriberId), sh.channel2sub.get(channel));\n-        assertEquals(channel, sh.sub2Channel.get(new TopicSubscriber(topic, subscriberId)));\n+        assertEquals(new TopicSubscriber(topic, subscriberId),\n+                     subChannelMgr.channel2sub.get(channel));\n+        assertEquals(channel,\n+                     subChannelMgr.sub2Channel.get(new TopicSubscriber(topic, subscriberId)));\n \n         // make sure delivery was started\n         StartServingRequest startRequest = (StartServingRequest) dm.lastRequest.poll();\n@@ -134,7 +138,7 @@ public void testSuccessCase() {\n         assertEquals(StatusCode.TOPIC_BUSY, ((PubSubResponse) dupChannel.getMessagesWritten().get(0)).getStatusCode());\n \n         // after disconnecting the channel, subscribe should work again\n-        sh.channelDisconnected(channel);\n+        subChannelMgr.channelDisconnected(channel);\n \n         dupChannel = new WriteRecordingChannel();\n         sh.handleRequestAtOwner(pubSubRequestPrototype, dupChannel);"}]}

