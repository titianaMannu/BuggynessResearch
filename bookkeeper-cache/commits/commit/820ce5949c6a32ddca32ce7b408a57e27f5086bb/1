{"sha":"820ce5949c6a32ddca32ce7b408a57e27f5086bb","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MjBjZTU5NDljNmEzMmRkY2EzMmNlN2I0MDhhNTdlMjdmNTA4NmJi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-14T16:16:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-14T16:16:17Z"},"message":"BOOKKEEPER-252: Hedwig: provide a subscription mode to kill other subscription channel when hedwig client is used as a proxy-style server. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1384836 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"06107c92c60873caf9fb179421ca37e2272e1262","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/06107c92c60873caf9fb179421ca37e2272e1262"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/820ce5949c6a32ddca32ce7b408a57e27f5086bb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/820ce5949c6a32ddca32ce7b408a57e27f5086bb","html_url":"https://github.com/apache/bookkeeper/commit/820ce5949c6a32ddca32ce7b408a57e27f5086bb","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/820ce5949c6a32ddca32ce7b408a57e27f5086bb/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"ec977dbe1e7bfb56dc93b6ba72d11f0468345668","url":"https://api.github.com/repos/apache/bookkeeper/commits/ec977dbe1e7bfb56dc93b6ba72d11f0468345668","html_url":"https://github.com/apache/bookkeeper/commit/ec977dbe1e7bfb56dc93b6ba72d11f0468345668"}],"stats":{"total":1211,"additions":1039,"deletions":172},"files":[{"sha":"52fe0b4e126c7531c7d221317296f94e90fa7701","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -158,6 +158,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-333: server-side message filter (sijie via ivank)\n \n+        BOOKKEEPER-252: Hedwig: provide a subscription mode to kill other subscription channel when hedwig client is used as a proxy-style server. (sijie via ivank)\n+\n       hedwig-client:\n \n         BOOKKEEPER-306: Change C++ client to use gtest for testing (ivank via sijie)"},{"sha":"80e961b077d373a13d31c8acda00f5aa694e8cfb","filename":"hedwig-client/src/main/cpp/inc/hedwig/callback.h","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/inc/hedwig/callback.h","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/inc/hedwig/callback.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/callback.h?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -30,6 +30,18 @@\n \n namespace Hedwig {\n \n+  //\n+  // A Listener registered for a Subscriber instance to emit events\n+  // for those disable resubscribe subscriptions.\n+  //\n+  class SubscriptionListener {\n+  public:\n+    virtual void processEvent(const std::string &topic, const std::string &subscriberId,\n+                              const Hedwig::SubscriptionEvent event) = 0;\n+    virtual ~SubscriptionListener() {};\n+  };\n+  typedef std::tr1::shared_ptr<SubscriptionListener> SubscriptionListenerPtr;\n+\n   template<class R>\n   class Callback {\n   public:"},{"sha":"92e25928365931e873ac0f64ed5497034ed11a47","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"modified","additions":9,"deletions":1,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -36,7 +36,7 @@ namespace Hedwig {\n     virtual void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback) = 0;\n     virtual void subscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options) = 0;\n     virtual void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options, const OperationCallbackPtr& callback) = 0;\n-    \n+\n     virtual void unsubscribe(const std::string& topic, const std::string& subscriberId) = 0;\n     virtual void asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback) = 0;  \n \n@@ -53,6 +53,14 @@ namespace Hedwig {\n \n     virtual void closeSubscription(const std::string& topic, const std::string& subscriberId) = 0;\n \n+    //\n+    // API to register/unregister subscription listeners for receiving\n+    // events indicating subscription changes for those disable resubscribe\n+    // subscriptions\n+    //\n+    virtual void addSubscriptionListener(SubscriptionListenerPtr& listener) = 0;\n+    virtual void removeSubscriptionListener(SubscriptionListenerPtr& listener) = 0;\n+\n     virtual ~Subscriber() {}\n   };\n };"},{"sha":"b44c13fdbc443e85d1799349c88554059f828761","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -134,6 +134,7 @@ const PubSubRequestPtr PubSubData::getRequest() {\n     Hedwig::SubscribeRequest* subreq = request->mutable_subscriberequest();\n     subreq->set_subscriberid(subscriberid);\n     subreq->set_createorattach(options.createorattach());\n+    subreq->set_forceattach(options.forceattach());\n     setPreferencesForSubRequest(subreq, options);\n   } else if (type == CONSUME) {\n     LOG4CXX_DEBUG(logger, \"Creating consume request\");"},{"sha":"835f8853b45698a283932392e20fb74bb36c128e","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":78,"deletions":14,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -147,7 +147,8 @@ void SubscriberReconnectCallback::operationFailed(const std::exception& exceptio\n }\n \n SubscriberClientChannelHandler::SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber, const PubSubDataPtr& data)\n-  : HedwigClientChannelHandler(client), subscriber(subscriber), origData(data), closed(false), should_wait(true)  {\n+  : HedwigClientChannelHandler(client), subscriber(subscriber), origData(data), closed(false),\n+    should_wait(true), disconnected(false) {\n   LOG4CXX_DEBUG(logger, \"Creating SubscriberClientChannelHandler \" << this);\n }\n \n@@ -178,7 +179,7 @@ void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& cha\n void SubscriberClientChannelHandler::close() {\n   closed = true;\n \n-  if (channel) {\n+  if (channel.get()) {\n     channel->kill();\n   }\n }\n@@ -190,7 +191,7 @@ void SubscriberClientChannelHandler::close() {\n     return;\n   }\n   handler->should_wait = false;\n-  handler->channelDisconnected(channel, e);\n+  handler->reconnect(channel, e);\n }\n \n void SubscriberClientChannelHandler::channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e) {\n@@ -205,12 +206,40 @@ void SubscriberClientChannelHandler::channelDisconnected(const DuplexChannelPtr&\n     return;\n   }\n \n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(disconnected_lock);\n+    // some one is reconnecting return\n+    if (disconnected) {\n+      return;\n+    }\n+    disconnected = true;\n+  }\n+\n+  // if we have registered the subscription channel listener, disable retry\n+  // just trigger listener to let application handle channel disconnected event\n+  if (!origData->getSubscriptionOptions().enableresubscribe()) {\n+    LOG4CXX_INFO(logger, \"Tell subscriber (topic:\" << origData->getTopic()\n+                         << \", subscriberId:\" << origData->getSubscriberId()\n+                         << \") his topic has been moved : channel \"\n+                         << channel.get() << \" is disconnected\");\n+    // remove record of the failed channel from the subscriber\n+    client->getSubscriberImpl().closeSubscription(origData->getTopic(), origData->getSubscriberId());\n+    // emit the event to notify the client that topic has been moved\n+    client->getSubscriberImpl().emitSubscriptionEvent(\n+      origData->getTopic(), origData->getSubscriberId(), TOPIC_MOVED);\n+  } else {\n+    reconnect(channel, e);\n+  }\n+}\n+\n+void SubscriberClientChannelHandler::reconnect(const DuplexChannelPtr& channel, const std::exception& e) {\n   if (should_wait) {\n     int retrywait = client->getConfiguration().getInt(Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME,\n \t\t\t\t\t\t      DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME);\n     \n-    boost::asio::deadline_timer t(channel->getService(), boost::posix_time::milliseconds(retrywait));\n-    t.async_wait(boost::bind(&SubscriberClientChannelHandler::reconnectTimerComplete, shared_from_this(), \n+    // set reconnect timer\n+    reconnectTimer = ReconnectTimerPtr(new boost::asio::deadline_timer(channel->getService(), boost::posix_time::milliseconds(retrywait)));\n+    reconnectTimer->async_wait(boost::bind(&SubscriberClientChannelHandler::reconnectTimerComplete, shared_from_this(),\n \t\t\t     channel, e, boost::asio::placeholders::error));  \n     return;\n   }\n@@ -387,9 +416,12 @@ void SubscriberImpl::doUnsubscribe(const DuplexChannelPtr& channel, const PubSub\n \n void SubscriberImpl::consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId) {\n   TopicSubscriber t(topic, subscriberId);\n-  \n-  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-  SubscriberClientChannelHandlerPtr handler = topicsubscriber2handler[t];\n+\n+  SubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    handler = topicsubscriber2handler[t];\n+  }\n \n   if (handler.get() == 0) {\n     LOG4CXX_ERROR(logger, \"Cannot consume. Bad handler for topic(\" << topic << \") subscriberId(\" << subscriberId << \") topicsubscriber2topic(\" << &topicsubscriber2handler << \")\");\n@@ -399,6 +431,7 @@ void SubscriberImpl::consume(const std::string& topic, const std::string& subscr\n   DuplexChannelPtr channel = handler->getChannel();\n   if (channel.get() == 0) {\n     LOG4CXX_ERROR(logger, \"Trying to consume a message on a topic/subscriber pair that don't have a channel. Something fishy going on. Topic: \" << topic << \" SubscriberId: \" << subscriberId << \" MessageSeqId: \" << messageSeqId.localcomponent());\n+    return;\n   }\n   \n   PubSubDataPtr data = PubSubData::forConsumeRequest(client->counter().next(), subscriberId, topic, messageSeqId);  \n@@ -430,23 +463,31 @@ void SubscriberImpl::startDelivery(const std::string& topic, const std::string&\n                                    const MessageHandlerCallbackPtr& callback) {\n   TopicSubscriber t(topic, subscriberId);\n \n-  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-  SubscriberClientChannelHandlerPtr handler = topicsubscriber2handler[t];\n+  SubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    handler = topicsubscriber2handler[t];\n+  }\n \n   if (handler.get() == 0) {\n     LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+    throw NotSubscribedException();\n   }\n   handler->startDelivery(callback);\n }\n \n void SubscriberImpl::stopDelivery(const std::string& topic, const std::string& subscriberId) {\n   TopicSubscriber t(topic, subscriberId);\n-  \n-  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-  SubscriberClientChannelHandlerPtr handler = topicsubscriber2handler[t];\n+\n+  SubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    handler = topicsubscriber2handler[t];\n+  }\n \n   if (handler.get() == 0) {\n-    LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+    LOG4CXX_ERROR(logger, \"Trying to stop deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+    throw NotSubscribedException();\n   }\n   handler->stopDelivery();\n }\n@@ -484,6 +525,29 @@ const SubscriptionPreferencesPtr& SubscriberImpl::getSubscriptionPreferences(\n   return preferences;\n }\n \n+void SubscriberImpl::addSubscriptionListener(SubscriptionListenerPtr& listener) {\n+  boost::lock_guard<boost::shared_mutex> lock(listeners_lock);\n+  listeners.insert(listener);\n+}\n+\n+void SubscriberImpl::removeSubscriptionListener(SubscriptionListenerPtr& listener) {\n+  boost::lock_guard<boost::shared_mutex> lock(listeners_lock);\n+  listeners.erase(listener);\n+}\n+\n+void SubscriberImpl::emitSubscriptionEvent(const std::string& topic,\n+                                           const std::string& subscriberId,\n+                                           const SubscriptionEvent event) {\n+  boost::shared_lock<boost::shared_mutex> lock(listeners_lock);\n+  if (0 == listeners.size()) {\n+    return;\n+  }\n+  for (SubscriptionListenerSet::iterator iter = listeners.begin();\n+       iter != listeners.end(); ++iter) {\n+    (*iter)->processEvent(topic, subscriberId, event);\n+  }\n+}\n+\n /**\n    takes ownership of txn\n */"},{"sha":"5f2ecd555f0c90ed192b93db250c890637821e50","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -121,6 +121,8 @@ namespace Hedwig {\n     void setChannel(const DuplexChannelPtr& channel);\n     DuplexChannelPtr& getChannel();\n \n+    void reconnect(const DuplexChannelPtr& channel, const std::exception& e);\n+\n     static void reconnectTimerComplete(const SubscriberClientChannelHandlerPtr handler, const DuplexChannelPtr channel, const std::exception e, \n \t\t\t\t       const boost::system::error_code& error);\n \n@@ -135,7 +137,18 @@ namespace Hedwig {\n     PubSubDataPtr origData;\n     DuplexChannelPtr channel;\n     bool closed;\n+\n+    boost::shared_mutex disconnected_lock;\n     bool should_wait;\n+    bool disconnected;\n+    typedef boost::shared_ptr<boost::asio::deadline_timer> ReconnectTimerPtr;\n+    ReconnectTimerPtr reconnectTimer;\n+  };\n+\n+  struct SubscriptionListenerPtrHash : public std::unary_function<SubscriptionListenerPtr, size_t> {\n+    size_t operator()(const Hedwig::SubscriptionListenerPtr& listener) const {\n+      return reinterpret_cast<size_t>(listener.get());\n+    }\n   };\n \n   class SubscriberImpl : public Subscriber {\n@@ -167,6 +180,12 @@ namespace Hedwig {\n     void doSubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data, const SubscriberClientChannelHandlerPtr& handler);\n     void doUnsubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data);\n \n+    virtual void addSubscriptionListener(SubscriptionListenerPtr& listener);\n+    virtual void removeSubscriptionListener(SubscriptionListenerPtr& listener);\n+    void emitSubscriptionEvent(const std::string& topic,\n+                               const std::string& subscriberId,\n+                               const SubscriptionEvent event);\n+\n   private:\n     void setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n                                     const SubscriptionPreferences& preferences);\n@@ -180,6 +199,10 @@ namespace Hedwig {\n     boost::shared_mutex topicsubscriber2handler_lock;\t    \n     std::tr1::unordered_map<TopicSubscriber, SubscriptionPreferencesPtr, TopicSubscriberHash> topicsubscriber2preferences;\n     boost::shared_mutex topicsubscriber2preferences_lock;\t    \n+\n+    typedef std::tr1::unordered_set<SubscriptionListenerPtr, SubscriptionListenerPtrHash> SubscriptionListenerSet;\n+    SubscriptionListenerSet listeners;\n+    boost::shared_mutex listeners_lock;\n   };\n \n };"},{"sha":"34bab4e6e0ea2d57859ae2d9b2bd914ec07b0c09","filename":"hedwig-client/src/main/cpp/test/subscribetest.cpp","status":"modified","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/test/subscribetest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/test/subscribetest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/subscribetest.cpp?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -164,3 +164,54 @@ TEST(SubscribeTest, testSubscribeTwice) {\n   ASSERT_THROW(sub.subscribe(\"testTopic\", \"mySubscriberId-8\", Hedwig::SubscribeRequest::CREATE_OR_ATTACH), Hedwig::AlreadySubscribedException);\n }\n \n+TEST(SubscribeTest, testAsyncSubcribeForceAttach) {\n+  Hedwig::Configuration* conf = new TestServerConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  // client 1\n+  Hedwig::Client* client1 = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> client1ptr(client1);\n+  Hedwig::Subscriber& sub1 = client1->getSubscriber();\n+  // client 2\n+  Hedwig::Client* client2 = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> client2ptr(client2);\n+  Hedwig::Subscriber& sub2 = client2->getSubscriber();\n+\n+  SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond1ptr(cond1);\n+  Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+\n+  SimpleWaitCondition* lcond1 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> lcond1ptr(lcond1);\n+  Hedwig::SubscriptionListenerPtr listener1(new TestSubscriptionListener(lcond1));\n+\n+  Hedwig::SubscriptionOptions options;\n+  options.set_createorattach(Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  options.set_forceattach(true);\n+  options.set_enableresubscribe(false);\n+\n+  sub1.addSubscriptionListener(listener1);\n+\n+  sub1.asyncSubscribe(\"asyncSubscribeForceAttach\", \"mysub\",\n+                      options, testcb1);\n+  cond1->wait();\n+  ASSERT_TRUE(cond1->wasSuccess());\n+\n+  // sub2 subscribe would force close the channel of sub1\n+  SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+  std::auto_ptr<SimpleWaitCondition> cond2ptr(cond2);\n+  Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n+\n+  Hedwig::SubscriptionListenerPtr listener2(new TestSubscriptionListener(0));\n+\n+  sub2.addSubscriptionListener(listener2);\n+\n+  sub2.asyncSubscribe(\"asyncSubscribeForceAttach\", \"mysub\",\n+                      options, testcb2);\n+  cond2->wait();\n+  ASSERT_TRUE(cond2->wasSuccess());\n+\n+  // sub1 would receive the disconnect event\n+  lcond1->wait();\n+\n+  sub1.unsubscribe(\"asyncSubscribeForceAttach\", \"mysub\");\n+}"},{"sha":"b40d7e8323d9febf7edb5a68e4df4376f20ffbe5","filename":"hedwig-client/src/main/cpp/test/util.h","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -113,6 +113,26 @@ class TestCallback : public Hedwig::OperationCallback {\n   SimpleWaitCondition *cond;\n };\n \n+class TestSubscriptionListener : public Hedwig::SubscriptionListener {\n+public:\n+  TestSubscriptionListener(SimpleWaitCondition* cond) : cond(cond) {\n+  }\n+\n+  virtual ~TestSubscriptionListener() {}\n+\n+  virtual void processEvent(const std::string& topic, const std::string& subscriberId,\n+                            const Hedwig::SubscriptionEvent event) {\n+    if (Hedwig::TOPIC_MOVED == event) {\n+      if (cond) {\n+        cond->setSuccess(true);\n+        cond->notify();\n+      }\n+    }\n+  }\n+\n+private:\n+  SimpleWaitCondition *cond;\n+};\n \n class TestServerConfiguration : public Hedwig::Configuration {\n public:"},{"sha":"7756c3757ac0b47193c34882a4f09a4e6ea636ee","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -31,6 +31,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.SubscriptionListener;\n \n /**\n  * Interface to define the client Subscriber API.\n@@ -349,4 +350,21 @@ public void startDeliveryWithFilter(ByteString topic, ByteString subscriberId,\n     public void asyncCloseSubscription(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n                                        Object context);\n \n+    /**\n+     * Register a subscription listener which get notified about subscription\n+     * event indicating a state of a subscription that subscribed disable\n+     * resubscribe logic.\n+     *\n+     * @param listener\n+     *          Subscription Listener\n+     */\n+    public void addSubscriptionListener(SubscriptionListener listener);\n+\n+    /**\n+     * Unregister a subscription listener.\n+     *\n+     * @param listener\n+     *          Subscription Listener\n+     */\n+    public void removeSubscriptionListener(SubscriptionListener listener);\n }"},{"sha":"39d9a867485654b585261c9b9adda3a84ff472cb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"modified","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -54,6 +54,10 @@\n \n     private static final Logger logger = LoggerFactory.getLogger(HedwigClientImpl.class);\n \n+    // Empty Topic List\n+    private ConcurrentLinkedQueue<ByteString> EMPTY_TOPIC_LIST =\n+        new ConcurrentLinkedQueue<ByteString>();\n+\n     // Global counter used for generating unique transaction ID's for\n     // publish and subscribe requests\n     protected final AtomicLong globalCounter = new AtomicLong();\n@@ -373,6 +377,31 @@ public void clearAllTopicsForHost(InetSocketAddress host) {\n         }\n     }\n \n+    // If a subscribe channel goes down, the topic might have moved.\n+    // We only clear out that topic for the host and not all cached information.\n+    public void clearHostForTopic(ByteString topic, InetSocketAddress host) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Clearing topic: \" + topic.toStringUtf8() + \" for host: \"\n+                    + host);\n+        }\n+        if (topic2Host.remove(topic, host)) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Removed topic to host mapping for topic: \" + topic.toStringUtf8()\n+                           + \" and host: \" + host);\n+            }\n+        }\n+        ConcurrentLinkedQueue<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null != topicsForHost && topicsForHost.remove(topic)) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Removed topic: \" + topic.toStringUtf8() + \" from host: \" + host);\n+            }\n+            if (topicsForHost.isEmpty()) {\n+                // remove only topic list is empty\n+                host2Topics.remove(host, EMPTY_TOPIC_LIST);\n+            }\n+        }\n+    }\n+\n     // Public getter to see if the client has been stopped.\n     public boolean hasStopped() {\n         return isStopped;"},{"sha":"81af1dd83a5e663bb430323bbb3dd5f8951b8150","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -18,9 +18,12 @@\n package org.apache.hedwig.client.netty;\n \n import java.net.InetSocketAddress;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n \n import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n import org.apache.hedwig.protocol.PubSubProtocol;\n@@ -54,11 +57,13 @@\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.SubscriptionListener;\n \n /**\n  * This is the Hedwig Netty specific implementation of the Subscriber interface.\n@@ -82,6 +87,8 @@\n     // user set when connection is recovered\n     protected final ConcurrentMap<TopicSubscriber, MessageHandler> topicSubscriber2MessageHandler= new ConcurrentHashMap<TopicSubscriber, MessageHandler>();\n \n+    protected final CopyOnWriteArraySet<SubscriptionListener> listeners;\n+\n     protected final HedwigClientImpl client;\n     protected final ClientConfiguration cfg;\n     private final Object closeLock = new Object();\n@@ -90,6 +97,22 @@\n     public HedwigSubscriber(HedwigClientImpl client) {\n         this.client = client;\n         this.cfg = client.getConfiguration();\n+        this.listeners = new CopyOnWriteArraySet<SubscriptionListener>();\n+    }\n+\n+    public void addSubscriptionListener(SubscriptionListener listener) {\n+        listeners.add(listener); \n+    }\n+\n+    public void removeSubscriptionListener(SubscriptionListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    void emitSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                               SubscriptionEvent event) {\n+        for (SubscriptionListener listener : listeners) {\n+            listener.processEvent(topic, subscriberId, event);\n+        }\n     }\n \n     // Private method that holds the common logic for doing synchronous\n@@ -424,6 +447,7 @@ protected void doSubUnsub(PubSubData pubSubData, Channel channel) {\n             SubscribeRequest.Builder subscribeRequestBuilder = SubscribeRequest.newBuilder();\n             subscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n             subscribeRequestBuilder.setCreateOrAttach(pubSubData.options.getCreateOrAttach());\n+            subscribeRequestBuilder.setForceAttach(pubSubData.options.getForceAttach());\n             // For now, all subscribes should wait for all cross-regional\n             // subscriptions to be established before returning.\n             subscribeRequestBuilder.setSynchronous(true);"},{"sha":"127cfb81454f7bed8d26eadb3b5482457720dde3","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","status":"modified","additions":23,"deletions":9,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -47,7 +47,9 @@\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.hedwig.util.SubscriptionListener;\n \n @ChannelPipelineCoverage(\"all\")\n public class ResponseHandler extends SimpleChannelHandler {\n@@ -301,22 +303,34 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n             // Subscribe channel disconnected so first close and clear all\n             // cached Channel data set up for this topic subscription.\n             sub.closeSubscription(origSubData.topic, origSubData.subscriberId);\n-            client.clearAllTopicsForHost(host);\n+            // a subscription channel disconnecteda because topic has moved.\n+            // just clear the entry for the given topic\n+            client.clearHostForTopic(origSubData.topic, host);\n             // Since the connection to the server host that was responsible\n             // for the topic died, we are not sure about the state of that\n             // server. Resend the original subscribe request data to the default\n             // server host/VIP. Also clear out all of the servers we've\n             // contacted or attempted to from this request as we are starting a\n             // \"fresh\" subscribe request.\n             origSubData.clearServersList();\n-            // Set a new type of VoidCallback for this async call. We need this\n-            // hook so after the subscribe reconnect has completed, delivery for\n-            // that topic subscriber should also be restarted (if it was that\n-            // case before the channel disconnect).\n-            origSubData.setCallback(new SubscribeReconnectCallback(origSubData, client));\n-            origSubData.context = null;\n-            logger.debug(\"Disconnected subscribe channel so reconnect with origSubData: {}\", origSubData);\n-            client.doConnect(origSubData, cfg.getDefaultServerHost());\n+            // do resubscribe if the subscription enables it\n+            if (origSubData.options.getEnableResubscribe()) {\n+                // Set a new type of VoidCallback for this async call. We need this\n+                // hook so after the subscribe reconnect has completed, delivery for\n+                // that topic subscriber should also be restarted (if it was that\n+                // case before the channel disconnect).\n+                origSubData.setCallback(new SubscribeReconnectCallback(origSubData, client));\n+                origSubData.context = null;\n+                // Clear the shouldClaim flag\n+                origSubData.shouldClaim = false;\n+                logger.debug(\"Disconnected subscribe channel so reconnect with origSubData: {}\", origSubData);\n+                client.doConnect(origSubData, cfg.getDefaultServerHost());\n+            } else {\n+                logger.info(\"Subscription channel for (topic:{}, subscriber:{}) is disconnected.\",\n+                            origSubData.topic.toStringUtf8(), origSubData.subscriberId.toStringUtf8());\n+                sub.emitSubscriptionEvent(origSubData.topic, origSubData.subscriberId,\n+                                          SubscriptionEvent.TOPIC_MOVED);\n+            }\n         }\n \n         // Finally, all of the PubSubRequests that are still waiting for an ack"},{"sha":"508519665fe147db074b3302c6cf45a018aa79e0","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+\n+/**\n+ * This class is used for subscriber to listen on subscription event.\n+ */\n+public interface SubscriptionListener {\n+\n+    /**\n+     * Process an event from a subscription.\n+     * <p>\n+     * NOTE: It would be better to not run blocking operations in a\n+     *       listener implementation.\n+     * </p>\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param event\n+     *          Event tell what happened to the subscription.\n+     */\n+    public void processEvent(ByteString topic, ByteString subscriberId,\n+                             SubscriptionEvent event);\n+}"},{"sha":"3dcc2b4e36afafde1ac1018ce696327d6067678f","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":341,"deletions":97,"changes":438,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -155,6 +155,75 @@ private OperationType(int index, int value) {\n     // @@protoc_insertion_point(enum_scope:Hedwig.OperationType)\n   }\n   \n+  public enum SubscriptionEvent\n+      implements com.google.protobuf.ProtocolMessageEnum {\n+    TOPIC_MOVED(0, 1),\n+    SUBSCRIPTION_FORCED_CLOSED(1, 2),\n+    ;\n+    \n+    public static final int TOPIC_MOVED_VALUE = 1;\n+    public static final int SUBSCRIPTION_FORCED_CLOSED_VALUE = 2;\n+    \n+    \n+    public final int getNumber() { return value; }\n+    \n+    public static SubscriptionEvent valueOf(int value) {\n+      switch (value) {\n+        case 1: return TOPIC_MOVED;\n+        case 2: return SUBSCRIPTION_FORCED_CLOSED;\n+        default: return null;\n+      }\n+    }\n+    \n+    public static com.google.protobuf.Internal.EnumLiteMap<SubscriptionEvent>\n+        internalGetValueMap() {\n+      return internalValueMap;\n+    }\n+    private static com.google.protobuf.Internal.EnumLiteMap<SubscriptionEvent>\n+        internalValueMap =\n+          new com.google.protobuf.Internal.EnumLiteMap<SubscriptionEvent>() {\n+            public SubscriptionEvent findValueByNumber(int number) {\n+              return SubscriptionEvent.valueOf(number);\n+            }\n+          };\n+    \n+    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+        getValueDescriptor() {\n+      return getDescriptor().getValues().get(index);\n+    }\n+    public final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptorForType() {\n+      return getDescriptor();\n+    }\n+    public static final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.getDescriptor().getEnumTypes().get(2);\n+    }\n+    \n+    private static final SubscriptionEvent[] VALUES = {\n+      TOPIC_MOVED, SUBSCRIPTION_FORCED_CLOSED, \n+    };\n+    \n+    public static SubscriptionEvent valueOf(\n+        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+      if (desc.getType() != getDescriptor()) {\n+        throw new java.lang.IllegalArgumentException(\n+          \"EnumValueDescriptor is not for this type.\");\n+      }\n+      return VALUES[desc.getIndex()];\n+    }\n+    \n+    private final int index;\n+    private final int value;\n+    \n+    private SubscriptionEvent(int index, int value) {\n+      this.index = index;\n+      this.value = value;\n+    }\n+    \n+    // @@protoc_insertion_point(enum_scope:Hedwig.SubscriptionEvent)\n+  }\n+  \n   public enum StatusCode\n       implements com.google.protobuf.ProtocolMessageEnum {\n     SUCCESS(0, 0),\n@@ -251,7 +320,7 @@ public StatusCode findValueByNumber(int number) {\n     }\n     public static final com.google.protobuf.Descriptors.EnumDescriptor\n         getDescriptor() {\n-      return org.apache.hedwig.protocol.PubSubProtocol.getDescriptor().getEnumTypes().get(2);\n+      return org.apache.hedwig.protocol.PubSubProtocol.getDescriptor().getEnumTypes().get(3);\n     }\n     \n     private static final StatusCode[] VALUES = {\n@@ -6218,6 +6287,10 @@ void setMessageFilter(com.google.protobuf.ByteString value) {\n     boolean hasPreferences();\n     org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences getPreferences();\n     org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferencesOrBuilder getPreferencesOrBuilder();\n+    \n+    // optional bool forceAttach = 7 [default = false];\n+    boolean hasForceAttach();\n+    boolean getForceAttach();\n   }\n   public static final class SubscribeRequest extends\n       com.google.protobuf.GeneratedMessage\n@@ -6373,12 +6446,23 @@ public boolean hasPreferences() {\n       return preferences_;\n     }\n     \n+    // optional bool forceAttach = 7 [default = false];\n+    public static final int FORCEATTACH_FIELD_NUMBER = 7;\n+    private boolean forceAttach_;\n+    public boolean hasForceAttach() {\n+      return ((bitField0_ & 0x00000020) == 0x00000020);\n+    }\n+    public boolean getForceAttach() {\n+      return forceAttach_;\n+    }\n+    \n     private void initFields() {\n       subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n       createOrAttach_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH;\n       synchronous_ = false;\n       messageBound_ = 0;\n       preferences_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences.getDefaultInstance();\n+      forceAttach_ = false;\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -6411,6 +6495,9 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       if (((bitField0_ & 0x00000010) == 0x00000010)) {\n         output.writeMessage(6, preferences_);\n       }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        output.writeBool(7, forceAttach_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -6440,6 +6527,10 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeMessageSize(6, preferences_);\n       }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBoolSize(7, forceAttach_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -6579,6 +6670,8 @@ public Builder clear() {\n           preferencesBuilder_.clear();\n         }\n         bitField0_ = (bitField0_ & ~0x00000010);\n+        forceAttach_ = false;\n+        bitField0_ = (bitField0_ & ~0x00000020);\n         return this;\n       }\n       \n@@ -6641,6 +6734,10 @@ public Builder clone() {\n         } else {\n           result.preferences_ = preferencesBuilder_.build();\n         }\n+        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        result.forceAttach_ = forceAttach_;\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -6672,6 +6769,9 @@ public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequ\n         if (other.hasPreferences()) {\n           mergePreferences(other.getPreferences());\n         }\n+        if (other.hasForceAttach()) {\n+          setForceAttach(other.getForceAttach());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -6742,6 +6842,11 @@ public Builder mergeFrom(\n               setPreferences(subBuilder.buildPartial());\n               break;\n             }\n+            case 56: {\n+              bitField0_ |= 0x00000020;\n+              forceAttach_ = input.readBool();\n+              break;\n+            }\n           }\n         }\n       }\n@@ -6928,6 +7033,27 @@ public Builder clearPreferences() {\n         return preferencesBuilder_;\n       }\n       \n+      // optional bool forceAttach = 7 [default = false];\n+      private boolean forceAttach_ ;\n+      public boolean hasForceAttach() {\n+        return ((bitField0_ & 0x00000020) == 0x00000020);\n+      }\n+      public boolean getForceAttach() {\n+        return forceAttach_;\n+      }\n+      public Builder setForceAttach(boolean value) {\n+        bitField0_ |= 0x00000020;\n+        forceAttach_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearForceAttach() {\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        forceAttach_ = false;\n+        onChanged();\n+        return this;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:Hedwig.SubscribeRequest)\n     }\n     \n@@ -6942,6 +7068,10 @@ public Builder clearPreferences() {\n   public interface SubscriptionOptionsOrBuilder\n       extends com.google.protobuf.MessageOrBuilder {\n     \n+    // optional bool forceAttach = 1 [default = false];\n+    boolean hasForceAttach();\n+    boolean getForceAttach();\n+    \n     // optional .Hedwig.SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n     boolean hasCreateOrAttach();\n     org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach getCreateOrAttach();\n@@ -6958,6 +7088,10 @@ public Builder clearPreferences() {\n     // optional string messageFilter = 5;\n     boolean hasMessageFilter();\n     String getMessageFilter();\n+    \n+    // optional bool enableResubscribe = 7 [default = true];\n+    boolean hasEnableResubscribe();\n+    boolean getEnableResubscribe();\n   }\n   public static final class SubscriptionOptions extends\n       com.google.protobuf.GeneratedMessage\n@@ -6988,11 +7122,21 @@ public SubscriptionOptions getDefaultInstanceForType() {\n     }\n     \n     private int bitField0_;\n+    // optional bool forceAttach = 1 [default = false];\n+    public static final int FORCEATTACH_FIELD_NUMBER = 1;\n+    private boolean forceAttach_;\n+    public boolean hasForceAttach() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public boolean getForceAttach() {\n+      return forceAttach_;\n+    }\n+    \n     // optional .Hedwig.SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n     public static final int CREATEORATTACH_FIELD_NUMBER = 2;\n     private org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach createOrAttach_;\n     public boolean hasCreateOrAttach() {\n-      return ((bitField0_ & 0x00000001) == 0x00000001);\n+      return ((bitField0_ & 0x00000002) == 0x00000002);\n     }\n     public org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach getCreateOrAttach() {\n       return createOrAttach_;\n@@ -7002,7 +7146,7 @@ public boolean hasCreateOrAttach() {\n     public static final int MESSAGEBOUND_FIELD_NUMBER = 3;\n     private int messageBound_;\n     public boolean hasMessageBound() {\n-      return ((bitField0_ & 0x00000002) == 0x00000002);\n+      return ((bitField0_ & 0x00000004) == 0x00000004);\n     }\n     public int getMessageBound() {\n       return messageBound_;\n@@ -7012,7 +7156,7 @@ public int getMessageBound() {\n     public static final int OPTIONS_FIELD_NUMBER = 4;\n     private org.apache.hedwig.protocol.PubSubProtocol.Map options_;\n     public boolean hasOptions() {\n-      return ((bitField0_ & 0x00000004) == 0x00000004);\n+      return ((bitField0_ & 0x00000008) == 0x00000008);\n     }\n     public org.apache.hedwig.protocol.PubSubProtocol.Map getOptions() {\n       return options_;\n@@ -7025,7 +7169,7 @@ public boolean hasOptions() {\n     public static final int MESSAGEFILTER_FIELD_NUMBER = 5;\n     private java.lang.Object messageFilter_;\n     public boolean hasMessageFilter() {\n-      return ((bitField0_ & 0x00000008) == 0x00000008);\n+      return ((bitField0_ & 0x00000010) == 0x00000010);\n     }\n     public String getMessageFilter() {\n       java.lang.Object ref = messageFilter_;\n@@ -7053,11 +7197,23 @@ public String getMessageFilter() {\n       }\n     }\n     \n+    // optional bool enableResubscribe = 7 [default = true];\n+    public static final int ENABLERESUBSCRIBE_FIELD_NUMBER = 7;\n+    private boolean enableResubscribe_;\n+    public boolean hasEnableResubscribe() {\n+      return ((bitField0_ & 0x00000020) == 0x00000020);\n+    }\n+    public boolean getEnableResubscribe() {\n+      return enableResubscribe_;\n+    }\n+    \n     private void initFields() {\n+      forceAttach_ = false;\n       createOrAttach_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH;\n       messageBound_ = 0;\n       options_ = org.apache.hedwig.protocol.PubSubProtocol.Map.getDefaultInstance();\n       messageFilter_ = \"\";\n+      enableResubscribe_ = true;\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -7072,17 +7228,23 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n                         throws java.io.IOException {\n       getSerializedSize();\n       if (((bitField0_ & 0x00000001) == 0x00000001)) {\n-        output.writeEnum(2, createOrAttach_.getNumber());\n+        output.writeBool(1, forceAttach_);\n       }\n       if (((bitField0_ & 0x00000002) == 0x00000002)) {\n-        output.writeUInt32(3, messageBound_);\n+        output.writeEnum(2, createOrAttach_.getNumber());\n       }\n       if (((bitField0_ & 0x00000004) == 0x00000004)) {\n-        output.writeMessage(4, options_);\n+        output.writeUInt32(3, messageBound_);\n       }\n       if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        output.writeMessage(4, options_);\n+      }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n         output.writeBytes(5, getMessageFilterBytes());\n       }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        output.writeBool(7, enableResubscribe_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -7094,20 +7256,28 @@ public int getSerializedSize() {\n       size = 0;\n       if (((bitField0_ & 0x00000001) == 0x00000001)) {\n         size += com.google.protobuf.CodedOutputStream\n-          .computeEnumSize(2, createOrAttach_.getNumber());\n+          .computeBoolSize(1, forceAttach_);\n       }\n       if (((bitField0_ & 0x00000002) == 0x00000002)) {\n         size += com.google.protobuf.CodedOutputStream\n-          .computeUInt32Size(3, messageBound_);\n+          .computeEnumSize(2, createOrAttach_.getNumber());\n       }\n       if (((bitField0_ & 0x00000004) == 0x00000004)) {\n         size += com.google.protobuf.CodedOutputStream\n-          .computeMessageSize(4, options_);\n+          .computeUInt32Size(3, messageBound_);\n       }\n       if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(4, options_);\n+      }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n         size += com.google.protobuf.CodedOutputStream\n           .computeBytesSize(5, getMessageFilterBytes());\n       }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBoolSize(7, enableResubscribe_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -7233,18 +7403,22 @@ private static Builder create() {\n       \n       public Builder clear() {\n         super.clear();\n-        createOrAttach_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH;\n+        forceAttach_ = false;\n         bitField0_ = (bitField0_ & ~0x00000001);\n-        messageBound_ = 0;\n+        createOrAttach_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH;\n         bitField0_ = (bitField0_ & ~0x00000002);\n+        messageBound_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000004);\n         if (optionsBuilder_ == null) {\n           options_ = org.apache.hedwig.protocol.PubSubProtocol.Map.getDefaultInstance();\n         } else {\n           optionsBuilder_.clear();\n         }\n-        bitField0_ = (bitField0_ & ~0x00000004);\n-        messageFilter_ = \"\";\n         bitField0_ = (bitField0_ & ~0x00000008);\n+        messageFilter_ = \"\";\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        enableResubscribe_ = true;\n+        bitField0_ = (bitField0_ & ~0x00000020);\n         return this;\n       }\n       \n@@ -7286,23 +7460,31 @@ public Builder clone() {\n         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n           to_bitField0_ |= 0x00000001;\n         }\n-        result.createOrAttach_ = createOrAttach_;\n+        result.forceAttach_ = forceAttach_;\n         if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n           to_bitField0_ |= 0x00000002;\n         }\n-        result.messageBound_ = messageBound_;\n+        result.createOrAttach_ = createOrAttach_;\n         if (((from_bitField0_ & 0x00000004) == 0x00000004)) {\n           to_bitField0_ |= 0x00000004;\n         }\n+        result.messageBound_ = messageBound_;\n+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {\n+          to_bitField0_ |= 0x00000008;\n+        }\n         if (optionsBuilder_ == null) {\n           result.options_ = options_;\n         } else {\n           result.options_ = optionsBuilder_.build();\n         }\n-        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {\n-          to_bitField0_ |= 0x00000008;\n+        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {\n+          to_bitField0_ |= 0x00000010;\n         }\n         result.messageFilter_ = messageFilter_;\n+        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        result.enableResubscribe_ = enableResubscribe_;\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -7319,6 +7501,9 @@ public Builder mergeFrom(com.google.protobuf.Message other) {\n       \n       public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions other) {\n         if (other == org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions.getDefaultInstance()) return this;\n+        if (other.hasForceAttach()) {\n+          setForceAttach(other.getForceAttach());\n+        }\n         if (other.hasCreateOrAttach()) {\n           setCreateOrAttach(other.getCreateOrAttach());\n         }\n@@ -7331,6 +7516,9 @@ public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionO\n         if (other.hasMessageFilter()) {\n           setMessageFilter(other.getMessageFilter());\n         }\n+        if (other.hasEnableResubscribe()) {\n+          setEnableResubscribe(other.getEnableResubscribe());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -7362,19 +7550,24 @@ public Builder mergeFrom(\n               }\n               break;\n             }\n+            case 8: {\n+              bitField0_ |= 0x00000001;\n+              forceAttach_ = input.readBool();\n+              break;\n+            }\n             case 16: {\n               int rawValue = input.readEnum();\n               org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach value = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.valueOf(rawValue);\n               if (value == null) {\n                 unknownFields.mergeVarintField(2, rawValue);\n               } else {\n-                bitField0_ |= 0x00000001;\n+                bitField0_ |= 0x00000002;\n                 createOrAttach_ = value;\n               }\n               break;\n             }\n             case 24: {\n-              bitField0_ |= 0x00000002;\n+              bitField0_ |= 0x00000004;\n               messageBound_ = input.readUInt32();\n               break;\n             }\n@@ -7388,20 +7581,46 @@ public Builder mergeFrom(\n               break;\n             }\n             case 42: {\n-              bitField0_ |= 0x00000008;\n+              bitField0_ |= 0x00000010;\n               messageFilter_ = input.readBytes();\n               break;\n             }\n+            case 56: {\n+              bitField0_ |= 0x00000020;\n+              enableResubscribe_ = input.readBool();\n+              break;\n+            }\n           }\n         }\n       }\n       \n       private int bitField0_;\n       \n+      // optional bool forceAttach = 1 [default = false];\n+      private boolean forceAttach_ ;\n+      public boolean hasForceAttach() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public boolean getForceAttach() {\n+        return forceAttach_;\n+      }\n+      public Builder setForceAttach(boolean value) {\n+        bitField0_ |= 0x00000001;\n+        forceAttach_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearForceAttach() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        forceAttach_ = false;\n+        onChanged();\n+        return this;\n+      }\n+      \n       // optional .Hedwig.SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n       private org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach createOrAttach_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH;\n       public boolean hasCreateOrAttach() {\n-        return ((bitField0_ & 0x00000001) == 0x00000001);\n+        return ((bitField0_ & 0x00000002) == 0x00000002);\n       }\n       public org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach getCreateOrAttach() {\n         return createOrAttach_;\n@@ -7410,13 +7629,13 @@ public Builder setCreateOrAttach(org.apache.hedwig.protocol.PubSubProtocol.Subsc\n         if (value == null) {\n           throw new NullPointerException();\n         }\n-        bitField0_ |= 0x00000001;\n+        bitField0_ |= 0x00000002;\n         createOrAttach_ = value;\n         onChanged();\n         return this;\n       }\n       public Builder clearCreateOrAttach() {\n-        bitField0_ = (bitField0_ & ~0x00000001);\n+        bitField0_ = (bitField0_ & ~0x00000002);\n         createOrAttach_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH;\n         onChanged();\n         return this;\n@@ -7425,19 +7644,19 @@ public Builder clearCreateOrAttach() {\n       // optional uint32 messageBound = 3 [default = 0];\n       private int messageBound_ ;\n       public boolean hasMessageBound() {\n-        return ((bitField0_ & 0x00000002) == 0x00000002);\n+        return ((bitField0_ & 0x00000004) == 0x00000004);\n       }\n       public int getMessageBound() {\n         return messageBound_;\n       }\n       public Builder setMessageBound(int value) {\n-        bitField0_ |= 0x00000002;\n+        bitField0_ |= 0x00000004;\n         messageBound_ = value;\n         onChanged();\n         return this;\n       }\n       public Builder clearMessageBound() {\n-        bitField0_ = (bitField0_ & ~0x00000002);\n+        bitField0_ = (bitField0_ & ~0x00000004);\n         messageBound_ = 0;\n         onChanged();\n         return this;\n@@ -7448,7 +7667,7 @@ public Builder clearMessageBound() {\n       private com.google.protobuf.SingleFieldBuilder<\n           org.apache.hedwig.protocol.PubSubProtocol.Map, org.apache.hedwig.protocol.PubSubProtocol.Map.Builder, org.apache.hedwig.protocol.PubSubProtocol.MapOrBuilder> optionsBuilder_;\n       public boolean hasOptions() {\n-        return ((bitField0_ & 0x00000004) == 0x00000004);\n+        return ((bitField0_ & 0x00000008) == 0x00000008);\n       }\n       public org.apache.hedwig.protocol.PubSubProtocol.Map getOptions() {\n         if (optionsBuilder_ == null) {\n@@ -7467,7 +7686,7 @@ public Builder setOptions(org.apache.hedwig.protocol.PubSubProtocol.Map value) {\n         } else {\n           optionsBuilder_.setMessage(value);\n         }\n-        bitField0_ |= 0x00000004;\n+        bitField0_ |= 0x00000008;\n         return this;\n       }\n       public Builder setOptions(\n@@ -7478,12 +7697,12 @@ public Builder setOptions(\n         } else {\n           optionsBuilder_.setMessage(builderForValue.build());\n         }\n-        bitField0_ |= 0x00000004;\n+        bitField0_ |= 0x00000008;\n         return this;\n       }\n       public Builder mergeOptions(org.apache.hedwig.protocol.PubSubProtocol.Map value) {\n         if (optionsBuilder_ == null) {\n-          if (((bitField0_ & 0x00000004) == 0x00000004) &&\n+          if (((bitField0_ & 0x00000008) == 0x00000008) &&\n               options_ != org.apache.hedwig.protocol.PubSubProtocol.Map.getDefaultInstance()) {\n             options_ =\n               org.apache.hedwig.protocol.PubSubProtocol.Map.newBuilder(options_).mergeFrom(value).buildPartial();\n@@ -7494,7 +7713,7 @@ public Builder mergeOptions(org.apache.hedwig.protocol.PubSubProtocol.Map value)\n         } else {\n           optionsBuilder_.mergeFrom(value);\n         }\n-        bitField0_ |= 0x00000004;\n+        bitField0_ |= 0x00000008;\n         return this;\n       }\n       public Builder clearOptions() {\n@@ -7504,11 +7723,11 @@ public Builder clearOptions() {\n         } else {\n           optionsBuilder_.clear();\n         }\n-        bitField0_ = (bitField0_ & ~0x00000004);\n+        bitField0_ = (bitField0_ & ~0x00000008);\n         return this;\n       }\n       public org.apache.hedwig.protocol.PubSubProtocol.Map.Builder getOptionsBuilder() {\n-        bitField0_ |= 0x00000004;\n+        bitField0_ |= 0x00000008;\n         onChanged();\n         return getOptionsFieldBuilder().getBuilder();\n       }\n@@ -7536,7 +7755,7 @@ public Builder clearOptions() {\n       // optional string messageFilter = 5;\n       private java.lang.Object messageFilter_ = \"\";\n       public boolean hasMessageFilter() {\n-        return ((bitField0_ & 0x00000008) == 0x00000008);\n+        return ((bitField0_ & 0x00000010) == 0x00000010);\n       }\n       public String getMessageFilter() {\n         java.lang.Object ref = messageFilter_;\n@@ -7552,23 +7771,44 @@ public Builder setMessageFilter(String value) {\n         if (value == null) {\n     throw new NullPointerException();\n   }\n-  bitField0_ |= 0x00000008;\n+  bitField0_ |= 0x00000010;\n         messageFilter_ = value;\n         onChanged();\n         return this;\n       }\n       public Builder clearMessageFilter() {\n-        bitField0_ = (bitField0_ & ~0x00000008);\n+        bitField0_ = (bitField0_ & ~0x00000010);\n         messageFilter_ = getDefaultInstance().getMessageFilter();\n         onChanged();\n         return this;\n       }\n       void setMessageFilter(com.google.protobuf.ByteString value) {\n-        bitField0_ |= 0x00000008;\n+        bitField0_ |= 0x00000010;\n         messageFilter_ = value;\n         onChanged();\n       }\n       \n+      // optional bool enableResubscribe = 7 [default = true];\n+      private boolean enableResubscribe_ = true;\n+      public boolean hasEnableResubscribe() {\n+        return ((bitField0_ & 0x00000020) == 0x00000020);\n+      }\n+      public boolean getEnableResubscribe() {\n+        return enableResubscribe_;\n+      }\n+      public Builder setEnableResubscribe(boolean value) {\n+        bitField0_ |= 0x00000020;\n+        enableResubscribe_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearEnableResubscribe() {\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        enableResubscribe_ = true;\n+        onChanged();\n+        return this;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:Hedwig.SubscriptionOptions)\n     }\n     \n@@ -15144,67 +15384,71 @@ public Builder clearNumTopics() {\n       \"yRequest\\\".\\n\\016PublishRequest\\022\\034\\n\\003msg\\030\\002 \\002(\\0132\" +\n       \"\\017.Hedwig.Message\\\"d\\n\\027SubscriptionPreferen\" +\n       \"ces\\022\\034\\n\\007options\\030\\001 \\001(\\0132\\013.Hedwig.Map\\022\\024\\n\\014mes\" +\n-      \"sageBound\\030\\002 \\001(\\r\\022\\025\\n\\rmessageFilter\\030\\003 \\001(\\t\\\"\\243\" +\n+      \"sageBound\\030\\002 \\001(\\r\\022\\025\\n\\rmessageFilter\\030\\003 \\001(\\t\\\"\\277\" +\n       \"\\002\\n\\020SubscribeRequest\\022\\024\\n\\014subscriberId\\030\\002 \\002(\" +\n       \"\\014\\022Q\\n\\016createOrAttach\\030\\003 \\001(\\0162\\'.Hedwig.Subsc\",\n       \"ribeRequest.CreateOrAttach:\\020CREATE_OR_AT\" +\n       \"TACH\\022\\032\\n\\013synchronous\\030\\004 \\001(\\010:\\005false\\022\\024\\n\\014mess\" +\n       \"ageBound\\030\\005 \\001(\\r\\0224\\n\\013preferences\\030\\006 \\001(\\0132\\037.He\" +\n-      \"dwig.SubscriptionPreferences\\\">\\n\\016CreateOr\" +\n-      \"Attach\\022\\n\\n\\006CREATE\\020\\000\\022\\n\\n\\006ATTACH\\020\\001\\022\\024\\n\\020CREATE\" +\n-      \"_OR_ATTACH\\020\\002\\\"\\266\\001\\n\\023SubscriptionOptions\\022Q\\n\\016\" +\n-      \"createOrAttach\\030\\002 \\001(\\0162\\'.Hedwig.SubscribeR\" +\n-      \"equest.CreateOrAttach:\\020CREATE_OR_ATTACH\\022\" +\n-      \"\\027\\n\\014messageBound\\030\\003 \\001(\\r:\\0010\\022\\034\\n\\007options\\030\\004 \\001(\" +\n-      \"\\0132\\013.Hedwig.Map\\022\\025\\n\\rmessageFilter\\030\\005 \\001(\\t\\\"K\\n\",\n-      \"\\016ConsumeRequest\\022\\024\\n\\014subscriberId\\030\\002 \\002(\\014\\022#\\n\" +\n-      \"\\005msgId\\030\\003 \\002(\\0132\\024.Hedwig.MessageSeqId\\\"*\\n\\022Un\" +\n-      \"subscribeRequest\\022\\024\\n\\014subscriberId\\030\\002 \\002(\\014\\\"+\" +\n-      \"\\n\\023StopDeliveryRequest\\022\\024\\n\\014subscriberId\\030\\002 \" +\n-      \"\\002(\\014\\\",\\n\\024StartDeliveryRequest\\022\\024\\n\\014subscribe\" +\n-      \"rId\\030\\002 \\002(\\014\\\"\\377\\001\\n\\016PubSubResponse\\0220\\n\\017protocol\" +\n-      \"Version\\030\\001 \\002(\\0162\\027.Hedwig.ProtocolVersion\\022&\" +\n-      \"\\n\\nstatusCode\\030\\002 \\002(\\0162\\022.Hedwig.StatusCode\\022\\r\" +\n-      \"\\n\\005txnId\\030\\003 \\002(\\004\\022\\021\\n\\tstatusMsg\\030\\004 \\001(\\t\\022 \\n\\007mess\" +\n-      \"age\\030\\005 \\001(\\0132\\017.Hedwig.Message\\022\\r\\n\\005topic\\030\\006 \\001(\",\n-      \"\\014\\022\\024\\n\\014subscriberId\\030\\007 \\001(\\014\\022*\\n\\014responseBody\\030\" +\n-      \"\\010 \\001(\\0132\\024.Hedwig.ResponseBody\\\"?\\n\\017PublishRe\" +\n-      \"sponse\\022,\\n\\016publishedMsgId\\030\\001 \\002(\\0132\\024.Hedwig.\" +\n-      \"MessageSeqId\\\"I\\n\\021SubscribeResponse\\0224\\n\\013pre\" +\n-      \"ferences\\030\\002 \\001(\\0132\\037.Hedwig.SubscriptionPref\" +\n-      \"erences\\\"v\\n\\014ResponseBody\\0220\\n\\017publishRespon\" +\n-      \"se\\030\\001 \\001(\\0132\\027.Hedwig.PublishResponse\\0224\\n\\021sub\" +\n-      \"scribeResponse\\030\\002 \\001(\\0132\\031.Hedwig.SubscribeR\" +\n-      \"esponse\\\"N\\n\\021SubscriptionState\\022#\\n\\005msgId\\030\\001 \" +\n-      \"\\002(\\0132\\024.Hedwig.MessageSeqId\\022\\024\\n\\014messageBoun\",\n-      \"d\\030\\002 \\001(\\r\\\"r\\n\\020SubscriptionData\\022(\\n\\005state\\030\\001 \\001\" +\n-      \"(\\0132\\031.Hedwig.SubscriptionState\\0224\\n\\013prefere\" +\n-      \"nces\\030\\002 \\001(\\0132\\037.Hedwig.SubscriptionPreferen\" +\n-      \"ces\\\"O\\n\\013LedgerRange\\022\\020\\n\\010ledgerId\\030\\001 \\002(\\004\\022.\\n\\020\" +\n-      \"endSeqIdIncluded\\030\\002 \\001(\\0132\\024.Hedwig.MessageS\" +\n-      \"eqId\\\"3\\n\\014LedgerRanges\\022#\\n\\006ranges\\030\\001 \\003(\\0132\\023.H\" +\n-      \"edwig.LedgerRange\\\":\\n\\013ManagerMeta\\022\\023\\n\\013mana\" +\n-      \"gerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016managerVersion\\030\\003 \\002(\\r\\\".\\n\" +\n-      \"\\013HubInfoData\\022\\020\\n\\010hostname\\030\\002 \\002(\\t\\022\\r\\n\\005czxid\\030\" +\n-      \"\\003 \\002(\\004\\\" \\n\\013HubLoadData\\022\\021\\n\\tnumTopics\\030\\002 \\002(\\004*\",\n-      \"\\\"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_ONE\\020\\001*p\\n\\rO\" +\n-      \"perationType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\" +\n-      \"\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\\022\\022\\n\\016START_\" +\n-      \"DELIVERY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005*\\205\\004\\n\\nStatus\" +\n-      \"Code\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\" +\n-      \"\\003\\022\\022\\n\\rNO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_\" +\n-      \"SUBSCRIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\" +\n-      \"\\003\\022\\026\\n\\021COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\" +\n-      \"\\226\\003\\022\\036\\n\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SE\" +\n-      \"RVICE_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026I\",\n-      \"NVALID_MESSAGE_FILTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\" +\n-      \"\\210\\004\\022\\036\\n\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TO\" +\n-      \"PIC_PERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUB\" +\n-      \"SCRIPTION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE\" +\n-      \"_EXISTS\\020\\214\\004\\022\\030\\n\\023NO_TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027\" +\n-      \"TOPIC_OWNER_INFO_EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED\" +\n-      \"_CONDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apa\" +\n-      \"che.hedwig.protocolH\\001\"\n+      \"dwig.SubscriptionPreferences\\022\\032\\n\\013forceAtt\" +\n+      \"ach\\030\\007 \\001(\\010:\\005false\\\">\\n\\016CreateOrAttach\\022\\n\\n\\006CR\" +\n+      \"EATE\\020\\000\\022\\n\\n\\006ATTACH\\020\\001\\022\\024\\n\\020CREATE_OR_ATTACH\\020\\002\" +\n+      \"\\\"\\363\\001\\n\\023SubscriptionOptions\\022\\032\\n\\013forceAttach\\030\" +\n+      \"\\001 \\001(\\010:\\005false\\022Q\\n\\016createOrAttach\\030\\002 \\001(\\0162\\'.H\" +\n+      \"edwig.SubscribeRequest.CreateOrAttach:\\020C\" +\n+      \"REATE_OR_ATTACH\\022\\027\\n\\014messageBound\\030\\003 \\001(\\r:\\0010\",\n+      \"\\022\\034\\n\\007options\\030\\004 \\001(\\0132\\013.Hedwig.Map\\022\\025\\n\\rmessag\" +\n+      \"eFilter\\030\\005 \\001(\\t\\022\\037\\n\\021enableResubscribe\\030\\007 \\001(\\010\" +\n+      \":\\004true\\\"K\\n\\016ConsumeRequest\\022\\024\\n\\014subscriberId\" +\n+      \"\\030\\002 \\002(\\014\\022#\\n\\005msgId\\030\\003 \\002(\\0132\\024.Hedwig.MessageSe\" +\n+      \"qId\\\"*\\n\\022UnsubscribeRequest\\022\\024\\n\\014subscriberI\" +\n+      \"d\\030\\002 \\002(\\014\\\"+\\n\\023StopDeliveryRequest\\022\\024\\n\\014subscr\" +\n+      \"iberId\\030\\002 \\002(\\014\\\",\\n\\024StartDeliveryRequest\\022\\024\\n\\014\" +\n+      \"subscriberId\\030\\002 \\002(\\014\\\"\\377\\001\\n\\016PubSubResponse\\0220\\n\" +\n+      \"\\017protocolVersion\\030\\001 \\002(\\0162\\027.Hedwig.Protocol\" +\n+      \"Version\\022&\\n\\nstatusCode\\030\\002 \\002(\\0162\\022.Hedwig.Sta\",\n+      \"tusCode\\022\\r\\n\\005txnId\\030\\003 \\002(\\004\\022\\021\\n\\tstatusMsg\\030\\004 \\001(\" +\n+      \"\\t\\022 \\n\\007message\\030\\005 \\001(\\0132\\017.Hedwig.Message\\022\\r\\n\\005t\" +\n+      \"opic\\030\\006 \\001(\\014\\022\\024\\n\\014subscriberId\\030\\007 \\001(\\014\\022*\\n\\014resp\" +\n+      \"onseBody\\030\\010 \\001(\\0132\\024.Hedwig.ResponseBody\\\"?\\n\\017\" +\n+      \"PublishResponse\\022,\\n\\016publishedMsgId\\030\\001 \\002(\\0132\" +\n+      \"\\024.Hedwig.MessageSeqId\\\"I\\n\\021SubscribeRespon\" +\n+      \"se\\0224\\n\\013preferences\\030\\002 \\001(\\0132\\037.Hedwig.Subscri\" +\n+      \"ptionPreferences\\\"v\\n\\014ResponseBody\\0220\\n\\017publ\" +\n+      \"ishResponse\\030\\001 \\001(\\0132\\027.Hedwig.PublishRespon\" +\n+      \"se\\0224\\n\\021subscribeResponse\\030\\002 \\001(\\0132\\031.Hedwig.S\",\n+      \"ubscribeResponse\\\"N\\n\\021SubscriptionState\\022#\\n\" +\n+      \"\\005msgId\\030\\001 \\002(\\0132\\024.Hedwig.MessageSeqId\\022\\024\\n\\014me\" +\n+      \"ssageBound\\030\\002 \\001(\\r\\\"r\\n\\020SubscriptionData\\022(\\n\\005\" +\n+      \"state\\030\\001 \\001(\\0132\\031.Hedwig.SubscriptionState\\0224\" +\n+      \"\\n\\013preferences\\030\\002 \\001(\\0132\\037.Hedwig.Subscriptio\" +\n+      \"nPreferences\\\"O\\n\\013LedgerRange\\022\\020\\n\\010ledgerId\\030\" +\n+      \"\\001 \\002(\\004\\022.\\n\\020endSeqIdIncluded\\030\\002 \\001(\\0132\\024.Hedwig\" +\n+      \".MessageSeqId\\\"3\\n\\014LedgerRanges\\022#\\n\\006ranges\\030\" +\n+      \"\\001 \\003(\\0132\\023.Hedwig.LedgerRange\\\":\\n\\013ManagerMet\" +\n+      \"a\\022\\023\\n\\013managerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016managerVersion\",\n+      \"\\030\\003 \\002(\\r\\\".\\n\\013HubInfoData\\022\\020\\n\\010hostname\\030\\002 \\002(\\t\\022\" +\n+      \"\\r\\n\\005czxid\\030\\003 \\002(\\004\\\" \\n\\013HubLoadData\\022\\021\\n\\tnumTopi\" +\n+      \"cs\\030\\002 \\002(\\004*\\\"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_O\" +\n+      \"NE\\020\\001*p\\n\\rOperationType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tSU\" +\n+      \"BSCRIBE\\020\\001\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\\022\" +\n+      \"\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005*D\" +\n+      \"\\n\\021SubscriptionEvent\\022\\017\\n\\013TOPIC_MOVED\\020\\001\\022\\036\\n\\032\" +\n+      \"SUBSCRIPTION_FORCED_CLOSED\\020\\002*\\205\\004\\n\\nStatusC\" +\n+      \"ode\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\" +\n+      \"\\022\\022\\n\\rNO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_S\",\n+      \"UBSCRIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\" +\n+      \"\\022\\026\\n\\021COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\" +\n+      \"\\003\\022\\036\\n\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SER\" +\n+      \"VICE_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026IN\" +\n+      \"VALID_MESSAGE_FILTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\" +\n+      \"\\004\\022\\036\\n\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOP\" +\n+      \"IC_PERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBS\" +\n+      \"CRIPTION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_\" +\n+      \"EXISTS\\020\\214\\004\\022\\030\\n\\023NO_TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027T\" +\n+      \"OPIC_OWNER_INFO_EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_\",\n+      \"CONDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apac\" +\n+      \"he.hedwig.protocolH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -15288,15 +15532,15 @@ public Builder clearNumTopics() {\n           internal_static_Hedwig_SubscribeRequest_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_SubscribeRequest_descriptor,\n-              new java.lang.String[] { \"SubscriberId\", \"CreateOrAttach\", \"Synchronous\", \"MessageBound\", \"Preferences\", },\n+              new java.lang.String[] { \"SubscriberId\", \"CreateOrAttach\", \"Synchronous\", \"MessageBound\", \"Preferences\", \"ForceAttach\", },\n               org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.class,\n               org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.Builder.class);\n           internal_static_Hedwig_SubscriptionOptions_descriptor =\n             getDescriptor().getMessageTypes().get(9);\n           internal_static_Hedwig_SubscriptionOptions_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_SubscriptionOptions_descriptor,\n-              new java.lang.String[] { \"CreateOrAttach\", \"MessageBound\", \"Options\", \"MessageFilter\", },\n+              new java.lang.String[] { \"ForceAttach\", \"CreateOrAttach\", \"MessageBound\", \"Options\", \"MessageFilter\", \"EnableResubscribe\", },\n               org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions.class,\n               org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions.Builder.class);\n           internal_static_Hedwig_ConsumeRequest_descriptor ="},{"sha":"aab2a3efd40cede2d0155e6b518027c9de773b11","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -136,17 +136,26 @@ message SubscribeRequest{\n \n     // subscription options\n     optional SubscriptionPreferences preferences = 6;\n+\n+    // force attach subscription which would kill existed channel\n+    // this option doesn't need to be persisted\n+    optional bool forceAttach = 7 [default = false];\n }\n \n // used in client only\n // options are stored in SubscriptionPreferences structure\n message SubscriptionOptions {\n+    // force attach subscription which would kill existed channel\n+    // this option doesn't need to be persisted\n+    optional bool forceAttach = 1 [default = false];\n     optional SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n     optional uint32 messageBound = 3 [default = 0];\n     // user customized subscription options\n     optional Map options = 4;\n     // server-side message filter\n     optional string messageFilter = 5;\n+    // enable resubscribe\n+    optional bool enableResubscribe = 7 [default = true];\n }\n \n message ConsumeRequest{\n@@ -168,6 +177,14 @@ message StartDeliveryRequest{\n     required bytes subscriberId = 2;\n }\n \n+// Identify an event happened for a subscription\n+enum SubscriptionEvent {\n+    // topic has changed ownership (hub server down or topic released)\n+    TOPIC_MOVED = 1;\n+    // subscription is force closed by other subscribers\n+    SUBSCRIPTION_FORCED_CLOSED = 2;\n+}\n+\n message PubSubResponse{\n     required ProtocolVersion protocolVersion = 1;\n     required StatusCode statusCode = 2;"},{"sha":"7cc83b50c888760b7ba25cc630ccba9589e537a0","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","status":"modified","additions":18,"deletions":1,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -50,11 +50,14 @@\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.hedwig.util.SubscriptionListener;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n \n@@ -238,6 +241,15 @@ public void deliver(ByteString topic, ByteString subscriberId,\n         \n     }\n \n+    static class ConsoleSubscriptionListener implements SubscriptionListener {\n+\n+        @Override\n+        public void processEvent(ByteString t, ByteString s, SubscriptionEvent event) {\n+            System.out.println(\"Subscription Channel for (topic:\" + t.toStringUtf8() + \", subscriber:\"\n+                                + s.toStringUtf8() + \") received event : \" + event);\n+        }\n+    }\n+\n     class SubCmd implements MyCommand {\n \n         @Override\n@@ -271,7 +283,10 @@ public boolean runCmd(String[] args) throws Exception {\n             ByteString topic = ByteString.copyFromUtf8(args[1]);\n             ByteString subId = ByteString.copyFromUtf8(args[2]);\n             try {\n-                subscriber.subscribe(topic, subId, mode);\n+                SubscriptionOptions options =\n+                    SubscriptionOptions.newBuilder().setCreateOrAttach(mode)\n+                                       .setForceAttach(false).build();\n+                subscriber.subscribe(topic, subId, options);\n                 if (receive) {\n                     subscriber.startDelivery(topic, subId, consoleHandler);\n                     System.out.println(\"SUB DONE AND RECEIVE\");\n@@ -400,6 +415,7 @@ public boolean runCmd(String[] args) throws Exception {\n                                  + \" subscriber: \" + args[2]);\n                 return true;\n             }\n+            lastConsumedId = subData.getState().getMsgId().getLocalComponent();\n             long numMessagesToConsume = Long.parseLong(args[3]);\n             long idToConsumed = lastConsumedId + numMessagesToConsume;\n             System.out.println(\"Try to move subscriber(\" + args[2] + \") consume ptr of topic(\" + args[1]\n@@ -852,6 +868,7 @@ public HedwigConsole(String[] args) throws IOException, InterruptedException {\n         hubClient = new HedwigClient(hubClientCfg);\n         publisher = hubClient.getPublisher();\n         subscriber = hubClient.getSubscriber();\n+        subscriber.addSubscriptionListener(new ConsoleSubscriptionListener());\n         \n         // other parameters\n         myRegion = hubServerConf.getMyRegion();"},{"sha":"468d44379ff4de570959a30c23f82dcc6291a0c0","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -314,6 +314,10 @@ public ActiveSubscriberState(ByteString topic, ByteString subscriberId, long las\n         }\n \n         public void setNotConnected() {\n+            // have closed it.\n+            if (!isConnected()) {\n+                return;\n+            }\n             this.connected = false;\n             deliveryEndPoint.close();\n             // uninitialize filter"},{"sha":"d97e3b8c9cd7fafe5224309a92d8eb0daac35d4c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"modified","additions":68,"deletions":18,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -22,6 +22,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n import org.jboss.netty.channel.ChannelFutureListener;\n \n import com.google.protobuf.ByteString;\n@@ -65,6 +66,17 @@\n     // op stats\n     private final OpStats subStats;\n \n+    private static ChannelFutureListener CLOSE_OLD_CHANNEL_LISTENER = new ChannelFutureListener() {\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (!future.isSuccess()) {\n+                logger.warn(\"Failed to close old subscription channel.\");\n+            } else {\n+                logger.debug(\"Close old subscription channel succeed.\");\n+            }\n+        }\n+    };\n+\n     public SubscribeHandler(TopicManager topicMgr, DeliveryManager deliveryManager, PersistenceManager persistenceMgr,\n                             SubscriptionManager subMgr, ServerConfiguration cfg) {\n         super(topicMgr, cfg);\n@@ -83,7 +95,8 @@ public void channelDisconnected(Channel channel) {\n         synchronized (channel) {\n             TopicSubscriber topicSub = channel2sub.remove(channel);\n             if (topicSub != null) {\n-                sub2Channel.remove(topicSub);\n+                // remove entry only currently mapped to given value.\n+                sub2Channel.remove(topicSub, channel);\n             }\n         }\n     }\n@@ -106,6 +119,8 @@ public void handleRequestAtOwner(final PubSubRequest request, final Channel chan\n         } catch (ServerNotResponsibleForTopicException e) {\n             channel.write(PubSubResponseUtils.getResponseForException(e, request.getTxnId())).addListener(\n                 ChannelFutureListener.CLOSE);\n+            logger.error(\"Error getting current seq id for topic \" + topic.toStringUtf8()\n+                       + \" when processing subscribe request (txnid:\" + request.getTxnId() + \") :\", e);\n             subStats.incrementFailedOps();\n             ServerStats.getInstance().incrementRequestsRedirect();\n             return;\n@@ -123,16 +138,15 @@ public void handleRequestAtOwner(final PubSubRequest request, final Channel chan\n             public void operationFailed(Object ctx, PubSubException exception) {\n                 channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId())).addListener(\n                     ChannelFutureListener.CLOSE);\n+                logger.error(\"Error serving subscribe request (\" + request.getTxnId() + \") for (topic: \"\n+                           + topic.toStringUtf8() + \" , subscriber: \" + subscriberId.toStringUtf8() + \")\", exception);\n                 subStats.incrementFailedOps();\n             }\n \n             @Override\n             public void operationFinished(Object ctx, SubscriptionData subData) {\n \n                 TopicSubscriber topicSub = new TopicSubscriber(topic, subscriberId);\n-\n-                // race with channel getting disconnected while we are adding it\n-                // to the 2 maps\n                 synchronized (channel) {\n                     if (!channel.isConnected()) {\n                         // channel got disconnected while we were processing the\n@@ -141,20 +155,6 @@ public void operationFinished(Object ctx, SubscriptionData subData) {\n                         subStats.incrementFailedOps();\n                         return;\n                     }\n-\n-                    if (null != sub2Channel.putIfAbsent(topicSub, channel)) {\n-                        // there was another channel mapped to this sub\n-                        PubSubException pse = new PubSubException.TopicBusyException(\n-                            \"subscription for this topic, subscriberId is already being served on a different channel\");\n-                        channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n-                        .addListener(ChannelFutureListener.CLOSE);\n-                        subStats.incrementFailedOps();\n-                        return;\n-                    } else {\n-                        // channel2sub is just a cache, so we can add to it\n-                        // without synchronization\n-                        channel2sub.put(channel, topicSub);\n-                    }\n                 }\n                 // initialize the message filter\n                 PipelineFilter filter = new PipelineFilter();\n@@ -192,7 +192,57 @@ public void operationFinished(Object ctx, SubscriptionData subData) {\n                     .addListener(ChannelFutureListener.CLOSE);\n                     return;\n                 }\n+                // race with channel getting disconnected while we are adding it\n+                // to the 2 maps\n+                synchronized (channel) {\n+                    boolean forceAttach = false;\n+                    if (subRequest.hasForceAttach()) {\n+                        forceAttach = subRequest.getForceAttach();\n+                    }\n \n+                    Channel oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n+                    if (null != oldChannel) {\n+                        boolean subSuccess = false;\n+                        if (forceAttach) {\n+                            // it is safe to close old channel here since new channel will be put\n+                            // in sub2Channel / channel2Sub so there is no race between channel\n+                            // getting disconnected and it.\n+                            ChannelFuture future = oldChannel.close();\n+                            future.addListener(CLOSE_OLD_CHANNEL_LISTENER);\n+                            logger.info(\"New subscribe request (\" + request.getTxnId() + \") for (topic: \" + topic.toStringUtf8()\n+                                      + \", subscriber: \" + subscriberId.toStringUtf8() + \") from channel \" + channel.getRemoteAddress()\n+                                      + \" kills old channel \" + oldChannel.getRemoteAddress());\n+                            // try replace the oldChannel\n+                            // if replace failure, it migth caused because channelDisconnect callback\n+                            // has removed the old channel.\n+                            if (!sub2Channel.replace(topicSub, oldChannel, channel)) {\n+                                // try to add it now.\n+                                // if add failure, it means other one has obtained the channel\n+                                oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n+                                if (null == oldChannel) {\n+                                    subSuccess = true;\n+                                }\n+                            } else {\n+                                subSuccess = true;\n+                            }\n+                        }\n+                        if (!subSuccess) {\n+                            PubSubException pse = new PubSubException.TopicBusyException(\n+                                \"Subscriber \" + subscriberId.toStringUtf8() + \" for topic \" + topic.toStringUtf8()\n+                                + \" is already being served on a different channel \" + oldChannel.getRemoteAddress());\n+                            subStats.incrementFailedOps();\n+                            logger.error(\"Error serving subscribe request (\" + request.getTxnId() + \") for (topic: \" + topic.toStringUtf8()\n+                                       + \", subscriber: \" + subscriberId.toStringUtf8() + \") from channel \" + channel.getRemoteAddress()\n+                                       + \" since it already being served on a different channel \" + oldChannel.getRemoteAddress());\n+                            channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n+                            .addListener(ChannelFutureListener.CLOSE);\n+                            return;\n+                        }\n+                    }\n+                    // channel2sub is just a cache, so we can add to it\n+                    // without synchronization\n+                    channel2sub.put(channel, topicSub);\n+                }\n                 // First write success and then tell the delivery manager,\n                 // otherwise the first message might go out before the response\n                 // to the subscribe"},{"sha":"5036154aacff36744ba434925acb26a05a3a1320","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -148,11 +148,12 @@ protected PersistenceManager instantiatePersistenceManager(TopicManager topicMgr\n         return pm;\n     }\n \n-    protected SubscriptionManager instantiateSubscriptionManager(TopicManager tm, PersistenceManager pm) {\n+    protected SubscriptionManager instantiateSubscriptionManager(TopicManager tm, PersistenceManager pm,\n+                                                                 DeliveryManager dm) {\n         if (conf.isStandalone()) {\n-            return new InMemorySubscriptionManager(tm, pm, conf, scheduler);\n+            return new InMemorySubscriptionManager(conf, tm, pm, dm, scheduler);\n         } else {\n-            return new MMSubscriptionManager(mm, tm, pm, conf, scheduler);\n+            return new MMSubscriptionManager(conf, mm, tm, pm, dm, scheduler);\n         }\n \n     }\n@@ -392,7 +393,7 @@ public void run() {\n                     dm = new FIFODeliveryManager(pm, conf);\n                     dm.start();\n \n-                    sm = instantiateSubscriptionManager(tm, pm);\n+                    sm = instantiateSubscriptionManager(tm, pm, dm);\n                     rm = instantiateRegionManager(pm, scheduler);\n                     sm.addListener(rm);\n "},{"sha":"1b8feaa30b961e578ad7932145b8e319cbd3a4aa","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":43,"deletions":14,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -42,6 +42,7 @@\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.common.TopicOpQueuer;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TopicOwnershipChangeListener;\n@@ -59,6 +60,9 @@\n     private final ArrayList<SubscriptionEventListener> listeners = new ArrayList<SubscriptionEventListener>();\n     private final ConcurrentHashMap<ByteString, AtomicInteger> topic2LocalCounts = new ConcurrentHashMap<ByteString, AtomicInteger>();\n \n+    // Handle to the DeliveryManager for the server so we can stop serving subscribers\n+    // when losing topics\n+    private final DeliveryManager dm;\n     // Handle to the PersistenceManager for the server so we can pass along the\n     // message consume pointers for each topic.\n     private final PersistenceManager pm;\n@@ -83,12 +87,14 @@ public void operationFinished(Object ctx, T resultOfOperation) {\n         };\n     }\n \n-    public AbstractSubscriptionManager(ServerConfiguration cfg, TopicManager tm, PersistenceManager pm,\n+    public AbstractSubscriptionManager(ServerConfiguration cfg, TopicManager tm,\n+                                       PersistenceManager pm, DeliveryManager dm,\n                                        ScheduledExecutorService scheduler) {\n         this.cfg = cfg;\n         queuer = new TopicOpQueuer(scheduler);\n         tm.addTopicOwnershipChangeListener(this);\n         this.pm = pm;\n+        this.dm = dm;\n         // Schedule the recurring MessagesConsumedTask only if a\n         // PersistenceManager is passed.\n         if (pm != null) {\n@@ -238,15 +244,21 @@ public void acquiredTopic(final ByteString topic, final Callback<Void> callback,\n \n     class ReleaseOp extends TopicOpQueuer.AsynchronousOp<Void> {\n \n-        public ReleaseOp(final ByteString topic, final Callback<Void> cb, Object ctx) {\n+        final boolean removeStates;\n+\n+        public ReleaseOp(final ByteString topic, final Callback<Void> cb, Object ctx,\n+                         boolean removeStates) {\n             queuer.super(topic, cb, ctx);\n+            this.removeStates = removeStates;\n         }\n \n         @Override\n         public void run() {\n             Callback<Void> finalCb = new Callback<Void>() {\n                 @Override\n                 public void operationFinished(Object ctx, Void resultOfOperation) {\n+                    logger.info(\"Finished update subscription states when losting topic \"\n+                              + topic.toStringUtf8());\n                     finish();\n                 }\n \n@@ -258,6 +270,28 @@ public void operationFailed(Object ctx,\n                 }\n \n                 private void finish() {\n+                    // tell delivery manager to stop delivery for subscriptions of this topic\n+                    final Map<ByteString, InMemorySubscriptionState> topicSubscriptions;\n+                    if (removeStates) {\n+                        topicSubscriptions = top2sub2seq.remove(topic);\n+                    } else {\n+                        topicSubscriptions = top2sub2seq.get(topic);\n+                    }\n+                    // no subscriptions now, it may be removed by other release ops\n+                    if (null != topicSubscriptions) {\n+                        for (ByteString subId : topicSubscriptions.keySet()) {\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Stop serving subscriber (\" + topic.toStringUtf8() + \", \"\n+                                           + subId.toStringUtf8() + \") when losing topic\");\n+                            }\n+                            if (null != dm) {\n+                                dm.stopServingSubscriber(topic, subId);\n+                            }\n+                        }\n+                    }\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Stop serving topic \" + topic.toStringUtf8());\n+                    }\n                     topic2LocalCounts.remove(topic);\n                     // Since we decrement local count when some of remote subscriptions failed,\n                     // while we don't unsubscribe those succeed subscriptions. so we can't depends\n@@ -269,18 +303,13 @@ private void finish() {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Try to update subscription states when losing topic \" + topic.toStringUtf8());\n             }\n-            updateSubscriptionStates(topic, finalCb, ctx, true);\n+            updateSubscriptionStates(topic, finalCb, ctx);\n         }\n     }\n \n-    void updateSubscriptionStates(ByteString topic, Callback<Void> finalCb, Object ctx, boolean removeTopic) {\n+    void updateSubscriptionStates(ByteString topic, Callback<Void> finalCb, Object ctx) {\n         // Try to update subscription states of a specified topic\n-        Map<ByteString, InMemorySubscriptionState> states;\n-        if (removeTopic) {\n-            states = top2sub2seq.remove(topic);\n-        } else {\n-            states = top2sub2seq.get(topic);\n-        }\n+        Map<ByteString, InMemorySubscriptionState> states = top2sub2seq.get(topic);\n         if (null == states) {\n             finalCb.operationFinished(ctx, null);\n         } else {\n@@ -301,7 +330,7 @@ void updateSubscriptionStates(ByteString topic, Callback<Void> finalCb, Object c\n      */\n     @Override\n     public void lostTopic(ByteString topic) {\n-        queuer.pushAndMaybeRun(topic, new ReleaseOp(topic, noopCallback, null));\n+        queuer.pushAndMaybeRun(topic, new ReleaseOp(topic, noopCallback, null, true));\n     }\n \n     private void notifyUnsubcribe(ByteString topic) {\n@@ -342,7 +371,7 @@ public void run() {\n                     String msg = \"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n                                  + \" requested creating a subscription but it is already subscribed with state: \"\n                                  + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState());\n-                    logger.debug(msg);\n+                    logger.error(msg);\n                     cb.operationFailed(ctx, new PubSubException.ClientAlreadySubscribedException(msg));\n                     return;\n                 }\n@@ -392,7 +421,7 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n             if (createOrAttach.equals(CreateOrAttach.ATTACH)) {\n                 String msg = \"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n                              + \" requested attaching to an existing subscription but it is not subscribed\";\n-                logger.debug(msg);\n+                logger.error(msg);\n                 cb.operationFailed(ctx, new PubSubException.ClientNotSubscribedException(msg));\n                 return;\n             }\n@@ -635,7 +664,7 @@ public void operationFailed(Object ctx,\n                         ConcurrencyUtils.put(queue, false);\n                     }\n                 };\n-                updateSubscriptionStates(topic, finalCb, null, false);\n+                updateSubscriptionStates(topic, finalCb, null);\n                 queue.take();\n             }\n         } catch (InterruptedException ie) {"},{"sha":"1400e4935914284280b694e6bed7c2ce34c09fbc","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","status":"modified","additions":10,"deletions":2,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -24,14 +24,18 @@\n import com.google.protobuf.ByteString;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.util.Callback;\n \n public class InMemorySubscriptionManager extends AbstractSubscriptionManager {\n \n-    public InMemorySubscriptionManager(TopicManager tm, PersistenceManager pm, ServerConfiguration conf, ScheduledExecutorService scheduler) {\n-        super(conf, tm, pm, scheduler);\n+    public InMemorySubscriptionManager(ServerConfiguration conf,\n+                                       TopicManager tm, PersistenceManager pm,\n+                                       DeliveryManager dm,\n+                                       ScheduledExecutorService scheduler) {\n+        super(conf, tm, pm, dm, scheduler);\n     }\n \n     @Override\n@@ -69,6 +73,10 @@ protected void replaceSubscriptionData(ByteString topic, ByteString subscriberId\n     @Override\n     public void lostTopic(ByteString topic) {\n         // Intentionally do nothing, so that we dont lose in-memory information\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"InMemorySubscriptionManager is losing topic \" + topic.toStringUtf8());\n+        }\n+        queuer.pushAndMaybeRun(topic, new ReleaseOp(topic, noopCallback, null, false));\n     }\n \n     @Override"},{"sha":"92d86d372a2097303b2374bb06bdfdd5c327d5a6","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -40,11 +40,12 @@\n \n     SubscriptionDataManager subManager;\n \n-    public MMSubscriptionManager(MetadataManagerFactory metaManagerFactory,\n+    public MMSubscriptionManager(ServerConfiguration cfg,\n+                                 MetadataManagerFactory metaManagerFactory,\n                                  TopicManager topicMgr, PersistenceManager pm,\n-                                 ServerConfiguration cfg,\n+                                 DeliveryManager dm,\n                                  ScheduledExecutorService scheduler) {\n-        super(cfg, topicMgr, pm, scheduler);\n+        super(cfg, topicMgr, pm, dm, scheduler);\n         this.subManager = metaManagerFactory.newSubscriptionDataManager();\n     }\n "},{"sha":"aba0044f45e2b861fe7720e23f504cf5540e3a19","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"modified","additions":168,"deletions":1,"changes":169,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -40,20 +40,61 @@\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.PublishResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.server.PubSubServerStandAloneTestBase;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.util.ConcurrencyUtils;\n+import org.apache.hedwig.util.SubscriptionListener;\n \n public class TestPubSubClient extends PubSubServerStandAloneTestBase {\n \n+    private static final int RETENTION_SECS_VALUE = 10;\n+\n     // Client side variables\n     protected HedwigClient client;\n     protected Publisher publisher;\n     protected Subscriber subscriber;\n \n+    protected class RetentionServerConfiguration extends StandAloneServerConfiguration {\n+        @Override\n+        public boolean isStandalone() {\n+            return true;\n+        }\n+\n+        @Override\n+        public int getRetentionSecs() {\n+            return RETENTION_SECS_VALUE;\n+        }\n+    }\n+\n     // SynchronousQueues to verify async calls\n     private final SynchronousQueue<Boolean> queue = new SynchronousQueue<Boolean>();\n     private final SynchronousQueue<Boolean> consumeQueue = new SynchronousQueue<Boolean>();\n+    private final SynchronousQueue<SubscriptionEvent> eventQueue =\n+        new SynchronousQueue<SubscriptionEvent>();\n+\n+    class TestSubscriptionListener implements SubscriptionListener {\n+        SynchronousQueue<SubscriptionEvent> eventQueue;\n+        public TestSubscriptionListener() {\n+            this.eventQueue = TestPubSubClient.this.eventQueue;\n+        }\n+        public TestSubscriptionListener(SynchronousQueue<SubscriptionEvent> queue) {\n+            this.eventQueue = queue;\n+        }\n+        @Override\n+        public void processEvent(final ByteString topic, final ByteString subscriberId,\n+                                 final SubscriptionEvent event) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    logger.debug(\"Event {} received for subscription(topic:{}, subscriber:{})\",\n+                                 new Object[] { event, topic.toStringUtf8(), subscriberId.toStringUtf8() });\n+                    ConcurrencyUtils.put(TestSubscriptionListener.this.eventQueue, event);\n+                }\n+            }).start();\n+        }\n+    }\n \n     // Test implementation of Callback for async client actions.\n     class TestCallback implements Callback<Void> {\n@@ -84,14 +125,25 @@ public void run() {\n \n     // Test implementation of subscriber's message handler.\n     class TestMessageHandler implements MessageHandler {\n+\n+        private final SynchronousQueue<Boolean> consumeQueue;\n+\n+        public TestMessageHandler() {\n+            this.consumeQueue = TestPubSubClient.this.consumeQueue;\n+        }\n+\n+        public TestMessageHandler(SynchronousQueue<Boolean> consumeQueue) {\n+            this.consumeQueue = consumeQueue;\n+        }\n+\n         public void deliver(ByteString topic, ByteString subscriberId, Message msg, Callback<Void> callback,\n                             Object context) {\n             new Thread(new Runnable() {\n                 @Override\n                 public void run() {\n                     if (logger.isDebugEnabled())\n                         logger.debug(\"Consume operation finished successfully!\");\n-                    ConcurrencyUtils.put(consumeQueue, true);\n+                    ConcurrencyUtils.put(TestMessageHandler.this.consumeQueue, true);\n                 }\n             }).start();\n             callback.operationFinished(context, null);\n@@ -362,4 +414,119 @@ public void testAsyncSubscribeAndCloseSubscription() throws Exception {\n         assertTrue(true);\n     }\n \n+    @Test\n+    public void testSyncSubscribeWithListener() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"mySyncSubscribeWithListener\");\n+        ByteString subscriberId = ByteString.copyFromUtf8(\"mysub\");\n+        subscriber.addSubscriptionListener(new TestSubscriptionListener());\n+        try {\n+            SubscriptionOptions options =\n+                SubscriptionOptions.newBuilder()\n+                .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH)\n+                .setEnableResubscribe(false).build();\n+            subscriber.subscribe(topic, subscriberId, options);\n+        } catch (PubSubException.ServiceDownException e) {\n+            fail(\"Should not reach here!\");\n+        }\n+        subscriber.startDelivery(topic, subscriberId, new TestMessageHandler());\n+        tearDownHubServer();\n+        assertEquals(SubscriptionEvent.TOPIC_MOVED, eventQueue.take());\n+    }\n+\n+    @Test\n+    public void testAsyncSubscribeWithListener() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"myAsyncSubscribeWithListener\");\n+        ByteString subscriberId = ByteString.copyFromUtf8(\"mysub\");\n+        subscriber.addSubscriptionListener(new TestSubscriptionListener());\n+        SubscriptionOptions options =\n+            SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH)\n+            .setEnableResubscribe(false).build();\n+        subscriber.asyncSubscribe(topic, subscriberId, options,\n+                                  new TestCallback(), null);\n+        assertTrue(queue.take());\n+        subscriber.startDelivery(topic, subscriberId, new TestMessageHandler());\n+        tearDownHubServer();\n+        assertEquals(SubscriptionEvent.TOPIC_MOVED, eventQueue.take());\n+    }\n+\n+    @Test\n+    public void testSyncSubscribeForceAttach() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"mySyncSubscribeForceAttach\");\n+        ByteString subscriberId = ByteString.copyFromUtf8(\"mysub\");\n+        subscriber.addSubscriptionListener(new TestSubscriptionListener());\n+        SubscriptionOptions options =\n+            SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH)\n+            .setForceAttach(true).setEnableResubscribe(false).build();\n+        try {\n+            subscriber.subscribe(topic, subscriberId, options);\n+        } catch (PubSubException.ServiceDownException e) {\n+            fail(\"Should not reach here!\");\n+        }\n+        subscriber.startDelivery(topic, subscriberId, new TestMessageHandler());\n+\n+        // new a client\n+        HedwigClient client2 = new HedwigClient(new ClientConfiguration());\n+        Subscriber subscriber2 = client2.getSubscriber();\n+        Publisher publisher2 = client2.getPublisher();\n+        SynchronousQueue<SubscriptionEvent> eventQueue2 =\n+            new SynchronousQueue<SubscriptionEvent>();\n+        subscriber2.addSubscriptionListener(new TestSubscriptionListener(eventQueue2));\n+        try {\n+            subscriber2.subscribe(topic, subscriberId, options);\n+        } catch (PubSubException.ServiceDownException e) {\n+            fail(\"Should not reach here!\");\n+        }\n+\n+        SynchronousQueue<Boolean> consumeQueue2 = new SynchronousQueue<Boolean>();\n+        subscriber2.startDelivery(topic, subscriberId, new TestMessageHandler(consumeQueue2));\n+\n+        assertEquals(SubscriptionEvent.TOPIC_MOVED, eventQueue.take());\n+        assertTrue(eventQueue2.isEmpty());\n+\n+        // Now publish some messages for the topic to be consumed by the\n+        // subscriber.\n+        publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #1\")).build(),\n+                               new TestCallback(), null);\n+        assertTrue(queue.take());\n+        assertTrue(consumeQueue2.take());\n+        assertTrue(consumeQueue.isEmpty());\n+\n+        publisher2.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #2\")).build(),\n+                               new TestCallback(), null);\n+        assertTrue(queue.take());\n+        assertTrue(consumeQueue2.take());\n+        assertTrue(consumeQueue.isEmpty());\n+\n+        client2.close();\n+    }\n+\n+    @Test\n+    public void testSyncSubscribeWithListenerWhenReleasingTopic() throws Exception {\n+        tearDownHubServer();\n+        startHubServer(new RetentionServerConfiguration());\n+        ByteString topic = ByteString.copyFromUtf8(\"mySyncSubscribeWithListenerWhenReleasingTopic\");\n+        ByteString subscriberId = ByteString.copyFromUtf8(\"mysub\");\n+        subscriber.addSubscriptionListener(new TestSubscriptionListener());\n+        SubscriptionOptions options =\n+            SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH)\n+            .setForceAttach(false).setEnableResubscribe(false).build();\n+        try {\n+            subscriber.subscribe(topic, subscriberId, options);\n+        } catch (PubSubException.ServiceDownException e) {\n+            fail(\"Should not reach here!\");\n+        }\n+        subscriber.startDelivery(topic, subscriberId, new TestMessageHandler());\n+\n+        publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #1\")).build(),\n+                               new TestCallback(), null);\n+        assertTrue(queue.take());\n+        assertTrue(consumeQueue.take());\n+\n+        Thread.sleep(RETENTION_SECS_VALUE * 2);\n+        assertEquals(SubscriptionEvent.TOPIC_MOVED, eventQueue.take());\n+    }\n+\n }"},{"sha":"07c4c1f52b689e317ebfb81248256d14ac9108e2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","status":"modified","additions":20,"deletions":3,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -41,23 +41,40 @@ public boolean isStandalone() {\n         }\n     }\n \n+    public ServerConfiguration getStandAloneServerConfiguration() {\n+        return new StandAloneServerConfiguration();\n+    }\n+\n     protected PubSubServer server;\n \n     @Override\n     @Before\n     public void setUp() throws Exception {\n         logger.info(\"STARTING \" + getName());\n-        server = new PubSubServer(new StandAloneServerConfiguration());\n-        server.start();\n+        startHubServer();\n         logger.info(\"Standalone PubSubServer test setup finished\");\n     }\n \n+\n     @Override\n     @After\n     public void tearDown() throws Exception {\n         logger.info(\"tearDown starting\");\n-        server.shutdown();\n+        tearDownHubServer();\n         logger.info(\"FINISHED \" + getName());\n     }\n \n+    protected void startHubServer() throws Exception {\n+        startHubServer(getStandAloneServerConfiguration());\n+    }\n+\n+    protected void startHubServer(ServerConfiguration conf) throws Exception {\n+        server = new PubSubServer(conf);\n+        server.start();\n+    }\n+\n+    protected void tearDownHubServer() throws Exception {\n+        server.shutdown();\n+    }\n+\n }"},{"sha":"b427b649d798846c2d8f2efae2633c3173bc18b9","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -74,7 +74,7 @@ protected void setUp() throws Exception {\n         TopicManager tm = new TrivialOwnAllTopicManager(conf, executor);\n         dm = new StubDeliveryManager();\n         PersistenceManager pm = LocalDBPersistenceManager.instance();\n-        sm = new StubSubscriptionManager(tm, pm, conf, executor);\n+        sm = new StubSubscriptionManager(tm, pm, dm, conf, executor);\n         sh = new SubscribeHandler(tm, dm, pm, sm, conf);\n         channel = new WriteRecordingChannel();\n "},{"sha":"26b2ce3417d5f35d5b82d42ab888287076c281cb","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -25,6 +25,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.util.Callback;\n@@ -36,8 +37,9 @@ public void setFail(boolean fail) {\n         this.fail = fail;\n     }\n \n-    public StubSubscriptionManager(TopicManager tm, PersistenceManager pm, ServerConfiguration conf, ScheduledExecutorService scheduler) {\n-        super(tm, pm, conf, scheduler);\n+    public StubSubscriptionManager(TopicManager tm, PersistenceManager pm, DeliveryManager dm,\n+                                   ServerConfiguration conf, ScheduledExecutorService scheduler) {\n+        super(conf, tm, pm, dm, scheduler);\n     }\n \n     @Override"},{"sha":"010ff29c26db7b3b09e1def6e8c4f21f04797dc1","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/820ce5949c6a32ddca32ce7b408a57e27f5086bb/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java?ref=820ce5949c6a32ddca32ce7b408a57e27f5086bb","patch":"@@ -57,8 +57,8 @@ public void setUp() throws Exception {\n         cfg = new ServerConfiguration();\n         final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n         mm = MetadataManagerFactory.newMetadataManagerFactory(cfg, zk);\n-        sm = new MMSubscriptionManager(mm, new TrivialOwnAllTopicManager(cfg, scheduler),\n-                                       LocalDBPersistenceManager.instance(), cfg, scheduler);\n+        sm = new MMSubscriptionManager(cfg, mm, new TrivialOwnAllTopicManager(cfg, scheduler),\n+                                       LocalDBPersistenceManager.instance(), null, scheduler);\n         subDataCallback = new Callback<SubscriptionData>() {\n             @Override\n             public void operationFailed(Object ctx, final PubSubException exception) {"}]}

