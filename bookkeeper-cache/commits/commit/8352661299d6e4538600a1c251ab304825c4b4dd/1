{"sha":"8352661299d6e4538600a1c251ab304825c4b4dd","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MzUyNjYxMjk5ZDZlNDUzODYwMGExYzI1MWFiMzA0ODI1YzRiNGRk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-04-24T11:40:47Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-04-24T11:40:47Z"},"message":"BOOKKEEPER-742: Fix for empty ledgers losing quorum. (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1589675 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d39fd842b4641d813b63d26dbea3bdb96cf6eb82","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d39fd842b4641d813b63d26dbea3bdb96cf6eb82"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8352661299d6e4538600a1c251ab304825c4b4dd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8352661299d6e4538600a1c251ab304825c4b4dd","html_url":"https://github.com/apache/bookkeeper/commit/8352661299d6e4538600a1c251ab304825c4b4dd","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8352661299d6e4538600a1c251ab304825c4b4dd/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"68925561dee3e83d5ea76691c3ad196c02d82e06","url":"https://api.github.com/repos/apache/bookkeeper/commits/68925561dee3e83d5ea76691c3ad196c02d82e06","html_url":"https://github.com/apache/bookkeeper/commit/68925561dee3e83d5ea76691c3ad196c02d82e06"}],"stats":{"total":222,"additions":177,"deletions":45},"files":[{"sha":"e3b91a4e38e3087bd3ada8497cd10cff799c2bb6","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -20,6 +20,8 @@ Release 4.2.3 - 2013-12-04\n        \n         BOOKKEEPER-710: OpenLedgerNoRecovery should watch ensemble change. (sijie, ivank via fpj)\n \n+        BOOKKEEPER-742: Fix for empty ledgers losing quorum. (ivank)\n+\n Release 4.2.2 - 2013-10-02\n \n   Backward compatible changes:"},{"sha":"fea01c6af301b881556a7b1e50ff97e8d7b5e494","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -873,4 +873,11 @@ public void remove()\n             }\n         };\n     }\n+\n+    /**\n+     * @return the metadata for the passed ledger handle\n+     */\n+    public LedgerMetadata getLedgerMetadata(LedgerHandle lh) {\n+        return lh.getLedgerMetadata();\n+    }\n }"},{"sha":"64fbb50332229357f7dbe10faff859bbbcf0189a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":39,"deletions":35,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -27,6 +27,7 @@\n import java.util.Map;\n import java.util.Set;\n \n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n@@ -62,6 +63,8 @@\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.commons.collections.CollectionUtils;\n import com.google.common.collect.Sets;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.SettableFuture;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.ZooKeeper;\n@@ -146,47 +149,48 @@ public void run() {\n         }\n     }\n \n-    private synchronized void submitAuditTask() {\n-        synchronized (this) {\n-            if (executor.isShutdown()) {\n-                return;\n-            }\n-            executor.submit(new Runnable() {\n-                    public void run() {\n-                        try {\n-                            waitIfLedgerReplicationDisabled();\n+    @VisibleForTesting\n+    synchronized Future<?> submitAuditTask() {\n+        if (executor.isShutdown()) {\n+            SettableFuture<Void> f = SettableFuture.<Void>create();\n+            f.setException(new BKAuditException(\"Auditor shutting down\"));\n+            return f;\n+        }\n+        return executor.submit(new Runnable() {\n+                public void run() {\n+                    try {\n+                        waitIfLedgerReplicationDisabled();\n \n-                            List<String> availableBookies = getAvailableBookies();\n+                        List<String> availableBookies = getAvailableBookies();\n \n-                            // casting to String, as knownBookies and availableBookies\n-                            // contains only String values\n-                            // find new bookies(if any) and update the known bookie list\n-                            Collection<String> newBookies = CollectionUtils.subtract(\n-                                    availableBookies, knownBookies);\n-                            knownBookies.addAll(newBookies);\n+                        // casting to String, as knownBookies and availableBookies\n+                        // contains only String values\n+                        // find new bookies(if any) and update the known bookie list\n+                        Collection<String> newBookies = CollectionUtils.subtract(\n+                                availableBookies, knownBookies);\n+                        knownBookies.addAll(newBookies);\n \n-                            // find lost bookies(if any)\n-                            Collection<String> lostBookies = CollectionUtils.subtract(\n-                                    knownBookies, availableBookies);\n+                        // find lost bookies(if any)\n+                        Collection<String> lostBookies = CollectionUtils.subtract(\n+                                knownBookies, availableBookies);\n \n-                            if (lostBookies.size() > 0) {\n-                                knownBookies.removeAll(lostBookies);\n-                                Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n-                                handleLostBookies(lostBookies, ledgerDetails);\n-                            }\n-                        } catch (BKException bke) {\n-                            LOG.error(\"Exception getting bookie list\", bke);\n-                        } catch (InterruptedException ie) {\n-                            Thread.currentThread().interrupt();\n-                            LOG.error(\"Interrupted while watching available bookies \", ie);\n-                        } catch (BKAuditException bke) {\n-                            LOG.error(\"Exception while watching available bookies\", bke);\n-                        } catch (UnavailableException ue) {\n-                            LOG.error(\"Exception while watching available bookies\", ue);\n+                        if (lostBookies.size() > 0) {\n+                            knownBookies.removeAll(lostBookies);\n+                            Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n+                            handleLostBookies(lostBookies, ledgerDetails);\n                         }\n+                    } catch (BKException bke) {\n+                        LOG.error(\"Exception getting bookie list\", bke);\n+                    } catch (InterruptedException ie) {\n+                        Thread.currentThread().interrupt();\n+                        LOG.error(\"Interrupted while watching available bookies \", ie);\n+                    } catch (BKAuditException bke) {\n+                        LOG.error(\"Exception while watching available bookies\", bke);\n+                    } catch (UnavailableException ue) {\n+                        LOG.error(\"Exception while watching available bookies\", ue);\n                     }\n-                });\n-        }\n+                }\n+            });\n     }\n \n     public void start() {"},{"sha":"908a2cd979d998780fc71bb92ecc3d457aa09c08","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -269,6 +269,11 @@ public void run() {\n         executor.submit(r);\n     }\n \n+    @VisibleForTesting\n+    Auditor getAuditor() {\n+        return auditor;\n+    }\n+\n     /**\n      * Shutting down AuditorElector\n      */"},{"sha":"a7f4537c6b78aca5ceba42ac3abae5f998dcba65","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -24,6 +24,8 @@\n import java.io.IOException;\n import java.net.MalformedURLException;\n \n+import com.google.common.annotations.VisibleForTesting;\n+\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.ExitCode;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -140,6 +142,11 @@ private int getExitCode() {\n         return exitCode;\n     }\n \n+    @VisibleForTesting\n+    public Auditor getAuditor() {\n+        return auditorElector.getAuditor();\n+    }\n+\n     /** Is auto-recovery service running? */\n     public boolean isAutoRecoveryRunning() {\n         return running;"},{"sha":"32a03e224e78c44f4d69e3c18e4f1b96b2c21374","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -70,5 +70,9 @@ public CompatibilityException(String message) {\n         BKAuditException(String message, Throwable cause) {\n             super(message, cause);\n         }\n+\n+        BKAuditException(String message) {\n+            super(message);\n+        }\n     }\n }"},{"sha":"6584e2a5cfe6f9fa9491c36c708ea184007b63f9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":48,"deletions":1,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -25,6 +25,9 @@\n import java.util.Set;\n import java.util.Timer;\n import java.util.TimerTask;\n+import java.util.SortedMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.client.BKException;\n@@ -33,6 +36,7 @@\n import org.apache.bookkeeper.client.LedgerChecker;\n import org.apache.bookkeeper.client.LedgerFragment;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.client.BKException.BKBookieHandleNotAvailableException;\n import org.apache.bookkeeper.client.BKException.BKNoSuchLedgerExistsException;\n import org.apache.bookkeeper.client.BKException.BKReadException;\n@@ -195,7 +199,7 @@ private void rereplicate() throws InterruptedException, BKException,\n             }\n         }\n \n-        if (foundOpenFragments) {\n+        if (foundOpenFragments || isLastSegmentOpenAndMissingBookies(lh)) {\n             deferLedgerLockRelease(ledgerIdToReplicate);\n             return;\n         }\n@@ -213,6 +217,45 @@ private void rereplicate() throws InterruptedException, BKException,\n         }\n     }\n \n+    /**\n+     * When checking the fragments of a ledger, there is a corner case\n+     * where if the last segment/ensemble is open, but nothing has been written to\n+     * some of the quorums in the ensemble, bookies can fail without any action being\n+     * taken. This is fine, until enough bookies fail to cause a quorum to become\n+     * unavailable, by which time the ledger is unrecoverable.\n+     *\n+     * For example, if in a E3Q2, only 1 entry is written and the last bookie\n+     * in the ensemble fails, nothing has been written to it, so nothing needs to be\n+     * recovered. But if the second to last bookie fails, we've now lost quorum for\n+     * the second entry, so it's impossible to see if the second has been written or\n+     * not.\n+     *\n+     * To avoid this situation, we need to check if bookies in the final open ensemble\n+     * are unavailable, and take action if so. The action to take is to close the ledger,\n+     * after a grace period as the writting client may replace the faulty bookie on its\n+     * own.\n+     *\n+     * Missing bookies in closed ledgers are fine, as we know the last confirmed add, so\n+     * we can tell which entries are supposed to exist and rereplicate them if necessary.\n+     */\n+    private boolean isLastSegmentOpenAndMissingBookies(LedgerHandle lh) throws BKException {\n+        LedgerMetadata md = admin.getLedgerMetadata(lh);\n+        if (md.isClosed()) {\n+            return false;\n+        }\n+\n+        SortedMap<Long, ArrayList<InetSocketAddress>> ensembles\n+            = admin.getLedgerMetadata(lh).getEnsembles();\n+        ArrayList<InetSocketAddress> finalEnsemble = ensembles.get(ensembles.lastKey());\n+        Collection<InetSocketAddress> available = admin.getAvailableBookies();\n+        for (InetSocketAddress b : finalEnsemble) {\n+            if (!available.contains(b)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /** Gets the under replicated fragments */\n     private Set<LedgerFragment> getUnderreplicatedFragments(LedgerHandle lh)\n             throws InterruptedException {\n@@ -235,6 +278,10 @@ public void run() {\n                 LedgerHandle lh = null;\n                 try {\n                     lh = admin.openLedgerNoRecovery(ledgerId);\n+                    if (isLastSegmentOpenAndMissingBookies(lh)) {\n+                        lh = admin.openLedger(ledgerId);\n+                    }\n+\n                     Set<LedgerFragment> fragments = getUnderreplicatedFragments(lh);\n                     for (LedgerFragment fragment : fragments) {\n                         if (!fragment.isClosed()) {"},{"sha":"3d507eec585bce04839f0e425d0f25b12657d638","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"modified","additions":54,"deletions":9,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -25,6 +25,7 @@\n import java.util.List;\n import java.util.SortedMap;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -37,7 +38,7 @@\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n-import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n@@ -52,8 +53,7 @@\n  * Auditor-rereplication process: Auditor will publish the bookie failures,\n  * consequently ReplicationWorker will get the notifications and act on it.\n  */\n-public class BookieAutoRecoveryTest extends\n-        MultiLedgerManagerTestCase {\n+public class BookieAutoRecoveryTest extends BookKeeperClusterTestCase {\n     private static final Logger LOG = LoggerFactory\n             .getLogger(BookieAutoRecoveryTest.class);\n     private static final byte[] PASSWD = \"admin\".getBytes();\n@@ -68,15 +68,15 @@\n     private final String UNDERREPLICATED_PATH = baseClientConf\n             .getZkLedgersRootPath() + \"/underreplication/ledgers\";\n \n-    public BookieAutoRecoveryTest(String ledgerManagerFactory) throws IOException, KeeperException,\n+    public BookieAutoRecoveryTest() throws IOException, KeeperException,\n             InterruptedException, UnavailableException, CompatibilityException {\n         super(3);\n-        LOG.info(\"Running test case using ledger manager : \"\n-                + ledgerManagerFactory);\n-        // set ledger manager name\n-        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+\n+        baseConf.setLedgerManagerFactoryClassName(\n+                \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n         baseConf.setOpenLedgerRereplicationGracePeriod(openLedgerRereplicationGracePeriod);\n-        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(\n+                \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n         this.digestType = DigestType.MAC;\n         setAutoRecoveryEnabled(true);\n     }\n@@ -342,6 +342,51 @@ public void testNoSuchLedgerExists() throws Exception {\n         }\n     }\n \n+    /**\n+     * Test that if a empty ledger loses the bookie not in the quorum for entry 0, it will\n+     * still be openable when it loses enough bookies to lose a whole quorum.\n+     */\n+    @Test(timeout=10000)\n+    public void testEmptyLedgerLosesQuorumEventually() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 2, 2, DigestType.CRC32, PASSWD);\n+        CountDownLatch latch = new CountDownLatch(1);\n+        String urZNode = getUrLedgerZNode(lh);\n+        watchUrLedgerNode(urZNode, latch);\n+\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+            .getLedgerMetadata(lh).getEnsembles().get(0L).get(2);\n+        LOG.info(\"Killing last bookie, {}, in ensemble {}\", replicaToKill,\n+                 LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L));\n+        killBookie(replicaToKill);\n+\n+        getAuditor().submitAuditTask().get(); // ensure auditor runs\n+\n+        assertTrue(\"Should be marked as underreplicated\", latch.await(5, TimeUnit.SECONDS));\n+        latch = new CountDownLatch(1);\n+        Stat s = watchUrLedgerNode(urZNode, latch); // should be marked as replicated\n+        if (s != null) {\n+            assertTrue(\"Should be marked as replicated\", latch.await(10, TimeUnit.SECONDS));\n+        }\n+\n+        replicaToKill = LedgerHandleAdapter\n+            .getLedgerMetadata(lh).getEnsembles().get(0L).get(1);\n+        LOG.info(\"Killing second bookie, {}, in ensemble {}\", replicaToKill,\n+                 LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L));\n+        killBookie(replicaToKill);\n+\n+        getAuditor().submitAuditTask().get(); // ensure auditor runs\n+\n+        assertTrue(\"Should be marked as underreplicated\", latch.await(5, TimeUnit.SECONDS));\n+        latch = new CountDownLatch(1);\n+        s = watchUrLedgerNode(urZNode, latch); // should be marked as replicated\n+        if (s != null) {\n+            assertTrue(\"Should be marked as replicated\", latch.await(5, TimeUnit.SECONDS));\n+        }\n+\n+        // should be able to open ledger without issue\n+        bkc.openLedger(lh.getId(), DigestType.CRC32, PASSWD);\n+    }\n+\n     private int getReplicaIndexInLedger(LedgerHandle lh,\n             InetSocketAddress replicaToKill) {\n         SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = LedgerHandleAdapter"},{"sha":"b5525024b7f68e094382dc2116bc6bc30729a254","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/8352661299d6e4538600a1c251ab304825c4b4dd/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=8352661299d6e4538600a1c251ab304825c4b4dd","patch":"@@ -43,6 +43,7 @@\n import org.apache.bookkeeper.metastore.InMemoryMetaStore;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n+import org.apache.bookkeeper.replication.Auditor;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.commons.io.FileUtils;\n@@ -529,4 +530,14 @@ public void stopReplicationService() throws Exception {\n                     + autoRecoveryProcess.getKey().getLocalAddress());\n         }\n     }\n+\n+    public Auditor getAuditor() throws Exception {\n+        for (AutoRecoveryMain p : autoRecoveryProcesses.values()) {\n+            Auditor a = p.getAuditor();\n+            if (a != null) {\n+                return a;\n+            }\n+        }\n+        throw new Exception(\"No auditor found\");\n+    }\n }"}]}

