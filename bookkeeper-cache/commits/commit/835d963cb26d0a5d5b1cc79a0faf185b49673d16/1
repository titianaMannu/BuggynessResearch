{"sha":"835d963cb26d0a5d5b1cc79a0faf185b49673d16","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MzVkOTYzY2IyNmQwYTVkNWIxY2M3OWEwZmFmMTg1YjQ5NjczZDE2","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-01T15:19:57Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-01T15:19:57Z"},"message":"BOOKKEEPER-157. For small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1239167 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"76085aa440080c3de0159c916fa20f02175046ce","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/76085aa440080c3de0159c916fa20f02175046ce"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16","html_url":"https://github.com/apache/bookkeeper/commit/835d963cb26d0a5d5b1cc79a0faf185b49673d16","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"d5fc00dc6b0a888b68131b7dff7309687c96d07e","url":"https://api.github.com/repos/apache/bookkeeper/commits/d5fc00dc6b0a888b68131b7dff7309687c96d07e","html_url":"https://github.com/apache/bookkeeper/commit/d5fc00dc6b0a888b68131b7dff7309687c96d07e"}],"stats":{"total":106,"additions":71,"deletions":35},"files":[{"sha":"d7f803d254b4059409f308226ca10c291863c889","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/835d963cb26d0a5d5b1cc79a0faf185b49673d16/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/835d963cb26d0a5d5b1cc79a0faf185b49673d16/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=835d963cb26d0a5d5b1cc79a0faf185b49673d16","patch":"@@ -40,6 +40,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-98: collect add/read statistics on bookie server (Sijie Guo via ivank)\n \n+\tBOOKKEEPER-157:\tFor small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n+\n \n Release 4.0.0 - 2011-11-30\n "},{"sha":"9194bf9c32c21994c40a8c7601485fbbda83fa9e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","status":"modified","additions":9,"deletions":4,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/835d963cb26d0a5d5b1cc79a0faf185b49673d16/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/835d963cb26d0a5d5b1cc79a0faf185b49673d16/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java?ref=835d963cb26d0a5d5b1cc79a0faf185b49673d16","patch":"@@ -23,7 +23,12 @@\n import java.util.zip.CRC32;\n \n class CRC32DigestManager extends DigestManager {\n-    CRC32 crc = new CRC32();\n+    private final ThreadLocal<CRC32> crc = new ThreadLocal<CRC32>() {\n+        @Override\n+        protected CRC32 initialValue() {\n+            return new CRC32();\n+        }\n+    };\n \n     public CRC32DigestManager(long ledgerId) {\n         super(ledgerId);\n@@ -38,13 +43,13 @@ int getMacCodeLength() {\n     byte[] getValueAndReset() {\n         byte[] value = new byte[8];\n         ByteBuffer buf = ByteBuffer.wrap(value);\n-        buf.putLong(crc.getValue());\n-        crc.reset();\n+        buf.putLong(crc.get().getValue());\n+        crc.get().reset();\n         return value;\n     }\n \n     @Override\n     void update(byte[] data, int offset, int length) {\n-        crc.update(data, offset, length);\n+        crc.get().update(data, offset, length);\n     }\n }"},{"sha":"e3d1847a4bb5fbfdd24e5d1e210673be7525204f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":34,"deletions":22,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/835d963cb26d0a5d5b1cc79a0faf185b49673d16/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/835d963cb26d0a5d5b1cc79a0faf185b49673d16/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=835d963cb26d0a5d5b1cc79a0faf185b49673d16","patch":"@@ -244,18 +244,22 @@ public void asyncClose(CloseCallback cb, Object ctx) {\n      * @param rc\n      */\n     void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {\n- \n         bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-\n             @Override\n             public void safeRun() {\n-                metadata.length = length;\n-                // Close operation is idempotent, so no need to check if we are\n-                // already closed\n-\n-                metadata.close(lastAddConfirmed);\n-                errorOutPendingAdds(rc);\n-                lastAddPushed = lastAddConfirmed;\n+                synchronized(LedgerHandle.this) {\n+                    // synchronized on LedgerHandle.this to ensure that \n+                    // lastAddPushed can not be updated after the metadata \n+                    // is closed. \n+                    metadata.length = length;\n+\n+                    // Close operation is idempotent, so no need to check if we are\n+                    // already closed\n+\n+                    metadata.close(lastAddConfirmed);\n+                    errorOutPendingAdds(rc);\n+                    lastAddPushed = lastAddConfirmed;\n+                }\n \n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n@@ -438,22 +442,30 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n                            LedgerHandle.this, -1, ctx);\n         }\n \n+        final long entryId;\n+        final long currentLength;\n+        synchronized(this) {\n+            // synchronized on this to ensure that\n+            // the ledger isn't closed between checking and \n+            // updating lastAddPushed\n+            if (metadata.isClosed()) {\n+                LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n+                LedgerHandle.this.opCounterSem.release();\n+                cb.addComplete(BKException.Code.LedgerClosedException,\n+                               LedgerHandle.this, -1, ctx);\n+                return;\n+            }\n+\n+            entryId = ++lastAddPushed;\n+            currentLength = addToLength(length);\n+            op.setEntryId(entryId);\n+            pendingAddOps.add(op);\n+        }\n+\n         try {\n-            bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+            bk.mainWorkerPool.submit(new SafeRunnable() {\n                 @Override\n                 public void safeRun() {\n-                    if (metadata.isClosed()) {\n-                        LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                        LedgerHandle.this.opCounterSem.release();\n-                        cb.addComplete(BKException.Code.LedgerClosedException,\n-                                       LedgerHandle.this, -1, ctx);\n-                        return;\n-                    }\n-\n-                    long entryId = ++lastAddPushed;\n-                    long currentLength = addToLength(length);\n-                    op.setEntryId(entryId);\n-                    pendingAddOps.add(op);\n                     ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n                                                entryId, lastAddConfirmed, currentLength, data, offset, length);\n                     op.initiate(toSend);"},{"sha":"bbd381a86937ae7c6429ec975c9166ff0c8b3c7e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"modified","additions":26,"deletions":9,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/835d963cb26d0a5d5b1cc79a0faf185b49673d16/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/835d963cb26d0a5d5b1cc79a0faf185b49673d16/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java?ref=835d963cb26d0a5d5b1cc79a0faf185b49673d16","patch":"@@ -25,19 +25,36 @@\n import javax.crypto.Mac;\n import javax.crypto.spec.SecretKeySpec;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n class MacDigestManager extends DigestManager {\n+    final static Logger LOG = LoggerFactory.getLogger(MacDigestManager.class);\n+\n     public static String DIGEST_ALGORITHM = \"SHA-1\";\n     public static String KEY_ALGORITHM = \"HmacSHA1\";\n-    Mac mac;\n \n-    public MacDigestManager(long ledgerId, byte[] passwd) throws GeneralSecurityException {\n-        super(ledgerId);\n-        byte[] macKey = genDigest(\"mac\", passwd);\n-        SecretKeySpec keySpec = new SecretKeySpec(macKey, KEY_ALGORITHM);\n-        mac = Mac.getInstance(KEY_ALGORITHM);\n-        mac.init(keySpec);\n+    final byte[] passwd;\n \n+    private final ThreadLocal<Mac> mac = new ThreadLocal<Mac>() {\n+        @Override\n+        protected Mac initialValue() {\n+            try {\n+                byte[] macKey = genDigest(\"mac\", passwd);\n+                SecretKeySpec keySpec = new SecretKeySpec(macKey, KEY_ALGORITHM);\n+                Mac mac = Mac.getInstance(KEY_ALGORITHM);\n+                mac.init(keySpec);\n+                return mac;\n+            } catch (GeneralSecurityException gse) {\n+                LOG.error(\"Couldn't not get mac instance\", gse);\n+                return null;\n+            }\n+        }\n+    };\n \n+    public MacDigestManager(long ledgerId, byte[] passwd) throws GeneralSecurityException {\n+        super(ledgerId);\n+        this.passwd = passwd;\n     }\n \n     static byte[] genDigest(String pad, byte[] passwd) throws NoSuchAlgorithmException {\n@@ -55,12 +72,12 @@ int getMacCodeLength() {\n \n     @Override\n     byte[] getValueAndReset() {\n-        return mac.doFinal();\n+        return mac.get().doFinal();\n     }\n \n     @Override\n     void update(byte[] data, int offset, int length) {\n-        mac.update(data, offset, length);\n+        mac.get().update(data, offset, length);\n     }\n \n "}]}

