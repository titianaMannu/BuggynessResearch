{"sha":"841e7dc187b17e6cf4c437fc211f9e285191dd7c","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4NDFlN2RjMTg3YjE3ZTZjZjRjNDM3ZmMyMTFmOWUyODUxOTFkZDdj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T11:51:03Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T11:51:03Z"},"message":"BOOKKEEPER-187: Create well defined interface for LedgerCache (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1302851 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"956bd659fab11190e5b04fe258b5bb5ff05f6154","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/956bd659fab11190e5b04fe258b5bb5ff05f6154"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c","html_url":"https://github.com/apache/bookkeeper/commit/841e7dc187b17e6cf4c437fc211f9e285191dd7c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3abac4eb86d64286d057d73024a177ef300283b0","url":"https://api.github.com/repos/apache/bookkeeper/commits/3abac4eb86d64286d057d73024a177ef300283b0","html_url":"https://github.com/apache/bookkeeper/commit/3abac4eb86d64286d057d73024a177ef300283b0"}],"stats":{"total":1381,"additions":742,"deletions":639},"files":[{"sha":"f3088ffa4545bf2dfa78c1b34cab089d27224603","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -90,6 +90,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-160: bookie server needs to do compaction over entry log files to reclaim disk space (sijie via ivank)\n \n+        BOOKKEEPER-187: Create well defined interface for LedgerCache (ivank)\n+\n       hedwig-server/\n \n         BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)"},{"sha":"52e6ad9e2a983298d192c2337f00115b540646bb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -400,8 +400,9 @@ public Bookie(ServerConfiguration conf)\n \n         syncThread = new SyncThread(conf);\n         entryLogger = new EntryLogger(conf);\n-        ledgerCache = new LedgerCache(conf, ledgerManager);\n+        ledgerCache = new LedgerCacheImpl(conf, ledgerManager);\n         gcThread = new GarbageCollectorThread(conf, this.zk, ledgerCache, entryLogger,\n+                                              ledgerManager,\n                                               new EntryLogCompactionScanner());\n         // replay journals\n         readJournal();\n@@ -565,7 +566,7 @@ public void registerJMX(BKMBeanInfo parent) {\n             BKMBeanRegistry.getInstance().register(jmxBookieBean, parent);\n \n             try {\n-                jmxLedgerCacheBean = new LedgerCacheBean(this.ledgerCache);\n+                jmxLedgerCacheBean = this.ledgerCache.getJMXBean();\n                 BKMBeanRegistry.getInstance().register(jmxLedgerCacheBean, jmxBookieBean);\n             } catch (Exception e) {\n                 LOG.warn(\"Failed to register with JMX for ledger cache\", e);"},{"sha":"23f02bc354a6c46ef08a66d9a3fe8d0bb04860cd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -74,6 +74,8 @@\n     // Ledger Cache Handle\n     final LedgerCache ledgerCache;\n \n+    final LedgerManager ledgerManager;\n+\n     // ZooKeeper Client\n     final ZooKeeper zk;\n \n@@ -116,13 +118,15 @@ public GarbageCollectorThread(ServerConfiguration conf,\n                                   ZooKeeper zookeeper,\n                                   LedgerCache ledgerCache,\n                                   EntryLogger entryLogger,\n+                                  LedgerManager ledgerManager,\n                                   EntryLogScanner scanner)\n         throws IOException {\n         super(\"GarbageCollectorThread\");\n \n         this.zk = zookeeper;\n         this.ledgerCache = ledgerCache;\n         this.entryLogger = entryLogger;\n+        this.ledgerManager = ledgerManager;\n         this.scanner = scanner;\n \n         this.gcWaitTime = conf.getGcWaitTime();\n@@ -231,7 +235,7 @@ public void run() {\n      * Do garbage collection ledger index files\n      */\n     private void doGcLedgers() {\n-        ledgerCache.activeLedgerManager.garbageCollectLedgers(\n+        ledgerManager.garbageCollectLedgers(\n         new LedgerManager.GarbageCollector() {\n             @Override\n             public void gc(long ledgerId) {\n@@ -253,7 +257,7 @@ private void doGcEntryLogs() {\n             EntryLogMetadata meta = entryLogMetaMap.get(entryLogId);\n             for (Long entryLogLedger : meta.ledgersMap.keySet()) {\n                 // Remove the entry log ledger from the set if it isn't active.\n-                if (!ledgerCache.activeLedgerManager.containsActiveLedger(entryLogLedger)) {\n+                if (!ledgerManager.containsActiveLedger(entryLogLedger)) {\n                     meta.removeLedger(entryLogLedger);\n                 }\n             }"},{"sha":"923363940db892bbf0f33347429826e2a72709d9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":10,"deletions":541,"changes":551,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -21,556 +21,25 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.io.File;\n import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  * This class maps a ledger entry number into a location (entrylogid, offset) in\n  * an entry log file. It does user level caching to more efficiently manage disk\n  * head scheduling.\n  */\n-public class LedgerCache {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n-\n-    final File ledgerDirectories[];\n-\n-    public LedgerCache(ServerConfiguration conf, LedgerManager alm) {\n-        this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n-        this.openFileLimit = conf.getOpenFileLimit();\n-        this.pageSize = conf.getPageSize();\n-        this.entriesPerPage = pageSize / 8;\n-        \n-        if (conf.getPageLimit() <= 0) {\n-            // allocate half of the memory to the page cache\n-            this.pageLimit = (int)((Runtime.getRuntime().maxMemory() / 3) / this.pageSize);\n-        } else {\n-            this.pageLimit = conf.getPageLimit();\n-        }\n-        LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n-        LOG.info(\"openFileLimit is \" + openFileLimit + \", pageSize is \" + pageSize + \", pageLimit is \" + pageLimit);\n-        activeLedgerManager = alm;\n-        // Retrieve all of the active ledgers.\n-        getActiveLedgers();\n-    }\n-    /**\n-     * the list of potentially clean ledgers\n-     */\n-    LinkedList<Long> cleanLedgers = new LinkedList<Long>();\n-\n-    /**\n-     * the list of potentially dirty ledgers\n-     */\n-    LinkedList<Long> dirtyLedgers = new LinkedList<Long>();\n-\n-    HashMap<Long, FileInfo> fileInfoCache = new HashMap<Long, FileInfo>();\n-\n-    LinkedList<Long> openLedgers = new LinkedList<Long>();\n-\n-    // Manage all active ledgers in LedgerManager\n-    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n-    final LedgerManager activeLedgerManager;\n-\n-    final int openFileLimit;\n-    final int pageSize;\n-    final int pageLimit;\n-    final int entriesPerPage;\n-\n-    /**\n-     * @return page size used in ledger cache\n-     */\n-    public int getPageSize() {\n-        return pageSize;\n-    }\n-\n-    /**\n-     * @return entries per page used in ledger cache\n-     */\n-    public int getEntriesPerPage() {\n-        return entriesPerPage;\n-    }\n-\n-    /**\n-     * @return page limitation in ledger cache\n-     */\n-    public int getPageLimit() {\n-        return pageLimit;\n-    }\n-\n-    // The number of pages that have actually been used\n-    private int pageCount = 0;\n-    HashMap<Long, HashMap<Long,LedgerEntryPage>> pages = new HashMap<Long, HashMap<Long,LedgerEntryPage>>();\n-\n-    /**\n-     * @return number of page used in ledger cache\n-     */\n-    public int getNumUsedPages() {\n-        return pageCount;\n-    }\n-\n-    private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, LedgerEntryPage lep) {\n-        HashMap<Long, LedgerEntryPage> map = table.get(lep.getLedger());\n-        if (map == null) {\n-            map = new HashMap<Long, LedgerEntryPage>();\n-            table.put(lep.getLedger(), map);\n-        }\n-        map.put(lep.getFirstEntry(), lep);\n-    }\n-\n-    private static LedgerEntryPage getFromTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, Long ledger, Long firstEntry) {\n-        HashMap<Long, LedgerEntryPage> map = table.get(ledger);\n-        if (map != null) {\n-            return map.get(firstEntry);\n-        }\n-        return null;\n-    }\n-\n-    synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n-        LedgerEntryPage lep = getFromTable(pages, ledger, firstEntry);\n-        try {\n-            if (onlyDirty && lep.isClean()) {\n-                return null;\n-            }\n-            return lep;\n-        } finally {\n-            if (lep != null) {\n-                lep.usePage();\n-            }\n-        }\n-    }\n-\n-    public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n-        int offsetInPage = (int) (entry % entriesPerPage);\n-        // find the id of the first entry of the page that has the entry\n-        // we are looking for\n-        long pageEntry = entry-offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        if (lep == null) {\n-            // find a free page\n-            lep = grabCleanPage(ledger, pageEntry);\n-            updatePage(lep);\n-            synchronized(this) {\n-                putIntoTable(pages, lep);\n-            }\n-        }\n-        if (lep != null) {\n-            lep.setOffset(offset, offsetInPage*8);\n-            lep.releasePage();\n-            return;\n-        }\n-    }\n-\n-    public long getEntryOffset(long ledger, long entry) throws IOException {\n-        int offsetInPage = (int) (entry%entriesPerPage);\n-        // find the id of the first entry of the page that has the entry\n-        // we are looking for\n-        long pageEntry = entry-offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        try {\n-            if (lep == null) {\n-                lep = grabCleanPage(ledger, pageEntry);\n-                // should update page before we put it into table\n-                // otherwise we would put an empty page in it\n-                updatePage(lep);\n-                synchronized(this) {\n-                    putIntoTable(pages, lep);\n-                }\n-            }\n-            return lep.getOffset(offsetInPage*8);\n-        } finally {\n-            if (lep != null) {\n-                lep.releasePage();\n-            }\n-        }\n-    }\n-\n-    static final String getLedgerName(long ledgerId) {\n-        int parent = (int) (ledgerId & 0xff);\n-        int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(Integer.toHexString(grandParent));\n-        sb.append('/');\n-        sb.append(Integer.toHexString(parent));\n-        sb.append('/');\n-        sb.append(Long.toHexString(ledgerId));\n-        sb.append(\".idx\");\n-        return sb.toString();\n-    }\n-\n-    static final private Random rand = new Random();\n-\n-    static final private File pickDirs(File dirs[]) {\n-        return dirs[rand.nextInt(dirs.length)];\n-    }\n-\n-    FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n-        synchronized(fileInfoCache) {\n-            FileInfo fi = fileInfoCache.get(ledger);\n-            if (fi == null) {\n-                String ledgerName = getLedgerName(ledger);\n-                File lf = null;\n-                for(File d: ledgerDirectories) {\n-                    lf = new File(d, ledgerName);\n-                    if (lf.exists()) {\n-                        break;\n-                    }\n-                    lf = null;\n-                }\n-                if (lf == null) {\n-                    if (masterKey == null) {\n-                        throw new Bookie.NoLedgerException(ledger);\n-                    }\n-                    File dir = pickDirs(ledgerDirectories);\n-                    lf = new File(dir, ledgerName);\n-                    // A new ledger index file has been created for this Bookie.\n-                    // Add this new ledger to the set of active ledgers.\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"New ledger index file created for ledgerId: \" + ledger);\n-                    }\n-                    activeLedgerManager.addActiveLedger(ledger, true);\n-                }\n-                if (openLedgers.size() > openFileLimit) {\n-                    fileInfoCache.remove(openLedgers.removeFirst()).close();\n-                }\n-                fi = new FileInfo(lf, masterKey);\n-                fileInfoCache.put(ledger, fi);\n-                openLedgers.add(ledger);\n-            }\n-            if (fi != null) {\n-                fi.use();\n-            }\n-            return fi;\n-        }\n-    }\n-    private void updatePage(LedgerEntryPage lep) throws IOException {\n-        if (!lep.isClean()) {\n-            throw new IOException(\"Trying to update a dirty page\");\n-        }\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(lep.getLedger(), null);\n-            long pos = lep.getFirstEntry()*8;\n-            if (pos >= fi.size()) {\n-                lep.zeroPage();\n-            } else {\n-                lep.readPage(fi);\n-            }\n-        } finally {\n-            if (fi != null) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    void flushLedger(boolean doAll) throws IOException {\n-        synchronized(dirtyLedgers) {\n-            if (dirtyLedgers.isEmpty()) {\n-                synchronized(this) {\n-                    for(Long l: pages.keySet()) {\n-                        if (LOG.isTraceEnabled()) {\n-                            LOG.trace(\"Adding \" + Long.toHexString(l) + \" to dirty pages\");\n-                        }\n-                        dirtyLedgers.add(l);\n-                    }\n-                }\n-            }\n-            if (dirtyLedgers.isEmpty()) {\n-                return;\n-            }\n-            while(!dirtyLedgers.isEmpty()) {\n-                Long l = dirtyLedgers.removeFirst();\n-\n-                flushLedger(l);\n-\n-                if (!doAll) {\n-                    break;\n-                }\n-                // Yeild. if we are doing all the ledgers we don't want to block other flushes that\n-                // need to happen\n-                try {\n-                    dirtyLedgers.wait(1);\n-                } catch (InterruptedException e) {\n-                    // just pass it on\n-                    Thread.currentThread().interrupt();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Flush a specified ledger\n-     *\n-     * @param l\n-     *          Ledger Id\n-     * @throws IOException\n-     */\n-    private void flushLedger(long l) throws IOException {\n-        LinkedList<Long> firstEntryList;\n-        synchronized(this) {\n-            HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n-            if (pageMap == null || pageMap.isEmpty()) {\n-                return;\n-            }\n-            firstEntryList = new LinkedList<Long>();\n-            for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n-                LedgerEntryPage lep = entry.getValue();\n-                if (lep.isClean()) {\n-                    if (LOG.isTraceEnabled()) {\n-                        LOG.trace(\"Page is clean \" + lep);\n-                    }\n-                    continue;\n-                }\n-                firstEntryList.add(lep.getFirstEntry());\n-            }\n-        }\n-\n-        if (firstEntryList.size() == 0) {\n-            LOG.debug(\"Nothing to flush for ledger {}.\", l);\n-            // nothing to do\n-            return;\n-        }\n-\n-        // Now flush all the pages of a ledger\n-        List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n-        FileInfo fi = null;\n-        try {\n-            for(Long firstEntry: firstEntryList) {\n-                LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n-                if (lep != null) {\n-                    entries.add(lep);\n-                }\n-            }\n-            Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n-                    @Override\n-                    public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n-                    return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n-                    }\n-                    });\n-            ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n-            fi = getFileInfo(l, null);\n-            int start = 0;\n-            long lastOffset = -1;\n-            for(int i = 0; i < entries.size(); i++) {\n-                versions.add(i, entries.get(i).getVersion());\n-                if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n-                    // send up a sequential list\n-                    int count = i - start;\n-                    if (count == 0) {\n-                        System.out.println(\"Count cannot possibly be zero!\");\n-                    }\n-                    writeBuffers(l, entries, fi, start, count);\n-                    start = i;\n-                }\n-                lastOffset = entries.get(i).getFirstEntry();\n-            }\n-            if (entries.size()-start == 0 && entries.size() != 0) {\n-                System.out.println(\"Nothing to write, but there were entries!\");\n-            }\n-            writeBuffers(l, entries, fi, start, entries.size()-start);\n-            synchronized(this) {\n-                for(int i = 0; i < entries.size(); i++) {\n-                    LedgerEntryPage lep = entries.get(i);\n-                    lep.setClean(versions.get(i));\n-                }\n-            }\n-        } finally {\n-            for(LedgerEntryPage lep: entries) {\n-                lep.releasePage();\n-            }\n-            if (fi != null) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    private void writeBuffers(Long ledger,\n-                              List<LedgerEntryPage> entries, FileInfo fi,\n-                              int start, int count) throws IOException {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Writing \" + count + \" buffers of \" + Long.toHexString(ledger));\n-        }\n-        if (count == 0) {\n-            //System.out.println(\"Count is zero!\");\n-            return;\n-        }\n-        ByteBuffer buffs[] = new ByteBuffer[count];\n-        for(int j = 0; j < count; j++) {\n-            buffs[j] = entries.get(start+j).getPageToWrite();\n-            if (entries.get(start+j).getLedger() != ledger) {\n-                throw new IOException(\"Writing to \" + ledger + \" but page belongs to \" + entries.get(start+j).getLedger());\n-            }\n-        }\n-        long totalWritten = 0;\n-        while(buffs[buffs.length-1].remaining() > 0) {\n-            long rc = fi.write(buffs, entries.get(start+0).getFirstEntry()*8);\n-            if (rc <= 0) {\n-                throw new IOException(\"Short write to ledger \" + ledger + \" rc = \" + rc);\n-            }\n-            //System.out.println(\"Wrote \" + rc + \" to \" + ledger);\n-            totalWritten += rc;\n-        }\n-        if (totalWritten != count * pageSize) {\n-            throw new IOException(\"Short write to ledger \" + ledger + \" wrote \" + totalWritten + \" expected \" + count * pageSize);\n-        }\n-    }\n-    private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOException {\n-        if (entry % entriesPerPage != 0) {\n-            throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n-        }\n-        synchronized(this) {\n-            if (pageCount  < pageLimit) {\n-                // let's see if we can allocate something\n-                LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n-                lep.setLedger(ledger);\n-                lep.setFirstEntry(entry);\n-\n-                // note, this will not block since it is a new page\n-                lep.usePage();\n-                pageCount++;\n-                return lep;\n-            }\n-        }\n-\n-        outerLoop:\n-        while(true) {\n-            synchronized(cleanLedgers) {\n-                if (cleanLedgers.isEmpty()) {\n-                    flushLedger(false);\n-                    synchronized(this) {\n-                        for(Long l: pages.keySet()) {\n-                            cleanLedgers.add(l);\n-                        }\n-                    }\n-                }\n-                synchronized(this) {\n-                    Long cleanLedger = cleanLedgers.getFirst();\n-                    Map<Long, LedgerEntryPage> map = pages.get(cleanLedger);\n-                    if (map == null || map.isEmpty()) {\n-                        cleanLedgers.removeFirst();\n-                        continue;\n-                    }\n-                    Iterator<Map.Entry<Long, LedgerEntryPage>> it = map.entrySet().iterator();\n-                    LedgerEntryPage lep = it.next().getValue();\n-                    while((lep.inUse() || !lep.isClean())) {\n-                        if (!it.hasNext()) {\n-                            continue outerLoop;\n-                        }\n-                        lep = it.next().getValue();\n-                    }\n-                    it.remove();\n-                    if (map.isEmpty()) {\n-                        pages.remove(lep.getLedger());\n-                    }\n-                    lep.usePage();\n-                    lep.zeroPage();\n-                    lep.setLedger(ledger);\n-                    lep.setFirstEntry(entry);\n-                    return lep;\n-                }\n-            }\n-        }\n-    }\n-\n-    public long getLastEntry(long ledgerId) {\n-        long lastEntry = 0;\n-        // Find the last entry in the cache\n-        synchronized(this) {\n-            Map<Long, LedgerEntryPage> map = pages.get(ledgerId);\n-            if (map != null) {\n-                for(LedgerEntryPage lep: map.values()) {\n-                    if (lep.getFirstEntry() + entriesPerPage < lastEntry) {\n-                        continue;\n-                    }\n-                    lep.usePage();\n-                    long highest = lep.getLastEntry();\n-                    if (highest > lastEntry) {\n-                        lastEntry = highest;\n-                    }\n-                    lep.releasePage();\n-                }\n-            }\n-        }\n-\n-        return lastEntry;\n-    }\n-\n-    /**\n-     * This method will look within the ledger directories for the ledger index\n-     * files. That will comprise the set of active ledgers this particular\n-     * BookieServer knows about that have not yet been deleted by the BookKeeper\n-     * Client. This is called only once during initialization.\n-     */\n-    private void getActiveLedgers() {\n-        // Ledger index files are stored in a file hierarchy with a parent and\n-        // grandParent directory. We'll have to go two levels deep into these\n-        // directories to find the index files.\n-        for (File ledgerDirectory : ledgerDirectories) {\n-            for (File grandParent : ledgerDirectory.listFiles()) {\n-                if (grandParent.isDirectory()) {\n-                    for (File parent : grandParent.listFiles()) {\n-                        if (parent.isDirectory()) {\n-                            for (File index : parent.listFiles()) {\n-                                if (!index.isFile() || !index.getName().endsWith(\".idx\")) {\n-                                    continue;\n-                                }\n-                                // We've found a ledger index file. The file name is the\n-                                // HexString representation of the ledgerId.\n-                                String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n-                                activeLedgerManager.addActiveLedger(Long.parseLong(ledgerIdInHex, 16), true);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n+interface LedgerCache {\n+    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n+    byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n+    boolean ledgerExists(long ledgerId) throws IOException;\n \n-    /**\n-     * This method is called whenever a ledger is deleted by the BookKeeper Client\n-     * and we want to remove all relevant data for it stored in the LedgerCache.\n-     */\n-    void deleteLedger(long ledgerId) throws IOException {\n-        if (LOG.isDebugEnabled())\n-            LOG.debug(\"Deleting ledgerId: \" + ledgerId);\n-        // Delete the ledger's index file and close the FileInfo\n-        FileInfo fi = getFileInfo(ledgerId, null);\n-        fi.delete();\n-        fi.close();\n+    void putEntryOffset(long ledger, long entry, long offset) throws IOException;\n+    long getEntryOffset(long ledger, long entry) throws IOException;\n \n-        // Remove it from the active ledger manager\n-        activeLedgerManager.removeActiveLedger(ledgerId);\n+    void flushLedger(boolean doAll) throws IOException;\n+    long getLastEntry(long ledgerId) throws IOException;\n \n-        // Now remove it from all the other lists and maps.\n-        // These data structures need to be synchronized first before removing entries.\n-        synchronized(this) {\n-            pages.remove(ledgerId);\n-        }\n-        synchronized(fileInfoCache) {\n-            fileInfoCache.remove(ledgerId);\n-        }\n-        synchronized(cleanLedgers) {\n-            cleanLedgers.remove(ledgerId);\n-        }\n-        synchronized(dirtyLedgers) {\n-            dirtyLedgers.remove(ledgerId);\n-        }\n-        synchronized(openLedgers) {\n-            openLedgers.remove(ledgerId);\n-        }\n-    }\n+    void deleteLedger(long ledgerId) throws IOException;\n \n+    LedgerCacheBean getJMXBean();\n }"},{"sha":"dabc12de9b859297b4c0b8652c9e00948133c239","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","status":"modified","additions":1,"deletions":53,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -23,57 +23,5 @@\n /**\n  * Ledger Cache Bean\n  */\n-public class LedgerCacheBean implements LedgerCacheMXBean, BKMBeanInfo {\n-\n-    final LedgerCache lc;\n-\n-    public LedgerCacheBean(LedgerCache lc) {\n-        this.lc = lc;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return \"LedgerCache\";\n-    }\n-\n-    @Override\n-    public boolean isHidden() {\n-        return false;\n-    }\n-\n-    @Override\n-    public int getPageCount() {\n-        return lc.getNumUsedPages();\n-    }\n-\n-    @Override\n-    public int getPageSize() {\n-        return lc.getPageSize();\n-    }\n-\n-    @Override\n-    public int getOpenFileLimit() {\n-        return lc.openFileLimit;\n-    }\n-\n-    @Override\n-    public int getPageLimit() {\n-        return lc.getPageLimit();\n-    }\n-\n-    @Override\n-    public int getNumCleanLedgers() {\n-        return lc.cleanLedgers.size();\n-    }\n-\n-    @Override\n-    public int getNumDirtyLedgers() {\n-        return lc.dirtyLedgers.size();\n-    }\n-\n-    @Override\n-    public int getNumOpenLedgers() {\n-        return lc.openLedgers.size();\n-    }\n-\n+public interface LedgerCacheBean extends LedgerCacheMXBean, BKMBeanInfo {\n }"},{"sha":"e9bdedc96066caa6ae2f9ee2b03d1f7164a6d736","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"added","additions":712,"deletions":0,"changes":712,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -0,0 +1,712 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of LedgerCache interface.\n+ * This class serves two purposes.\n+ */\n+public class LedgerCacheImpl implements LedgerCache {\n+    private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n+\n+    final File ledgerDirectories[];\n+\n+    public LedgerCacheImpl(ServerConfiguration conf, LedgerManager alm) {\n+        this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n+        this.openFileLimit = conf.getOpenFileLimit();\n+        this.pageSize = conf.getPageSize();\n+        this.entriesPerPage = pageSize / 8;\n+\n+        if (conf.getPageLimit() <= 0) {\n+            // allocate half of the memory to the page cache\n+            this.pageLimit = (int)((Runtime.getRuntime().maxMemory() / 3) / this.pageSize);\n+        } else {\n+            this.pageLimit = conf.getPageLimit();\n+        }\n+        LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n+        LOG.info(\"openFileLimit is \" + openFileLimit + \", pageSize is \" + pageSize + \", pageLimit is \" + pageLimit);\n+        activeLedgerManager = alm;\n+        // Retrieve all of the active ledgers.\n+        getActiveLedgers();\n+    }\n+    /**\n+     * the list of potentially clean ledgers\n+     */\n+    LinkedList<Long> cleanLedgers = new LinkedList<Long>();\n+\n+    /**\n+     * the list of potentially dirty ledgers\n+     */\n+    LinkedList<Long> dirtyLedgers = new LinkedList<Long>();\n+\n+    HashMap<Long, FileInfo> fileInfoCache = new HashMap<Long, FileInfo>();\n+\n+    LinkedList<Long> openLedgers = new LinkedList<Long>();\n+\n+    // Manage all active ledgers in LedgerManager\n+    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n+    final LedgerManager activeLedgerManager;\n+\n+    final int openFileLimit;\n+    final int pageSize;\n+    final int pageLimit;\n+    final int entriesPerPage;\n+\n+    /**\n+     * @return page size used in ledger cache\n+     */\n+    public int getPageSize() {\n+        return pageSize;\n+    }\n+\n+    /**\n+     * @return entries per page used in ledger cache\n+     */\n+    public int getEntriesPerPage() {\n+        return entriesPerPage;\n+    }\n+\n+    /**\n+     * @return page limitation in ledger cache\n+     */\n+    public int getPageLimit() {\n+        return pageLimit;\n+    }\n+\n+    // The number of pages that have actually been used\n+    private int pageCount = 0;\n+    HashMap<Long, HashMap<Long,LedgerEntryPage>> pages = new HashMap<Long, HashMap<Long,LedgerEntryPage>>();\n+\n+    /**\n+     * @return number of page used in ledger cache\n+     */\n+    public int getNumUsedPages() {\n+        return pageCount;\n+    }\n+\n+    private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, LedgerEntryPage lep) {\n+        HashMap<Long, LedgerEntryPage> map = table.get(lep.getLedger());\n+        if (map == null) {\n+            map = new HashMap<Long, LedgerEntryPage>();\n+            table.put(lep.getLedger(), map);\n+        }\n+        map.put(lep.getFirstEntry(), lep);\n+    }\n+\n+    private static LedgerEntryPage getFromTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table,\n+                                                Long ledger, Long firstEntry) {\n+        HashMap<Long, LedgerEntryPage> map = table.get(ledger);\n+        if (map != null) {\n+            return map.get(firstEntry);\n+        }\n+        return null;\n+    }\n+\n+    synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n+        LedgerEntryPage lep = getFromTable(pages, ledger, firstEntry);\n+        try {\n+            if (onlyDirty && lep.isClean()) {\n+                return null;\n+            }\n+            return lep;\n+        } finally {\n+            if (lep != null) {\n+                lep.usePage();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n+        int offsetInPage = (int) (entry % entriesPerPage);\n+        // find the id of the first entry of the page that has the entry\n+        // we are looking for\n+        long pageEntry = entry-offsetInPage;\n+        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        if (lep == null) {\n+            // find a free page\n+            lep = grabCleanPage(ledger, pageEntry);\n+            updatePage(lep);\n+            synchronized(this) {\n+                putIntoTable(pages, lep);\n+            }\n+        }\n+        if (lep != null) {\n+            lep.setOffset(offset, offsetInPage*8);\n+            lep.releasePage();\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public long getEntryOffset(long ledger, long entry) throws IOException {\n+        int offsetInPage = (int) (entry%entriesPerPage);\n+        // find the id of the first entry of the page that has the entry\n+        // we are looking for\n+        long pageEntry = entry-offsetInPage;\n+        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        try {\n+            if (lep == null) {\n+                lep = grabCleanPage(ledger, pageEntry);\n+                // should update page before we put it into table\n+                // otherwise we would put an empty page in it\n+                updatePage(lep);\n+                synchronized(this) {\n+                    putIntoTable(pages, lep);\n+                }\n+            }\n+            return lep.getOffset(offsetInPage*8);\n+        } finally {\n+            if (lep != null) {\n+                lep.releasePage();\n+            }\n+        }\n+    }\n+\n+    static final String getLedgerName(long ledgerId) {\n+        int parent = (int) (ledgerId & 0xff);\n+        int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(Integer.toHexString(grandParent));\n+        sb.append('/');\n+        sb.append(Integer.toHexString(parent));\n+        sb.append('/');\n+        sb.append(Long.toHexString(ledgerId));\n+        sb.append(\".idx\");\n+        return sb.toString();\n+    }\n+\n+    static final private Random rand = new Random();\n+\n+    static final private File pickDirs(File dirs[]) {\n+        return dirs[rand.nextInt(dirs.length)];\n+    }\n+\n+    FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledger);\n+            if (fi == null) {\n+                File lf = findIndexFile(ledger);\n+                if (lf == null) {\n+                    if (masterKey == null) {\n+                        throw new Bookie.NoLedgerException(ledger);\n+                    }\n+                    File dir = pickDirs(ledgerDirectories);\n+                    String ledgerName = getLedgerName(ledger);\n+                    lf = new File(dir, ledgerName);\n+                    // A new ledger index file has been created for this Bookie.\n+                    // Add this new ledger to the set of active ledgers.\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"New ledger index file created for ledgerId: \" + ledger);\n+                    }\n+                    activeLedgerManager.addActiveLedger(ledger, true);\n+                }\n+                if (openLedgers.size() > openFileLimit) {\n+                    fileInfoCache.remove(openLedgers.removeFirst()).close();\n+                }\n+                fi = new FileInfo(lf, masterKey);\n+                fileInfoCache.put(ledger, fi);\n+                openLedgers.add(ledger);\n+            }\n+            if (fi != null) {\n+                fi.use();\n+            }\n+            return fi;\n+        }\n+    }\n+    private void updatePage(LedgerEntryPage lep) throws IOException {\n+        if (!lep.isClean()) {\n+            throw new IOException(\"Trying to update a dirty page\");\n+        }\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(lep.getLedger(), null);\n+            long pos = lep.getFirstEntry()*8;\n+            if (pos >= fi.size()) {\n+                lep.zeroPage();\n+            } else {\n+                lep.readPage(fi);\n+            }\n+        } finally {\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void flushLedger(boolean doAll) throws IOException {\n+        synchronized(dirtyLedgers) {\n+            if (dirtyLedgers.isEmpty()) {\n+                synchronized(this) {\n+                    for(Long l: pages.keySet()) {\n+                        if (LOG.isTraceEnabled()) {\n+                            LOG.trace(\"Adding \" + Long.toHexString(l) + \" to dirty pages\");\n+                        }\n+                        dirtyLedgers.add(l);\n+                    }\n+                }\n+            }\n+            if (dirtyLedgers.isEmpty()) {\n+                return;\n+            }\n+            while(!dirtyLedgers.isEmpty()) {\n+                Long l = dirtyLedgers.removeFirst();\n+\n+                flushLedger(l);\n+\n+                if (!doAll) {\n+                    break;\n+                }\n+                // Yeild. if we are doing all the ledgers we don't want to block other flushes that\n+                // need to happen\n+                try {\n+                    dirtyLedgers.wait(1);\n+                } catch (InterruptedException e) {\n+                    // just pass it on\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Flush a specified ledger\n+     *\n+     * @param l\n+     *          Ledger Id\n+     * @throws IOException\n+     */\n+    private void flushLedger(long l) throws IOException {\n+        LinkedList<Long> firstEntryList;\n+        synchronized(this) {\n+            HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n+            if (pageMap == null || pageMap.isEmpty()) {\n+                return;\n+            }\n+            firstEntryList = new LinkedList<Long>();\n+            for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n+                LedgerEntryPage lep = entry.getValue();\n+                if (lep.isClean()) {\n+                    if (LOG.isTraceEnabled()) {\n+                        LOG.trace(\"Page is clean \" + lep);\n+                    }\n+                    continue;\n+                }\n+                firstEntryList.add(lep.getFirstEntry());\n+            }\n+        }\n+\n+        if (firstEntryList.size() == 0) {\n+            LOG.debug(\"Nothing to flush for ledger {}.\", l);\n+            // nothing to do\n+            return;\n+        }\n+\n+        // Now flush all the pages of a ledger\n+        List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n+        FileInfo fi = null;\n+        try {\n+            for(Long firstEntry: firstEntryList) {\n+                LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n+                if (lep != null) {\n+                    entries.add(lep);\n+                }\n+            }\n+            Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n+                    @Override\n+                    public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n+                    return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n+                    }\n+                    });\n+            ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n+            fi = getFileInfo(l, null);\n+            int start = 0;\n+            long lastOffset = -1;\n+            for(int i = 0; i < entries.size(); i++) {\n+                versions.add(i, entries.get(i).getVersion());\n+                if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n+                    // send up a sequential list\n+                    int count = i - start;\n+                    if (count == 0) {\n+                        System.out.println(\"Count cannot possibly be zero!\");\n+                    }\n+                    writeBuffers(l, entries, fi, start, count);\n+                    start = i;\n+                }\n+                lastOffset = entries.get(i).getFirstEntry();\n+            }\n+            if (entries.size()-start == 0 && entries.size() != 0) {\n+                System.out.println(\"Nothing to write, but there were entries!\");\n+            }\n+            writeBuffers(l, entries, fi, start, entries.size()-start);\n+            synchronized(this) {\n+                for(int i = 0; i < entries.size(); i++) {\n+                    LedgerEntryPage lep = entries.get(i);\n+                    lep.setClean(versions.get(i));\n+                }\n+            }\n+        } finally {\n+            for(LedgerEntryPage lep: entries) {\n+                lep.releasePage();\n+            }\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    private void writeBuffers(Long ledger,\n+                              List<LedgerEntryPage> entries, FileInfo fi,\n+                              int start, int count) throws IOException {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Writing \" + count + \" buffers of \" + Long.toHexString(ledger));\n+        }\n+        if (count == 0) {\n+            //System.out.println(\"Count is zero!\");\n+            return;\n+        }\n+        ByteBuffer buffs[] = new ByteBuffer[count];\n+        for(int j = 0; j < count; j++) {\n+            buffs[j] = entries.get(start+j).getPageToWrite();\n+            if (entries.get(start+j).getLedger() != ledger) {\n+                throw new IOException(\"Writing to \" + ledger + \" but page belongs to \"\n+                                      + entries.get(start+j).getLedger());\n+            }\n+        }\n+        long totalWritten = 0;\n+        while(buffs[buffs.length-1].remaining() > 0) {\n+            long rc = fi.write(buffs, entries.get(start+0).getFirstEntry()*8);\n+            if (rc <= 0) {\n+                throw new IOException(\"Short write to ledger \" + ledger + \" rc = \" + rc);\n+            }\n+            //System.out.println(\"Wrote \" + rc + \" to \" + ledger);\n+            totalWritten += rc;\n+        }\n+        if (totalWritten != count * pageSize) {\n+            throw new IOException(\"Short write to ledger \" + ledger + \" wrote \" + totalWritten\n+                                  + \" expected \" + count * pageSize);\n+        }\n+    }\n+    private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOException {\n+        if (entry % entriesPerPage != 0) {\n+            throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n+        }\n+        synchronized(this) {\n+            if (pageCount  < pageLimit) {\n+                // let's see if we can allocate something\n+                LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n+                lep.setLedger(ledger);\n+                lep.setFirstEntry(entry);\n+\n+                // note, this will not block since it is a new page\n+                lep.usePage();\n+                pageCount++;\n+                return lep;\n+            }\n+        }\n+\n+        outerLoop:\n+        while(true) {\n+            synchronized(cleanLedgers) {\n+                if (cleanLedgers.isEmpty()) {\n+                    flushLedger(false);\n+                    synchronized(this) {\n+                        for(Long l: pages.keySet()) {\n+                            cleanLedgers.add(l);\n+                        }\n+                    }\n+                }\n+                synchronized(this) {\n+                    Long cleanLedger = cleanLedgers.getFirst();\n+                    Map<Long, LedgerEntryPage> map = pages.get(cleanLedger);\n+                    if (map == null || map.isEmpty()) {\n+                        cleanLedgers.removeFirst();\n+                        continue;\n+                    }\n+                    Iterator<Map.Entry<Long, LedgerEntryPage>> it = map.entrySet().iterator();\n+                    LedgerEntryPage lep = it.next().getValue();\n+                    while((lep.inUse() || !lep.isClean())) {\n+                        if (!it.hasNext()) {\n+                            continue outerLoop;\n+                        }\n+                        lep = it.next().getValue();\n+                    }\n+                    it.remove();\n+                    if (map.isEmpty()) {\n+                        pages.remove(lep.getLedger());\n+                    }\n+                    lep.usePage();\n+                    lep.zeroPage();\n+                    lep.setLedger(ledger);\n+                    lep.setFirstEntry(entry);\n+                    return lep;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getLastEntry(long ledgerId) throws IOException {\n+        long lastEntry = 0;\n+        // Find the last entry in the cache\n+        synchronized(this) {\n+            Map<Long, LedgerEntryPage> map = pages.get(ledgerId);\n+            if (map != null) {\n+                for(LedgerEntryPage lep: map.values()) {\n+                    if (lep.getFirstEntry() + entriesPerPage < lastEntry) {\n+                        continue;\n+                    }\n+                    lep.usePage();\n+                    long highest = lep.getLastEntry();\n+                    if (highest > lastEntry) {\n+                        lastEntry = highest;\n+                    }\n+                    lep.releasePage();\n+                }\n+            }\n+        }\n+\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            long size = fi.size();\n+            // make sure the file size is aligned with index entry size\n+            // otherwise we may read incorret data\n+            if (0 != size % 8) {\n+                LOG.warn(\"Index file of ledger {} is not aligned with index entry size.\", ledgerId);\n+                size = size - size % 8;\n+            }\n+            // we may not have the last entry in the cache\n+            if (size > lastEntry*8) {\n+                ByteBuffer bb = ByteBuffer.allocate(getPageSize());\n+                long position = size - getPageSize();\n+                if (position < 0) {\n+                    position = 0;\n+                }\n+                fi.read(bb, position);\n+                bb.flip();\n+                long startingEntryId = position/8;\n+                for(int i = getEntriesPerPage()-1; i >= 0; i--) {\n+                    if (bb.getLong(i*8) != 0) {\n+                        if (lastEntry < startingEntryId+i) {\n+                            lastEntry = startingEntryId+i;\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+\n+        return lastEntry;\n+    }\n+\n+    /**\n+     * This method will look within the ledger directories for the ledger index\n+     * files. That will comprise the set of active ledgers this particular\n+     * BookieServer knows about that have not yet been deleted by the BookKeeper\n+     * Client. This is called only once during initialization.\n+     */\n+    private void getActiveLedgers() {\n+        // Ledger index files are stored in a file hierarchy with a parent and\n+        // grandParent directory. We'll have to go two levels deep into these\n+        // directories to find the index files.\n+        for (File ledgerDirectory : ledgerDirectories) {\n+            for (File grandParent : ledgerDirectory.listFiles()) {\n+                if (grandParent.isDirectory()) {\n+                    for (File parent : grandParent.listFiles()) {\n+                        if (parent.isDirectory()) {\n+                            for (File index : parent.listFiles()) {\n+                                if (!index.isFile() || !index.getName().endsWith(\".idx\")) {\n+                                    continue;\n+                                }\n+                                // We've found a ledger index file. The file name is the\n+                                // HexString representation of the ledgerId.\n+                                String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n+                                activeLedgerManager.addActiveLedger(Long.parseLong(ledgerIdInHex, 16), true);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is called whenever a ledger is deleted by the BookKeeper Client\n+     * and we want to remove all relevant data for it stored in the LedgerCache.\n+     */\n+    @Override\n+    public void deleteLedger(long ledgerId) throws IOException {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Deleting ledgerId: \" + ledgerId);\n+        // Delete the ledger's index file and close the FileInfo\n+        FileInfo fi = getFileInfo(ledgerId, null);\n+        fi.delete();\n+        fi.close();\n+\n+        // Remove it from the active ledger manager\n+        activeLedgerManager.removeActiveLedger(ledgerId);\n+\n+        // Now remove it from all the other lists and maps.\n+        // These data structures need to be synchronized first before removing entries.\n+        synchronized(this) {\n+            pages.remove(ledgerId);\n+        }\n+        synchronized(fileInfoCache) {\n+            fileInfoCache.remove(ledgerId);\n+        }\n+        synchronized(cleanLedgers) {\n+            cleanLedgers.remove(ledgerId);\n+        }\n+        synchronized(dirtyLedgers) {\n+            dirtyLedgers.remove(ledgerId);\n+        }\n+        synchronized(openLedgers) {\n+            openLedgers.remove(ledgerId);\n+        }\n+    }\n+\n+    private File findIndexFile(long ledgerId) throws IOException {\n+        String ledgerName = getLedgerName(ledgerId);\n+        for(File d: ledgerDirectories) {\n+            File lf = new File(d, ledgerName);\n+            if (lf.exists()) {\n+                return lf;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledgerId);\n+            if (fi == null) {\n+                File lf = findIndexFile(ledgerId);\n+                if (lf == null) {\n+                    throw new Bookie.NoLedgerException(ledgerId);\n+                }\n+                if (openLedgers.size() > openFileLimit) {\n+                    fileInfoCache.remove(openLedgers.removeFirst()).close();\n+                }\n+                fi = new FileInfo(lf, null);\n+                byte[] key = fi.getMasterKey();\n+                fileInfoCache.put(ledgerId, fi);\n+                openLedgers.add(ledgerId);\n+                return key;\n+            }\n+            return fi.getMasterKey();\n+        }\n+    }\n+\n+    @Override\n+    public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n+        getFileInfo(ledgerId, masterKey);\n+    }\n+\n+    @Override\n+    public boolean ledgerExists(long ledgerId) throws IOException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledgerId);\n+            if (fi == null) {\n+                File lf = findIndexFile(ledgerId);\n+                if (lf == null) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public LedgerCacheBean getJMXBean() {\n+        return new LedgerCacheBean() {\n+            @Override\n+            public String getName() {\n+                return \"LedgerCache\";\n+            }\n+\n+            @Override\n+            public boolean isHidden() {\n+                return false;\n+            }\n+\n+            @Override\n+            public int getPageCount() {\n+                return getNumUsedPages();\n+            }\n+\n+            @Override\n+            public int getPageSize() {\n+                return getPageSize();\n+            }\n+\n+            @Override\n+            public int getOpenFileLimit() {\n+                return openFileLimit;\n+            }\n+\n+            @Override\n+            public int getPageLimit() {\n+                return getPageLimit();\n+            }\n+\n+            @Override\n+            public int getNumCleanLedgers() {\n+                return cleanLedgers.size();\n+            }\n+\n+            @Override\n+            public int getNumDirtyLedgers() {\n+                return dirtyLedgers.size();\n+            }\n+\n+            @Override\n+            public int getNumOpenLedgers() {\n+                return openLedgers.size();\n+            }\n+        };\n+    }\n+}"},{"sha":"8e8d3dad1182ff398165471d1ec9bf614d7ef969","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":5,"deletions":38,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -37,11 +37,13 @@\n  */\n public class LedgerDescriptor {\n     final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n-    LedgerCache ledgerCache;\n+    LedgerCacheImpl ledgerCache;\n     LedgerDescriptor(long ledgerId, EntryLogger entryLogger, LedgerCache ledgerCache) {\n         this.ledgerId = ledgerId;\n         this.entryLogger = entryLogger;\n-        this.ledgerCache = ledgerCache;\n+        // This cast is only here until ledgerDescriptor changes go in to make it\n+        // unnecessary\n+        this.ledgerCache = (LedgerCacheImpl)ledgerCache;\n     }\n \n     private byte[] masterKey = null;\n@@ -136,42 +138,7 @@ ByteBuffer readEntry(long entryId) throws IOException {\n          * If entryId is -1, then return the last written.\n          */\n         if (entryId == -1) {\n-            long lastEntry = ledgerCache.getLastEntry(ledgerId);\n-            FileInfo fi = null;\n-            try {\n-                fi = ledgerCache.getFileInfo(ledgerId, null);\n-                long size = fi.size();\n-                // make sure the file size is aligned with index entry size\n-                // otherwise we may read incorret data\n-                if (0 != size % 8) {\n-                    LOG.warn(\"Index file of ledger {} is not aligned with index entry size.\", ledgerId);\n-                    size = size - size % 8;\n-                }\n-                // we may not have the last entry in the cache\n-                if (size > lastEntry*8) {\n-                    ByteBuffer bb = ByteBuffer.allocate(ledgerCache.getPageSize());\n-                    long position = size - ledgerCache.getPageSize();\n-                    if (position < 0) {\n-                        position = 0;\n-                    }\n-                    fi.read(bb, position);\n-                    bb.flip();\n-                    long startingEntryId = position/8;\n-                    for(int i = ledgerCache.getEntriesPerPage()-1; i >= 0; i--) {\n-                        if (bb.getLong(i*8) != 0) {\n-                            if (lastEntry < startingEntryId+i) {\n-                                lastEntry = startingEntryId+i;\n-                            }\n-                            break;\n-                        }\n-                    }\n-                }\n-            } finally {\n-                if (fi != null) {\n-                    fi.release();\n-                }\n-            }\n-            entryId = lastEntry;\n+            entryId = ledgerCache.getLastEntry(ledgerId);\n         }\n \n         offset = ledgerCache.getEntryOffset(ledgerId, entryId);"},{"sha":"75b025996c53eb1ad7ced3fa90f75dd8ac092821","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -59,7 +59,7 @@\n     private void writeIndexFileForLedger(File indexDir, long ledgerId,\n                                          byte[] masterKey)\n             throws Exception {\n-        File fn = new File(indexDir, LedgerCache.getLedgerName(ledgerId));\n+        File fn = new File(indexDir, LedgerCacheImpl.getLedgerName(ledgerId));\n         fn.getParentFile().mkdirs();\n         FileInfo fi = new FileInfo(fn, masterKey);\n         // force creation of index file\n@@ -70,7 +70,7 @@ private void writeIndexFileForLedger(File indexDir, long ledgerId,\n     private void writePartialIndexFileForLedger(File indexDir, long ledgerId,\n                                                 byte[] masterKey, boolean truncateToMasterKey)\n             throws Exception {\n-        File fn = new File(indexDir, LedgerCache.getLedgerName(ledgerId));\n+        File fn = new File(indexDir, LedgerCacheImpl.getLedgerName(ledgerId));\n         fn.getParentFile().mkdirs();\n         FileInfo fi = new FileInfo(fn, masterKey);\n         // force creation of index file"},{"sha":"d7824a9066089982de16336e10f24d573a0a5606","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/841e7dc187b17e6cf4c437fc211f9e285191dd7c/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java?ref=841e7dc187b17e6cf4c437fc211f9e285191dd7c","patch":"@@ -72,7 +72,7 @@ static void writeLedgerDir(File dir,\n             throws Exception {\n         long ledgerId = 1;\n \n-        File fn = new File(dir, LedgerCache.getLedgerName(ledgerId));\n+        File fn = new File(dir, LedgerCacheImpl.getLedgerName(ledgerId));\n         fn.getParentFile().mkdirs();\n         FileInfo fi = new FileInfo(fn, masterKey);\n         // force creation of index file"}]}

