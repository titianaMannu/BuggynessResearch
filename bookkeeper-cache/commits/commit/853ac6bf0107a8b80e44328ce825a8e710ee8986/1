{"sha":"853ac6bf0107a8b80e44328ce825a8e710ee8986","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4NTNhYzZiZjAxMDdhOGI4MGU0NDMyOGNlODI1YThlNzEwZWU4OTg2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-01T13:36:31Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-01T13:36:31Z"},"message":"BOOKKEEPER-143: Add SSL support for hedwig cpp client (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1392319 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dee55a8fa8a6ea5a49a15c65487be760c67eece5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dee55a8fa8a6ea5a49a15c65487be760c67eece5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/853ac6bf0107a8b80e44328ce825a8e710ee8986","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/853ac6bf0107a8b80e44328ce825a8e710ee8986","html_url":"https://github.com/apache/bookkeeper/commit/853ac6bf0107a8b80e44328ce825a8e710ee8986","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/853ac6bf0107a8b80e44328ce825a8e710ee8986/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"eba338eb398f8a22987c6bd8352bf2d649fb7c33","url":"https://api.github.com/repos/apache/bookkeeper/commits/eba338eb398f8a22987c6bd8352bf2d649fb7c33","html_url":"https://github.com/apache/bookkeeper/commit/eba338eb398f8a22987c6bd8352bf2d649fb7c33"}],"stats":{"total":1399,"additions":1091,"deletions":308},"files":[{"sha":"f86ef707926a0803d87d3914b5559208a1517a13","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -176,6 +176,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-364: re-factor hedwig java client to support both one-subscription-per-channel and multiplex-subscriptions-per-channel. (sijie via ivank)\n \n+        BOOKKEEPER-143: Add SSL support for hedwig cpp client (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"391a16eaa3e5e5765a1dd508bdaf50c67bb81ca8","filename":"hedwig-client/src/main/cpp/Makefile.am","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/Makefile.am?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -27,3 +27,12 @@ pkgconfigdir = $(libdir)/pkgconfig\n nodist_pkgconfig_DATA = hedwig-0.1.pc\n \n EXTRA_DIST = $(DX_CONFIG) doc/html\n+\n+check:\n+\tcd test; make check\n+\n+sslcheck:\n+\tcd test; make sslcheck\n+\n+simplecheck:\n+\tcd test; make simplecheck"},{"sha":"efc6e05c96107f4fd10c20103edc1e36935b4aee","filename":"hedwig-client/src/main/cpp/configure.ac","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/configure.ac","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/configure.ac","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/configure.ac?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -26,7 +26,7 @@ AC_LANG([C++])\n AC_CONFIG_FILES([Makefile lib/Makefile test/Makefile hedwig-0.1.pc])\n AC_PROG_LIBTOOL\n AC_CONFIG_MACRO_DIR([m4])\n-PKG_CHECK_MODULES([DEPS], [liblog4cxx protobuf])\n+PKG_CHECK_MODULES([DEPS], [liblog4cxx protobuf openssl])\n \n GTEST_LIB_CHECK([1.5.0], [AC_MSG_RESULT([GoogleTest found, Tests Enabled])],\n                          [AC_MSG_WARN([GoogleTest not found, Tests disabled])])"},{"sha":"a11355ca221b5a9d5c157437e1fb1c556c2e6f52","filename":"hedwig-client/src/main/cpp/inc/hedwig/client.h","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/inc/hedwig/client.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/inc/hedwig/client.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/client.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -47,6 +47,8 @@ namespace Hedwig {\n     static const std::string SYNC_REQUEST_TIMEOUT;\n     static const std::string SUBSCRIBER_AUTOCONSUME;\n     static const std::string NUM_DISPATCH_THREADS;\n+    static const std::string RUN_AS_SSL_MODE;\n+    static const std::string SSL_PEM_FILE;\n     /**\n      * The maximum number of messages the hub will queue for subscriptions\n      * created using this configuration. The hub will always queue the most"},{"sha":"66eec527f64f315a359a0f27dacf828dc19c1000","filename":"hedwig-client/src/main/cpp/lib/channel.cpp","status":"modified","additions":473,"deletions":133,"changes":606,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/channel.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/channel.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -15,7 +15,6 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\t\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n@@ -48,63 +47,109 @@ static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n \n-DuplexChannel::DuplexChannel(EventDispatcher& dispatcher, const HostAddress& addr, \n-\t\t\t     const Configuration& cfg, const ChannelHandlerPtr& handler)\n-  : dispatcher(dispatcher), address(addr), handler(handler), service(dispatcher.getService()),\n-    socket(service), instream(&in_buf), copy_buf(NULL), copy_buf_length(0),\n-    state(UNINITIALISED), receiving(false), reading(false), sending(false)\n-{\n-  LOG4CXX_DEBUG(logger, \"Creating DuplexChannel(\" << this << \")\");\n+const bool DEFAULT_SSL_ENABLED = false;\n+const std::string DEFAULT_SSL_PEM_FILE = \"\";\n+\n+AbstractDuplexChannel::AbstractDuplexChannel(IOServicePtr& service,\n+                                             const HostAddress& addr, \n+                                             const ChannelHandlerPtr& handler)\n+  : address(addr), handler(handler), service(service->getService()),\n+    instream(&in_buf), copy_buf(NULL), copy_buf_length(0),\n+    state(UNINITIALISED), receiving(false), reading(false), sending(false),\n+    closed(false)\n+{}\n+\n+AbstractDuplexChannel::~AbstractDuplexChannel() {\n+  free(copy_buf);\n+  copy_buf = NULL;\n+  copy_buf_length = 0;\n+\n+  LOG4CXX_INFO(logger, \"Destroying DuplexChannel(\" << this << \")\");\n }\n \n-/*static*/ void DuplexChannel::connectCallbackHandler(DuplexChannelPtr channel,\n-\t\t\t\t\t\t      const boost::system::error_code& error) {\n-  LOG4CXX_DEBUG(logger,\"DuplexChannel::connectCallbackHandler error(\" << error \n-\t\t<< \") channel(\" << channel.get() << \")\");\n+/*static*/ void AbstractDuplexChannel::connectCallbackHandler(\n+                  AbstractDuplexChannelPtr channel,\n+                  OperationCallbackPtr callback,\n+                  const boost::system::error_code& error) {\n+  channel->doAfterConnect(callback, error);\n+}\n \n+void AbstractDuplexChannel::connect() {\n+  connect(OperationCallbackPtr());\n+}\n+\n+void AbstractDuplexChannel::connect(const OperationCallbackPtr& callback) {  \n+  setState(CONNECTING);\n+  doConnect(callback);\n+}\n+\n+void AbstractDuplexChannel::doAfterConnect(const OperationCallbackPtr& callback,\n+                                           const boost::system::error_code& error) {\n   if (error) {\n-    channel->channelDisconnected(ChannelConnectException());\n-    channel->setState(DEAD);\n+    LOG4CXX_ERROR(logger, \"Channel \" << this << \" connect error : \" << error.message().c_str());\n+    channelConnectFailed(ChannelConnectException(), callback);\n     return;\n   }\n \n-  channel->setState(CONNECTED);\n-\n+  // set no delay option\n   boost::system::error_code ec;\n-  boost::asio::ip::tcp::no_delay option(true);\n-\n-  channel->socket.set_option(option, ec);\n+  setSocketOption(ec);\n   if (ec) {\n-    channel->channelDisconnected(ChannelSetupException());\n-    channel->setState(DEAD);\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" set up socket error : \" << ec.message().c_str());\n+    channelConnectFailed(ChannelSetupException(), callback);\n     return;\n   } \n-  \n-  channel->startSending();\n-  channel->startReceiving();\n+\n+  boost::asio::ip::tcp::endpoint localEp;\n+  boost::asio::ip::tcp::endpoint remoteEp;\n+  localEp = getLocalAddress(ec);\n+  remoteEp = getRemoteAddress(ec);\n+\n+  if (!ec) {\n+    LOG4CXX_INFO(logger, \"Channel \" << this << \" connected :\"\n+                         << localEp.address().to_string() << \":\" << localEp.port() << \"=>\"\n+                         << remoteEp.address().to_string() << \":\" << remoteEp.port());\n+    // update ip address since if might connect to VIP\n+    address.updateIP(remoteEp.address().to_v4().to_ulong());\n+  }\n+  // the channel is connected\n+  channelConnected(callback);\n }\n \n-void DuplexChannel::connect() {  \n-  setState(CONNECTING);\n+void AbstractDuplexChannel::channelConnectFailed(const std::exception& e,\n+                                                 const OperationCallbackPtr& callback) {\n+  channelDisconnected(e);\n+  setState(DEAD);\n+  if (callback.get()) {\n+    callback->operationFailed(e);\n+  }\n+}\n \n-  boost::asio::ip::tcp::endpoint endp(boost::asio::ip::address_v4(address.ip()), address.port());\n-  boost::system::error_code error = boost::asio::error::host_not_found;\n+void AbstractDuplexChannel::channelConnected(const OperationCallbackPtr& callback) {\n+  // for normal channel, we have done here\n+  setState(CONNECTED);\n+  if (callback.get()) {\n+    callback->operationComplete();\n+  }\n \n-  socket.async_connect(endp, boost::bind(&DuplexChannel::connectCallbackHandler, \n-\t\t\t\t\t shared_from_this(), \n-\t\t\t\t\t boost::asio::placeholders::error)); \n+  // enable sending & receiving\n+  startSending();\n+  startReceiving();\n }\n \n-/*static*/ void DuplexChannel::messageReadCallbackHandler(DuplexChannelPtr channel, \n-\t\t\t\t\t\t\t  std::size_t message_size,\n-\t\t\t\t\t\t\t  const boost::system::error_code& error, \n-\t\t\t\t\t\t\t  std::size_t bytes_transferred) {\n+/*static*/ void AbstractDuplexChannel::messageReadCallbackHandler(\n+                AbstractDuplexChannelPtr channel, \n+                std::size_t message_size,\n+                const boost::system::error_code& error, \n+                std::size_t bytes_transferred) {\n   LOG4CXX_DEBUG(logger, \"DuplexChannel::messageReadCallbackHandler \" << error << \", \" \n-\t\t<< bytes_transferred << \" channel(\" << channel.get() << \")\");\n-\t\t  \n+                        << bytes_transferred << \" channel(\" << channel.get() << \")\");\n+\n   if (error) {\n-    LOG4CXX_ERROR(logger, \"Invalid read error (\" << error << \") bytes_transferred (\" \n-\t\t  << bytes_transferred << \") channel(\" << channel.get() << \")\");\n+    if (!channel->isClosed()) {\n+      LOG4CXX_INFO(logger, \"Invalid read error (\" << error << \") bytes_transferred (\" \n+                           << bytes_transferred << \") channel(\" << channel.get() << \")\");\n+    }\n     channel->channelDisconnected(ChannelReadException());\n     return;\n   }\n@@ -114,6 +159,10 @@ void DuplexChannel::connect() {\n     channel->copy_buf = (char*)realloc(channel->copy_buf, channel->copy_buf_length);\n     if (channel->copy_buf == NULL) {\n       LOG4CXX_ERROR(logger, \"Error allocating buffer. channel(\" << channel.get() << \")\");\n+      // if failed to realloc memory, we should disconnect the channel.\n+      // then it would enter disconnect logic, which would close channel and release\n+      // its resources includes the copy_buf memory.\n+      channel->channelDisconnected(ChannelOutOfMemoryException());\n       return;\n     }\n   }\n@@ -122,15 +171,13 @@ void DuplexChannel::connect() {\n   PubSubResponsePtr response(new PubSubResponse());\n   bool err = response->ParseFromArray(channel->copy_buf, message_size);\n \n-\n   if (!err) {\n     LOG4CXX_ERROR(logger, \"Error parsing message. channel(\" << channel.get() << \")\");\n-\n     channel->channelDisconnected(ChannelReadException());\n     return;\n   } else {\n     LOG4CXX_DEBUG(logger,  \"channel(\" << channel.get() << \") : \" << channel->in_buf.size() \n-\t\t  << \" bytes left in buffer\");\n+                           << \" bytes left in buffer\");\n   }\n \n   ChannelHandlerPtr h;\n@@ -159,25 +206,28 @@ void DuplexChannel::connect() {\n     h->messageReceived(channel, response);\n   }\n \n-  DuplexChannel::readSize(channel);\n+  AbstractDuplexChannel::readSize(channel);\n }\n \n-/*static*/ void DuplexChannel::sizeReadCallbackHandler(DuplexChannelPtr channel, \n-\t\t\t\t\t\t       const boost::system::error_code& error, \n-\t\t\t\t\t\t       std::size_t bytes_transferred) {\n+/*static*/ void AbstractDuplexChannel::sizeReadCallbackHandler(\n+                   AbstractDuplexChannelPtr channel, \n+                   const boost::system::error_code& error, \n+                   std::size_t bytes_transferred) {\n   LOG4CXX_DEBUG(logger, \"DuplexChannel::sizeReadCallbackHandler \" << error << \", \" \n-\t\t<< bytes_transferred << \" channel(\" << channel.get() << \")\");\n+                        << bytes_transferred << \" channel(\" << channel.get() << \")\");\n \n   if (error) {\n-    LOG4CXX_ERROR(logger, \"Invalid read error (\" << error << \") bytes_transferred (\" \n-\t\t  << bytes_transferred << \") channel(\" << channel.get() << \")\");\n+    if (!channel->isClosed()) {\n+      LOG4CXX_INFO(logger, \"Invalid read error (\" << error << \") bytes_transferred (\" \n+                           << bytes_transferred << \") channel(\" << channel.get() << \")\");\n+    }\n     channel->channelDisconnected(ChannelReadException());\n     return;\n   }\n   \n   if (channel->in_buf.size() < sizeof(uint32_t)) {\n     LOG4CXX_ERROR(logger, \"Not enough data in stream. Must have been an error reading. \" \n-\t\t  << \" Closing channel(\" << channel.get() << \")\");\n+                          << \" Closing channel(\" << channel.get() << \")\");\n     channel->channelDisconnected(ChannelReadException());\n     return;\n   }\n@@ -189,40 +239,30 @@ void DuplexChannel::connect() {\n \n   int toread = size - channel->in_buf.size();\n   LOG4CXX_DEBUG(logger, \" size of incoming message \" << size << \", currently in buffer \" \n-\t\t<< channel->in_buf.size() << \" channel(\" << channel.get() << \")\");\n+                        << channel->in_buf.size() << \" channel(\" << channel.get() << \")\");\n   if (toread <= 0) {\n-    DuplexChannel::messageReadCallbackHandler(channel, size, error, 0);\n+    AbstractDuplexChannel::messageReadCallbackHandler(channel, size, error, 0);\n   } else {\n-    boost::asio::async_read(channel->socket, channel->in_buf,\n-\t\t\t    boost::asio::transfer_at_least(toread),\n-\t\t\t    boost::bind(&DuplexChannel::messageReadCallbackHandler, \n-\t\t\t\t\tchannel, size,\n-\t\t\t\t\tboost::asio::placeholders::error, \n-\t\t\t\t\tboost::asio::placeholders::bytes_transferred));\n+    channel->readMsgBody(channel->in_buf, toread, size);\n   }\n }\n \n-/*static*/ void DuplexChannel::readSize(DuplexChannelPtr channel) {\n+/*static*/ void AbstractDuplexChannel::readSize(AbstractDuplexChannelPtr channel) {\n   int toread = sizeof(uint32_t) - channel->in_buf.size();\n   LOG4CXX_DEBUG(logger, \" size of incoming message \" << sizeof(uint32_t) \n-\t\t<< \", currently in buffer \" << channel->in_buf.size() \n-\t\t<< \" channel(\" << channel.get() << \")\");\n+                        << \", currently in buffer \" << channel->in_buf.size() \n+                        << \" channel(\" << channel.get() << \")\");\n \n   if (toread < 0) {\n-    DuplexChannel::sizeReadCallbackHandler(channel, boost::system::error_code(), 0);\n+    AbstractDuplexChannel::sizeReadCallbackHandler(channel, boost::system::error_code(), 0);\n   } else {\n-    //  in_buf_size.prepare(sizeof(uint32_t));\n-    boost::asio::async_read(channel->socket, channel->in_buf, \n-\t\t\t    boost::asio::transfer_at_least(sizeof(uint32_t)),\n-\t\t\t    boost::bind(&DuplexChannel::sizeReadCallbackHandler, \n-\t\t\t\t\tchannel, \n-\t\t\t\t\tboost::asio::placeholders::error, \n-\t\t\t\t\tboost::asio::placeholders::bytes_transferred));\n+    channel->readMsgSize(channel->in_buf);\n   }\n }\n \n-void DuplexChannel::startReceiving() {\n-  LOG4CXX_DEBUG(logger, \"DuplexChannel::startReceiving channel(\" << this << \") currently receiving = \" << receiving);\n+void AbstractDuplexChannel::startReceiving() {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::startReceiving channel(\" << this\n+                        << \") currently receiving = \" << receiving);\n \n   PubSubResponsePtr response;\n   bool inReadingState;\n@@ -271,22 +311,26 @@ void DuplexChannel::startReceiving() {\n \n   // if channel is not in reading state, #readSize\n   if (!inReadingState) {\n-    DuplexChannel::readSize(shared_from_this());\n+    AbstractDuplexChannel::readSize(shared_from_this());\n   }\n }\n \n-bool DuplexChannel::isReceiving() {\n+bool AbstractDuplexChannel::isReceiving() {\n   return receiving;\n }\n \n-void DuplexChannel::stopReceiving() {\n+bool AbstractDuplexChannel::isClosed() {\n+  return closed;\n+}\n+\n+void AbstractDuplexChannel::stopReceiving() {\n   LOG4CXX_DEBUG(logger, \"DuplexChannel::stopReceiving channel(\" << this << \")\");\n   \n   boost::lock_guard<boost::mutex> lock(receiving_lock);\n   receiving = false;\n }\n \n-void DuplexChannel::startSending() {\n+void AbstractDuplexChannel::startSending() {\n   {\n     boost::shared_lock<boost::shared_mutex> lock(state_lock);\n     if (state != CONNECTED) {\n@@ -298,7 +342,7 @@ void DuplexChannel::startSending() {\n   if (sending) {\n     return;\n   }\n-  LOG4CXX_DEBUG(logger, \"DuplexChannel::startSending channel(\" << this << \")\");\n+  LOG4CXX_DEBUG(logger, \"AbstractDuplexChannel::startSending channel(\" << this << \")\");\n   \n   WriteRequest w;\n   { \n@@ -323,20 +367,14 @@ void DuplexChannel::startSending() {\n     return;\n   }\n \n-  boost::asio::async_write(socket, out_buf, \n-\t\t\t   boost::bind(&DuplexChannel::writeCallbackHandler, \n-\t\t\t\t       shared_from_this(), \n-\t\t\t\t       w.second,\n-\t\t\t\t       boost::asio::placeholders::error, \n-\t\t\t\t       boost::asio::placeholders::bytes_transferred));\n+  writeBuffer(out_buf, w.second);\n }\n \n-\n-const HostAddress& DuplexChannel::getHostAddress() const {\n+const HostAddress& AbstractDuplexChannel::getHostAddress() const {\n   return address;\n }\n \n-void DuplexChannel::channelDisconnected(const std::exception& e) {\n+void AbstractDuplexChannel::channelDisconnected(const std::exception& e) {\n   setState(DEAD);\n   \n   {\n@@ -360,54 +398,39 @@ void DuplexChannel::channelDisconnected(const std::exception& e) {\n   }\n }\n \n-void DuplexChannel::kill() {\n-  LOG4CXX_DEBUG(logger, \"Killing duplex channel (\" << this << \")\");\n-    \n-  bool connected = false;\n+void AbstractDuplexChannel::close() {\n   {\n     boost::shared_lock<boost::shared_mutex> statelock(state_lock);\n-    connected = (state == CONNECTING || state == CONNECTED);\n+    state = DEAD;\n   }\n \n-  boost::lock_guard<boost::shared_mutex> lock(destruction_lock);\n-  if (connected) {\n-    setState(DEAD);\n-    \n-    boost::system::error_code ec;\n-    socket.cancel(ec);\n-    if (ec) {\n-      LOG4CXX_WARN(logger, \"Channel \" << this << \" canceling io error : \" << ec.message().c_str());\n-    }\n-    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n-    if (ec) {\n-      LOG4CXX_WARN(logger, \"Channel \" << this << \" shutdown error : \" << ec.message().c_str());\n-    }\n-    socket.close(ec);\n-    if (ec) {\n-      LOG4CXX_WARN(logger, \"Channel \" << this << \" close error : \" << ec.message().c_str());\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(destruction_lock);\n+    if (closed) {\n+      // some one has closed the socket.\n+      return;\n     }\n+    closed = true;\n+    handler = ChannelHandlerPtr(); // clear the handler in case it ever referenced the channel*/\n   }\n-  handler = ChannelHandlerPtr(); // clear the handler in case it ever referenced the channel*/\n-}\n \n-DuplexChannel::~DuplexChannel() {\n-  /** If we are going away, fail all transactions that haven't been completed */\n-  failAllTransactions();\n-  kill();\n-  free(copy_buf);\n-  copy_buf = NULL;\n-  copy_buf_length = 0;\n+  LOG4CXX_INFO(logger, \"Killing duplex channel (\" << this << \")\");\n \n-  LOG4CXX_DEBUG(logger, \"Destroying DuplexChannel(\" << this << \")\");\n+  // If we are going away, fail all transactions that haven't been completed\n+  failAllTransactions();\n+  closeSocket();  \n }\n \n-/*static*/ void DuplexChannel::writeCallbackHandler(DuplexChannelPtr channel, OperationCallbackPtr callback,\n-\t\t\t\t\t\t    const boost::system::error_code& error, \n-\t\t\t\t\t\t    std::size_t bytes_transferred) {\n-  LOG4CXX_DEBUG(logger, \"DuplexChannel::writeCallbackHandler \" << error << \", \" \n-\t\t<< bytes_transferred << \" channel(\" << channel.get() << \")\");\n-\n+/*static*/ void AbstractDuplexChannel::writeCallbackHandler(\n+                  AbstractDuplexChannelPtr channel,\n+                  OperationCallbackPtr callback,\n+                  const boost::system::error_code& error, \n+                  std::size_t bytes_transferred) {\n   if (error) {\n+    if (!channel->isClosed()) {\n+      LOG4CXX_DEBUG(logger, \"AbstractDuplexChannel::writeCallbackHandler \" << error << \", \" \n+                            << bytes_transferred << \" channel(\" << channel.get() << \")\");\n+    }\n     callback->operationFailed(ChannelWriteException());\n     channel->channelDisconnected(ChannelWriteException());\n     return;\n@@ -425,17 +448,15 @@ DuplexChannel::~DuplexChannel() {\n   channel->startSending();\n }\n \n-void DuplexChannel::writeRequest(const PubSubRequestPtr& m, const OperationCallbackPtr& callback) {\n-  LOG4CXX_DEBUG(logger, \"DuplexChannel::writeRequest channel(\" << this << \") txnid(\" \n-\t\t<< m->txnid() << \") shouldClaim(\"<< m->has_shouldclaim() << \", \" \n-\t\t<< m->shouldclaim() << \")\");\n-\n+void AbstractDuplexChannel::writeRequest(const PubSubRequestPtr& m,\n+                                         const OperationCallbackPtr& callback) {\n   {\n     boost::shared_lock<boost::shared_mutex> lock(state_lock);\n     if (state != CONNECTED && state != CONNECTING) {\n       LOG4CXX_ERROR(logger,\"Tried to write transaction [\" << m->txnid() << \"] to a channel [\" \n-\t\t    << this << \"] which is \" << (state == DEAD ? \"DEAD\" : \"UNINITIALISED\"));\n+                           << this << \"] which is \" << (state == DEAD ? \"DEAD\" : \"UNINITIALISED\"));\n       callback->operationFailed(UninitialisedChannelException());\n+      return;\n     }\n   }\n \n@@ -448,10 +469,14 @@ void DuplexChannel::writeRequest(const PubSubRequestPtr& m, const OperationCallb\n   startSending();\n }\n \n+//\n+// Transaction operations\n+//\n+\n /**\n    Store the transaction data for a request.\n */\n-void DuplexChannel::storeTransaction(const PubSubDataPtr& data) {\n+void AbstractDuplexChannel::storeTransaction(const PubSubDataPtr& data) {\n   LOG4CXX_DEBUG(logger, \"Storing txnid(\" << data->getTxnId() << \") for channel(\" << this << \")\");\n \n   boost::lock_guard<boost::mutex> lock(txnid2data_lock);\n@@ -461,20 +486,20 @@ void DuplexChannel::storeTransaction(const PubSubDataPtr& data) {\n /**\n    Give the transaction back to the caller. \n */\n-PubSubDataPtr DuplexChannel::retrieveTransaction(long txnid) {\n+PubSubDataPtr AbstractDuplexChannel::retrieveTransaction(long txnid) {\n   boost::lock_guard<boost::mutex> lock(txnid2data_lock);\n \n   PubSubDataPtr data = txnid2data[txnid];\n   txnid2data.erase(txnid);\n   if (data == NULL) {\n     LOG4CXX_ERROR(logger, \"Transaction txnid(\" << txnid \n-\t\t  << \") doesn't exist in channel (\" << this << \")\");\n+                          << \") doesn't exist in channel (\" << this << \")\");\n   }\n \n   return data;\n }\n \n-void DuplexChannel::failAllTransactions() {\n+void AbstractDuplexChannel::failAllTransactions() {\n   boost::lock_guard<boost::mutex> lock(txnid2data_lock);\n   for (TransactionMap::iterator iter = txnid2data.begin(); iter != txnid2data.end(); ++iter) {\n     PubSubDataPtr& data = (*iter).second;\n@@ -483,7 +508,322 @@ void DuplexChannel::failAllTransactions() {\n   txnid2data.clear();\n }\n \n-void DuplexChannel::setState(State s) {\n+// Set state for the channel\n+void AbstractDuplexChannel::setState(State s) {\n   boost::lock_guard<boost::shared_mutex> lock(state_lock);\n   state = s;\n }\n+\n+//\n+// Basic Asio Channel Implementation\n+//\n+\n+AsioDuplexChannel::AsioDuplexChannel(IOServicePtr& service,\n+                                     const HostAddress& addr, \n+                                     const ChannelHandlerPtr& handler)\n+  : AbstractDuplexChannel(service, addr, handler) {\n+  this->socket = boost_socket_ptr(new boost_socket(getService()));\n+  LOG4CXX_DEBUG(logger, \"Creating DuplexChannel(\" << this << \")\");\n+}\n+\n+AsioDuplexChannel::~AsioDuplexChannel() {\n+}\n+\n+void AsioDuplexChannel::doConnect(const OperationCallbackPtr& callback) {\n+  boost::system::error_code error = boost::asio::error::host_not_found;\n+  uint32_t ip2conn = address.ip();\n+  uint16_t port2conn = address.port();\n+  boost::asio::ip::tcp::endpoint endp(boost::asio::ip::address_v4(ip2conn), port2conn);\n+\n+  socket->async_connect(endp, boost::bind(&AbstractDuplexChannel::connectCallbackHandler, \n+                                          shared_from_this(), callback,\n+                                          boost::asio::placeholders::error));\n+  LOG4CXX_INFO(logger, \"Channel (\" << this << \") fire connect operation to ip (\" \n+                                   << ip2conn << \") port (\" << port2conn << \")\");\n+}\n+\n+void AsioDuplexChannel::setSocketOption(boost::system::error_code& ec) {\n+  boost::asio::ip::tcp::no_delay option(true);\n+  socket->set_option(option, ec);\n+}\n+\n+boost::asio::ip::tcp::endpoint AsioDuplexChannel::getLocalAddress(\n+    boost::system::error_code& ec) {\n+  return socket->local_endpoint(ec);\n+}\n+\n+boost::asio::ip::tcp::endpoint AsioDuplexChannel::getRemoteAddress(\n+    boost::system::error_code& ec) {\n+  return socket->remote_endpoint(ec);\n+}\n+\n+void AsioDuplexChannel::writeBuffer(boost::asio::streambuf& buffer,\n+                                    const OperationCallbackPtr& callback) {\n+  boost::asio::async_write(*socket, buffer,\n+    boost::bind(&AbstractDuplexChannel::writeCallbackHandler, \n+    shared_from_this(), callback,\n+    boost::asio::placeholders::error, \n+    boost::asio::placeholders::bytes_transferred)\n+  );\n+}\n+\n+void AsioDuplexChannel::readMsgSize(boost::asio::streambuf& buffer) {\n+  boost::asio::async_read(*socket, buffer, boost::asio::transfer_at_least(sizeof(uint32_t)),\n+                          boost::bind(&AbstractDuplexChannel::sizeReadCallbackHandler,\n+                                      shared_from_this(),\n+                                      boost::asio::placeholders::error,\n+                                      boost::asio::placeholders::bytes_transferred));\n+}\n+\n+void AsioDuplexChannel::readMsgBody(boost::asio::streambuf& buffer,\n+                                    int toread, uint32_t msgSize) {\n+  boost::asio::async_read(*socket, buffer, boost::asio::transfer_at_least(toread),\n+                          boost::bind(&AbstractDuplexChannel::messageReadCallbackHandler,\n+                                      shared_from_this(), msgSize,\n+                                      boost::asio::placeholders::error,\n+                                      boost::asio::placeholders::bytes_transferred));\n+}\n+\n+void AsioDuplexChannel::closeSocket() {\n+  boost::system::error_code ec;\n+\n+  socket->cancel(ec);\n+  if (ec) {\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" canceling io error : \" << ec.message().c_str());\n+  }\n+\n+  socket->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n+  if (ec) {\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" shutdown error : \" << ec.message().c_str());\n+  }\n+\n+  socket->close(ec);\n+  if (ec) {\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" close error : \" << ec.message().c_str());\n+  }\n+}\n+\n+// SSL Context Factory\n+\n+SSLContextFactory::SSLContextFactory(const Configuration& conf)\n+  : conf(conf),\n+    sslPemFile(conf.get(Configuration::SSL_PEM_FILE,\n+                        DEFAULT_SSL_PEM_FILE)) {\n+}\n+\n+SSLContextFactory::~SSLContextFactory() {}\n+\n+boost_ssl_context_ptr SSLContextFactory::createSSLContext(boost::asio::io_service& service) {\n+  boost_ssl_context_ptr sslCtx(new boost_ssl_context(service,\n+                               boost::asio::ssl::context::sslv23_client));\n+  sslCtx->set_verify_mode(boost::asio::ssl::context::verify_none);\n+  if (!sslPemFile.empty()) {\n+    boost::system::error_code err;\n+    sslCtx->load_verify_file(sslPemFile, err);\n+\n+    if (err) {\n+      LOG4CXX_ERROR(logger, \"Failed to load verify ssl pem file : \"\n+                            << sslPemFile);\n+      throw InvalidSSLPermFileException();\n+    }\n+  }\n+  return sslCtx;\n+}\n+\n+//\n+// SSL Channl Implementation\n+//\n+\n+#ifndef __APPLE__\n+AsioSSLDuplexChannel::AsioSSLDuplexChannel(IOServicePtr& service,\n+                                           const boost_ssl_context_ptr& sslCtx,\n+                                           const HostAddress& addr,\n+                                           const ChannelHandlerPtr& handler)\n+  : AbstractDuplexChannel(service, addr, handler), ssl_ctx(sslCtx),\n+    sslclosed(false) {\n+#else\n+AsioSSLDuplexChannel::AsioSSLDuplexChannel(IOServicePtr& service,\n+                                           const boost_ssl_context_ptr& sslCtx,\n+                                           const HostAddress& addr,\n+                                           const ChannelHandlerPtr& handler)\n+  : AbstractDuplexChannel(service, addr, handler), ssl_ctx(sslCtx) {\n+#endif\n+  ssl_socket = boost_ssl_socket_ptr(new boost_ssl_socket(getService(), *ssl_ctx));\n+  LOG4CXX_DEBUG(logger, \"Created SSL DuplexChannel(\" << this << \")\");\n+}\n+\n+AsioSSLDuplexChannel::~AsioSSLDuplexChannel() {\n+}\n+\n+void AsioSSLDuplexChannel::doConnect(const OperationCallbackPtr& callback) {\n+  boost::system::error_code error = boost::asio::error::host_not_found;\n+  uint32_t ip2conn = address.ip();\n+  uint16_t port2conn = address.sslPort();\n+  boost::asio::ip::tcp::endpoint endp(boost::asio::ip::address_v4(ip2conn), port2conn);\n+\n+  ssl_socket->lowest_layer().async_connect(endp,\n+      boost::bind(&AbstractDuplexChannel::connectCallbackHandler, \n+                  shared_from_this(), callback,\n+                  boost::asio::placeholders::error));\n+  LOG4CXX_INFO(logger, \"SSL Channel (\" << this << \") fire connect operation to ip (\" \n+                                       << ip2conn << \") port (\" << port2conn << \")\");\n+}\n+\n+void AsioSSLDuplexChannel::setSocketOption(boost::system::error_code& ec) {\n+  boost::asio::ip::tcp::no_delay option(true);\n+  ssl_socket->lowest_layer().set_option(option, ec);\n+}\n+\n+boost::asio::ip::tcp::endpoint AsioSSLDuplexChannel::getLocalAddress(\n+    boost::system::error_code& ec) {\n+  return ssl_socket->lowest_layer().local_endpoint(ec);\n+}\n+\n+boost::asio::ip::tcp::endpoint AsioSSLDuplexChannel::getRemoteAddress(\n+    boost::system::error_code& ec) {\n+  return ssl_socket->lowest_layer().remote_endpoint(ec);\n+}\n+\n+void AsioSSLDuplexChannel::channelConnected(const OperationCallbackPtr& callback) {\n+  // for SSL channel, we had to do SSL hand shake\n+  startHandShake(callback);\n+  LOG4CXX_INFO(logger, \"SSL Channel \" << this << \" fire hand shake operation\");\n+}\n+\n+void AsioSSLDuplexChannel::sslChannelConnected(const OperationCallbackPtr& callback) {\n+  LOG4CXX_INFO(logger, \"SSL Channel \" << this << \" hand shake finish!!\");\n+  AbstractDuplexChannel::channelConnected(callback);\n+}\n+\n+void AsioSSLDuplexChannel::startHandShake(const OperationCallbackPtr& callback) {\n+  ssl_socket->async_handshake(boost::asio::ssl::stream_base::client,\n+                              boost::bind(&AsioSSLDuplexChannel::handleHandshake,\n+                                          boost::shared_dynamic_cast<AsioSSLDuplexChannel>(shared_from_this()),\n+                                          callback, boost::asio::placeholders::error));\n+}\n+\n+void AsioSSLDuplexChannel::handleHandshake(AsioSSLDuplexChannelPtr channel,\n+                                           OperationCallbackPtr callback,\n+                                           const boost::system::error_code& error) {\n+  if (error) {\n+    LOG4CXX_ERROR(logger, \"SSL Channel \" << channel.get() << \" hand shake error : \"\n+                          << error.message().c_str());\n+    channel->channelConnectFailed(ChannelConnectException(), callback);\n+    return;\n+  }\n+  channel->sslChannelConnected(callback);\n+}\n+\n+void AsioSSLDuplexChannel::writeBuffer(boost::asio::streambuf& buffer,\n+                                       const OperationCallbackPtr& callback) {\n+  boost::asio::async_write(*ssl_socket, buffer,\n+    boost::bind(&AbstractDuplexChannel::writeCallbackHandler, \n+    shared_from_this(), callback,\n+    boost::asio::placeholders::error, \n+    boost::asio::placeholders::bytes_transferred)\n+  );\n+}\n+\n+void AsioSSLDuplexChannel::readMsgSize(boost::asio::streambuf& buffer) {\n+  boost::asio::async_read(*ssl_socket, buffer, boost::asio::transfer_at_least(sizeof(uint32_t)),\n+                          boost::bind(&AbstractDuplexChannel::sizeReadCallbackHandler, \n+                                      shared_from_this(),\n+                                      boost::asio::placeholders::error, \n+                                      boost::asio::placeholders::bytes_transferred));\n+}\n+\n+void AsioSSLDuplexChannel::readMsgBody(boost::asio::streambuf& buffer,\n+                                       int toread, uint32_t msgSize) {\n+  boost::asio::async_read(*ssl_socket, buffer, boost::asio::transfer_at_least(toread),\n+                          boost::bind(&AbstractDuplexChannel::messageReadCallbackHandler, \n+                                      shared_from_this(), msgSize,\n+                                      boost::asio::placeholders::error, \n+                                      boost::asio::placeholders::bytes_transferred));\n+}\n+\n+#ifndef __APPLE__\n+// boost asio doesn't provide time out mechanism to shutdown ssl\n+void AsioSSLDuplexChannel::sslShutdown() {\n+  ssl_socket->async_shutdown(boost::bind(&AsioSSLDuplexChannel::handleSSLShutdown,\n+                                         boost::shared_dynamic_cast<AsioSSLDuplexChannel>(shared_from_this()),\n+                                         boost::asio::placeholders::error));\n+}\n+\n+void AsioSSLDuplexChannel::handleSSLShutdown(const boost::system::error_code& error) {\n+  if (error) {\n+    LOG4CXX_ERROR(logger, \"SSL Channel \" << this << \" shutdown error : \"\n+                          << error.message().c_str());\n+  }\n+  {\n+    boost::lock_guard<boost::mutex> lock(sslclosed_lock);\n+    sslclosed = true;\n+  }\n+  sslclosed_cond.notify_all();\n+}\n+#endif\n+\n+void AsioSSLDuplexChannel::closeSocket() {\n+#ifndef __APPLE__\n+  // Shutdown ssl\n+  sslShutdown();\n+  // time wait \n+  {\n+    boost::mutex::scoped_lock lock(sslclosed_lock);\n+    if (!sslclosed) {\n+      sslclosed_cond.timed_wait(lock, boost::posix_time::milliseconds(1000)); \n+    }\n+  }\n+#endif\n+  closeLowestLayer();\n+}\n+\n+void AsioSSLDuplexChannel::closeLowestLayer() {\n+  boost::system::error_code ec;\n+\n+  ssl_socket->lowest_layer().cancel(ec);\n+  if (ec) {\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" canceling io error : \" << ec.message().c_str());\n+  }\n+\n+  ssl_socket->lowest_layer().shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n+  if (ec) {\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" shutdown error : \" << ec.message().c_str());\n+  }\n+\n+  ssl_socket->lowest_layer().close(ec);\n+  if (ec) {\n+    LOG4CXX_WARN(logger, \"Channel \" << this << \" close error : \" << ec.message().c_str());\n+  }\n+}\n+\n+DuplexChannelManagerPtr DuplexChannelManager::create(const Configuration& conf,\n+                                                     EventDispatcher& dispatcher) {\n+  DuplexChannelManagerPtr factory(new DuplexChannelManager(conf, dispatcher));\n+  LOG4CXX_DEBUG(logger, \"Created DuplexChannelManager \" << factory);\n+  return factory;\n+}\n+\n+DuplexChannelManager::DuplexChannelManager(const Configuration& conf,\n+                                           EventDispatcher& dispatcher)\n+  : conf(conf), dispatcher(dispatcher) {\n+  sslEnabled = conf.getBool(Configuration::RUN_AS_SSL_MODE, DEFAULT_SSL_ENABLED); \n+  if (sslEnabled) {\n+    sslCtxFactory = SSLContextFactoryPtr(new SSLContextFactory(conf));\n+  }\n+}\n+\n+DuplexChannelManager::~DuplexChannelManager() {\n+}\n+\n+DuplexChannelPtr DuplexChannelManager::createChannel(const HostAddress& addr,\n+                                                     const ChannelHandlerPtr& handler) {\n+  LOG4CXX_DEBUG(logger, \"Creating channel with handler \" << handler.get());\n+  IOServicePtr& service = dispatcher.getService();\n+  if (sslEnabled) {\n+    boost_ssl_context_ptr sslCtx =\n+      sslCtxFactory->createSSLContext(service->getService());\n+    return DuplexChannelPtr(new AsioSSLDuplexChannel(service, sslCtx, addr, handler));\n+  } else {\n+    return DuplexChannelPtr(new AsioDuplexChannel(service, addr, handler));\n+  }\n+}"},{"sha":"f1b235d55fe9a8579376fd9f1a3f154967d3de2a","filename":"hedwig-client/src/main/cpp/lib/channel.h","status":"modified","additions":327,"deletions":44,"changes":371,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/channel.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/channel.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -40,6 +40,8 @@\n \n #include <boost/asio.hpp>\n #include <boost/asio/ip/tcp.hpp>\n+#include <boost/asio/ssl.hpp>\n+#include <boost/function.hpp>\n #include <boost/thread/mutex.hpp>\n #include <boost/thread/shared_mutex.hpp>\n \n@@ -57,9 +59,16 @@ namespace Hedwig {\n   class ChannelWriteException : public ChannelException {};\n   class ChannelReadException : public ChannelException {};\n   class ChannelThreadException : public ChannelException {};\n+  class ChannelOutOfMemoryException : public ChannelException {};\n+\n+  class InvalidSSLPermFileException : public std::exception {};\n \n   class DuplexChannel;\n   typedef boost::shared_ptr<DuplexChannel> DuplexChannelPtr;\n+  typedef boost::asio::ip::tcp::socket boost_socket;\n+  typedef boost::shared_ptr<boost_socket> boost_socket_ptr;\n+  typedef boost::asio::ssl::stream<boost_socket> boost_ssl_socket;\n+  typedef boost::shared_ptr<boost_ssl_socket> boost_ssl_socket_ptr;\n \n   class ChannelHandler {\n   public:\n@@ -74,90 +83,364 @@ namespace Hedwig {\n \n   typedef boost::shared_ptr<ChannelHandler> ChannelHandlerPtr;\n \n+  // A channel interface to send requests\n+  class DuplexChannel {\n+  public:\n+    virtual ~DuplexChannel() {}\n+\n+    // Issues a connect request to the target host\n+    // User could writeRequest after issued connect request, those requests should\n+    // be buffered and written until the channel is connected.\n+    virtual void connect() = 0;\n+\n+    // Issues a connect request to the target host\n+    // User could writeRequest after issued connect request, those requests should\n+    // be buffered and written until the channel is connected.\n+    // The provided callback would be triggered after connected.\n+    virtual void connect(const OperationCallbackPtr& callback) = 0;\n+\n+    // Write the request to underlying channel\n+    // If the channel is not established, all write requests would be buffered\n+    // until channel is connected.\n+    virtual void writeRequest(const PubSubRequestPtr& m,\n+                              const OperationCallbackPtr& callback) = 0; \n+\n+    // Returns the remote address where this channel is connected to.\n+    virtual const HostAddress& getHostAddress() const = 0;\n+\n+    // Resumes the read operation of this channel asynchronously\n+    virtual void startReceiving() = 0;\n+\n+    // Suspends the read operation of this channel asynchronously\n+    virtual void stopReceiving() = 0;\n+\n+    // Returns if and only if the channel will read a message\n+    virtual bool isReceiving() = 0;\n+\n+    //\n+    // Transaction operations\n+    //\n+\n+    // Store a pub/sub request\n+    virtual void storeTransaction(const PubSubDataPtr& data) = 0;\n+\n+    // Remove a pub/sub request\n+    virtual PubSubDataPtr retrieveTransaction(long txnid) = 0;\n+\n+    // Fail all transactions\n+    virtual void failAllTransactions() = 0;\n+\n+    // Handle the case that the channel is disconnected due issues found\n+    // when reading or writing\n+    virtual void channelDisconnected(const std::exception& e) = 0;\n+\n+    // Close the channel to release the resources\n+    // Once a channel is closed, it can not be open again. Calling this\n+    // method on a closed channel has no efffect.\n+    virtual void close() = 0;\n+  };\n+\n+  typedef boost::asio::ssl::context boost_ssl_context;\n+  typedef boost::shared_ptr<boost_ssl_context> boost_ssl_context_ptr;\n \n-  class DuplexChannel : public boost::enable_shared_from_this<DuplexChannel> {\n+  class SSLContextFactory {\n   public:\n-    DuplexChannel(EventDispatcher& dispatcher, const HostAddress& addr, \n-\t\t  const Configuration& cfg, const ChannelHandlerPtr& handler);\n-    static void connectCallbackHandler(DuplexChannelPtr channel, \n-\t\t\t\t       const boost::system::error_code& error);\n-    void connect();\n-\n-    static void writeCallbackHandler(DuplexChannelPtr channel, OperationCallbackPtr callback, \n-\t\t\t\t     const boost::system::error_code& error, \n-\t\t\t\t     std::size_t bytes_transferred);\n-    void writeRequest(const PubSubRequestPtr& m, const OperationCallbackPtr& callback);\n-    \n-    const HostAddress& getHostAddress() const;\n-\n-    void storeTransaction(const PubSubDataPtr& data);\n-    PubSubDataPtr retrieveTransaction(long txnid);\n-    void failAllTransactions();\n-\n-    static void sizeReadCallbackHandler(DuplexChannelPtr channel, \n-\t\t\t\t\tconst boost::system::error_code& error, \n-\t\t\t\t\tstd::size_t bytes_transferred);\n-    static void messageReadCallbackHandler(DuplexChannelPtr channel, std::size_t messagesize, \n-\t\t\t\t\t   const boost::system::error_code& error, \n-\t\t\t\t\t   std::size_t bytes_transferred);\n-    static void readSize(DuplexChannelPtr channel);\n-\n-    void startReceiving();\n-    bool isReceiving();\n-    void stopReceiving();\n-    \n-    void startSending();\n+    SSLContextFactory(const Configuration& conf);\n+    ~SSLContextFactory();\n+\n+    boost_ssl_context_ptr createSSLContext(boost::asio::io_service& service);\n+  private:\n+    const Configuration& conf;\n+    std::string sslPemFile;\n+  };\n+\n+  typedef boost::shared_ptr<SSLContextFactory> SSLContextFactoryPtr;\n+\n+  class DuplexChannelManager;\n+  typedef boost::shared_ptr<DuplexChannelManager> DuplexChannelManagerPtr;\n+\n+  class DuplexChannelManager : public boost::enable_shared_from_this<DuplexChannelManager> {\n+  public:\n+    static DuplexChannelManagerPtr create(const Configuration& conf,\n+                                          EventDispatcher& dispatcher);\n+    ~DuplexChannelManager();\n+\n+    DuplexChannelPtr createChannel(const HostAddress& addr, const ChannelHandlerPtr& handler);\n+  private:\n+    DuplexChannelManager(const Configuration& conf, EventDispatcher& dispatcher);\n+\n+    const Configuration& conf;\n+    EventDispatcher& dispatcher;\n+    bool sslEnabled;\n+    SSLContextFactoryPtr sslCtxFactory;\n+  };\n \n-    void channelDisconnected(const std::exception& e);\n-    virtual void kill();\n+  class AbstractDuplexChannel;\n+  typedef boost::shared_ptr<AbstractDuplexChannel> AbstractDuplexChannelPtr;\n \n-    inline boost::asio::io_service & getService() {\n+  class AbstractDuplexChannel : public DuplexChannel,\n+                                public boost::enable_shared_from_this<AbstractDuplexChannel> {\n+  public:\n+    AbstractDuplexChannel(IOServicePtr& service,\n+                          const HostAddress& addr, \n+                          const ChannelHandlerPtr& handler);\n+    virtual ~AbstractDuplexChannel();\n+\n+    //\n+    // Connect Operation\n+    //\n+\n+    // Asio Connect Callback Handler\n+    static void connectCallbackHandler(AbstractDuplexChannelPtr channel, \n+                                       OperationCallbackPtr callback,\n+                                       const boost::system::error_code& error);\n+    virtual void connect();\n+    virtual void connect(const OperationCallbackPtr& callback);\n+\n+    //\n+    // Write Operation\n+    //\n+\n+    // Asio Write Callback Handler\n+    static void writeCallbackHandler(AbstractDuplexChannelPtr channel,\n+                                     OperationCallbackPtr callback, \n+                                     const boost::system::error_code& error, \n+                                     std::size_t bytes_transferred);\n+    // Write request\n+    virtual void writeRequest(const PubSubRequestPtr& m,\n+                              const OperationCallbackPtr& callback);\n+\n+    // get the target host\n+    virtual const HostAddress& getHostAddress() const;\n+\n+    static void sizeReadCallbackHandler(AbstractDuplexChannelPtr channel, \n+                                        const boost::system::error_code& error, \n+                                        std::size_t bytes_transferred);\n+    static void messageReadCallbackHandler(AbstractDuplexChannelPtr channel,\n+                                           std::size_t messagesize, \n+                                           const boost::system::error_code& error, \n+                                           std::size_t bytes_transferred);\n+    static void readSize(AbstractDuplexChannelPtr channel);\n+\n+    // start receiving responses from underlying channel\n+    virtual void startReceiving();\n+    // is the underlying channel in receiving state\n+    virtual bool isReceiving();\n+    // stop receiving responses from underlying channel\n+    virtual void stopReceiving();\n+\n+    // Store a pub/sub request\n+    virtual void storeTransaction(const PubSubDataPtr& data);\n+\n+    // Remove a pub/sub request\n+    virtual PubSubDataPtr retrieveTransaction(long txnid);\n+\n+    // Fail all transactions\n+    virtual void failAllTransactions();\n+\n+    // channel is disconnected for a specified exception\n+    virtual void channelDisconnected(const std::exception& e);\n+\n+    // close the channel\n+    virtual void close();\n+\n+    inline boost::asio::io_service & getService() const {\n       return service;\n     }\n \n-    virtual ~DuplexChannel();\n-  private:\n-    enum State { UNINITIALISED, CONNECTING, CONNECTED, DEAD };\n+  protected:\n+    // execute the connect operation\n+    virtual void doConnect(const OperationCallbackPtr& callback) = 0;\n \n-    void setState(State s);\n+    virtual void doAfterConnect(const OperationCallbackPtr& callback,\n+                                const boost::system::error_code& error);\n \n-    EventDispatcher& dispatcher;\n+    // Execute the action after channel connect\n+    // It would be executed in asio connect callback handler\n+    virtual void setSocketOption(boost::system::error_code& ec) = 0;\n+    virtual boost::asio::ip::tcp::endpoint\n+            getRemoteAddress(boost::system::error_code& ec) = 0;\n+    virtual boost::asio::ip::tcp::endpoint\n+            getLocalAddress(boost::system::error_code& ec) = 0;\n+\n+    // Channel failed to connect\n+    virtual void channelConnectFailed(const std::exception& e,\n+                                      const OperationCallbackPtr& callback);\n+    // Channel connected\n+    virtual void channelConnected(const OperationCallbackPtr& callback);\n+\n+    // Start sending buffered requests to target host\n+    void startSending();\n+\n+    // Write a buffer to underlying socket\n+    virtual void writeBuffer(boost::asio::streambuf& buffer,\n+                             const OperationCallbackPtr& callback) = 0;\n+\n+    // Read a message from underlying socket\n+    virtual void readMsgSize(boost::asio::streambuf& buffer) = 0;\n+    virtual void readMsgBody(boost::asio::streambuf& buffer,\n+                             int toread, uint32_t msgSize) = 0;\n \n+    // is the channel under closing\n+    bool isClosed();\n+\n+    // close the underlying socket to release resource \n+    virtual void closeSocket() = 0;\n+\n+    enum State { UNINITIALISED, CONNECTING, CONNECTED, DEAD };\n+    void setState(State s);\n+\n+    // Address\n     HostAddress address;\n+  private:\n     ChannelHandlerPtr handler;\n \n     boost::asio::io_service &service;\n-    boost::asio::ip::tcp::socket socket;\n+\n+    // buffers for input stream\n     boost::asio::streambuf in_buf;\n     std::istream instream;\n-    \n-    // only exists because protobufs can't play nice with streams (if there's more than message len in it, it tries to read all)\n+\n+    // only exists because protobufs can't play nice with streams\n+    // (if there's more than message len in it, it tries to read all)\n     char* copy_buf;\n     std::size_t copy_buf_length;\n \n+    // buffers for output stream\n     boost::asio::streambuf out_buf;\n-    \n+    // write requests queue \n     typedef std::pair<PubSubRequestPtr, OperationCallbackPtr> WriteRequest;\n     boost::mutex write_lock;\n     std::deque<WriteRequest> write_queue;\n \n+    // channel state\n     State state;\n     boost::shared_mutex state_lock;\n \n+    // reading state\n     bool receiving;\n     bool reading;\n     PubSubResponsePtr outstanding_response;\n     boost::mutex receiving_lock;\n-    \n+\n+    // sending state\n     bool sending;\n     boost::mutex sending_lock;\n \n+    // flag indicates the channel is closed\n+    // some callback might return when closing\n+    bool closed;\n+\n+    // transactions\n     typedef std::tr1::unordered_map<long, PubSubDataPtr> TransactionMap;\n \n     TransactionMap txnid2data;\n     boost::mutex txnid2data_lock;\n     boost::shared_mutex destruction_lock;\n   };\n+\n+  class AsioDuplexChannel : public AbstractDuplexChannel {\n+  public:\n+    AsioDuplexChannel(IOServicePtr& service,\n+                      const HostAddress& addr, \n+                      const ChannelHandlerPtr& handler);\n+    virtual ~AsioDuplexChannel();\n+  protected:\n+    // execute the connect operation\n+    virtual void doConnect(const OperationCallbackPtr& callback);\n+\n+    // Execute the action after channel connect\n+    // It would be executed in asio connect callback handler\n+    virtual void setSocketOption(boost::system::error_code& ec);\n+    virtual boost::asio::ip::tcp::endpoint\n+            getRemoteAddress(boost::system::error_code& ec);\n+    virtual boost::asio::ip::tcp::endpoint\n+            getLocalAddress(boost::system::error_code& ec);\n+\n+    // Write a buffer to underlying socket\n+    virtual void writeBuffer(boost::asio::streambuf& buffer,\n+                             const OperationCallbackPtr& callback);\n+\n+    // Read a message from underlying socket\n+    virtual void readMsgSize(boost::asio::streambuf& buffer);\n+    virtual void readMsgBody(boost::asio::streambuf& buffer,\n+                             int toread, uint32_t msgSize);\n+\n+    // close the underlying socket to release resource \n+    virtual void closeSocket();\n+  private:\n+    // underlying socket\n+    boost_socket_ptr socket;\n+  };\n+\n+  typedef boost::shared_ptr<AsioDuplexChannel> AsioDuplexChannelPtr;\n+\n+  class AsioSSLDuplexChannel;\n+  typedef boost::shared_ptr<AsioSSLDuplexChannel> AsioSSLDuplexChannelPtr;\n+\n+  class AsioSSLDuplexChannel : public AbstractDuplexChannel {\n+  public:\n+    AsioSSLDuplexChannel(IOServicePtr& service,\n+                         const boost_ssl_context_ptr& sslCtx,\n+                         const HostAddress& addr, \n+                         const ChannelHandlerPtr& handler);\n+    virtual ~AsioSSLDuplexChannel();\n+  protected:\n+    // execute the connect operation\n+    virtual void doConnect(const OperationCallbackPtr& callback);\n+    // Execute the action after channel connect\n+    // It would be executed in asio connect callback handler\n+    virtual void setSocketOption(boost::system::error_code& ec);\n+    virtual boost::asio::ip::tcp::endpoint\n+            getRemoteAddress(boost::system::error_code& ec);\n+    virtual boost::asio::ip::tcp::endpoint\n+            getLocalAddress(boost::system::error_code& ec);\n+\n+    virtual void channelConnected(const OperationCallbackPtr& callback);\n+\n+    // Start SSL Hand Shake after the channel is connected\n+    void startHandShake(const OperationCallbackPtr& callback);\n+    // Asio Callback After Hand Shake\n+    static void handleHandshake(AsioSSLDuplexChannelPtr channel,\n+                                OperationCallbackPtr callback,\n+                                const boost::system::error_code& error);\n+\n+    void sslChannelConnected(const OperationCallbackPtr& callback);\n+\n+    // Write a buffer to underlying socket\n+    virtual void writeBuffer(boost::asio::streambuf& buffer,\n+                             const OperationCallbackPtr& callback);\n+\n+    // Read a message from underlying socket\n+    virtual void readMsgSize(boost::asio::streambuf& buffer);\n+    virtual void readMsgBody(boost::asio::streambuf& buffer,\n+                             int toread, uint32_t msgSize);\n+\n+    // close the underlying socket to release resource \n+    virtual void closeSocket();\n+\n+  private:\n+#ifndef __APPLE__\n+    // Shutdown ssl\n+    void sslShutdown();\n+    // Handle ssl shutdown\n+    void handleSSLShutdown(const boost::system::error_code& error);\n+#endif\n+    // Close lowest layer\n+    void closeLowestLayer();\n+\n+    // underlying ssl socket\n+    boost_ssl_socket_ptr ssl_socket;\n+    // ssl context\n+    boost_ssl_context_ptr ssl_ctx;\n+\n+#ifndef __APPLE__\n+    // Flag indicated ssl is closed.\n+    bool sslclosed;\n+    boost::mutex sslclosed_lock;\n+    boost::condition_variable sslclosed_cond;\n+#endif\n+  };\n   \n \n   struct DuplexChannelPtrHash : public std::unary_function<DuplexChannelPtr, size_t> {"},{"sha":"f85a0bb10a6d843d8b10d8fcdc538e2f8a4f6b15","filename":"hedwig-client/src/main/cpp/lib/client.cpp","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/client.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/client.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/client.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -39,6 +39,8 @@ const std::string Configuration::SYNC_REQUEST_TIMEOUT = \"hedwig.cpp.sync_request\n const std::string Configuration::SUBSCRIBER_AUTOCONSUME = \"hedwig.cpp.subscriber_autoconsume\";\n const std::string Configuration::NUM_DISPATCH_THREADS = \"hedwig.cpp.num_dispatch_threads\";\n const std::string Configuration::SUBSCRIPTION_MESSAGE_BOUND = \"hedwig.cpp.subscription_message_bound\";\n+const std::string Configuration::RUN_AS_SSL_MODE = \"hedwig.cpp.ssl_mode\";\n+const std::string Configuration::SSL_PEM_FILE = \"hedwig.cpp.ssl_pem\";\n \n Client::Client(const Configuration& conf) {\n   LOG4CXX_DEBUG(logger, \"Client::Client (\" << this << \")\");"},{"sha":"7a9e4679e69ac21c3b35e68b589d062ed2f53d0b","filename":"hedwig-client/src/main/cpp/lib/clientimpl.cpp","status":"modified","additions":22,"deletions":17,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/clientimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/clientimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -30,7 +30,6 @@ static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n using namespace Hedwig;\n \n const std::string DEFAULT_SERVER_DEFAULT_VAL = \"\";\n-const int DEFAULT_NUM_DISPATCH_THREADS = 1;\n \n void SyncOperationCallback::wait() {\n   boost::unique_lock<boost::mutex> lock(mut);\n@@ -182,25 +181,25 @@ long ClientTxnCounter::next() {  // would be nice to remove lock from here, look\n ClientImplPtr ClientImpl::Create(const Configuration& conf) {\n   ClientImplPtr impl(new ClientImpl(conf));\n   LOG4CXX_DEBUG(logger, \"Creating Clientimpl \" << impl);\n-\n   impl->dispatcher->start();\n-\n   return impl;\n }\n \n void ClientImpl::Destroy() {\n   LOG4CXX_DEBUG(logger, \"destroying Clientimpl \" << this);\n \n-  dispatcher->stop();\n   {\n     boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n     \n     shuttingDownFlag = true;\n     for (ChannelMap::iterator iter = allchannels.begin(); iter != allchannels.end(); ++iter ) {\n-      (*iter)->kill();\n+      (*iter)->close();\n     }  \n     allchannels.clear();\n   }\n+  // SSL Channel shutdown needs to send packets to server\n+  // so we only stop dispatcher after all channels are closed\n+  dispatcher->stop();\n \n   /* destruction of the maps will clean up any items they hold */\n   \n@@ -217,8 +216,10 @@ void ClientImpl::Destroy() {\n ClientImpl::ClientImpl(const Configuration& conf) \n   : conf(conf), publisher(NULL), subscriber(NULL), counterobj(), shuttingDownFlag(false)\n {\n-  defaultHost = HostAddress::fromString(conf.get(Configuration::DEFAULT_SERVER, DEFAULT_SERVER_DEFAULT_VAL));\n-  dispatcher = EventDispatcherPtr(new EventDispatcher(conf.getInt(Configuration::NUM_DISPATCH_THREADS, DEFAULT_NUM_DISPATCH_THREADS)));\n+  defaultHost = HostAddress::fromString(conf.get(Configuration::DEFAULT_SERVER,\n+                                                 DEFAULT_SERVER_DEFAULT_VAL));\n+  dispatcher = EventDispatcherPtr(new EventDispatcher(conf));\n+  channelManager = DuplexChannelManager::create(conf, *dispatcher);\n }\n \n Subscriber& ClientImpl::getSubscriber() {\n@@ -275,15 +276,13 @@ void ClientImpl::redirectRequest(const DuplexChannelPtr& channel, PubSubDataPtr&\n     if (data->getType() == SUBSCRIBE) {\n       // a redirect for subscription, kill old channel and remove old channel from all channels list\n       // otherwise old channel will not be destroyed, caused lost of CLOSE_WAIT connections\n-      channel->kill();\n-      {\n-        boost::lock_guard<boost::shared_mutex> aclock(allchannels_lock);\n-        allchannels.erase(channel); // channel should be deleted here\n-      }\n+      removeAndCloseChannel(channel);\n+\n       SubscriberClientChannelHandlerPtr handler(new SubscriberClientChannelHandler(shared_from_this(), \n \t\t\t\t\t\t\t\t\t\t   this->getSubscriberImpl(), data));\n       newchannel = createChannel(data->getTopic(), handler);\n       handler->setChannel(newchannel);\n+      newchannel->connect();\n       getSubscriberImpl().doSubscribe(newchannel, data, handler);\n     } else if (data->getType() == PUBLISH) {\n       newchannel = getChannel(data->getTopic());\n@@ -314,14 +313,15 @@ DuplexChannelPtr ClientImpl::createChannel(const std::string& topic, const Chann\n     setHostForTopic(topic, addr);\n   }\n \n-  DuplexChannelPtr channel(new DuplexChannel(*dispatcher, addr, conf, handler));\n+  DuplexChannelPtr channel = channelManager->createChannel(addr, handler);\n \n   boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n   if (shuttingDownFlag) {\n-    channel->kill();\n+    channel->close();\n     throw ShuttingDownException();\n   }\n-  channel->connect();\n+  // Don't connect here, otherwise connect callback may be triggered before setChannel\n+  // channel->connect();\n \n   allchannels.insert(channel);\n   LOG4CXX_DEBUG(logger, \"(create) All channels size: \" << allchannels.size());\n@@ -345,6 +345,7 @@ DuplexChannelPtr ClientImpl::getChannel(const std::string& topic) {\n     LOG4CXX_DEBUG(logger, \" No channel for topic, creating new channel.get() \" << channel.get() << \" addr \" << addr.getAddressString());\n     ChannelHandlerPtr handler(new HedwigClientChannelHandler(shared_from_this()));\n     channel = createChannel(topic, handler);\n+    channel->connect();\n \n     boost::lock_guard<boost::shared_mutex> lock(host2channel_lock);\n     host2channel[addr] = channel;\n@@ -376,7 +377,6 @@ void ClientImpl::channelDied(const DuplexChannelPtr& channel) {\n   boost::lock_guard<boost::shared_mutex> h2tlock(host2topics_lock);\n   boost::lock_guard<boost::shared_mutex> h2clock(host2channel_lock);\n   boost::lock_guard<boost::shared_mutex> t2hlock(topic2host_lock);\n-  boost::lock_guard<boost::shared_mutex> aclock(allchannels_lock);\n   // get host\n   HostAddress addr = channel->getHostAddress();\n   \n@@ -385,14 +385,19 @@ void ClientImpl::channelDied(const DuplexChannelPtr& channel) {\n   }\n   host2topics.erase(addr);\n   host2channel.erase(addr);\n+  removeAndCloseChannel(channel);\n+}\n \n+void ClientImpl::removeAndCloseChannel(const DuplexChannelPtr& channel) {\n+  boost::lock_guard<boost::shared_mutex> aclock(allchannels_lock);\n   allchannels.erase(channel); // channel should be deleted here\n+  channel->close(); // close channel\n }\n \n const Configuration& ClientImpl::getConfiguration() {\n   return conf;\n }\n \n boost::asio::io_service& ClientImpl::getService() {\n-  return dispatcher->getService();\n+  return dispatcher->getService()->getService();\n }"},{"sha":"3d1257a2a46dd1dc3b9ea5fd6f9a85f1591f8dd8","filename":"hedwig-client/src/main/cpp/lib/clientimpl.h","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/clientimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/clientimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -206,6 +206,7 @@ namespace Hedwig {\n \n     void setChannelForHost(const HostAddress& address, const DuplexChannelPtr& channel);\n     void channelDied(const DuplexChannelPtr& channel);\n+    void removeAndCloseChannel(const DuplexChannelPtr& channel);\n     bool shuttingDown() const;\n     \n     SubscriberImpl& getSubscriberImpl();\n@@ -230,7 +231,8 @@ namespace Hedwig {\n \n     typedef boost::shared_ptr<EventDispatcher> EventDispatcherPtr;\n     EventDispatcherPtr dispatcher;\n-    \n+    DuplexChannelManagerPtr channelManager;\n+\n     typedef std::tr1::unordered_multimap<HostAddress, std::string, HostAddressHash > Host2TopicsMap;\n     Host2TopicsMap host2topics;\n     boost::shared_mutex host2topics_lock;"},{"sha":"60aed20beefeac0bd06355e9492e1a24c6d52e02","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","status":"modified","additions":49,"deletions":22,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -27,41 +27,71 @@ static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n using namespace Hedwig;\n \n-EventDispatcher::EventDispatcher(int numThreads)\n-  : num_threads(numThreads), running(false), next_io_service(0) {\n-  if (0 == num_threads) {\n-    throw std::runtime_error(\"number of threads in dispatcher is zero\");\n-  }\n-  for (size_t i = 0; i < num_threads; i++) {\n-    io_service_ptr service(new boost::asio::io_service);\n-    services.push_back(service);\n+const int DEFAULT_NUM_DISPATCH_THREADS = 1;\n+\n+IOService::IOService() {\n+}\n+\n+IOService::~IOService() {}\n+\n+void IOService::start() {\n+  if (work.get()) {\n+    return;\n   }\n+  work = work_ptr(new boost::asio::io_service::work(service));\n }\n \n-void EventDispatcher::run_forever(io_service_ptr service, size_t idx) {\n-  LOG4CXX_DEBUG(logger, \"Starting event dispatcher \" << idx);\n+void IOService::stop() {\n+  if (!work.get()) {\n+    return;\n+  }\n+\n+  work = work_ptr();\n+  service.stop();\n+}\n \n+void IOService::run() {\n   while (true) {\n     try {\n-      service->run();\n+      service.run();\n       break;\n     } catch (std::exception &e) {\n-    LOG4CXX_ERROR(logger, \"Exception in dispatch handler \" << idx << \" : \" << e.what());\n+      LOG4CXX_ERROR(logger, \"Exception in IO Service \" << this << \" : \" << e.what());\n     }\n   }\n-  LOG4CXX_DEBUG(logger, \"Event dispatcher \" << idx << \" done\");\n+}\n+\n+EventDispatcher::EventDispatcher(const Configuration& conf)\n+  : conf(conf), running(false), next_io_service(0) {\n+  num_threads = conf.getInt(Configuration::NUM_DISPATCH_THREADS,\n+                            DEFAULT_NUM_DISPATCH_THREADS);\n+  if (0 == num_threads) {\n+    throw std::runtime_error(\"number of threads in dispatcher is zero\");\n+  }\n+  for (size_t i = 0; i < num_threads; i++) {\n+    services.push_back(IOServicePtr(new IOService()));\n+  }\n+}\n+\n+void EventDispatcher::run_forever(IOServicePtr service, size_t idx) {\n+  LOG4CXX_INFO(logger, \"Starting event dispatcher \" << idx);\n+\n+  service->run();\n+\n+  LOG4CXX_INFO(logger, \"Event dispatcher \" << idx << \" done\");\n }\n \n void EventDispatcher::start() {\n   if (running) {\n     return;\n   }\n+\n   for (size_t i = 0; i < num_threads; i++) {\n-    io_service_ptr service = services[i];\n-    work_ptr work(new boost::asio::io_service::work(*service));\n-    works.push_back(work);\n+    IOServicePtr service = services[i];\n+    service->start();\n     // new thread\n-    thread_ptr t(new boost::thread(boost::bind(&EventDispatcher::run_forever, this, service, i)));\n+    thread_ptr t(new boost::thread(boost::bind(&EventDispatcher::run_forever,\n+                                               this, service, i)));\n     threads.push_back(t);\n   }\n   running = true;\n@@ -72,8 +102,6 @@ void EventDispatcher::stop() {\n     return;\n   }\n \n-  works.clear();\n-\n   for (size_t i = 0; i < num_threads; i++) {\n     services[i]->stop();\n   }\n@@ -90,13 +118,12 @@ EventDispatcher::~EventDispatcher() {\n   services.clear();\n }\n \n-boost::asio::io_service& EventDispatcher::getService() {\n+IOServicePtr& EventDispatcher::getService() {\n   size_t next = 0;\n   {\n     boost::lock_guard<boost::mutex> lock(next_lock);\n     next = next_io_service;\n     next_io_service = (next_io_service + 1) % num_threads;\n   }\n-  boost::asio::io_service& service = *services[next];\n-  return service;\n+  return services[next];\n }"},{"sha":"b6a75040a4fea40ba4e05adc02f43439b7f6d824","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.h","status":"modified","additions":34,"deletions":9,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/eventdispatcher.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/eventdispatcher.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -20,37 +20,62 @@\n \n #include <vector>\n \n+#include <hedwig/client.h>\n+\n #include <boost/asio.hpp>\n #include <boost/thread.hpp>\n-#include <boost/thread/mutex.hpp>\n #include <boost/shared_ptr.hpp>\n \n namespace Hedwig {\n-  typedef boost::shared_ptr<boost::asio::io_service> io_service_ptr;\n   typedef boost::shared_ptr<boost::asio::io_service::work> work_ptr;\n   typedef boost::shared_ptr<boost::thread> thread_ptr;\n \n+  class IOService;\n+  typedef boost::shared_ptr<IOService> IOServicePtr;\n+\n+  class IOService {\n+  public:\n+    IOService();\n+    virtual ~IOService();\n+\n+    // start the io service\n+    void start();\n+    // stop the io service\n+    void stop();\n+    // run the io service\n+    void run();\n+\n+    inline boost::asio::io_service& getService() {\n+      return service;\n+    }\n+\n+  private:\n+    boost::asio::io_service service;  \n+    work_ptr work;\n+  };\n+\n   class EventDispatcher {\n   public:  \n-    EventDispatcher(int numThreads = 1);\n+    EventDispatcher(const Configuration& conf);\n     ~EventDispatcher();\n     \n     void start();\n+\n     void stop();\n     \n-    boost::asio::io_service& getService();\n-    \n+    IOServicePtr& getService();\n+\n   private:\n-    void run_forever(io_service_ptr service, size_t idx);\n+    void run_forever(IOServicePtr service, size_t idx);\n+\n+    const Configuration& conf;\n \n     // number of threads\n     size_t num_threads;\n     // running flag\n     bool running;\n     // pool of io_services.\n-    std::vector<io_service_ptr> services;\n-    // pool of works\n-    std::vector<work_ptr> works;\n+    std::vector<IOServicePtr> services;\n     // threads\n     std::vector<thread_ptr> threads;\n     // next io_service used for a connection"},{"sha":"229dc418b9cadee2ed8e3d9e9b145b57d3008ee6","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":38,"deletions":11,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -129,7 +129,8 @@ void SubscriberConsumeCallback::operationFailed(const std::exception& exception)\n   LOG4CXX_ERROR(logger, \"Error passing message to client transaction: \" << data->getTxnId() << \" error: \" << exception.what() \n \t\t<< \" retrying in \" << retrywait << \" Microseconds\");\n \n-  boost::asio::deadline_timer t(handler->getChannel()->getService(), boost::posix_time::milliseconds(retrywait));\n+  AbstractDuplexChannelPtr chPtr = boost::dynamic_pointer_cast<AbstractDuplexChannel>(handler->getChannel());\n+  boost::asio::deadline_timer t(chPtr->getService(), boost::posix_time::milliseconds(retrywait));\n \n   t.async_wait(boost::bind(&SubscriberConsumeCallback::timerComplete, handler, m, boost::asio::placeholders::error));  \n }\n@@ -179,8 +180,23 @@ void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& cha\n void SubscriberClientChannelHandler::close() {\n   closed = true;\n \n+  // cancel reconnect timer\n+  if (reconnectTimer.get()) {\n+    boost::system::error_code ec;\n+    reconnectTimer->cancel(ec);\n+    if (ec) {\n+      LOG4CXX_WARN(logger, \"Handler \" << this << \" cancel reconnect task \" << reconnectTimer.get() << \" error :\" << ec.message().c_str());\n+    }\n+  }\n+\n+  LOG4CXX_INFO(logger, \"close subscription handler \" << this << \" for (topic:\" << origData->getTopic()\n+                    << \", subscriberId:\" << origData->getSubscriberId() << \").\");\n   if (channel.get()) {\n-    channel->kill();\n+    // need to ensure the channel is removed from allchannels list\n+    // since it will be killed\n+    client->removeAndCloseChannel(channel);\n+    LOG4CXX_INFO(logger, \"removed subscription channel \" << channel.get() << \" for (topic: \" << origData->getTopic()\n+                      << \", subscriberId:\" << origData->getSubscriberId() << \").\");\n   }\n }\n \n@@ -236,9 +252,10 @@ void SubscriberClientChannelHandler::reconnect(const DuplexChannelPtr& channel,\n   if (should_wait) {\n     int retrywait = client->getConfiguration().getInt(Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME,\n \t\t\t\t\t\t      DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME);\n-    \n+    AbstractDuplexChannelPtr chPtr = boost::dynamic_pointer_cast<AbstractDuplexChannel>(channel);\n     // set reconnect timer\n-    reconnectTimer = ReconnectTimerPtr(new boost::asio::deadline_timer(channel->getService(), boost::posix_time::milliseconds(retrywait)));\n+    reconnectTimer = ReconnectTimerPtr(new boost::asio::deadline_timer(chPtr->getService(),\n+                                       boost::posix_time::milliseconds(retrywait)));\n     reconnectTimer->async_wait(boost::bind(&SubscriberClientChannelHandler::reconnectTimerComplete, shared_from_this(),\n \t\t\t     channel, e, boost::asio::placeholders::error));  \n     return;\n@@ -256,6 +273,8 @@ void SubscriberClientChannelHandler::reconnect(const DuplexChannelPtr& channel,\n   \n   DuplexChannelPtr newchannel = client->createChannel(origData->getTopic(), baseptr);\n   newhandler->setChannel(newchannel);\n+  newchannel->connect();\n+  LOG4CXX_DEBUG(logger, \"Create a new channel \" << newchannel.get() << \" to handover delivery to new handler \" << newhandler.get());\n   handoverDelivery(newhandler);\n   \n   // remove record of the failed channel from the subscriber\n@@ -368,6 +387,10 @@ void SubscriberImpl::asyncSubscribe(const std::string& topic, const std::string&\n \n   DuplexChannelPtr channel = client->createChannel(topic, handler);\n   handler->setChannel(channel);\n+  channel->connect();\n+  LOG4CXX_INFO(logger, \"New handler \" << handler.get() << \" on channel \" << channel.get()\n+                    << \" is created for (topic:\" << topic << \", subscriber:\" << subscriberId << \", txn:\"\n+                    << data->getTxnId() << \").\");\n   doSubscribe(channel, data, handler);\n }\n \n@@ -377,15 +400,19 @@ void SubscriberImpl::doSubscribe(const DuplexChannelPtr& channel, const PubSubDa\n   OperationCallbackPtr writecb(new SubscriberWriteCallback(client, data));\n   channel->writeRequest(data->getRequest(), writecb);\n \n-  boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n-  TopicSubscriber t(data->getTopic(), data->getSubscriberId());\n-  SubscriberClientChannelHandlerPtr oldhandler = topicsubscriber2handler[t];\n-  if (oldhandler != NULL) {\n+  SubscriberClientChannelHandlerPtr oldhandler;\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    TopicSubscriber t(data->getTopic(), data->getSubscriberId());\n+    oldhandler = topicsubscriber2handler[t];\n+    topicsubscriber2handler[t] = handler;\n+  }\n+  if (oldhandler.get() != NULL) {\n+    LOG4CXX_DEBUG(logger, \"(topic:\" << data->getTopic() << \", subscriber:\" << data->getSubscriberId()\n+                          << \") handover delivery from old handler \" << oldhandler.get()\n+                          << \" to new handler \" << handler.get());\n     oldhandler->handoverDelivery(handler);\n   }\n-  topicsubscriber2handler[t] = handler;\n-  \n-  LOG4CXX_DEBUG(logger, \"Set topic subscriber for topic(\" << data->getTopic() << \") subscriberId(\" << data->getSubscriberId() << \") to \" << handler.get() << \" topicsubscriber2topic(\" << &topicsubscriber2handler << \")\");\n }\n \n void SubscriberImpl::unsubscribe(const std::string& topic, const std::string& subscriberId) {"},{"sha":"24784a80b798f79844f60fa30dbc1c18c706a952","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -107,7 +107,8 @@ namespace Hedwig {\n   class SubscriberClientChannelHandler : public HedwigClientChannelHandler, \n \t\t\t\t\t public boost::enable_shared_from_this<SubscriberClientChannelHandler> {\n   public: \n-    SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber, const PubSubDataPtr& data);\n+    SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber,\n+                                   const PubSubDataPtr& data);\n     ~SubscriberClientChannelHandler();\n \n     void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m);"},{"sha":"89190e236ddcfef775c3356a1bad8c941dfce2d5","filename":"hedwig-client/src/main/cpp/lib/util.cpp","status":"modified","additions":12,"deletions":1,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/util.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/util.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -39,7 +39,7 @@ const std::string UNITIALISED_HOST(\"UNINITIALISED HOST\");\n const int DEFAULT_PORT = 4080;\n const int DEFAULT_SSL_PORT = 9876;\n \n-HostAddress::HostAddress() : initialised(false), address_str() {\n+HostAddress::HostAddress() : initialised(false), address_str(), ssl_host_port(0) {\n }\n \n HostAddress::~HostAddress() {\n@@ -65,13 +65,23 @@ uint32_t HostAddress::ip() const {\n   return host_ip;\n }\n \n+void HostAddress::updateIP(uint32_t ip) {\n+  this->host_ip = ip;\n+}\n+\n uint16_t HostAddress::port() const {\n   return host_port;\n }\n \n+uint16_t HostAddress::sslPort() const {\n+  return ssl_host_port;\n+}\n+\n void HostAddress::parse_string() {\n   char* url = strdup(address_str.c_str());\n \n+  LOG4CXX_DEBUG(logger, \"Parse address : \" << url);\n+\n   if (url == NULL) {\n     LOG4CXX_ERROR(logger, \"You seems to be out of memory\");\n     throw OomException();\n@@ -130,6 +140,7 @@ void HostAddress::parse_string() {\n \n   host_ip = ntohl(socket_addr.sin_addr.s_addr);\n   host_port = ntohs(socket_addr.sin_port);\n+  ssl_host_port = sslport;\n \n   freeaddrinfo(addr);\n   free((void*)url);"},{"sha":"ead706f8f18d296c28369d3de9222cf8741df3b1","filename":"hedwig-client/src/main/cpp/lib/util.h","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/lib/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -53,6 +53,11 @@ namespace Hedwig {\n     const std::string& getAddressString() const;\n     uint32_t ip() const;\n     uint16_t port() const;\n+    uint16_t sslPort() const;\n+\n+    // the real ip address is different from default server\n+    // if default server is a VIP\n+    void updateIP(uint32_t ip);\n \n     static HostAddress fromString(std::string host);\n \n@@ -64,6 +69,7 @@ namespace Hedwig {\n     std::string address_str;\n     uint32_t host_ip;\n     uint16_t host_port;\n+    uint16_t ssl_host_port;\n   };\n \n   /**"},{"sha":"2e094399eae8ed74be01c4b84e99c43a84b1ebb9","filename":"hedwig-client/src/main/cpp/scripts/log4cxx.conf","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/scripts/log4cxx.conf","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/scripts/log4cxx.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/log4cxx.conf?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -22,20 +22,21 @@\n log4j.appender.rootAppender=org.apache.log4j.ConsoleAppender\n log4j.appender.rootAppender.layout=org.apache.log4j.BasicLayout\n \n-#log4j.appender.hedwig=org.apache.log4j.RollingFileAppender\n-log4j.appender.hedwig=org.apache.log4j.ConsoleAppender\n-#log4j.appender.hedwig.fileName=./testLog.log\n+log4j.appender.hedwig=org.apache.log4j.RollingFileAppender\n+#log4j.appender.hedwig=org.apache.log4j.ConsoleAppender\n+log4j.appender.hedwig.fileName=./testLog.log\n log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n log4j.appender.hedwig.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %p %c - %m%n\n \n-log4j.appender.hedwigtest=org.apache.log4j.ConsoleAppender\n-#log4j.appender.hedwig.fileName=./testLog.log\n+log4j.appender.hedwig=org.apache.log4j.RollingFileAppender\n+#log4j.appender.hedwigtest=org.apache.log4j.ConsoleAppender\n+log4j.appender.hedwig.fileName=./testLog.log\n log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n log4j.appender.hedwigtest.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %p %c - %m%n\n \n # category\n-log4j.category.hedwig=OFF, hedwig\n-log4j.category.hedwigtest=OFF, hedwigtest\n+log4j.category.hedwig=DEBUG, hedwig\n+log4j.category.hedwigtest=DEBUG, hedwigtest\n \n log4j.rootCategory=OFF\n "},{"sha":"cd199d007598512298e72dc49a1ee6804f4032ed","filename":"hedwig-client/src/main/cpp/scripts/server-control.sh","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/scripts/server-control.sh","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/scripts/server-control.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/server-control.sh?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -94,6 +94,7 @@ start_hw_server () {\n     REGION=$1\n     COUNT=$2\n     PORT=$((4080+$COUNT))\n+    SSL_PORT=$((9876+$COUNT))\n \n     export HEDWIG_LOG_CONF=/tmp/hw-log4j-$COUNT.properties\n     cat > $HEDWIG_LOG_CONF <<EOF\n@@ -112,6 +113,8 @@ log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n #log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+log4j.logger.org.apache.zookeeper=OFF,ROLLINGFILE\n+log4j.logger.org.apache.hedwig.zookeeper=OFF,ROLLINGFILE\n EOF\n \n     export HEDWIG_SERVER_CONF=/tmp/hw-server-$COUNT.conf\n@@ -122,9 +125,11 @@ zk_timeout=2000\n # The port at which the clients will connect.\n server_port=$PORT\n # The SSL port at which the clients will connect (only if SSL is enabled).\n-ssl_server_port=9876\n+ssl_server_port=$SSL_PORT\n # Flag indicating if the server should also operate in SSL mode.\n-ssl_enabled=false\n+ssl_enabled=true\n+cert_path=$PWD/../../../../../hedwig-server/src/main/resources/server.p12\n+password=eUySvp2phM2Wk\n region=$REGION\n EOF\n     sh $HWSCRIPT server 2>&1 > hwoutput.$COUNT.log &"},{"sha":"08a99518030782f636db10235ad338d30f82bbea","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"modified","additions":21,"deletions":4,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -24,15 +24,19 @@ export LOG4CXX_CONF=`pwd`/log4cxx.conf\n source network-delays.sh\n source server-control.sh\n \n-all() {\n+runtest() {\n     if [ \"z$HEDWIG_NETWORK_DELAY\" != \"z\" ]; then\n \tsetup_delays $HEDWIG_NETWORK_DELAY\n     fi\n \n     stop_cluster;\n     start_cluster;\n+    if [ \"z$1\" != \"z\" ]; then\n+      ../test/hedwigtest -s true\n+    else\n+      ../test/hedwigtest\n+    fi\n \n-    ../test/hedwigtest \n     RESULT=$?\n     stop_cluster;\n \n@@ -101,14 +105,21 @@ case \"$1\" in\n     stop-cluster)\n \tstop_cluster \n \t;;\n+    simple-test)\n+        runtest\n+        ;;\n+    ssl-test)\n+        runtest ssl\n+        ;;\n     setup-delays)\n \tsetup_delays $2\n \t;;\n     clear-delays)\n \tclear_delays\n \t;;\n     all)\n-\tall\n+\truntest\n+\truntest ssl\n \t;;\n     singletest)\n \tsingletest $2\n@@ -118,7 +129,13 @@ case \"$1\" in\n Usage: tester.sh [command]\n \n tester.sh all\n-   Run through the tests, setting up and cleaning up all prerequisites.\n+   Run through the tests (both simple and ssl), setting up and cleaning up all prerequisites.\n+\n+tester.sh simple-test\n+   Run through the tests (simple mode), setting up and cleaning up all prerequisites.\n+\n+tester.sh ssl-test\n+   Run through the tests (ssl mode), setting up and cleaning up all prerequisites.\n \n tester.sh singletest <name>\n    Run a single test"},{"sha":"68d38481ede9d7b21bab48ac62a8b64ca3f5603a","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -26,6 +26,13 @@ hedwigtest_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_TH\n \n check: hedwigtest\n \tbash ../scripts/tester.sh all\n+\n+sslcheck: hedwigtest\n+\tbash ../scripts/tester.sh ssl-test\n+\n+simplecheck: hedwigtest\n+\tbash ../scripts/tester.sh simple-test\n+\n else\n check:\n \t@echo \"\\n\\nYou haven't configured with gtest. Run the ./configure command with --enable-gtest=<path_to_gtest>\""},{"sha":"2b92bf65569686cc862a151a730d906d05d5455a","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -34,6 +34,9 @@\n \n #include \"gtest/gtest.h\"\n \n+bool TestServerConfiguration::isSSL = false;\n+std::string TestServerConfiguration::certFile = \"\";\n+\n int main( int argc, char **argv)\n {\n   try {\n@@ -48,6 +51,25 @@ int main( int argc, char **argv)\n   } catch (...) {\n     std::cerr << \"unknown exception while configuring log4cpp vi'.\" << std::endl;\n   }\n+\n+  // Enable SSL for testing\n+  int opt;\n+  while((opt = getopt(argc,argv,\"s:c:\")) > 0) {\n+    switch(opt) {\n+    case 's':\n+      if (std::string(optarg) == \"true\") {\n+        std::cout << \"run in ssl mode....\" << std::endl;\n+        TestServerConfiguration::isSSL = true;\n+      } else {\n+        TestServerConfiguration::isSSL = false;\n+      }\n+      break;\n+    case 'c':\n+      std::cout << \"use cert file :\" << optarg << std::endl;\n+      TestServerConfiguration::certFile = std::string(optarg);\n+      break;\n+    }//switch\n+  }//while\n   \n   ::testing::InitGoogleTest(&argc, argv);\n   int ret = RUN_ALL_TESTS();"},{"sha":"a1ea07e54e4d86e65e72b630509ffdec81f1826c","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"modified","additions":11,"deletions":21,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -33,32 +33,16 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n-\n-class MessageBoundConfiguration : public Hedwig::Configuration {\n+class MessageBoundConfiguration : public TestServerConfiguration {\n public:\n-  MessageBoundConfiguration() : address(\"localhost:4081\") {}\n+  MessageBoundConfiguration() : TestServerConfiguration() {}\n     \n   virtual int getInt(const std::string& key, int defaultVal) const {\n     if (key == Configuration::SUBSCRIPTION_MESSAGE_BOUND) {\n       return 5;\n     }\n-    return defaultVal;\n-  }\n-\n-  virtual const std::string get(const std::string& key, const std::string& defaultVal) const {\n-    if (key == Configuration::DEFAULT_SERVER) {\n-      return address;\n-    } else {\n-      return defaultVal;\n-    }\n+    return TestServerConfiguration::getInt(key, defaultVal);\n   }\n-    \n-  virtual bool getBool(const std::string& /*key*/, bool defaultVal) const {\n-    return defaultVal;\n-  }\n-\n-protected:\n-  const std::string address;\n };\n     \n class MessageBoundOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n@@ -91,10 +75,16 @@ class MessageBoundOrderCheckingMessageHandlerCallback : public Hedwig::MessageHa\n \n void sendXExpectLastY(Hedwig::Publisher& pub, Hedwig::Subscriber& sub, const std::string& topic, \n \t\t      const std::string& subid, int X, int Y) {\n-  for (int i = 0; i < X; i++) {\n+  for (int i = 0; i < X;) {\n     std::stringstream oss;\n     oss << i;\n-    pub.publish(topic, oss.str());\n+    try {\n+      pub.publish(topic, oss.str());\n+      ++i;\n+    } catch (std::exception &e) {\n+      LOG4CXX_WARN(logger, \"Exception when publishing message \" << i << \" : \"\n+                           << e.what());\n+    }\n   }\n \n   sub.subscribe(topic, subid, Hedwig::SubscribeRequest::ATTACH);"},{"sha":"907d95da72386364160b455dfae5079db3a738c9","filename":"hedwig-client/src/main/cpp/test/messagefiltertest.cpp","status":"modified","additions":3,"deletions":18,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/messagefiltertest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/messagefiltertest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messagefiltertest.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -33,32 +33,17 @@\n \n static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n \n-class MessageFilterConfiguration : public Hedwig::Configuration {\n+class MessageFilterConfiguration : public TestServerConfiguration {\n public:\n-  MessageFilterConfiguration() : address(\"localhost:4081\") {}\n-  \n-  virtual int getInt(const std::string& key, int defaultVal) const {\n-    return defaultVal;\n-  }\n-\n-  virtual const std::string get(const std::string& key, const std::string& defaultVal) const {\n-    if (key == Configuration::DEFAULT_SERVER) {\n-      return address;\n-    } else {\n-      return defaultVal;\n-    }\n-  }\n+  MessageFilterConfiguration() : TestServerConfiguration() {}\n   \n   virtual bool getBool(const std::string& key, bool defaultVal) const {\n     if (key == Configuration::SUBSCRIBER_AUTOCONSUME) {\n       return false;\n     } else {\n-      return defaultVal;\n+      return TestServerConfiguration::getBool(key, defaultVal);\n     }\n   }\n-\n-  protected:\n-  const std::string address;\n };\n     \n class ModMessageFilter : public Hedwig::ClientMessageFilter {"},{"sha":"5a0b8e84239a2a89dcbfe93b6282e9066b288e48","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"modified","additions":16,"deletions":12,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -75,23 +75,29 @@ class PubSubMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n class PubSubOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n public:\n   PubSubOrderCheckingMessageHandlerCallback(const std::string& topic, const std::string& subscriberId, const int startMsgId, const int sleepTimeInConsume)\n-    : messagesReceived(0), topic(topic), subscriberId(subscriberId), startMsgId(startMsgId), \n-      isInOrder(true), sleepTimeInConsume(sleepTimeInConsume) {\n+    : topic(topic), subscriberId(subscriberId), startMsgId(startMsgId),\n+      nextMsgId(startMsgId), isInOrder(true), sleepTimeInConsume(sleepTimeInConsume) {\n   }\n \n   virtual void consume(const std::string& topic, const std::string& subscriberId,\n \t\t       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n     if (topic == this->topic && subscriberId == this->subscriberId) {\n       boost::lock_guard<boost::mutex> lock(mutex);\n-            \n-      messagesReceived++;\n \n       int newMsgId = atoi(msg.body().c_str());\n+      if (newMsgId == nextMsgId + 1) {\n+        // only calculate unduplicated entries\n+        ++nextMsgId;\n+      }\n+\n       // checking msgId\n       LOG4CXX_DEBUG(logger, \"received message \" << newMsgId);\n       if (startMsgId >= 0) { // need to check ordering if start msg id is larger than 0\n \tif (isInOrder) {\n-\t  if (newMsgId != startMsgId + 1) {\n+          // in some environments, ssl channel encountering error like Bad File Descriptor.\n+          // the channel would disconnect and reconnect. A duplicated message would be received.\n+          // so just checking we received a larger out-of-order message.\n+\t  if (newMsgId > startMsgId + 1) {\n \t    LOG4CXX_ERROR(logger, \"received out-of-order message : expected \" << (startMsgId + 1) << \", actual \" << newMsgId);\n \t    isInOrder = false;\n \t  } else {\n@@ -106,10 +112,9 @@ class PubSubOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerC\n     }\n   }\n     \n-  int numMessagesReceived() {\n+  int nextExpectedMsgId() {\n     boost::lock_guard<boost::mutex> lock(mutex);\n-    int i = messagesReceived;\n-    return i;\n+    return nextMsgId;\n   }    \n \n   bool inOrder() {\n@@ -119,10 +124,10 @@ class PubSubOrderCheckingMessageHandlerCallback : public Hedwig::MessageHandlerC\n     \n protected:\n   boost::mutex mutex;\n-  int messagesReceived;\n   std::string topic;\n   std::string subscriberId;\n   int startMsgId;\n+  int nextMsgId;\n   bool isInOrder;\n   int sleepTimeInConsume;\n };\n@@ -271,7 +276,7 @@ TEST(PubSubTest, testRandomDelivery) {\n \n    for (int i = 0; i < 10; i++) {\n      sleep(3);\n-     if (cb->numMessagesReceived() == 2 * numMessages) {\n+     if (cb->nextExpectedMsgId() == 2 * numMessages) {\n        break;\n      }\n    }\n@@ -329,7 +334,7 @@ TEST(PubSubTest, testRandomDelivery) {\n      PubSubOrderCheckingMessageHandlerCallback *cb =\n        (PubSubOrderCheckingMessageHandlerCallback *)(callbacks[j].get());\n      for (int i = 0; i < 10; i++) {\n-       if (cb->numMessagesReceived() == numMessages) {\n+       if (cb->nextExpectedMsgId() == numMessages) {\n \t break;\n        }\n        sleep(3);\n@@ -339,7 +344,6 @@ TEST(PubSubTest, testRandomDelivery) {\n    callbacks.clear();\n  }\n \n-\n  TEST(PubSubTest, testPubSubContinuousOverClose) {\n    std::string topic = \"pubSubTopic\";\n    std::string sid = \"MySubscriberid-1\";"},{"sha":"225e0e0a620589156b0c4c4e0a5e96de3d15d968","filename":"hedwig-client/src/main/cpp/test/util.h","status":"modified","additions":14,"deletions":4,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/853ac6bf0107a8b80e44328ce825a8e710ee8986/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=853ac6bf0107a8b80e44328ce825a8e710ee8986","patch":"@@ -136,9 +136,11 @@ class TestSubscriptionListener : public Hedwig::SubscriptionListener {\n \n class TestServerConfiguration : public Hedwig::Configuration {\n public:\n-  TestServerConfiguration() : address(\"localhost:4081\"), syncTimeout(10000), numThreads(2) {}\n+  TestServerConfiguration() : address(\"localhost:4081:9877\"),\n+                              syncTimeout(10000), numThreads(2) {}\n \n-  TestServerConfiguration(int syncTimeout, int numThreads = 2) : address(\"localhost:4081\"), syncTimeout(syncTimeout), numThreads(numThreads) {}\n+  TestServerConfiguration(int syncTimeout, int numThreads = 2)\n+    : address(\"localhost:4081:9877\"), syncTimeout(syncTimeout), numThreads(numThreads) {}\n   \n   virtual int getInt(const std::string& key, int defaultVal) const {\n     if (key == Configuration::SYNC_REQUEST_TIMEOUT) {\n@@ -152,15 +154,23 @@ class TestServerConfiguration : public Hedwig::Configuration {\n   virtual const std::string get(const std::string& key, const std::string& defaultVal) const {\n     if (key == Configuration::DEFAULT_SERVER) {\n       return address;\n+    } else if (key == Configuration::SSL_PEM_FILE) {\n+      return certFile;\n     } else {\n       return defaultVal;\n     }\n   }\n \n-  virtual bool getBool(const std::string& /*key*/, bool defaultVal) const {\n+  virtual bool getBool(const std::string& key, bool defaultVal) const {\n+    if (key == Configuration::RUN_AS_SSL_MODE) {\n+      return isSSL;\n+    }\n     return defaultVal;\n   }\n-  \n+public:\n+  // for testing\n+  static bool isSSL;\n+  static std::string certFile;\n private:\n   const std::string address;\n   const int syncTimeout;"}]}

