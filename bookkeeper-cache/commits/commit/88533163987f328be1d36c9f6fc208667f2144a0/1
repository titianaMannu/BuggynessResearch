{"sha":"88533163987f328be1d36c9f6fc208667f2144a0","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4ODUzMzE2Mzk4N2YzMjhiZTFkMzZjOWY2ZmMyMDg2NjdmMjE0NGEw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-03-12T20:26:58Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-03-12T20:26:58Z"},"message":"BOOKKEEPER-432: Improve performance of entry log range read per ledger entries (yixue, sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1576883 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8e7167794c9e510931d198e245caf85db8bba10f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8e7167794c9e510931d198e245caf85db8bba10f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/88533163987f328be1d36c9f6fc208667f2144a0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/88533163987f328be1d36c9f6fc208667f2144a0","html_url":"https://github.com/apache/bookkeeper/commit/88533163987f328be1d36c9f6fc208667f2144a0","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/88533163987f328be1d36c9f6fc208667f2144a0/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"1ac25ebe98dd3038f68fe80e79570b9beceb0be8","url":"https://api.github.com/repos/apache/bookkeeper/commits/1ac25ebe98dd3038f68fe80e79570b9beceb0be8","html_url":"https://github.com/apache/bookkeeper/commit/1ac25ebe98dd3038f68fe80e79570b9beceb0be8"}],"stats":{"total":1178,"additions":1147,"deletions":31},"files":[{"sha":"84ce07f272a3b10b1be59298cda9e2670fd07f08","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -176,6 +176,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-740: AutoRecoveryMainTest#testAutoRecoverySessionLoss is failing (Rakesh via sijie)\n \n+        BOOKKEEPER-432: Improve performance of entry log range read per ledger entries (yixue, sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"b56db55b5134b4b5322898f385da11394bab04ae","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":10,"deletions":3,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -437,9 +437,16 @@ public Bookie(ServerConfiguration conf)\n         this.ledgerDirsManager.init();\n         // instantiate the journal\n         journal = new Journal(conf, ledgerDirsManager);\n-        ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager,\n-                                                     ledgerDirsManager, indexDirsManager,\n-                                                     journal);\n+        // Check the type of storage.\n+        if (conf.getSortedLedgerStorageEnabled()) {\n+            ledgerStorage = new SortedLedgerStorage(conf, ledgerManager,\n+                                                    ledgerDirsManager, indexDirsManager,\n+                                                    journal);\n+        } else {\n+            ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager,\n+                                                         ledgerDirsManager, indexDirsManager,\n+                                                         journal);\n+        }\n         syncThread = new SyncThread(conf, getLedgerDirsListener(),\n                                     ledgerStorage, journal);\n "},{"sha":"43da72fac30c927865867b8b2f4dc9b3e57a388e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -0,0 +1,34 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Interface plugged into caching to receive callback notifications\n+ */\n+public interface CacheCallback {\n+    /**\n+     * Process notification that cache size limit reached.\n+     */\n+    public void onSizeLimitReached() throws IOException;\n+}"},{"sha":"dab5396c3a91c30a8ad55761cc2cda7241b62db0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -0,0 +1,129 @@\n+/**\n+ * Copyright The Apache Software Foundation\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * An entry Key/Value.\n+ * EntryKeyValue wraps a byte array and takes offsets and lengths into the array to\n+ * interpret the content as entry blob.\n+ */\n+public class EntryKeyValue extends EntryKey {\n+    final private byte [] bytes;\n+    private int offset = 0; // start offset of entry blob\n+    private int length = 0; // length of entry blob\n+\n+    /**\n+    * @return The byte array backing this EntryKeyValue.\n+    */\n+    public byte [] getBuffer() {\n+        return this.bytes;\n+    }\n+\n+    /**\n+    * @return Offset into {@link #getBuffer()} at which the EntryKeyValue starts.\n+    */\n+    public int getOffset() {\n+        return this.offset;\n+    }\n+\n+    /**\n+    * @return Length of bytes this EntryKeyValue occupies in {@link #getBuffer()}.\n+    */\n+    public int getLength() {\n+        return this.length;\n+    }\n+\n+    /**\n+     *\n+     * Creates a EntryKeyValue from the start of the specified byte array.\n+     * Presumes <code>bytes</code> content contains the value portion of a EntryKeyValue.\n+     * @param bytes byte array\n+     */\n+    public EntryKeyValue(long ledgerId, long entryId, final byte [] bytes) {\n+        this(ledgerId, entryId, bytes, 0, bytes.length);\n+    }\n+\n+    /**\n+     *\n+     * Creates a EntryKeyValue from the start of the specified byte array.\n+     * Presumes <code>bytes</code> content contains the value portion of a EntryKeyValue.\n+     * @param bytes byte array\n+     * @param offset offset in bytes as start of blob\n+     * @param length of blob\n+     */\n+    public EntryKeyValue(long ledgerId, long entryId, final byte [] bytes, int offset, int length) {\n+        super(ledgerId, entryId);\n+        this.bytes = bytes;\n+        this.offset = offset;\n+        this.length = length;\n+    }\n+\n+    /**\n+    * Returns the blob wrapped in a new <code>ByteBuffer</code>.\n+    *\n+    * @return the value\n+    */\n+    public ByteBuffer getValueAsByteBuffer() {\n+        return ByteBuffer.wrap(getBuffer(), getOffset(), getLength());\n+    }\n+\n+    /**\n+    * Write EntryKeyValue blob into the provided byte buffer.\n+    *\n+    * @param dst the bytes buffer to use\n+    *\n+    * @return The number of useful bytes in the buffer.\n+    *\n+    * @throws IllegalArgumentException an illegal value was passed or there is insufficient space\n+    * remaining in the buffer\n+    */\n+    int writeToByteBuffer(ByteBuffer dst) {\n+        if (dst.remaining() < getLength()) {\n+            throw new IllegalArgumentException(\"Buffer size \" + dst.remaining() + \" < \" + getLength());\n+        }\n+\n+        dst.put(getBuffer(), getOffset(), getLength());\n+        return getLength();\n+    }\n+\n+    /**\n+    * String representation\n+    */\n+    public String toString() {\n+        return ledgerId + \":\" + entryId;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        // since this entry is identified by (lid, eid)\n+        // so just use {@link org.apache.bookkeeper.bookie.EntryKey#equals}.\n+        return super.equals(other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        // since this entry is identified by (lid, eid)\n+        // so just use {@link org.apache.bookkeeper.bookie.EntryKey#hashCode} as the hash code.\n+        return super.hashCode();\n+    }\n+\n+}"},{"sha":"398af9a5ae2649f3569dfddaa091d2148acad4b2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","status":"added","additions":380,"deletions":0,"changes":380,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -0,0 +1,380 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+\n+/**\n+ * The EntryMemTable holds in-memory representation to the entries not-yet flushed.\n+ * When asked to flush, current EntrySkipList is moved to snapshot and is cleared.\n+ * We continue to serve edits out of new EntrySkipList and backing snapshot until\n+ * flusher reports in that the flush succeeded. At that point we let the snapshot go.\n+ */\n+public class EntryMemTable {\n+    private static Logger Logger = LoggerFactory.getLogger(Journal.class);\n+\n+    /**\n+     * Entry skip list\n+     */\n+    static class EntrySkipList extends ConcurrentSkipListMap<EntryKey, EntryKeyValue> {\n+        final Checkpoint cp;\n+        static final EntrySkipList EMPTY_VALUE = new EntrySkipList(Checkpoint.MAX) {\n+            @Override\n+            public boolean isEmpty() {\n+                return true;\n+            }\n+        };\n+\n+        EntrySkipList(final Checkpoint cp) {\n+            super(EntryKey.COMPARATOR);\n+            this.cp = cp;\n+        }\n+\n+        int compareTo(final Checkpoint cp) {\n+            return this.cp.compareTo(cp);\n+        }\n+\n+        @Override\n+        public EntryKeyValue put(EntryKey k, EntryKeyValue v) {\n+            return putIfAbsent(k, v);\n+        }\n+\n+        @Override\n+        public EntryKeyValue putIfAbsent(EntryKey k, EntryKeyValue v) {\n+            assert k.equals(v);\n+            return super.putIfAbsent(v, v);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return this == o;\n+        }\n+    }\n+\n+    volatile EntrySkipList kvmap;\n+\n+    // Snapshot of EntryMemTable.  Made for flusher.\n+    volatile EntrySkipList snapshot;\n+\n+    final ServerConfiguration conf;\n+    final CheckpointSource checkpointSource;\n+\n+    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    // Used to track own data size\n+    final AtomicLong size;\n+\n+    final long skipListSizeLimit;\n+\n+    SkipListArena allocator;\n+\n+    private EntrySkipList newSkipList() {\n+        return new EntrySkipList(checkpointSource.newCheckpoint());\n+    }\n+\n+    /**\n+    * Constructor.\n+    * @param conf Server configuration\n+    */\n+    public EntryMemTable(final ServerConfiguration conf, final CheckpointSource source) {\n+        this.checkpointSource = source;\n+        this.kvmap = newSkipList();\n+        this.snapshot = EntrySkipList.EMPTY_VALUE;\n+        this.conf = conf;\n+        this.size = new AtomicLong(0);\n+        this.allocator = new SkipListArena(conf);\n+        // skip list size limit\n+        this.skipListSizeLimit = conf.getSkipListSizeLimit();\n+    }\n+\n+    void dump() {\n+        for (EntryKey key: this.kvmap.keySet()) {\n+            Logger.info(key.toString());\n+        }\n+        for (EntryKey key: this.snapshot.keySet()) {\n+            Logger.info(key.toString());\n+        }\n+    }\n+\n+    Checkpoint snapshot() throws IOException {\n+        return snapshot(Checkpoint.MAX);\n+    }\n+\n+    /**\n+     * Snapshot current EntryMemTable. if given <i>oldCp</i> is older than current checkpoint,\n+     * we don't do any snapshot. If snapshot happened, we return the checkpoint of the snapshot.\n+     *\n+     * @param oldCp\n+     *          checkpoint\n+     * @return checkpoint of the snapshot, null means no snapshot\n+     * @throws IOException\n+     */\n+    Checkpoint snapshot(Checkpoint oldCp) throws IOException {\n+        Checkpoint cp = null;\n+        // No-op if snapshot currently has entries\n+        if (this.snapshot.isEmpty() &&\n+                this.kvmap.compareTo(oldCp) < 0) {\n+            this.lock.writeLock().lock();\n+            try {\n+                if (this.snapshot.isEmpty() && !this.kvmap.isEmpty()\n+                        && this.kvmap.compareTo(oldCp) < 0) {\n+                    this.snapshot = this.kvmap;\n+                    this.kvmap = newSkipList();\n+                    // get the checkpoint of the memtable.\n+                    cp = this.kvmap.cp;\n+                    // Reset heap to not include any keys\n+                    this.size.set(0);\n+                    // Reset allocator so we get a fresh buffer for the new EntryMemTable\n+                    this.allocator = new SkipListArena(conf);\n+                }\n+            } finally {\n+                this.lock.writeLock().unlock();\n+            }\n+        }\n+        return cp;\n+    }\n+\n+    /**\n+     * Flush snapshot and clear it.\n+     */\n+    long flush(final SkipListFlusher flusher) throws IOException {\n+        return flushSnapshot(flusher, Checkpoint.MAX);\n+    }\n+\n+    /**\n+     * Flush memtable until checkpoint.\n+     *\n+     * @param checkpoint\n+     *          all data before this checkpoint need to be flushed.\n+     */\n+    public long flush(SkipListFlusher flusher, Checkpoint checkpoint) throws IOException {\n+        long size = flushSnapshot(flusher, checkpoint);\n+        if (null != snapshot(checkpoint)) {\n+            size += flushSnapshot(flusher, checkpoint);\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Flush snapshot and clear it iff its data is before checkpoint.\n+     * Only this function change non-empty this.snapshot.\n+     */\n+    private long flushSnapshot(final SkipListFlusher flusher, Checkpoint checkpoint) throws IOException {\n+        long size = 0;\n+        if (this.snapshot.compareTo(checkpoint) < 0) {\n+            long ledger, ledgerGC = -1;\n+            synchronized (this) {\n+                EntrySkipList keyValues = this.snapshot;\n+                if (keyValues.compareTo(checkpoint) < 0) {\n+                    for (EntryKey key : keyValues.keySet()) {\n+                        EntryKeyValue kv = (EntryKeyValue)key;\n+                        size += kv.getLength();\n+                        ledger = kv.getLedgerId();\n+                        if (ledgerGC != ledger) {\n+                            try {\n+                                flusher.process(ledger, kv.getEntryId(), kv.getValueAsByteBuffer());\n+                            } catch (NoLedgerException exception) {\n+                                ledgerGC = ledger;\n+                            }\n+                        }\n+                    }\n+                    clearSnapshot(keyValues);\n+                }\n+            }\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * The passed snapshot was successfully persisted; it can be let go.\n+     * @param keyValues The snapshot to clean out.\n+     * @see {@link #snapshot()}\n+     */\n+    private void clearSnapshot(final EntrySkipList keyValues) {\n+        // Caller makes sure that keyValues not empty\n+        assert !keyValues.isEmpty();\n+        this.lock.writeLock().lock();\n+        try {\n+            // create a new snapshot and let the old one go.\n+            assert this.snapshot == keyValues;\n+            this.snapshot = EntrySkipList.EMPTY_VALUE;\n+        } finally {\n+            this.lock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Throttling writer w/ 1 ms delay\n+     */\n+    private void throttleWriters() {\n+        try {\n+            Thread.sleep(1);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    /**\n+    * Write an update\n+    * @param entry\n+    * @return approximate size of the passed key and value.\n+    */\n+    public long addEntry(long ledgerId, long entryId, final ByteBuffer entry, final CacheCallback cb)\n+            throws IOException {\n+        long size = 0;\n+        if (isSizeLimitReached()) {\n+            Checkpoint cp = snapshot();\n+            if (null != cp) {\n+                cb.onSizeLimitReached();\n+            } else {\n+                throttleWriters();\n+            }\n+        }\n+\n+        this.lock.readLock().lock();\n+        try {\n+            EntryKeyValue toAdd = cloneWithAllocator(ledgerId, entryId, entry);\n+            size = internalAdd(toAdd);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+    * Internal version of add() that doesn't clone KVs with the\n+    * allocator, and doesn't take the lock.\n+    *\n+    * Callers should ensure they already have the read lock taken\n+    */\n+    private long internalAdd(final EntryKeyValue toAdd) throws IOException {\n+        long sizeChange = 0;\n+        if (kvmap.putIfAbsent(toAdd, toAdd) == null) {\n+            sizeChange = toAdd.getLength();\n+            size.addAndGet(sizeChange);\n+        }\n+        return sizeChange;\n+    }\n+\n+    private EntryKeyValue newEntry(long ledgerId, long entryId, final ByteBuffer entry) {\n+        byte[] buf;\n+        int offset = 0;\n+        int length = entry.remaining();\n+\n+        if (entry.hasArray()) {\n+            buf = entry.array();\n+            offset = entry.arrayOffset();\n+        }\n+        else {\n+            buf = new byte[length];\n+            entry.get(buf);\n+        }\n+        return new EntryKeyValue(ledgerId, entryId, buf, offset, length);\n+    }\n+\n+    private EntryKeyValue cloneWithAllocator(long ledgerId, long entryId, final ByteBuffer entry) {\n+        int len = entry.remaining();\n+        SkipListArena.MemorySlice alloc = allocator.allocateBytes(len);\n+        if (alloc == null) {\n+            // The allocation was too large, allocator decided\n+            // not to do anything with it.\n+            return newEntry(ledgerId, entryId, entry);\n+        }\n+\n+        assert alloc.getData() != null;\n+        entry.get(alloc.getData(), alloc.getOffset(), len);\n+        return new EntryKeyValue(ledgerId, entryId, alloc.getData(), alloc.getOffset(), len);\n+    }\n+\n+    /**\n+     * Find the entry with given key\n+     * @param ledgerId\n+     * @param entryId\n+     * @return the entry kv or null if none found.\n+     */\n+    public EntryKeyValue getEntry(long ledgerId, long entryId) throws IOException {\n+        EntryKey key = new EntryKey(ledgerId, entryId);\n+        EntryKeyValue value = null;\n+        this.lock.readLock().lock();\n+        try {\n+            value = this.kvmap.get(key);\n+            if (value == null) {\n+                value = this.snapshot.get(key);\n+            }\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Find the last entry with the given ledger key\n+     * @param ledgerId\n+     * @return the entry kv or null if none found.\n+     */\n+    public EntryKeyValue getLastEntry(long ledgerId) throws IOException {\n+        EntryKey result = null;\n+        EntryKey key = new EntryKey(ledgerId, Long.MAX_VALUE);\n+        this.lock.readLock().lock();\n+        try {\n+            result = this.kvmap.floorKey(key);\n+            if (result == null || result.getLedgerId() != ledgerId) {\n+                result = this.snapshot.floorKey(key);\n+            }\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+\n+        if (result == null || result.getLedgerId() != ledgerId) {\n+            return null;\n+        }\n+        return (EntryKeyValue)result;\n+    }\n+\n+    /**\n+     * Check if the entire heap usage for this EntryMemTable exceeds limit\n+     */\n+    boolean isSizeLimitReached() {\n+        return size.get() >= skipListSizeLimit;\n+    }\n+\n+    /**\n+     * Check if there is data in the mem-table\n+     * @return\n+     */\n+    boolean isEmpty() {\n+        return size.get() == 0 && snapshot.isEmpty();\n+    }\n+}"},{"sha":"d309469e1761db18d783ad8631416a5abc491324","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -46,30 +46,30 @@\n     private final static Logger LOG = LoggerFactory.getLogger(InterleavedLedgerStorage.class);\n \n     // Hold the last checkpoint\n-    static class CheckpointHolder {\n+    protected static class CheckpointHolder {\n         Checkpoint lastCheckpoint = Checkpoint.MAX;\n \n-        synchronized void setNextCheckpoint(Checkpoint cp) {\n+        protected synchronized void setNextCheckpoint(Checkpoint cp) {\n             if (Checkpoint.MAX.equals(lastCheckpoint) || lastCheckpoint.compareTo(cp) < 0) {\n                 lastCheckpoint = cp;\n             }\n         }\n \n-        synchronized void clearLastCheckpoint(Checkpoint done) {\n+        protected synchronized void clearLastCheckpoint(Checkpoint done) {\n             if (0 == lastCheckpoint.compareTo(done)) {\n                 lastCheckpoint = Checkpoint.MAX;\n             }\n         }\n \n-        synchronized Checkpoint getLastCheckpoint() {\n+        protected synchronized Checkpoint getLastCheckpoint() {\n             return lastCheckpoint;\n         }\n     }\n \n     EntryLogger entryLogger;\n     LedgerCache ledgerCache;\n     private final CheckpointSource checkpointSource;\n-    private final CheckpointHolder checkpointHolder = new CheckpointHolder();\n+    protected final CheckpointHolder checkpointHolder = new CheckpointHolder();\n \n     // A sorted map to stored all active ledger ids\n     protected final SnapshotMap<Long, Boolean> activeLedgers;"},{"sha":"c3ec897f9bb7840a4f57235c737bb88b44339ab9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","status":"added","additions":238,"deletions":0,"changes":238,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -0,0 +1,238 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+\n+/**\n+ * SkipList allocation buffer to reduce memory fragment.\n+ * Adapted from HBase project.\n+ * <p>\n+ * The SkipListArena is basically a bump-the-pointer allocator that allocates\n+ * big (default 2MB) byte[] chunks from and then handles it out to threads that\n+ * request slices into the array.\n+ * <p>\n+ * The purpose of this class is to combat heap fragmentation in the\n+ * bookie. By ensuring that all KeyValues in a given SkipList refer\n+ * only to large chunks of contiguous memory, we ensure that large blocks\n+ * get freed up when the SkipList is flushed.\n+ * <p>\n+ * Without the Arena, the byte array allocated during insertion end up\n+ * interleaved throughout the heap, and the old generation gets progressively\n+ * more fragmented until a stop-the-world compacting collection occurs.\n+ * <p>\n+ */\n+public class SkipListArena {\n+    private AtomicReference<Chunk> curChunk = new AtomicReference<Chunk>();\n+\n+    final int chunkSize;\n+\n+    final int maxAlloc;\n+\n+    public SkipListArena(ServerConfiguration cfg) {\n+        chunkSize = cfg.getSkipListArenaChunkSize();\n+        maxAlloc = cfg.getSkipListArenaMaxAllocSize();\n+        assert maxAlloc <= chunkSize;\n+    }\n+\n+    /**\n+    * Allocate a slice of the given length.\n+    *\n+    * If the size is larger than the maximum size specified for this\n+    * allocator, returns null.\n+    */\n+    public MemorySlice allocateBytes(int size) {\n+        assert size >= 0;\n+\n+        // Callers should satisfy large allocations directly from JVM since they\n+        // don't cause fragmentation as badly.\n+        if (size > maxAlloc) {\n+            return null;\n+        }\n+\n+        while (true) {\n+            Chunk c = getCurrentChunk();\n+\n+            // Try to allocate from this chunk\n+            int allocOffset = c.alloc(size);\n+            if (allocOffset != -1) {\n+                // We succeeded - this is the common case - small alloc\n+                // from a big buffer\n+                return new MemorySlice(c.data, allocOffset);\n+            }\n+\n+            // not enough space!\n+            // try to retire this chunk\n+            retireCurrentChunk(c);\n+        }\n+    }\n+\n+    /**\n+    * Try to retire the current chunk if it is still there.\n+    */\n+    private void retireCurrentChunk(Chunk c) {\n+        curChunk.compareAndSet(c, null);\n+        // If the CAS fails, that means that someone else already\n+        // retired the chunk for us.\n+    }\n+\n+    /**\n+    * Get the current chunk, or, if there is no current chunk,\n+    * allocate a new one from the JVM.\n+    */\n+    private Chunk getCurrentChunk() {\n+        while (true) {\n+            // Try to get the chunk\n+            Chunk c = curChunk.get();\n+            if (c != null) {\n+                return c;\n+            }\n+\n+            // No current chunk, so we want to allocate one. We race\n+            // against other allocators to CAS in an uninitialized chunk\n+            // (which is cheap to allocate)\n+            c = new Chunk(chunkSize);\n+            if (curChunk.compareAndSet(null, c)) {\n+                c.init();\n+                return c;\n+            }\n+            // lost race\n+        }\n+    }\n+\n+    /**\n+    * A chunk of memory out of which allocations are sliced.\n+    */\n+    private static class Chunk {\n+        /** Actual underlying data */\n+        private byte[] data;\n+\n+        private static final int UNINITIALIZED = -1;\n+        private static final int OOM = -2;\n+        /**\n+         * Offset for the next allocation, or the sentinel value -1\n+         * which implies that the chunk is still uninitialized.\n+         * */\n+        private AtomicInteger nextFreeOffset = new AtomicInteger(UNINITIALIZED);\n+\n+        /** Total number of allocations satisfied from this buffer */\n+        private AtomicInteger allocCount = new AtomicInteger();\n+\n+        /** Size of chunk in bytes */\n+        private final int size;\n+\n+        /**\n+         * Create an uninitialized chunk. Note that memory is not allocated yet, so\n+         * this is cheap.\n+         * @param size in bytes\n+         */\n+        private Chunk(int size) {\n+            this.size = size;\n+        }\n+\n+        /**\n+         * Actually claim the memory for this chunk. This should only be called from\n+         * the thread that constructed the chunk. It is thread-safe against other\n+         * threads calling alloc(), who will block until the allocation is complete.\n+         */\n+        public void init() {\n+            assert nextFreeOffset.get() == UNINITIALIZED;\n+            try {\n+                data = new byte[size];\n+            } catch (OutOfMemoryError e) {\n+                boolean failInit = nextFreeOffset.compareAndSet(UNINITIALIZED, OOM);\n+                assert failInit; // should be true.\n+                throw e;\n+            }\n+            // Mark that it's ready for use\n+            boolean okInit = nextFreeOffset.compareAndSet(UNINITIALIZED, 0);\n+            assert okInit;    // single-threaded call\n+        }\n+\n+        /**\n+         * Try to allocate <code>size</code> bytes from the chunk.\n+         * @return the offset of the successful allocation, or -1 to indicate not-enough-space\n+         */\n+        public int alloc(int size) {\n+            while (true) {\n+                int oldOffset = nextFreeOffset.get();\n+                if (oldOffset == UNINITIALIZED) {\n+                    // Other thread allocating it right now\n+                    Thread.yield();\n+                    continue;\n+                }\n+                if (oldOffset == OOM) {\n+                    return -1;\n+                }\n+\n+                if (oldOffset + size > data.length) {\n+                    return -1; // alloc doesn't fit\n+                }\n+\n+                // Try to atomically claim this chunk\n+                if (nextFreeOffset.compareAndSet(oldOffset, oldOffset + size)) {\n+                    // we got the alloc\n+                    allocCount.incrementAndGet();\n+                    return oldOffset;\n+                }\n+                // lost race\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Chunk@\" + System.identityHashCode(this) +\n+                \": used(\" + allocCount.get() + \"), free(\" +\n+                (data.length - nextFreeOffset.get() + \")\");\n+        }\n+    }\n+\n+    /**\n+    * The result of a single allocation. Contains the chunk that the\n+    * allocation points into, and the offset in this array where the\n+    * slice begins.\n+    */\n+    public static class MemorySlice {\n+        private final byte[] data;\n+        private final int offset;\n+\n+        private MemorySlice(byte[] data, int off) {\n+            this.data = data;\n+            this.offset = off;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Slice:\" + \"capacity(\" + data.length + \"), offset(\" + offset + \")\";\n+        }\n+\n+        byte[] getData() {\n+            return data;\n+        }\n+\n+        int getOffset() {\n+            return offset;\n+        }\n+    }\n+}"},{"sha":"1dfb880ce288ba87ef205f362504f94a30f7a323","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -0,0 +1,43 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Flush entries from skip list\n+ */\n+public interface SkipListFlusher {\n+    /**\n+     * Process an entry.\n+     *\n+     * @param ledgerId\n+     *          Ledger ID.\n+     * @param entryId\n+     *          The entry id this entry.\n+     * @param entry\n+     *          Entry ByteBuffer\n+     * @throws IOException\n+     */\n+    public void process(long ledgerId, long entryId, ByteBuffer entry) throws IOException;\n+}"},{"sha":"21ba4721de83fba4662574788897e4c505e613ab","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -0,0 +1,185 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SortedLedgerStorage extends InterleavedLedgerStorage\n+        implements LedgerStorage, CacheCallback, SkipListFlusher {\n+    private final static Logger LOG = LoggerFactory.getLogger(SortedLedgerStorage.class);\n+\n+    private final EntryMemTable memTable;\n+    private final ScheduledExecutorService scheduler;\n+\n+    public SortedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager,\n+                               LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n+                               final CheckpointSource checkpointSource)\n+                                       throws IOException {\n+        super(conf, ledgerManager, ledgerDirsManager, indexDirsManager, null);\n+        this.memTable = new EntryMemTable(conf, checkpointSource);\n+        this.scheduler = Executors.newSingleThreadScheduledExecutor(\n+                new ThreadFactoryBuilder()\n+                .setNameFormat(\"SortedLedgerStorage-%d\")\n+                .setPriority((Thread.NORM_PRIORITY + Thread.MAX_PRIORITY)/2).build());\n+    }\n+\n+    @Override\n+    public void start() {\n+        try {\n+            flush();\n+        } catch (IOException e) {\n+            LOG.error(\"Exception thrown while flushing ledger cache.\", e);\n+        }\n+        super.start();\n+    }\n+\n+    @Override\n+    public void shutdown() throws InterruptedException {\n+        // Wait for any jobs currently scheduled to be completed and then shut down.\n+        scheduler.shutdown();\n+        if (!scheduler.awaitTermination(3, TimeUnit.SECONDS)) {\n+            scheduler.shutdownNow();\n+        }\n+        super.shutdown();\n+    }\n+\n+    @Override\n+    public boolean ledgerExists(long ledgerId) throws IOException {\n+        // Done this way because checking the skip list is an O(logN) operation compared to\n+        // the O(1) for the ledgerCache.\n+        if (!super.ledgerExists(ledgerId)) {\n+            EntryKeyValue kv = memTable.getLastEntry(ledgerId);\n+            if (null == kv) {\n+                return super.ledgerExists(ledgerId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public long addEntry(ByteBuffer entry) throws IOException {\n+        long ledgerId = entry.getLong();\n+        long entryId = entry.getLong();\n+        entry.rewind();\n+        memTable.addEntry(ledgerId, entryId, entry, this);\n+        return entryId;\n+    }\n+\n+    /**\n+     * Get the last entry id for a particular ledger.\n+     * @param ledgerId\n+     * @return\n+     */\n+    private ByteBuffer getLastEntryId(long ledgerId) throws IOException {\n+        EntryKeyValue kv = memTable.getLastEntry(ledgerId);\n+        if (null != kv) {\n+            return kv.getValueAsByteBuffer();\n+        }\n+        // If it doesn't exist in the skip list, then fallback to the ledger cache+index.\n+        return super.getEntry(ledgerId, BookieProtocol.LAST_ADD_CONFIRMED);\n+    }\n+\n+    @Override\n+    public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n+        if (entryId == BookieProtocol.LAST_ADD_CONFIRMED) {\n+            return getLastEntryId(ledgerId);\n+        }\n+        ByteBuffer buffToRet;\n+        try {\n+            buffToRet = super.getEntry(ledgerId, entryId);\n+        } catch (Bookie.NoEntryException nee) {\n+            EntryKeyValue kv = memTable.getEntry(ledgerId, entryId);\n+            if (null == kv) {\n+                // The entry might have been flushed since we last checked, so query the ledger cache again.\n+                // If the entry truly doesn't exist, then this will throw a NoEntryException\n+                buffToRet = super.getEntry(ledgerId, entryId);\n+            } else {\n+                buffToRet = kv.getValueAsByteBuffer();\n+            }\n+        }\n+        // buffToRet will not be null when we reach here.\n+        return buffToRet;\n+    }\n+\n+    @Override\n+    public Checkpoint checkpoint(final Checkpoint checkpoint) throws IOException {\n+        Checkpoint lastCheckpoint = checkpointHolder.getLastCheckpoint();\n+        // if checkpoint is less than last checkpoint, we don't need to do checkpoint again.\n+        if (lastCheckpoint.compareTo(checkpoint) > 0) {\n+            return lastCheckpoint;\n+        }\n+        memTable.flush(this, checkpoint);\n+        return super.checkpoint(checkpoint);\n+    }\n+\n+    @Override\n+    public void process(long ledgerId, long entryId,\n+                        ByteBuffer buffer) throws IOException {\n+        processEntry(ledgerId, entryId, buffer, false);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        memTable.flush(this, Checkpoint.MAX);\n+        super.flush();\n+    }\n+\n+    // CacheCallback functions.\n+    @Override\n+    public void onSizeLimitReached() throws IOException {\n+        // when size limit reached, we get the previous checkpoint from snapshot mem-table.\n+        // at this point, we are safer to schedule a checkpoint, since the entries added before\n+        // this checkpoint already written to entry logger.\n+        // but it would be better not to let mem-table flush to different entry log files,\n+        // so we roll entry log files in SortedLedgerStorage itself.\n+        // After that, we could make the process writing data to entry logger file not bound with checkpoint.\n+        // otherwise, it hurts add performance.\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    LOG.info(\"Started flushing mem table.\");\n+                    memTable.flush(SortedLedgerStorage.this);\n+                    if (entryLogger.reachEntryLogLimit(0)) {\n+                        entryLogger.rollLog();\n+                        LOG.info(\"Rolling entry logger since it reached size limitation\");\n+                    }\n+                } catch (IOException e) {\n+                    // TODO: if we failed to flush data, we should switch the bookie back to readonly mode\n+                    //       or shutdown it.\n+                    LOG.error(\"Exception thrown while flushing skip list cache.\", e);\n+                }\n+            }\n+        });\n+    }\n+}"},{"sha":"0e700517e779a05431c36cbb5a32c91ec9547c69","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":98,"deletions":15,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -21,11 +21,9 @@\n import java.util.List;\n \n import com.google.common.annotations.Beta;\n-\n+import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.lang.StringUtils;\n \n-import com.google.common.annotations.Beta;\n-\n /**\n  * Configuration manages server-side settings\n  */\n@@ -95,6 +93,11 @@\n     protected final static String READ_BUFFER_SIZE = \"readBufferSizeBytes\";\n     protected final static String WRITE_BUFFER_SIZE = \"writeBufferSizeBytes\";\n \n+    protected final static String SORTED_LEDGER_STORAGE_ENABLED = \"sortedLedgerStorageEnabled\";\n+    protected final static String SKIP_LIST_SIZE_LIMIT = \"skipListSizeLimit\";\n+    protected final static String SKIP_LIST_CHUNK_SIZE_ENTRY = \"skipListArenaChunkSize\";\n+    protected final static String SKIP_LIST_MAX_ALLOC_ENTRY = \"skipListArenaMaxAllocSize\";\n+\n     /**\n      * Construct a default configuration object\n      */\n@@ -732,7 +735,7 @@ public ServerConfiguration setMajorCompactionInterval(long interval) {\n      * that ledger.\n      *\n      * @see org.apache.bookkeeper.client.BookKeeper#openLedger\n-     * \n+     *\n      * @param waitTime time to wait before replicating ledger fragment\n      */\n     public void setOpenLedgerRereplicationGracePeriod(String waitTime) {\n@@ -743,7 +746,7 @@ public void setOpenLedgerRereplicationGracePeriod(String waitTime) {\n      * Get the grace period which the rereplication worker to wait before\n      * fencing and rereplicating a ledger fragment which is still being written\n      * to, on bookie failure.\n-     * \n+     *\n      * @return long\n      */\n     public long getOpenLedgerRereplicationGracePeriod() {\n@@ -856,6 +859,76 @@ public int getNumJournalCallbackThreads() {\n         return getInt(NUM_JOURNAL_CALLBACK_THREADS, 1);\n     }\n \n+    /**\n+     * Set sorted-ledger storage enabled or not\n+     *\n+     * @param enabled\n+     */\n+    public ServerConfiguration setSortedLedgerStorageEnabled(boolean enabled) {\n+        this.setProperty(SORTED_LEDGER_STORAGE_ENABLED, enabled);\n+        return this;\n+    }\n+\n+    /**\n+     * Check if sorted-ledger storage enabled (default true)\n+     *\n+     * @return\n+     */\n+    public boolean getSortedLedgerStorageEnabled() {\n+        return this.getBoolean(SORTED_LEDGER_STORAGE_ENABLED, true);\n+    }\n+\n+    /**\n+     * Get skip list data size limitation (default 64MB)\n+     *\n+     * @return skip list data size limitation\n+     */\n+    public long getSkipListSizeLimit() {\n+        return this.getLong(SKIP_LIST_SIZE_LIMIT, 64 * 1024 * 1024L);\n+    }\n+\n+    /**\n+     * Set skip list size limit.\n+     *\n+     * @param size skip list size limit.\n+     * @return server configuration object.\n+     */\n+    public ServerConfiguration setSkipListSizeLimit(int size) {\n+        setProperty(SKIP_LIST_SIZE_LIMIT, size);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of bytes we should use as chunk allocation for the {@link\n+     * org.apache.bookkeeper.bookie.SkipListArena}\n+     * Default is 4 MB\n+     * @return\n+     */\n+    public int getSkipListArenaChunkSize() {\n+        return getInt(SKIP_LIST_CHUNK_SIZE_ENTRY, 4096 * 1024);\n+    }\n+\n+    /**\n+     * Set the number of bytes w used as chunk allocation for {@link\n+     * org.apache.bookkeeper.bookie.SkipListArena}.\n+     *\n+     * @param size chunk size.\n+     * @return server configuration object.\n+     */\n+    public ServerConfiguration setSkipListArenaChunkSize(int size) {\n+        setProperty(SKIP_LIST_CHUNK_SIZE_ENTRY, size);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the max size we should delegate memory allocation to VM for the {@link\n+     * org.apache.bookkeeper.bookie.SkipListArena}\n+     * Default is 128 KB\n+     * @return\n+     */\n+    public int getSkipListArenaMaxAllocSize() {\n+        return getInt(SKIP_LIST_MAX_ALLOC_ENTRY, 128 * 1024);\n+    }\n \n     /**\n      * Should we group journal force writes\n@@ -940,10 +1013,10 @@ public boolean getJournalFlushWhenQueueEmpty() {\n      * Set whether the bookie is able to go into read-only mode.\n      * If this is set to false, the bookie will shutdown on encountering\n      * an error condition.\n-     * \n+     *\n      * @param enabled whether to enable read-only mode.\n-     * \n-     * @return ServerConfiguration \n+     *\n+     * @return ServerConfiguration\n      */\n     public ServerConfiguration setReadOnlyModeEnabled(boolean enabled) {\n         setProperty(READ_ONLY_MODE_ENABLED, enabled);\n@@ -952,7 +1025,7 @@ public ServerConfiguration setReadOnlyModeEnabled(boolean enabled) {\n \n     /**\n      * Get whether read-only mode is enabled. The default is false.\n-     * \n+     *\n      * @return boolean\n      */\n     public boolean isReadOnlyModeEnabled() {\n@@ -983,9 +1056,9 @@ public float getDiskUsageWarnThreshold() {\n     /**\n      * Set the Disk free space threshold as a fraction of the total\n      * after which disk will be considered as full during disk check.\n-     * \n+     *\n      * @param threshold threshold to declare a disk full\n-     * \n+     *\n      * @return ServerConfiguration\n      */\n     public ServerConfiguration setDiskUsageThreshold(float threshold) {\n@@ -995,7 +1068,7 @@ public ServerConfiguration setDiskUsageThreshold(float threshold) {\n \n     /**\n      * Returns disk free space threshold. By default it is 0.95.\n-     * \n+     *\n      * @return float\n      */\n     public float getDiskUsageThreshold() {\n@@ -1004,9 +1077,9 @@ public float getDiskUsageThreshold() {\n \n     /**\n      * Set the disk checker interval to monitor ledger disk space\n-     * \n+     *\n      * @param interval interval between disk checks for space.\n-     * \n+     *\n      * @return ServerConfiguration\n      */\n     public ServerConfiguration setDiskCheckInterval(int interval) {\n@@ -1016,7 +1089,7 @@ public ServerConfiguration setDiskCheckInterval(int interval) {\n \n     /**\n      * Get the disk checker interval\n-     * \n+     *\n      * @return int\n      */\n     public int getDiskCheckInterval() {\n@@ -1140,4 +1213,14 @@ public ServerConfiguration setJournalRemovePagesFromCache(boolean enabled) {\n         setProperty(JOURNAL_REMOVE_FROM_PAGE_CACHE, enabled);\n         return this;\n     }\n+\n+    /**\n+     * Validate the configuration.\n+     * @throws ConfigurationException\n+     */\n+    public void validate() throws ConfigurationException {\n+        if (getSkipListArenaChunkSize() < getSkipListArenaMaxAllocSize()) {\n+            throw new ConfigurationException(\"Arena max allocation size should be smaller than the chunk size.\");\n+        }\n+    }\n }"},{"sha":"0ecbecc1b1c301e52d02090443a14912d051c1b2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -262,6 +262,7 @@ private static void loadConfFile(ServerConfiguration conf, String confFile)\n         throws IllegalArgumentException {\n         try {\n             conf.loadConf(new File(confFile).toURI().toURL());\n+            conf.validate();\n         } catch (MalformedURLException e) {\n             LOG.error(\"Could not open configuration file: \" + confFile, e);\n             throw new IllegalArgumentException();"},{"sha":"97a6156356a2536891efe638d91e991356dbae10","filename":"bookkeeper-server/src/main/resources/findbugsExclude.xml","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/resources/findbugsExclude.xml?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -20,4 +20,17 @@\n     <!-- generated code, we can't be held responsible for findbugs in it //-->\n     <Class name=\"~org\\.apache\\.bookkeeper\\.proto\\.DataFormats.*\" />\n   </Match>\n+  <Match>\n+    <!-- it is safe to store external bytes reference here. since we are using\n+         bytes from a slab. //-->\n+    <Class name=\"org.apache.bookkeeper.bookie.EntryKeyValue\" />\n+    <Bug pattern=\"EI_EXPOSE_REP2\" />\n+  </Match>\n+  <Match>\n+    <!-- it is safe to store external bytes reference here. since we are using\n+         bytes from a slab. //-->\n+    <Class name=\"org.apache.bookkeeper.bookie.EntryKeyValue\" />\n+    <Method name=\"getBuffer\" />\n+    <Bug pattern=\"EI_EXPOSE_REP\" />\n+  </Match>\n </FindBugsFilter>"},{"sha":"091261dc0d105bae220a40d7fb9854e5da2209c9","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -102,6 +102,7 @@ public void setUp() throws Exception {\n         baseConf.setMinorCompactionInterval(minorCompactionInterval);\n         baseConf.setMajorCompactionInterval(majorCompactionInterval);\n         baseConf.setEntryLogFilePreAllocationEnabled(false);\n+        baseConf.setSortedLedgerStorageEnabled(false);\n \n         super.setUp();\n     }"},{"sha":"57d2d105220b05c9121489665170e58b472586eb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -211,12 +211,9 @@ public void testAddEntryFailureOnDiskFull() throws Exception {\n         bookie.getLedgerDirsManager().addToFilledDirs(entryLogger.currentDir);\n         ledgerStorage.addEntry(generateEntry(3, 1));\n         // Verify written entries\n-        Assert.assertArrayEquals(generateEntry(1, 1).array(), ledgerStorage\n-                .getEntry(1, 1).array());\n-        Assert.assertArrayEquals(generateEntry(2, 1).array(), ledgerStorage\n-                .getEntry(2, 1).array());\n-        Assert.assertArrayEquals(generateEntry(3, 1).array(), ledgerStorage\n-                .getEntry(3, 1).array());\n+        Assert.assertTrue(0 == generateEntry(1, 1).compareTo(ledgerStorage.getEntry(1, 1)));\n+        Assert.assertTrue(0 == generateEntry(2, 1).compareTo(ledgerStorage.getEntry(2, 1)));\n+        Assert.assertTrue(0 == generateEntry(3, 1).compareTo(ledgerStorage.getEntry(3, 1)));\n     }\n \n     @After"},{"sha":"d4e81d8a97db3d8e06afe3ad82f0560d242dd302","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -220,7 +220,7 @@ public void testPageEviction() throws Exception {\n \n             // flush all first to clean previous dirty ledgers\n             ledgerCache.flushLedger(true);\n-            // flush all \n+            // flush all\n             ledgerCache.flushLedger(true);\n \n             // delete serveral ledgers\n@@ -320,7 +320,8 @@ public void testIndexPageEvictionWriteOrder() throws Exception {\n             .setJournalDirName(journalDir.getPath())\n             .setLedgerDirNames(new String[] { ledgerDir.getPath() })\n             .setFlushInterval(1000)\n-            .setPageLimit(1);\n+            .setPageLimit(1)\n+            .setSortedLedgerStorageEnabled(false);\n \n         Bookie b = new Bookie(conf);\n         b.start();"},{"sha":"dcaa4294ec536b0543f22196db85e96f6b261745","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -58,6 +58,7 @@ public void setUp() throws Exception {\n         baseConf.setEntryLogSizeLimit(2 * 1024 * 1024L);\n         baseConf.setGcWaitTime(1000);\n         baseConf.setEntryLogFilePreAllocationEnabled(false);\n+        baseConf.setSortedLedgerStorageEnabled(false);\n         super.setUp();\n     }\n "},{"sha":"f010d4d390dc47e7770a811416454b40238c34b8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/88533163987f328be1d36c9f6fc208667f2144a0/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java?ref=88533163987f328be1d36c9f6fc208667f2144a0","patch":"@@ -39,6 +39,7 @@\n \n     public ReadOnlyBookieTest() {\n         super(2);\n+        baseConf.setSortedLedgerStorageEnabled(false);\n         baseConf.setEntryLogFilePreAllocationEnabled(false);\n     }\n "}]}

