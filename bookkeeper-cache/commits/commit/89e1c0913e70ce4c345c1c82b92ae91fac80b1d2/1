{"sha":"89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4OWUxYzA5MTNlNzBjZTRjMzQ1YzFjODJiOTJhZTkxZmFjODBiMWQy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-19T09:39:33Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-19T09:39:33Z"},"message":"BOOKKEEPER-299: Provide LedgerFragmentReplicator which should replicate the fragments found from LedgerChecker (umamahesh via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1374719 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7981f00886bd05e4b4c9e4f96622a2fe0611a1a6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7981f00886bd05e4b4c9e4f96622a2fe0611a1a6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","html_url":"https://github.com/apache/bookkeeper/commit/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"be94b88ea61b75246586b6495f8d3710d4c4217a","url":"https://api.github.com/repos/apache/bookkeeper/commits/be94b88ea61b75246586b6495f8d3710d4c4217a","html_url":"https://github.com/apache/bookkeeper/commit/be94b88ea61b75246586b6495f8d3710d4c4217a"}],"stats":{"total":787,"additions":565,"deletions":222},"files":[{"sha":"5b37a3e3b9e7a4eca734e57b90347726a97d0610","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","patch":"@@ -88,6 +88,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-247: Detection of under replication (ivank)\n \n+        BOOKKEEPER-299: Provide LedgerFragmentReplicator which should replicate the fragments found from LedgerChecker (umamahesh via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"85283faf9f825bd2dd3d34a688de105383d93e29","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":77,"deletions":222,"changes":299,"blob_url":"https://github.com/apache/bookkeeper/blob/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","patch":"@@ -1,6 +1,4 @@\n-package org.apache.bookkeeper.client;\n-\n-/*\n+/**\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -20,11 +18,11 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.client;\n \n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n-import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -33,24 +31,20 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n-import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.client.LedgerFragmentReplicator.SingleFragmentCallback;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.KeeperException.Code;\n-import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Admin client for BookKeeper clusters\n@@ -67,6 +61,9 @@\n \n     // BookKeeper client instance\n     private BookKeeper bkc;\n+    \n+    // LedgerFragmentReplicator instance\n+    private LedgerFragmentReplicator lfr;\n \n     /*\n      * Random number generator used to choose an available bookie server to\n@@ -135,6 +132,7 @@ public void process(WatchedEvent event) {\n         bookiesPath = conf.getZkAvailableBookiesPath();\n         // Create the BookKeeper client instance\n         bkc = new BookKeeper(conf, zk);\n+        this.lfr = new LedgerFragmentReplicator(bkc);\n     }\n \n     /**\n@@ -538,9 +536,22 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n                                   + \" to \" + newBookie);\n                     }\n                     try {\n-                        SingleFragmentCallback cb = new SingleFragmentCallback(\n+                        LedgerFragmentReplicator.SingleFragmentCallback cb = new LedgerFragmentReplicator.SingleFragmentCallback(\n                                                                                ledgerFragmentsMcb, lh, startEntryId, bookieSrc, newBookie);\n-                        recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, cb, newBookie);\n+                        ArrayList<InetSocketAddress> currentEnsemble =  lh.getLedgerMetadata().getEnsemble(startEntryId);\n+                        int bookieIndex = -1;\n+                        if (null != currentEnsemble) {\n+                            for (int i = 0; i < currentEnsemble.size(); i++) {\n+                                if (currentEnsemble.get(i).equals(bookieSrc)) {\n+                                    bookieIndex = i;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        LedgerFragment ledgerFragment = new LedgerFragment(lh.ledgerId,\n+                        startEntryId, endEntryId, bookieIndex,\n+                        currentEnsemble, lh.distributionSchedule);\n+                        asyncRecoverLedgerFragment(lh, ledgerFragment, cb, newBookie);\n                     } catch(InterruptedException e) {\n                         Thread.currentThread().interrupt();\n                         return;\n@@ -554,229 +565,73 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n      * This method asynchronously recovers a ledger fragment which is a\n      * contiguous portion of a ledger that was stored in an ensemble that\n      * included the failed bookie.\n-     *\n-     * @param bookieSrc\n-     *            Source bookie that had a failure. We want to replicate the\n-     *            ledger fragments that were stored there.\n+     * \n      * @param lh\n-     *            LedgerHandle for the ledger\n-     * @param startEntryId\n-     *            Start entry Id for the ledger fragment\n-     * @param endEntryId\n-     *            End entry Id for the ledger fragment\n+     *            - LedgerHandle for the ledger\n+     * @param lf\n+     *            - LedgerFragment to replicate\n      * @param ledgerFragmentMcb\n-     *            MultiCallback to invoke once we've recovered the current\n+     *            - MultiCallback to invoke once we've recovered the current\n      *            ledger fragment.\n      * @param newBookie\n-     *            New bookie we want to use to recover and replicate the ledger\n-     *            entries that were stored on the failed bookie.\n+     *            - New bookie we want to use to recover and replicate the\n+     *            ledger entries that were stored on the failed bookie.\n      */\n-    private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final LedgerHandle lh,\n-                                       final Long startEntryId, final Long endEntryId, final SingleFragmentCallback cb,\n-                                       final InetSocketAddress newBookie) throws InterruptedException {\n-        if (endEntryId == null) {\n-            /*\n-             * Ideally this should never happen if bookie failure is taken care\n-             * of properly. Nothing we can do though in this case.\n-             */\n-            LOG.warn(\"Dead bookie (\" + bookieSrc + \") is still part of the current active ensemble for ledgerId: \"\n-                     + lh.getId());\n-            cb.processResult(BKException.Code.OK, null, null);\n-            return;\n-        }\n-        if (startEntryId > endEntryId) {\n-            // for open ledger which there is no entry, the start entry id is 0, the end entry id is -1.\n-            // we can return immediately to trigger forward read\n-            cb.processResult(BKException.Code.OK, null, null);\n-            return;\n-        }\n-\n-        ArrayList<InetSocketAddress> curEnsemble = lh.getLedgerMetadata().getEnsembles().get(startEntryId);\n-        int bookieIndex = 0;\n-        for (int i = 0; i < curEnsemble.size(); i++) {\n-            if (curEnsemble.get(i).equals(bookieSrc)) {\n-                bookieIndex = i;\n-                break;\n-            }\n-        }\n-        /*\n-         * Loop through all entries in the current ledger fragment range and\n-         * find the ones that were stored on the dead bookie.\n-         */\n-        List<Long> entriesToReplicate = new LinkedList<Long>();\n-        for (long i = startEntryId; i <= endEntryId; i++) {\n-            if (lh.getDistributionSchedule().getReplicaIndex(i, bookieIndex) >= 0) {\n-                /*\n-                 * Current entry is stored on the dead bookie so we'll need to\n-                 * read it and replicate it to a new bookie.\n-                 */\n-                entriesToReplicate.add(i);\n-            }\n-        }\n-        /*\n-         * Now asynchronously replicate all of the entries for the ledger\n-         * fragment that were on the dead bookie.\n-         */\n-        MultiCallback ledgerFragmentEntryMcb =\n-            new MultiCallback(entriesToReplicate.size(), cb, null,\n-                              BKException.Code.OK, BKException.Code.LedgerRecoveryException);\n-        for (final Long entryId : entriesToReplicate) {\n-            recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb, newBookie);\n-        }\n+    private void asyncRecoverLedgerFragment(final LedgerHandle lh,\n+            final LedgerFragment ledgerFragment,\n+            final LedgerFragmentReplicator.SingleFragmentCallback ledgerFragmentMcb,\n+            final InetSocketAddress newBookie) throws InterruptedException {\n+        lfr.replicate(lh, ledgerFragment, ledgerFragmentMcb, newBookie);\n     }\n \n     /**\n-     * This method asynchronously recovers a specific ledger entry by reading\n-     * the values via the BookKeeper Client (which would read it from the other\n-     * replicas) and then writing it to the chosen new bookie.\n-     *\n-     * @param entryId\n-     *            Ledger Entry ID to recover.\n+     * Replicate the Ledger fragment to target Bookie passed.\n+     * \n      * @param lh\n-     *            LedgerHandle for the ledger\n-     * @param ledgerFragmentEntryMcb\n-     *            MultiCallback to invoke once we've recovered the current\n-     *            ledger entry.\n-     * @param newBookie\n-     *            New bookie we want to use to recover and replicate the ledger\n-     *            entries that were stored on the failed bookie.\n+     *            - ledgerHandle\n+     * @param lf\n+     *            - LedgerFragment to replicate\n+     * @param targetBookieAddress\n+     *            - target Bookie, to where entries should be replicated.\n+     * @return true - if replication success, false if fails to replicate.\n      */\n-    private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n-                                            final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,\n-                                            final InetSocketAddress newBookie) throws InterruptedException {\n-        /*\n-         * Read the ledger entry using the LedgerHandle. This will allow us to\n-         * read the entry from one of the other replicated bookies other than\n-         * the dead one.\n-         */\n-        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {\n-            @Override\n-            public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"BK error reading ledger entry: \" + entryId, BKException.create(rc));\n-                    ledgerFragmentEntryMcb.processResult(rc, null, null);\n-                    return;\n-                }\n-                /*\n-                 * Now that we've read the ledger entry, write it to the new\n-                 * bookie we've selected.\n-                 */\n-                LedgerEntry entry = seq.nextElement();\n-                byte[] data = entry.getEntry();\n-                ChannelBuffer toSend = lh.getDigestManager().computeDigestAndPackageForSending(entryId,\n-                                       lh.getLastAddConfirmed(), entry.getLength(), data, 0, data.length);\n-                bkc.getBookieClient().addEntry(newBookie, lh.getId(), lh.getLedgerKey(), entryId, toSend,\n-                new WriteCallback() {\n-                    @Override\n-                    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr,\n-                    Object ctx) {\n-                        if (rc != Code.OK.intValue()) {\n-                            LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n-                                      + entryId + \", bookie: \" + addr, BKException.create(rc));\n-                        } else {\n-                            if (LOG.isDebugEnabled()) {\n-                                LOG.debug(\"Success writing ledger id \" +ledgerId + \", entry id \"\n-                                          + entryId + \" to a new bookie \" + addr + \"!\");\n-                            }\n-                        }\n-                        /*\n-                         * Pass the return code result up the chain with\n-                         * the parent callback.\n-                         */\n-                        ledgerFragmentEntryMcb.processResult(rc, null, null);\n-                    }\n-                }, null, BookieProtocol.FLAG_RECOVERY_ADD);\n-            }\n-        }, null);\n+    boolean replicateLedgerFragment(LedgerHandle lh,\n+            final LedgerFragment ledgerFragment,\n+            InetSocketAddress targetBookieAddress) throws InterruptedException {\n+        final SyncCounter syncCounter = new SyncCounter();\n+        ResultCallBack resultCallBack = new ResultCallBack(syncCounter);\n+        SingleFragmentCallback sfcb = new SingleFragmentCallback(\n+                resultCallBack, lh, ledgerFragment.getFirstStoredEntryId(),\n+                ledgerFragment.getAddress(), targetBookieAddress);\n+        syncCounter.inc();\n+        lfr.replicate(lh, ledgerFragment, sfcb, targetBookieAddress);\n+        syncCounter.block(0);\n+        return resultCallBack.getResult();\n     }\n \n-    /*\n-     * Callback for recovery of a single ledger fragment.\n-     * Once the fragment has had all entries replicated, update the ensemble \n-     * in zookeeper.\n-     * Once finished propogate callback up to ledgerFragmentsMcb which should\n-     * be a multicallback responsible for all fragments in a single ledger\n-     */\n-    static class SingleFragmentCallback implements AsyncCallback.VoidCallback {\n-        final AsyncCallback.VoidCallback ledgerFragmentsMcb;\n-        final LedgerHandle lh;\n-        final long fragmentStartId;\n-        final InetSocketAddress oldBookie;\n-        final InetSocketAddress newBookie;\n-\n-        SingleFragmentCallback(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n-                               LedgerHandle lh,\n-                               long fragmentStartId,\n-                               InetSocketAddress oldBookie,\n-                               InetSocketAddress newBookie) {\n-            this.ledgerFragmentsMcb = ledgerFragmentsMcb;\n-            this.lh = lh;\n-            this.fragmentStartId = fragmentStartId;\n-            this.newBookie = newBookie;\n-            this.oldBookie = oldBookie;\n-        }\n-        \n-        @Override\n-        public void processResult(int rc, String path, Object ctx) {\n-            if (rc != Code.OK.intValue()) {\n-                LOG.error(\"BK error replicating ledger fragments for ledger: \" + lh.getId(), \n-                          BKException.create(rc));\n-                ledgerFragmentsMcb.processResult(rc, null, null);\n-                return;\n-            }\n-            writeLedgerConfig();\n+    /** This is the class for getting the replication result */\n+    static class ResultCallBack implements AsyncCallback.VoidCallback {\n+\n+        private boolean result;\n+        private SyncCounter sync;\n+\n+        public boolean getResult() {\n+            return this.result;\n         }\n \n-        protected void writeLedgerConfig() {\n-            /*\n-             * Update the ledger metadata's ensemble info to point\n-             * to the new bookie.\n-             */\n-            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().get(\n-                    fragmentStartId);\n-            int deadBookieIndex = ensemble.indexOf(oldBookie);\n-            ensemble.remove(deadBookieIndex);\n-            ensemble.add(deadBookieIndex, newBookie);\n-            lh.writeLedgerConfig(new WriteCb());\n+        public ResultCallBack(SyncCounter sync) {\n+            this.sync = sync;\n         }\n-        \n-        private class WriteCb implements GenericCallback<Void> {\n-            @Override\n-            public void operationComplete(int rc, Void result) {\n-                if (rc == BKException.Code.MetadataVersionException) {\n-                    LOG.warn(\"Two fragments attempted update at once; ledger id: \" + lh.getId() \n-                             + \" startid: \" + fragmentStartId);\n-                    // try again, the previous success (with which this has conflicted)\n-                    // will have updated the stat\n-                    // other operations such as (addEnsemble) would update it too.\n-                    lh.rereadMetadata(new GenericCallback<LedgerMetadata>() {\n-                        @Override\n-                        public void operationComplete(int rc, LedgerMetadata newMeta) {\n-                            if (rc != BKException.Code.OK) {\n-                                LOG.error(\"Error reading updated ledger metadata for ledger \" + lh.getId());\n-                                ledgerFragmentsMcb.processResult(rc, null, null);\n-                            } else {\n-                                lh.metadata = newMeta;\n-                                writeLedgerConfig();\n-                            }\n-                        }\n-                    });\n-                    return;\n-                } else if (rc != BKException.Code.OK) {\n-                    LOG.error(\"Error updating ledger config metadata for ledgerId \" + lh.getId() + \" : \"\n-                            + BKException.getMessage(rc));\n-                } else {\n-                    LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId() + \" : \" + fragmentStartId \n-                             + \") to point ledger fragments from old dead bookie: (\" + oldBookie\n-                             + \") to new bookie: (\" + newBookie + \")\");\n-                }\n-                /*\n-                 * Pass the return code result up the chain with\n-                 * the parent callback.\n-                 */\n-                ledgerFragmentsMcb.processResult(rc, null, null);\n+\n+        @Override\n+        public void processResult(int rc, String s, Object obj) {\n+\n+            if (rc != BKException.Code.OK) {\n+                this.result = false;\n+            } else {\n+                this.result = true;\n             }\n-        };\n+            sync.dec();\n+        }\n     }\n-\n }"},{"sha":"d371df199bfdcf23f82019b8604cabfeee4d0350","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"added","additions":298,"deletions":0,"changes":298,"blob_url":"https://github.com/apache/bookkeeper/blob/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","raw_url":"https://github.com/apache/bookkeeper/raw/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java?ref=89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","patch":"@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is the helper class for replicating the fragments from one bookie to\n+ * another\n+ */\n+public class LedgerFragmentReplicator {\n+\n+    // BookKeeper instance\n+    private BookKeeper bkc;\n+\n+    public LedgerFragmentReplicator(BookKeeper bkc) {\n+        this.bkc = bkc;\n+    }\n+\n+    private static Logger LOG = LoggerFactory\n+            .getLogger(LedgerFragmentReplicator.class);\n+\n+    /**\n+     * This method replicate a ledger fragment which is a contiguous portion of\n+     * a ledger that was stored in an ensemble that included the failed bookie.\n+     * \n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param lf\n+     *            LedgerFragment to replicate\n+     * @param ledgerFragmentMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger fragment.\n+     * @param newBookie\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    void replicate(final LedgerHandle lh, final LedgerFragment lf,\n+            final SingleFragmentCallback ledgerFragmentMcb,\n+            final InetSocketAddress newBookie) throws InterruptedException {\n+        Long startEntryId = lf.firstEntryId;\n+        Long endEntryId = lf.lastEntryId;\n+        if (endEntryId == null) {\n+            /*\n+             * Ideally this should never happen if bookie failure is taken care\n+             * of properly. Nothing we can do though in this case.\n+             */\n+            LOG.warn(\"Dead bookie (\" + lf.getAddress()\n+                    + \") is still part of the current\"\n+                    + \" active ensemble for ledgerId: \" + lh.getId());\n+            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n+        if (startEntryId > endEntryId) {\n+            // for open ledger which there is no entry, the start entry id is 0,\n+            // the end entry id is -1.\n+            // we can return immediately to trigger forward read\n+            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n+\n+        /*\n+         * Add all the entries to entriesToReplicate list from\n+         * firstStoredEntryId to lastStoredEntryID.\n+         */\n+        List<Long> entriesToReplicate = new LinkedList<Long>();\n+        long lastStoredEntryId = lf.getLastStoredEntryId();\n+        for (long i = lf.getFirstStoredEntryId(); i <= lastStoredEntryId; i++) {\n+            entriesToReplicate.add(i);\n+        }\n+        /*\n+         * Now asynchronously replicate all of the entries for the ledger\n+         * fragment that were on the dead bookie.\n+         */\n+        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(\n+                entriesToReplicate.size(), ledgerFragmentMcb, null, BKException.Code.OK,\n+                BKException.Code.LedgerRecoveryException);\n+        for (final Long entryId : entriesToReplicate) {\n+            recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb,\n+                    newBookie);\n+        }\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a specific ledger entry by reading\n+     * the values via the BookKeeper Client (which would read it from the other\n+     * replicas) and then writing it to the chosen new bookie.\n+     * \n+     * @param entryId\n+     *            Ledger Entry ID to recover.\n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param ledgerFragmentEntryMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger entry.\n+     * @param newBookie\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    private void recoverLedgerFragmentEntry(final Long entryId,\n+            final LedgerHandle lh,\n+            final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,\n+            final InetSocketAddress newBookie) throws InterruptedException {\n+        /*\n+         * Read the ledger entry using the LedgerHandle. This will allow us to\n+         * read the entry from one of the other replicated bookies other than\n+         * the dead one.\n+         */\n+        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {\n+            @Override\n+            public void readComplete(int rc, LedgerHandle lh,\n+                    Enumeration<LedgerEntry> seq, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"BK error reading ledger entry: \" + entryId,\n+                            BKException.create(rc));\n+                    ledgerFragmentEntryMcb.processResult(rc, null, null);\n+                    return;\n+                }\n+                /*\n+                 * Now that we've read the ledger entry, write it to the new\n+                 * bookie we've selected.\n+                 */\n+                LedgerEntry entry = seq.nextElement();\n+                byte[] data = entry.getEntry();\n+                ChannelBuffer toSend = lh.getDigestManager()\n+                        .computeDigestAndPackageForSending(entryId,\n+                                lh.getLastAddConfirmed(), entry.getLength(),\n+                                data, 0, data.length);\n+                bkc.getBookieClient().addEntry(newBookie, lh.getId(),\n+                        lh.getLedgerKey(), entryId, toSend,\n+                        new WriteCallback() {\n+                            @Override\n+                            public void writeComplete(int rc, long ledgerId,\n+                                    long entryId, InetSocketAddress addr,\n+                                    Object ctx) {\n+                                if (rc != Code.OK.intValue()) {\n+                                    LOG.error(\n+                                            \"BK error writing entry for ledgerId: \"\n+                                                    + ledgerId + \", entryId: \"\n+                                                    + entryId + \", bookie: \"\n+                                                    + addr, BKException\n+                                                    .create(rc));\n+                                } else {\n+                                    if (LOG.isDebugEnabled()) {\n+                                        LOG.debug(\"Success writing ledger id \"\n+                                                + ledgerId + \", entry id \"\n+                                                + entryId + \" to a new bookie \"\n+                                                + addr + \"!\");\n+                                    }\n+                                }\n+                                /*\n+                                 * Pass the return code result up the chain with\n+                                 * the parent callback.\n+                                 */\n+                                ledgerFragmentEntryMcb.processResult(rc, null,\n+                                        null);\n+                            }\n+                        }, null, BookieProtocol.FLAG_RECOVERY_ADD);\n+            }\n+        }, null);\n+    }\n+    \n+    /**\n+     * Callback for recovery of a single ledger fragment. Once the fragment has\n+     * had all entries replicated, update the ensemble in zookeeper. Once\n+     * finished propogate callback up to ledgerFragmentsMcb which should be a\n+     * multicallback responsible for all fragments in a single ledger\n+     */\n+    static class SingleFragmentCallback implements AsyncCallback.VoidCallback {\n+        final AsyncCallback.VoidCallback ledgerFragmentsMcb;\n+        final LedgerHandle lh;\n+        final long fragmentStartId;\n+        final InetSocketAddress oldBookie;\n+        final InetSocketAddress newBookie;\n+\n+        SingleFragmentCallback(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n+                LedgerHandle lh, long fragmentStartId,\n+                InetSocketAddress oldBookie, InetSocketAddress newBookie) {\n+            this.ledgerFragmentsMcb = ledgerFragmentsMcb;\n+            this.lh = lh;\n+            this.fragmentStartId = fragmentStartId;\n+            this.newBookie = newBookie;\n+            this.oldBookie = oldBookie;\n+        }\n+\n+        @Override\n+        public void processResult(int rc, String path, Object ctx) {\n+            if (rc != Code.OK.intValue()) {\n+                LOG.error(\"BK error replicating ledger fragments for ledger: \"\n+                        + lh.getId(), BKException.create(rc));\n+                ledgerFragmentsMcb.processResult(rc, null, null);\n+                return;\n+            }\n+            writeLedgerConfig();\n+        }\n+\n+        protected void writeLedgerConfig() {\n+            /*\n+             * Update the ledger metadata's ensemble info to point to the new\n+             * bookie.\n+             */\n+            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+                    .getEnsembles().get(fragmentStartId);\n+            int deadBookieIndex = ensemble.indexOf(oldBookie);\n+            ensemble.remove(deadBookieIndex);\n+            ensemble.add(deadBookieIndex, newBookie);\n+            lh.writeLedgerConfig(new WriteCb());\n+        }\n+\n+        private class WriteCb implements GenericCallback<Void> {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (rc == BKException.Code.MetadataVersionException) {\n+                    LOG\n+                            .warn(\"Two fragments attempted update at once; ledger id: \"\n+                                    + lh.getId()\n+                                    + \" startid: \"\n+                                    + fragmentStartId);\n+                    // try again, the previous success (with which this has\n+                    // conflicted)\n+                    // will have updated the stat\n+                    // other operations such as (addEnsemble) would update it\n+                    // too.\n+                    lh.rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                        @Override\n+                        public void operationComplete(int rc,\n+                                LedgerMetadata newMeta) {\n+                            if (rc != BKException.Code.OK) {\n+                                LOG\n+                                        .error(\"Error reading updated ledger metadata for ledger \"\n+                                                + lh.getId());\n+                                ledgerFragmentsMcb\n+                                        .processResult(rc, null, null);\n+                            } else {\n+                                lh.metadata = newMeta;\n+                                writeLedgerConfig();\n+                            }\n+                        }\n+                    });\n+                    return;\n+                } else if (rc != BKException.Code.OK) {\n+                    LOG\n+                            .error(\"Error updating ledger config metadata for ledgerId \"\n+                                    + lh.getId()\n+                                    + \" : \"\n+                                    + BKException.getMessage(rc));\n+                } else {\n+                    LOG\n+                            .info(\"Updated ZK for ledgerId: (\"\n+                                    + lh.getId()\n+                                    + \" : \"\n+                                    + fragmentStartId\n+                                    + \") to point ledger fragments from old dead bookie: (\"\n+                                    + oldBookie + \") to new bookie: (\"\n+                                    + newBookie + \")\");\n+                }\n+                /*\n+                 * Pass the return code result up the chain with the parent\n+                 * callback.\n+                 */\n+                ledgerFragmentsMcb.processResult(rc, null, null);\n+            }\n+        };\n+    }\n+\n+}"},{"sha":"b0a24fffb12df2d6085efc4eebef105ebf6a4e41","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","status":"added","additions":188,"deletions":0,"changes":188,"blob_url":"https://github.com/apache/bookkeeper/blob/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","raw_url":"https://github.com/apache/bookkeeper/raw/89e1c0913e70ce4c345c1c82b92ae91fac80b1d2/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java?ref=89e1c0913e70ce4c345c1c82b92ae91fac80b1d2","patch":"@@ -0,0 +1,188 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one \n+ * or more contributor license agreements.  See the NOTICE file \n+ * distributed with this work for additional information \n+ * regarding copyright ownership.  The ASF licenses this file \n+ * to you under the Apache License, Version 2.0 (the \n+ * \"License\"); you may not use this file except in compliance \n+ * with the License.  You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0 \n+ * \n+ * Unless required by applicable law or agreed to in writing, \n+ * software distributed under the License is distributed on an \n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n+ * KIND, either express or implied.  See the License for the \n+ * specific language governing permissions and limitations \n+ * under the License. \n+ * \n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Tests BKAdmin that it should be able to replicate the failed bookie fragments\n+ * to target bookie.\n+ */\n+public class TestLedgerFragmentReplication extends BookKeeperClusterTestCase {\n+\n+    private static Logger LOG = LoggerFactory\n+            .getLogger(TestLedgerFragmentReplication.class);\n+\n+    public TestLedgerFragmentReplication() {\n+        super(3);\n+    }\n+\n+    private static class CheckerCallback implements\n+            GenericCallback<Set<LedgerFragment>> {\n+        private Set<LedgerFragment> result = null;\n+        private CountDownLatch latch = new CountDownLatch(1);\n+\n+        Set<LedgerFragment> waitAndGetResult() throws InterruptedException {\n+            latch.await();\n+            return result;\n+        }\n+\n+        @Override\n+        public void operationComplete(int rc, Set<LedgerFragment> result) {\n+            this.result = result;\n+            latch.countDown();\n+        }\n+    }\n+\n+    /**\n+     * Tests that replicate method should replicate the failed bookie fragments\n+     * to target bookie passed.\n+     */\n+    @Test\n+    public void testReplicateLFShouldCopyFailedBookieFragmentsToTargetBookie()\n+            throws Exception {\n+        byte[] data = \"TestLedgerFragmentReplication\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+                .get(0L).get(0);\n+\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        killBookie(replicaToKill);\n+\n+        int startNewBookie = startNewBookie();\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+        Set<LedgerFragment> result = getFragmentsToReplicate(lh);\n+\n+        BookKeeperAdmin admin = new BookKeeperAdmin(baseClientConf);\n+        lh.close();\n+        // 0-9 entries should be copy to new bookie\n+        \n+        for (LedgerFragment lf : result) {\n+            assertTrue(admin.replicateLedgerFragment(lh, lf, newBkAddr));\n+        }\n+\n+        // Killing all bookies except newly replicated bookie\n+        SortedMap<Long, ArrayList<InetSocketAddress>> allBookiesBeforeReplication = lh\n+                .getLedgerMetadata().getEnsembles();\n+        Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = allBookiesBeforeReplication\n+                .entrySet();\n+        for (Entry<Long, ArrayList<InetSocketAddress>> entry : entrySet) {\n+            ArrayList<InetSocketAddress> bookies = entry.getValue();\n+            for (InetSocketAddress bookie : bookies) {\n+                if (newBkAddr.equals(bookie)) {\n+                    continue;\n+                }\n+                killBookie(bookie);\n+            }\n+        }\n+\n+        // Should be able to read the entries from 0-9\n+        verifyRecoveredLedgers(lh, 0, 9);\n+    }\n+\n+    /**\n+     * Tests that ReplicateLedgerFragment should return false if replication\n+     * fails\n+     */\n+    @Test\n+    public void testReplicateLFShouldReturnFalseIfTheReplicationFails()\n+            throws Exception {\n+        byte[] data = \"TestLedgerFragmentReplication\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(2, 1, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // Kill the first Bookie\n+        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+                .get(0L).get(0);\n+        killBookie(replicaToKill);\n+        LOG.info(\"Killed Bookie =\" + replicaToKill);\n+\n+        // Write some more entries\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        // Kill the second Bookie\n+        replicaToKill = lh.getLedgerMetadata().getEnsembles().get(0L).get(0);\n+        killBookie(replicaToKill);\n+        LOG.info(\"Killed Bookie =\" + replicaToKill);\n+\n+        Set<LedgerFragment> fragments = getFragmentsToReplicate(lh);\n+        BookKeeperAdmin admin = new BookKeeperAdmin(baseClientConf);\n+        int startNewBookie = startNewBookie();\n+        InetSocketAddress additionalBK = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        for (LedgerFragment lf : fragments) {\n+            assertFalse(\"Replication should fail\", admin\n+                    .replicateLedgerFragment(lh, lf, additionalBK));\n+        }\n+    }\n+\n+    private Set<LedgerFragment> getFragmentsToReplicate(LedgerHandle lh)\n+            throws InterruptedException {\n+        LedgerChecker checker = new LedgerChecker(bkc);\n+        CheckerCallback cb = new CheckerCallback();\n+        checker.checkLedger(lh, cb);\n+        Set<LedgerFragment> fragments = cb.waitAndGetResult();\n+        return fragments;\n+    }\n+\n+    private void verifyRecoveredLedgers(LedgerHandle lh, long startEntryId,\n+            long endEntryId) throws BKException, InterruptedException {\n+        LedgerHandle lhs = bkc.openLedgerNoRecovery(lh.getId(),\n+                BookKeeper.DigestType.CRC32, \"testpasswd\".getBytes());\n+        Enumeration<LedgerEntry> entries = lhs.readEntries(startEntryId,\n+                endEntryId);\n+        assertTrue(\"Should have the elements\", entries.hasMoreElements());\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            assertEquals(\"TestLedgerFragmentReplication\", new String(entry\n+                    .getEntry()));\n+        }\n+    }\n+\n+}"}]}

