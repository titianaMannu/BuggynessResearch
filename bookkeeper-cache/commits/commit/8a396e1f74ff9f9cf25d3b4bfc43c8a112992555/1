{"sha":"8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4YTM5NmUxZjc0ZmY5ZjljZjI1ZDNiNGJmYzQzYzhhMTEyOTkyNTU1","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-12-27T22:16:40Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-12-27T22:16:40Z"},"message":"BOOKKEEPER-520: BookieFailureTest hangs on precommit build (sijie via fpj, jira reopened)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1426349 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"01d80c547aae127b5f9dcf74654f4462f3460e35","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/01d80c547aae127b5f9dcf74654f4462f3460e35"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","html_url":"https://github.com/apache/bookkeeper/commit/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","url":"https://api.github.com/repos/apache/bookkeeper/commits/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d","html_url":"https://github.com/apache/bookkeeper/commit/7de3ecbd5d5052138a9c4aded9256c5030ab2f6d"}],"stats":{"total":81,"additions":65,"deletions":16},"files":[{"sha":"dd6a000b34f938ca5d1ae378e18d833c54f99119","filename":"CHANGES.txt","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","patch":"@@ -153,6 +153,7 @@ Trunk (unreleased changes)\n         BOOKKEEPER-520: BookieFailureTest hangs on precommit build (ivank via sijie)\n \n         BOOKKEEPER-447: Bookie can fail to recover if index pages flushed before ledger flush acknowledged (ivank via sijie)\n+\tBOOKKEEPER-520: BookieFailureTest hangs on precommit build (sijie via fpj, jira reopened)\n \n       hedwig-protocol:\n "},{"sha":"e06725fa556ef369d2de9f33ea978496924506ce","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":42,"deletions":8,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,7 +15,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.client;\n \n+import java.util.HashSet;\n+import java.util.Set;\n import java.net.InetSocketAddress;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -42,6 +43,7 @@\n     AddCallback cb;\n     Object ctx;\n     long entryId;\n+    Set<Integer> writeSet;\n \n     DistributionSchedule.AckSet ackSet;\n     boolean completed = false;\n@@ -69,6 +71,7 @@ PendingAddOp enableRecoveryAdd() {\n \n     void setEntryId(long entryId) {\n         this.entryId = entryId;\n+        writeSet = new HashSet<Integer>(lh.distributionSchedule.getWriteSet(entryId));\n     }\n \n     void sendWriteRequest(int bookieIndex) {\n@@ -85,6 +88,24 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n             // now\n             return;\n         }\n+        // Suppose that unset doesn't happen on the write set of an entry. In this\n+        // case we don't need to resend the write request upon an ensemble change.\n+        // We do need to invoke #sendAddSuccessCallbacks() for such entries because\n+        // they may have already completed, but they are just waiting for the ensemble\n+        // to change.\n+        // E.g.\n+        // ensemble (A, B, C, D), entry k is written to (A, B, D). An ensemble change\n+        // happens to replace C with E. Entry k does not complete until C is\n+        // replaced with E successfully. When the ensemble change completes, it tries\n+        // to unset entry k. C however is not in k's write set, so no entry is written\n+        // again, and no one triggers #sendAddSuccessCallbacks. Consequently, k never\n+        // completes.\n+        //\n+        // We call sendAddSuccessCallback when unsetting t cover this case.\n+        if (!writeSet.contains(bookieIndex)) {\n+            lh.sendAddSuccessCallbacks();\n+            return;\n+        }\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Unsetting success for ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n@@ -102,7 +123,7 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n \n     void initiate(ChannelBuffer toSend) {\n         this.toSend = toSend;\n-        for (int bookieIndex : lh.distributionSchedule.getWriteSet(entryId)) {\n+        for (int bookieIndex : writeSet) {\n             sendWriteRequest(bookieIndex);\n         }\n     }\n@@ -130,14 +151,18 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             return;\n         }\n \n+        if (!writeSet.contains(bookieIndex)) {\n+            LOG.warn(\"Received a response for (lid:{}, eid:{}) from {}@{}, but it doesn't belong to {}.\",\n+                     new Object[] { ledgerId, entryId, addr, bookieIndex, writeSet });\n+            return;\n+        }\n+\n         if (ackSet.addBookieAndCheck(bookieIndex) && !completed) {\n             completed = true;\n \n-            // do some quick checks to see if some adds may have finished. All\n-            // this will be checked under locks again\n-            if (lh.pendingAddOps.peek() == this) {\n-                lh.sendAddSuccessCallbacks();\n-            }\n+            LOG.debug(\"Complete (lid:{}, eid:{}).\", ledgerId, entryId);\n+            // when completed an entry, try to send success add callbacks in order\n+            lh.sendAddSuccessCallbacks();\n         }\n     }\n \n@@ -146,4 +171,13 @@ void submitCallback(final int rc) {\n         lh.opCounterSem.release();\n     }\n \n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"PendingAddOp(lid:\").append(lh.ledgerId)\n+          .append(\", eid:\").append(entryId).append(\", completed:\")\n+          .append(completed).append(\")\");\n+        return sb.toString();\n+    }\n+\n }"},{"sha":"868781e9892fc09ee61bd2e6949c524389236020","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","patch":"@@ -150,7 +150,7 @@ synchronized InetSocketAddress sendNextRead() {\n                 // we are done, the read has failed from all replicas, just fail the\n                 // read\n \n-                // Do it a bit perssimistically, only when finished trying all replicas\n+                // Do it a bit pessimistically, only when finished trying all replicas\n                 // to check whether we received more missed reads than maxMissedReadsAllowed\n                 if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n                     numMissedEntryReads > maxMissedReadsAllowed) {"},{"sha":"f1e9e88227f3e9041c9bb2a1d95a0365333a7046","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":21,"deletions":7,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","patch":"@@ -107,9 +107,14 @@ public void addEntry(final InetSocketAddress addr, final long ledgerId, final by\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n             @Override\n-            public void operationComplete(int rc, Void result) {\n+            public void operationComplete(final int rc, Void result) {\n                 if (rc != BKException.Code.OK) {\n-                    cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+                    executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                        @Override\n+                        public void safeRun() {\n+                            cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+                        }\n+                    });\n                     return;\n                 }\n                 client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n@@ -127,9 +132,14 @@ public void readEntryAndFenceLedger(final InetSocketAddress addr,\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n             @Override\n-            public void operationComplete(int rc, Void result) {\n+            public void operationComplete(final int rc, Void result) {\n                 if (rc != BKException.Code.OK) {\n-                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                    executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                        @Override\n+                        public void safeRun() {\n+                            cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                        }\n+                    });\n                     return;\n                 }\n                 client.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n@@ -143,10 +153,14 @@ public void readEntry(final InetSocketAddress addr, final long ledgerId, final l\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n             @Override\n-            public void operationComplete(int rc, Void result) {\n-\n+            public void operationComplete(final int rc, Void result) {\n                 if (rc != BKException.Code.OK) {\n-                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                    executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                        @Override\n+                        public void safeRun() {\n+                            cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                        }\n+                    });\n                     return;\n                 }\n                 client.readEntry(ledgerId, entryId, cb, ctx);"}]}

