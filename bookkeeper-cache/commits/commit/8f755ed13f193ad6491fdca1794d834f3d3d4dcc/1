{"sha":"8f755ed13f193ad6491fdca1794d834f3d3d4dcc","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4Zjc1NWVkMTNmMTkzYWQ2NDkxZmRjYTE3OTRkODM0ZjNkM2Q0ZGNj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-21T16:43:23Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-21T16:43:23Z"},"message":"BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1221798 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0bc707992820f86936e45d818023b629fd31b58b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0bc707992820f86936e45d818023b629fd31b58b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","html_url":"https://github.com/apache/bookkeeper/commit/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"015097021c1a2d2860643fda7fcb3e8a0d191442","url":"https://api.github.com/repos/apache/bookkeeper/commits/015097021c1a2d2860643fda7fcb3e8a0d191442","html_url":"https://github.com/apache/bookkeeper/commit/015097021c1a2d2860643fda7fcb3e8a0d191442"}],"stats":{"total":589,"additions":499,"deletions":90},"files":[{"sha":"bd41a91b6464b7d4bcddef4873558534613845ce","filename":"CHANGES.txt","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=8f755ed13f193ad6491fdca1794d834f3d3d4dcc","patch":"@@ -16,6 +16,10 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-141: Run extracting ledger id from entry log files in GC thread to speed up bookie restart (Sijie Gou via ivank)\n \n+      hedwig-server/\n+      \n+        BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)\n+\n     IMPROVEMENTS:\n \n Release 4.0.0 - 2011-11-30"},{"sha":"791c704eebe69822b46ef021f1cebe00c607e82f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=8f755ed13f193ad6491fdca1794d834f3d3d4dcc","patch":"@@ -58,6 +58,7 @@\n     protected final static String MESSAGES_CONSUMED_THREAD_RUN_INTERVAL = \"messages_consumed_thread_run_interval\";\n     protected final static String BK_ENSEMBLE_SIZE = \"bk_ensemble_size\";\n     protected final static String BK_QUORUM_SIZE = \"bk_quorum_size\";\n+    protected final static String RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL = \"retry_remote_subscribe_thread_run_interval\";\n \n     // these are the derived attributes\n     protected ByteString myRegionByteString = null;\n@@ -246,6 +247,13 @@ public int getMessagesConsumedThreadRunInterval() {\n         return conf.getInt(MESSAGES_CONSUMED_THREAD_RUN_INTERVAL, 60000);\n     }\n \n+    // This parameter is used to determine how often we run a thread\n+    // to retry those failed remote subscriptions in asynchronous mode\n+    // (in milliseconds).\n+    public int getRetryRemoteSubscribeThreadRunInterval() {\n+        return conf.getInt(RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL, 120000);\n+    }\n+\n     // This parameter is used when Bookkeeper is the persistence store\n     // and indicates what the ensemble size is (i.e. how many bookie\n     // servers to stripe the ledger entries across)."},{"sha":"517fa87484bf3f232e7015b533822a5d1906bfe0","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","status":"modified","additions":241,"deletions":67,"changes":308,"blob_url":"https://github.com/apache/bookkeeper/blob/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java?ref=8f755ed13f193ad6491fdca1794d834f3d3d4dcc","patch":"@@ -18,10 +18,16 @@\n package org.apache.hedwig.server.regions;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.ZooKeeper;\n@@ -52,6 +58,82 @@\n     private final PersistenceManager pm;\n     private final ArrayList<HedwigHubClient> clients = new ArrayList<HedwigHubClient>();\n     private final TopicOpQueuer queue;\n+    private final ByteString myRegion;\n+    // Timer for running a retry thread task to retry remote-subscription in asynchronous mode.\n+    private final Timer timer = new Timer(true);\n+    private final HashMap<HedwigHubClient, Set<ByteString>> retryMap =\n+            new HashMap<HedwigHubClient, Set<ByteString>>();\n+    // map used to track whether a topic is remote subscribed or not\n+    private final ConcurrentMap<ByteString, Boolean> topicStatuses =\n+            new ConcurrentHashMap<ByteString, Boolean>();\n+\n+    /**\n+     * This is the Timer Task for retrying subscribing to remote regions\n+     */\n+    class RetrySubscribeTask extends TimerTask {\n+\n+        @Override\n+        public void run() {\n+            Set<HedwigHubClient> hubClients = new HashSet<HedwigHubClient>();\n+            synchronized (retryMap) {\n+                hubClients.addAll(retryMap.keySet());\n+            }\n+            if (hubClients.isEmpty()) {\n+                if (LOGGER.isDebugEnabled()) {\n+                    LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] There is no hub client needs to retry subscriptions.\");\n+                }\n+                return;\n+            }\n+            for (HedwigHubClient client : hubClients) {\n+                Set<ByteString> topics = null;\n+                synchronized (retryMap) {\n+                    topics = retryMap.remove(client);\n+                }\n+                if (null == topics || topics.isEmpty()) {\n+                    continue;\n+                }\n+                final AtomicBoolean done = new AtomicBoolean(false);\n+                Callback<Void> postCb = new Callback<Void>() {\n+                    @Override\n+                    public void operationFinished(Object ctx,\n+                            Void resultOfOperation) {\n+                        finish();\n+                    }\n+                    @Override\n+                    public void operationFailed(Object ctx,\n+                            PubSubException exception) {\n+                        finish();\n+                    }\n+                    void finish() {\n+                        synchronized (done) {\n+                            done.set(true);\n+                            done.notifyAll();\n+                        }\n+                    }\n+                };\n+                Callback<Void> mcb = CallbackUtils.multiCallback(topics.size(), postCb, null);\n+                for (ByteString topic : topics) {\n+                    Boolean doRemoteSubscribe = topicStatuses.get(topic);\n+                    // topic has been removed, no retry again\n+                    if (null == doRemoteSubscribe) {\n+                        mcb.operationFinished(null, null);\n+                        continue;\n+                    }\n+                    retrySubscribe(client, topic, mcb);\n+                }\n+                synchronized (done) {\n+                    if (done.get()) {\n+                        try {\n+                            done.wait();\n+                        } catch (InterruptedException e) {\n+                            LOGGER.warn(\"Exception during retrying remote subscriptions : \", e);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n \n     public RegionManager(final PersistenceManager pm, final ServerConfiguration cfg, final ZooKeeper zk,\n                          ScheduledExecutorService scheduler, HedwigHubClientFactory hubClientFactory) {\n@@ -61,81 +143,155 @@ public RegionManager(final PersistenceManager pm, final ServerConfiguration cfg,\n         for (final String hub : cfg.getRegions()) {\n             clients.add(hubClientFactory.create(new HedwigSocketAddress(hub)));\n         }\n+        myRegion = cfg.getMyRegionByteString();\n+        if (cfg.getRetryRemoteSubscribeThreadRunInterval() > 0) {\n+            timer.schedule(new RetrySubscribeTask(), 0, cfg.getRetryRemoteSubscribeThreadRunInterval());\n+        }\n+    }\n+\n+    private void putTopicInRetryMap(HedwigHubClient client, ByteString topic) {\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] Put topic in retry map : \" + topic.toStringUtf8());\n+        }\n+        synchronized (retryMap) {\n+            Set<ByteString> topics = retryMap.get(client);\n+            if (null == topics) {\n+                topics = new HashSet<ByteString>();\n+                retryMap.put(client, topics);\n+            }\n+            topics.add(topic);\n+        }\n+    }\n+    \n+    /**\n+     * Do remote subscribe for a specified topic.\n+     *\n+     * @param client\n+     *          Hedwig Hub Client to subscribe remote topic.\n+     * @param topic\n+     *          Topic to subscribe.\n+     * @param synchronous\n+     *          Whether to wait for the callback of subscription.\n+     * @param mcb\n+     *          Callback to trigger after subscription is done.\n+     * @param contex\n+     *          Callback context\n+     */\n+    private void doRemoteSubscribe(final HedwigHubClient client, final ByteString topic, final boolean synchronous,\n+                                   final Callback<Void> mcb, final Object context) {\n+        final HedwigSubscriber sub = client.getSubscriber();\n+        try {\n+            if (sub.hasSubscription(topic, mySubId)) {\n+                if (LOGGER.isDebugEnabled()) {\n+                    LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] cross-region subscription for topic \"\n+                                 + topic.toStringUtf8() + \" has existed before.\");\n+                }\n+                mcb.operationFinished(null, null);\n+                return;\n+            }\n+        } catch (PubSubException e) {\n+            LOGGER.error(\"[\" + myRegion.toStringUtf8() + \"] checking cross-region subscription for topic \"\n+                         + topic.toStringUtf8() + \" failed (this is should not happen): \", e);\n+            mcb.operationFailed(context, e);\n+            return;\n+        }\n+        sub.asyncSubscribe(topic, mySubId, CreateOrAttach.CREATE_OR_ATTACH, new Callback<Void>() {\n+            @Override\n+            public void operationFinished(Object ctx, Void resultOfOperation) {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] cross-region subscription done for topic \" + topic.toStringUtf8());\n+                try {\n+                    sub.startDelivery(topic, mySubId, new MessageHandler() {\n+                        @Override\n+                        public void deliver(final ByteString topic, ByteString subscriberId, Message msg,\n+                        final Callback<Void> callback, final Object context) {\n+                            // When messages are first published\n+                            // locally, the PublishHandler sets the\n+                            // source region in the Message.\n+                            if (msg.hasSrcRegion()) {\n+                                Message.newBuilder(msg).setMsgId(\n+                                    MessageSeqId.newBuilder(msg.getMsgId()).addRemoteComponents(\n+                                        RegionSpecificSeqId.newBuilder().setRegion(\n+                                            msg.getSrcRegion()).setSeqId(\n+                                            msg.getMsgId().getLocalComponent())));\n+                            }\n+                            pm.persistMessage(new PersistRequest(topic, msg, new Callback<Long>() {\n+                                @Override\n+                                public void operationFinished(Object ctx, Long resultOfOperation) {\n+                                    if (LOGGER.isDebugEnabled())\n+                                        LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] cross-region recv-fwd succeeded for topic \"\n+                                                     + topic.toStringUtf8());\n+                                    callback.operationFinished(context, null);\n+                                }\n+\n+                                @Override\n+                                public void operationFailed(Object ctx, PubSubException exception) {\n+                                    if (LOGGER.isDebugEnabled())\n+                                        LOGGER.error(\"[\" + myRegion.toStringUtf8() + \"] cross-region recv-fwd failed for topic \"\n+                                                     + topic.toStringUtf8(), exception);\n+                                    callback.operationFailed(context, exception);\n+                                }\n+                            }, null));\n+                        }\n+                    });\n+                    if (LOGGER.isDebugEnabled())\n+                        LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] cross-region start-delivery succeeded for topic \"\n+                                     + topic.toStringUtf8());\n+                    mcb.operationFinished(ctx, null);\n+                } catch (PubSubException ex) {\n+                    if (LOGGER.isDebugEnabled())\n+                        LOGGER.error(\n+                                \"[\" + myRegion.toStringUtf8() + \"] cross-region start-delivery failed for topic \" + topic.toStringUtf8(), ex);\n+                    mcb.operationFailed(ctx, ex);\n+                }\n+            }\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                if (LOGGER.isDebugEnabled())\n+                    LOGGER.error(\"[\" + myRegion.toStringUtf8() + \"] cross-region subscribe failed for topic \" + topic.toStringUtf8(),\n+                                 exception);\n+                if (!synchronous) {\n+                    putTopicInRetryMap(client, topic);\n+                }\n+                mcb.operationFailed(ctx, exception);\n+            }\n+        }, null);\n+    }\n+\n+    private void retrySubscribe(final HedwigHubClient client, final ByteString topic, final Callback<Void> cb) {\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] Retry remote subscribe topic : \" + topic.toStringUtf8());\n+        }\n+        queue.pushAndMaybeRun(topic, queue.new AsynchronousOp<Void>(topic, cb, null) {\n+            @Override\n+            public void run() {\n+                Boolean doRemoteSubscribe = topicStatuses.get(topic);\n+                // topic has been removed, no retry again\n+                if (null == doRemoteSubscribe) {\n+                    cb.operationFinished(ctx, null);\n+                    return;\n+                }\n+                doRemoteSubscribe(client, topic, false, cb, ctx);\n+            }\n+        });\n     }\n \n     @Override\n     public void onFirstLocalSubscribe(final ByteString topic, final boolean synchronous, final Callback<Void> cb) {\n+        topicStatuses.put(topic, true);\n         // Whenever we acquire a topic due to a (local) subscribe, subscribe on\n         // it to all the other regions (currently using simple all-to-all\n         // topology).\n         queue.pushAndMaybeRun(topic, queue.new AsynchronousOp<Void>(topic, cb, null) {\n             @Override\n             public void run() {\n                 Callback<Void> postCb = synchronous ? cb : CallbackUtils.logger(LOGGER, \n-                        \"all cross-region subscriptions succeeded\", \n-                        \"at least one cross-region subscription failed\");\n+                        \"[\" + myRegion.toStringUtf8() + \"] all cross-region subscriptions succeeded\", \n+                        \"[\" + myRegion.toStringUtf8() + \"] at least one cross-region subscription failed\");\n                 final Callback<Void> mcb = CallbackUtils.multiCallback(clients.size(), postCb, ctx);\n                 for (final HedwigHubClient client : clients) {\n-                    final HedwigSubscriber sub = client.getSubscriber();\n-                    sub.asyncSubscribe(topic, mySubId, CreateOrAttach.CREATE_OR_ATTACH, new Callback<Void>() {\n-                        @Override\n-                        public void operationFinished(Object ctx, Void resultOfOperation) {\n-                            if (LOGGER.isDebugEnabled())\n-                                LOGGER.debug(\"cross-region subscription done for topic \" + topic.toStringUtf8());\n-                            try {\n-                                sub.startDelivery(topic, mySubId, new MessageHandler() {\n-                                    @Override\n-                                    public void deliver(final ByteString topic, ByteString subscriberId, Message msg,\n-                                    final Callback<Void> callback, final Object context) {\n-                                        // When messages are first published\n-                                        // locally, the PublishHandler sets the\n-                                        // source region in the Message.\n-                                        if (msg.hasSrcRegion()) {\n-                                            Message.newBuilder(msg).setMsgId(\n-                                                MessageSeqId.newBuilder(msg.getMsgId()).addRemoteComponents(\n-                                                    RegionSpecificSeqId.newBuilder().setRegion(\n-                                                        msg.getSrcRegion()).setSeqId(\n-                                                        msg.getMsgId().getLocalComponent())));\n-                                        }\n-                                        pm.persistMessage(new PersistRequest(topic, msg, new Callback<Long>() {\n-                                            @Override\n-                                            public void operationFinished(Object ctx, Long resultOfOperation) {\n-                                                if (LOGGER.isDebugEnabled())\n-                                                    LOGGER.debug(\"cross-region recv-fwd succeeded for topic \"\n-                                                                 + topic.toStringUtf8());\n-                                                callback.operationFinished(context, null);\n-                                            }\n-\n-                                            @Override\n-                                            public void operationFailed(Object ctx, PubSubException exception) {\n-                                                if (LOGGER.isDebugEnabled())\n-                                                    LOGGER.error(\"cross-region recv-fwd failed for topic \"\n-                                                                 + topic.toStringUtf8(), exception);\n-                                                callback.operationFailed(context, exception);\n-                                            }\n-                                        }, null));\n-                                    }\n-                                });\n-                                if (LOGGER.isDebugEnabled())\n-                                    LOGGER.debug(\"cross-region start-delivery succeeded for topic \"\n-                                                 + topic.toStringUtf8());\n-                                mcb.operationFinished(ctx, null);\n-                            } catch (PubSubException ex) {\n-                                if (LOGGER.isDebugEnabled())\n-                                    LOGGER.error(\n-                                        \"cross-region start-delivery failed for topic \" + topic.toStringUtf8(), ex);\n-                                mcb.operationFailed(ctx, ex);\n-                            }\n-                        }\n-\n-                        @Override\n-                        public void operationFailed(Object ctx, PubSubException exception) {\n-                            if (LOGGER.isDebugEnabled())\n-                                LOGGER.error(\"cross-region subscribe failed for topic \" + topic.toStringUtf8(),\n-                                             exception);\n-                            mcb.operationFailed(ctx, exception);\n-                        }\n-                    }, null);\n+                    doRemoteSubscribe(client, topic, synchronous, mcb, ctx);\n                 }\n                 if (!synchronous)\n                     cb.operationFinished(null, null);\n@@ -146,35 +302,53 @@ public void operationFailed(Object ctx, PubSubException exception) {\n \n     @Override\n     public void onLastLocalUnsubscribe(final ByteString topic) {\n+        topicStatuses.remove(topic);\n         // TODO may want to ease up on the eager unsubscribe; this is dropping\n         // cross-region subscriptions ASAP\n         queue.pushAndMaybeRun(topic, queue.new AsynchronousOp<Void>(topic, new Callback<Void>() {\n \n             @Override\n             public void operationFinished(Object ctx, Void result) {\n                 if (LOGGER.isDebugEnabled())\n-                    LOGGER.debug(\"cross-region unsubscribes succeeded for topic \" + topic.toStringUtf8());\n+                    LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] cross-region unsubscribes succeeded for topic \" + topic.toStringUtf8());\n             }\n \n             @Override\n             public void operationFailed(Object ctx, PubSubException exception) {\n                 if (LOGGER.isDebugEnabled())\n-                    LOGGER.error(\"cross-region unsubscribes failed for topic \" + topic.toStringUtf8(), exception);\n+                    LOGGER.error(\"[\" + myRegion.toStringUtf8() + \"] cross-region unsubscribes failed for topic \" + topic.toStringUtf8(), exception);\n             }\n \n         }, null) {\n             @Override\n             public void run() {\n                 Callback<Void> mcb = CallbackUtils.multiCallback(clients.size(), cb, ctx);\n                 for (final HedwigHubClient client : clients) {\n-                    client.getSubscriber().asyncUnsubscribe(topic, mySubId, mcb, null);\n+                    final HedwigSubscriber sub = client.getSubscriber();\n+                    try {\n+                        if (!sub.hasSubscription(topic, mySubId)) {\n+                            if (LOGGER.isDebugEnabled()) {\n+                                LOGGER.debug(\"[\" + myRegion.toStringUtf8() + \"] cross-region subscription for topic \"\n+                                             + topic.toStringUtf8() + \" has existed before.\");\n+                            }\n+                            mcb.operationFinished(null, null);\n+                            continue;\n+                        }\n+                    } catch (PubSubException e) {\n+                        LOGGER.error(\"[\" + myRegion.toStringUtf8() + \"] checking cross-region subscription for topic \"\n+                                     + topic.toStringUtf8() + \" failed (this is should not happen): \", e);\n+                        mcb.operationFailed(ctx, e);\n+                        continue;\n+                    }\n+                    sub.asyncUnsubscribe(topic, mySubId, mcb, null);\n                 }\n             }\n         });\n     }\n \n     // Method to shutdown and stop all of the cross-region Hedwig clients.\n     public void stop() {\n+        timer.cancel();\n         for (HedwigHubClient client : clients) {\n             client.close();\n         }"},{"sha":"78d1435079e6ecd6cf5f28eac35caae8dd6fd4b5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":32,"deletions":6,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=8f755ed13f193ad6491fdca1794d834f3d3d4dcc","patch":"@@ -218,10 +218,11 @@ public void acquiredTopic(final ByteString topic, final Callback<Void> callback,\n     @Override\n     public void lostTopic(ByteString topic) {\n         top2sub2seq.remove(topic);\n-        AtomicInteger count = topic2LocalCounts.remove(topic);\n-        // Notify listeners if necessary.\n-        if (null != count && count.get() > 0)\n-            notifyUnsubcribe(topic);\n+        topic2LocalCounts.remove(topic);\n+        // Since we decrement local count when some of remote subscriptions failed,\n+        // while we don't unsubscribe those succeed subscriptions. so we can't depends\n+        // on local count, just try to notify unsubscribe.\n+        notifyUnsubcribe(topic);\n     }\n \n     private void notifyUnsubcribe(ByteString topic) {\n@@ -300,10 +301,35 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                     Callback<Void> cb2 = new Callback<Void>() {\n \n                         @Override\n-                        public void operationFailed(Object ctx, PubSubException exception) {\n+                        public void operationFailed(final Object ctx, final PubSubException exception) {\n                             logger.error(\"subscription for subscriber \" + subscriberId.toStringUtf8() + \" to topic \"\n                                          + topic.toStringUtf8() + \" failed due to failed listener callback\", exception);\n-                            cb.operationFailed(ctx, exception);\n+                            // should remove subscription when synchronized cross-region subscription failed\n+                            deleteSubscriptionState(topic, subscriberId, new Callback<Void>() {\n+                                @Override\n+                                public void operationFinished(Object context,\n+                                        Void resultOfOperation) {\n+                                    finish();\n+                                }\n+                                @Override\n+                                public void operationFailed(Object context,\n+                                        PubSubException ex) {\n+                                    logger.error(\"Remove subscription for subscriber \" + subscriberId.toStringUtf8() + \" to topic \"\n+                                                 + topic.toStringUtf8() + \" failed : \", ex);\n+                                    finish();\n+                                }\n+                                private void finish() {\n+                                    // we should decrement local count when remote subscription failed\n+                                    if (!SubscriptionStateUtils.isHubSubscriber(subRequest.getSubscriberId())) {\n+                                        // since the subscribe op is executed one by one in queue order,\n+                                        // so the following codes only happened when remote subscription failed.\n+                                        // it is safe to decrement the local count so next subscribe op\n+                                        // could have the chance to subscribe remote.\n+                                        topic2LocalCounts.get(topic).decrementAndGet();\n+                                    }\n+                                    cb.operationFailed(ctx, exception);\n+                                }\n+                            }, ctx);\n                         }\n \n                         @Override"},{"sha":"2252f436e3905299c0aec11281c5ca7e0e9837bf","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","status":"modified","additions":42,"deletions":17,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java?ref=8f755ed13f193ad6491fdca1794d834f3d3d4dcc","patch":"@@ -176,23 +176,7 @@ public void setUp() throws Exception {\n         regionServersMap = new HashMap<String, List<PubSubServer>>(numRegions, 1.0f);\n         regionClientsMap = new HashMap<String, HedwigClient>(numRegions, 1.0f);\n         for (int i = 0; i < numRegions; i++) {\n-            List<PubSubServer> serversList = new LinkedList<PubSubServer>();\n-            // For the current region, create the necessary amount of hub\n-            // servers. We will basically increment through the port numbers\n-            // starting from the initial ones defined.\n-            for (int j = 0; j < numServersPerRegion; j++) {\n-                serversList.add(new PubSubServer(getServerConfiguration(initialServerPort\n-                                                 + (j + i * numServersPerRegion), initialSSLServerPort + (j + i * numServersPerRegion),\n-                                                 REGION_PREFIX + i)));\n-            }\n-            // Store this list of servers created for the current region\n-            regionServersMap.put(REGION_PREFIX + i, serversList);\n-\n-            // Create a Hedwig Client that points to the first Hub server\n-            // created in the loop above for the current region.\n-            HedwigClient regionClient = new HedwigClient(getClientConfiguration(initialServerPort\n-                    + (i * numServersPerRegion), initialSSLServerPort + (i * numServersPerRegion)));\n-            regionClientsMap.put(REGION_PREFIX + i, regionClient);\n+            startRegion(i);\n         }\n         logger.info(\"HedwigRegion test setup finished\");\n     }\n@@ -219,4 +203,45 @@ public void tearDown() throws Exception {\n         logger.info(\"FINISHED \" + getName());\n     }\n \n+    protected void stopRegion(int regionIdx) throws Exception {\n+        String regionName = REGION_PREFIX + regionIdx;\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Stop region : \" + regionName);\n+        }\n+        HedwigClient regionClient = regionClientsMap.remove(regionName);\n+        if (null != regionClient) {\n+            regionClient.close();\n+        }\n+        List<PubSubServer> serversList = regionServersMap.remove(regionName);\n+        if (null == serversList) {\n+            return;\n+        }\n+        for (PubSubServer server : serversList) {\n+            server.shutdown();\n+        }\n+        logger.info(\"Finished shutting down all of the hub servers in region \" + regionName);\n+    }\n+\n+    protected void startRegion(int i) throws Exception {\n+        String regionName = REGION_PREFIX + i;\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Start region : \" + regionName);\n+        }\n+        List<PubSubServer> serversList = new LinkedList<PubSubServer>();\n+        // For the current region, create the necessary amount of hub\n+        // servers. We will basically increment through the port numbers\n+        // starting from the initial ones defined.\n+        for (int j = 0; j < numServersPerRegion; j++) {\n+            serversList.add(new PubSubServer(getServerConfiguration(initialServerPort\n+                                             + (j + i * numServersPerRegion), initialSSLServerPort + (j + i * numServersPerRegion),\n+                                             regionName)));\n+        }\n+        // Store this list of servers created for the current region\n+        regionServersMap.put(regionName, serversList);\n+        // Create a Hedwig Client that points to the first Hub server\n+        // created in the loop above for the current region.\n+        HedwigClient regionClient = new HedwigClient(getClientConfiguration(initialServerPort\n+                + (i * numServersPerRegion), initialSSLServerPort + (i * numServersPerRegion)));\n+        regionClientsMap.put(regionName, regionClient);\n+    }\n }"},{"sha":"0b1851ebbc5c6c80fa25a0fd62e1dfb2783ae947","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","status":"modified","additions":172,"deletions":0,"changes":172,"blob_url":"https://github.com/apache/bookkeeper/blob/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","raw_url":"https://github.com/apache/bookkeeper/raw/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java?ref=8f755ed13f193ad6491fdca1794d834f3d3d4dcc","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.hedwig.server.integration;\n \n+import java.util.Map;\n+import java.util.Random;\n import java.util.concurrent.SynchronousQueue;\n \n import org.junit.After;\n@@ -29,6 +31,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.server.HedwigRegionTestBase;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.integration.TestHedwigHub.TestCallback;\n import org.apache.hedwig.server.integration.TestHedwigHub.TestMessageHandler;\n \n@@ -38,6 +41,25 @@\n     private final SynchronousQueue<Boolean> queue = new SynchronousQueue<Boolean>();\n     private final SynchronousQueue<Boolean> consumeQueue = new SynchronousQueue<Boolean>();\n \n+    private static final int TEST_RETRY_REMOTE_SUBSCRIBE_INTERVAL_VALUE = 3000;\n+\n+    protected class NewRegionServerConfiguration extends RegionServerConfiguration {\n+\n+        public NewRegionServerConfiguration(int serverPort, int sslServerPort,\n+                String regionName) {\n+            super(serverPort, sslServerPort, regionName);\n+        }\n+\n+        @Override\n+        public int getRetryRemoteSubscribeThreadRunInterval() {\n+            return TEST_RETRY_REMOTE_SUBSCRIBE_INTERVAL_VALUE;\n+        }\n+    }\n+\n+    protected ServerConfiguration getServerConfiguration(int serverPort, int sslServerPort, String regionName) {\n+        return new NewRegionServerConfiguration(serverPort, sslServerPort, regionName);\n+    }\n+\n     @Override\n     @Before\n     public void setUp() throws Exception {\n@@ -90,4 +112,154 @@ public void testMultiRegionSubscribeAndConsume() throws Exception {\n         }\n     }\n \n+    /**\n+     * Test region shuts down when first subscription.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSubscribeAndConsumeWhenARegionDown() throws Exception {\n+        int batchSize = 10;\n+\n+        // first shut down a region\n+        Random r = new Random();\n+        int regionId = r.nextInt(numRegions);\n+        stopRegion(regionId);\n+        // subscribe to topics when a region shuts down\n+        for (HedwigClient client : regionClientsMap.values()) {\n+            for (int i = 0; i < batchSize; i++) {\n+                client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                      ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n+                                                      new TestCallback(queue), null);\n+                assertFalse(queue.take());\n+            }\n+        }\n+\n+        // start region gain\n+        startRegion(regionId);\n+\n+        // sub it again\n+        for (Map.Entry<String, HedwigClient> entry : regionClientsMap.entrySet()) {\n+            HedwigClient client = entry.getValue();\n+            for (int i = 0; i < batchSize; i++) {\n+                client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                      ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n+                                                      new TestCallback(queue), null);\n+                assertTrue(queue.take());\n+            }\n+        }\n+\n+        // Start delivery for local subscribers in all regions\n+        for (Map.Entry<String, HedwigClient> entry : regionClientsMap.entrySet()) {\n+            HedwigClient client = entry.getValue();\n+            for (int i = 0; i < batchSize; i++) {\n+                client.getSubscriber().startDelivery(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                     ByteString.copyFromUtf8(\"LocalSubscriber\"), new TestMessageHandler(consumeQueue));\n+            }\n+        }\n+\n+        // Now start publishing messages for the subscribed topics in one of the\n+        // regions and verify that it gets delivered and consumed in all of the\n+        // other ones.\n+        int rid = r.nextInt(numRegions);\n+        String regionName = REGION_PREFIX + rid;\n+        Publisher publisher = regionClientsMap.get(regionName).getPublisher();\n+        for (int i = 0; i < batchSize; i++) {\n+            publisher.asyncPublish(ByteString.copyFromUtf8(\"Topic\" + i), Message.newBuilder().setBody(\n+                                   ByteString.copyFromUtf8(regionName + \"-Message\" + i)).build(), new TestCallback(queue), null);\n+            assertTrue(queue.take());\n+        }\n+        // Make sure each region consumes the same set of published messages.\n+        for (int i = 0; i < regionClientsMap.size(); i++) {\n+            for (int j = 0; j < batchSize; j++) {\n+                assertTrue(consumeQueue.take());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test region shuts down when attaching existing subscriptions.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testAttachExistingSubscriptionsWhenARegionDown() throws Exception {\n+        int batchSize = 10;\n+        \n+        // sub it remotely to make subscriptions existed\n+        for (Map.Entry<String, HedwigClient> entry : regionClientsMap.entrySet()) {\n+            HedwigClient client = entry.getValue();\n+            for (int i = 0; i < batchSize; i++) {\n+                client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                      ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n+                                                      new TestCallback(queue), null);\n+                assertTrue(queue.take());\n+            }\n+        }\n+\n+        // stop regions\n+        for (int i=0; i<numRegions; i++) {\n+            stopRegion(i);\n+        }\n+        // start regions again\n+        for (int i=0; i<numRegions; i++) {\n+            startRegion(i);\n+        }\n+\n+        // first shut down a region\n+        Random r = new Random();\n+        int regionId = r.nextInt(numRegions);\n+        stopRegion(regionId);\n+        // subscribe to topics when a region shuts down\n+        // it should succeed since the subscriptions existed before\n+        for (HedwigClient client : regionClientsMap.values()) {\n+            for (int i = 0; i < batchSize; i++) {\n+                client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                      ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n+                                                      new TestCallback(queue), null);\n+                assertTrue(queue.take());\n+            }\n+        }\n+\n+        // Start delivery for local subscribers in all regions\n+        for (Map.Entry<String, HedwigClient> entry : regionClientsMap.entrySet()) {\n+            HedwigClient client = entry.getValue();\n+            for (int i = 0; i < batchSize; i++) {\n+                client.getSubscriber().startDelivery(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                     ByteString.copyFromUtf8(\"LocalSubscriber\"), new TestMessageHandler(consumeQueue));\n+            }\n+        }\n+\n+        // start region again\n+        startRegion(regionId);\n+        // wait for retry\n+        Thread.sleep(3 * TEST_RETRY_REMOTE_SUBSCRIBE_INTERVAL_VALUE);\n+\n+        String regionName = REGION_PREFIX + regionId;\n+        HedwigClient client = regionClientsMap.get(regionName);\n+        for (int i = 0; i < batchSize; i++) {\n+            client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8(\"Topic\" + i),\n+                                                  ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n+                                                  new TestCallback(queue), null);\n+            assertTrue(queue.take());\n+            client.getSubscriber().startDelivery(ByteString.copyFromUtf8(\"Topic\" + i),\n+                    ByteString.copyFromUtf8(\"LocalSubscriber\"), new TestMessageHandler(consumeQueue));\n+        }\n+\n+        // Now start publishing messages for the subscribed topics in one of the\n+        // regions and verify that it gets delivered and consumed in all of the\n+        // other ones.        \n+        Publisher publisher = client.getPublisher();\n+        for (int i = 0; i < batchSize; i++) {\n+            publisher.asyncPublish(ByteString.copyFromUtf8(\"Topic\" + i), Message.newBuilder().setBody(\n+                                   ByteString.copyFromUtf8(regionName + \"-Message\" + i)).build(), new TestCallback(queue), null);\n+            assertTrue(queue.take());\n+        }\n+        // Make sure each region consumes the same set of published messages.\n+        for (int i = 0; i < regionClientsMap.size(); i++) {\n+            for (int j = 0; j < batchSize; j++) {\n+                assertTrue(consumeQueue.take());\n+            }\n+        }\n+    }\n }"}]}

