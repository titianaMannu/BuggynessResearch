{"sha":"9001e300ce0d5d2655d437e3eaa52f91487caed6","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5MDAxZTMwMGNlMGQ1ZDI2NTVkNDM3ZTNlYWE1MmY5MTQ4N2NhZWQ2","commit":{"author":{"name":"Govind Menon","email":"govindappumenon@gmail.com","date":"2017-04-03T19:31:47Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-04-03T19:31:47Z"},"message":"BOOKKEEPER-1018: Allow client to select older V2 protocol (no protobuf)\n\nOriginally done by Matteo Merli (merlimat). Tagging sijie and eolivelli  for review.\n\nAuthor: Govind Menon <govindappumenon@gmail.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #120 from govind-menon/BOOKKEEPER-1018","tree":{"sha":"47654ac1545ccff03d4e39b02ebdd99099c94a6a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/47654ac1545ccff03d4e39b02ebdd99099c94a6a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9001e300ce0d5d2655d437e3eaa52f91487caed6","comment_count":6,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9001e300ce0d5d2655d437e3eaa52f91487caed6","html_url":"https://github.com/apache/bookkeeper/commit/9001e300ce0d5d2655d437e3eaa52f91487caed6","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9001e300ce0d5d2655d437e3eaa52f91487caed6/comments","author":{"login":"govind-menon","id":2053016,"node_id":"MDQ6VXNlcjIwNTMwMTY=","avatar_url":"https://avatars.githubusercontent.com/u/2053016?v=4","gravatar_id":"","url":"https://api.github.com/users/govind-menon","html_url":"https://github.com/govind-menon","followers_url":"https://api.github.com/users/govind-menon/followers","following_url":"https://api.github.com/users/govind-menon/following{/other_user}","gists_url":"https://api.github.com/users/govind-menon/gists{/gist_id}","starred_url":"https://api.github.com/users/govind-menon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/govind-menon/subscriptions","organizations_url":"https://api.github.com/users/govind-menon/orgs","repos_url":"https://api.github.com/users/govind-menon/repos","events_url":"https://api.github.com/users/govind-menon/events{/privacy}","received_events_url":"https://api.github.com/users/govind-menon/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"9836c87dc2c082c46692d60c60cf9e23c7b0b06c","url":"https://api.github.com/repos/apache/bookkeeper/commits/9836c87dc2c082c46692d60c60cf9e23c7b0b06c","html_url":"https://github.com/apache/bookkeeper/commit/9836c87dc2c082c46692d60c60cf9e23c7b0b06c"}],"stats":{"total":470,"additions":336,"deletions":134},"files":[{"sha":"2b75e9ec34de170e87919448df2b7c64e8741db2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":22,"deletions":1,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=9001e300ce0d5d2655d437e3eaa52f91487caed6","patch":"@@ -57,7 +57,7 @@\n     protected final static String CLIENT_WRITEBUFFER_HIGH_WATER_MARK = \"clientWriteBufferHighWaterMark\";\n     protected final static String CLIENT_CONNECT_TIMEOUT_MILLIS = \"clientConnectTimeoutMillis\";\n     protected final static String NUM_CHANNELS_PER_BOOKIE = \"numChannelsPerBookie\";\n-\n+    protected final static String USE_V2_WIRE_PROTOCOL = \"useV2WireProtocol\";\n     // Read Parameters\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n@@ -435,6 +435,27 @@ public ClientConfiguration setNumChannelsPerBookie(int numChannelsPerBookie) {\n         return this;\n     }\n \n+    /**\n+     * Use older Bookkeeper wire protocol (no protobuf)\n+     *\n+     * @return whether or not to use older Bookkeeper wire protocol (no protobuf)\n+     */\n+    public boolean getUseV2WireProtocol() {\n+        return getBoolean(USE_V2_WIRE_PROTOCOL, false);\n+    }\n+\n+    /**\n+     * Set whether or not to use older Bookkeeper wire protocol (no protobuf)\n+     *\n+     * @param useV2WireProtocol\n+     *          whether or not to use older Bookkeeper wire protocol (no protobuf)\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setUseV2WireProtocol(boolean useV2WireProtocol) {\n+        setProperty(USE_V2_WIRE_PROTOCOL, useV2WireProtocol);\n+        return this;\n+    }\n+\n     /**\n      * Get zookeeper servers to connect\n      *"},{"sha":"d2608e72fb7ebbaad78669212e27277c3b131cd2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java?ref=9001e300ce0d5d2655d437e3eaa52f91487caed6","patch":"@@ -322,6 +322,14 @@ public void writeRequested(ChannelHandlerContext ctx,\n                     } else {\n                         waitingForAuth.add(e);\n                     }\n+                } else if (e.getMessage() instanceof BookieProtocol.Request) {\n+                    // let auth messages through, queue the rest\n+                    BookieProtocol.Request req = (BookieProtocol.Request)e.getMessage();\n+                    if (BookkeeperProtocol.OperationType.AUTH.getNumber() == req.getOpCode()) {\n+                        super.writeRequested(ctx, e);\n+                    } else {\n+                        waitingForAuth.add(e);\n+                    }\n                 } // else just drop\n             }\n         }"},{"sha":"1191d3c906850ebec9a9cb3d5e7bbc774cbf497f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=9001e300ce0d5d2655d437e3eaa52f91487caed6","patch":"@@ -140,6 +140,9 @@ short getFlags() {\n      * by the auth providers themselves.\n      */\n     public static final byte AUTH = 3;\n+    public static final byte READ_LAC = 4;\n+    public static final byte WRITE_LAC = 5;\n+    public static final byte GET_BOOKIE_INFO = 6;\n \n     /**\n      * The error code that indicates success"},{"sha":"a24bb1eb9a1f4e2539e1130edfa3805b9b05ef16","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":303,"deletions":133,"changes":436,"blob_url":"https://github.com/apache/bookkeeper/blob/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/9001e300ce0d5d2655d437e3eaa52f91487caed6/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=9001e300ce0d5d2655d437e3eaa52f91487caed6","patch":"@@ -21,8 +21,10 @@\n import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -98,7 +100,7 @@\n import com.google.protobuf.ByteString;\n import com.google.protobuf.ExtensionRegistry;\n import java.net.SocketAddress;\n-import java.util.Collection;\n+\n import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n import org.jboss.netty.channel.ChannelFactory;\n import org.apache.bookkeeper.client.ClientConnectionPeer;\n@@ -147,6 +149,8 @@\n     private final OpStatsLogger getBookieInfoOpLogger;\n     private final OpStatsLogger getBookieInfoTimeoutOpLogger;\n \n+    private final boolean useV2WireProtocol;\n+\n     /**\n      * The following member variables do not need to be concurrent, or volatile\n      * because they are always updated under a lock\n@@ -202,6 +206,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.addEntryTimeout = conf.getAddEntryTimeout();\n         this.readEntryTimeout = conf.getReadEntryTimeout();\n         this.getBookieInfoTimeout = conf.getBookieInfoTimeout();\n+        this.useV2WireProtocol = conf.getUseV2WireProtocol();\n \n         this.authProviderFactory = authProviderFactory;\n         this.extRegistry = extRegistry;\n@@ -469,33 +474,45 @@ public void operationComplete(ChannelFuture future) throws Exception {\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n-        final long txnId = getTxnId();\n-        final int entrySize = toSend.readableBytes();\n-        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.ADD_ENTRY);\n-        completionObjects.put(completionKey,\n-                new AddCompletion(this, addEntryOpLogger, cb, ctx, ledgerId, entryId,\n-                                  scheduleTimeout(completionKey, addEntryTimeout)));\n-\n-        // Build the request and calculate the total size to be included in the packet.\n-        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                .setVersion(ProtocolVersion.VERSION_THREE)\n-                .setOperation(OperationType.ADD_ENTRY)\n-                .setTxnId(txnId);\n+        Object request = null;\n+        CompletionKey completion = null;\n+        if (useV2WireProtocol) {\n+            completion = new V2CompletionKey(ledgerId, entryId, OperationType.ADD_ENTRY);\n+            request = new BookieProtocol.AddRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n+                    (short) options, masterKey, toSend);\n \n-        AddRequest.Builder addBuilder = AddRequest.newBuilder()\n-                .setLedgerId(ledgerId)\n-                .setEntryId(entryId)\n-                .setMasterKey(ByteString.copyFrom(masterKey))\n-                .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n \n-        if (((short)options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n-            addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);\n+        } else {\n+            final long txnId = getTxnId();\n+            completion = new CompletionKey(txnId, OperationType.ADD_ENTRY);\n+            // Build the request and calculate the total size to be included in the packet.\n+            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                    .setVersion(ProtocolVersion.VERSION_THREE)\n+                    .setOperation(OperationType.ADD_ENTRY)\n+                    .setTxnId(txnId);\n+\n+            AddRequest.Builder addBuilder = AddRequest.newBuilder()\n+                    .setLedgerId(ledgerId)\n+                    .setEntryId(entryId)\n+                    .setMasterKey(ByteString.copyFrom(masterKey))\n+                    .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n+\n+            if (((short) options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n+                addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);\n+            }\n+            request = Request.newBuilder()\n+                    .setHeader(headerBuilder)\n+                    .setAddRequest(addBuilder)\n+                    .build();\n         }\n \n-        final Request addRequest = Request.newBuilder()\n-                .setHeader(headerBuilder)\n-                .setAddRequest(addBuilder)\n-                .build();\n+        final Object addRequest = request;\n+        final CompletionKey completionKey = completion;\n+\n+        completionObjects.put(completionKey, new AddCompletion(this,\n+                addEntryOpLogger, cb, ctx, ledgerId, entryId, scheduleTimeout(completion, addEntryTimeout)));\n+\n+        final int entrySize = toSend.readableBytes();\n \n         final Channel c = channel;\n         if (c == null) {\n@@ -531,35 +548,52 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n                                         final long entryId,\n                                         ReadEntryCallback cb, Object ctx) {\n-        final long txnId = getTxnId();\n-        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n-        completionObjects.put(completionKey,\n-                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n-                                   scheduleTimeout(completionKey, readEntryTimeout)));\n-\n-        // Build the request and calculate the total size to be included in the packet.\n-        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                .setVersion(ProtocolVersion.VERSION_THREE)\n-                .setOperation(OperationType.READ_ENTRY)\n-                .setTxnId(txnId);\n-\n-        ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n-                .setLedgerId(ledgerId)\n-                .setEntryId(entryId)\n-                .setMasterKey(ByteString.copyFrom(masterKey))\n-                .setFlag(ReadRequest.Flag.FENCE_LEDGER);\n-\n-        final Request readRequest = Request.newBuilder()\n-                .setHeader(headerBuilder)\n-                .setReadRequest(readBuilder)\n-                .build();\n+        Object request = null;\n+        CompletionKey completion = null;\n+        if (useV2WireProtocol) {\n+            completion = new V2CompletionKey(ledgerId, entryId, OperationType.READ_ENTRY);\n+            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n+                    BookieProtocol.FLAG_DO_FENCING, masterKey);\n+        } else {\n+            final long txnId = getTxnId();\n+            final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n+            completionObjects.put(completionKey,\n+                    new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                            scheduleTimeout(completionKey, readEntryTimeout)));\n+\n+            // Build the request and calculate the total size to be included in the packet.\n+            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                    .setVersion(ProtocolVersion.VERSION_THREE)\n+                    .setOperation(OperationType.READ_ENTRY)\n+                    .setTxnId(txnId);\n+\n+            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n+                    .setLedgerId(ledgerId)\n+                    .setEntryId(entryId)\n+                    .setMasterKey(ByteString.copyFrom(masterKey))\n+                    .setFlag(ReadRequest.Flag.FENCE_LEDGER);\n+\n+            final Request readRequest = Request.newBuilder()\n+                    .setHeader(headerBuilder)\n+                    .setReadRequest(readBuilder)\n+                    .build();\n+        }\n+\n+        final CompletionKey completionKey = completion;\n+        if (completionObjects.putIfAbsent(completionKey, new ReadCompletion(this, readEntryOpLogger, cb,\n+                ctx, ledgerId, entryId, scheduleTimeout(completionKey, readEntryTimeout))) != null) {\n+            // We cannot have more than 1 pending read on the same ledger/entry in the v2 protocol\n+            cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException, ledgerId, entryId, null, ctx);\n+            return;\n+        }\n \n         final Channel c = channel;\n         if (c == null) {\n             errorOutReadKey(completionKey);\n             return;\n         }\n \n+        final Object readRequest = request;\n         try {\n             ChannelFuture future = c.write(readRequest);\n             future.addListener(new ChannelFutureListener() {\n@@ -586,22 +620,34 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {\n-        final long txnId = getTxnId();\n-        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_LAC);\n+        Object request = null;\n+        CompletionKey completion = null;\n+        if (useV2WireProtocol) {\n+            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                    ledgerId, (long) 0, (short) 0);\n+            completion = new V2CompletionKey(ledgerId, (long) 0, OperationType.READ_LAC);\n+        } else {\n+            final long txnId = getTxnId();\n+            final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_LAC);\n+\n+            // Build the request and calculate the total size to be included in the packet.\n+            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                    .setVersion(ProtocolVersion.VERSION_THREE)\n+                    .setOperation(OperationType.READ_LAC)\n+                    .setTxnId(txnId);\n+            ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()\n+                    .setLedgerId(ledgerId);\n+            request = Request.newBuilder()\n+                    .setHeader(headerBuilder)\n+                    .setReadLacRequest(readLacBuilder)\n+                    .build();\n+        }\n+        final Object readLacRequest = request;\n+        final CompletionKey completionKey = completion;\n+\n         completionObjects.put(completionKey,\n                 new ReadLacCompletion(readLacOpLogger, cb, ctx, ledgerId,\n                         scheduleTimeout(completionKey, readEntryTimeout)));\n-        // Build the request and calculate the total size to be included in the packet.\n-        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                .setVersion(ProtocolVersion.VERSION_THREE)\n-                .setOperation(OperationType.READ_LAC)\n-                .setTxnId(txnId);\n-        ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()\n-                .setLedgerId(ledgerId);\n-        final Request readLacRequest = Request.newBuilder()\n-                .setHeader(headerBuilder)\n-                .setReadLacRequest(readLacBuilder)\n-                .build();\n         final Channel c = channel;\n         if (c == null) {\n             errorOutReadLacKey(completionKey);\n@@ -632,27 +678,37 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n-        final long txnId = getTxnId();\n-        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n-        completionObjects.put(completionKey,\n-                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n-                                   scheduleTimeout(completionKey, readEntryTimeout)));\n+        Object request = null;\n+        CompletionKey completion = null;\n+        if (useV2WireProtocol) {\n+            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                    ledgerId, entryId, (short) 0);\n+            completion = new V2CompletionKey(ledgerId, entryId, OperationType.READ_ENTRY);\n+        } else {\n+            final long txnId = getTxnId();\n+            completion = new CompletionKey(txnId, OperationType.READ_ENTRY);\n \n-        // Build the request and calculate the total size to be included in the packet.\n-        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                .setVersion(ProtocolVersion.VERSION_THREE)\n-                .setOperation(OperationType.READ_ENTRY)\n-                .setTxnId(txnId);\n+            // Build the request and calculate the total size to be included in the packet.\n+            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                    .setVersion(ProtocolVersion.VERSION_THREE)\n+                    .setOperation(OperationType.READ_ENTRY)\n+                    .setTxnId(txnId);\n \n-        ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n-                .setLedgerId(ledgerId)\n-                .setEntryId(entryId);\n+            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n+                    .setLedgerId(ledgerId)\n+                    .setEntryId(entryId);\n \n-        final Request readRequest = Request.newBuilder()\n-                .setHeader(headerBuilder)\n-                .setReadRequest(readBuilder)\n-                .build();\n+            final Request readRequest = Request.newBuilder()\n+                    .setHeader(headerBuilder)\n+                    .setReadRequest(readBuilder)\n+                    .build();\n+        }\n+        final Object readRequest = request;\n+        final CompletionKey completionKey = completion;\n \n+        completionObjects.put(completionKey,\n+                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                        scheduleTimeout(completionKey, readEntryTimeout)));\n         final Channel c = channel;\n         if (c == null) {\n             errorOutReadKey(completionKey);\n@@ -803,6 +859,7 @@ void errorOutReadKey(final CompletionKey key) {\n     }\n \n     void errorOutReadKey(final CompletionKey key, final int rc) {\n+        LOG.info(\"Removing completion key: {}\", key);\n         final ReadCompletion readCompletion = (ReadCompletion)completionObjects.remove(key);\n         if (null == readCompletion) {\n             return;\n@@ -835,6 +892,7 @@ void errorOutWriteLacKey(final CompletionKey key) {\n     }\n \n     void errorOutWriteLacKey(final CompletionKey key, final int rc) {\n+        LOG.info(\"Removing completion key: {}\", key);\n         final WriteLacCompletion writeLacCompletion = (WriteLacCompletion)completionObjects.remove(key);\n         if (null == writeLacCompletion) {\n             return;\n@@ -859,6 +917,7 @@ void errorOutReadLacKey(final CompletionKey key) {\n     }\n \n     void errorOutReadLacKey(final CompletionKey key, final int rc) {\n+        LOG.info(\"Removing completion key: {}\", key);\n         final ReadLacCompletion readLacCompletion = (ReadLacCompletion)completionObjects.remove(key);\n         if (null == readLacCompletion) {\n             return;\n@@ -1058,12 +1117,101 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n      */\n     @Override\n     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-        if (!(e.getMessage() instanceof Response)) {\n+\n+        if (e.getMessage() instanceof BookieProtocol.Response) {\n+            BookieProtocol.Response response = (BookieProtocol.Response) e.getMessage();\n+            readV2Response(response);\n+        } else if (e.getMessage() instanceof Response) {\n+            Response response = (Response) e.getMessage();\n+            readV3Response(response);\n+        } else {\n             ctx.sendUpstream(e);\n-            return;\n         }\n+    }\n+\n+    private void readV2Response(final BookieProtocol.Response response) {\n+        final long ledgerId = response.ledgerId;\n+        final long entryId = response.entryId;\n+\n+        final OperationType operationType = getOperationType(response.getOpCode());\n+        final StatusCode status = getStatusCodeFromErrorCode(response.errorCode);\n+\n+        final CompletionValue completionValue = completionObjects.remove(new V2CompletionKey(ledgerId, entryId, operationType));\n \n-        final Response response = (Response) e.getMessage();\n+        if (null == completionValue) {\n+            // Unexpected response, so log it. The txnId should have been present.\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Unexpected response received from bookie : \" + addr + \" for type : \" + operationType\n+                        + \" and ledger:entry : \" + ledgerId + \":\" + entryId);\n+            }\n+        } else {\n+            long orderingKey = completionValue.ledgerId;\n+\n+            executor.submitOrdered(orderingKey, new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    switch (operationType) {\n+                        case ADD_ENTRY: {\n+                            handleAddResponse(ledgerId, entryId, status, completionValue);\n+                        }\n+                        case READ_ENTRY: {\n+                            BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;\n+                            handleReadResponse(ledgerId, entryId, status, readResponse.getData(), completionValue);\n+                        }\n+                        default:\n+                            LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\", operationType, addr);\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private StatusCode getStatusCodeFromErrorCode(int errorCode) {\n+        switch (errorCode) {\n+            case BookieProtocol.EOK:\n+                return StatusCode.EOK;\n+            case BookieProtocol.ENOLEDGER:\n+                return StatusCode.ENOLEDGER;\n+            case BookieProtocol.ENOENTRY:\n+                return StatusCode.ENOENTRY;\n+            case BookieProtocol.EBADREQ:\n+                return StatusCode.EBADREQ;\n+            case BookieProtocol.EIO:\n+                return StatusCode.EIO;\n+            case BookieProtocol.EUA:\n+                return StatusCode.EUA;\n+            case BookieProtocol.EBADVERSION:\n+                return StatusCode.EBADVERSION;\n+            case BookieProtocol.EFENCED:\n+                return StatusCode.EFENCED;\n+            case BookieProtocol.EREADONLY:\n+                return StatusCode.EREADONLY;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid error code: \" + errorCode);\n+        }\n+    }\n+\n+    private OperationType getOperationType(byte opCode) {\n+        switch (opCode) {\n+            case BookieProtocol.ADDENTRY:\n+                return  OperationType.ADD_ENTRY;\n+            case BookieProtocol.READENTRY:\n+                return OperationType.READ_ENTRY;\n+            case BookieProtocol.AUTH:\n+                return OperationType.AUTH;\n+            case BookieProtocol.READ_LAC:\n+                return OperationType.READ_LAC;\n+            case BookieProtocol.WRITE_LAC:\n+                return OperationType.WRITE_LAC;\n+            case BookieProtocol.GET_BOOKIE_INFO:\n+                return OperationType.GET_BOOKIE_INFO;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operation type\");\n+        }\n+    }\n+\n+    private void readV3Response(final Response response) {\n         final BKPacketHeader header = response.getHeader();\n \n         final CompletionValue completionValue = completionObjects.remove(newCompletionKey(header.getTxnId(),\n@@ -1082,21 +1230,51 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n                 public void safeRun() {\n                     OperationType type = header.getOperation();\n                     switch (type) {\n-                        case ADD_ENTRY:\n-                            handleAddResponse(response, completionValue);\n+                        case ADD_ENTRY: {\n+                            AddResponse addResponse = response.getAddResponse();\n+                            StatusCode status = response.getStatus() == StatusCode.EOK ? addResponse.getStatus() : response.getStatus();\n+                            handleAddResponse(addResponse.getLedgerId(), addResponse.getEntryId(), status, completionValue);\n                             break;\n-                        case READ_ENTRY:\n-                            handleReadResponse(response, completionValue);\n+                        }\n+                        case READ_ENTRY: {\n+                            ReadResponse readResponse = response.getReadResponse();\n+                            StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();\n+                            ChannelBuffer buffer = ChannelBuffers.buffer(0);\n+                            if (readResponse.hasBody()) {\n+                                buffer = ChannelBuffers.copiedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n+                            }\n+                            handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, completionValue);\n                             break;\n-                        case WRITE_LAC:\n-                            handleWriteLacResponse(response.getWriteLacResponse(), completionValue);\n+                        }\n+                        case WRITE_LAC: {\n+                            WriteLacResponse writeLacResponse = response.getWriteLacResponse();\n+                            StatusCode status = response.getStatus() == StatusCode.EOK ? writeLacResponse.getStatus() : response.getStatus();\n+                            handleWriteLacResponse(writeLacResponse.getLedgerId(), status, completionValue);\n                             break;\n-                        case READ_LAC:\n-                            handleReadLacResponse(response.getReadLacResponse(), completionValue);\n+                        }\n+                        case READ_LAC: {\n+                            ReadLacResponse readLacResponse = response.getReadLacResponse();\n+                            ChannelBuffer lacBuffer = ChannelBuffers.buffer(0);\n+                            ChannelBuffer lastEntryBuffer = ChannelBuffers.buffer(0);\n+                            StatusCode status = response.getStatus() == StatusCode.EOK ? readLacResponse.getStatus() : response.getStatus();\n+                            // Thread.dumpStack();\n+\n+                            if (readLacResponse.hasLacBody()) {\n+                                lacBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n+                            }\n+\n+                            if (readLacResponse.hasLastEntryBody()) {\n+                                lastEntryBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n+                            }\n+                            handleReadLacResponse(readLacResponse.getLedgerId(), status, lacBuffer, lastEntryBuffer, completionValue);\n                             break;\n-                        case GET_BOOKIE_INFO:\n-                            handleGetBookieInfoResponse(response, completionValue);\n+                        }\n+                        case GET_BOOKIE_INFO: {\n+                            GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();\n+                            StatusCode status = response.getStatus() == StatusCode.EOK ? getBookieInfoResponse.getStatus() : response.getStatus();\n+                            handleGetBookieInfoResponse(getBookieInfoResponse.getFreeDiskSpace(), getBookieInfoResponse.getTotalDiskCapacity(), status, completionValue);\n                             break;\n+                        }\n                         default:\n                             LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n                                       type, addr);\n@@ -1114,13 +1292,10 @@ public String toString() {\n         }\n     }\n \n-    void handleWriteLacResponse(WriteLacResponse writeLacResponse, CompletionValue completionValue) {\n+    void handleWriteLacResponse(long ledgerId, StatusCode status, CompletionValue completionValue) {\n         // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n         WriteLacCompletion plc = (WriteLacCompletion)completionValue;\n \n-        long ledgerId = writeLacResponse.getLedgerId();\n-        StatusCode status = writeLacResponse.getStatus();\n-\n         LOG.debug(\"Got response for writeLac request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" rc: \" + status);\n \n         // convert to BKException code\n@@ -1133,14 +1308,9 @@ void handleWriteLacResponse(WriteLacResponse writeLacResponse, CompletionValue c\n         plc.cb.writeLacComplete(rcToRet, ledgerId, addr, plc.ctx);\n     }\n \n- void handleAddResponse(Response response, CompletionValue completionValue) {\n+ void handleAddResponse(long ledgerId, long entryId, StatusCode status, CompletionValue completionValue) {\n         // The completion value should always be an instance of an AddCompletion object when we reach here.\n         AddCompletion ac = (AddCompletion)completionValue;\n-        AddResponse addResponse = response.getAddResponse();\n-\n-        long ledgerId = addResponse.getLedgerId();\n-        long entryId = addResponse.getEntryId();\n-        StatusCode status = response.getStatus() == StatusCode.EOK ? addResponse.getStatus() : response.getStatus();\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n@@ -1160,25 +1330,10 @@ void handleAddResponse(Response response, CompletionValue completionValue) {\n         ac.cb.writeComplete(rcToRet, ledgerId, entryId, addr, ac.ctx);\n     }\n \n-    void handleReadLacResponse(ReadLacResponse readLacResponse, CompletionValue completionValue) {\n+    void handleReadLacResponse(long ledgerId, StatusCode status, ChannelBuffer lacBuffer, ChannelBuffer lastEntryBuffer, CompletionValue completionValue) {\n         // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n         ReadLacCompletion glac = (ReadLacCompletion)completionValue;\n \n-        long ledgerId = readLacResponse.getLedgerId();\n-        StatusCode status = readLacResponse.getStatus();\n-        ChannelBuffer lacBuffer = ChannelBuffers.buffer(0);\n-        ChannelBuffer lastEntryBuffer = ChannelBuffers.buffer(0);\n-\n-       // Thread.dumpStack();\n-\n-        if (readLacResponse.hasLacBody()) {\n-            lacBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n-        }\n-\n-        if (readLacResponse.hasLastEntryBody()) {\n-            lastEntryBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n-        }\n-\n         LOG.debug(\"Got response for readLac request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" rc: \" + status);\n         // convert to BKException code\n         Integer rcToRet = statusCodeToExceptionCode(status);\n@@ -1190,20 +1345,10 @@ void handleReadLacResponse(ReadLacResponse readLacResponse, CompletionValue comp\n         glac.cb.readLacComplete(rcToRet, ledgerId, lacBuffer.slice(), lastEntryBuffer.slice(), glac.ctx);\n     }\n \n-    void handleReadResponse(Response response, CompletionValue completionValue) {\n+    void handleReadResponse(long ledgerId, long entryId, StatusCode status, ChannelBuffer buffer, CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n-        ReadResponse readResponse = response.getReadResponse();\n-\n-        long ledgerId = readResponse.getLedgerId();\n-        long entryId = readResponse.getEntryId();\n-        StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();\n \n-        ChannelBuffer buffer = ChannelBuffers.buffer(0);\n-\n-        if (readResponse.hasBody()) {\n-            buffer = ChannelBuffers.copiedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n-        }\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n@@ -1222,15 +1367,9 @@ void handleReadResponse(Response response, CompletionValue completionValue) {\n         rc.cb.readEntryComplete(rcToRet, ledgerId, entryId, buffer.slice(), rc.ctx);\n     }\n \n-    void handleGetBookieInfoResponse(Response response, CompletionValue completionValue) {\n+    void handleGetBookieInfoResponse(long freeDiskSpace, long totalDiskCapacity,  StatusCode status, CompletionValue completionValue) {\n         // The completion value should always be an instance of a GetBookieInfoCompletion object when we reach here.\n         GetBookieInfoCompletion rc = (GetBookieInfoCompletion)completionValue;\n-        GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();\n-\n-        long freeDiskSpace = getBookieInfoResponse.hasFreeDiskSpace() ? getBookieInfoResponse.getFreeDiskSpace() : 0L;\n-        long totalDiskCapacity = getBookieInfoResponse.hasTotalDiskCapacity() ? getBookieInfoResponse.getTotalDiskCapacity() : 0L;\n-\n-        StatusCode status = response.getStatus() == StatusCode.EOK ? getBookieInfoResponse.getStatus() : response.getStatus();\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for read metadata request from bookie: {} rc {}\", addr, rc);\n@@ -1556,4 +1695,35 @@ private long getTxnId() {\n         return txnIdGenerator.incrementAndGet();\n     }\n \n+    private class V2CompletionKey extends CompletionKey {\n+        final long ledgerId;\n+        final long entryId;\n+\n+\n+        public V2CompletionKey(long ledgerId, long entryId, OperationType operationType) {\n+            super(0, operationType);\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (!(object instanceof V2CompletionKey)) {\n+                return  false;\n+            }\n+            V2CompletionKey that = (V2CompletionKey) object;\n+            return  this.entryId == that.entryId && this.ledgerId == that.ledgerId;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(ledgerId, entryId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%d:%d %s\", ledgerId, entryId, operationType);\n+        }\n+    }\n }"}]}

