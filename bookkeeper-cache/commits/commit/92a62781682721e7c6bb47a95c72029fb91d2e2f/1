{"sha":"92a62781682721e7c6bb47a95c72029fb91d2e2f","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5MmE2Mjc4MTY4MjcyMWU3YzZiYjQ3YTk1YzcyMDI5ZmI5MWQyZTJm","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-02-05T21:43:39Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-02-05T21:43:39Z"},"message":"BOOKKEEPER-644: Provide a bookie address wrapper (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1564946 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"223e727d17c627b8503f75e322450364cc081bbc","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/223e727d17c627b8503f75e322450364cc081bbc"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/92a62781682721e7c6bb47a95c72029fb91d2e2f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/92a62781682721e7c6bb47a95c72029fb91d2e2f","html_url":"https://github.com/apache/bookkeeper/commit/92a62781682721e7c6bb47a95c72029fb91d2e2f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/92a62781682721e7c6bb47a95c72029fb91d2e2f/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"0345c8095ee47aefd7d40a07e2a621079c94f4fd","url":"https://api.github.com/repos/apache/bookkeeper/commits/0345c8095ee47aefd7d40a07e2a621079c94f4fd","html_url":"https://github.com/apache/bookkeeper/commit/0345c8095ee47aefd7d40a07e2a621079c94f4fd"}],"stats":{"total":1802,"additions":912,"deletions":890},"files":[{"sha":"0465ab0526e8688e0693856b8fcdb2d69a4aa276","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -56,6 +56,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-719: Inconsistent synchronization of org.apache.bookkeeper.stats.CodahaleMetricsProvider.metrics (sijie via ivank)\n \n+      BOOKKEEPER-644: Provide a bookie address wrapper (sijie via fpj)\n+\n       bookkeeper-server:\n \n         BOOKKEEPER-567: ReadOnlyBookieTest hangs on shutdown (sijie via ivank)"},{"sha":"258a3fb606b3b47d52b8ebfd8ca4024768a31ab6","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","status":"modified","additions":12,"deletions":15,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -19,13 +19,10 @@\n  */\n package org.apache.bookkeeper.benchmark;\n \n-import java.net.InetSocketAddress;\n-import java.util.concurrent.Executors;\n-\n import java.io.IOException;\n+import java.util.concurrent.Executors;\n \n-import org.apache.zookeeper.KeeperException;\n-\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -34,18 +31,18 @@\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-\n import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Option;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.PosixParser;\n import org.apache.commons.cli.ParseException;\n+import org.apache.zookeeper.KeeperException;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -57,7 +54,7 @@\n         boolean complete;\n         @Override\n         synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n-                InetSocketAddress addr, Object ctx) {\n+                BookieSocketAddress addr, Object ctx) {\n             if (rc != 0) {\n                 LOG.error(\"Got error \" + rc);\n             }\n@@ -78,7 +75,7 @@ synchronized public void waitForComplete() throws InterruptedException {\n         int count;\n         int waitingCount = Integer.MAX_VALUE;\n         synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n-                InetSocketAddress addr, Object ctx) {\n+                BookieSocketAddress addr, Object ctx) {\n             if (rc != 0) {\n                 LOG.error(\"Got error \" + rc);\n             }\n@@ -162,7 +159,7 @@ public static void main(String[] args)\n             toSend.writeLong(ledger);\n             toSend.writeLong(entry);\n             toSend.writerIndex(toSend.capacity());\n-            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20],\n+            bc.addEntry(new BookieSocketAddress(addr, port), ledger, new byte[20],\n                         entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n         }\n         LOG.info(\"Waiting for warmup\");\n@@ -180,7 +177,7 @@ public static void main(String[] args)\n             toSend.writeLong(entry);\n             toSend.writerIndex(toSend.capacity());\n             lc.resetComplete();\n-            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20],\n+            bc.addEntry(new BookieSocketAddress(addr, port), ledger, new byte[20],\n                         entry, toSend, lc, null, BookieProtocol.FLAG_NONE);\n             lc.waitForComplete();\n         }\n@@ -200,7 +197,7 @@ public static void main(String[] args)\n             toSend.writeLong(ledger);\n             toSend.writeLong(entry);\n             toSend.writerIndex(toSend.capacity());\n-            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20],\n+            bc.addEntry(new BookieSocketAddress(addr, port), ledger, new byte[20],\n                         entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n         }\n         tc.waitFor(entryCount);"},{"sha":"ec3cd610f532321e7663b6509f167b89065da3b7","filename":"bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","status":"modified","additions":12,"deletions":14,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -24,28 +24,26 @@\n import org.junit.Test;\n import org.junit.Assert;\n \n-import java.net.InetSocketAddress;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.util.LocalBookKeeper;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.LocalBookKeeper;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import java.util.Arrays;\n-import java.util.List;\n-\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.Watcher.Event.EventType;\n-import org.apache.zookeeper.Watcher.Event.KeeperState;\n-\n public class TestBenchmark extends BookKeeperClusterTestCase {\n     protected static final Logger LOG = LoggerFactory.getLogger(TestBenchmark.class);\n \n@@ -68,9 +66,9 @@ public void testThroughputLatency() throws Exception {\n \n     @Test(timeout=60000)\n     public void testBookie() throws Exception {\n-        InetSocketAddress bookie = getBookie(0);\n+        BookieSocketAddress bookie = getBookie(0);\n         BenchBookie.main(new String[] {\n-                \"--host\", bookie.getHostName(),\n+                \"--host\", bookie.getSocketAddress().getHostName(),\n                 \"--port\", String.valueOf(bookie.getPort()),\n                 \"--zookeeper\", zkUtil.getZooKeeperConnectString()\n                 });"},{"sha":"789bee9b087860d778cd191276c96c0bdb5d4d07","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -48,11 +48,11 @@\n import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.IOUtils;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.util.net.DNS;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n@@ -158,7 +158,7 @@ public long getEntry() {\n     static class NopWriteCallback implements WriteCallback {\n         @Override\n         public void writeComplete(int rc, long ledgerId, long entryId,\n-                                  InetSocketAddress addr, Object ctx) {\n+                                  BookieSocketAddress addr, Object ctx) {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n                           new Object[] { entryId, ledgerId, addr, rc });\n@@ -225,7 +225,7 @@ void setDone(T value) {\n \n         @Override\n         public void writeComplete(int rc, long ledgerId, long entryId,\n-                                  InetSocketAddress addr, Object ctx) {\n+                                  BookieSocketAddress addr, Object ctx) {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n                           new Object[] { entryId, ledgerId, addr, rc });\n@@ -352,16 +352,16 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n     /**\n      * Return the configured address of the bookie.\n      */\n-    public static InetSocketAddress getBookieAddress(ServerConfiguration conf)\n+    public static BookieSocketAddress getBookieAddress(ServerConfiguration conf)\n             throws UnknownHostException {\n         String iface = conf.getListeningInterface();\n         if (iface == null) {\n             iface = \"default\";\n         }\n-        InetSocketAddress addr = new InetSocketAddress(\n-                DNS.getDefaultHost(iface),\n-                conf.getBookiePort());\n-        if (addr.getAddress().isLoopbackAddress()\n+        InetSocketAddress inetAddr = new InetSocketAddress(DNS.getDefaultHost(iface), conf.getBookiePort());\n+        BookieSocketAddress addr =\n+            new BookieSocketAddress(inetAddr.getAddress().getHostAddress(), conf.getBookiePort());\n+        if (addr.getSocketAddress().getAddress().isLoopbackAddress()\n             && !conf.getAllowLoopback()) {\n             throw new UnknownHostException(\"Trying to listen on loopback address, \"\n                     + addr + \" but this is forbidden by default \"\n@@ -452,7 +452,7 @@ public Bookie(ServerConfiguration conf)\n     }\n \n     private String getMyId() throws UnknownHostException {\n-        return StringUtils.addrToString(Bookie.getBookieAddress(conf));\n+        return Bookie.getBookieAddress(conf).toString();\n     }\n \n     void readJournal() throws IOException, BookieException {\n@@ -1108,7 +1108,7 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n         int count;\n \n         @Override\n-        synchronized public void writeComplete(int rc, long l, long e, InetSocketAddress addr, Object ctx) {\n+        synchronized public void writeComplete(int rc, long l, long e, BookieSocketAddress addr, Object ctx) {\n             count--;\n             if (count == 0) {\n                 notifyAll();"},{"sha":"0749dbabc0a4f1ca5ae74ce91793f2e680e1d811","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"modified","additions":30,"deletions":33,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -18,46 +18,42 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Formatter;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.bookkeeper.meta.LedgerManagerFactory;\n-import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n-import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n-\n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.util.EntryFormatter;\n import org.apache.bookkeeper.util.Tool;\n import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.util.StringUtils;\n-\n-import org.apache.commons.configuration.Configuration;\n-import org.apache.commons.configuration.CompositeConfiguration;\n-import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.cli.BasicParser;\n-import org.apache.commons.cli.MissingArgumentException;\n-import org.apache.commons.cli.Options;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.MissingArgumentException;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-\n+import org.apache.commons.configuration.CompositeConfiguration;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n /**\n  * Bookie Shell is to provide utilities for users to administer a bookkeeper cluster.\n  */\n@@ -262,17 +258,17 @@ private int bkRecovery(BookKeeperAdmin bkAdmin, String[] args)\n                         + \"(host:port expected): \" + args[0]);\n                 return -1;\n             }\n-            final InetSocketAddress bookieSrc = new InetSocketAddress(\n+            final BookieSocketAddress bookieSrc = new BookieSocketAddress(\n                     bookieSrcString[0], Integer.parseInt(bookieSrcString[1]));\n-            InetSocketAddress bookieDest = null;\n+            BookieSocketAddress bookieDest = null;\n             if (args.length >= 2) {\n                 final String bookieDestString[] = args[1].split(\":\");\n                 if (bookieDestString.length < 2) {\n                     System.err.println(\"BookieDest inputted has invalid format\"\n                             + \"(host:port expected): \" + args[1]);\n                     return -1;\n                 }\n-                bookieDest = new InetSocketAddress(bookieDestString[0],\n+                bookieDest = new BookieSocketAddress(bookieDestString[0],\n                         Integer.parseInt(bookieDestString[1]));\n             }\n \n@@ -505,20 +501,20 @@ public int runCmd(CommandLine cmdLine) throws Exception {\n             BookKeeperAdmin bka = new BookKeeperAdmin(clientconf);\n \n             int count = 0;\n-            Collection<InetSocketAddress> bookies = new ArrayList<InetSocketAddress>();\n+            Collection<BookieSocketAddress> bookies = new ArrayList<BookieSocketAddress>();\n             if (cmdLine.hasOption(\"rw\")) {\n-                Collection<InetSocketAddress> availableBookies = bka\n+                Collection<BookieSocketAddress> availableBookies = bka\n                         .getAvailableBookies();\n                 bookies.addAll(availableBookies);\n             } else if (cmdLine.hasOption(\"ro\")) {\n-                Collection<InetSocketAddress> roBookies = bka\n+                Collection<BookieSocketAddress> roBookies = bka\n                         .getReadOnlyBookies();\n                 bookies.addAll(roBookies);\n             }\n-            for (InetSocketAddress b : bookies) {\n-                System.out.print(StringUtils.addrToString(b));\n+            for (BookieSocketAddress b : bookies) {\n+                System.out.print(b);\n                 if (cmdLine.hasOption(\"h\")) {\n-                    System.out.print(\"\\t\" + b.getHostName());\n+                    System.out.print(\"\\t\" + b.getSocketAddress().getHostName());\n                 }\n                 System.out.println(\"\");\n                 count++;\n@@ -1003,6 +999,7 @@ static String bytes2Hex(byte[] data) {\n         for (byte b : data) {\n             formatter.format(\"%02x\", b);\n         }\n+        formatter.close();\n         return sb.toString();\n     }\n }"},{"sha":"39c0243ed8d988ca369e9920292f4a8131016314","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","status":"modified","additions":12,"deletions":15,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,34 +20,31 @@\n  */\n package org.apache.bookkeeper.bookie;\n \n+import static com.google.common.base.Charsets.UTF_8;\n+\n import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n import java.io.EOFException;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n import java.io.StringReader;\n-\n import java.net.UnknownHostException;\n \n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.data.Stat;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.ZooDefs.Ids;\n-\n-import org.apache.bookkeeper.util.BookKeeperConstants;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.DataFormats.CookieFormat;\n-\n+import org.apache.bookkeeper.util.BookKeeperConstants;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.google.common.base.Charsets.UTF_8;\n import com.google.protobuf.TextFormat;\n \n /**\n@@ -209,7 +206,7 @@ static Cookie generateCookie(ServerConfiguration conf)\n             throws UnknownHostException {\n         Cookie c = new Cookie();\n         c.layoutVersion = CURRENT_COOKIE_LAYOUT_VERSION;\n-        c.bookieHost = StringUtils.addrToString(Bookie.getBookieAddress(conf));\n+        c.bookieHost = Bookie.getBookieAddress(conf).toString();\n         c.journalDir = conf.getJournalDirName();\n         StringBuilder b = new StringBuilder();\n         String[] dirs = conf.getLedgerDirNames();\n@@ -257,6 +254,6 @@ private static String getZkPath(ServerConfiguration conf)\n             throws UnknownHostException {\n         String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\"\n                 + BookKeeperConstants.COOKIE_NODE;\n-        return bookieCookiePath + \"/\" + StringUtils.addrToString(Bookie.getBookieAddress(conf));\n+        return bookieCookiePath + \"/\" + Bookie.getBookieAddress(conf);\n     }\n }"},{"sha":"7967a82c61d27a4b96b7d7ee283cfb0470340c4d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":60,"deletions":55,"changes":115,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,27 +20,13 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Random;\n-import java.util.UUID;\n-import java.util.Collection;\n-\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.SyncOpenCallback;\n import org.apache.bookkeeper.client.LedgerFragmentReplicator.SingleFragmentCallback;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager.LedgerRange;\n import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n@@ -50,13 +36,26 @@\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZKUtil;\n-import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZKUtil;\n import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.IOException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.UUID;\n+\n import static com.google.common.base.Charsets.UTF_8;\n \n /**\n@@ -71,7 +70,7 @@\n \n     // BookKeeper client instance\n     private BookKeeper bkc;\n-    \n+\n     // LedgerFragmentReplicator instance\n     private LedgerFragmentReplicator lfr;\n \n@@ -136,7 +135,7 @@ public BookKeeperAdmin(ClientConfiguration conf) throws IOException, Interrupted\n     /**\n      * Constructor that takes in a BookKeeper instance . This will be useful,\n      * when users already has bk instance ready.\n-     * \n+     *\n      * @param bkc\n      *            - bookkeeper instance\n      */\n@@ -164,7 +163,7 @@ public void close() throws InterruptedException, BKException {\n      *\n      * @return a collection of bookie addresses\n      */\n-    public Collection<InetSocketAddress> getAvailableBookies()\n+    public Collection<BookieSocketAddress> getAvailableBookies()\n             throws BKException {\n         return bkc.bookieWatcher.getBookies();\n     }\n@@ -174,7 +173,7 @@ public void close() throws InterruptedException, BKException {\n      *\n      * @return a collection of bookie addresses\n      */\n-    public Collection<InetSocketAddress> getReadOnlyBookies() {\n+    public Collection<BookieSocketAddress> getReadOnlyBookies() {\n         return bkc.bookieWatcher.getReadOnlyBookies();\n     }\n \n@@ -206,12 +205,12 @@ public void notifyBookiesChanged(final BookiesListener listener)\n     public void asyncOpenLedger(final long lId, final OpenCallback cb, final Object ctx) {\n         new LedgerOpenOp(bkc, lId, cb, ctx).initiate();\n     }\n-    \n+\n     /**\n      * Open a ledger as an administrator. This means that no digest password\n      * checks are done. Otherwise, the call is identical to\n      * BookKeeper#openLedger\n-     * \n+     *\n      * @param lId\n      *            - ledger identifier\n      * @see BookKeeper#openLedger\n@@ -249,12 +248,12 @@ public LedgerHandle openLedger(final long lId) throws InterruptedException,\n     public void asyncOpenLedgerNoRecovery(final long lId, final OpenCallback cb, final Object ctx) {\n         new LedgerOpenOp(bkc, lId, cb, ctx).initiateWithoutRecovery();\n     }\n-    \n+\n     /**\n      * Open a ledger as an administrator without recovering the ledger. This\n      * means that no digest password checks are done. Otherwise, the call is\n      * identical to BookKeeper#openLedgerNoRecovery\n-     * \n+     *\n      * @param lId\n      *            ledger identifier\n      * @see BookKeeper#openLedgerNoRecovery\n@@ -305,7 +304,7 @@ public SyncObject() {\n      *            Optional destination bookie that if passed, we will copy all\n      *            of the ledger fragments from the source bookie over to it.\n      */\n-    public void recoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest)\n+    public void recoverBookieData(final BookieSocketAddress bookieSrc, final BookieSocketAddress bookieDest)\n             throws InterruptedException, BKException {\n         SyncObject sync = new SyncObject();\n         // Call the async method to recover bookie data.\n@@ -356,7 +355,7 @@ public void recoverComplete(int rc, Object ctx) {\n      * @param context\n      *            Context for the RecoverCallback to call.\n      */\n-    public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+    public void asyncRecoverBookieData(final BookieSocketAddress bookieSrc, final BookieSocketAddress bookieDest,\n                                        final RecoverCallback cb, final Object context) {\n         // Sync ZK to make sure we're reading the latest bookie data.\n         zk.sync(bookiesPath, new AsyncCallback.VoidCallback() {\n@@ -368,7 +367,9 @@ public void processResult(int rc, String path, Object ctx) {\n                     return;\n                 }\n                 getAvailableBookies(bookieSrc, bookieDest, cb, context);\n-            };\n+            }\n+\n+            ;\n         }, null);\n     }\n \n@@ -391,9 +392,9 @@ public void processResult(int rc, String path, Object ctx) {\n      * @param context\n      *            Context for the RecoverCallback to call.\n      */\n-    private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+    private void getAvailableBookies(final BookieSocketAddress bookieSrc, final BookieSocketAddress bookieDest,\n                                      final RecoverCallback cb, final Object context) {\n-        final List<InetSocketAddress> availableBookies = new LinkedList<InetSocketAddress>();\n+        final List<BookieSocketAddress> availableBookies = new LinkedList<BookieSocketAddress>();\n         if (bookieDest != null) {\n             availableBookies.add(bookieDest);\n             // Now poll ZK to get the active ledgers\n@@ -414,13 +415,15 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n                             // exclude the readonly node from available bookies.\n                             continue;\n                         }\n-                        String parts[] = bookieNode.split(BookKeeperConstants.COLON);\n-                        if (parts.length < 2) {\n+                        BookieSocketAddress addr;\n+                        try {\n+                            addr = new BookieSocketAddress(bookieNode);\n+                        } catch (UnknownHostException nhe) {\n                             LOG.error(\"Bookie Node retrieved from ZK has invalid name format: \" + bookieNode);\n                             cb.recoverComplete(BKException.Code.ZKException, context);\n                             return;\n                         }\n-                        availableBookies.add(new InetSocketAddress(parts[0], Integer.parseInt(parts[1])));\n+                        availableBookies.add(addr);\n                     }\n                     // Now poll ZK to get the active ledgers\n                     getActiveLedgers(bookieSrc, null, cb, context, availableBookies);\n@@ -452,8 +455,8 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      *            single bookie server if the user explicitly chose a bookie\n      *            server to replicate data to.\n      */\n-    private void getActiveLedgers(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-                                  final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n+    private void getActiveLedgers(final BookieSocketAddress bookieSrc, final BookieSocketAddress bookieDest,\n+            final RecoverCallback cb, final Object context, final List<BookieSocketAddress> availableBookies) {\n         // Wrapper class around the RecoverCallback so it can be used\n         // as the final VoidCallback to process ledgers\n         class RecoverCallbackWrapper implements AsyncCallback.VoidCallback {\n@@ -476,18 +479,18 @@ public void process(Long ledgerId, AsyncCallback.VoidCallback iterCallback) {\n             }\n         };\n         bkc.getLedgerManager().asyncProcessLedgers(\n-            ledgerProcessor, new RecoverCallbackWrapper(cb),\n-            context, BKException.Code.OK, BKException.Code.LedgerRecoveryException);\n+                ledgerProcessor, new RecoverCallbackWrapper(cb),\n+                context, BKException.Code.OK, BKException.Code.LedgerRecoveryException);\n     }\n \n     /**\n      * Get a new random bookie, but ensure that it isn't one that is already\n      * in the ensemble for the ledger.\n      */\n-    private InetSocketAddress getNewBookie(final List<InetSocketAddress> bookiesAlreadyInEnsemble, \n-                                           final List<InetSocketAddress> availableBookies) \n+    private BookieSocketAddress getNewBookie(final List<BookieSocketAddress> bookiesAlreadyInEnsemble,\n+            final List<BookieSocketAddress> availableBookies)\n             throws BKException.BKNotEnoughBookiesException {\n-        ArrayList<InetSocketAddress> candidates = new ArrayList<InetSocketAddress>();\n+        ArrayList<BookieSocketAddress> candidates = new ArrayList<BookieSocketAddress>();\n         candidates.addAll(availableBookies);\n         candidates.removeAll(bookiesAlreadyInEnsemble);\n         if (candidates.size() == 0) {\n@@ -514,8 +517,8 @@ private InetSocketAddress getNewBookie(final List<InetSocketAddress> bookiesAlre\n      *            single bookie server if the user explicitly chose a bookie\n      *            server to replicate data to.\n      */\n-    private void recoverLedger(final InetSocketAddress bookieSrc, final long lId,\n-                               final AsyncCallback.VoidCallback ledgerIterCb, final List<InetSocketAddress> availableBookies) {\n+    private void recoverLedger(final BookieSocketAddress bookieSrc, final long lId,\n+            final AsyncCallback.VoidCallback ledgerIterCb, final List<BookieSocketAddress> availableBookies) {\n         LOG.debug(\"Recovering ledger : {}\", lId);\n \n         asyncOpenLedgerNoRecovery(lId, new OpenCallback() {\n@@ -531,7 +534,7 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                 if (!lm.isClosed() &&\n                     lm.getEnsembles().size() > 0) {\n                     Long lastKey = lm.getEnsembles().lastKey();\n-                    ArrayList<InetSocketAddress> lastEnsemble = lm.getEnsembles().get(lastKey);\n+                    ArrayList<BookieSocketAddress> lastEnsemble = lm.getEnsembles().get(lastKey);\n                     // the original write has not removed faulty bookie from\n                     // current ledger ensemble. to avoid data loss issue in\n                     // the case of concurrent updates to the ensemble composition,\n@@ -575,7 +578,7 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n                  */\n                 Map<Long, Long> ledgerFragmentsRange = new HashMap<Long, Long>();\n                 Long curEntryId = null;\n-                for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n+                for (Map.Entry<Long, ArrayList<BookieSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n                          .entrySet()) {\n                     if (curEntryId != null)\n                         ledgerFragmentsRange.put(curEntryId, entry.getKey() - 1);\n@@ -617,25 +620,26 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n                  */\n                 for (final Long startEntryId : ledgerFragmentsToRecover) {\n                     Long endEntryId = ledgerFragmentsRange.get(startEntryId);\n-                    InetSocketAddress newBookie = null;\n+                    BookieSocketAddress newBookie = null;\n                     try {\n                         newBookie = getNewBookie(lh.getLedgerMetadata().getEnsembles().get(startEntryId),\n                                                  availableBookies);\n                     } catch (BKException.BKNotEnoughBookiesException bke) {\n-                        ledgerFragmentsMcb.processResult(BKException.Code.NotEnoughBookiesException, \n+                        ledgerFragmentsMcb.processResult(BKException.Code.NotEnoughBookiesException,\n                                                          null, null);\n                         continue;\n                     }\n-                    \n+\n                     if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"Replicating fragment from [\" + startEntryId \n+                        LOG.debug(\"Replicating fragment from [\" + startEntryId\n                                   + \",\" + endEntryId + \"] of ledger \" + lh.getId()\n                                   + \" to \" + newBookie);\n                     }\n                     try {\n                         LedgerFragmentReplicator.SingleFragmentCallback cb = new LedgerFragmentReplicator.SingleFragmentCallback(\n                                                                                ledgerFragmentsMcb, lh, startEntryId, bookieSrc, newBookie);\n-                        ArrayList<InetSocketAddress> currentEnsemble =  lh.getLedgerMetadata().getEnsemble(startEntryId);\n+                        ArrayList<BookieSocketAddress> currentEnsemble = lh.getLedgerMetadata().getEnsemble(\n+                                startEntryId);\n                         int bookieIndex = -1;\n                         if (null != currentEnsemble) {\n                             for (int i = 0; i < currentEnsemble.size(); i++) {\n@@ -661,10 +665,10 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n      * This method asynchronously recovers a ledger fragment which is a\n      * contiguous portion of a ledger that was stored in an ensemble that\n      * included the failed bookie.\n-     * \n+     *\n      * @param lh\n      *            - LedgerHandle for the ledger\n-     * @param lf\n+     * @param ledgerFragment\n      *            - LedgerFragment to replicate\n      * @param ledgerFragmentMcb\n      *            - MultiCallback to invoke once we've recovered the current\n@@ -676,13 +680,14 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n     private void asyncRecoverLedgerFragment(final LedgerHandle lh,\n             final LedgerFragment ledgerFragment,\n             final AsyncCallback.VoidCallback ledgerFragmentMcb,\n-            final InetSocketAddress newBookie) throws InterruptedException {\n+            final BookieSocketAddress newBookie)\n+            throws InterruptedException {\n         lfr.replicate(lh, ledgerFragment, ledgerFragmentMcb, newBookie);\n     }\n \n     /**\n      * Replicate the Ledger fragment to target Bookie passed.\n-     * \n+     *\n      * @param lh\n      *            - ledgerHandle\n      * @param ledgerFragment\n@@ -692,7 +697,7 @@ private void asyncRecoverLedgerFragment(final LedgerHandle lh,\n      */\n     public void replicateLedgerFragment(LedgerHandle lh,\n             final LedgerFragment ledgerFragment,\n-            final InetSocketAddress targetBookieAddress)\n+            final BookieSocketAddress targetBookieAddress)\n             throws InterruptedException, BKException {\n         SyncCounter syncCounter = new SyncCounter();\n         ResultCallBack resultCallBack = new ResultCallBack(syncCounter);\n@@ -724,7 +729,7 @@ public void processResult(int rc, String s, Object obj) {\n \n     /**\n      * Format the BookKeeper metadata in zookeeper\n-     * \n+     *\n      * @param isInteractive\n      *            Whether format should ask prompt for confirmation if old data\n      *            exists or not."},{"sha":"744d9c69a8abe5a90c4a4796f2a08673b54f88a3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":32,"deletions":31,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,35 +15,34 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.client;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n-\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.apache.bookkeeper.util.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.AsyncCallback.ChildrenCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.AsyncCallback.ChildrenCallback;\n import org.apache.zookeeper.KeeperException.Code;\n import org.apache.zookeeper.KeeperException.NodeExistsException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.Watcher.Event.EventType;\n import org.apache.zookeeper.ZooDefs.Ids;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * This class is responsible for maintaining a consistent view of what bookies\n@@ -58,7 +55,7 @@\n     static final Logger logger = LoggerFactory.getLogger(BookieWatcher.class);\n \n     public static int ZK_CONNECT_BACKOFF_SEC = 1;\n-    private static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n+    private static final Set<BookieSocketAddress> EMPTY_SET = new HashSet<BookieSocketAddress>();\n \n     // Bookie registration path in ZK\n     private final String bookieRegistrationPath;\n@@ -108,7 +105,7 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n-    public Collection<InetSocketAddress> getBookies() throws BKException {\n+    public Collection<BookieSocketAddress> getBookies() throws BKException {\n         try {\n             List<String> children = bk.getZkHandle().getChildren(this.bookieRegistrationPath, false);\n             children.remove(BookKeeperConstants.READONLY);\n@@ -123,8 +120,8 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n-    Collection<InetSocketAddress> getReadOnlyBookies() {\n-        return new HashSet<InetSocketAddress>(readOnlyBookieWatcher.getReadOnlyBookies());\n+    Collection<BookieSocketAddress> getReadOnlyBookies() {\n+        return new HashSet<BookieSocketAddress>(readOnlyBookieWatcher.getReadOnlyBookies());\n     }\n \n     public void readBookies() {\n@@ -154,11 +151,11 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n         // available nodes list.\n         children.remove(BookKeeperConstants.READONLY);\n \n-        HashSet<InetSocketAddress> newBookieAddrs = convertToBookieAddresses(children);\n+        HashSet<BookieSocketAddress> newBookieAddrs = convertToBookieAddresses(children);\n \n-        final Set<InetSocketAddress> deadBookies;\n+        final Set<BookieSocketAddress> deadBookies;\n         synchronized (this) {\n-            Set<InetSocketAddress> readonlyBookies = readOnlyBookieWatcher.getReadOnlyBookies();\n+            Set<BookieSocketAddress> readonlyBookies = readOnlyBookieWatcher.getReadOnlyBookies();\n             deadBookies = placementPolicy.onClusterChanged(newBookieAddrs, readonlyBookies);\n         }\n \n@@ -167,13 +164,13 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n         }\n     }\n \n-    private static HashSet<InetSocketAddress> convertToBookieAddresses(List<String> children) {\n+    private static HashSet<BookieSocketAddress> convertToBookieAddresses(List<String> children) {\n         // Read the bookie addresses into a set for efficient lookup\n-        HashSet<InetSocketAddress> newBookieAddrs = new HashSet<InetSocketAddress>();\n+        HashSet<BookieSocketAddress> newBookieAddrs = new HashSet<BookieSocketAddress>();\n         for (String bookieAddrString : children) {\n-            InetSocketAddress bookieAddr;\n+            BookieSocketAddress bookieAddr;\n             try {\n-                bookieAddr = StringUtils.parseAddr(bookieAddrString);\n+                bookieAddr = new BookieSocketAddress(bookieAddrString);\n             } catch (IOException e) {\n                 logger.error(\"Could not parse bookie address: \" + bookieAddrString + \", ignoring this bookie\");\n                 continue;\n@@ -212,29 +209,33 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n     }\n \n     /**\n-     * Wrapper over the {@link #getAdditionalBookies(Set, int)} method when there is no exclusion list (or exisiting bookies)\n+     * Create an ensemble with given <i>ensembleSize</i> and <i>writeQuorumSize</i>.\n+     *\n      * @param ensembleSize\n      *          Ensemble Size\n      * @param writeQuorumSize\n      *          Write Quorum Size\n      * @return list of bookies for new ensemble.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize)\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize)\n             throws BKNotEnoughBookiesException {\n         return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, EMPTY_SET);\n     }\n \n     /**\n-     * Wrapper over the {@link #getAdditionalBookies(Set, int)} method when you just need 1 extra bookie\n+     * Choose a bookie to replace bookie <i>bookieIdx</i> in <i>existingBookies</i>.\n      * @param existingBookies\n-     * @return\n+     *          list of existing bookies.\n+     * @param bookieIdx\n+     *          index of the bookie in the list to be replaced.\n+     * @return the bookie to replace.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public InetSocketAddress replaceBookie(List<InetSocketAddress> existingBookies, int bookieIdx)\n+    public BookieSocketAddress replaceBookie(List<BookieSocketAddress> existingBookies, int bookieIdx)\n             throws BKNotEnoughBookiesException {\n-        InetSocketAddress addr = existingBookies.get(bookieIdx);\n-        return placementPolicy.replaceBookie(addr, new HashSet<InetSocketAddress>(existingBookies));\n+        BookieSocketAddress addr = existingBookies.get(bookieIdx);\n+        return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingBookies));\n     }\n \n     /**\n@@ -244,7 +245,7 @@ public InetSocketAddress replaceBookie(List<InetSocketAddress> existingBookies,\n     private static class ReadOnlyBookieWatcher implements Watcher, ChildrenCallback {\n \n         private final static Logger LOG = LoggerFactory.getLogger(ReadOnlyBookieWatcher.class);\n-        private HashSet<InetSocketAddress> readOnlyBookies = new HashSet<InetSocketAddress>();\n+        private HashSet<BookieSocketAddress> readOnlyBookies = new HashSet<BookieSocketAddress>();\n         private BookKeeper bk;\n         private String readOnlyBookieRegPath;\n \n@@ -307,12 +308,12 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n                 return;\n             }\n \n-            HashSet<InetSocketAddress> newReadOnlyBookies = convertToBookieAddresses(children);\n+            HashSet<BookieSocketAddress> newReadOnlyBookies = convertToBookieAddresses(children);\n             readOnlyBookies = newReadOnlyBookies;\n         }\n \n         // returns the readonly bookies\n-        public HashSet<InetSocketAddress> getReadOnlyBookies() {\n+        public HashSet<BookieSocketAddress> getReadOnlyBookies() {\n             return readOnlyBookies;\n         }\n     }"},{"sha":"5f2d2c31c7decee7f9acdd45c0ac2e4161846f90","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","status":"modified","additions":16,"deletions":17,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -17,39 +17,38 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.commons.configuration.Configuration;\n \n /**\n  * Default Ensemble Placement Policy, which picks bookies randomly\n  */\n public class DefaultEnsemblePlacementPolicy implements EnsemblePlacementPolicy {\n \n-    static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n+    static final Set<BookieSocketAddress> EMPTY_SET = new HashSet<BookieSocketAddress>();\n \n-    private Set<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n+    private Set<BookieSocketAddress> knownBookies = new HashSet<BookieSocketAddress>();\n \n     @Override\n-    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int quorumSize,\n-            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n-        ArrayList<InetSocketAddress> newBookies = new ArrayList<InetSocketAddress>(ensembleSize);\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int quorumSize,\n+            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        ArrayList<BookieSocketAddress> newBookies = new ArrayList<BookieSocketAddress>(ensembleSize);\n         if (ensembleSize <= 0) {\n             return newBookies;\n         }\n-        List<InetSocketAddress> allBookies;\n+        List<BookieSocketAddress> allBookies;\n         synchronized (this) {\n-            allBookies = new ArrayList<InetSocketAddress>(knownBookies);\n+            allBookies = new ArrayList<BookieSocketAddress>(knownBookies);\n         }\n         Collections.shuffle(allBookies);\n-        for (InetSocketAddress bookie : allBookies) {\n+        for (BookieSocketAddress bookie : allBookies) {\n             if (excludeBookies.contains(bookie)) {\n                 continue;\n             }\n@@ -63,17 +62,17 @@\n     }\n \n     @Override\n-    public InetSocketAddress replaceBookie(InetSocketAddress bookieToReplace,\n-            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n-        ArrayList<InetSocketAddress> addresses = newEnsemble(1, 1, excludeBookies);\n+    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n+            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        ArrayList<BookieSocketAddress> addresses = newEnsemble(1, 1, excludeBookies);\n         return addresses.get(0);\n     }\n \n     @Override\n-    public synchronized Set<InetSocketAddress> onClusterChanged(Set<InetSocketAddress> writableBookies,\n-            Set<InetSocketAddress> readOnlyBookies) {\n-        HashSet<InetSocketAddress> deadBookies;\n-        deadBookies = new HashSet<InetSocketAddress>(knownBookies);\n+    public synchronized Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n+            Set<BookieSocketAddress> readOnlyBookies) {\n+        HashSet<BookieSocketAddress> deadBookies;\n+        deadBookies = new HashSet<BookieSocketAddress>(knownBookies);\n         deadBookies.removeAll(writableBookies);\n         // readonly bookies should not be treated as dead bookies\n         deadBookies.removeAll(readOnlyBookies);"},{"sha":"a1d8ce38f766a8a8e399935433eaff500b59785b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -17,12 +17,11 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Set;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.commons.configuration.Configuration;\n \n /**\n@@ -55,8 +54,8 @@\n      *          All the bookies in the cluster available for readonly.\n      * @return the dead bookies during this cluster change.\n      */\n-    public Set<InetSocketAddress> onClusterChanged(Set<InetSocketAddress> writableBookies,\n-            Set<InetSocketAddress> readOnlyBookies);\n+    public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n+            Set<BookieSocketAddress> readOnlyBookies);\n \n     /**\n      * Choose <i>numBookies</i> bookies for ensemble. If the count is more than the number of available\n@@ -71,8 +70,8 @@\n      * @return list of bookies chosen as targets.\n      * @throws BKNotEnoughBookiesException if not enough bookies available.\n      */\n-    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n-            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n+            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n \n     /**\n      * Choose a new bookie to replace <i>bookieToReplace</i>. If no bookie available in the cluster,\n@@ -85,6 +84,6 @@\n      * @return the bookie chosen as target.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public InetSocketAddress replaceBookie(InetSocketAddress bookieToReplace,\n-            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n+            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n }"},{"sha":"962f3a341432c3825979a27708556c68384b8010","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":8,"deletions":10,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,22 +21,20 @@\n \n import java.util.ArrayList;\n import java.util.HashSet;\n-import java.util.Set;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.net.InetSocketAddress;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n /**\n  *Checks the complete ledger and finds the UnderReplicated fragments if any\n  */\n@@ -177,8 +175,8 @@ public void checkLedger(LedgerHandle lh,\n         final Set<LedgerFragment> fragments = new HashSet<LedgerFragment>();\n \n         Long curEntryId = null;\n-        ArrayList<InetSocketAddress> curEnsemble = null;\n-        for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : lh\n+        ArrayList<BookieSocketAddress> curEnsemble = null;\n+        for (Map.Entry<Long, ArrayList<BookieSocketAddress>> e : lh\n                 .getLedgerMetadata().getEnsembles().entrySet()) {\n             if (curEntryId != null) {\n                 for (int i = 0; i < curEnsemble.size(); i++) {\n@@ -234,7 +232,7 @@ public void operationComplete(int rc, Boolean result) {\n                                               });\n \n                 for (int bi : lh.getDistributionSchedule().getWriteSet(entryToRead)) {\n-                    InetSocketAddress addr = curEnsemble.get(bi);\n+                    BookieSocketAddress addr = curEnsemble.get(bi);\n                     bookieClient.readEntry(addr, lh.getId(),\n                                            entryToRead, eecb, null);\n                 }"},{"sha":"fe223af959228c34482ce9c96b25c4559858494b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,13 +21,13 @@\n \n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n \n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n@@ -95,7 +95,7 @@ public void initiate() {\n          * Adding bookies to ledger handle\n          */\n \n-        ArrayList<InetSocketAddress> ensemble;\n+        ArrayList<BookieSocketAddress> ensemble;\n         try {\n             ensemble = bk.bookieWatcher\n                     .newEnsemble(metadata.getEnsembleSize(), metadata.getWriteQuorumSize());"},{"sha":"6aadb8aaa1fc77cb12731fa24e1087bc3e67dda4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -19,11 +19,12 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.SortedMap;\n \n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+\n /**\n  * Represents the entries of a segment of a ledger which are stored on a single\n  * bookie in the segments bookie ensemble.\n@@ -32,7 +33,7 @@\n  */\n public class LedgerFragment {\n     private final int bookieIndex;\n-    private final List<InetSocketAddress> ensemble;\n+    private final List<BookieSocketAddress> ensemble;\n     private final long firstEntryId;\n     private final long lastKnownEntryId;\n     private final long ledgerId;\n@@ -47,7 +48,7 @@\n         this.bookieIndex = bookieIndex;\n         this.ensemble = lh.getLedgerMetadata().getEnsemble(firstEntryId);\n         this.schedule = lh.getDistributionSchedule();\n-        SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = lh\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles = lh\n                 .getLedgerMetadata().getEnsembles();\n         this.isLedgerClosed = lh.getLedgerMetadata().isClosed()\n                 || !ensemble.equals(ensembles.get(ensembles.lastKey()));\n@@ -82,7 +83,7 @@ long getLastKnownEntryId() {\n     /**\n      * Gets the failedBookie address\n      */\n-    public InetSocketAddress getAddress() {\n+    public BookieSocketAddress getAddress() {\n         return ensemble.get(bookieIndex);\n     }\n     \n@@ -133,7 +134,7 @@ public long getLastStoredEntryId() {\n      * \n      * @return the ensemble for the segment which this fragment is a part of\n      */\n-    public List<InetSocketAddress> getEnsemble() {\n+    public List<BookieSocketAddress> getEnsemble() {\n         return this.ensemble;\n     }\n "},{"sha":"7329ba112fbe5fdae19026107650c37e6694e07d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"modified","additions":15,"deletions":16,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -19,7 +19,6 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.HashSet;\n@@ -29,12 +28,12 @@\n import java.util.Set;\n \n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n-\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException.Code;\n import org.jboss.netty.buffer.ChannelBuffer;\n@@ -60,7 +59,7 @@ public LedgerFragmentReplicator(BookKeeper bkc) {\n     private void replicateFragmentInternal(final LedgerHandle lh,\n             final LedgerFragment lf,\n             final AsyncCallback.VoidCallback ledgerFragmentMcb,\n-            final InetSocketAddress newBookie) throws InterruptedException {\n+            final BookieSocketAddress newBookie) throws InterruptedException {\n         if (!lf.isClosed()) {\n             LOG.error(\"Trying to replicate an unclosed fragment;\"\n                       + \" This is not safe {}\", lf);\n@@ -133,7 +132,7 @@ private void replicateFragmentInternal(final LedgerHandle lh,\n      */\n     void replicate(final LedgerHandle lh, final LedgerFragment lf,\n             final AsyncCallback.VoidCallback ledgerFragmentMcb,\n-            final InetSocketAddress targetBookieAddress)\n+            final BookieSocketAddress targetBookieAddress)\n             throws InterruptedException {\n         Set<LedgerFragment> partionedFragments = splitIntoSubFragments(lh, lf,\n                 bkc.getConf().getRereplicationEntryBatchSize());\n@@ -147,7 +146,7 @@ void replicate(final LedgerHandle lh, final LedgerFragment lf,\n     private void replicateNextBatch(final LedgerHandle lh,\n             final Iterator<LedgerFragment> fragments,\n             final AsyncCallback.VoidCallback ledgerFragmentMcb,\n-            final InetSocketAddress targetBookieAddress) {\n+            final BookieSocketAddress targetBookieAddress) {\n         if (fragments.hasNext()) {\n             try {\n                 replicateFragmentInternal(lh, fragments.next(),\n@@ -238,7 +237,7 @@ public void processResult(int rc, String v, Object ctx) {\n     private void recoverLedgerFragmentEntry(final Long entryId,\n             final LedgerHandle lh,\n             final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,\n-            final InetSocketAddress newBookie) throws InterruptedException {\n+            final BookieSocketAddress newBookie) throws InterruptedException {\n         /*\n          * Read the ledger entry using the LedgerHandle. This will allow us to\n          * read the entry from one of the other replicated bookies other than\n@@ -269,7 +268,7 @@ public void readComplete(int rc, LedgerHandle lh,\n                         new WriteCallback() {\n                             @Override\n                             public void writeComplete(int rc, long ledgerId,\n-                                    long entryId, InetSocketAddress addr,\n+                                    long entryId, BookieSocketAddress addr,\n                                     Object ctx) {\n                                 if (rc != Code.OK.intValue()) {\n                                     LOG.error(\n@@ -308,12 +307,12 @@ public void writeComplete(int rc, long ledgerId,\n         final AsyncCallback.VoidCallback ledgerFragmentsMcb;\n         final LedgerHandle lh;\n         final long fragmentStartId;\n-        final InetSocketAddress oldBookie;\n-        final InetSocketAddress newBookie;\n+        final BookieSocketAddress oldBookie;\n+        final BookieSocketAddress newBookie;\n \n         SingleFragmentCallback(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n                 LedgerHandle lh, long fragmentStartId,\n-                InetSocketAddress oldBookie, InetSocketAddress newBookie) {\n+                BookieSocketAddress oldBookie, BookieSocketAddress newBookie) {\n             this.ledgerFragmentsMcb = ledgerFragmentsMcb;\n             this.lh = lh;\n             this.fragmentStartId = fragmentStartId;\n@@ -337,13 +336,13 @@ public void processResult(int rc, String path, Object ctx) {\n     /** Updates the ensemble with newBookie and notify the ensembleUpdatedCb */\n     private static void updateEnsembleInfo(\n             AsyncCallback.VoidCallback ensembleUpdatedCb, long fragmentStartId,\n-            LedgerHandle lh, InetSocketAddress oldBookie,\n-            InetSocketAddress newBookie) {\n+            LedgerHandle lh, BookieSocketAddress oldBookie,\n+            BookieSocketAddress newBookie) {\n         /*\n          * Update the ledger metadata's ensemble info to point to the new\n          * bookie.\n          */\n-        ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(fragmentStartId);\n         int deadBookieIndex = ensemble.indexOf(oldBookie);\n         ensemble.remove(deadBookieIndex);\n@@ -361,12 +360,12 @@ private static void updateEnsembleInfo(\n         final AsyncCallback.VoidCallback ensembleUpdatedCb;\n         final LedgerHandle lh;\n         final long fragmentStartId;\n-        final InetSocketAddress oldBookie;\n-        final InetSocketAddress newBookie;\n+        final BookieSocketAddress oldBookie;\n+        final BookieSocketAddress newBookie;\n \n         public UpdateEnsembleCb(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n                 long fragmentStartId, LedgerHandle lh,\n-                InetSocketAddress oldBookie, InetSocketAddress newBookie) {\n+                BookieSocketAddress oldBookie, BookieSocketAddress newBookie) {\n             this.ensembleUpdatedCb = ledgerFragmentsMcb;\n             this.lh = lh;\n             this.fragmentStartId = fragmentStartId;"},{"sha":"13d6aa797f3ff41939ed6e419f5574d47c6bb97b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -22,7 +22,6 @@\n \n import static com.google.common.base.Charsets.UTF_8;\n \n-import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -36,6 +35,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State;\n@@ -677,11 +677,11 @@ void sendAddSuccessCallbacks() {\n \n     }\n \n-    ArrayList<InetSocketAddress> replaceBookieInMetadata(final InetSocketAddress addr, final int bookieIndex)\n+    ArrayList<BookieSocketAddress> replaceBookieInMetadata(final BookieSocketAddress addr, final int bookieIndex)\n             throws BKException.BKNotEnoughBookiesException {\n-        InetSocketAddress newBookie;\n+        BookieSocketAddress newBookie;\n         LOG.info(\"Handling failure of bookie: {} index: {}\", addr, bookieIndex);\n-        final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>();\n+        final ArrayList<BookieSocketAddress> newEnsemble = new ArrayList<BookieSocketAddress>();\n         final long newEnsembleStartEntry = lastAddConfirmed + 1;\n \n         // avoid parallel ensemble changes to same ensemble.\n@@ -702,7 +702,7 @@ void sendAddSuccessCallbacks() {\n         return newEnsemble;\n     }\n \n-    void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n+    void handleBookieFailure(final BookieSocketAddress addr, final int bookieIndex) {\n         blockAddCompletions.incrementAndGet();\n \n         synchronized (metadata) {\n@@ -715,7 +715,7 @@ void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n             }\n \n             try {\n-                ArrayList<InetSocketAddress> newEnsemble = replaceBookieInMetadata(addr, bookieIndex);\n+                ArrayList<BookieSocketAddress> newEnsemble = replaceBookieInMetadata(addr, bookieIndex);\n \n                 EnsembleInfo ensembleInfo = new EnsembleInfo(newEnsemble, bookieIndex,\n                                                              addr);\n@@ -731,12 +731,12 @@ void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n \n     // Contains newly reformed ensemble, bookieIndex, failedBookieAddress\n     private static final class EnsembleInfo {\n-        private final ArrayList<InetSocketAddress> newEnsemble;\n+        private final ArrayList<BookieSocketAddress> newEnsemble;\n         private final int bookieIndex;\n-        private final InetSocketAddress addr;\n+        private final BookieSocketAddress addr;\n \n-        public EnsembleInfo(ArrayList<InetSocketAddress> newEnsemble,\n-                int bookieIndex, InetSocketAddress addr) {\n+        public EnsembleInfo(ArrayList<BookieSocketAddress> newEnsemble, int bookieIndex,\n+                            BookieSocketAddress addr) {\n             this.newEnsemble = newEnsemble;\n             this.bookieIndex = bookieIndex;\n             this.addr = addr;"},{"sha":"66260e0330047f44bb81414dddf6c58ae124ad97","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":33,"deletions":35,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -17,12 +17,17 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import static com.google.common.base.Charsets.UTF_8;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.TextFormat;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.StringReader;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Iterator;\n@@ -31,14 +36,7 @@\n import java.util.SortedMap;\n import java.util.TreeMap;\n \n-import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat;\n-import org.apache.bookkeeper.util.StringUtils;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.protobuf.ByteString;\n-import com.google.protobuf.TextFormat;\n+import static com.google.common.base.Charsets.UTF_8;\n \n /**\n  * This class encapsulates all the ledger metadata that is persistently stored\n@@ -70,8 +68,9 @@\n     private long lastEntryId;\n \n     private LedgerMetadataFormat.State state;\n-    private SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = new TreeMap<Long, ArrayList<InetSocketAddress>>();\n-    ArrayList<InetSocketAddress> currentEnsemble;\n+    private SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles =\n+        new TreeMap<Long, ArrayList<BookieSocketAddress>>();\n+    ArrayList<BookieSocketAddress> currentEnsemble;\n     volatile Version version = Version.NEW;\n \n     private boolean hasPassword = false;\n@@ -116,9 +115,9 @@ public LedgerMetadata(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n         this.password = new byte[other.password.length];\n         System.arraycopy(other.password, 0, this.password, 0, other.password.length);\n         // copy the ensembles\n-        for (Entry<Long, ArrayList<InetSocketAddress>> entry : other.ensembles.entrySet()) {\n+        for (Entry<Long, ArrayList<BookieSocketAddress>> entry : other.ensembles.entrySet()) {\n             long startEntryId = entry.getKey();\n-            ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>(entry.getValue());\n+            ArrayList<BookieSocketAddress> newEnsemble = new ArrayList<BookieSocketAddress>(entry.getValue());\n             this.addEnsemble(startEntryId, newEnsemble);\n         }\n     }\n@@ -135,11 +134,11 @@ private LedgerMetadata() {\n      * @return SortedMap of Ledger Fragments and the corresponding\n      * bookie ensembles that store the entries.\n      */\n-    public SortedMap<Long, ArrayList<InetSocketAddress>> getEnsembles() {\n+    public SortedMap<Long, ArrayList<BookieSocketAddress>> getEnsembles() {\n         return ensembles;\n     }\n \n-    void setEnsembles(SortedMap<Long, ArrayList<InetSocketAddress>> ensembles) {\n+    void setEnsembles(SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles) {\n         this.ensembles = ensembles;\n     }\n \n@@ -214,14 +213,14 @@ void close(long entryId) {\n         state = LedgerMetadataFormat.State.CLOSED;\n     }\n \n-    void addEnsemble(long startEntryId, ArrayList<InetSocketAddress> ensemble) {\n+    void addEnsemble(long startEntryId, ArrayList<BookieSocketAddress> ensemble) {\n         assert ensembles.isEmpty() || startEntryId >= ensembles.lastKey();\n \n         ensembles.put(startEntryId, ensemble);\n         currentEnsemble = ensemble;\n     }\n \n-    ArrayList<InetSocketAddress> getEnsemble(long entryId) {\n+    ArrayList<BookieSocketAddress> getEnsemble(long entryId) {\n         // the head map cannot be empty, since we insert an ensemble for\n         // entry-id 0, right when we start\n         return ensembles.get(ensembles.headMap(entryId + 1).lastKey());\n@@ -235,7 +234,7 @@ void addEnsemble(long startEntryId, ArrayList<InetSocketAddress> ensemble) {\n      * @return\n      */\n     long getNextEnsembleChange(long entryId) {\n-        SortedMap<Long, ArrayList<InetSocketAddress>> tailMap = ensembles.tailMap(entryId + 1);\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> tailMap = ensembles.tailMap(entryId + 1);\n \n         if (tailMap.isEmpty()) {\n             return -1;\n@@ -262,11 +261,11 @@ long getNextEnsembleChange(long entryId) {\n             builder.setDigestType(digestType).setPassword(ByteString.copyFrom(password));\n         }\n \n-        for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : ensembles.entrySet()) {\n+        for (Map.Entry<Long, ArrayList<BookieSocketAddress>> entry : ensembles.entrySet()) {\n             LedgerMetadataFormat.Segment.Builder segmentBuilder = LedgerMetadataFormat.Segment.newBuilder();\n             segmentBuilder.setFirstEntryId(entry.getKey());\n-            for (InetSocketAddress addr : entry.getValue()) {\n-                segmentBuilder.addEnsembleMember(StringUtils.addrToString(addr));\n+            for (BookieSocketAddress addr : entry.getValue()) {\n+                segmentBuilder.addEnsembleMember(addr.toString());\n             }\n             builder.addSegment(segmentBuilder.build());\n         }\n@@ -283,11 +282,11 @@ long getNextEnsembleChange(long entryId) {\n         s.append(VERSION_KEY).append(tSplitter).append(metadataFormatVersion).append(lSplitter);\n         s.append(writeQuorumSize).append(lSplitter).append(ensembleSize).append(lSplitter).append(length);\n \n-        for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : ensembles.entrySet()) {\n+        for (Map.Entry<Long, ArrayList<BookieSocketAddress>> entry : ensembles.entrySet()) {\n             s.append(lSplitter).append(entry.getKey());\n-            for (InetSocketAddress addr : entry.getValue()) {\n+            for (BookieSocketAddress addr : entry.getValue()) {\n                 s.append(tSplitter);\n-                s.append(StringUtils.addrToString(addr));\n+                s.append(addr.toString());\n             }\n         }\n \n@@ -325,7 +324,6 @@ public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws I\n         if (versionLine == null) {\n             throw new IOException(\"Invalid metadata. Content missing\");\n         }\n-        int i = 0;\n         if (versionLine.startsWith(VERSION_KEY)) {\n             String parts[] = versionLine.split(tSplitter);\n             lc.metadataFormatVersion = new Integer(parts[1]);\n@@ -372,9 +370,9 @@ public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws I\n         }\n \n         for (LedgerMetadataFormat.Segment s : data.getSegmentList()) {\n-            ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n+            ArrayList<BookieSocketAddress> addrs = new ArrayList<BookieSocketAddress>();\n             for (String member : s.getEnsembleMemberList()) {\n-                addrs.add(StringUtils.parseAddr(member));\n+                addrs.add(new BookieSocketAddress(member));\n             }\n             lc.addEnsemble(s.getFirstEntryId(), addrs);\n         }\n@@ -405,9 +403,9 @@ static LedgerMetadata parseVersion1Config(LedgerMetadata lc,\n                     lc.state = LedgerMetadataFormat.State.OPEN;\n                 }\n \n-                ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n+                ArrayList<BookieSocketAddress> addrs = new ArrayList<BookieSocketAddress>();\n                 for (int j = 1; j < parts.length; j++) {\n-                    addrs.add(StringUtils.parseAddr(parts[j]));\n+                    addrs.add(new BookieSocketAddress(parts[j]));\n                 }\n                 lc.addEnsemble(new Long(parts[0]), addrs);\n                 line = reader.readLine();\n@@ -420,7 +418,7 @@ static LedgerMetadata parseVersion1Config(LedgerMetadata lc,\n \n     /**\n      * Updates the version of this metadata.\n-     * \n+     *\n      * @param v Version\n      */\n     public void setVersion(Version v) {\n@@ -429,7 +427,7 @@ public void setVersion(Version v) {\n \n     /**\n      * Returns the last version.\n-     * \n+     *\n      * @return version\n      */\n     public Version getVersion() {\n@@ -507,21 +505,21 @@ public String toString() {\n         return sb.toString();\n     }\n \n-    void mergeEnsembles(SortedMap<Long, ArrayList<InetSocketAddress>> newEnsembles) {\n+    void mergeEnsembles(SortedMap<Long, ArrayList<BookieSocketAddress>> newEnsembles) {\n         // allow new metadata to be one ensemble less than current metadata\n         // since ensemble change might kick in when recovery changed metadata\n         int diff = ensembles.size() - newEnsembles.size();\n         if (0 != diff && 1 != diff) {\n             return;\n         }\n         int i = 0;\n-        for (Entry<Long, ArrayList<InetSocketAddress>> entry : newEnsembles.entrySet()) {\n+        for (Entry<Long, ArrayList<BookieSocketAddress>> entry : newEnsembles.entrySet()) {\n             ++i;\n             if (ensembles.size() != i) {\n                 // we should use last ensemble from current metadata\n                 // not the new metadata read from zookeeper\n                 long key = entry.getKey();\n-                ArrayList<InetSocketAddress> ensemble = entry.getValue();\n+                ArrayList<BookieSocketAddress> ensemble = entry.getValue();\n                 ensembles.put(key, ensemble);\n             }\n         }"},{"sha":"f464ac5d28cdc9352af78ccf9334b75b87951d69","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -19,8 +19,9 @@\n \n import java.util.HashSet;\n import java.util.Set;\n-import java.net.InetSocketAddress;\n+\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n@@ -138,7 +139,7 @@ void initiate(ChannelBuffer toSend, int entryLength) {\n     }\n \n     @Override\n-    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+    public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n         int bookieIndex = (Integer) ctx;\n \n         if (completed) {"},{"sha":"241fdbbfa270710a885534e3a4278ac2c1023d60","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":18,"deletions":18,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,7 +20,6 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.Enumeration;\n@@ -37,6 +36,7 @@\n \n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n@@ -59,7 +59,7 @@\n     final private ScheduledExecutorService scheduler;\n     private ScheduledFuture<?> speculativeTask = null;\n     Queue<LedgerEntryRequest> seq;\n-    Set<InetSocketAddress> heardFromHosts;\n+    Set<BookieSocketAddress> heardFromHosts;\n     ReadCallback cb;\n     Object ctx;\n     LedgerHandle lh;\n@@ -79,12 +79,12 @@\n         int firstError = BKException.Code.OK;\n         int numMissedEntryReads = 0;\n \n-        final ArrayList<InetSocketAddress> ensemble;\n+        final ArrayList<BookieSocketAddress> ensemble;\n         final List<Integer> writeSet;\n         final BitSet sentReplicas;\n         final BitSet erroredReplicas;\n \n-        LedgerEntryRequest(ArrayList<InetSocketAddress> ensemble, long lId, long eId) {\n+        LedgerEntryRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n             super(lId, eId);\n \n             this.ensemble = ensemble;\n@@ -93,7 +93,7 @@\n             this.erroredReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n         }\n \n-        private int getReplicaIndex(InetSocketAddress host) {\n+        private int getReplicaIndex(BookieSocketAddress host) {\n             int bookieIndex = ensemble.indexOf(host);\n             if (bookieIndex == -1) {\n                 return NOT_FOUND;\n@@ -112,9 +112,9 @@ private BitSet getSentToBitSet() {\n             return b;\n         }\n \n-        private BitSet getHeardFromBitSet(Set<InetSocketAddress> heardFromHosts) {\n+        private BitSet getHeardFromBitSet(Set<BookieSocketAddress> heardFromHosts) {\n             BitSet b = new BitSet(ensemble.size());\n-            for (InetSocketAddress i : heardFromHosts) {\n+            for (BookieSocketAddress i : heardFromHosts) {\n                 int index = ensemble.indexOf(i);\n                 if (index != -1) {\n                     b.set(index);\n@@ -132,7 +132,7 @@ private boolean readsOutstanding() {\n          * This returns the host we may have sent to for unit testing.\n          * @return host we sent to if we sent. null otherwise.\n          */\n-        synchronized InetSocketAddress maybeSendSpeculativeRead(Set<InetSocketAddress> heardFromHosts) {\n+        synchronized BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts) {\n             if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 return null;\n             }\n@@ -150,7 +150,7 @@ synchronized InetSocketAddress maybeSendSpeculativeRead(Set<InetSocketAddress> h\n             }\n         }\n \n-        synchronized InetSocketAddress sendNextRead() {\n+        synchronized BookieSocketAddress sendNextRead() {\n             if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 // we are done, the read has failed from all replicas, just fail the\n                 // read\n@@ -171,7 +171,7 @@ synchronized InetSocketAddress sendNextRead() {\n             nextReplicaIndexToReadFrom++;\n \n             try {\n-                InetSocketAddress to = ensemble.get(bookieIndex);\n+                BookieSocketAddress to = ensemble.get(bookieIndex);\n                 sendReadTo(to, this);\n                 sentReplicas.set(replica);\n                 return to;\n@@ -183,7 +183,7 @@ synchronized InetSocketAddress sendNextRead() {\n             }\n         }\n \n-        synchronized void logErrorAndReattemptRead(InetSocketAddress host, String errMsg, int rc) {\n+        synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n             if (BKException.Code.OK == firstError ||\n                 BKException.Code.NoSuchEntryException == firstError) {\n                 firstError = rc;\n@@ -216,7 +216,7 @@ synchronized void logErrorAndReattemptRead(InetSocketAddress host, String errMsg\n \n         // return true if we managed to complete the entry\n         // return false if the read entry is not complete or it is already completed before\n-        boolean complete(InetSocketAddress host, final ChannelBuffer buffer) {\n+        boolean complete(BookieSocketAddress host, final ChannelBuffer buffer) {\n             ChannelBufferInputStream is;\n             try {\n                 is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n@@ -262,7 +262,7 @@ public String toString() {\n         maxMissedReadsAllowed = getLedgerMetadata().getWriteQuorumSize()\n                 - getLedgerMetadata().getAckQuorumSize();\n         speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n-        heardFromHosts = new HashSet<InetSocketAddress>();\n+        heardFromHosts = new HashSet<BookieSocketAddress>();\n \n         readOpLogger = lh.bk.getReadOpLogger();\n     }\n@@ -281,7 +281,7 @@ private void cancelSpeculativeTask(boolean mayInterruptIfRunning) {\n     public void initiate() throws InterruptedException {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n         this.requestTimeMillis = MathUtils.now();\n-        ArrayList<InetSocketAddress> ensemble = null;\n+        ArrayList<BookieSocketAddress> ensemble = null;\n \n         if (speculativeReadTimeout > 0) {\n             speculativeTask = scheduler.scheduleWithFixedDelay(new Runnable() {\n@@ -322,19 +322,19 @@ public void run() {\n     }\n \n     private static class ReadContext {\n-        final InetSocketAddress to;\n+        final BookieSocketAddress to;\n         final LedgerEntryRequest entry;\n \n-        ReadContext(InetSocketAddress to, LedgerEntryRequest entry) {\n+        ReadContext(BookieSocketAddress to, LedgerEntryRequest entry) {\n             this.to = to;\n             this.entry = entry;\n         }\n     }\n \n-    void sendReadTo(InetSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n+    void sendReadTo(BookieSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n         lh.throttler.acquire();\n \n-        lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId, \n+        lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId,\n                                      this, new ReadContext(to, entry));\n     }\n "},{"sha":"7b15d9e6e8a17d19d495245382dcbe8d07e6b584","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","status":"modified","additions":30,"deletions":31,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -18,7 +18,6 @@\n package org.apache.bookkeeper.client;\n \n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -31,14 +30,14 @@\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.conf.Configurable;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.CachedDNSToSwitchMapping;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.NetworkTopology;\n import org.apache.bookkeeper.net.Node;\n import org.apache.bookkeeper.net.NodeBase;\n import org.apache.bookkeeper.net.ScriptBasedMapping;\n import org.apache.bookkeeper.util.ReflectionUtils;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.commons.configuration.Configuration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -80,7 +79,7 @@\n         /**\n          * @return list of addresses representing the ensemble\n          */\n-        public ArrayList<InetSocketAddress> toList();\n+        public ArrayList<BookieSocketAddress> toList();\n     }\n \n     protected static class TruePredicate implements Predicate {\n@@ -97,15 +96,15 @@ public boolean apply(BookieNode candidate, Ensemble chosenNodes) {\n     protected static class EnsembleForReplacement implements Ensemble {\n \n         public static final EnsembleForReplacement instance = new EnsembleForReplacement();\n-        static final ArrayList<InetSocketAddress> EMPTY_LIST = new ArrayList<InetSocketAddress>(0);\n+        static final ArrayList<BookieSocketAddress> EMPTY_LIST = new ArrayList<BookieSocketAddress>(0);\n \n         @Override\n         public void addBookie(BookieNode node) {\n             // do nothing\n         }\n \n         @Override\n-        public ArrayList<InetSocketAddress> toList() {\n+        public ArrayList<BookieSocketAddress> toList() {\n             return EMPTY_LIST;\n         }\n \n@@ -181,8 +180,8 @@ public void addBookie(BookieNode node) {\n         }\n \n         @Override\n-        public ArrayList<InetSocketAddress> toList() {\n-            ArrayList<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(ensembleSize);\n+        public ArrayList<BookieSocketAddress> toList() {\n+            ArrayList<BookieSocketAddress> addresses = new ArrayList<BookieSocketAddress>(ensembleSize);\n             for (BookieNode bn : chosenNodes) {\n                 addresses.add(bn.getAddr());\n             }\n@@ -198,20 +197,20 @@ public String toString() {\n \n     protected static class BookieNode implements Node {\n \n-        private final InetSocketAddress addr; // identifier of a bookie node.\n+        private final BookieSocketAddress addr; // identifier of a bookie node.\n \n         private int level; // the level in topology tree\n         private Node parent; // its parent in topology tree\n         private String location = NetworkTopology.DEFAULT_RACK; // its network location\n         private final String name;\n \n-        BookieNode(InetSocketAddress addr, String networkLoc) {\n+        BookieNode(BookieSocketAddress addr, String networkLoc) {\n             this.addr = addr;\n-            this.name = StringUtils.addrToString(addr);\n+            this.name = addr.toString();\n             setNetworkLocation(networkLoc);\n         }\n \n-        public InetSocketAddress getAddr() {\n+        public BookieSocketAddress getAddr() {\n             return addr;\n         }\n \n@@ -292,18 +291,18 @@ public void reloadCachedMappings() {\n     // for now, we just maintain the writable bookies' topology\n     private final NetworkTopology topology;\n     private DNSToSwitchMapping dnsResolver;\n-    private final Map<InetSocketAddress, BookieNode> knownBookies;\n+    private final Map<BookieSocketAddress, BookieNode> knownBookies;\n     private BookieNode localNode;\n     private final ReentrantReadWriteLock rwLock;\n \n     public RackawareEnsemblePlacementPolicy() {\n         topology = new NetworkTopology();\n-        knownBookies = new HashMap<InetSocketAddress, BookieNode>();\n+        knownBookies = new HashMap<BookieSocketAddress, BookieNode>();\n \n         rwLock = new ReentrantReadWriteLock();\n     }\n \n-    private BookieNode createBookieNode(InetSocketAddress addr) {\n+    private BookieNode createBookieNode(BookieSocketAddress addr) {\n         return new BookieNode(addr, resolveNetworkLocation(addr));\n     }\n \n@@ -322,7 +321,7 @@ public EnsemblePlacementPolicy initialize(Configuration conf) {\n \n         BookieNode bn;\n         try {\n-            bn = createBookieNode(new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0));\n+            bn = createBookieNode(new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0));\n         } catch (UnknownHostException e) {\n             LOG.error(\"Failed to get local host address : \", e);\n             bn = null;\n@@ -338,12 +337,12 @@ public void uninitalize() {\n         // do nothing\n     }\n \n-    private String resolveNetworkLocation(InetSocketAddress addr) {\n+    private String resolveNetworkLocation(BookieSocketAddress addr) {\n         List<String> names = new ArrayList<String>(1);\n         if (dnsResolver instanceof CachedDNSToSwitchMapping) {\n-            names.add(addr.getAddress().getHostAddress());\n+            names.add(addr.getSocketAddress().getAddress().getHostAddress());\n         } else {\n-            names.add(addr.getHostName());\n+            names.add(addr.getSocketAddress().getHostName());\n         }\n         // resolve network addresses\n         List<String> rNames = dnsResolver.resolve(names);\n@@ -359,12 +358,12 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n     }\n \n     @Override\n-    public Set<InetSocketAddress> onClusterChanged(Set<InetSocketAddress> writableBookies,\n-            Set<InetSocketAddress> readOnlyBookies) {\n+    public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n+            Set<BookieSocketAddress> readOnlyBookies) {\n         rwLock.writeLock().lock();\n         try {\n-            ImmutableSet<InetSocketAddress> joinedBookies, leftBookies, deadBookies;\n-            Set<InetSocketAddress> oldBookieSet = knownBookies.keySet();\n+            ImmutableSet<BookieSocketAddress> joinedBookies, leftBookies, deadBookies;\n+            Set<BookieSocketAddress> oldBookieSet = knownBookies.keySet();\n             // left bookies : bookies in known bookies, but not in new writable bookie cluster.\n             leftBookies = Sets.difference(oldBookieSet, writableBookies).immutableCopy();\n             // joined bookies : bookies in new writable bookie cluster, but not in known bookies\n@@ -378,7 +377,7 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n             }\n \n             // node left\n-            for (InetSocketAddress addr : leftBookies) {\n+            for (BookieSocketAddress addr : leftBookies) {\n                 BookieNode node = knownBookies.remove(addr);\n                 topology.remove(node);\n                 if (LOG.isDebugEnabled()) {\n@@ -387,7 +386,7 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n             }\n \n             // node joined\n-            for (InetSocketAddress addr : joinedBookies) {\n+            for (BookieSocketAddress addr : joinedBookies) {\n                 BookieNode node = createBookieNode(addr);\n                 topology.add(node);\n                 knownBookies.put(addr, node);\n@@ -402,9 +401,9 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n         }\n     }\n \n-    private Set<Node> convertBookiesToNodes(Set<InetSocketAddress> excludeBookies) {\n+    private Set<Node> convertBookiesToNodes(Set<BookieSocketAddress> excludeBookies) {\n         Set<Node> nodes = new HashSet<Node>();\n-        for (InetSocketAddress addr : excludeBookies) {\n+        for (BookieSocketAddress addr : excludeBookies) {\n             BookieNode bn = knownBookies.get(addr);\n             if (null == bn) {\n                 bn = createBookieNode(addr);\n@@ -415,8 +414,8 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n     }\n \n     @Override\n-    public ArrayList<InetSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n-            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n+            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n         rwLock.readLock().lock();\n         try {\n             Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n@@ -427,7 +426,7 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n             if (numRacks < 2) {\n                 List<BookieNode> bns = selectRandom(ensembleSize, excludeNodes,\n                         EnsembleForReplacement.instance);\n-                ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>(ensembleSize);\n+                ArrayList<BookieSocketAddress> addrs = new ArrayList<BookieSocketAddress>(ensembleSize);\n                 for (BookieNode bn : bns) {\n                     addrs.add(bn.addr);\n                 }\n@@ -454,8 +453,8 @@ private String resolveNetworkLocation(InetSocketAddress addr) {\n     }\n \n     @Override\n-    public InetSocketAddress replaceBookie(InetSocketAddress bookieToReplace,\n-            Set<InetSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n+            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n         rwLock.readLock().lock();\n         try {\n             BookieNode bn = knownBookies.get(bookieToReplace);"},{"sha":"8de4092b8d9e289a9702e2f8f2fb40e5c9bee329","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,15 +20,16 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import java.security.GeneralSecurityException;\n+\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.LedgerMetadataListener;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.bookkeeper.versioning.Version;\n \n-import java.security.GeneralSecurityException;\n-import java.net.InetSocketAddress;\n import java.util.concurrent.RejectedExecutionException;\n \n /**\n@@ -106,7 +107,7 @@ public void asyncAddEntry(final byte[] data, final int offset, final int length,\n     }\n \n     @Override\n-    void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n+    void handleBookieFailure(final BookieSocketAddress addr, final int bookieIndex) {\n         blockAddCompletions.incrementAndGet();\n         synchronized (metadata) {\n             try {"},{"sha":"78773330188f2e511ef282bc04d96ddbe2ffe5e0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -0,0 +1,100 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+\n+import static org.apache.bookkeeper.util.BookKeeperConstants.COLON;\n+\n+/**\n+ * This is a data wrapper class that is an InetSocketAddress, it would use the hostname\n+ * provided in constructors directly.\n+ * <p>\n+ * The string representation of a BookieSocketAddress is : <hostname>:<port>\n+ */\n+public class BookieSocketAddress {\n+\n+    // Member fields that make up this class.\n+    private final String hostname;\n+    private final int port;\n+\n+    private final InetSocketAddress socketAddress;\n+\n+    // Constructor that takes in both a port.\n+    public BookieSocketAddress(String hostname, int port) {\n+        this.hostname = hostname;\n+        this.port = port;\n+        socketAddress = new InetSocketAddress(hostname, port);\n+    }\n+\n+    // Constructor from a String \"serialized\" version of this class.\n+    public BookieSocketAddress(String addr) throws UnknownHostException {\n+        String[] parts = addr.split(COLON);\n+        if (parts.length < 2) {\n+            throw new UnknownHostException(addr);\n+        }\n+        this.hostname = parts[0];\n+        try {\n+            this.port = Integer.parseInt(parts[1]);\n+        } catch (NumberFormatException nfe) {\n+            throw new UnknownHostException(addr);\n+        }\n+        socketAddress = new InetSocketAddress(hostname, port);\n+    }\n+\n+    // Public getters\n+    public String getHostname() {\n+        return hostname;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    // Method to return an InetSocketAddress for the regular port.\n+    public InetSocketAddress getSocketAddress() {\n+        return socketAddress;\n+    }\n+\n+    // Return the String \"serialized\" version of this object.\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(hostname).append(COLON).append(port);\n+        return sb.toString();\n+    }\n+\n+    // Implement an equals method comparing two HedwigSocketAddress objects.\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof BookieSocketAddress))\n+            return false;\n+        BookieSocketAddress that = (BookieSocketAddress) obj;\n+        return this.hostname.equals(that.hostname) && (this.port == that.port);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return this.hostname.hashCode() + 13 * this.port;\n+    }\n+\n+}"},{"sha":"2f447d9eae3621259ba7a1eca6188ca14af1ff43","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":15,"deletions":16,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.proto;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,11 +18,11 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.proto;\n \n import static com.google.common.base.Charsets.UTF_8;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.util.HashSet;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -36,6 +34,7 @@\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -47,11 +46,10 @@\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n /**\n  * Implements the client-side part of the BookKeeper protocol.\n  *\n@@ -64,8 +62,8 @@\n \n     final OrderedSafeExecutor executor;\n     final ClientSocketChannelFactory channelFactory;\n-    final ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient> channels =\n-        new ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient>();\n+    final ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClient> channels =\n+        new ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClient>();\n     final ScheduledExecutorService timeoutExecutor = Executors\n             .newSingleThreadScheduledExecutor(new ThreadFactoryBuilder()\n                     .setNameFormat(\"BKClient-TimeoutTaskExecutor-%d\").build());\n@@ -88,7 +86,7 @@ public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channel\n         this.statsLogger = statsLogger;\n     }\n \n-    public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n+    public PerChannelBookieClient lookupClient(BookieSocketAddress addr) {\n         PerChannelBookieClient channel = channels.get(addr);\n \n         if (channel == null) {\n@@ -111,9 +109,9 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n         return channel;\n     }\n \n-    public void closeClients(Set<InetSocketAddress> addrs) {\n+    public void closeClients(Set<BookieSocketAddress> addrs) {\n         final HashSet<PerChannelBookieClient> clients = new HashSet<PerChannelBookieClient>();\n-        for (InetSocketAddress a : addrs) {\n+        for (BookieSocketAddress a : addrs) {\n             PerChannelBookieClient c = channels.get(a);\n             if (c != null) {\n                 clients.add(c);\n@@ -133,7 +131,8 @@ public void safeRun() {\n             });\n     }\n \n-    public void addEntry(final InetSocketAddress addr, final long ledgerId, final byte[] masterKey, final long entryId,\n+    public void addEntry(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n+            final long entryId,\n             final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n         final PerChannelBookieClient client = lookupClient(addr);\n         if (client == null) {\n@@ -159,7 +158,7 @@ public void safeRun() {\n         });\n     }\n \n-    public void readEntryAndFenceLedger(final InetSocketAddress addr,\n+    public void readEntryAndFenceLedger(final BookieSocketAddress addr,\n                                         final long ledgerId,\n                                         final byte[] masterKey,\n                                         final long entryId,\n@@ -189,7 +188,7 @@ public void safeRun() {\n         });\n     }\n \n-    public void readEntry(final InetSocketAddress addr, final long ledgerId, final long entryId,\n+    public void readEntry(final BookieSocketAddress addr, final long ledgerId, final long entryId,\n                           final ReadEntryCallback cb, final Object ctx) {\n         final PerChannelBookieClient client = lookupClient(addr);\n         if (client == null) {\n@@ -276,7 +275,7 @@ public static void main(String[] args) throws NumberFormatException, IOException\n         }\n         WriteCallback cb = new WriteCallback() {\n \n-            public void writeComplete(int rc, long ledger, long entry, InetSocketAddress addr, Object ctx) {\n+            public void writeComplete(int rc, long ledger, long entry, BookieSocketAddress addr, Object ctx) {\n                 Counter counter = (Counter) ctx;\n                 counter.dec();\n                 if (rc != 0) {\n@@ -296,7 +295,7 @@ public void writeComplete(int rc, long ledger, long entry, InetSocketAddress add\n         OrderedSafeExecutor executor = new OrderedSafeExecutor(1,\n                 \"BookieClientWorker\");\n         BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n-        InetSocketAddress addr = new InetSocketAddress(args[0], Integer.parseInt(args[1]));\n+        BookieSocketAddress addr = new BookieSocketAddress(args[0], Integer.parseInt(args[1]));\n \n         for (int i = 0; i < 100000; i++) {\n             counter.inc();"},{"sha":"b623998aea07f564d4fc3bf141e8b890d8d70634","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -81,7 +81,7 @@\n             // listen on all interfaces\n             bindAddress = new InetSocketAddress(conf.getBookiePort());\n         } else {\n-            bindAddress = Bookie.getBookieAddress(conf);\n+            bindAddress = Bookie.getBookieAddress(conf).getSocketAddress();\n         }\n         listenOn(bindAddress);\n     }"},{"sha":"b922a823b69bf0e63a3b873c492732297ff007a9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,7 +20,6 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import java.nio.channels.ClosedChannelException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.processor.RequestProcessor;\n import org.jboss.netty.channel.Channel;\n@@ -33,6 +32,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.nio.channels.ClosedChannelException;\n+\n /**\n  * Serverside handler for bookkeeper requests\n  */"},{"sha":"d6146e9e0fb894a3493942c9ba4b9bba3c874f40","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -22,7 +22,6 @@\n \n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n@@ -34,6 +33,7 @@\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.processor.RequestProcessor;\n import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.channel.Channel;\n@@ -202,7 +202,7 @@ private void handleAdd(BookieProtocol.Request r, Channel c) {\n \n     @Override\n     public void writeComplete(int rc, long ledgerId, long entryId,\n-                    InetSocketAddress addr, Object ctx) {\n+                              BookieSocketAddress addr, Object ctx) {\n         assert (ctx instanceof AddCtx);\n         AddCtx addctx = (AddCtx) ctx;\n         addctx.c.write(ResponseBuilder.buildAddResponse(addctx.r));"},{"sha":"0e04c091802b67a13035db6db500e4d67d916c20","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":7,"deletions":10,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -22,35 +22,32 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.net.MalformedURLException;\n import java.net.UnknownHostException;\n \n-import org.apache.zookeeper.KeeperException;\n-\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieCriticalThread;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.ExitCode;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.processor.RequestProcessor;\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-\n-import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.cli.BasicParser;\n-import org.apache.commons.cli.Options;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.zookeeper.KeeperException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.annotations.VisibleForTesting;\n+\n /**\n  * Implements the server-side part of the BookKeeper protocol.\n  *\n@@ -112,7 +109,7 @@ public void start() throws IOException, UnavailableException {\n     }\n \n     @VisibleForTesting\n-    public InetSocketAddress getLocalAddress() throws UnknownHostException {\n+    public BookieSocketAddress getLocalAddress() throws UnknownHostException {\n         return Bookie.getBookieAddress(conf);\n     }\n "},{"sha":"afb763e93e116e6b03cc35dc44524685e649757a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","status":"modified","additions":1,"deletions":3,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,11 +20,9 @@\n \n import java.net.UnknownHostException;\n \n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n-import org.apache.bookkeeper.proto.BKStats;\n import org.apache.bookkeeper.proto.BKStats.OpStatData;\n \n /**\n@@ -75,7 +73,7 @@ public OpStatData getReadStats() {\n     @Override\n     public String getServerPort() {\n         try {\n-            return StringUtils.addrToString(Bookie.getBookieAddress(conf));\n+            return Bookie.getBookieAddress(conf).toString();\n         } catch (UnknownHostException e) {\n             return \"localhost:\" + conf.getBookiePort();\n         }"},{"sha":"e6e7802ddd3cc1c5f5c55047d606326621219db5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,11 +21,11 @@\n \n package org.apache.bookkeeper.proto;\n \n-import java.net.InetSocketAddress;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.zookeeper.AsyncCallback;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n@@ -62,7 +62,7 @@\n     }\n \n     public interface WriteCallback {\n-        void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx);\n+        void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx);\n     }\n \n     public interface GenericCallback<T> {"},{"sha":"3738366cc4453f12023c56135b3c9d4e5de3ec0a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":15,"deletions":9,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -18,7 +18,6 @@\n package org.apache.bookkeeper.proto;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n import java.util.Queue;\n@@ -30,6 +29,7 @@\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -73,8 +73,7 @@\n     static final long maxMemory = Runtime.getRuntime().maxMemory() / 5;\n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n \n-\n-    InetSocketAddress addr;\n+    BookieSocketAddress addr;\n     AtomicLong totalBytesOutstanding;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor;\n@@ -148,20 +147,20 @@ private void errorOutTimedOutEntries() {\n     }\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n-                                  InetSocketAddress addr, AtomicLong totalBytesOutstanding,\n+                                  BookieSocketAddress addr, AtomicLong totalBytesOutstanding,\n                                   ScheduledExecutorService timeoutExecutor) {\n         this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, timeoutExecutor,\n                 NullStatsLogger.INSTANCE);\n     }\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n-                                  InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n+                                  BookieSocketAddress addr, AtomicLong totalBytesOutstanding) {\n         this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, null,\n                 NullStatsLogger.INSTANCE);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n-                                  ClientSocketChannelFactory channelFactory, InetSocketAddress addr,\n+                                  ClientSocketChannelFactory channelFactory, BookieSocketAddress addr,\n                                   AtomicLong totalBytesOutstanding, ScheduledExecutorService timeoutExecutor,\n                                   StatsLogger parentStatsLogger) {\n         this.conf = conf;\n@@ -172,7 +171,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.state = ConnectionState.DISCONNECTED;\n \n         StringBuilder nameBuilder = new StringBuilder();\n-        nameBuilder.append(addr.getHostName().replace('.', '_').replace('-', '_'))\n+        nameBuilder.append(addr.getHostname().replace('.', '_').replace('-', '_'))\n             .append(\"_\").append(addr.getPort());\n \n         this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE)\n@@ -201,7 +200,7 @@ private void connect() {\n         bootstrap.setOption(\"tcpNoDelay\", conf.getClientTcpNoDelay());\n         bootstrap.setOption(\"keepAlive\", true);\n \n-        ChannelFuture future = bootstrap.connect(addr);\n+        ChannelFuture future = bootstrap.connect(addr.getSocketAddress());\n         future.addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) throws Exception {\n@@ -302,12 +301,19 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n      * {@link #connectIfNeededAndDoOp(GenericCallback)}\n      *\n      * @param ledgerId\n+     *          Ledger Id\n      * @param masterKey\n+     *          Master Key\n      * @param entryId\n+     *          Entry Id\n      * @param toSend\n+     *          Buffer to send\n      * @param cb\n+     *          Write callback\n      * @param ctx\n+     *          Write callback context\n      * @param options\n+     *          Add options\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n@@ -799,7 +805,7 @@ public AddCompletion(final OpStatsLogger addEntryOpLogger,\n             final long requestTimeMillis = MathUtils.now();\n             this.cb = null == addEntryOpLogger ? originalCallback : new WriteCallback() {\n                 @Override\n-                public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+                public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n                     long latencyMillis = MathUtils.now() - requestTimeMillis;\n                     if (rc != BKException.Code.OK) {\n                         addEntryOpLogger.registerFailedEvent(latencyMillis);"},{"sha":"af5c1f32c62752c93254b7c808a1377a89c93f41","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":32,"deletions":42,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,55 +20,47 @@\n  */\n package org.apache.bookkeeper.replication;\n \n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ThreadFactory;\n-\n-import java.net.InetSocketAddress;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.BookKeeperAdmin;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n+import com.google.common.collect.Sets;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.BookiesListener;\n import org.apache.bookkeeper.client.LedgerChecker;\n import org.apache.bookkeeper.client.LedgerFragment;\n-import org.apache.bookkeeper.client.BookiesListener;\n-import org.apache.bookkeeper.util.StringUtils;\n-\n-import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n-\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n-\n import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.collections.CollectionUtils;\n-import com.google.common.collect.Sets;\n+import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.AsyncCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n /**\n  * Auditor is a single entity in the entire Bookie cluster and will be watching\n  * all the bookies under 'ledgerrootpath/available' zkpath. When any of the\n@@ -115,7 +107,6 @@ private void initialize(ServerConfiguration conf, ZooKeeper zkc)\n \n             this.bkc = new BookKeeper(new ClientConfiguration(conf), zkc);\n             this.admin = new BookKeeperAdmin(bkc);\n-\n         } catch (CompatibilityException ce) {\n             throw new UnavailableException(\n                     \"CompatibilityException while initializing Auditor\", ce);\n@@ -272,13 +263,13 @@ private void waitIfLedgerReplicationDisabled() throws UnavailableException,\n         // Watching on only available bookies is sufficient, as changes in readonly bookies also changes in available\n         // bookies\n         admin.notifyBookiesChanged(this);\n-        Collection<InetSocketAddress> availableBkAddresses = admin.getAvailableBookies();\n-        Collection<InetSocketAddress> readOnlyBkAddresses = admin.getReadOnlyBookies();\n+        Collection<BookieSocketAddress> availableBkAddresses = admin.getAvailableBookies();\n+        Collection<BookieSocketAddress> readOnlyBkAddresses = admin.getReadOnlyBookies();\n         availableBkAddresses.addAll(readOnlyBkAddresses);\n \n         List<String> availableBookies = new ArrayList<String>();\n-        for (InetSocketAddress addr : availableBkAddresses) {\n-            availableBookies.add(StringUtils.addrToString(addr));\n+        for (BookieSocketAddress addr : availableBkAddresses) {\n+            availableBookies.add(addr.toString());\n         }\n         return availableBookies;\n     }\n@@ -352,13 +343,12 @@ private void publishSuspectedLedgers(String bookieIP, Set<Long> ledgers)\n         public void operationComplete(int rc, Set<LedgerFragment> fragments) {\n             try {\n                 if (rc == BKException.Code.OK) {\n-                    Set<InetSocketAddress> bookies = Sets.newHashSet();\n+                    Set<BookieSocketAddress> bookies = Sets.newHashSet();\n                     for (LedgerFragment f : fragments) {\n                         bookies.add(f.getAddress());\n                     }\n-                    for (InetSocketAddress bookie : bookies) {\n-                        publishSuspectedLedgers(StringUtils.addrToString(bookie),\n-                                                Sets.newHashSet(lh.getId()));\n+                    for (BookieSocketAddress bookie : bookies) {\n+                        publishSuspectedLedgers(bookie.toString(), Sets.newHashSet(lh.getId()));\n                     }\n                 }\n                 lh.close();\n@@ -508,7 +498,7 @@ public void shutdown() {\n \n     /**\n      * Return true if auditor is running otherwise return false\n-     * \n+     *\n      * @return auditor status\n      */\n     public boolean isRunning() {"},{"sha":"176d27a3ef1e1130eb837579bdd979b6712be4e5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","status":"modified","additions":1,"deletions":3,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -31,7 +31,6 @@\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.cli.BasicParser;\n import org.apache.commons.cli.CommandLine;\n@@ -80,8 +79,7 @@ public void process(WatchedEvent event) {\n             }\n         };\n         zk = ZkUtils.createConnectedZookeeperClient(conf.getZkServers(), w);\n-        auditorElector = new AuditorElector(\n-                StringUtils.addrToString(Bookie.getBookieAddress(conf)), conf, zk);\n+        auditorElector = new AuditorElector(Bookie.getBookieAddress(conf).toString(), conf, zk);\n         replicationWorker = new ReplicationWorker(zk, conf,\n                 Bookie.getBookieAddress(conf));\n         deathWatcher = new AutoRecoveryDeathWatcher(this);"},{"sha":"1b4efafc1f40c5769fb4c9515aecc666e0d7d755","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -17,7 +17,6 @@\n  */\n package org.apache.bookkeeper.replication;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -30,10 +29,10 @@\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.zookeeper.AsyncCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -75,12 +74,12 @@ public void process(final Long ledgerId,\n                     public void operationComplete(final int rc,\n                             LedgerMetadata ledgerMetadata) {\n                         if (rc == BKException.Code.OK) {\n-                            for (Map.Entry<Long, ArrayList<InetSocketAddress>> ensemble : ledgerMetadata\n+                            for (Map.Entry<Long, ArrayList<BookieSocketAddress>> ensemble : ledgerMetadata\n                                     .getEnsembles().entrySet()) {\n-                                for (InetSocketAddress bookie : ensemble\n+                                for (BookieSocketAddress bookie : ensemble\n                                         .getValue()) {\n                                     putLedger(bookie2ledgersMap,\n-                                              StringUtils.addrToString(bookie),\n+                                              bookie.toString(),\n                                               ledgerId);\n                                 }\n                             }"},{"sha":"8df03c58200bd08eec3799f9f9058e86a05ed6d7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,7 +20,6 @@\n package org.apache.bookkeeper.replication;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.util.List;\n import java.util.Set;\n import java.util.Timer;\n@@ -29,18 +28,19 @@\n \n import org.apache.bookkeeper.bookie.BookieThread;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BKException.BKBookieHandleNotAvailableException;\n+import org.apache.bookkeeper.client.BKException.BKNoSuchLedgerExistsException;\n+import org.apache.bookkeeper.client.BKException.BKReadException;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.apache.bookkeeper.client.LedgerChecker;\n import org.apache.bookkeeper.client.LedgerFragment;\n import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.BKException.BKBookieHandleNotAvailableException;\n-import org.apache.bookkeeper.client.BKException.BKNoSuchLedgerExistsException;\n-import org.apache.bookkeeper.client.BKException.BKReadException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n@@ -62,7 +62,7 @@\n     private volatile boolean workerRunning = false;\n     final private BookKeeperAdmin admin;\n     private LedgerChecker ledgerChecker;\n-    private InetSocketAddress targetBookie;\n+    private BookieSocketAddress targetBookie;\n     private BookKeeper bkc;\n     private Thread workerThread;\n     private long openLedgerRereplicationGracePeriod;\n@@ -82,7 +82,7 @@\n      *            local Bookie address.\n      */\n     public ReplicationWorker(final ZooKeeper zkc,\n-            final ServerConfiguration conf, InetSocketAddress targetBKAddr)\n+            final ServerConfiguration conf, BookieSocketAddress targetBKAddr)\n             throws CompatibilityException, KeeperException,\n             InterruptedException, IOException {\n         this.zkc = zkc;\n@@ -328,8 +328,8 @@ boolean isRunning() {\n \n     private boolean isTargetBookieExistsInFragmentEnsemble(LedgerHandle lh,\n             LedgerFragment ledgerFragment) {\n-        List<InetSocketAddress> ensemble = ledgerFragment.getEnsemble();\n-        for (InetSocketAddress bkAddr : ensemble) {\n+        List<BookieSocketAddress> ensemble = ledgerFragment.getEnsemble();\n+        for (BookieSocketAddress bkAddr : ensemble) {\n             if (targetBookie.equals(bkAddr)) {\n                 return true;\n             }"},{"sha":"54e07c3df1e445f03fa72108c3d72267c554ac07","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"modified","additions":8,"deletions":12,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,22 +21,18 @@\n  *\n  */\n \n-import java.io.IOException;\n-import org.apache.zookeeper.KeeperException;\n-import java.net.InetSocketAddress;\n-\n-import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.zookeeper.KeeperException;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import java.io.IOException;\n \n /**\n  * Provides Admin Tools to manage the BookKeeper cluster.\n  *\n  */\n public class BookKeeperTools {\n-    private final static Logger LOG = LoggerFactory.getLogger(BookKeeperTools.class);\n \n     /**\n      * Main method so we can invoke the bookie recovery via command line.\n@@ -53,7 +49,7 @@\n      * @throws KeeperException\n      * @throws BKException\n      */\n-    public static void main(String[] args) \n+    public static void main(String[] args)\n             throws InterruptedException, IOException, KeeperException, BKException {\n         // Validate the inputs\n         if (args.length < 2) {\n@@ -67,17 +63,17 @@ public static void main(String[] args)\n             System.err.println(\"BookieSrc inputted has invalid name format (host:port expected): \" + args[1]);\n             return;\n         }\n-        final InetSocketAddress bookieSrc = new InetSocketAddress(bookieSrcString[0], Integer\n+        final BookieSocketAddress bookieSrc = new BookieSocketAddress(bookieSrcString[0], Integer\n                 .parseInt(bookieSrcString[1]));\n-        InetSocketAddress bookieDest = null;\n+        BookieSocketAddress bookieDest = null;\n         if (args.length < 3) {\n             String bookieDestString[] = args[2].split(\":\");\n             if (bookieDestString.length < 2) {\n                 System.err.println(\"BookieDest inputted has invalid name format (host:port expected): \"\n                                    + args[2]);\n                 return;\n             }\n-            bookieDest = new InetSocketAddress(bookieDestString[0], Integer.parseInt(bookieDestString[1]));\n+            bookieDest = new BookieSocketAddress(bookieDestString[0], Integer.parseInt(bookieDestString[1]));\n         }\n \n         // Create the BookKeeperTools instance and perform the bookie recovery"},{"sha":"bea03721dae126f4bb9c15bee502a30c221c97d7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"modified","additions":0,"deletions":29,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -19,7 +19,6 @@\n  */\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n \n /**\n  * Provided utilites for parsing network addresses, ledger-id from node paths\n@@ -31,34 +30,6 @@\n     // Ledger Node Prefix\n     static public final String LEDGER_NODE_PREFIX = \"L\";\n \n-    /**\n-     * Parses address into IP and port.\n-     *\n-     * @param addr\n-     *            String\n-     */\n-\n-    public static InetSocketAddress parseAddr(String s) throws IOException {\n-\n-        String parts[] = s.split(\":\");\n-        if (parts.length != 2) {\n-            throw new IOException(s + \" does not have the form host:port\");\n-        }\n-        int port;\n-        try {\n-            port = Integer.parseInt(parts[1]);\n-        } catch (NumberFormatException e) {\n-            throw new IOException(s + \" does not have the form host:port\");\n-        }\n-\n-        InetSocketAddress addr = new InetSocketAddress(parts[0], port);\n-        return addr;\n-    }\n-\n-    public static String addrToString(InetSocketAddress addr) {\n-        return addr.getAddress().getHostAddress() + \":\" + addr.getPort();\n-    }\n-\n     /**\n      * Formats ledger ID according to ZooKeeper rules\n      *"},{"sha":"77047dfc5b2d83e216303fd3b1f3f2d1a222c81e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":58,"deletions":55,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,36 +18,37 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.client;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.MSLedgerManagerFactory;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.HashSet;\n-import java.util.HashMap;\n-import java.util.Collections;\n import java.util.Random;\n-\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n-import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.MSLedgerManagerFactory;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * This class tests the bookie recovery admin functionality.\n@@ -244,7 +243,7 @@ public void testMetadataConflictWithRecovery() throws Exception {\n         for (int i = 0; i < numEntries; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress bookieToKill = lh.getLedgerMetadata().getEnsemble(numEntries - 1).get(1);\n+        BookieSocketAddress bookieToKill = lh.getLedgerMetadata().getEnsemble(numEntries - 1).get(1);\n         killBookie(bookieToKill);\n         startNewBookie();\n         for (int i = 0; i < numEntries; i++) {\n@@ -299,8 +298,10 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n         writeEntriestoLedgers(numMsgs, 10, lhs);\n \n         // Call the async recover bookie method.\n-        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n-        InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n+        BookieSocketAddress bookieSrc = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                initialPort);\n+        BookieSocketAddress bookieDest = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                newBookiePort);\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n                  + bookieDest + \")\");\n         // Initiate the sync object\n@@ -355,8 +356,9 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n         writeEntriestoLedgers(numMsgs, 10, lhs);\n \n         // Call the async recover bookie method.\n-        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n-        InetSocketAddress bookieDest = null;\n+        BookieSocketAddress bookieSrc = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                initialPort);\n+        BookieSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n                  + \") and replicate it to a random available one\");\n         // Initiate the sync object\n@@ -408,8 +410,10 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         writeEntriestoLedgers(numMsgs, 10, lhs);\n \n         // Call the sync recover bookie method.\n-        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n-        InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n+        BookieSocketAddress bookieSrc = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                initialPort);\n+        BookieSocketAddress bookieDest = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                newBookiePort);\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n                  + bookieDest + \")\");\n         bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n@@ -454,8 +458,9 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n         writeEntriestoLedgers(numMsgs, 10, lhs);\n \n         // Call the sync recover bookie method.\n-        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n-        InetSocketAddress bookieDest = null;\n+        BookieSocketAddress bookieSrc = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                initialPort);\n+        BookieSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n                  + \") and replicate it to a random available one\");\n         bkAdmin.recoverBookieData(bookieSrc, bookieDest);\n@@ -476,7 +481,6 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n         @Override\n         public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n             if (LOG.isDebugEnabled()) {\n-                InetSocketAddress addr = (InetSocketAddress)ctx;\n                 LOG.debug(\"Got \" + rc + \" for ledger \" + ledgerId + \" entry \" + entryId + \" from \" + ctx);\n             }\n             if (rc == BKException.Code.OK) {\n@@ -498,7 +502,7 @@ long await() throws InterruptedException {\n     private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws Exception {\n         LedgerMetadata md = getLedgerMetadata(lh);\n \n-        Map<Long, ArrayList<InetSocketAddress>> ensembles = md.getEnsembles();\n+        Map<Long, ArrayList<BookieSocketAddress>> ensembles = md.getEnsembles();\n \n         HashMap<Long, Long> ranges = new HashMap<Long, Long>();\n         ArrayList<Long> keyList = Collections.list(\n@@ -509,7 +513,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n         }\n         ranges.put(keyList.get(keyList.size()-1), untilEntry);\n \n-        for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : ensembles.entrySet()) {\n+        for (Map.Entry<Long, ArrayList<BookieSocketAddress>> e : ensembles.entrySet()) {\n             int quorum = md.getAckQuorumSize();\n             long startEntryId = e.getKey();\n             long endEntryId = ranges.get(startEntryId);\n@@ -518,7 +522,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n \n             ReplicationVerificationCallback cb = new ReplicationVerificationCallback(numRequests);\n             for (long i = startEntryId; i < endEntryId; i++) {\n-                for (InetSocketAddress addr : e.getValue()) {\n+                for (BookieSocketAddress addr : e.getValue()) {\n                     bkc.bookieClient.readEntry(addr, lh.getId(), i, cb, addr);\n                 }\n             }\n@@ -577,11 +581,11 @@ private boolean findDupesInEnsembles(List<LedgerHandle> lhs) throws Exception {\n         long numDupes = 0;\n         for (LedgerHandle lh : lhs) {\n             LedgerMetadata md = getLedgerMetadata(lh);\n-            for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : md.getEnsembles().entrySet()) {\n-                HashSet<InetSocketAddress> set = new HashSet<InetSocketAddress>();\n+            for (Map.Entry<Long, ArrayList<BookieSocketAddress>> e : md.getEnsembles().entrySet()) {\n+                HashSet<BookieSocketAddress> set = new HashSet<BookieSocketAddress>();\n                 long fragment = e.getKey();\n \n-                for (InetSocketAddress addr : e.getValue()) {\n+                for (BookieSocketAddress addr : e.getValue()) {\n                     if (set.contains(addr)) {\n                         LOG.error(\"Dupe \" + addr + \" found in ensemble for fragment \" + fragment\n                                 + \" of ledger \" + lh.getId());\n@@ -610,15 +614,15 @@ public void testBookieRecoveryOnClosedLedgers() throws Exception {\n         closeLedgers(lhs);\n \n         // Shutdown last bookie server in last ensemble\n-        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+        ArrayList<BookieSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n                                                        .entrySet().iterator().next().getValue();\n-        InetSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n+        BookieSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n         killBookie(bookieToKill);\n \n         // start a new bookie\n         startNewBookie();\n \n-        InetSocketAddress bookieDest = null;\n+        BookieSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieToKill\n                + \") and replicate it to a random available one\");\n \n@@ -640,15 +644,15 @@ public void testBookieRecoveryOnOpenedLedgers() throws Exception {\n         writeEntriestoLedgers(numMsgs, 0, lhs);\n \n         // Shutdown the first bookie server\n-        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+        ArrayList<BookieSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n                                                        .entrySet().iterator().next().getValue();\n-        InetSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n+        BookieSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n         killBookie(bookieToKill);\n \n         // start a new bookie\n         startNewBookie();\n \n-        InetSocketAddress bookieDest = null;\n+        BookieSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieToKill\n                + \") and replicate it to a random available one\");\n \n@@ -677,13 +681,13 @@ public void testBookieRecoveryOnInRecoveryLedger() throws Exception {\n         writeEntriestoLedgers(numMsgs, 0, lhs);\n \n         // Shutdown the first bookie server\n-        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+        ArrayList<BookieSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n                                                        .entrySet().iterator().next().getValue();\n         // removed bookie\n-        InetSocketAddress bookieToKill = lastEnsemble.get(0);\n+        BookieSocketAddress bookieToKill = lastEnsemble.get(0);\n         killBookie(bookieToKill);\n         // temp failure\n-        InetSocketAddress bookieToKill2 = lastEnsemble.get(1);\n+        BookieSocketAddress bookieToKill2 = lastEnsemble.get(1);\n         ServerConfiguration conf2 = killBookie(bookieToKill2);\n \n         // start a new bookie\n@@ -720,7 +724,7 @@ public void testBookieRecoveryOnInRecoveryLedger() throws Exception {\n         List<LedgerHandle> newLhs = openLedgers(lhs);\n         for (LedgerHandle newLh : newLhs) {\n             // first ensemble should contains bookieToKill2 and not contain bookieToKill\n-            Map.Entry<Long, ArrayList<InetSocketAddress>> entry =\n+            Map.Entry<Long, ArrayList<BookieSocketAddress>> entry =\n                 newLh.getLedgerMetadata().getEnsembles().entrySet().iterator().next();\n             assertFalse(entry.getValue().contains(bookieToKill));\n             assertTrue(entry.getValue().contains(bookieToKill2));\n@@ -745,8 +749,8 @@ public void testAsyncBookieRecoveryToRandomBookiesNotEnoughBookies() throws Exce\n         bs.remove(0);\n \n         // Call the async recover bookie method.\n-        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n-        InetSocketAddress bookieDest = null;\n+        BookieSocketAddress bookieSrc = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),\n+                initialPort);\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n                  + \") and replicate it to a random available one\");\n         // Initiate the sync object\n@@ -774,7 +778,7 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n         // Shutdown the first bookie server\n         LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n         int removeIndex = r.nextInt(bs.size());\n-        InetSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n+        BookieSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n         bs.get(removeIndex).shutdown();\n         bs.remove(removeIndex);\n \n@@ -808,7 +812,6 @@ public void recoverWithoutPasswordInConf() throws Exception {\n         byte[] passwdCorrect = \"AAAAAA\".getBytes();\n         byte[] passwdBad = \"BBBBBB\".getBytes();\n         DigestType digestCorrect = digestType;\n-        DigestType digestBad = (digestType == DigestType.MAC) ? DigestType.CRC32 : DigestType.MAC;\n \n         LedgerHandle lh = bkc.createLedger(3, 2, digestCorrect, passwdCorrect);\n         long ledgerId = lh.getId();\n@@ -817,7 +820,7 @@ public void recoverWithoutPasswordInConf() throws Exception {\n         }\n         lh.close();\n \n-        InetSocketAddress bookieSrc = bs.get(0).getLocalAddress();\n+        BookieSocketAddress bookieSrc = bs.get(0).getLocalAddress();\n         bs.get(0).shutdown();\n         bs.remove(0);\n         startNewBookie();\n@@ -919,9 +922,9 @@ public void ensurePasswordUsedForOldLedgers() throws Exception {\n         bkc41.close();\n \n         // Startup a new bookie server\n-        int newBookiePort = startNewBookie();\n+        startNewBookie();\n         int removeIndex = 0;\n-        InetSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n+        BookieSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n         bs.get(removeIndex).shutdown();\n         bs.remove(removeIndex);\n "},{"sha":"d914fcdb3c44bc82da4fde1d55a6815c750d120f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,14 +20,14 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.Random;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n import org.junit.Before;\n import org.junit.Test;\n@@ -107,7 +107,7 @@ public void testWithMultipleBookieFailuresInLastEnsemble() throws Exception {\n         startNewBookie();\n \n         // Shutdown three bookies in the last ensemble and continue writing\n-        ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata()\n                 .getEnsembles().entrySet().iterator().next().getValue();\n         killBookie(ensemble.get(0));\n         killBookie(ensemble.get(1));\n@@ -156,7 +156,7 @@ public void testAsyncWritesWithMultipleFailuresInLastEnsemble()\n         startNewBookie();\n \n         // Shutdown three bookies in the last ensemble and continue writing\n-        ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata()\n                 .getEnsembles().entrySet().iterator().next().getValue();\n         killBookie(ensemble.get(0));\n         killBookie(ensemble.get(1));"},{"sha":"4a7f1b52ed7a586363620690f8a5183497d7df42","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -18,7 +18,6 @@\n package org.apache.bookkeeper.client;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n@@ -31,6 +30,7 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n@@ -133,7 +133,7 @@ private void verifyMetadataConsistency(int numEntries, LedgerHandle lh)\n         final CountDownLatch recoverDoneLatch = new CountDownLatch(1);\n         final CountDownLatch failedLatch = new CountDownLatch(1);\n         // kill first bookie to replace with a unauthorize bookie\n-        InetSocketAddress bookie = lh.getLedgerMetadata().currentEnsemble.get(0);\n+        BookieSocketAddress bookie = lh.getLedgerMetadata().currentEnsemble.get(0);\n         ServerConfiguration conf = killBookie(bookie);\n         // replace a unauthorize bookie\n         startUnauthorizedBookie(conf, addDoneLatch);"},{"sha":"24ee71eff6a8780d4d657c74038d48e853740460","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -22,7 +22,6 @@\n  */\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n@@ -33,6 +32,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.test.BaseTestCase;\n import org.junit.Test;\n@@ -179,7 +179,7 @@ private void ledgerRecoveryWithSlowBookie(int ensembleSize, int writeQuorumSize,\n         // kill first bookie server to start a fake one to simulate a slow bookie\n         // and failed to add entry on crash\n         // until write succeed\n-        InetSocketAddress host = beforelh.getLedgerMetadata().currentEnsemble.get(slowBookieIdx);\n+        BookieSocketAddress host = beforelh.getLedgerMetadata().currentEnsemble.get(slowBookieIdx);\n         ServerConfiguration conf = killBookie(host);\n \n         Bookie fakeBookie = new Bookie(conf) {\n@@ -253,7 +253,7 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n         bs.add(startBookie(conf, deadBookie1));\n \n         // kill first bookie server\n-        InetSocketAddress bookie1 = lhbefore.getLedgerMetadata().currentEnsemble.get(0);\n+        BookieSocketAddress bookie1 = lhbefore.getLedgerMetadata().currentEnsemble.get(0);\n         ServerConfiguration conf1 = killBookie(bookie1);\n \n         // Try to recover and fence the ledger after killing one bookie in the\n@@ -268,7 +268,7 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n         // restart the first server, kill the second\n         bsConfs.add(conf1);\n         bs.add(startBookie(conf1));\n-        InetSocketAddress bookie2 = lhbefore.getLedgerMetadata().currentEnsemble.get(1);\n+        BookieSocketAddress bookie2 = lhbefore.getLedgerMetadata().currentEnsemble.get(1);\n         ServerConfiguration conf2 = killBookie(bookie2);\n \n         // using async, because this could trigger an assertion\n@@ -334,8 +334,8 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n         bs.add(startBookie(conf, deadBookie1));\n \n         // kill first bookie server\n-        InetSocketAddress bookie1 = lhbefore.getLedgerMetadata().currentEnsemble.get(0);\n-        ServerConfiguration conf1 = killBookie(bookie1);\n+        BookieSocketAddress bookie1 = lhbefore.getLedgerMetadata().currentEnsemble.get(0);\n+        killBookie(bookie1);\n \n         // Try to recover and fence the ledger after killing one bookie in the\n         // ensemble in the ensemble, and another bookie is available in zk but not writtable\n@@ -386,9 +386,9 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n             fail(\"Failed to add \" + numEntries + \" to ledger handle \" + lh.getId());\n         }\n         // kill first 2 bookies to replace bookies\n-        InetSocketAddress bookie1 = lh.getLedgerMetadata().currentEnsemble.get(0);\n+        BookieSocketAddress bookie1 = lh.getLedgerMetadata().currentEnsemble.get(0);\n         ServerConfiguration conf1 = killBookie(bookie1);\n-        InetSocketAddress bookie2 = lh.getLedgerMetadata().currentEnsemble.get(1);\n+        BookieSocketAddress bookie2 = lh.getLedgerMetadata().currentEnsemble.get(1);\n         ServerConfiguration conf2 = killBookie(bookie2);\n \n         // replace these two bookies"},{"sha":"bb69e2d3bf87dd269f003f67b816d54d1fefcffa","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","status":"modified","additions":7,"deletions":9,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,22 +21,20 @@\n \n package org.apache.bookkeeper.client;\n \n-import java.util.Set;\n import java.util.List;\n-\n+import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.net.InetSocketAddress;\n-import org.junit.Test;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n @SuppressWarnings(\"deprecation\")\n public class SlowBookieTest extends BookKeeperClusterTestCase {\n@@ -64,7 +62,7 @@ public void testSlowBookie() throws Exception {\n         final CountDownLatch b0latch = new CountDownLatch(1);\n         final CountDownLatch b1latch = new CountDownLatch(1);\n         final CountDownLatch addEntrylatch = new CountDownLatch(1);\n-        List<InetSocketAddress> curEns = lh.getLedgerMetadata().currentEnsemble;\n+        List<BookieSocketAddress> curEns = lh.getLedgerMetadata().currentEnsemble;\n         try {\n             sleepBookie(curEns.get(0), b0latch);\n             for (int i = 0; i < 10; i++) {"},{"sha":"84582cb7af3293a4b05635a1d639e2518dbd6fbb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"modified","additions":9,"deletions":15,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,20 +21,14 @@\n  *\n  */\n \n-import org.junit.*;\n-import java.net.InetSocketAddress;\n-import java.util.Enumeration;\n-import java.util.concurrent.CyclicBarrier;\n import java.util.concurrent.CountDownLatch;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.BookKeeperAdmin;\n-import org.apache.bookkeeper.client.BKException;\n+import java.util.concurrent.CyclicBarrier;\n+\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BaseTestCase;\n-\n+import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -228,7 +222,7 @@ public void testNoRecoveryOpen() throws Exception {\n         writelh.addEntry(tmp.getBytes());\n         long numReadable = readlh.getLastAddConfirmed();\n         LOG.error(\"numRead \" + numReadable);\n-        Enumeration<LedgerEntry> entries = readlh.readEntries(1, numReadable);\n+        readlh.readEntries(1, numReadable);\n         try {\n             readlh.readEntries(numReadable+1, numReadable+1);\n             fail(\"Shouldn't have been able to read this far\");\n@@ -266,7 +260,7 @@ public void testFencingInteractionWithBookieRecovery() throws Exception {\n             writelh.addEntry(tmp.getBytes());\n         }\n \n-        InetSocketAddress bookieToKill \n+        BookieSocketAddress bookieToKill\n             = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n         killBookie(bookieToKill);\n \n@@ -319,7 +313,7 @@ public void testFencingInteractionWithBookieRecovery2() throws Exception {\n         LedgerHandle readlh = bkc.openLedger(writelh.getId(), \n                                              digestType, \"testPasswd\".getBytes());\n         // should be fenced by now\n-        InetSocketAddress bookieToKill \n+        BookieSocketAddress bookieToKill\n             = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n         killBookie(bookieToKill);\n         admin.recoverBookieData(bookieToKill, null);\n@@ -356,7 +350,7 @@ public void testFencingBadPassword() throws Exception {\n          * Try to open ledger.\n          */\n         try {\n-            LedgerHandle readlh = bkc.openLedger(writelh.getId(), digestType, \"badPassword\".getBytes());\n+            bkc.openLedger(writelh.getId(), digestType, \"badPassword\".getBytes());\n             fail(\"Should not have been able to open with a bad password\");\n         } catch (BKException.BKUnauthorizedAccessException uue) {\n             // correct behaviour"},{"sha":"d6d5f3e0bea711afc9d6620dc532499e3a3443b3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"modified","additions":23,"deletions":23,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,11 +20,11 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n \n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.Test;\n@@ -74,7 +74,7 @@ public void testChecker() throws Exception {\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n         }\n-        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+        BookieSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n                 .get(0L).get(0);\n         LOG.info(\"Killing {}\", replicaToKill);\n         killBookie(replicaToKill);\n@@ -92,7 +92,7 @@ public void testChecker() throws Exception {\n         assertEquals(\"Fragment should be missing from first replica\", result\n                 .iterator().next().getAddress(), replicaToKill);\n \n-        InetSocketAddress replicaToKill2 = lh.getLedgerMetadata()\n+        BookieSocketAddress replicaToKill2 = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L).get(1);\n         LOG.info(\"Killing {}\", replicaToKill2);\n         killBookie(replicaToKill2);\n@@ -129,9 +129,9 @@ public void testShouldNotGetTheFragmentIfThereIsNoMissedEntry()\n         // Entry should have added in first 2 Bookies.\n \n         // Kill the 3rd BK from ensemble.\n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n-        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(2);\n+        BookieSocketAddress lastBookieFromEnsemble = firstEnsemble.get(2);\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n         killBookie(lastBookieFromEnsemble);\n@@ -172,13 +172,13 @@ public void testShouldGetTwoFrgamentsIfTwoBookiesFailedInSameEnsemble()\n         startNewBookie();\n         lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n \n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n \n-        InetSocketAddress firstBookieFromEnsemble = firstEnsemble.get(0);\n+        BookieSocketAddress firstBookieFromEnsemble = firstEnsemble.get(0);\n         killBookie(firstEnsemble, firstBookieFromEnsemble);\n \n-        InetSocketAddress secondBookieFromEnsemble = firstEnsemble.get(1);\n+        BookieSocketAddress secondBookieFromEnsemble = firstEnsemble.get(1);\n         killBookie(firstEnsemble, secondBookieFromEnsemble);\n         lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n         Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n@@ -203,9 +203,9 @@ public void testShouldNotGetAnyFragmentIfNoLedgerPresent()\n         LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n                 TEST_LEDGER_PASSWORD);\n \n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n-        InetSocketAddress firstBookieFromEnsemble = firstEnsemble.get(0);\n+        BookieSocketAddress firstBookieFromEnsemble = firstEnsemble.get(0);\n         killBookie(firstBookieFromEnsemble);\n         startNewBookie();\n         lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n@@ -235,9 +235,9 @@ public void testShouldGetFailedEnsembleNumberOfFgmntsIfEnsembleBookiesFailedOnNe\n         }\n \n         // Kill all three bookies\n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n-        for (InetSocketAddress bkAddr : firstEnsemble) {\n+        for (BookieSocketAddress bkAddr : firstEnsemble) {\n             killBookie(firstEnsemble, bkAddr);\n         }\n \n@@ -277,7 +277,7 @@ public void testShouldNotGetAnyFragmentWithEmptyLedger() throws Exception {\n     public void testShouldGet2FragmentsWithEmptyLedgerButBookiesDead() throws Exception {\n         LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n                 TEST_LEDGER_PASSWORD);\n-        for (InetSocketAddress b : lh.getLedgerMetadata().getEnsembles().get(0L)) {\n+        for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsembles().get(0L)) {\n             killBookie(b);\n         }\n         Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n@@ -294,9 +294,9 @@ public void testShouldGetOneFragmentWithSingleEntryOpenedLedger() throws Excepti\n         LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n                 TEST_LEDGER_PASSWORD);\n         lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n-        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(0);\n+        BookieSocketAddress lastBookieFromEnsemble = firstEnsemble.get(0);\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n         killBookie(lastBookieFromEnsemble);\n@@ -326,9 +326,9 @@ public void testSingleEntryAfterEnsembleChange() throws Exception {\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n         }\n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n-        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(\n+        BookieSocketAddress lastBookieFromEnsemble = firstEnsemble.get(\n                 lh.getDistributionSchedule().getWriteSet(lh.getLastAddPushed()).get(0));\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n@@ -361,11 +361,11 @@ public void testSingleEntryAfterEnsembleChange() throws Exception {\n     public void testClosedEmptyLedger() throws Exception {\n         LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n                 TEST_LEDGER_PASSWORD);\n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n         lh.close();\n \n-        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(0);\n+        BookieSocketAddress lastBookieFromEnsemble = firstEnsemble.get(0);\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n         killBookie(lastBookieFromEnsemble);\n@@ -388,13 +388,13 @@ public void testClosedEmptyLedger() throws Exception {\n     public void testClosedSingleEntryLedger() throws Exception {\n         LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n                 TEST_LEDGER_PASSWORD);\n-        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+        ArrayList<BookieSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n             .getEnsembles().get(0L);\n         lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n         lh.close();\n \n         // kill bookie 2\n-        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(2);\n+        BookieSocketAddress lastBookieFromEnsemble = firstEnsemble.get(2);\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n         killBookie(lastBookieFromEnsemble);\n@@ -453,8 +453,8 @@ public void testClosedSingleEntryLedger() throws Exception {\n         return result;\n     }\n \n-    private void killBookie(ArrayList<InetSocketAddress> firstEnsemble,\n-            InetSocketAddress ensemble) throws Exception {\n+    private void killBookie(ArrayList<BookieSocketAddress> firstEnsemble, BookieSocketAddress ensemble)\n+            throws Exception {\n         LOG.info(\"Killing \" + ensemble + \" from ensemble=\" + firstEnsemble);\n         killBookie(ensemble);\n     }"},{"sha":"175620916a3df2ea3ca05ea387b2389bdee0c558","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,15 +20,15 @@\n package org.apache.bookkeeper.client;\n \n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Enumeration;\n+import java.util.Map.Entry;\n import java.util.Set;\n import java.util.SortedMap;\n-import java.util.Map.Entry;\n import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.Test;\n@@ -81,7 +81,7 @@ public void testReplicateLFShouldCopyFailedBookieFragmentsToTargetBookie()\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+        BookieSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n                 .get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKill);\n@@ -92,7 +92,7 @@ public void testReplicateLFShouldCopyFailedBookieFragmentsToTargetBookie()\n             lh.addEntry(data);\n         }\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n         Set<LedgerFragment> result = getFragmentsToReplicate(lh);\n@@ -106,13 +106,13 @@ public void testReplicateLFShouldCopyFailedBookieFragmentsToTargetBookie()\n         }\n \n         // Killing all bookies except newly replicated bookie\n-        SortedMap<Long, ArrayList<InetSocketAddress>> allBookiesBeforeReplication = lh\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> allBookiesBeforeReplication = lh\n                 .getLedgerMetadata().getEnsembles();\n-        Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = allBookiesBeforeReplication\n+        Set<Entry<Long, ArrayList<BookieSocketAddress>>> entrySet = allBookiesBeforeReplication\n                 .entrySet();\n-        for (Entry<Long, ArrayList<InetSocketAddress>> entry : entrySet) {\n-            ArrayList<InetSocketAddress> bookies = entry.getValue();\n-            for (InetSocketAddress bookie : bookies) {\n+        for (Entry<Long, ArrayList<BookieSocketAddress>> entry : entrySet) {\n+            ArrayList<BookieSocketAddress> bookies = entry.getValue();\n+            for (BookieSocketAddress bookie : bookies) {\n                 if (newBkAddr.equals(bookie)) {\n                     continue;\n                 }\n@@ -138,7 +138,7 @@ public void testReplicateLFFailsOnlyOnLastUnClosedFragments()\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+        BookieSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n                 .get(0L).get(0);\n \n         startNewBookie();\n@@ -150,14 +150,14 @@ public void testReplicateLFFailsOnlyOnLastUnClosedFragments()\n             lh.addEntry(data);\n         }\n \n-        InetSocketAddress replicaToKill2 = lh.getLedgerMetadata()\n+        BookieSocketAddress replicaToKill2 = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L).get(1);\n \n         int startNewBookie2 = startNewBookie();\n         LOG.info(\"Killing Bookie\", replicaToKill2);\n         killBookie(replicaToKill2);\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie2);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n         Set<LedgerFragment> result = getFragmentsToReplicate(lh);\n@@ -198,7 +198,7 @@ public void testReplicateLFShouldReturnFalseIfTheReplicationFails()\n         }\n \n         // Kill the first Bookie\n-        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+        BookieSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n                 .get(0L).get(0);\n         killBookie(replicaToKill);\n         LOG.info(\"Killed Bookie =\" + replicaToKill);\n@@ -215,7 +215,7 @@ public void testReplicateLFShouldReturnFalseIfTheReplicationFails()\n         Set<LedgerFragment> fragments = getFragmentsToReplicate(lh);\n         BookKeeperAdmin admin = new BookKeeperAdmin(baseClientConf);\n         int startNewBookie = startNewBookie();\n-        InetSocketAddress additionalBK = new InetSocketAddress(InetAddress\n+        BookieSocketAddress additionalBK = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         for (LedgerFragment lf : fragments) {\n             try {\n@@ -236,7 +236,7 @@ public void testSplitIntoSubFragmentsWithDifferentFragmentBoundaries()\n         LedgerMetadata metadata = new LedgerMetadata(3, 3, 3, TEST_DIGEST_TYPE,\n                 TEST_PSSWD) {\n             @Override\n-            ArrayList<InetSocketAddress> getEnsemble(long entryId) {\n+            ArrayList<BookieSocketAddress> getEnsemble(long entryId) {\n                 return null;\n             }\n "},{"sha":"afdbe0b379ea4875e47839d244d64529cedb365d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","status":"modified","additions":96,"deletions":89,"changes":185,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,14 +20,14 @@\n import static org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy.REPP_DNS_RESOLVER_CLASS;\n \n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.Set;\n \n import junit.framework.TestCase;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.NetworkTopology;\n import org.apache.bookkeeper.util.StaticDNSResolver;\n import org.apache.commons.configuration.CompositeConfiguration;\n@@ -64,74 +64,77 @@ protected void tearDown() throws Exception {\n \n     @Test(timeout = 60000)\n     public void testReplaceBookieWithEnoughBookiesInSameRack() throws Exception {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n         addrs.add(addr4);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         // replace node under r2\n-        InetSocketAddress replacedBookie = repp.replaceBookie(addr2, new HashSet<InetSocketAddress>());\n+        BookieSocketAddress replacedBookie = repp.replaceBookie(addr2, new HashSet<BookieSocketAddress>());\n         assertEquals(addr3, replacedBookie);\n     }\n \n     @Test(timeout = 60000)\n     public void testReplaceBookieWithEnoughBookiesInDifferentRack() throws Exception {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n         addrs.add(addr4);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         // replace node under r2\n-        Set<InetSocketAddress> excludedAddrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n         excludedAddrs.add(addr1);\n-        InetSocketAddress replacedBookie = repp.replaceBookie(addr2, excludedAddrs);\n+        BookieSocketAddress replacedBookie = repp.replaceBookie(addr2, excludedAddrs);\n \n         assertFalse(addr1.equals(replacedBookie));\n         assertTrue(addr3.equals(replacedBookie) || addr4.equals(replacedBookie));\n     }\n \n     @Test(timeout = 60000)\n     public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n         addrs.add(addr4);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         // replace node under r2\n-        Set<InetSocketAddress> excludedAddrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n         excludedAddrs.add(addr1);\n         excludedAddrs.add(addr3);\n         excludedAddrs.add(addr4);\n@@ -145,21 +148,21 @@ public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n \n     @Test(timeout = 60000)\n     public void testNewEnsembleWithSingleRack() throws Exception {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n         addrs.add(addr4);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         try {\n-            ArrayList<InetSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<InetSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(0, getNumCoveredWriteQuorums(ensemble, 2));\n-            ArrayList<InetSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<InetSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(0, getNumCoveredWriteQuorums(ensemble2, 2));\n         } catch (BKNotEnoughBookiesException bnebe) {\n             fail(\"Should not get not enough bookies exception even there is only one rack.\");\n@@ -168,27 +171,28 @@ public void testNewEnsembleWithSingleRack() throws Exception {\n \n     @Test(timeout = 60000)\n     public void testNewEnsembleWithMultipleRacks() throws Exception {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n         addrs.add(addr4);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         try {\n-            ArrayList<InetSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<InetSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<BookieSocketAddress>());\n             int numCovered = getNumCoveredWriteQuorums(ensemble, 2);\n             assertTrue(numCovered >= 1 && numCovered < 3);\n-            ArrayList<InetSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<InetSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<BookieSocketAddress>());\n             numCovered = getNumCoveredWriteQuorums(ensemble2, 2);\n             assertTrue(numCovered >= 1 && numCovered < 3);\n         } catch (BKNotEnoughBookiesException bnebe) {\n@@ -198,25 +202,27 @@ public void testNewEnsembleWithMultipleRacks() throws Exception {\n \n     @Test(timeout = 90000)\n     public void testNewEnsembleWithEnoughRacks() throws Exception {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n-        InetSocketAddress addr5 = new InetSocketAddress(\"127.0.0.5\", 3181);\n-        InetSocketAddress addr6 = new InetSocketAddress(\"127.0.0.6\", 3181);\n-        InetSocketAddress addr7 = new InetSocketAddress(\"127.0.0.7\", 3181);\n-        InetSocketAddress addr8 = new InetSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r4\");\n-        StaticDNSResolver.addNodeToRack(addr5.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr6.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr7.getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr8.getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr6.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr7.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr8.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n@@ -225,11 +231,11 @@ public void testNewEnsembleWithEnoughRacks() throws Exception {\n         addrs.add(addr6);\n         addrs.add(addr7);\n         addrs.add(addr8);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         try {\n-            ArrayList<InetSocketAddress> ensemble1 = repp.newEnsemble(3, 2, new HashSet<InetSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble1 = repp.newEnsemble(3, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(3, getNumCoveredWriteQuorums(ensemble1, 2));\n-            ArrayList<InetSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<InetSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(4, getNumCoveredWriteQuorums(ensemble2, 2));\n         } catch (BKNotEnoughBookiesException bnebe) {\n             fail(\"Should not get not enough bookies exception even there is only one rack.\");\n@@ -241,36 +247,37 @@ public void testNewEnsembleWithEnoughRacks() throws Exception {\n      */\n     @Test(timeout = 60000)\n     public void testRemoveBookieFromCluster() {\n-        InetSocketAddress addr1 = new InetSocketAddress(\"127.0.0.1\", 3181);\n-        InetSocketAddress addr2 = new InetSocketAddress(\"127.0.0.2\", 3181);\n-        InetSocketAddress addr3 = new InetSocketAddress(\"127.0.0.3\", 3181);\n-        InetSocketAddress addr4 = new InetSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr4.getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n         // Update cluster\n-        Set<InetSocketAddress> addrs = new HashSet<InetSocketAddress>();\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n         addrs.add(addr2);\n         addrs.add(addr3);\n         addrs.add(addr4);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         addrs.remove(addr1);\n-        repp.onClusterChanged(addrs, new HashSet<InetSocketAddress>());\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n     }\n \n-    private int getNumCoveredWriteQuorums(ArrayList<InetSocketAddress> ensemble, int writeQuorumSize)\n+    private int getNumCoveredWriteQuorums(ArrayList<BookieSocketAddress> ensemble, int writeQuorumSize)\n             throws Exception {\n         int ensembleSize = ensemble.size();\n         int numCoveredWriteQuorums = 0;\n         for (int i = 0; i < ensembleSize; i++) {\n             Set<String> racks = new HashSet<String>();\n             for (int j = 0; j < writeQuorumSize; j++) {\n                 int bookieIdx = (i + j) % ensembleSize;\n-                InetSocketAddress addr = ensemble.get(bookieIdx);\n-                racks.add(StaticDNSResolver.getRack(addr.getAddress().getHostAddress()));\n+                BookieSocketAddress addr = ensemble.get(bookieIdx);\n+                racks.add(StaticDNSResolver.getRack(addr.getSocketAddress().getAddress().getHostAddress()));\n             }\n             numCoveredWriteQuorums += (racks.size() > 1 ? 1 : 0);\n         }"},{"sha":"96c5fa872a9feb459cf7d34b7fdf160d68ba96cc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","status":"modified","additions":11,"deletions":19,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,25 +21,17 @@\n  *\n  */\n \n-import org.junit.*;\n-import java.net.InetSocketAddress;\n-import java.util.Enumeration;\n-import java.util.concurrent.CyclicBarrier;\n+import java.util.HashSet;\n+import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n \n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.BookKeeperAdmin;\n-import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -70,12 +62,12 @@ public void testReadTimeout() throws Exception {\n             writelh.addEntry(tmp.getBytes());\n         }\n         \n-        Set<InetSocketAddress> beforeSet = new HashSet<InetSocketAddress>();\n-        for (InetSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries)) {\n+        Set<BookieSocketAddress> beforeSet = new HashSet<BookieSocketAddress>();\n+        for (BookieSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries)) {\n             beforeSet.add(addr);\n         }\n \n-        final InetSocketAddress bookieToSleep \n+        final BookieSocketAddress bookieToSleep\n             = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n         int sleeptime = baseClientConf.getReadTimeout()*3;\n         CountDownLatch latch = sleepBookie(bookieToSleep, sleeptime);\n@@ -91,8 +83,8 @@ public void addComplete(int rc, LedgerHandle lh,\n         Thread.sleep((baseClientConf.getReadTimeout()*3)*1000);\n         Assert.assertTrue(\"Write request did not finish\", completed.get());\n \n-        Set<InetSocketAddress> afterSet = new HashSet<InetSocketAddress>();\n-        for (InetSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries+1)) {\n+        Set<BookieSocketAddress> afterSet = new HashSet<BookieSocketAddress>();\n+        for (BookieSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries + 1)) {\n             afterSet.add(addr);\n         }\n         beforeSet.removeAll(afterSet);"},{"sha":"17f1ad468acc06df20d059f5f07d8601c06ea46d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"modified","additions":12,"deletions":16,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,23 +21,19 @@\n  *\n  */\n \n-import org.junit.*;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n-import java.util.Set;\n-import java.util.HashSet;\n import java.util.Enumeration;\n-import java.util.concurrent.TimeUnit;\n+import java.util.HashSet;\n+import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.BKException;\n+import java.util.concurrent.TimeUnit;\n+\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BaseTestCase;\n-\n+import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -132,7 +128,7 @@ public void testSpeculativeRead() throws Exception {\n \n         // sleep second bookie\n         CountDownLatch sleepLatch = new CountDownLatch(1);\n-        InetSocketAddress second = lnospec.getLedgerMetadata().getEnsembles().get(0L).get(1);\n+        BookieSocketAddress second = lnospec.getLedgerMetadata().getEnsembles().get(0L).get(1);\n         sleepBookie(second, sleepLatch);\n \n         try {\n@@ -287,10 +283,10 @@ public void testSpeculativeReadScheduling() throws Exception {\n \n         LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n \n-        ArrayList<InetSocketAddress> ensemble = l.getLedgerMetadata().getEnsembles().get(0L);\n-        Set<InetSocketAddress> allHosts = new HashSet<InetSocketAddress>(ensemble);\n-        Set<InetSocketAddress> noHost = new HashSet<InetSocketAddress>();\n-        Set<InetSocketAddress> secondHostOnly = new HashSet<InetSocketAddress>();\n+        ArrayList<BookieSocketAddress> ensemble = l.getLedgerMetadata().getEnsembles().get(0L);\n+        Set<BookieSocketAddress> allHosts = new HashSet<BookieSocketAddress>(ensemble);\n+        Set<BookieSocketAddress> noHost = new HashSet<BookieSocketAddress>();\n+        Set<BookieSocketAddress> secondHostOnly = new HashSet<BookieSocketAddress>();\n         secondHostOnly.add(ensemble.get(1));\n         PendingReadOp.LedgerEntryRequest req0 = null, req2 = null, req4 = null;\n         try {"},{"sha":"fc6aaa7303199e8ec49ef3851f4be0295112b830","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,12 +21,12 @@\n package org.apache.bookkeeper.client;\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.concurrent.TimeUnit;\n \n@@ -52,9 +52,9 @@ public void testWatchEnsembleChange() throws Exception {\n         LedgerHandle readLh = bkc.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n         long lastLAC = readLh.getLastAddConfirmed();\n         assertEquals(numEntries - 2, lastLAC);\n-        ArrayList<InetSocketAddress> ensemble =\n+        ArrayList<BookieSocketAddress> ensemble =\n                 lh.getLedgerMetadata().currentEnsemble;\n-        for (InetSocketAddress addr : ensemble) {\n+        for (BookieSocketAddress addr : ensemble) {\n             killBookie(addr);\n         }\n         // write another batch of entries, which will trigger ensemble change"},{"sha":"0ea590253c1fdb24400d36d2c4860d8342e9ba84","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":18,"deletions":21,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.proto;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,35 +18,34 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.proto;\n \n-import org.junit.*;\n-import java.net.InetSocketAddress;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-import java.nio.ByteBuffer;\n-import java.io.IOException;\n-\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.PerChannelBookieClient.ConnectionState;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.jboss.netty.channel.Channel;\n+import org.apache.bookkeeper.util.SafeRunnable;\n import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-\n+import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n /**\n  * Tests for PerChannelBookieClient. Historically, this class has\n  * had a few race conditions, so this is what these tests focus on.\n@@ -75,7 +72,7 @@ public void testConnectCloseRace() throws Exception {\n         OrderedSafeExecutor executor = new OrderedSafeExecutor(1,\n                 \"BKClientOrderedSafeExecutor\");\n \n-        InetSocketAddress addr = getBookie(0);\n+        BookieSocketAddress addr = getBookie(0);\n         AtomicLong bytesOutstanding = new AtomicLong(0);\n         for (int i = 0; i < 1000; i++) {\n             PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n@@ -113,7 +110,7 @@ public void operationComplete(int rc, Void result) {\n         OrderedSafeExecutor executor = new OrderedSafeExecutor(1,\n                 \"BKClientOrderedSafeExecutor\");\n \n-        InetSocketAddress addr = getBookie(0);\n+        BookieSocketAddress addr = getBookie(0);\n         AtomicLong bytesOutstanding = new AtomicLong(0);\n         for (int i = 0; i < 100; i++) {\n             PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n@@ -148,7 +145,7 @@ public void operationComplete(int rc, Void result) {\n                                                 Executors.newCachedThreadPool());\n         OrderedSafeExecutor executor = new OrderedSafeExecutor(1,\n                 \"BKClientOrderedSafeExecutor\");\n-        InetSocketAddress addr = getBookie(0);\n+        BookieSocketAddress addr = getBookie(0);\n \n         AtomicLong bytesOutstanding = new AtomicLong(0);\n         final PerChannelBookieClient client = new PerChannelBookieClient(executor,\n@@ -247,7 +244,7 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n                                                 Executors.newCachedThreadPool());\n         final OrderedSafeExecutor executor = new OrderedSafeExecutor(1,\n                 \"BKClientOrderedSafeExecutor\");\n-        InetSocketAddress addr = getBookie(0);\n+        BookieSocketAddress addr = getBookie(0);\n         AtomicLong bytesOutstanding = new AtomicLong(0);\n \n         final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,"},{"sha":"5fcc445dda3d929d5bd401c37d25523c8511bf8f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","status":"modified","additions":15,"deletions":19,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,28 +21,23 @@\n \n package org.apache.bookkeeper.proto;\n \n-import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-\n-import org.apache.bookkeeper.client.BKException;\n-\n-import org.apache.bookkeeper.test.BaseTestCase;\n-import org.apache.bookkeeper.test.BookieClientTest;\n-import static org.junit.Assert.*;\n-import org.junit.Test;\n-import org.junit.Before;\n-import org.junit.After;\n-\n-import java.util.concurrent.TimeUnit;\n+import static org.junit.Assert.assertEquals;\n \n+import java.net.InetAddress;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.net.InetSocketAddress;\n-import java.net.InetAddress;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.test.BookieClientTest;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n \n public class TestProtoVersions {\n     private BookieClientTest base;\n@@ -60,7 +55,8 @@ public void teardown() throws Exception {\n \n     private void testVersion(byte version, int expectedresult) throws Exception {\n         PerChannelBookieClient bc = new PerChannelBookieClient(base.executor, base.channelFactory, \n-                new InetSocketAddress(InetAddress.getLocalHost(), base.port), new AtomicLong(0));\n+                new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), base.port),\n+                new AtomicLong(0));\n         final AtomicInteger outerrc = new AtomicInteger(-1);\n         final CountDownLatch connectLatch = new CountDownLatch(1);\n         bc.connectIfNeededAndDoOp(new GenericCallback<Void>() {"},{"sha":"6070a2a67a197c4b2d397411381608ca4d851d27","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"modified","additions":5,"deletions":8,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -28,12 +28,9 @@\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n-\n-import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import org.apache.bookkeeper.util.StringUtils;\n-import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.junit.Test;\n import org.slf4j.Logger;\n@@ -166,7 +163,7 @@ public void testShutdown() throws Exception {\n         for (String child : children) {\n             byte[] data = zkc.getData(electionPath + '/' + child, false, null);\n             String bookieIP = new String(data);\n-            String addr = StringUtils.addrToString(auditor.getLocalAddress());\n+            String addr = auditor.getLocalAddress().toString();\n             Assert.assertFalse(\"AuditorElection cleanup fails\", bookieIP\n                     .contains(addr));\n         }\n@@ -181,7 +178,7 @@ public void testRestartAuditorBookieAfterCrashing() throws Exception {\n         BookieServer auditor = verifyAuditor();\n \n         shutdownBookie(auditor);\n-        String addr = StringUtils.addrToString(auditor.getLocalAddress());\n+        String addr = auditor.getLocalAddress().toString();\n \n         // restarting Bookie with same configurations.\n         int indexOfDownBookie = bs.indexOf(auditor);\n@@ -222,7 +219,7 @@ private void startAuditorElector(String addr) throws Exception {\n \n     private void startAuditorElectors() throws Exception {\n         for (BookieServer bserver : bs) {\n-            String addr = StringUtils.addrToString(bserver.getLocalAddress());\n+            String addr = bserver.getLocalAddress().toString();\n             startAuditorElector(addr);\n         }\n     }\n@@ -255,7 +252,7 @@ private BookieServer verifyAuditor() throws Exception {\n     }\n \n     private void shutdownBookie(BookieServer bkServer) throws Exception {\n-        String addr = StringUtils.addrToString(bkServer.getLocalAddress());\n+        String addr = bkServer.getLocalAddress().toString();\n         LOG.debug(\"Shutting down bookie:\" + addr);\n \n         // shutdown bookie which is an auditor"},{"sha":"42e0ebea8aa430a1fec159507d77649f67996f3c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -30,22 +30,21 @@\n import java.util.Map;\n import java.util.Random;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n@@ -111,7 +110,7 @@ public void tearDown() throws Exception {\n \n     private void startAuditorElectors() throws Exception {\n         for (BookieServer bserver : bs) {\n-            String addr = StringUtils.addrToString(bserver.getLocalAddress());\n+            String addr = bserver.getLocalAddress().toString();\n             AuditorElector auditorElector = new AuditorElector(addr,\n                     baseConf, zkc);\n             auditorElectors.put(addr, auditorElector);\n@@ -346,7 +345,7 @@ private void doLedgerRereplication(Long... ledgerIds)\n \n     private String shutdownBookie(int bkShutdownIndex) throws Exception {\n         BookieServer bkServer = bs.get(bkShutdownIndex);\n-        String bookieAddr = StringUtils.addrToString(bkServer.getLocalAddress());\n+        String bookieAddr = bkServer.getLocalAddress().toString();\n         LOG.debug(\"Shutting down bookie:\" + bookieAddr);\n         killBookie(bkShutdownIndex);\n         auditorElectors.get(bookieAddr).shutdown();"},{"sha":"3f8496fee3c1dd2f46f965ef0ebf1d66fafb6046","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","status":"modified","additions":15,"deletions":16,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,19 +20,6 @@\n  */\n package org.apache.bookkeeper.replication;\n \n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.FilenameFilter;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieAccessor;\n import org.apache.bookkeeper.bookie.IndexPersistenceMgr;\n@@ -44,7 +31,6 @@\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.zookeeper.ZooKeeper;\n@@ -54,6 +40,19 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n /**\n  * This test verifies that the period check on the auditor\n  * will pick up on missing data in the client\n@@ -81,7 +80,7 @@ public void setUp() throws Exception {\n             ServerConfiguration conf = new ServerConfiguration(bsConfs.get(i));\n             conf.setAuditorPeriodicCheckInterval(CHECK_INTERVAL);\n \n-            String addr = StringUtils.addrToString(bs.get(i).getLocalAddress());\n+            String addr = bs.get(i).getLocalAddress().toString();\n \n             ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(10000);\n             ZooKeeper zk = ZkUtils.createConnectedZookeeperClient(\n@@ -309,7 +308,7 @@ public void testPeriodicCheckWhenLedgerDeleted() throws Exception {\n             lh.close();\n         }\n         final Auditor auditor = new Auditor(\n-                StringUtils.addrToString(Bookie.getBookieAddress(bsConfs.get(0))),\n+                Bookie.getBookieAddress(bsConfs.get(0)).toString(),\n                 bsConfs.get(0), zkc);\n         final AtomicBoolean exceptionCaught = new AtomicBoolean(false);\n         final CountDownLatch latch = new CountDownLatch(1);"},{"sha":"b75c966b6a389a1f6bc0c5f31d023bc2a6e8649d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -20,7 +20,6 @@\n package org.apache.bookkeeper.replication;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.SortedMap;\n@@ -34,6 +33,7 @@\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n@@ -120,7 +120,7 @@ public void testOpenLedgers() throws Exception {\n         List<LedgerHandle> listOfLedgerHandle = createLedgersAndAddEntries(1, 5);\n         LedgerHandle lh = listOfLedgerHandle.get(0);\n         int ledgerReplicaIndex = 0;\n-        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKillAddr = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n \n         final String urLedgerZNode = getUrLedgerZNode(lh);\n@@ -169,7 +169,7 @@ public void testClosedLedgers() throws Exception {\n         closeLedgers(listOfLedgerHandle);\n         LedgerHandle lhandle = listOfLedgerHandle.get(0);\n         int ledgerReplicaIndex = 0;\n-        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKillAddr = LedgerHandleAdapter\n                 .getLedgerMetadata(lhandle).getEnsembles().get(0L).get(0);\n \n         CountDownLatch latch = new CountDownLatch(listOfLedgerHandle.size());\n@@ -231,7 +231,7 @@ public void testStopWhileReplicationInProgress() throws Exception {\n                 numberOfLedgers, 5);\n         closeLedgers(listOfLedgerHandle);\n         LedgerHandle handle = listOfLedgerHandle.get(0);\n-        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKillAddr = LedgerHandleAdapter\n                 .getLedgerMetadata(handle).getEnsembles().get(0L).get(0);\n         LOG.info(\"Killing Bookie:\" + replicaToKillAddr);\n \n@@ -310,7 +310,7 @@ public void testNoSuchLedgerExists() throws Exception {\n             assertNull(\"UrLedger already exists!\",\n                     watchUrLedgerNode(getUrLedgerZNode(lh), latch));\n         }\n-        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKillAddr = LedgerHandleAdapter\n                 .getLedgerMetadata(listOfLedgerHandle.get(0)).getEnsembles()\n                 .get(0L).get(0);\n         killBookie(replicaToKillAddr);\n@@ -343,11 +343,11 @@ public void testNoSuchLedgerExists() throws Exception {\n     }\n \n     private int getReplicaIndexInLedger(LedgerHandle lh,\n-            InetSocketAddress replicaToKill) {\n-        SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = LedgerHandleAdapter\n+ BookieSocketAddress replicaToKill) {\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles();\n         int ledgerReplicaIndex = -1;\n-        for (InetSocketAddress addr : ensembles.get(0L)) {\n+        for (BookieSocketAddress addr : ensembles.get(0L)) {\n             ++ledgerReplicaIndex;\n             if (addr.equals(replicaToKill)) {\n                 break;\n@@ -362,7 +362,7 @@ private void verifyLedgerEnsembleMetadataAfterReplication(\n         LedgerHandle openLedger = bkc\n                 .openLedger(lh.getId(), digestType, PASSWD);\n \n-        InetSocketAddress inetSocketAddress = LedgerHandleAdapter\n+        BookieSocketAddress inetSocketAddress = LedgerHandleAdapter\n                 .getLedgerMetadata(openLedger).getEnsembles().get(0L)\n                 .get(ledgerReplicaIndex);\n         assertEquals(\"Rereplication has been failed and ledgerReplicaIndex :\""},{"sha":"cb20de36cb8e66b2160d5f5884ad623fc06117fc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestAutoRecoveryAlongWithBookieServers.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,16 +21,16 @@\n package org.apache.bookkeeper.replication;\n \n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Enumeration;\n-import java.util.Set;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerHandleAdapter;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.junit.Test;\n@@ -59,13 +59,13 @@ public void testAutoRecoveryAlongWithBookieServers() throws Exception {\n             lh.addEntry(testData);\n         }\n         lh.close();\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n \n         killBookie(replicaToKill);\n \n         int startNewBookie = startNewBookie();\n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n \n         while (ReplicationTestUtil.isLedgerInUnderReplication(zkc, lh.getId(),\n@@ -74,11 +74,11 @@ public void testAutoRecoveryAlongWithBookieServers() throws Exception {\n         }\n \n         // Killing all bookies except newly replicated bookie\n-        Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = LedgerHandleAdapter\n+        Set<Entry<Long, ArrayList<BookieSocketAddress>>> entrySet = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().entrySet();\n-        for (Entry<Long, ArrayList<InetSocketAddress>> entry : entrySet) {\n-            ArrayList<InetSocketAddress> bookies = entry.getValue();\n-            for (InetSocketAddress bookie : bookies) {\n+        for (Entry<Long, ArrayList<BookieSocketAddress>> entry : entrySet) {\n+            ArrayList<BookieSocketAddress> bookies = entry.getValue();\n+            for (BookieSocketAddress bookie : bookies) {\n                 if (bookie.equals(newBkAddr)) {\n                     continue;\n                 }"},{"sha":"0555be7286e791eaa7777bb47e05709337b4e0e1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":50,"deletions":49,"changes":99,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -1,31 +1,24 @@\n /**\n- * Licensed to the Apache Software Foundation (ASF) under one \n- * or more contributor license agreements.  See the NOTICE file \n- * distributed with this work for additional information \n- * regarding copyright ownership.  The ASF licenses this file \n- * to you under the Apache License, Version 2.0 (the \n- * \"License\"); you may not use this file except in compliance \n- * with the License.  You may obtain a copy of the License at \n- * \n- *   http://www.apache.org/licenses/LICENSE-2.0 \n- * \n- * Unless required by applicable law or agreed to in writing, \n- * software distributed under the License is distributed on an \n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n- * KIND, either express or implied.  See the License for the \n- * specific language governing permissions and limitations \n- * under the License. \n- * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n  */\n package org.apache.bookkeeper.replication;\n \n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayList;\n-import java.util.Enumeration;\n-import java.util.Set;\n-import java.util.Map.Entry;\n-\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.ClientUtil;\n@@ -35,6 +28,7 @@\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n@@ -45,6 +39,12 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.InetAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n /**\n  * Test the ReplicationWroker, where it has to replicate the fragments from\n  * failed Bookies to given target Bookie.\n@@ -93,7 +93,7 @@ public void tearDown() throws Exception {\n             underReplicationManager = null;\n         }\n     }\n-    \n+\n     /**\n      * Tests that replication worker should replicate the failed bookie\n      * fragments to target bookie given to the worker.\n@@ -106,7 +106,7 @@ public void testRWShouldReplicateFragmentsToTargetBookie() throws Exception {\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKill);\n@@ -117,7 +117,7 @@ public void testRWShouldReplicateFragmentsToTargetBookie() throws Exception {\n             lh.addEntry(data);\n         }\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n@@ -157,13 +157,13 @@ public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication()\n             lh.addEntry(data);\n         }\n         lh.close();\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n         LOG.info(\"Killing Bookie\", replicaToKill);\n         ServerConfiguration killedBookieConfig = killBookie(replicaToKill);\n \n         int startNewBookie = startNewBookie();\n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n@@ -209,22 +209,22 @@ public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplicatio\n             lh.addEntry(data);\n         }\n         lh.close();\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n         LOG.info(\"Killing Bookie\", replicaToKill);\n         ServerConfiguration killedBookieConfig = killBookie(replicaToKill);\n \n         killAllBookies(lh, null);\n         // Starte RW1\n         int startNewBookie1 = startNewBookie();\n-        InetSocketAddress newBkAddr1 = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr1 = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie1);\n         LOG.info(\"New Bookie addr :\" + newBkAddr1);\n         ReplicationWorker rw1 = new ReplicationWorker(zkc, baseConf, newBkAddr1);\n \n         // Starte RW2\n         int startNewBookie2 = startNewBookie();\n-        InetSocketAddress newBkAddr2 = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr2 = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie2);\n         LOG.info(\"New Bookie addr :\" + newBkAddr2);\n         ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(10000);\n@@ -275,13 +275,13 @@ public void testRWShouldCleanTheLedgerFromUnderReplicationIfLedgerAlreadyDeleted\n             lh.addEntry(data);\n         }\n         lh.close();\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n         LOG.info(\"Killing Bookie\", replicaToKill);\n         killBookie(replicaToKill);\n \n         int startNewBookie = startNewBookie();\n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n         ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n@@ -312,7 +312,7 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n         for (int i = 0; i < 10; i++) {\n             lh1.addEntry(data);\n         }\n-        InetSocketAddress replicaToKillFromFirstLedger = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKillFromFirstLedger = LedgerHandleAdapter\n                 .getLedgerMetadata(lh1).getEnsembles().get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKillFromFirstLedger);\n@@ -324,7 +324,7 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n         for (int i = 0; i < 10; i++) {\n             lh2.addEntry(data);\n         }\n-        InetSocketAddress replicaToKillFromSecondLedger = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKillFromSecondLedger = LedgerHandleAdapter\n                 .getLedgerMetadata(lh2).getEnsembles().get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKillFromSecondLedger);\n@@ -338,7 +338,7 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n \n         int startNewBookie = startNewBookie();\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n@@ -373,7 +373,7 @@ public void testMultipleLedgerReplicationWithReplicationWorker()\n         }\n \n     }\n-    \n+\n     /**\n      * Tests that ReplicationWorker should fence the ledger and release ledger\n      * lock after timeout. Then replication should happen normally.\n@@ -387,15 +387,15 @@ public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsUR()\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKill);\n         killBookie(replicaToKill);\n \n         int startNewBookie = startNewBookie();\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n@@ -444,7 +444,7 @@ public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsNotUR()\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKill);\n@@ -458,7 +458,7 @@ public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsNotUR()\n             lh.addEntry(data);\n         }\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n@@ -506,7 +506,8 @@ public void testRWShutdownOnLocalBookieReadonlyTransition() throws Exception {\n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n         }\n-        InetSocketAddress replicaToKill = LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+        BookieSocketAddress replicaToKill =\n+                LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n \n         LOG.info(\"Killing Bookie\", replicaToKill);\n         killBookie(replicaToKill);\n@@ -516,7 +517,7 @@ public void testRWShutdownOnLocalBookieReadonlyTransition() throws Exception {\n             lh.addEntry(data);\n         }\n \n-        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBkPort);\n+        BookieSocketAddress newBkAddr = new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBkPort);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n         ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n@@ -569,14 +570,14 @@ public void testRWZKSessionLost() throws Exception {\n         }\n     }\n \n-    private void killAllBookies(LedgerHandle lh, InetSocketAddress excludeBK)\n+    private void killAllBookies(LedgerHandle lh, BookieSocketAddress excludeBK)\n             throws Exception {\n         // Killing all bookies except newly replicated bookie\n-        Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = LedgerHandleAdapter\n+        Set<Entry<Long, ArrayList<BookieSocketAddress>>> entrySet = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().entrySet();\n-        for (Entry<Long, ArrayList<InetSocketAddress>> entry : entrySet) {\n-            ArrayList<InetSocketAddress> bookies = entry.getValue();\n-            for (InetSocketAddress bookie : bookies) {\n+        for (Entry<Long, ArrayList<BookieSocketAddress>> entry : entrySet) {\n+            ArrayList<BookieSocketAddress> bookies = entry.getValue();\n+            for (BookieSocketAddress bookie : bookies) {\n                 if (bookie.equals(excludeBK)) {\n                     continue;\n                 }"},{"sha":"e6d98e616aafc64b57acd8b6d47e981875ed3335","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -24,7 +24,6 @@\n import java.io.File;\n import java.io.IOException;\n import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -42,6 +41,7 @@\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.metastore.InMemoryMetaStore;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n@@ -204,7 +204,7 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n     /**\n      * Get bookie address for bookie at index\n      */\n-    public InetSocketAddress getBookie(int index) throws Exception {\n+    public BookieSocketAddress getBookie(int index) throws Exception {\n         if (bs.size() <= index || index < 0) {\n             throw new IllegalArgumentException(\"Invalid index, there are only \" + bs.size()\n                                                + \" bookies. Asked for \" + index);\n@@ -221,7 +221,7 @@ public InetSocketAddress getBookie(int index) throws Exception {\n      * @return the configuration of killed bookie\n      * @throws InterruptedException\n      */\n-    public ServerConfiguration killBookie(InetSocketAddress addr) throws Exception {\n+    public ServerConfiguration killBookie(BookieSocketAddress addr) throws Exception {\n         BookieServer toRemove = null;\n         int toRemoveIndex = 0;\n         for (BookieServer server : bs) {\n@@ -272,7 +272,7 @@ public ServerConfiguration killBookie(int index) throws Exception {\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public CountDownLatch sleepBookie(InetSocketAddress addr, final int seconds)\n+    public CountDownLatch sleepBookie(BookieSocketAddress addr, final int seconds)\n             throws Exception {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {\n@@ -307,7 +307,7 @@ public void run() {\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public void sleepBookie(InetSocketAddress addr, final CountDownLatch l)\n+    public void sleepBookie(BookieSocketAddress addr, final CountDownLatch l)\n             throws Exception {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {"},{"sha":"bc05229e49834bcddef2873f5a9437fc54989db1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -22,7 +22,6 @@\n  */\n \n import java.io.File;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.concurrent.Executors;\n@@ -32,6 +31,7 @@\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookieProtocol;\n@@ -116,7 +116,7 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n     };\n \n     WriteCallback wrcb = new WriteCallback() {\n-        public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+        public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n             if (ctx != null) {\n                 synchronized (ctx) {\n                     ctx.notifyAll();\n@@ -130,7 +130,7 @@ public void testWriteGaps() throws Exception {\n         final Object notifyObject = new Object();\n         byte[] passwd = new byte[20];\n         Arrays.fill(passwd, (byte) 'a');\n-        InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", port);\n+        BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", port);\n         ResultStruct arc = new ResultStruct();\n \n         BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n@@ -233,7 +233,7 @@ private ChannelBuffer createByteBuffer(int i, long lid, long eid) {\n     @Test(timeout=60000)\n     public void testNoLedger() throws Exception {\n         ResultStruct arc = new ResultStruct();\n-        InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", port);\n+        BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", port);\n         BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n         synchronized (arc) {\n             bc.readEntry(addr, 2, 13, recb, arc);"},{"sha":"cd63b5a10d7ba8ca669e1a1b16d27682263e8934","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -23,7 +23,6 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -33,6 +32,7 @@\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.junit.After;\n@@ -158,7 +158,7 @@ private long doWrites(int ledgers, int size, int totalwrites)\n         WriteCallback cb = new WriteCallback() {\n             @Override\n             public void writeComplete(int rc, long ledgerId, long entryId,\n-            InetSocketAddress addr, Object ctx) {\n+                    BookieSocketAddress addr, Object ctx) {\n                 AtomicInteger counter = (AtomicInteger)ctx;\n                 counter.getAndIncrement();\n                 throttle.release();"},{"sha":"27c31d9e362db6aeb565373e040edcdb2047c648","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConditionalSetTest.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConditionalSetTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConditionalSetTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConditionalSetTest.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -18,12 +18,10 @@\n  * under the License.\n  *\n  */\n-\n package org.apache.bookkeeper.test;\n \n import java.io.File;\n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.Random;"},{"sha":"778a804822c7752764899b554c5bd8a8865ab4c8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -21,22 +21,21 @@\n  *\n  */\n \n-import java.net.InetSocketAddress;\n import java.io.IOException;\n-import java.lang.InterruptedException;\n import java.util.Arrays;\n import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * This class tests BookieClient. It just sends the a new entry to itself.\n@@ -73,7 +72,7 @@ synchronized void increment() {\n         this.begin = begin;\n     }\n \n-    void write(long ledgerId, long entry, byte[] data, InetSocketAddress addr, WriteCallback cb, Object ctx)\n+    void write(long ledgerId, long entry, byte[] data, BookieSocketAddress addr, WriteCallback cb, Object ctx)\n             throws IOException, InterruptedException {\n         LOG.info(\"Ledger id: \" + ledgerId + \", Entry: \" + entry);\n         byte[] passwd = new byte[20];\n@@ -82,7 +81,7 @@ void write(long ledgerId, long entry, byte[] data, InetSocketAddress addr, Write\n         client.addEntry(addr, ledgerId, passwd, entry, ChannelBuffers.wrappedBuffer(data), cb, ctx, BookieProtocol.FLAG_NONE);\n     }\n \n-    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+    public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n         Counter counter = (Counter) ctx;\n         counter.increment();\n     }\n@@ -99,7 +98,7 @@ public static void main(String args[]) {\n                 .newCachedThreadPool());\n         OrderedSafeExecutor executor = new OrderedSafeExecutor(2, \"BookieClientScheduler\");\n         try {\n-            InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", Integer.valueOf(args[2]).intValue());\n+            BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", Integer.valueOf(args[2]).intValue());\n             lb = new LoopbackClient(channelFactory, executor, begin, limit.intValue());\n \n             for (int i = 0; i < limit; i++) {"},{"sha":"8f47c2f59573d50b397bb7d5bc2eeb5e79b72b07","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/92a62781682721e7c6bb47a95c72029fb91d2e2f/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/92a62781682721e7c6bb47a95c72029fb91d2e2f/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java?ref=92a62781682721e7c6bb47a95c72029fb91d2e2f","patch":"@@ -17,12 +17,12 @@\n  */\n package org.apache.hedwig.server.benchmark;\n \n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.util.concurrent.Executors;\n import java.util.concurrent.Semaphore;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -39,7 +39,7 @@\n     static final Logger logger = LoggerFactory.getLogger(BookkeeperBenchmark.class);\n \n     BookieClient bkc;\n-    InetSocketAddress addr;\n+    BookieSocketAddress addr;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor = new OrderedSafeExecutor(1, \"BookieBenchmarkScheduler\");\n \n@@ -48,8 +48,7 @@ public BookieBenchmark(String bookieHostPort)  throws Exception {\n         channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());\n         bkc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n         String[] hostPort = bookieHostPort.split(\":\");\n-        addr = new InetSocketAddress(hostPort[0], Integer.parseInt(hostPort[1]));\n-\n+        addr = new BookieSocketAddress(hostPort[0], Integer.parseInt(hostPort[1]));\n     }\n \n \n@@ -64,7 +63,7 @@ void doOps(final int numOps) throws Exception {\n \n             @Override\n             public void writeComplete(int rc, long ledgerId, long entryId,\n-            InetSocketAddress addr, Object ctx) {\n+            BookieSocketAddress addr, Object ctx) {\n                 handler.handle(rc == BKException.Code.OK, ctx);\n             }\n         };"}]}

