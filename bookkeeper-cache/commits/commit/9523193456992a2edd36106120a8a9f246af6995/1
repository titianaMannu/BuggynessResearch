{"sha":"9523193456992a2edd36106120a8a9f246af6995","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5NTIzMTkzNDU2OTkyYTJlZGQzNjEwNjEyMGE4YTlmMjQ2YWY2OTk1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T18:08:01Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T18:08:01Z"},"message":"BOOKKEEPER-177: Index file is lost or some index pages aren't flushed. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1293369 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6a3d9916efc8f4d5f346df97493d096f206ac2c9","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6a3d9916efc8f4d5f346df97493d096f206ac2c9"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9523193456992a2edd36106120a8a9f246af6995","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9523193456992a2edd36106120a8a9f246af6995","html_url":"https://github.com/apache/bookkeeper/commit/9523193456992a2edd36106120a8a9f246af6995","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9523193456992a2edd36106120a8a9f246af6995/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"110d36673bcc393853aaab4bb423d785daa947c7","url":"https://api.github.com/repos/apache/bookkeeper/commits/110d36673bcc393853aaab4bb423d785daa947c7","html_url":"https://github.com/apache/bookkeeper/commit/110d36673bcc393853aaab4bb423d785daa947c7"}],"stats":{"total":408,"additions":314,"deletions":94},"files":[{"sha":"ed3427fdd32d82c6bf5797a0f7b3e8e7776b2206","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9523193456992a2edd36106120a8a9f246af6995/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/9523193456992a2edd36106120a8a9f246af6995/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=9523193456992a2edd36106120a8a9f246af6995","patch":"@@ -44,6 +44,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-174: Bookie can't start when replaying entries whose ledger were deleted and garbage collected. (sijie via ivank)\n \n+        BOOKKEEPER-177: Index file is lost or some index pages aren't flushed. (sijie via ivank)\n+\n       hedwig-server/\n       \n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)"},{"sha":"51195d4523e8f0592ae33c0a3c2e76f2e4012555","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":34,"deletions":23,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=9523193456992a2edd36106120a8a9f246af6995","patch":"@@ -197,42 +197,53 @@ public void run() {\n                 }\n \n                 lastLogMark.markLog();\n+\n+                boolean flushFailed = false;\n                 try {\n                     ledgerCache.flushLedger(true);\n                 } catch (IOException e) {\n                     LOG.error(\"Exception flushing Ledger\", e);\n+                    flushFailed = true;\n                 }\n                 try {\n                     entryLogger.flush();\n                 } catch (IOException e) {\n                     LOG.error(\"Exception flushing entry logger\", e);\n+                    flushFailed = true;\n                 }\n-                lastLogMark.rollLog();\n-\n-                // list the journals that have been marked\n-                List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n-                    @Override\n-                    public boolean accept(long journalId) {\n-                        if (journalId < lastLogMark.lastMark.txnLogId) {\n-                            return true;\n-                        } else {\n-                            return false;\n+\n+                // if flush failed, we should not roll last mark, otherwise we would\n+                // have some ledgers are not flushed and their journal entries were lost\n+                if (!flushFailed) {\n+\n+                    lastLogMark.rollLog();\n+\n+                    // list the journals that have been marked\n+                    List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n+                        @Override\n+                        public boolean accept(long journalId) {\n+                            if (journalId < lastLogMark.lastMark.txnLogId) {\n+                                return true;\n+                            } else {\n+                                return false;\n+                            }\n                         }\n-                    }\n-                });\n-\n-                // keep MAX_BACKUP_JOURNALS journal files before marked journal\n-                if (logs.size() >= maxBackupJournals) {\n-                    int maxIdx = logs.size() - maxBackupJournals;\n-                    for (int i=0; i<maxIdx; i++) {\n-                        long id = logs.get(i);\n-                        // make sure the journal id is smaller than marked journal id\n-                        if (id < lastLogMark.lastMark.txnLogId) {\n-                            File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n-                            journalFile.delete();\n-                            LOG.info(\"garbage collected journal \" + journalFile.getName());\n+                    });\n+\n+                    // keep MAX_BACKUP_JOURNALS journal files before marked journal\n+                    if (logs.size() >= maxBackupJournals) {\n+                        int maxIdx = logs.size() - maxBackupJournals;\n+                        for (int i=0; i<maxIdx; i++) {\n+                            long id = logs.get(i);\n+                            // make sure the journal id is smaller than marked journal id\n+                            if (id < lastLogMark.lastMark.txnLogId) {\n+                                File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n+                                journalFile.delete();\n+                                LOG.info(\"garbage collected journal \" + journalFile.getName());\n+                            }\n                         }\n                     }\n+\n                 }\n \n                 // clear flushing flag"},{"sha":"0c0cf8be29662a7a88b42a1330789e68aaf97d5b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":92,"deletions":71,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=9523193456992a2edd36106120a8a9f246af6995","patch":"@@ -183,11 +183,12 @@ public long getEntryOffset(long ledger, long entry) throws IOException {\n         try {\n             if (lep == null) {\n                 lep = grabCleanPage(ledger, pageEntry);\n+                // should update page before we put it into table\n+                // otherwise we would put an empty page in it\n+                updatePage(lep);\n                 synchronized(this) {\n                     putIntoTable(pages, lep);\n                 }\n-                updatePage(lep);\n-\n             }\n             return lep.getOffset(offsetInPage*8);\n         } finally {\n@@ -303,75 +304,9 @@ void flushLedger(boolean doAll) throws IOException {\n             }\n             while(!dirtyLedgers.isEmpty()) {\n                 Long l = dirtyLedgers.removeFirst();\n-                LinkedList<Long> firstEntryList;\n-                synchronized(this) {\n-                    HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n-                    if (pageMap == null || pageMap.isEmpty()) {\n-                        continue;\n-                    }\n-                    firstEntryList = new LinkedList<Long>();\n-                    for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n-                        LedgerEntryPage lep = entry.getValue();\n-                        if (lep.isClean()) {\n-                            if (LOG.isTraceEnabled()) {\n-                                LOG.trace(\"Page is clean \" + lep);\n-                            }\n-                            continue;\n-                        }\n-                        firstEntryList.add(lep.getFirstEntry());\n-                    }\n-                }\n-                // Now flush all the pages of a ledger\n-                List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n-                FileInfo fi = null;\n-                try {\n-                    for(Long firstEntry: firstEntryList) {\n-                        LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n-                        if (lep != null) {\n-                            entries.add(lep);\n-                        }\n-                    }\n-                    Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n-                        @Override\n-                        public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n-                            return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n-                        }\n-                    });\n-                    ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n-                    fi = getFileInfo(l, null);\n-                    int start = 0;\n-                    long lastOffset = -1;\n-                    for(int i = 0; i < entries.size(); i++) {\n-                        versions.add(i, entries.get(i).getVersion());\n-                        if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n-                            // send up a sequential list\n-                            int count = i - start;\n-                            if (count == 0) {\n-                                System.out.println(\"Count cannot possibly be zero!\");\n-                            }\n-                            writeBuffers(l, entries, fi, start, count);\n-                            start = i;\n-                        }\n-                        lastOffset = entries.get(i).getFirstEntry();\n-                    }\n-                    if (entries.size()-start == 0 && entries.size() != 0) {\n-                        System.out.println(\"Nothing to write, but there were entries!\");\n-                    }\n-                    writeBuffers(l, entries, fi, start, entries.size()-start);\n-                    synchronized(this) {\n-                        for(int i = 0; i < entries.size(); i++) {\n-                            LedgerEntryPage lep = entries.get(i);\n-                            lep.setClean(versions.get(i));\n-                        }\n-                    }\n-                } finally {\n-                    for(LedgerEntryPage lep: entries) {\n-                        lep.releasePage();\n-                    }\n-                    if (fi != null) {\n-                        fi.release();\n-                    }\n-                }\n+\n+                flushLedger(l);\n+\n                 if (!doAll) {\n                     break;\n                 }\n@@ -387,6 +322,92 @@ public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n         }\n     }\n \n+    /**\n+     * Flush a specified ledger\n+     *\n+     * @param l\n+     *          Ledger Id\n+     * @throws IOException\n+     */\n+    private void flushLedger(long l) throws IOException {\n+        LinkedList<Long> firstEntryList;\n+        synchronized(this) {\n+            HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n+            if (pageMap == null || pageMap.isEmpty()) {\n+                return;\n+            }\n+            firstEntryList = new LinkedList<Long>();\n+            for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n+                LedgerEntryPage lep = entry.getValue();\n+                if (lep.isClean()) {\n+                    if (LOG.isTraceEnabled()) {\n+                        LOG.trace(\"Page is clean \" + lep);\n+                    }\n+                    continue;\n+                }\n+                firstEntryList.add(lep.getFirstEntry());\n+            }\n+        }\n+\n+        if (firstEntryList.size() == 0) {\n+            LOG.debug(\"Nothing to flush for ledger {}.\", l);\n+            // nothing to do\n+            return;\n+        }\n+\n+        // Now flush all the pages of a ledger\n+        List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n+        FileInfo fi = null;\n+        try {\n+            for(Long firstEntry: firstEntryList) {\n+                LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n+                if (lep != null) {\n+                    entries.add(lep);\n+                }\n+            }\n+            Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n+                    @Override\n+                    public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n+                    return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n+                    }\n+                    });\n+            ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n+            fi = getFileInfo(l, null);\n+            int start = 0;\n+            long lastOffset = -1;\n+            for(int i = 0; i < entries.size(); i++) {\n+                versions.add(i, entries.get(i).getVersion());\n+                if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n+                    // send up a sequential list\n+                    int count = i - start;\n+                    if (count == 0) {\n+                        System.out.println(\"Count cannot possibly be zero!\");\n+                    }\n+                    writeBuffers(l, entries, fi, start, count);\n+                    start = i;\n+                }\n+                lastOffset = entries.get(i).getFirstEntry();\n+            }\n+            if (entries.size()-start == 0 && entries.size() != 0) {\n+                System.out.println(\"Nothing to write, but there were entries!\");\n+            }\n+            writeBuffers(l, entries, fi, start, entries.size()-start);\n+            synchronized(this) {\n+                for(int i = 0; i < entries.size(); i++) {\n+                    LedgerEntryPage lep = entries.get(i);\n+                    lep.setClean(versions.get(i));\n+                }\n+            }\n+        } finally {\n+            for(LedgerEntryPage lep: entries) {\n+                lep.releasePage();\n+            }\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n     private void writeBuffers(Long ledger,\n                               List<LedgerEntryPage> entries, FileInfo fi,\n                               int start, int count) throws IOException {"},{"sha":"87a1e66c870eec825d92541c5d18abe5ced8cb03","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=9523193456992a2edd36106120a8a9f246af6995","patch":"@@ -141,6 +141,12 @@ ByteBuffer readEntry(long entryId) throws IOException {\n             try {\n                 fi = ledgerCache.getFileInfo(ledgerId, null);\n                 long size = fi.size();\n+                // make sure the file size is aligned with index entry size\n+                // otherwise we may read incorret data\n+                if (0 != size % 8) {\n+                    LOG.warn(\"Index file of ledger {} is not aligned with index entry size.\", ledgerId);\n+                    size = size - size % 8;\n+                }\n                 // we may not have the last entry in the cache\n                 if (size > lastEntry*8) {\n                     ByteBuffer bb = ByteBuffer.allocate(ledgerCache.getPageSize());"},{"sha":"23a1ffc2bf8c68a8a17d9abb0062edbcb14d0728","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=9523193456992a2edd36106120a8a9f246af6995","patch":"@@ -167,6 +167,20 @@ public int getPageSize() {\n         return this.getInt(PAGE_SIZE, 8192);\n     }\n \n+    /**\n+     * Set page size\n+     *\n+     * @see #getPageSize()\n+     *\n+     * @param pageSize\n+     *          Page Size\n+     * @return Server Configuration\n+     */\n+    public ServerConfiguration setPageSize(int pageSize) {\n+        this.setProperty(PAGE_SIZE, pageSize);\n+        return this;\n+    }\n+\n     /**\n      * Max journal file size\n      *"},{"sha":"5dcb964b8250fd330b1fe22fc81f385f8dbba9eb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9523193456992a2edd36106120a8a9f246af6995/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java?ref=9523193456992a2edd36106120a8a9f246af6995","patch":"@@ -0,0 +1,166 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.util.Enumeration;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * This class tests that index corruption cases\n+ */\n+public class IndexCorruptionTest extends BaseTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(IndexCorruptionTest.class);\n+\n+    DigestType digestType;\n+\n+    int pageSize = 1024;\n+\n+    public IndexCorruptionTest(DigestType digestType) {\n+        super(1);\n+        this.digestType = digestType;\n+        baseConf.setPageSize(pageSize);\n+    }\n+\n+    private Thread findSyncThread() {\n+        int threadCount = Thread.activeCount();\n+        Thread[] allthreads = new Thread[Thread.activeCount()];\n+        Thread.enumerate(allthreads);\n+        for (Thread t : allthreads) {\n+            if (t.getName().equals(\"SyncThread\")) {\n+                return t;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Test\n+    public void testNoSuchLedger() throws Exception {\n+        LOG.debug(\"Testing NoSuchLedger\");\n+\n+        Thread syncThread = findSyncThread();\n+        assertNotNull(\"Not found SyncThread.\", syncThread);\n+\n+        syncThread.suspend();\n+        // Create a ledger\n+        LedgerHandle lh = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+\n+        // Close the ledger which cause a readEntry(0) call\n+        LedgerHandle newLh = bkc.openLedger(lh.getId(), digestType, \"\".getBytes());\n+\n+        // Create a new ledger to write entries\n+        String dummyMsg = \"NoSuchLedger\";\n+        int numMsgs = 3;\n+        LedgerHandle wlh = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+        for (int i=0; i<numMsgs; i++) {\n+            wlh.addEntry(dummyMsg.getBytes());\n+        }\n+\n+        syncThread.resume();\n+\n+        // trigger sync \n+        Thread.sleep(2 * baseConf.getFlushInterval());\n+\n+        // restart bookies\n+        restartBookies();\n+\n+        Enumeration<LedgerEntry> seq = wlh.readEntries(0, numMsgs - 1); \n+        assertTrue(\"Enumeration of ledger entries has no element\", seq.hasMoreElements() == true);\n+        int entryId = 0;\n+        while (seq.hasMoreElements()) {\n+            LedgerEntry e = seq.nextElement();\n+            assertEquals(entryId, e.getEntryId());\n+\n+            Assert.assertArrayEquals(dummyMsg.getBytes(), e.getEntry());\n+            ++entryId;\n+        }\n+        assertEquals(entryId, numMsgs);\n+    }\n+\n+    @Test\n+    public void testEmptyIndexPage() throws Exception {\n+        LOG.debug(\"Testing EmptyIndexPage\");\n+\n+        Thread syncThread = findSyncThread();\n+        assertNotNull(\"Not found SyncThread.\", syncThread);\n+\n+        syncThread.suspend();\n+\n+        // Create a ledger\n+        LedgerHandle lh1 = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+\n+        String dummyMsg = \"NoSuchLedger\";\n+\n+        // write two page entries to ledger 2\n+        int numMsgs = 2 * pageSize / 8;\n+        LedgerHandle lh2 = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+        for (int i=0; i<numMsgs; i++) {\n+            lh2.addEntry(dummyMsg.getBytes());\n+        }\n+\n+        syncThread.resume();\n+\n+        // trigger sync\n+        Thread.sleep(2 * baseConf.getFlushInterval());\n+\n+        syncThread.suspend();\n+\n+        // Close ledger 1 which cause a readEntry(0) call\n+        LedgerHandle newLh1 = bkc.openLedger(lh1.getId(), digestType, \"\".getBytes());\n+\n+        // write another 3 entries to ledger 2\n+        for (int i=0; i<3; i++) {\n+            lh2.addEntry(dummyMsg.getBytes());\n+        }\n+\n+        syncThread.resume();\n+\n+        // wait for sync again\n+        Thread.sleep(2 * baseConf.getFlushInterval());\n+    \n+        // restart bookies\n+        restartBookies();\n+\n+        numMsgs += 3;\n+        Enumeration<LedgerEntry> seq = lh2.readEntries(0, numMsgs - 1); \n+        assertTrue(\"Enumeration of ledger entries has no element\", seq.hasMoreElements() == true);\n+        int entryId = 0;\n+        while (seq.hasMoreElements()) {\n+            LedgerEntry e = seq.nextElement();\n+            assertEquals(entryId, e.getEntryId());\n+\n+            Assert.assertArrayEquals(dummyMsg.getBytes(), e.getEntry());\n+            ++entryId;\n+        }\n+        assertEquals(entryId, numMsgs);\n+    }\n+}"}]}

