{"sha":"96b5aa8e6463c36a0421e47f9892479aa63f885b","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5NmI1YWE4ZTY0NjNjMzZhMDQyMWU0N2Y5ODkyNDc5YWE2M2Y4ODVi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-12T17:55:26Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-12T17:55:26Z"},"message":"BOOKKEEPER-503: The test case of TestThrottlingDelivery#testServerSideThrottle failed sometimes (jiannan & sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1432485 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0ae8700d7a938c51e67e490dd84dac9b2bbbd86d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0ae8700d7a938c51e67e490dd84dac9b2bbbd86d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/96b5aa8e6463c36a0421e47f9892479aa63f885b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/96b5aa8e6463c36a0421e47f9892479aa63f885b","html_url":"https://github.com/apache/bookkeeper/commit/96b5aa8e6463c36a0421e47f9892479aa63f885b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/96b5aa8e6463c36a0421e47f9892479aa63f885b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"1374b7ad2738f6c52a2aed1d0ee4e412aa382086","url":"https://api.github.com/repos/apache/bookkeeper/commits/1374b7ad2738f6c52a2aed1d0ee4e412aa382086","html_url":"https://github.com/apache/bookkeeper/commit/1374b7ad2738f6c52a2aed1d0ee4e412aa382086"}],"stats":{"total":241,"additions":177,"deletions":64},"files":[{"sha":"23db8d1ac4273261863d5f53d451756b0d6f21ba","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/96b5aa8e6463c36a0421e47f9892479aa63f885b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/96b5aa8e6463c36a0421e47f9892479aa63f885b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=96b5aa8e6463c36a0421e47f9892479aa63f885b","patch":"@@ -238,6 +238,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-539: ClientNotSubscribedException & doesn't receive enough messages in TestThrottlingDelivery#testServerSideThrottle (sijie)\n \n+        BOOKKEEPER-503: The test case of TestThrottlingDelivery#testServerSideThrottle failed sometimes (jiannan & sijie via ivank)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-467: Allocate ports for testing dynamically (ivank)"},{"sha":"d6e4c6a667a4f8a801d3e31edd51f966ff552c31","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":39,"deletions":35,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/96b5aa8e6463c36a0421e47f9892479aa63f885b/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/96b5aa8e6463c36a0421e47f9892479aa63f885b/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=96b5aa8e6463c36a0421e47f9892479aa63f885b","patch":"@@ -483,22 +483,18 @@ public ByteString getTopic() {\n             return topic;\n         }\n \n-        public long getLastLocalSeqIdDelivered() {\n-            return lastLocalSeqIdDelivered;\n-        }\n-\n-        public long getLastScanErrorTime() {\n+        public synchronized long getLastScanErrorTime() {\n             return lastScanErrorTime;\n         }\n \n-        public void setLastScanErrorTime(long lastScanErrorTime) {\n+        public synchronized void setLastScanErrorTime(long lastScanErrorTime) {\n             this.lastScanErrorTime = lastScanErrorTime;\n         }\n \n         /**\n          * Clear the last scan error time so it could be retry immediately.\n          */\n-        protected void clearLastScanErrorTime() {\n+        protected synchronized void clearLastScanErrorTime() {\n             this.lastScanErrorTime = -1;\n         }\n \n@@ -511,7 +507,7 @@ protected boolean isConnected() {\n             }\n         }\n \n-        protected void messageConsumed(long newSeqIdConsumed) {\n+        protected synchronized void messageConsumed(long newSeqIdConsumed) {\n             if (newSeqIdConsumed <= lastSeqIdConsumedUtil) {\n                 return;\n             }\n@@ -563,20 +559,22 @@ private void doDeliverNextMessage() {\n                 return;\n             }\n \n-            // check whether we have delivered enough messages without receiving their consumes\n-            if (msgLimitExceeded()) {\n-                logger.info(\"Subscriber ({}) is throttled : last delivered {}, last consumed {}.\",\n-                            va(this, lastLocalSeqIdDelivered, lastSeqIdConsumedUtil));\n-                isThrottled = true;\n-                // do nothing, since the delivery process would be throttled.\n-                // After message consumed, it would be added back to retry queue.\n-                return;\n-            }\n+            synchronized (this) {\n+                // check whether we have delivered enough messages without receiving their consumes\n+                if (msgLimitExceeded()) {\n+                    logger.info(\"Subscriber ({}) is throttled : last delivered {}, last consumed {}.\",\n+                                va(this, lastLocalSeqIdDelivered, lastSeqIdConsumedUtil));\n+                    isThrottled = true;\n+                    // do nothing, since the delivery process would be throttled.\n+                    // After message consumed, it would be added back to retry queue.\n+                    return;\n+                }\n \n-            localSeqIdDeliveringNow = persistenceMgr.getSeqIdAfterSkipping(topic, lastLocalSeqIdDelivered, 1);\n+                localSeqIdDeliveringNow = persistenceMgr.getSeqIdAfterSkipping(topic, lastLocalSeqIdDelivered, 1);\n \n-            outstandingScanRequest = new ScanRequest(topic, localSeqIdDeliveringNow,\n-                    /* callback= */this, /* ctx= */null);\n+                outstandingScanRequest = new ScanRequest(topic, localSeqIdDeliveringNow,\n+                        /* callback= */this, /* ctx= */null);\n+            }\n \n             persistenceMgr.scanSingleMessage(outstandingScanRequest);\n         }\n@@ -665,24 +663,26 @@ public void sendingFinished() {\n                 return;\n             }\n \n-            lastLocalSeqIdDelivered = localSeqIdDeliveringNow;\n-\n-            if (lastLocalSeqIdDelivered > lastSeqIdCommunicatedExternally + SEQ_ID_SLACK) {\n-                // Note: The order of the next 2 statements is important. We should\n-                // submit a request to change our delivery pointer only *after* we\n-                // have actually changed it. Otherwise, there is a race condition\n-                // with removal of this channel, w.r.t, maintaining the deliveryPtrs\n-                // tree map.\n-                long prevId = lastSeqIdCommunicatedExternally;\n-                lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n-                moveDeliveryPtrForward(this, prevId, lastLocalSeqIdDelivered);\n+            synchronized (this) {\n+                lastLocalSeqIdDelivered = localSeqIdDeliveringNow;\n+\n+                if (lastLocalSeqIdDelivered > lastSeqIdCommunicatedExternally + SEQ_ID_SLACK) {\n+                    // Note: The order of the next 2 statements is important. We should\n+                    // submit a request to change our delivery pointer only *after* we\n+                    // have actually changed it. Otherwise, there is a race condition\n+                    // with removal of this channel, w.r.t, maintaining the deliveryPtrs\n+                    // tree map.\n+                    long prevId = lastSeqIdCommunicatedExternally;\n+                    lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n+                    moveDeliveryPtrForward(this, prevId, lastLocalSeqIdDelivered);\n+                }\n             }\n             // increment deliveried message\n             ServerStats.getInstance().incrementMessagesDelivered();\n             deliverNextMessage();\n         }\n \n-        public long getLastSeqIdCommunicatedExternally() {\n+        public synchronized long getLastSeqIdCommunicatedExternally() {\n             return lastSeqIdCommunicatedExternally;\n         }\n \n@@ -730,8 +730,10 @@ public void performRequest() {\n                 doStopServingSubscriber(prevSubscriber, se);\n             }\n \n-            lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n-            addDeliveryPtr(this, lastLocalSeqIdDelivered);\n+            synchronized (this) {\n+                lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n+                addDeliveryPtr(this, lastLocalSeqIdDelivered);\n+            }\n \n             deliverNextMessage();\n         };\n@@ -741,7 +743,9 @@ public String toString() {\n             StringBuilder sb = new StringBuilder();\n             sb.append(\"Topic: \");\n             sb.append(topic.toStringUtf8());\n-            sb.append(\"DeliveryPtr: \");\n+            sb.append(\"Subscriber: \");\n+            sb.append(subscriberId.toStringUtf8());\n+            sb.append(\", DeliveryPtr: \");\n             sb.append(lastLocalSeqIdDelivered);\n             return sb.toString();\n "},{"sha":"a2b5b279e5c7f5504ea26ab055dd7db854df5461","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","status":"modified","additions":127,"deletions":27,"changes":154,"blob_url":"https://github.com/apache/bookkeeper/blob/96b5aa8e6463c36a0421e47f9892479aa63f885b/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/96b5aa8e6463c36a0421e47f9892479aa63f885b/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java?ref=96b5aa8e6463c36a0421e47f9892479aa63f885b","patch":"@@ -17,41 +17,36 @@\n  */\n package org.apache.hedwig.server.delivery;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import org.junit.Test;\n-\n-import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.protobuf.ByteString;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.filter.PipelineFilter;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n-import org.apache.hedwig.filter.PipelineFilter;\n-import org.apache.hedwig.server.subscriptions.AllToAllTopologyFilter;\n-\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n-import org.apache.hedwig.exceptions.PubSubException;\n-\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.server.common.ServerConfiguration;\n-import org.apache.hedwig.util.Callback;\n-import org.apache.hedwig.server.persistence.StubPersistenceManager;\n-import org.apache.hedwig.server.persistence.PersistenceManager;\n import org.apache.hedwig.server.persistence.PersistRequest;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.persistence.StubPersistenceManager;\n+import org.apache.hedwig.server.subscriptions.AllToAllTopologyFilter;\n+import org.apache.hedwig.util.Callback;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n \n public class TestFIFODeliveryManager {\n     static Logger logger = LoggerFactory.getLogger(TestFIFODeliveryManager.class);\n@@ -133,7 +128,7 @@ public void testFIFODeliverySubCloseSubRace() throws Exception {\n         filter.addLast(new AllToAllTopologyFilter());\n         filter.initialize(conf.getConf());\n         filter.setSubscriptionPreferences(topic, subscriber, prefs);\n-        MessageSeqId startId = MessageSeqId.newBuilder().build();\n+        MessageSeqId startId = MessageSeqId.newBuilder().setLocalComponent(1).build();\n \n         CountDownLatch l = new CountDownLatch(1);\n         Message m = Message.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(1))).build();\n@@ -194,4 +189,109 @@ public void operationFailed(Object ctx, PubSubException exception) {\n         r = dep.getNextResponse();\n         assertNull(\"There should only be 2 responses\", r);\n     }\n+\n+    static class ExecutorDeliveryEndPoint implements DeliveryEndPoint {\n+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+        AtomicInteger numDelivered = new AtomicInteger();\n+        final DeliveryManager dm;\n+\n+        ExecutorDeliveryEndPoint(DeliveryManager dm) {\n+            this.dm = dm;\n+        }\n+\n+        public void send(final PubSubResponse response, final DeliveryCallback callback) {\n+            executor.submit(new Runnable() {\n+                    public void run() {\n+                        if (response.hasMessage()) {\n+                            MessageSeqId msgid = response.getMessage().getMsgId();\n+                            if ((msgid.getLocalComponent() % 2) == 1) {\n+                                dm.messageConsumed(response.getTopic(),\n+                                        response.getSubscriberId(),\n+                                        response.getMessage().getMsgId());\n+                            } else {\n+                                executor.schedule(new Runnable() {\n+                                        public void run() {\n+                                            dm.messageConsumed(response.getTopic(),\n+                                                    response.getSubscriberId(),\n+                                                    response.getMessage().getMsgId());\n+                                        }\n+                                    }, 1, TimeUnit.SECONDS);\n+                            }\n+                        }\n+                        numDelivered.incrementAndGet();\n+                        callback.sendingFinished();\n+                    }\n+                });\n+        }\n+\n+        public void close() {\n+            executor.shutdown();\n+        }\n+\n+        int getNumDelivered() {\n+            return numDelivered.get();\n+        }\n+    }\n+\n+    /**\n+     * Test throttle race issue cause by messageConsumed and doDeliverNextMessage\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-503}\n+     */\n+    @Test\n+    public void testFIFODeliveryThrottlingRace() throws Exception {\n+        final int numMessages = 20;\n+        final int throttleSize = 10;\n+        ServerConfiguration conf = new ServerConfiguration() {\n+                @Override\n+                public int getDefaultMessageWindowSize() {\n+                    return throttleSize;\n+                }\n+            };\n+        ByteString topic = ByteString.copyFromUtf8(\"throttlingRaceTopic\");\n+        ByteString subscriber = ByteString.copyFromUtf8(\"throttlingRaceSubscriber\");\n+\n+        PersistenceManager pm = new StubPersistenceManager();\n+        FIFODeliveryManager fdm = new FIFODeliveryManager(pm, conf);\n+        ExecutorDeliveryEndPoint dep = new ExecutorDeliveryEndPoint(fdm);\n+        SubscriptionPreferences prefs = SubscriptionPreferences.newBuilder().build();\n+\n+        PipelineFilter filter = new PipelineFilter();\n+        filter.addLast(new AllToAllTopologyFilter());\n+        filter.initialize(conf.getConf());\n+        filter.setSubscriptionPreferences(topic, subscriber, prefs);\n+\n+        CountDownLatch l = new CountDownLatch(numMessages);\n+\n+        TestCallback firstCallback = null;\n+        for (int i = 0; i < numMessages; i++) {\n+            Message m = Message.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(i))).build();\n+            TestCallback cb = new TestCallback(l);\n+            if (firstCallback == null) {\n+                firstCallback = cb;\n+            }\n+            pm.persistMessage(new PersistRequest(topic, m, cb, null));\n+        }\n+        fdm.start();\n+        assertTrue(\"Persistence never finished\", l.await(10, TimeUnit.SECONDS));\n+        fdm.startServingSubscription(topic, subscriber, prefs, firstCallback.getId(), dep, filter,\n+                new Callback<Void>() {\n+                     @Override\n+                     public void operationFinished(Object ctx, Void result) {\n+                     }\n+                     @Override\n+                     public void operationFailed(Object ctx, PubSubException exception) {\n+                         // would not happened\n+                     }\n+                }, null);\n+\n+        int count = 30; // wait for 30 seconds maximum\n+        while (dep.getNumDelivered() < numMessages) {\n+            Thread.sleep(1000);\n+            if (count-- == 0) {\n+                break;\n+            }\n+        }\n+        assertEquals(\"Should have delivered \" + numMessages, numMessages, dep.getNumDelivered());\n+    }\n+\n }"},{"sha":"827677f14094a13cb8a28bad559897e3e1adfbc0","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"modified","additions":9,"deletions":2,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/96b5aa8e6463c36a0421e47f9892479aa63f885b/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/96b5aa8e6463c36a0421e47f9892479aa63f885b/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=96b5aa8e6463c36a0421e47f9892479aa63f885b","patch":"@@ -88,9 +88,16 @@ public void scanSingleMessage(ScanRequest request) {\n             return;\n         }\n \n-        request.getCallback().messageScanned(request.getCtx(),\n-                                             messages.get(request.getTopic()).get((int) request.getStartSeqId()));\n+        long index = request.getStartSeqId() - 1;\n+        List<Message> messageList = messages.get(request.getTopic());\n+        if (index >= messageList.size()) {\n+            request.getCallback().scanFinished(request.getCtx(), ReasonForFinish.NO_MORE_MESSAGES);\n+            return;\n+        }\n \n+        Message msg = messageList.get((int) index);\n+        Message toDeliver = MessageIdUtils.mergeLocalSeqId(msg, request.getStartSeqId());\n+        request.getCallback().messageScanned(request.getCtx(), toDeliver);\n     }\n \n     public void scanMessages(RangeScanRequest request) {"}]}

