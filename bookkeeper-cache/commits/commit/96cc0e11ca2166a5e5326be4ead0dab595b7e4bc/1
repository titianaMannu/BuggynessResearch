{"sha":"96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5NmNjMGUxMWNhMjE2NmE1ZTUzMjZiZTRlYWQwZGFiNTk1YjdlNGJj","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-01-21T04:05:00Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-01-21T04:05:00Z"},"message":"BOOKKEEPER-429: Provide separate read and write threads in the bookkeeper server (Aniruddha via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1559917 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"71934c18ea057ace4ff08fcf22be27c0102dd78b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/71934c18ea057ace4ff08fcf22be27c0102dd78b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","html_url":"https://github.com/apache/bookkeeper/commit/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"78c0d2515f2e381b2c690bdbf2bf9bad03d1250c","url":"https://api.github.com/repos/apache/bookkeeper/commits/78c0d2515f2e381b2c690bdbf2bf9bad03d1250c","html_url":"https://github.com/apache/bookkeeper/commit/78c0d2515f2e381b2c690bdbf2bf9bad03d1250c"}],"stats":{"total":1032,"additions":791,"deletions":241},"files":[{"sha":"35a74aeca4eac6d44d9e7e699909e85f3b3fc092","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -138,6 +138,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-710: OpenLedgerNoRecovery should watch ensemble change. (sijie via ivank)\n \n+        BOOKKEEPER-429: Provide separate read and write threads in the bookkeeper server (Aniruddha via sijie)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"37f2b63393ac2a531897376d2caa03e40d13593d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -491,7 +491,8 @@ public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager) {\n         this.forceWriteThread = new ForceWriteThread(this, enableGroupForceWrites);\n         this.maxGroupWaitInMSec = conf.getJournalMaxGroupWaitMSec();\n         this.bufferedWritesThreshold = conf.getJournalBufferedWritesThreshold();\n-        this.cbThreadPool = Executors.newFixedThreadPool(conf.getNumAddWorkerThreads(), new DaemonThreadFactory());\n+        this.cbThreadPool = Executors.newFixedThreadPool(conf.getNumJournalCallbackThreads(),\n+                                                         new DaemonThreadFactory());\n \n         // Unless there is a cap on the max wait (which requires group force writes)\n         // we cannot skip flushing for queue empty"},{"sha":"8df226a286a54f0bf56600411bda2b4642279a73","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":63,"deletions":8,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -60,6 +60,7 @@\n     protected final static String JOURNAL_REMOVE_FROM_PAGE_CACHE = \"journalRemoveFromPageCache\";\n     protected final static String JOURNAL_PRE_ALLOC_SIZE = \"journalPreAllocSizeMB\";\n     protected final static String JOURNAL_WRITE_BUFFER_SIZE = \"journalWriteBufferSizeKB\";\n+    protected final static String NUM_JOURNAL_CALLBACK_THREADS = \"numJournalCallbackThreads\";\n     // Bookie Parameters\n     protected final static String BOOKIE_PORT = \"bookiePort\";\n     protected final static String LISTENING_INTERFACE = \"listeningInterface\";\n@@ -87,6 +88,7 @@\n \n     // Worker Thread parameters.\n     protected final static String NUM_ADD_WORKER_THREADS = \"numAddWorkerThreads\";\n+    protected final static String NUM_READ_WORKER_THREADS = \"numReadWorkerThreads\";\n \n     protected final static String READ_BUFFER_SIZE = \"readBufferSizeBytes\";\n     protected final static String WRITE_BUFFER_SIZE = \"writeBufferSizeBytes\";\n@@ -725,14 +727,6 @@ public long getOpenLedgerRereplicationGracePeriod() {\n         return getLong(OPEN_LEDGER_REREPLICATION_GRACE_PERIOD, 30000);\n     }\n \n-    /**\n-     * Get the number of threads that should handle write requests.\n-     * @return\n-     */\n-    public int getNumAddWorkerThreads() {\n-        return getInt(NUM_ADD_WORKER_THREADS, 1);\n-    }\n-\n     /**\n      * Get the number of bytes we should use as capacity for the {@link\n      * org.apache.bookkeeper.bookie.BufferedReadChannel}\n@@ -756,6 +750,46 @@ public ServerConfiguration setReadBufferBytes(int readBufferSize) {\n         return this;\n     }\n \n+    /**\n+     * Set the number of threads that would handle write requests.\n+     *\n+     * @param numThreads\n+     *          number of threads to handle write requests.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setNumAddWorkerThreads(int numThreads) {\n+        setProperty(NUM_ADD_WORKER_THREADS, numThreads);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of threads that should handle write requests.\n+     *\n+     * @return the number of threads that handle write requests.\n+     */\n+    public int getNumAddWorkerThreads() {\n+        return getInt(NUM_ADD_WORKER_THREADS, 1);\n+    }\n+\n+    /**\n+     * Set the number of threads that would handle read requests.\n+     *\n+     * @param numThreads\n+     *          Number of threads to handle read requests.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setNumReadWorkerThreads(int numThreads) {\n+        setProperty(NUM_READ_WORKER_THREADS, numThreads);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of threads that should handle read requests.\n+     */\n+    public int getNumReadWorkerThreads() {\n+        return getInt(NUM_READ_WORKER_THREADS, 8);\n+    }\n+\n     /**\n      * Get the number of bytes used as capacity for the write buffer. Default is\n      * 64KB.\n@@ -778,6 +812,27 @@ public ServerConfiguration setWriteBufferBytes(int writeBufferBytes) {\n         return this;\n     }\n \n+    /**\n+     * Set the number of threads that would handle journal callbacks.\n+     *\n+     * @param numThreads\n+     *          number of threads to handle journal callbacks.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setNumJournalCallbackThreads(int numThreads) {\n+        setProperty(NUM_JOURNAL_CALLBACK_THREADS, numThreads);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of threads that should handle journal callbacks.\n+     *\n+     * @return the number of threads that handle journal callbacks.\n+     */\n+    public int getNumJournalCallbackThreads() {\n+        return getInt(NUM_JOURNAL_CALLBACK_THREADS, 1);\n+    }\n+\n \n     /**\n      * Should we group journal force writes"},{"sha":"241f369af08d7024cc2328012cfb038fbbc5bcfe","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -0,0 +1,43 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.processor;\n+\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.jboss.netty.channel.Channel;\n+\n+public interface RequestProcessor {\n+\n+    /**\n+     * Close the request processor.\n+     */\n+    public void close();\n+\n+    /**\n+     * Process request.\n+     *\n+     * @param r\n+     *          request to process\n+     * @param channel\n+     *          channel received the given request <i>r</i>\n+     */\n+    public void processRequest(BookieProtocol.Request r, Channel channel);\n+\n+}"},{"sha":"7627e4049c31de6a6e6b8d8c4986611a67973c01","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":6,"deletions":4,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -28,6 +28,7 @@\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.processor.RequestProcessor;\n import org.apache.zookeeper.KeeperException;\n import org.jboss.netty.bootstrap.ServerBootstrap;\n import org.jboss.netty.channel.Channel;\n@@ -59,16 +60,16 @@\n     final static int maxMessageSize = 0xfffff;\n     final ServerConfiguration conf;\n     final ChannelFactory serverChannelFactory;\n-    final Bookie bookie;\n+    final RequestProcessor requestProcessor;\n     final ChannelGroup allChannels = new CleanupChannelGroup();\n     final AtomicBoolean isRunning = new AtomicBoolean(false);\n     Object suspensionLock = new Object();\n     boolean suspended = false;\n \n-    BookieNettyServer(ServerConfiguration conf, Bookie bookie)\n+    BookieNettyServer(ServerConfiguration conf, RequestProcessor processor)\n             throws IOException, KeeperException, InterruptedException, BookieException  {\n         this.conf = conf;\n-        this.bookie = bookie;\n+        this.requestProcessor = processor;\n \n         ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n         String base = \"bookie-\" + conf.getBookiePort() + \"-netty\";\n@@ -141,7 +142,8 @@ public ChannelPipeline getPipeline() throws Exception {\n \n             pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.RequestDecoder());\n             pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.ResponseEncoder());\n-            SimpleChannelHandler requestHandler = isRunning.get() ? new BookieRequestHandler(conf, bookie, allChannels)\n+            SimpleChannelHandler requestHandler = isRunning.get() ?\n+                    new BookieRequestHandler(conf, requestProcessor, allChannels)\n                     : new RejectRequestHandler();\n             pipeline.addLast(\"bookieRequestHandler\", requestHandler);\n             return pipeline;"},{"sha":"4a877222840b7cd2e8ee4c85249bf61ff4512fac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"modified","additions":6,"deletions":225,"changes":231,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -20,49 +20,31 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.nio.ByteBuffer;\n import java.nio.channels.ClosedChannelException;\n-\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.bookie.BookieException;\n-\n+import org.apache.bookkeeper.processor.RequestProcessor;\n import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelHandlerContext;\n import org.jboss.netty.channel.ChannelStateEvent;\n import org.jboss.netty.channel.ExceptionEvent;\n import org.jboss.netty.channel.MessageEvent;\n import org.jboss.netty.channel.SimpleChannelHandler;\n import org.jboss.netty.channel.group.ChannelGroup;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  * Serverside handler for bookkeeper requests\n  */\n-class BookieRequestHandler extends SimpleChannelHandler\n-    implements BookkeeperInternalCallbacks.WriteCallback {\n+class BookieRequestHandler extends SimpleChannelHandler {\n \n     private final static Logger LOG = LoggerFactory.getLogger(BookieRequestHandler.class);\n-    private final Bookie bookie;\n+    private final RequestProcessor requestProcessor;\n     private final ChannelGroup allChannels;\n \n-    private final BKStats bkStats = BKStats.getInstance();\n-    private final boolean statsEnabled;\n-\n-    BookieRequestHandler(ServerConfiguration conf, Bookie bookie, ChannelGroup allChannels) {\n-        this.bookie = bookie;\n+    BookieRequestHandler(ServerConfiguration conf, RequestProcessor processor, ChannelGroup allChannels) {\n+        this.requestProcessor = processor;\n         this.allChannels = allChannels;\n-        this.statsEnabled = conf.isStatisticsEnabled();\n     }\n \n     @Override\n@@ -100,210 +82,9 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n             return;\n         }\n         BookieProtocol.Request r = (BookieProtocol.Request)e.getMessage();\n-\n         Channel c = ctx.getChannel();\n-\n-        if (r.getProtocolVersion() < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n-            || r.getProtocolVersion() > BookieProtocol.CURRENT_PROTOCOL_VERSION) {\n-            LOG.error(\"Invalid protocol version, expected something between \"\n-                      + BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n-                      + \" & \" + BookieProtocol.CURRENT_PROTOCOL_VERSION\n-                      + \". got \" + r.getProtocolVersion());\n-            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, r));\n-            return;\n-        }\n-\n-        switch (r.getOpCode()) {\n-        case BookieProtocol.ADDENTRY:\n-            handleAdd(r, c);\n-            break;\n-        case BookieProtocol.READENTRY:\n-            handleRead(r, c);\n-            break;\n-        default:\n-            LOG.error(\"Unknown op type {}, sending error\", r.getOpCode());\n-            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n-            }\n-            break;\n-        }\n-    }\n-\n-    class AddCtx {\n-        final Channel c;\n-        final BookieProtocol.AddRequest r;\n-        final long startTime;\n-\n-        AddCtx(Channel c, BookieProtocol.AddRequest r) {\n-            this.c = c;\n-            this.r = r;\n-\n-            if (statsEnabled) {\n-                startTime = MathUtils.now();\n-            } else {\n-                startTime = 0;\n-            }\n-        }\n-    }\n-\n-    private void handleAdd(BookieProtocol.Request r, Channel c) {\n-        assert (r instanceof BookieProtocol.AddRequest);\n-        BookieProtocol.AddRequest add = (BookieProtocol.AddRequest)r;\n-\n-        if (bookie.isReadOnly()) {\n-            LOG.warn(\"BookieServer is running as readonly mode,\"\n-                     + \" so rejecting the request from the client!\");\n-            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n-            }\n-            return;\n-        }\n-\n-        int rc = BookieProtocol.EOK;\n-        try {\n-            if (add.isRecoveryAdd()) {\n-                bookie.recoveryAddEntry(add.getDataAsByteBuffer(), this, new AddCtx(c, add),\n-                                        add.getMasterKey());\n-            } else {\n-                bookie.addEntry(add.getDataAsByteBuffer(),\n-                                this, new AddCtx(c, add), add.getMasterKey());\n-            }\n-        } catch (IOException e) {\n-            LOG.error(\"Error writing \" + add, e);\n-            rc = BookieProtocol.EIO;\n-        } catch (BookieException.LedgerFencedException lfe) {\n-            LOG.error(\"Attempt to write to fenced ledger\", lfe);\n-            rc = BookieProtocol.EFENCED;\n-        } catch (BookieException e) {\n-            LOG.error(\"Unauthorized access to ledger \" + add.getLedgerId(), e);\n-            rc = BookieProtocol.EUA;\n-        }\n-        if (rc != BookieProtocol.EOK) {\n-            c.write(ResponseBuilder.buildErrorResponse(rc, add));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void writeComplete(int rc, long ledgerId, long entryId,\n-                              InetSocketAddress addr, Object ctx) {\n-        assert(ctx instanceof AddCtx);\n-        AddCtx addctx = (AddCtx)ctx;\n-        addctx.c.write(ResponseBuilder.buildAddResponse(addctx.r));\n-\n-        if (statsEnabled) {\n-            // compute the latency\n-            if (0 == rc) {\n-                // for add operations, we compute latency in writeComplete callbacks.\n-                long elapsedTime = MathUtils.now() - addctx.startTime;\n-                bkStats.getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n-            } else {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n-            }\n-        }\n+        requestProcessor.processRequest(r, c);\n     }\n \n-    private void handleRead(BookieProtocol.Request r, Channel c) {\n-        assert (r instanceof BookieProtocol.ReadRequest);\n-        BookieProtocol.ReadRequest read = (BookieProtocol.ReadRequest)r;\n \n-        LOG.debug(\"Received new read request: {}\", r);\n-        int errorCode = BookieProtocol.EIO;\n-        long startTime = 0;\n-        if (statsEnabled) {\n-            startTime = MathUtils.now();\n-        }\n-        ByteBuffer data = null;\n-        try {\n-            Future<Boolean> fenceResult = null;\n-            if (read.isFencingRequest()) {\n-                LOG.warn(\"Ledger \" + r.getLedgerId() + \" fenced by \" + c.getRemoteAddress());\n-\n-                if (read.hasMasterKey()) {\n-                    fenceResult = bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n-                } else {\n-                    LOG.error(\"Password not provided, Not safe to fence {}\", read.getLedgerId());\n-                    if (statsEnabled) {\n-                        bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n-                    }\n-                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n-                }\n-            }\n-            data = bookie.readEntry(r.getLedgerId(), r.getEntryId());\n-            LOG.debug(\"##### Read entry ##### {}\", data.remaining());\n-            if (null != fenceResult) {\n-                // TODO:\n-                // currently we don't have readCallback to run in separated read\n-                // threads. after BOOKKEEPER-429 is complete, we could improve\n-                // following code to make it not wait here\n-                //\n-                // For now, since we only try to wait after read entry. so writing\n-                // to journal and read entry are executed in different thread\n-                // it would be fine.\n-                try {\n-                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n-                    if (null == fenced || !fenced) {\n-                        // if failed to fence, fail the read request to make it retry.\n-                        errorCode = BookieProtocol.EIO;\n-                        data = null;\n-                    } else {\n-                        errorCode = BookieProtocol.EOK;\n-                    }\n-                } catch (InterruptedException ie) {\n-                    LOG.error(\"Interrupting fence read entry \" + read, ie);\n-                    errorCode = BookieProtocol.EIO;\n-                    data = null;\n-                } catch (ExecutionException ee) {\n-                    LOG.error(\"Failed to fence read entry \" + read, ee);\n-                    errorCode = BookieProtocol.EIO;\n-                    data = null;\n-                } catch (TimeoutException te) {\n-                    LOG.error(\"Timeout to fence read entry \" + read, te);\n-                    errorCode = BookieProtocol.EIO;\n-                    data = null;\n-                }\n-            } else {\n-                errorCode = BookieProtocol.EOK;\n-            }\n-        } catch (Bookie.NoLedgerException e) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.error(\"Error reading \" + read, e);\n-            }\n-            errorCode = BookieProtocol.ENOLEDGER;\n-        } catch (Bookie.NoEntryException e) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.error(\"Error reading \" + read, e);\n-            }\n-            errorCode = BookieProtocol.ENOENTRY;\n-        } catch (IOException e) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.error(\"Error reading \" + read, e);\n-            }\n-            errorCode = BookieProtocol.EIO;\n-        } catch (BookieException e) {\n-            LOG.error(\"Unauthorized access to ledger \" + read.getLedgerId(), e);\n-            errorCode = BookieProtocol.EUA;\n-        }\n-\n-        LOG.trace(\"Read entry rc = {} for {}\",\n-                  new Object[] { errorCode, read});\n-        if (errorCode == BookieProtocol.EOK) {\n-            assert data != null;\n-\n-            c.write(ResponseBuilder.buildReadResponse(data, read));\n-            if (statsEnabled) {\n-                long elapsedTime = MathUtils.now() - startTime;\n-                bkStats.getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n-            }\n-        } else {\n-            c.write(ResponseBuilder.buildErrorResponse(errorCode, read));\n-           if (statsEnabled) {\n-               bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n-           }\n-        }\n-    }\n }"},{"sha":"3a8d4bfa04a727aab371000c708355b0d1ade794","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"added","additions":335,"deletions":0,"changes":335,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -0,0 +1,335 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.processor.RequestProcessor;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BookieRequestProcessor implements RequestProcessor, BookkeeperInternalCallbacks.WriteCallback {\n+\n+    private final static Logger LOG = LoggerFactory.getLogger(BookieRequestProcessor.class);\n+    /**\n+     * The server configuration. We use this for getting the number of add and read\n+     * worker threads.\n+     */\n+    private ServerConfiguration serverCfg;\n+\n+    /**\n+     * This is the Bookie instance that is used to handle all read and write requests.\n+     */\n+    private Bookie bookie;\n+\n+    /**\n+     * The threadpool used to execute all read entry requests issued to this server.\n+     */\n+    private final ExecutorService readThreadPool;\n+\n+    /**\n+     * The threadpool used to execute all add entry requests issued to this server.\n+     */\n+    private final ExecutorService writeThreadPool;\n+\n+    private final BKStats bkStats = BKStats.getInstance();\n+    private final boolean statsEnabled;\n+\n+    public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie) {\n+        this.serverCfg = serverCfg;\n+        this.bookie = bookie;\n+        this.readThreadPool =\n+            createExecutor(this.serverCfg.getNumReadWorkerThreads(),\n+                           \"BookieWriteThread-\" + serverCfg.getBookiePort() + \"-%d\");\n+        this.writeThreadPool =\n+            createExecutor(this.serverCfg.getNumAddWorkerThreads(),\n+                           \"BookieReadThread-\" + serverCfg.getBookiePort() + \"-%d\");\n+        this.statsEnabled = serverCfg.isStatisticsEnabled();\n+    }\n+\n+    @Override\n+    public void close() {\n+        shutdownExecutor(writeThreadPool);\n+        shutdownExecutor(readThreadPool);\n+    }\n+\n+    private ExecutorService createExecutor(int numThreads, String nameFormat) {\n+        if (numThreads <= 0) {\n+            return null;\n+        } else {\n+            return Executors.newFixedThreadPool(numThreads,\n+                new ThreadFactoryBuilder().setNameFormat(nameFormat).build());\n+        }\n+    }\n+\n+    private void shutdownExecutor(ExecutorService service) {\n+        if (null != service) {\n+            service.shutdown();\n+        }\n+    }\n+\n+    @Override\n+    public void processRequest(BookieProtocol.Request r, Channel c) {\n+        if (r.getProtocolVersion() < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n+                        || r.getProtocolVersion() > BookieProtocol.CURRENT_PROTOCOL_VERSION) {\n+            LOG.error(\"Invalid protocol version, expected something between \"\n+                            + BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n+                            + \" & \" + BookieProtocol.CURRENT_PROTOCOL_VERSION\n+                            + \". got \" + r.getProtocolVersion());\n+            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, r));\n+            return;\n+        }\n+\n+        switch (r.getOpCode()) {\n+        case BookieProtocol.ADDENTRY:\n+            processAddRequest(r, c);\n+            break;\n+        case BookieProtocol.READENTRY:\n+            processReadRequest(r, c);\n+            break;\n+        default:\n+            LOG.error(\"Unknown op type {}, sending error\", r.getOpCode());\n+            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n+            }\n+            break;\n+        }\n+    }\n+\n+    class AddCtx {\n+        final Channel c;\n+        final BookieProtocol.AddRequest r;\n+        final long startTime;\n+\n+        AddCtx(Channel c, BookieProtocol.AddRequest r) {\n+            this.c = c;\n+            this.r = r;\n+\n+            if (statsEnabled) {\n+                startTime = MathUtils.now();\n+            } else {\n+                startTime = 0;\n+            }\n+        }\n+    }\n+\n+    private void processAddRequest(final BookieProtocol.Request r, final Channel c) {\n+        if (null == writeThreadPool) {\n+            handleAdd(r, c);\n+        } else {\n+            writeThreadPool.submit(new Runnable() {\n+                @Override\n+                public void run() {\n+                    handleAdd(r, c);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void handleAdd(BookieProtocol.Request r, Channel c) {\n+        assert (r instanceof BookieProtocol.AddRequest);\n+        BookieProtocol.AddRequest add = (BookieProtocol.AddRequest) r;\n+\n+        if (bookie.isReadOnly()) {\n+            LOG.warn(\"BookieServer is running as readonly mode,\"\n+                            + \" so rejecting the request from the client!\");\n+            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            }\n+            return;\n+        }\n+\n+        int rc = BookieProtocol.EOK;\n+        try {\n+            if (add.isRecoveryAdd()) {\n+                bookie.recoveryAddEntry(add.getDataAsByteBuffer(), this, new AddCtx(c, add),\n+                                add.getMasterKey());\n+            } else {\n+                bookie.addEntry(add.getDataAsByteBuffer(),\n+                                this, new AddCtx(c, add), add.getMasterKey());\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Error writing \" + add, e);\n+            rc = BookieProtocol.EIO;\n+        } catch (BookieException.LedgerFencedException lfe) {\n+            LOG.error(\"Attempt to write to fenced ledger\", lfe);\n+            rc = BookieProtocol.EFENCED;\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger \" + add.getLedgerId(), e);\n+            rc = BookieProtocol.EUA;\n+        }\n+        if (rc != BookieProtocol.EOK) {\n+            c.write(ResponseBuilder.buildErrorResponse(rc, add));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void writeComplete(int rc, long ledgerId, long entryId,\n+                    InetSocketAddress addr, Object ctx) {\n+        assert (ctx instanceof AddCtx);\n+        AddCtx addctx = (AddCtx) ctx;\n+        addctx.c.write(ResponseBuilder.buildAddResponse(addctx.r));\n+\n+        if (statsEnabled) {\n+            // compute the latency\n+            if (0 == rc) {\n+                // for add operations, we compute latency in writeComplete callbacks.\n+                long elapsedTime = MathUtils.now() - addctx.startTime;\n+                bkStats.getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n+            } else {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            }\n+        }\n+    }\n+\n+    private void processReadRequest(final BookieProtocol.Request r, final Channel c) {\n+        if (null == readThreadPool) {\n+            handleRead(r, c);\n+        } else {\n+            readThreadPool.submit(new Runnable() {\n+                @Override\n+                public void run() {\n+                    handleRead(r, c);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void handleRead(BookieProtocol.Request r, Channel c) {\n+        assert (r instanceof BookieProtocol.ReadRequest);\n+        BookieProtocol.ReadRequest read = (BookieProtocol.ReadRequest) r;\n+\n+        LOG.debug(\"Received new read request: {}\", r);\n+        int errorCode = BookieProtocol.EIO;\n+        long startTime = 0;\n+        if (statsEnabled) {\n+            startTime = MathUtils.now();\n+        }\n+        ByteBuffer data = null;\n+        try {\n+            Future<Boolean> fenceResult = null;\n+            if (read.isFencingRequest()) {\n+                LOG.warn(\"Ledger \" + r.getLedgerId() + \" fenced by \" + c.getRemoteAddress());\n+\n+                if (read.hasMasterKey()) {\n+                    fenceResult = bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n+                } else {\n+                    LOG.error(\"Password not provided, Not safe to fence {}\", read.getLedgerId());\n+                    if (statsEnabled) {\n+                        bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+                    }\n+                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+                }\n+            }\n+            data = bookie.readEntry(r.getLedgerId(), r.getEntryId());\n+            LOG.debug(\"##### Read entry ##### {}\", data.remaining());\n+            if (null != fenceResult) {\n+                // TODO:\n+                // currently we don't have readCallback to run in separated read\n+                // threads. after BOOKKEEPER-429 is complete, we could improve\n+                // following code to make it not wait here\n+                //\n+                // For now, since we only try to wait after read entry. so writing\n+                // to journal and read entry are executed in different thread\n+                // it would be fine.\n+                try {\n+                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n+                    if (null == fenced || !fenced) {\n+                        // if failed to fence, fail the read request to make it retry.\n+                        errorCode = BookieProtocol.EIO;\n+                        data = null;\n+                    } else {\n+                        errorCode = BookieProtocol.EOK;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupting fence read entry \" + read, ie);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                } catch (ExecutionException ee) {\n+                    LOG.error(\"Failed to fence read entry \" + read, ee);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                } catch (TimeoutException te) {\n+                    LOG.error(\"Timeout to fence read entry \" + read, te);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                }\n+            } else {\n+                errorCode = BookieProtocol.EOK;\n+            }\n+        } catch (Bookie.NoLedgerException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.ENOLEDGER;\n+        } catch (Bookie.NoEntryException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.ENOENTRY;\n+        } catch (IOException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.EIO;\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger \" + read.getLedgerId(), e);\n+            errorCode = BookieProtocol.EUA;\n+        }\n+\n+        LOG.trace(\"Read entry rc = {} for {}\",\n+                        new Object[] { errorCode, read });\n+        if (errorCode == BookieProtocol.EOK) {\n+            assert data != null;\n+\n+            c.write(ResponseBuilder.buildReadResponse(data, read));\n+            if (statsEnabled) {\n+                long elapsedTime = MathUtils.now() - startTime;\n+                bkStats.getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n+            }\n+        } else {\n+            c.write(ResponseBuilder.buildErrorResponse(errorCode, read));\n+            if (statsEnabled) {\n+                bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"ceafb4910383b5cae54ad17140331c271c1c474a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -34,6 +34,7 @@\n import org.apache.bookkeeper.bookie.ExitCode;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n+import org.apache.bookkeeper.processor.RequestProcessor;\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n@@ -69,12 +70,16 @@\n     AutoRecoveryMain autoRecoveryMain = null;\n     private boolean isAutoRecoveryDaemonEnabled;\n \n+    // request processor\n+    private final RequestProcessor requestProcessor;\n+\n     public BookieServer(ServerConfiguration conf) throws IOException,\n             KeeperException, InterruptedException, BookieException,\n             UnavailableException, CompatibilityException {\n         this.conf = conf;\n         this.bookie = newBookie(conf);\n-        this.nettyServer = new BookieNettyServer(this.conf, this.bookie);\n+        this.requestProcessor = new BookieRequestProcessor(conf, bookie);\n+        this.nettyServer = new BookieNettyServer(this.conf, requestProcessor);\n         isAutoRecoveryDaemonEnabled = conf.isAutoRecoveryDaemonEnabled();\n         if (isAutoRecoveryDaemonEnabled) {\n             this.autoRecoveryMain = new AutoRecoveryMain(conf);\n@@ -144,6 +149,7 @@ public synchronized void shutdown() {\n         if (isAutoRecoveryDaemonEnabled && this.autoRecoveryMain != null) {\n             this.autoRecoveryMain.shutdown();\n         }\n+        this.requestProcessor.close();\n         running = false;\n \n         // unregister JMX"},{"sha":"d7e53023eb2fb5eab4224d2e37d057ab9a093c3d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -44,6 +44,8 @@\n \n     public SlowBookieTest() {\n         super(4);\n+        baseConf.setNumAddWorkerThreads(0);\n+        baseConf.setNumReadWorkerThreads(0);\n     }\n \n     @Test(timeout=60000)"},{"sha":"123b1bfe077bba2abf32a05075c3abac7685691a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -184,8 +184,7 @@ public void testStreamingClients() throws IOException, BKException, InterruptedE\n         lh.close();\n     }\n \n-    @Test(timeout=60000)\n-    public void testReadWriteAsyncSingleClient() throws IOException {\n+    private void testReadWriteAsyncSingleClient(int numEntries) throws IOException {\n         SyncObj sync = new SyncObj();\n         try {\n             // Create a ledger\n@@ -265,6 +264,11 @@ public void testReadWriteAsyncSingleClient() throws IOException {\n         }\n     }\n \n+    @Test\n+    public void testReadWriteAsyncSingleClient200() throws IOException {\n+        testReadWriteAsyncSingleClient(200);\n+    }\n+\n     /**\n      * Check that the add api with offset and length work correctly.\n      * First try varying the offset. Then the length with a fixed non-zero"},{"sha":"559e8de41538b4c720e5def01ea6d2c3a39b5a1a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java","status":"added","additions":319,"deletions":0,"changes":319,"blob_url":"https://github.com/apache/bookkeeper/blob/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/96cc0e11ca2166a5e5326be4ead0dab595b7e4bc/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultipleThreadReadTest.java?ref=96cc0e11ca2166a5e5326be4ead0dab595b7e4bc","patch":"@@ -0,0 +1,319 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.bookkeeper.client.AsyncCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.BookKeeperTestClient;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MultipleThreadReadTest extends BookKeeperClusterTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(MultipleThreadReadTest.class);\n+    BookKeeper.DigestType digestType;\n+    byte[] ledgerPassword = \"aaa\".getBytes();\n+    private int entriesPerLedger = 1000;\n+    final SyncObj mainSyncObj = new SyncObj();\n+\n+    class SyncObj {\n+        volatile int counter;\n+        boolean value;\n+        boolean failed;\n+\n+        public SyncObj() {\n+            counter = 0;\n+            value = false;\n+            failed = false;\n+        }\n+    }\n+\n+    final List<BookKeeperTestClient> clients = new ArrayList<BookKeeperTestClient>();\n+\n+    public MultipleThreadReadTest() {\n+        super(3);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    private void createClients(int numClients) {\n+        closeClientsAndClear();\n+        for (int i = 0; i < numClients; i++) {\n+            try {\n+                clients.add(new BookKeeperTestClient(baseClientConf));\n+            } catch (KeeperException e) {\n+                fail(\"Keeper exception while creating clients\");\n+            } catch (IOException e) {\n+                fail(\"IOException while creating clients\");\n+            } catch (InterruptedException e) {\n+                fail(\"Interrupted while creating clients\");\n+            }\n+        }\n+    }\n+\n+    private void closeClientsAndClear() {\n+        for (BookKeeperTestClient client : clients) {\n+            try {\n+                client.close();\n+            } catch (Exception e) {\n+                LOG.warn(\"Error closing client\");\n+            }\n+        }\n+        clients.clear();\n+    }\n+\n+    private Thread getWriterThread(final int tNo, final LedgerHandle lh) {\n+        Thread t = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                final SyncObj tSync = new SyncObj();\n+                for (int j = 0; j < entriesPerLedger; j++) {\n+                    byte[] entry = (\"Entry-\" + tNo + \"-\" + j).getBytes();\n+                    lh.asyncAddEntry(entry, new AsyncCallback.AddCallback() {\n+                        @Override\n+                        public void addComplete(int rc, LedgerHandle ledgerHandle, long eid, Object o) {\n+                            SyncObj syncObj = (SyncObj) o;\n+                            try {\n+                                if (rc != BKException.Code.OK) {\n+                                    fail(\"Add entries returned a code that is not OK. rc:\" + rc);\n+                                }\n+                                synchronized (syncObj) {\n+                                    syncObj.counter++;\n+                                    syncObj.notify();\n+                                }\n+                            } catch (AssertionError e) {\n+                                synchronized (syncObj) {\n+                                    syncObj.failed = true;\n+                                    syncObj.notify();\n+                                }\n+                            }\n+                        }\n+                    }, tSync);\n+                }\n+                synchronized (tSync) {\n+                    while (!tSync.failed && tSync.counter < entriesPerLedger) {\n+                        try {\n+                            tSync.wait();\n+                        } catch (InterruptedException e) {\n+                            Thread.currentThread().interrupt();\n+                        }\n+                    }\n+                    if (tSync.failed) {\n+                        fail(\"Failed to add entries.\");\n+                    }\n+                }\n+                // close this handle\n+                try {\n+                    lh.close();\n+                } catch (Exception e) {\n+                    if (e instanceof InterruptedException) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+                }\n+            }\n+        });\n+        t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+            @Override\n+            public void uncaughtException(Thread thread, Throwable throwable) {\n+                synchronized (mainSyncObj) {\n+                    mainSyncObj.failed = true;\n+                }\n+            }\n+        });\n+        return t;\n+    }\n+\n+    private Thread getReaderThread(final int tNo, final LedgerHandle lh, final int ledgerNumber) {\n+        Thread t = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    final SyncObj tSync = new SyncObj();\n+                    lh.asyncReadEntries(0, entriesPerLedger - 1, new AsyncCallback.ReadCallback() {\n+                        @Override\n+                        public void readComplete(int rc, LedgerHandle ledgerHandle, Enumeration<LedgerEntry> list,\n+                                        Object o) {\n+                            SyncObj syncObj = (SyncObj) o;\n+                            try {\n+                                if (rc != BKException.Code.OK) {\n+                                    fail(\"Read entries returned a code that is not OK. rc:\" + rc);\n+                                }\n+                                for (int j = 0; j < entriesPerLedger; j++) {\n+                                    LedgerEntry e = null;\n+                                    try {\n+                                        e = list.nextElement();\n+                                    } catch (NoSuchElementException exception) {\n+                                        fail(\"Short read for ledger:\" + ledgerHandle.getId());\n+                                    }\n+                                    byte[] data = e.getEntry();\n+                                    if (!Arrays.equals((\"Entry-\" + ledgerNumber + \"-\" + j).getBytes(), data)) {\n+                                        fail(\"Wrong entry while reading from ledger\");\n+                                    }\n+                                }\n+                                if (list.hasMoreElements()) {\n+                                    fail(\"Read more elements than we wrote for ledger:\" + ledgerHandle.getId());\n+                                }\n+                            } catch (AssertionError e) {\n+                                synchronized (syncObj) {\n+                                    syncObj.failed = true;\n+                                    syncObj.notify();\n+                                }\n+                            } finally {\n+                                synchronized (syncObj) {\n+                                    syncObj.value = true;\n+                                    syncObj.notify();\n+                                }\n+                            }\n+                        }\n+                    }, tSync);\n+                    synchronized (tSync) {\n+                        while (!tSync.value) {\n+                            tSync.wait();\n+                        }\n+                        if (tSync.failed) {\n+                            fail(\"Invalid read while reading form ledger:\" + lh.getId());\n+                        }\n+                    }\n+                } catch (InterruptedException e) {\n+                    fail(\"Interrupted while waiting for replies.\");\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+        });\n+        t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+            @Override\n+            public void uncaughtException(Thread thread, Throwable throwable) {\n+                synchronized (mainSyncObj) {\n+                    mainSyncObj.failed = true;\n+                }\n+            }\n+        });\n+        return t;\n+    }\n+\n+    /**\n+     * Ledger L is handled threads [L, T+(T/L), T+2*(T/L) ... ]\n+     * Reads are simultaneous, writes are sequential.\n+     * @throws java.io.IOException\n+     */\n+    public void multiLedgerMultiThreadRead(final int numLedgers,\n+                    final int numThreads) throws IOException {\n+        assertTrue(numLedgers != 0 && numThreads >= numLedgers && numThreads % numLedgers == 0);\n+\n+        // We create numThread/numLedger clients so that each client can be used to open a handle.\n+        try {\n+            final List<LedgerHandle> oldLedgerHandles = new ArrayList<LedgerHandle>();\n+            final List<Long> ledgerIds = new ArrayList<Long>();\n+            List<Thread> threadList = new ArrayList<Thread>();\n+            // Start write threads.\n+            // Only one thread writes to a ledger, so just use numLedgers instead.\n+            for (int i = 0; i < numLedgers; i++) {\n+                LedgerHandle lh = bkc.createLedger(digestType, ledgerPassword);\n+                oldLedgerHandles.add(lh);\n+                ledgerIds.add(lh.getId());\n+                Thread t;\n+                threadList.add(t = getWriterThread(i, oldLedgerHandles.get(i)));\n+                t.start();\n+            }\n+            // Wait for the threads to complete\n+            for (Thread t : threadList) {\n+                t.join();\n+            }\n+            synchronized (mainSyncObj) {\n+                if (mainSyncObj.failed) {\n+                    fail(\"Test failed because we couldn't add entries.\");\n+                }\n+            }\n+            // Close the ledger handles.\n+            for (LedgerHandle lh : oldLedgerHandles) {\n+                try {\n+                    lh.close();\n+                } catch (BKException.BKLedgerClosedException e) {\n+                } catch (Exception e) {\n+                    fail(\"Error while closing handle.\");\n+                }\n+            }\n+            // Now try to read.\n+            mainSyncObj.failed = false;\n+            threadList.clear();\n+\n+            // Create clients used for reading. Each client is responsible for a disjoint range of numLedgers\n+            // threads. Client X will be used by threads [numLedgers*X .. numLedgers*(X+1))\n+            closeClientsAndClear();\n+            createClients(numThreads / numLedgers);\n+\n+            for (int i = 0; i < numThreads; i++) {\n+                Thread t;\n+                threadList.add(t = getReaderThread(i, clients.get(i / numLedgers)\n+                    .openLedger(ledgerIds.get(i % numLedgers), digestType, ledgerPassword), i % numLedgers));\n+                t.start();\n+            }\n+            // Wait for the threads to complete.\n+            for (Thread t : threadList) {\n+                t.join();\n+            }\n+            synchronized (mainSyncObj) {\n+                if (mainSyncObj.failed) {\n+                    fail(\"Test failed because we couldn't read entries\");\n+                }\n+            }\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n+    @Test\n+    public void test10Ledgers20ThreadsRead() throws IOException {\n+        multiLedgerMultiThreadRead(10, 20);\n+    }\n+\n+    @Test\n+    public void test10Ledgers200ThreadsRead() throws IOException {\n+        multiLedgerMultiThreadRead(10, 200);\n+    }\n+\n+    @Test\n+    public void test1Ledger50ThreadsRead() throws IOException {\n+        multiLedgerMultiThreadRead(1, 50);\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        closeClientsAndClear();\n+        super.tearDown();\n+    }\n+}"}]}

