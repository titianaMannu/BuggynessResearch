{"sha":"97c76a36d79d1d96314cd7e832d1dfbd1211965d","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5N2M3NmEzNmQ3OWQxZDk2MzE0Y2Q3ZTgzMmQxZGZiZDEyMTE5NjVk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-24T20:44:27Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-24T20:44:27Z"},"message":"BOOKKEEPER-248: Rereplicating of under replicated data (umamahesh via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1377100 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6f17250b9b29d8e508979c61493e84a067581279","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6f17250b9b29d8e508979c61493e84a067581279"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/97c76a36d79d1d96314cd7e832d1dfbd1211965d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/97c76a36d79d1d96314cd7e832d1dfbd1211965d","html_url":"https://github.com/apache/bookkeeper/commit/97c76a36d79d1d96314cd7e832d1dfbd1211965d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/97c76a36d79d1d96314cd7e832d1dfbd1211965d/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"b3331cbc528aa32ceb30dcbc676d298beda62df3","url":"https://api.github.com/repos/apache/bookkeeper/commits/b3331cbc528aa32ceb30dcbc676d298beda62df3","html_url":"https://github.com/apache/bookkeeper/commit/b3331cbc528aa32ceb30dcbc676d298beda62df3"}],"stats":{"total":824,"additions":822,"deletions":2},"files":[{"sha":"70fdc85b27beedced2c96e17d7d4461068a8f190","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/97c76a36d79d1d96314cd7e832d1dfbd1211965d/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/97c76a36d79d1d96314cd7e832d1dfbd1211965d/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=97c76a36d79d1d96314cd7e832d1dfbd1211965d","patch":"@@ -94,6 +94,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-299: Provide LedgerFragmentReplicator which should replicate the fragments found from LedgerChecker (umamahesh via ivank)\n \n+        BOOKKEEPER-248: Rereplicating of under replicated data (umamahesh via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"52aad62e477f29fc66d3e79b17caba22a7c0979f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=97c76a36d79d1d96314cd7e832d1dfbd1211965d","patch":"@@ -541,7 +541,7 @@ public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n         }\n     }\n \n-    private static class SyncOpenCallback implements OpenCallback {\n+    static class SyncOpenCallback implements OpenCallback {\n         /**\n          * Callback method for synchronous open operation\n          *"},{"sha":"f173adfbc582ba876eae5a7153623b33a5b66585","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":67,"deletions":1,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=97c76a36d79d1d96314cd7e832d1dfbd1211965d","patch":"@@ -33,6 +33,7 @@\n \n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n+import org.apache.bookkeeper.client.BookKeeper.SyncOpenCallback;\n import org.apache.bookkeeper.client.LedgerFragmentReplicator.SingleFragmentCallback;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n@@ -135,6 +136,20 @@ public void process(WatchedEvent event) {\n         this.lfr = new LedgerFragmentReplicator(bkc);\n     }\n \n+    /**\n+     * Constructor that takes in a BookKeeper instance . This will be useful,\n+     * when users already has bk instance ready.\n+     * \n+     * @param bkc\n+     *            - bookkeeper instance\n+     */\n+    public BookKeeperAdmin(final BookKeeper bkc) {\n+        this.bkc = bkc;\n+        this.zk = bkc.zk;\n+        this.bookiesPath = bkc.getConf().getZkAvailableBookiesPath();\n+        this.lfr = new LedgerFragmentReplicator(bkc);\n+    }\n+\n     /**\n      * Gracefully release resources that this client uses.\n      *\n@@ -163,6 +178,31 @@ public void close() throws InterruptedException, BKException {\n     public void asyncOpenLedger(final long lId, final OpenCallback cb, final Object ctx) {\n         new LedgerOpenOp(bkc, lId, cb, ctx).initiate();\n     }\n+    \n+    /**\n+     * Open a ledger as an administrator. This means that no digest password\n+     * checks are done. Otherwise, the call is identical to\n+     * BookKeeper#openLedger\n+     * \n+     * @param lId\n+     *            - ledger identifier\n+     * @see BookKeeper#openLedger\n+     */\n+    public LedgerHandle openLedger(final long lId) throws InterruptedException,\n+            BKException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+        new LedgerOpenOp(bkc, lId, new SyncOpenCallback(), counter).initiate();\n+        /*\n+         * Wait\n+         */\n+        counter.block(0);\n+        if (counter.getrc() != BKException.Code.OK) {\n+            throw BKException.create(counter.getrc());\n+        }\n+\n+        return counter.getLh();\n+    }\n \n     /**\n      * Open a ledger as an administrator without recovering the ledger. This means\n@@ -181,6 +221,32 @@ public void asyncOpenLedger(final long lId, final OpenCallback cb, final Object\n     public void asyncOpenLedgerNoRecovery(final long lId, final OpenCallback cb, final Object ctx) {\n         new LedgerOpenOp(bkc, lId, cb, ctx).initiateWithoutRecovery();\n     }\n+    \n+    /**\n+     * Open a ledger as an administrator without recovering the ledger. This\n+     * means that no digest password checks are done. Otherwise, the call is\n+     * identical to BookKeeper#openLedgerNoRecovery\n+     * \n+     * @param lId\n+     *            ledger identifier\n+     * @see BookKeeper#openLedgerNoRecovery\n+     */\n+    public LedgerHandle openLedgerNoRecovery(final long lId)\n+            throws InterruptedException, BKException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+        new LedgerOpenOp(bkc, lId, new SyncOpenCallback(), counter)\n+                .initiateWithoutRecovery();\n+        /*\n+         * Wait\n+         */\n+        counter.block(0);\n+        if (counter.getrc() != BKException.Code.OK) {\n+            throw BKException.create(counter.getrc());\n+        }\n+\n+        return counter.getLh();\n+    }\n \n     // Object used for calling async methods and waiting for them to complete.\n     static class SyncObject {\n@@ -595,7 +661,7 @@ private void asyncRecoverLedgerFragment(final LedgerHandle lh,\n      *            - target Bookie, to where entries should be replicated.\n      * @return true - if replication success, false if fails to replicate.\n      */\n-    boolean replicateLedgerFragment(LedgerHandle lh,\n+    public boolean replicateLedgerFragment(LedgerHandle lh,\n             final LedgerFragment ledgerFragment,\n             InetSocketAddress targetBookieAddress) throws InterruptedException {\n         final SyncCounter syncCounter = new SyncCounter();"},{"sha":"e0a5bce7a02550c94474b2e2e30049c409e359a0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"added","additions":289,"deletions":0,"changes":289,"blob_url":"https://github.com/apache/bookkeeper/blob/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=97c76a36d79d1d96314cd7e832d1dfbd1211965d","patch":"@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one \n+ * or more contributor license agreements.  See the NOTICE file \n+ * distributed with this work for additional information \n+ * regarding copyright ownership.  The ASF licenses this file \n+ * to you under the Apache License, Version 2.0 (the \n+ * \"License\"); you may not use this file except in compliance \n+ * with the License.  You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0 \n+ * \n+ * Unless required by applicable law or agreed to in writing, \n+ * software distributed under the License is distributed on an \n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n+ * KIND, either express or implied.  See the License for the \n+ * specific language governing permissions and limitations \n+ * under the License. \n+ * \n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.LedgerChecker;\n+import org.apache.bookkeeper.client.LedgerFragment;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BKException.BKBookieHandleNotAvailableException;\n+import org.apache.bookkeeper.client.BKException.BKNoSuchLedgerExistsException;\n+import org.apache.bookkeeper.client.BKException.BKReadException;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * ReplicationWorker will take the fragments one by one from\n+ * ZKLedgerUnderreplicationManager and replicates to it.\n+ */\n+public class ReplicationWorker implements Runnable {\n+    private static Logger LOG = LoggerFactory\n+            .getLogger(ReplicationWorker.class);\n+    private LedgerUnderreplicationManager underreplicationManager;\n+    private AbstractConfiguration conf;\n+    private ZooKeeper zkc;\n+    private volatile boolean workerRunning = false;\n+    private BookKeeperAdmin admin;\n+    private LedgerChecker ledgerChecker;\n+    private InetSocketAddress targetBookie;\n+    private BookKeeper bkc;\n+    private Thread workerThread;\n+\n+    /**\n+     * Replication worker for replicating the ledger fragments from\n+     * UnderReplicationManager to the targetBookie. This target bookie will be a\n+     * local bookie.\n+     * \n+     * @param zkc\n+     *            - ZK instance\n+     * @param conf\n+     *            - configurations\n+     * @param targetBKAddr\n+     *            - to where replication should happen. Ideally this will be\n+     *            local Bookie address.\n+     */\n+    public ReplicationWorker(final ZooKeeper zkc,\n+            final AbstractConfiguration conf, InetSocketAddress targetBKAddr)\n+            throws CompatibilityException, KeeperException,\n+            InterruptedException, IOException {\n+        this.zkc = zkc;\n+        this.conf = conf;\n+        this.targetBookie = targetBKAddr;\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(this.conf, this.zkc);\n+        this.underreplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+        this.bkc = new BookKeeper(new ClientConfiguration(conf), zkc);\n+        this.admin = new BookKeeperAdmin(bkc);\n+        this.ledgerChecker = new LedgerChecker(bkc);\n+        this.workerThread = new Thread(this);\n+    }\n+\n+    /** Start the replication worker */\n+    public void start() {\n+        this.workerThread.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        workerRunning = true;\n+        while (workerRunning) {\n+            try {\n+                long ledgerIdToReplicate = underreplicationManager\n+                        .getLedgerToRereplicate();\n+                LOG.info(\"Going to replicate the fragments of the ledger: \"\n+                        + ledgerIdToReplicate);\n+                LedgerHandle lh;\n+                try {\n+                    lh = admin.openLedgerNoRecovery(ledgerIdToReplicate);\n+                } catch (BKNoSuchLedgerExistsException e) {\n+                    // Ledger might have been deleted by user\n+                    LOG.info(\"BKNoSuchLedgerExistsException while opening \"\n+                            + \"ledger for replication. Other clients \"\n+                            + \"might have deleted the ledger. \"\n+                            + \"So, no harm to continue\");\n+                    underreplicationManager\n+                            .markLedgerReplicated(ledgerIdToReplicate);\n+                    continue;\n+                } catch (BKReadException e) {\n+                    LOG.info(\"BKReadException while\"\n+                            + \" opening ledger for replication.\"\n+                            + \" Enough Bookies might not have available\"\n+                            + \"So, no harm to continue\");\n+                    underreplicationManager\n+                            .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n+                    continue;\n+                } catch (BKBookieHandleNotAvailableException e) {\n+                    LOG.info(\"BKBookieHandleNotAvailableException while\"\n+                            + \" opening ledger for replication.\"\n+                            + \" Enough Bookies might not have available\"\n+                            + \"So, no harm to continue\");\n+                    underreplicationManager\n+                            .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n+                    continue;\n+                }\n+\n+                boolean isAllFragmentsReplicated = doReplicateFragments(\n+                        ledgerIdToReplicate, lh);\n+                if (!isAllFragmentsReplicated) {\n+                    // Releasing the underReplication ledger lock and compete\n+                    // for the replication again for the pending fragments\n+                    underreplicationManager\n+                            .releaseUnderreplicatedLedger(ledgerIdToReplicate);\n+                    continue;\n+                }\n+\n+                LOG.info(\"Ledger replicated successfully. ledger id is: \"\n+                        + ledgerIdToReplicate);\n+                underreplicationManager\n+                        .markLedgerReplicated(ledgerIdToReplicate);\n+            } catch (InterruptedException e) {\n+                shutdown();\n+                Thread.currentThread().interrupt();\n+                LOG.info(\"InterruptedException \"\n+                        + \"while replicating fragments\", e);\n+                return;\n+            } catch (BKException e) {\n+                shutdown();\n+                LOG.error(\"BKException while replicating fragments\", e);\n+                return;\n+            } catch (UnavailableException e) {\n+                shutdown();\n+                LOG.error(\"UnavailableException \"\n+                        + \"while replicating fragments\", e);\n+                return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Replicates the under replicated fragments from failed bookie ledger to\n+     * targetBookie\n+     * \n+     * @return - false if the re-replication fails for any fragment. Also\n+     *         returns false if fragment ensemble contains the target bookie\n+     *         (since target bookie already present in the current fragment\n+     *         ensemble, it will skip replication for that particular\n+     *         fragments). Returns true if all fragments replicated\n+     *         successfully.\n+     */\n+    private boolean doReplicateFragments(long ledgerIdToReplicate,\n+            LedgerHandle lh) throws InterruptedException {\n+        CheckerCallback checkerCb = new CheckerCallback();\n+        ledgerChecker.checkLedger(lh, checkerCb);\n+        Set<LedgerFragment> fragments = checkerCb.waitAndGetResult();\n+        LOG.info(\"Founds fragments \" + fragments\n+                + \" for replication from ledger: \" + ledgerIdToReplicate);\n+        boolean isTargetBookieExistsInFragmentEnsemble = false;\n+        boolean isAllFragmentsReplicated = true;\n+        for (LedgerFragment ledgerFragment : fragments) {\n+            if (isTargetBookieExistsInFragmentEnsemble(lh, ledgerFragment)) {\n+                LOG.info(\"Target Bookie[\" + targetBookie\n+                        + \"] found in the fragment ensemble:\"\n+                        + ledgerFragment.getEnsemble());\n+                isTargetBookieExistsInFragmentEnsemble = true;\n+                continue;\n+            }\n+            boolean isFragmentReplicated = admin.replicateLedgerFragment(lh,\n+                    ledgerFragment, targetBookie);\n+            if (!isFragmentReplicated) {\n+                isAllFragmentsReplicated = false;\n+            }\n+        }\n+        if (isTargetBookieExistsInFragmentEnsemble) {\n+            LOG.info(\"Releasing the lock, as target Bookie found\"\n+                    + \" in the fragments ensemble.\");\n+            return false;\n+        }\n+\n+        // There might be some connectivity issues while replicating,\n+        // so, still I am eligible to replicate it, lets retry.\n+        if (!isAllFragmentsReplicated) {\n+            LOG.info(\"Could not replicate all fragments.\"\n+                    + \"So, Releasing the lock. Let's compete \"\n+                    + \"for the replication again\");\n+            return false;\n+        }\n+\n+        // Re-replication success\n+        return true;\n+\n+    }\n+\n+    /**\n+     * Stop the replication worker service\n+     */\n+    public void shutdown() {\n+        workerRunning = false;\n+        try {\n+            underreplicationManager.close();\n+        } catch (UnavailableException e) {\n+            LOG.warn(\"Exception while closing the \"\n+                    + \"ZkLedgerUnderrepliationManager\", e);\n+        }\n+        try {\n+            bkc.close();\n+        } catch (InterruptedException e) {\n+            LOG.warn(\"Interrupted while closing the Bookie client\", e);\n+            Thread.currentThread().interrupt();\n+        } catch (BKException e) {\n+            LOG.warn(\"Exception while closing the Bookie client\", e);\n+        }\n+        try {\n+            this.workerThread.interrupt();\n+            this.workerThread.join();\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Interrupted during shutting down replication worker : \",\n+                    e);\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    private boolean isTargetBookieExistsInFragmentEnsemble(LedgerHandle lh,\n+            LedgerFragment ledgerFragment) {\n+        List<InetSocketAddress> ensemble = ledgerFragment.getEnsemble();\n+        for (InetSocketAddress bkAddr : ensemble) {\n+            if (targetBookie.equals(bkAddr)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** Ledger checker call back */\n+    private static class CheckerCallback implements\n+            GenericCallback<Set<LedgerFragment>> {\n+        private Set<LedgerFragment> result = null;\n+        private CountDownLatch latch = new CountDownLatch(1);\n+\n+        @Override\n+        public void operationComplete(int rc, Set<LedgerFragment> result) {\n+            this.result = result;\n+            latch.countDown();\n+        }\n+\n+        /**\n+         * Wait until operation complete call back comes and return the ledger\n+         * fragments set\n+         */\n+        Set<LedgerFragment> waitAndGetResult() throws InterruptedException {\n+            latch.await();\n+            return result;\n+        }\n+    }\n+\n+}"},{"sha":"9af527a36408d3af93e3a16bb12f861c8ea70295","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java","raw_url":"https://github.com/apache/bookkeeper/raw/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerHandleAdapter.java?ref=97c76a36d79d1d96314cd7e832d1dfbd1211965d","patch":"@@ -0,0 +1,32 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one \n+ * or more contributor license agreements.  See the NOTICE file \n+ * distributed with this work for additional information \n+ * regarding copyright ownership.  The ASF licenses this file \n+ * to you under the Apache License, Version 2.0 (the \n+ * \"License\"); you may not use this file except in compliance \n+ * with the License.  You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0 \n+ * \n+ * Unless required by applicable law or agreed to in writing, \n+ * software distributed under the License is distributed on an \n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n+ * KIND, either express or implied.  See the License for the \n+ * specific language governing permissions and limitations \n+ * under the License. \n+ * \n+ */\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Adapter for tests to get the public access from LedgerHandle for its default\n+ * scope\n+ */\n+public class LedgerHandleAdapter {\n+\n+    /** get the ledger handle */\n+    public static LedgerMetadata getLedgerMetadata(LedgerHandle lh) {\n+        return lh.getLedgerMetadata();\n+    }\n+}"},{"sha":"db79edd82378363634690b381eec46bd90692a11","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"added","additions":431,"deletions":0,"changes":431,"blob_url":"https://github.com/apache/bookkeeper/blob/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/97c76a36d79d1d96314cd7e832d1dfbd1211965d/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=97c76a36d79d1d96314cd7e832d1dfbd1211965d","patch":"@@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one \n+ * or more contributor license agreements.  See the NOTICE file \n+ * distributed with this work for additional information \n+ * regarding copyright ownership.  The ASF licenses this file \n+ * to you under the Apache License, Version 2.0 (the \n+ * \"License\"); you may not use this file except in compliance \n+ * with the License.  You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0 \n+ * \n+ * Unless required by applicable law or agreed to in writing, \n+ * software distributed under the License is distributed on an \n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n+ * KIND, either express or implied.  See the License for the \n+ * specific language governing permissions and limitations \n+ * under the License. \n+ * \n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Map.Entry;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerHandleAdapter;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test the ReplicationWroker, where it has to replicate the fragments from\n+ * failed Bookies to given target Bookie.\n+ */\n+public class TestReplicationWorker extends MultiLedgerManagerTestCase {\n+\n+    private static Logger LOG = LoggerFactory\n+            .getLogger(TestReplicationWorker.class);\n+\n+    public TestReplicationWorker(String ledgerManagerFactory) {\n+        super(3);\n+        LOG.info(\"Running test case using ledger manager : \"\n+                + ledgerManagerFactory);\n+        // set ledger manager name\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+    }\n+\n+    /**\n+     * Tests that replication worker should replicate the failed bookie\n+     * fragments to target bookie given to the worker.\n+     */\n+    @Test(timeout = 30000)\n+    public void testRWShouldReplicateFragmentsToTargetBookie() throws Exception {\n+        byte[] data = \"TestReplicationWorker\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        killBookie(replicaToKill);\n+\n+        int startNewBookie = startNewBookie();\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n+                newBkAddr);\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+\n+        rw.start();\n+        try {\n+\n+            underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n+                    replicaToKill.toString());\n+            String basePath = baseClientConf.getZkLedgersRootPath()\n+                    + \"/underreplication/ledgers\";\n+\n+            while (isLedgerInUnderReplication(lh.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+\n+            killAllBookies(lh, newBkAddr);\n+\n+            // Should be able to read the entries from 0-9\n+            verifyRecoveredLedgers(lh, 0, 9);\n+        } finally {\n+            rw.shutdown();\n+            underReplicationManager.close();\n+        }\n+    }\n+\n+    /**\n+     * Tests that replication worker should retry for replication until enough\n+     * bookies available for replication\n+     */\n+    @Test(timeout = 60000)\n+    public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication()\n+            throws Exception {\n+        byte[] data = \"TestReplicationWorker\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(1, 1, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        lh.close();\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        ServerConfiguration killedBookieConfig = killBookie(replicaToKill);\n+\n+        int startNewBookie = startNewBookie();\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+\n+        killAllBookies(lh, newBkAddr);\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n+                newBkAddr);\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+\n+        rw.start();\n+        try {\n+            underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n+                    replicaToKill.toString());\n+            String basePath = baseClientConf.getZkLedgersRootPath()\n+                    + \"/underreplication/ledgers\";\n+            int counter = 100;\n+            while (counter-- > 0) {\n+                assertTrue(\"Expecting that replication should not complete\",\n+                        isLedgerInUnderReplication(lh.getId(), basePath));\n+                Thread.sleep(100);\n+            }\n+            // restart killed bookie\n+            bs.add(startBookie(killedBookieConfig));\n+            bsConfs.add(killedBookieConfig);\n+            while (isLedgerInUnderReplication(lh.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+            // Should be able to read the entries from 0-9\n+            verifyRecoveredLedgers(lh, 0, 9);\n+        } finally {\n+            rw.shutdown();\n+            underReplicationManager.close();\n+        }\n+    }\n+\n+    /**\n+     * Tests that replication worker1 should take one fragment replication and\n+     * other replication worker also should compete for the replication.\n+     */\n+    @Test(timeout = 90000)\n+    public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplication()\n+            throws Exception {\n+        byte[] data = \"TestReplicationWorker\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(2, 2, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        lh.close();\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        ServerConfiguration killedBookieConfig = killBookie(replicaToKill);\n+\n+        killAllBookies(lh, null);\n+        // Starte RW1\n+        int startNewBookie1 = startNewBookie();\n+        InetSocketAddress newBkAddr1 = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie1);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr1);\n+        ReplicationWorker rw1 = new ReplicationWorker(zkc, baseClientConf,\n+                newBkAddr1);\n+\n+        // Starte RW2\n+        int startNewBookie2 = startNewBookie();\n+        InetSocketAddress newBkAddr2 = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie2);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr2);\n+        ZooKeeper zkc1 = zkUtil.getNewZooKeeperClient();\n+        ReplicationWorker rw2 = new ReplicationWorker(zkc1, baseClientConf,\n+                newBkAddr2);\n+        rw1.start();\n+        rw2.start();\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+        try {\n+            underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n+                    replicaToKill.toString());\n+            String basePath = baseClientConf.getZkLedgersRootPath()\n+                    + \"/underreplication/ledgers\";\n+            int counter = 10;\n+            while (counter-- > 0) {\n+                assertTrue(\"Expecting that replication should not complete\",\n+                        isLedgerInUnderReplication(lh.getId(), basePath));\n+                Thread.sleep(100);\n+            }\n+            // restart killed bookie\n+            bs.add(startBookie(killedBookieConfig));\n+            bsConfs.add(killedBookieConfig);\n+            while (isLedgerInUnderReplication(lh.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+            // Should be able to read the entries from 0-9\n+            verifyRecoveredLedgers(lh, 0, 9);\n+        } finally {\n+            rw1.shutdown();\n+            rw2.shutdown();\n+            zkc1.close();\n+            underReplicationManager.close();\n+        }\n+    }\n+\n+    /**\n+     * Tests that Replication worker should clean the leadger under replication\n+     * node of the ledger already deleted\n+     */\n+    @Test(timeout = 3000)\n+    public void testRWShouldCleanTheLedgerFromUnderReplicationIfLedgerAlreadyDeleted()\n+            throws Exception {\n+        byte[] data = \"TestReplicationWorker\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(2, 2, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(data);\n+        }\n+        lh.close();\n+        InetSocketAddress replicaToKill = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+        LOG.info(\"Killing Bookie\", replicaToKill);\n+        killBookie(replicaToKill);\n+\n+        int startNewBookie = startNewBookie();\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n+                newBkAddr);\n+        rw.start();\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+        try {\n+            bkc.deleteLedger(lh.getId()); // Deleting the ledger\n+            // Also mark ledger as in UnderReplication\n+            underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n+                    replicaToKill.toString());\n+            String basePath = baseClientConf.getZkLedgersRootPath()\n+                    + \"/underreplication/ledgers\";\n+            while (isLedgerInUnderReplication(lh.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+        } finally {\n+            rw.shutdown();\n+            underReplicationManager.close();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testMultipleLedgerReplicationWithReplicationWorker()\n+            throws Exception {\n+\n+        byte[] data = \"TestReplicationWorker\".getBytes();\n+\n+        // Ledger1\n+        LedgerHandle lh1 = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh1.addEntry(data);\n+        }\n+        InetSocketAddress replicaToKillFromFirstLedger = LedgerHandleAdapter\n+                .getLedgerMetadata(lh1).getEnsembles().get(0L).get(0);\n+\n+        LOG.info(\"Killing Bookie\", replicaToKillFromFirstLedger);\n+\n+        // Ledger2\n+        LedgerHandle lh2 = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                \"testpasswd\".getBytes());\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh2.addEntry(data);\n+        }\n+        InetSocketAddress replicaToKillFromSecondLedger = LedgerHandleAdapter\n+                .getLedgerMetadata(lh2).getEnsembles().get(0L).get(0);\n+\n+        LOG.info(\"Killing Bookie\", replicaToKillFromSecondLedger);\n+\n+        // Kill ledger1\n+        killBookie(replicaToKillFromFirstLedger);\n+        lh1.close();\n+        // Kill ledger2\n+        killBookie(replicaToKillFromFirstLedger);\n+        lh2.close();\n+\n+        int startNewBookie = startNewBookie();\n+\n+        InetSocketAddress newBkAddr = new InetSocketAddress(InetAddress\n+                .getLocalHost().getHostAddress(), startNewBookie);\n+        LOG.info(\"New Bookie addr :\" + newBkAddr);\n+\n+        ReplicationWorker rw = new ReplicationWorker(zkc, baseClientConf,\n+                newBkAddr);\n+\n+        LedgerManagerFactory mFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        LedgerUnderreplicationManager underReplicationManager = mFactory\n+                .newLedgerUnderreplicationManager();\n+\n+        rw.start();\n+        try {\n+\n+            // Mark ledger1 and 2 as underreplicated\n+            underReplicationManager.markLedgerUnderreplicated(lh1.getId(),\n+                    replicaToKillFromFirstLedger.toString());\n+            underReplicationManager.markLedgerUnderreplicated(lh2.getId(),\n+                    replicaToKillFromSecondLedger.toString());\n+            String basePath = baseClientConf.getZkLedgersRootPath()\n+                    + \"/underreplication/ledgers\";\n+\n+            while (isLedgerInUnderReplication(lh1.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+\n+            while (isLedgerInUnderReplication(lh2.getId(), basePath)) {\n+                Thread.sleep(100);\n+            }\n+\n+            killAllBookies(lh1, newBkAddr);\n+\n+            // Should be able to read the entries from 0-9\n+            verifyRecoveredLedgers(lh1, 0, 9);\n+            verifyRecoveredLedgers(lh2, 0, 9);\n+        } finally {\n+            rw.shutdown();\n+            underReplicationManager.close();\n+        }\n+\n+    }\n+\n+    private void killAllBookies(LedgerHandle lh, InetSocketAddress excludeBK)\n+            throws InterruptedException {\n+        // Killing all bookies except newly replicated bookie\n+        Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().entrySet();\n+        for (Entry<Long, ArrayList<InetSocketAddress>> entry : entrySet) {\n+            ArrayList<InetSocketAddress> bookies = entry.getValue();\n+            for (InetSocketAddress bookie : bookies) {\n+                if (bookie.equals(excludeBK)) {\n+                    continue;\n+                }\n+                killBookie(bookie);\n+            }\n+        }\n+    }\n+\n+    private boolean isLedgerInUnderReplication(long id, String basePath)\n+            throws KeeperException, InterruptedException {\n+        List<String> children = zkc.getChildren(basePath, true);\n+        boolean isMatched = false;\n+        for (String child : children) {\n+            if (child.startsWith(\"urL\") && child.contains(String.valueOf(id))) {\n+                isMatched = true;\n+                break;\n+            } else {\n+                String path = basePath + \"/\" + child;\n+                if (zkc.getChildren(path, false).size() > 0) {\n+                    isMatched = isLedgerInUnderReplication(id, path);\n+                }\n+            }\n+\n+        }\n+        return isMatched;\n+    }\n+\n+    private void verifyRecoveredLedgers(LedgerHandle lh, long startEntryId,\n+            long endEntryId) throws BKException, InterruptedException {\n+        LedgerHandle lhs = bkc.openLedgerNoRecovery(lh.getId(),\n+                BookKeeper.DigestType.CRC32, \"testpasswd\".getBytes());\n+        Enumeration<LedgerEntry> entries = lhs.readEntries(startEntryId,\n+                endEntryId);\n+        assertTrue(\"Should have the elements\", entries.hasMoreElements());\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            assertEquals(\"TestReplicationWorker\", new String(entry.getEntry()));\n+        }\n+    }\n+\n+}"}]}

