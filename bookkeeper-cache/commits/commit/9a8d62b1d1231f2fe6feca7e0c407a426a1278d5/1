{"sha":"9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5YThkNjJiMWQxMjMxZjJmZTZmZWNhN2UwYzQwN2E0MjZhMTI3OGQ1","commit":{"author":{"name":"Robin Dhamankar","email":"robindh@apache.org","date":"2016-03-16T03:43:54Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-03-16T03:43:54Z"},"message":"BOOKKEEPER-769: Remove the Hedwig Code\n\n- Remove code directories for Hedwig code\n- Remove code directories under compat\n- Remove Hedwig related documentation\n- Remove references to Hedwig code in pom files\n\n* There is an unrelated findbugs violation in BookieWatcher which is not related to this change\n* There were flaky tests that failed locally but passed when I reran them\n\nAuthor: Robin Dhamankar <robindh@Robins-MacBook-Air.local>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #27 from robindh/RemoveHedwig","tree":{"sha":"02ef5a2fa0c8090e5e410f5804a51ce5a0cf7ff0","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/02ef5a2fa0c8090e5e410f5804a51ce5a0cf7ff0"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","html_url":"https://github.com/apache/bookkeeper/commit/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"410ff7263a477d4b75a43d006adde3549225a4b9","url":"https://api.github.com/repos/apache/bookkeeper/commits/410ff7263a477d4b75a43d006adde3549225a4b9","html_url":"https://github.com/apache/bookkeeper/commit/410ff7263a477d4b75a43d006adde3549225a4b9"}],"stats":{"total":104540,"additions":11,"deletions":104529},"files":[{"sha":"654b37037fa18022f025d5093e9a6eeb1fb5f8f0","filename":"README","status":"modified","additions":4,"deletions":21,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/README","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/README","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/README?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -6,7 +6,6 @@ Requirements:\n * Unix System\n * JDK 1.6\n * Maven 3.0\n-* Autotools (if compiling native hedwig client)\n * Internet connection for first build (to fetch all dependencies)\n \n -------------------------------------------------------------------------------\n@@ -16,19 +15,11 @@ The BookKeeper project contains:\n  - bookkeeper-benchmark         (Benchmark suite for testing BookKeeper performance)\n  - bookkeeper-stats             (BookKeeper stats library)\n  - bookkeeper-stats-providers   (BookKeeper stats providers)\n- - hedwig-protocol              (Hedwig network protocol)\n- - hedwig-server                (Hedwig server)\n- - hedwig-client                (Hedwig client library)\n- - hedwig-client-jms            (Hedwig client jms library)\n \n BookKeeper is a system to reliably log streams of records. It is designed to \n store  write ahead logs, such as those found in database or database like \n applications.\n \n-Hedwig is a publish-subscribe system designed to carry large amounts of data \n-across the internet in a guaranteed-delivery fashion from those who produce \n-it (publishers) to those who are interested in it (subscribers).\n-\n --------------------------------------------------------------------------------\n How do I build?\n \n@@ -59,9 +50,10 @@ How do I build?\n --------------------------------------------------------------------------------\n How do I run the services?\n \n- Running a Hedwig service requires a running BookKeeper service, which in turn\n- requires a running ZooKeeper service (see http://zookeeper.apache.org). To \n- start a bookkeeper service quickly for testing, run:\n+ Running BookKeeper service, requires a running ZooKeeper service \n+ (see http://zookeeper.apache.org). \n+\n+ To start a bookkeeper service quickly for testing, run:\n    \n    $ bookkeeper-server/bin/bookkeeper localbookie 10\n \n@@ -74,15 +66,6 @@ How do I run the services?\n \n    $ bookkeeper-server/bin/bookkeeper bookie\n \n- Once you have at least 3 bookies runnings, you can start some Hedwig hubs. A \n- hub is a machines which is responsible for a set of topics in the pubsub \n- system. The service automatically distributes the topics among the hubs. \n- To start a hedwig hub:\n-\n-   $ hedwig-server/bin/hedwig server\n-\n  You can get more help on using these commands by running:\n \n    $ bookkeeper-server/bin/bookkeeper help\n-       and\n-   $ hedwig-server/bin/hedwig help"},{"sha":"b0dd95f46c74897236cedf039a95cff6be2acc0e","filename":"bookkeeper-server/conf/log4j.properties","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/bookkeeper-server/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/bookkeeper-server/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/log4j.properties?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -19,10 +19,6 @@\n #\n #\n \n-#\n-# Hedwig Logging Configuration\n-#\n-\n # Format is \"<default threshold> (, <appender>)+\n \n # DEFAULT: console appender only"},{"sha":"b0d03270d1dd48a152db8e39f7b406fb284cc033","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -83,7 +83,7 @@ public String toString() {\n         return sb.toString();\n     }\n \n-    // Implement an equals method comparing two HedwigSocketAddress objects.\n+    // Implement an equals method comparing two BookiSocketAddress objects.\n     @Override\n     public boolean equals(Object obj) {\n         if (!(obj instanceof BookieSocketAddress))"},{"sha":"a7bcf774ef603a84718134cc7e1b1ba342679b08","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -174,8 +174,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         addDoneLatch.countDown();\n         // wait until entries failed due to UnauthorizedAccessException\n         failedLatch.await();\n-        // simulate the ownership of this ledger is transfer to another host (which is actually\n-        // what we did in Hedwig).\n+        // simulate the ownership of this ledger is transfer to another host\n         LOG.info(\"Recover ledger {}.\", lh.getId());\n         ClientConfiguration newConf = new ClientConfiguration();\n         newConf.addConfiguration(baseClientConf);"},{"sha":"4e789d79f177306efc22f2c4652e55e7647dc69f","filename":"compat-deps/hedwig-server-compat-4.0.0/pom.xml","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/compat-deps/hedwig-server-compat-4.0.0/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/compat-deps/hedwig-server-compat-4.0.0/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/compat-deps/hedwig-server-compat-4.0.0/pom.xml?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,97 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n-  <modelVersion>4.0.0</modelVersion>\n-  <parent>\n-    <artifactId>compat-deps</artifactId>\n-    <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.4.0-SNAPSHOT</version>\n-  </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n-  <artifactId>hedwig-server-compat400</artifactId>\n-  <version>4.0.0</version>\n-  <name>hedwig-server-compat400</name>\n-  <url>http://maven.apache.org</url>\n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-  </properties>\n-  <dependencies>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-server</artifactId>\n-      <version>4.0.0</version>\n-    </dependency>\n-  </dependencies>\n-  <build>\n-    <plugins>\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-shade-plugin</artifactId>\n-        <version>1.5</version>\n-        <executions>\n-          <execution>\n-            <phase>package</phase>\n-            <goals>\n-              <goal>shade</goal>\n-            </goals>\n-            <configuration>\n-              <createDependencyReducedPom>false</createDependencyReducedPom>\n-              <artifactSet>\n-                <includes>\n-                  <include>org.apache.*:*</include>\n-                  <include>org.jboss.*:*</include>\n-                  <include>commons-*:*</include>\n-                </includes>\n-                <excludes>\n-                  <exclude>commons-beanutils*:commons-beanutils*</exclude>\n-                </excludes>\n-              </artifactSet>\n-              <relocations>\n-                <relocation>\n-                  <pattern>org.apache.commons</pattern>\n-                  <shadedPattern>org.apache.hw_v4_0_0.commons</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.bookkeeper</pattern>\n-                  <shadedPattern>org.apache.hw_v4_0_0.bookkeeper</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.zookeeper</pattern>\n-                  <shadedPattern>org.apache.hw_v4_0_0.zookkeeper</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.hedwig</pattern>\n-                  <shadedPattern>org.apache.hw_v4_0_0.hedwig</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.jute</pattern>\n-                  <shadedPattern>org.apache.hw_v4_0_0.jute</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.jboss</pattern>\n-                  <shadedPattern>org.jboss.hw_v4_0_0</shadedPattern>\n-                </relocation>\n-              </relocations>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-    </plugins>\n-  </build>\n-</project>"},{"sha":"f6f6630344a3777808d7a9567e9707da8fcbd190","filename":"compat-deps/hedwig-server-compat-4.1.0/pom.xml","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/compat-deps/hedwig-server-compat-4.1.0/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/compat-deps/hedwig-server-compat-4.1.0/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/compat-deps/hedwig-server-compat-4.1.0/pom.xml?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,97 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n-  <modelVersion>4.0.0</modelVersion>\n-  <parent>\n-    <artifactId>compat-deps</artifactId>\n-    <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.4.0-SNAPSHOT</version>\n-  </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n-  <artifactId>hedwig-server-compat410</artifactId>\n-  <version>4.1.0</version>\n-  <name>hedwig-server-compat410</name>\n-  <url>http://maven.apache.org</url>\n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-  </properties>\n-  <dependencies>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-server</artifactId>\n-      <version>4.1.0</version>\n-    </dependency>\n-  </dependencies>\n-  <build>\n-    <plugins>\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-shade-plugin</artifactId>\n-        <version>1.5</version>\n-        <executions>\n-          <execution>\n-            <phase>package</phase>\n-            <goals>\n-              <goal>shade</goal>\n-            </goals>\n-            <configuration>\n-              <createDependencyReducedPom>false</createDependencyReducedPom>\n-              <artifactSet>\n-                <includes>\n-                  <include>org.apache.*:*</include>\n-                  <include>org.jboss.*:*</include>\n-                  <include>commons-*:*</include>\n-                </includes>\n-                <excludes>\n-                  <exclude>commons-beanutils*:commons-beanutils*</exclude>\n-                </excludes>\n-              </artifactSet>\n-              <relocations>\n-                <relocation>\n-                  <pattern>org.apache.commons</pattern>\n-                  <shadedPattern>org.apache.hw_v4_1_0.commons</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.bookkeeper</pattern>\n-                  <shadedPattern>org.apache.hw_v4_1_0.bookkeeper</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.zookeeper</pattern>\n-                  <shadedPattern>org.apache.hw_v4_1_0.zookkeeper</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.hedwig</pattern>\n-                  <shadedPattern>org.apache.hw_v4_1_0.hedwig</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.jute</pattern>\n-                  <shadedPattern>org.apache.hw_v4_1_0.jute</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.jboss</pattern>\n-                  <shadedPattern>org.jboss.hw_v4_1_0</shadedPattern>\n-                </relocation>\n-              </relocations>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-    </plugins>\n-  </build>\n-</project>"},{"sha":"71f59ea43a1f811d7797828518bea305b715aa3b","filename":"compat-deps/hedwig-server-compat-4.2.0/pom.xml","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/compat-deps/hedwig-server-compat-4.2.0/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/compat-deps/hedwig-server-compat-4.2.0/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/compat-deps/hedwig-server-compat-4.2.0/pom.xml?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,97 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n-  <modelVersion>4.0.0</modelVersion>\n-  <parent>\n-    <artifactId>compat-deps</artifactId>\n-    <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.4.0-SNAPSHOT</version>\n-  </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n-  <artifactId>hedwig-server-compat420</artifactId>\n-  <version>4.2.0</version>\n-  <name>hedwig-server-compat420</name>\n-  <url>http://maven.apache.org</url>\n-  <properties>\n-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-  </properties>\n-  <dependencies>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-server</artifactId>\n-      <version>4.2.0</version>\n-    </dependency>\n-  </dependencies>\n-  <build>\n-    <plugins>\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-shade-plugin</artifactId>\n-        <version>1.5</version>\n-        <executions>\n-          <execution>\n-            <phase>package</phase>\n-            <goals>\n-              <goal>shade</goal>\n-            </goals>\n-            <configuration>\n-              <createDependencyReducedPom>false</createDependencyReducedPom>\n-              <artifactSet>\n-                <includes>\n-                  <include>org.apache.*:*</include>\n-                  <include>org.jboss.*:*</include>\n-                  <include>commons-*:*</include>\n-                </includes>\n-                <excludes>\n-                  <exclude>commons-beanutils*:commons-beanutils*</exclude>\n-                </excludes>\n-              </artifactSet>\n-              <relocations>\n-                <relocation>\n-                  <pattern>org.apache.commons</pattern>\n-                  <shadedPattern>org.apache.hw_v4_2_0.commons</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.bookkeeper</pattern>\n-                  <shadedPattern>org.apache.hw_v4_2_0.bookkeeper</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.zookeeper</pattern>\n-                  <shadedPattern>org.apache.hw_v4_2_0.zookkeeper</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.hedwig</pattern>\n-                  <shadedPattern>org.apache.hw_v4_2_0.hedwig</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.apache.jute</pattern>\n-                  <shadedPattern>org.apache.hw_v4_2_0.jute</shadedPattern>\n-                </relocation>\n-                <relocation>\n-                  <pattern>org.jboss</pattern>\n-                  <shadedPattern>org.jboss.hw_v4_2_0</shadedPattern>\n-                </relocation>\n-              </relocations>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-    </plugins>\n-  </build>\n-</project>"},{"sha":"05d1373ec93299aeb3363bab8dc6e0b5e349afe6","filename":"compat-deps/pom.xml","status":"modified","additions":0,"deletions":3,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/compat-deps/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/compat-deps/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/compat-deps/pom.xml?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -34,9 +34,6 @@\n     <module>bookkeeper-server-compat-4.0.0</module>\n     <module>bookkeeper-server-compat-4.1.0</module>\n     <module>bookkeeper-server-compat-4.2.0</module>\n-    <module>hedwig-server-compat-4.0.0</module>\n-    <module>hedwig-server-compat-4.1.0</module>\n-    <module>hedwig-server-compat-4.2.0</module>\n   </modules>\n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>"},{"sha":"bcecd9930e0727ef11d5c81d2fa3b8a9c272073a","filename":"doc/hedwigBuild.textile","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigBuild.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigBuild.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigBuild.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,38 +0,0 @@\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .        \n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-\n-h1. Pre-requisites\n-\n-For the core itself:\n-\n-* JDK 6: \"http://java.sun.com/\":http://java.sun.com/. Ensure @$JAVA_HOME@ is correctly set.\n-* Maven 2: \"http://maven.apache.org/\":http://maven.apache.org/.\n-\n-Hedwig has been tested on Windows XP, Linux 2.6, and OS X.\n-\n-h1. Command-Line Instructions\n-\n-From the top level bookkeeper directory, run @mvn package@. This will compile and package the jars necessary for running hedwig. \n-\n-See the User's Guide for instructions on running and usage.\n-\n-h1. Eclipse Instructions\n-\n-To check out, build, and develop using Eclipse:\n-\n-# Install the Subclipse plugin. Update site: \"http://subclipse.tigris.org/update_1.4.x\":http://subclipse.tigris.org/update_1.4.x.\n-# Install the Maven plugin. Update site: \"http://m2eclipse.sonatype.org/update\":http://m2eclipse.sonatype.org/update. From the list of packages available from this site, select everything under the &quot;Maven Integration&quot; category, and from the optional components select the ones with the word &quot;SCM&quot; in them.\n-# Go to Preferences &gt; Team &gt; SVN. For the SVN interface, choose &quot;Pure Java&quot;.\n-# Choose File &gt; New &gt; Project... &gt; Maven &gt; Checkout Maven Projects from SCM.\n-# For the SCM URL type, choose SVN. For the URL, enter SVN URL. Maven will automatically create a top-level Eclipse project for each of the 4 Maven modules (recommended). If you want fewer top-level projects, uncheck the option of having a project for each module (under Advanced).\n-\n-You are now ready to run and debug the client and server code. See the User's Guide for instructions on running and usage.\n-"},{"sha":"b37d20c174d68c02a1d88cb6c9732733d672ae39","filename":"doc/hedwigConsole.textile","status":"removed","additions":0,"deletions":187,"changes":187,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigConsole.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigConsole.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigConsole.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,187 +0,0 @@\n-Title:        Hedwig Console\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .\n-        .        \n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-        .\n-\n-h1. Hedwig Console\n-\n-Apache Hedwig provides a console client, which allows users and administrators to interact with a hedwig cluster. \n-\n-h2. Connecting to hedwig cluster\n-\n-Hedwig console client is shipped with hedwig server package.\n-\n-p. To start the console client:\n-\n- @hedwig-server/bin/hedwig console@\n-\n-p. By default, the console client connects to hub server on localhost. If you want the console client to connect to a different hub server, you can override following environment variables.\n-\n-| @HEDWIG_CONSOLE_SERVER_CONF@ | Path of a hub server configuration file. Override to make hedwig console client connect to correct zookeeper cluster. |\n-| @HEDWIG_CONSOLE_CLIENT_CONF@ | Path of a hedwig client configuration file. Override to make hedwig console client communicate with correct hub servers. |\n-\n-p. Once connected, you should see something like:\n-\n-<pre>\n-Connecting to zookeeper/bookkeeper using HedwigAdmin\n-\n-Connecting to default hub server localhost/127.0.0.1:4080\n-Welcome to Hedwig!\n-JLine support is enabled\n-JLine history support is enabled\n-[hedwig: (standalone) 16] \n-</pre>\n-\n-p. From the shell, type __help__ to get a list of commands that can be executed from the client:\n-\n-<pre>\n-[hedwig: (standalone) 16] help\n-HedwigConsole [options] [command] [args]\n-\n-Available commands:\n-        pub\n-        sub\n-        closesub\n-        unsub\n-        rmsub\n-        consume\n-        consumeto\n-        pubsub\n-        show\n-        describe\n-        readtopic\n-        set\n-        history\n-        redo\n-        help\n-        quit\n-        exit\n-\n-Finished 0.0020 s.\n-</pre>\n-\n-p. If you want to know detail usage for each command, type __help {command}__ in the shell. For example:\n-\n-<pre>\n-[hedwig: (standalone) 17] help pub\n-pub: Publish a message to a topic in Hedwig\n-usage: pub {topic} {message}\n-\n-  {topic}   : topic name.\n-              any printable string without spaces.\n-  {message} : message body.\n-              remaining arguments are used as message body to publish.\n-\n-Finished 0.0 s.\n-</pre>\n-\n-h2. Commands\n-\n-All the available commands provided in hedwig console could be categorized into three groups. They are __interactive commands__, __admin commands__, __utility commands__.\n-\n-h3. Interactive Commands\n-\n-p. Interactive commands are used by users to communicate with a hedwig cluster. They are __pub__, __sub__, __closesub__, __unsub__, __consume__ and __consumeto__.\n-\n-p. These commands are quite simple and have same semantics as the API provided in hedwig client.\n-\n-h3.  Admin Commands\n-\n-p. Admin commands are used by administrators to operate or debug a hedwig cluster. They are __show__, __describe__, __pubsub__ and __readtopic__.\n-\n-p. __show__ is used to list all available hub servers or topics in the cluster.\n-\n-p. You could use __show__ to list hub servers to know how many hub servers are alive in the cluster.\n-\n-<pre>\n-[hedwig: (standalone) 27] show hubs\n-Available Hub Servers:\n-        192.168.1.102:4080:9876 :       0\n-Finished 0.0040 s.\n-</pre>\n-\n-p. Also, you could use __show__ to list all topics. If you have a lot of topics on the clusters, this command will take a long time to run.\n-\n-<pre>\n-[hedwig: (standalone) 28] show topics\n-Topic List:\n-[mytopic]\n-Finished 0.0020 s.\n-</pre>\n-\n-p. To see the details of a topic, run __describe__. This shows the metadata of a topic, including topic owner, persistence info, subscriptions info.\n-\n-<pre>\n-[hedwig: (standalone) 43] describe topic mytopic\n-===== Topic Information : mytopic =====\n-\n-Owner : 192.168.1.102:4080:9876\n-\n->>> Persistence Info <<<\n-Ledger 3 [ 1 ~ 9 ]\n-\n->>> Subscription Info <<<\n-Subscriber mysub : consumeSeqId: local:0\n-\n-Finished 0.011 s.\n-</pre>\n-\n-p. When you are run the __describe__ command, you should keep in mind that __describe__ command reads the metadata from __ZooKeeper__ directly, so the subscription info might not be completely up to date due to the fact that hub servers update the subscription metadata lazily.\n-\n-p. The __readtopic__ command is useful to see which messages have not been consumed by the client.\n-\n-<pre>\n-[hedwig: (standalone) 46] readtopic mytopic\n-\n->>>>> Ledger 3 [ 1 ~ 9] <<<<<\n-\n----------- MSGID=LOCAL(1) ----------\n-MsgId:     LOCAL(1)\n-SrcRegion: standalone\n-Message:\n-\n-hello\n-\n----------- MSGID=LOCAL(2) ----------\n-MsgId:     LOCAL(2)\n-SrcRegion: standalone\n-Message:\n-\n-hello 2\n-\n----------- MSGID=LOCAL(3) ----------\n-MsgId:     LOCAL(3)\n-SrcRegion: standalone\n-Message:\n-\n-hello 3\n-\n-...\n-</pre>\n-\n-p. __pubsub__ is another useful command for administrators. It can be used to test availability and functionality of a cluster. It generates a temporary subscriber id with the current timestamp, subscribes to the given topic using generated subscriber id, publishes a message to given topic and testes whether the subscriber received the message.\n-\n-<pre>\n-[hedwig: (standalone) 48] pubsub testtopic testsub- 10 test message for availability\n-Starting PUBSUB test ...\n-Sub topic testtopic, subscriber id testsub--1338126964504\n-Pub topic testtopic : test message for availability-1338126964504\n-Received message : test message for availability-1338126964504\n-PUBSUB SUCCESS. TIME: 377 MS\n-Finished 0.388 s.\n-</pre>\n-\n-h3. Utility Commands\n-\n-p. Utility Commands are __help__, __history__, __redo__, __quit__ and __exit__.\n-\n-p. __quit__ and __exit__ are used to exit console, while __history__ and __redo__ are used to manage the history of commands executed in the shell."},{"sha":"e56c0d19569831941517566c8679c39a0f3831d8","filename":"doc/hedwigDesign.textile","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigDesign.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigDesign.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigDesign.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,72 +0,0 @@\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .        \n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-\n-h1. Style\n-\n-We have provided an Eclipse Formatter file @formatter.xml@ with all the formatting conventions currently used in the project. Highlights include no tabs, 4-space indentation, and 120-char width. Please respect this so as to reduce the amount of formatting-related noise produced in commits.\n-\n-h1. Static Analysis\n-\n-We would like to use static analysis tools PMD and FindBugs to maintain code quality. However, we have not yet arrived at a consensus on what rules to adhere to, and what to ignore.\n-\n-h1. Netty Notes\n-\n-The asynchronous network IO infrastructure that Hedwig uses is \"Netty\":http://www.jboss.org/netty. Here are some notes on Netty's concurrency architecture and its filter pipeline design.\n-\n-h2. Concurrency Architecture\n-\n-After calling @ServerBootstrap.bind()@, Netty starts a boss thread (@NioServerSocketPipelineSink.Boss@) that just accepts new connections and registers them with one of the workers from the @NioWorker@ pool in round-robin fashion (pool size defaults to CPU count). Each worker runs its own select loop over just the set of keys that have been registered with it. Workers start lazily on demand and run only so long as there are interested fd's/keys. All selected events are handled in the same thread and sent up the pipeline attached to the channel (this association is established by the boss as soon as a new connection is accepted).\n-\n-All workers, and the boss, run via the executor thread pool; hence, the executor must support at least two simultaneous threads.\n-\n-h2. Handler Pipeline\n-\n-A pipeline implements the intercepting filter pattern. A pipeline is a sequence of handlers. Whenever a packet is read from the wire, it travels up the stream, stopping at each handler that can handle upstream events. Vice-versa for writes. Between each filter, control flows back through the centralized pipeline, and a linked list of contexts keeps track of where we are in the pipeline (one context object per handler).\n-\n-\n-h1. Pseudocode\n-\n-This summarizes the control flow through the system.\n-\n-h2. publish\n-\n-Need to document\n-\n-h2. subscribe\n-\n-Need to document\n-\n-h1. ReadAhead Cache\n-\n-The delivery manager class is responsible for pushing published messages from the hubs to the subscribers. The most common case is that all subscribers are connected and either caught up, or close to the tail end of the topic. In this case, we don't want the delivery manager to be polling bookkeeper for any newly arrived messages on the topic; new messages should just be pushed to the delivery manager. However, there is also the uncommon case when a subscriber is behind, and messages must be pulled from Bookkeeper.\n-\n-Since all publishes go through the hub, it is possible to cache the recently published messages in the hub, and then the delivery manager won't have to make the trip to bookkeeper to get the messages but instead get them from local process memory.\n-\n-These ideas of push, pull, and caching are unified in the following way: - A hub has a cache of messages\n-\n-* When the delivery manager wants to deliver a message, it asks the cache for it. There are 3 cases:\n-* The message is available in the cache, in which case it is given to the delivery manager\n-* The message is not present in the cache and the seq-id of the message is beyond the last message published on that topic (this happens if the subscriber is totally caught up for that topic). In this case, a stub is put in the cache in order to notify the delivery manager when that message does happen to be published.\n-* The message is not in the cache but has been published to the topic. In this case, a stub is put in the cache, and a read is issued to bookkeeper.\n-* Whenever a message is published, it is cached. If there is a stub already in the cache for that message, the delivery manager is notified.\n-* Whenever a message is read from bookkeeper, it is cached. There must be a stub for that message (since reads to bookkeeper are issued only after putting a stub), so the delivery manager is notified.\n-* The cache does readahead, i.e., if a message requested by the delivery manager is not in the cache, a stub is established not only for that message, but also for the next n messages where n is configurable (default 10). On a cache hit, we look ahead n/2 messages, and if that message is not present, we establish another n/2 stubs. In short, we always ensure that the next n stubs are always established.\n-* Over time, the cache will grow in size. There are 2 pruning mechanisms:\n-* Once all subscribers have consumed up to a particular seq-id, they notify the cache, and all messages up to that seq-id are pruned from the cache.\n-* If the above pruning is not working (e.g., because some subscribers are down), the cache will eventually hit its size limit which is configurable\n- (default, half of maximum jvm heap size). At this point, messages are just pruned in FIFO order. We use the size of the blobs in the message for estimating the cache size. The assumption is that that size will dominate over fixed, object-level size overheads.\n-* Stubs are not purged because according to the above simplification, they are of 0 size.\n-\n-h1. Scalability Bottlenecks Down the Road\n-\n-* Currently each topic subscription is served on a different channel. The number of channels will become a bottleneck at higher channels. We should switch to an architecture, where multiple topic subscriptions between the same client, hub pair should be served on the same channel. We can have commands to start, stop subscriptions sent all the way to the server (right now these are local).\n-* Publishes for a topic are serialized through a hub, to get ordering guarantees. Currently, all subscriptions to that topic are served from the same hub. If we start having large number of subscribers to heavy-volume topics, the outbound bandwidth at the hub, or the CPU at that hub might become the bottleneck. In that case, we can setup other regions through which the messages are routed (this hierarchical scheme) reduces bandwidth requirements at any single node. It should be possible to do this entirely through configuration.\n-"},{"sha":"06075c09de2431f952481b721ddce8d665fac28b","filename":"doc/hedwigDocs.textile","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigDocs.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigDocs.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigDocs.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,31 +0,0 @@\n-Title:     Hedwig Documentation\n-Notice:    Licensed to the Apache Software Foundation (ASF) under one\n-           or more contributor license agreements.  See the NOTICE file\n-           distributed with this work for additional information\n-           regarding copyright ownership.  The ASF licenses this file\n-           to you under the Apache License, Version 2.0 (the\n-           \"License\"); you may not use this file except in compliance\n-           with the License.  You may obtain a copy of the License at\n-           .\n-             http://www.apache.org/licenses/LICENSE-2.0\n-           .\n-           Unless required by applicable law or agreed to in writing,\n-           software distributed under the License is distributed on an\n-           \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-           KIND, either express or implied.  See the License for the\n-           specific language governing permissions and limitations\n-           under the License.\n-\n-h1. Apache Hedwig documentation\n-\n-* \"Building Hedwig, or how to set up Hedwig\":./hedwigBuild.html\n-* \"User's Guide, or how to program against the Hedwig API and how to run it\":./hedwigUser.html\n-* \"Developer's Guide, or Hedwig internals and hacking details\":./hedwigDesign.html\n-* \"Configuration parameters\":./hedwigParams.html\n-* \"Message Filtering\":./hedwigMessageFilter.html\n-* \"Hedwig Metadata Management\":./hedwigMetadata.html\n-\n-h2. Hedwig Admin & Ops\n-\n-* \"Hedwig Console\":./hedwigConsole.html\n-* \"Hedwig JMX\":./hedwigJMX.html"},{"sha":"4c694993a8f0599155f649a1fe5a190c7682edb4","filename":"doc/hedwigJMX.textile","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigJMX.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigJMX.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigJMX.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,32 +0,0 @@\n-Title:        Hedwig JMX\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .\n-        .        \n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-        .\n-\n-h1. JMX\n-\n-Apache Hedwig has extensive support for JMX, which allows viewing and managing a hedwig cluster.\n-\n-This document assumes that you have basic knowledge of JMX. See \"Sun JMX Technology\":http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/ page to get started with JMX.\n-\n-See the \"JMX Management Guide\":http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html for details on setting up local and remote management of VM instances. By default the included __hedwig__ script supports only local management - review the linked document to enable support for remote management (beyond the scope of this document).\n-\n-__Hub Server__ is a JMX manageable server, which registers the proper MBeans during initialization to support JMX monitoring and management of the instance.\n-\n-h1. Hub Server MBean Reference\n-\n-This table details JMX for a hub server.\n-\n-| _.MBean | _.MBean Object Name | _.Description |\n-| PubSubServer | PubSubServer | Represents a hub server. It is the root MBean for hub server, which includes statistics for a hub server. E.g. number packets sent/received/redirected, and statistics for pub/sub/unsub/consume operations. |\n-| NettyHandlers | NettyHandler | Provide statistics for netty handlers. Currently it just returns number of subscription channels established to a hub server. |\n-| ReadAheadCache | ReadAheadCache | Provide read ahead cache statistics. |"},{"sha":"d5ca21ff210ae1768da8066d1a24c0b64202dd68","filename":"doc/hedwigMessageFilter.textile","status":"removed","additions":0,"deletions":76,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigMessageFilter.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigMessageFilter.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigMessageFilter.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,76 +0,0 @@\n-Title:        Hedwig Message Filter\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .\n-        .\n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-        .\n-\n-h1. Message Filter\n-\n-Apache Hedwig provides an efficient mechanism for supporting application-defined __message filtering__.\n-\n-h2. Message\n-\n-Most message-oriented middleware (MOM) products treat messages as lightweight entities that consist of a header and a payload. The header contains fields used for message routing and identification; the payload contains the application data being sent.\n-\n-Hedwig messages follow a similar template, being composed of following parts:\n-\n-* @Header@ - All messages support both system defined fields and application defined property values. Properties provide an efficient mechanism for supporting application-defined message filtering.\n-* @Body@ - Hedwig considers the message body as a opaque binary blob.\n-* @SrcRegion@ - Indicates where the message comes from.\n-* @MessageSeqId@ - The unique message sequence id assigned by Hedwig.\n-\n-h3. Message Header Properties\n-\n-A __Message__ object contains a built-in facility for supporting application-defined property values. In effect, this provides a mechanism for adding application-specific header fields to a message.\n-\n-By using properties and  __message filters__, an application can have Hedwig select, or filter, messages on its behalf using application-specific criteria.\n-\n-Property names must be a __String__ and must not be null, while property values are binary blobs. The flexibility of binary blobs allows applications to define their own serialize/deserialize functions, allowing structured data to be stored in the message header.\n-\n-h2. Message Filter\n-\n-A __Message Filter__ allows an application to specify, via header properties, the messages it is interested in. Only messages which pass validation of a __Message Filter__, specified by a subscriber, are be delivered to the subscriber.\n-\n-A message filter could be run either on the __server side__ or on the __client side__. For both __server side__ and __client side__, a __Message Filter__ implementation needs to implement the following two interfaces:\n-\n-* @setSubscriptionPreferences(topic, subscriberId, preferences)@: The __subscription preferences__ of the subscriber will be passed to message filter when it was attached to its subscription either on the server-side or on the client-side.\n-* @testMessage(message)@: Used to test whether a particular message passes the filter or not.\n-\n-The __subscription preferences__ are used to specify the messages that the user is interested in. The __message filter__ uses the __subscription preferences__ to decide which messages are passed to the user.\n-\n-Take a book store(using topic __BookStore__) as an example:\n-\n-# User A may only care about History books. He subscribes to __BookStore__ with his custom preferences : type=\"History\".\n-# User B may only care about Romance books. He subscribes to __BookStore__ with his custom preferences : type=\"Romance\".\n-# A new book arrives at the book store; a message is sent to __BookStore__ with type=\"History\" in its header\n-# The message is then delivered to __BookStore__'s subscribers.\n-# Subscriber A filters the message by checking messages' header to accept those messages whose type is \"History\".\n-# Subscriber B filters out the message, as the type does not match its preferences.\n-\n-h3. Client Message Filter.\n-\n-A __ClientMessageFilter__ runs on the client side. Each subscriber can write its own filter and pass it as a parameter when starting delivery ( __startDelivery(topic, subscriberId, messageHandler, messageFilter)__ ).\n-\n-h3. Server Message Filter.\n-\n-A __ServerMessageFilter__ runs on the server side (a hub server). A hub server instantiates a server message filter, by means of reflection, using the message filter class specified in the subscription preferences which are provided by the subscriber. Since __ServerMessageFilter__s run on the hub server, all filtered-out messages are never delivered to client, reducing unnecessary network traffic. Hedwig uses a implementation of __ServerMessageFilter__ to filter unnecessary message deliveries between regions.\n-\n-Since hub servers use reflection to instantiate a __ServerMessageFilter__, an implementation of __ServerMessageFilter__ needs to implement two additional methods:\n-\n-* @initialize(conf)@: Initialize the message filter before filtering messages.\n-* @uninitialize()@: Uninitialize the message filter to release resources used by the message filter.\n-\n-For the hub server to load the message filter, the implementation class must be in the server's classpath at startup.\n-\n-h3. Which message filter should be used?\n-\n-It depends on application requirements. Using a __ServerMessageFilter__ will reduce network traffic by filtering unnecessary messages, but it would compete for resources on the hub server(CPU, memory, etc). Conversely, __ClientMessageFilter__s have the advantage of inducing no extra load on the hub server, but at the price of higher network utilization. A filter can be installed both at the server side and on the client; Hedwig does not restrict this.\n-"},{"sha":"1add816dea118cbd6cbc6d1fbbb603893394b8b0","filename":"doc/hedwigMetadata.textile","status":"removed","additions":0,"deletions":123,"changes":123,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigMetadata.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigMetadata.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigMetadata.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,123 +0,0 @@\n-Title:        Hedwig Metadata Management\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .\n-        .\n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-        .\n-\n-h1. Metadata Management\n-\n-There are two classes of metadata that need to be managed in Hedwig: one is the __list of available hubs__, which is used to track server availability (ZooKeeper is designed naturally for this); while the other is for data structures to track __topic states__ and __subscription states__. This second class can be handled by any key/value store which provides ah __CAS (Compare And Set)__ operation. The metadata in this class are:\n-\n-* @Topic Ownership@: tracks which hub server is assigned to serve requests for a specific topic.\n-* @Topic Persistence Info@: records what __bookkeeper ledgers__ are used to store messages for a specific topic and their message id ranges.\n-* @Subscription Data@: records the preferences and subscription state for a specific subscription (topic, subscriber).\n-\n-Each kind of metadata is handled by a specific metadata manager. They are __TopicOwnershipManager__, __TopicPersistenceManager__ and __SubscriptionDataManager__.\n-\n-h2. Topic Ownership Management\n-\n-There are two ways to management topic ownership. One is leveraging ZooKeeper's ephemeral znodes to record the topic's owner info as a child ephemeral znode under its topic znode. When a hub server, owning a specific topic, crashes, the ephemeral znode which signifies topic ownership will be deleted due to the loss of the zookeeper session. Other hubs can then be assigned the ownership of the topic. The other one is to leverage the __CAS__ operation provided by key/value stores to do leader election. __CAS__ doesn't require the underlying key/value store to provide functionality similar to ZooKeeper's ephemeral nodes. With __CAS__ it is possible to guarantee that only one hub server gains the ownership for a specific topic, which is more scalable and generic solution.\n-\n-The implementation of a __TopicOwnershipManager__ is required to implement following methods:\n-\n-<pre><code>\n-\n-public void readOwnerInfo(ByteString topic, Callback<Versioned<HubInfo>> callback, Object ctx);\n-\n-public void writeOwnerInfo(ByteString topic, HubInfo owner, Version version,\n-                           Callback<Version> callback, Object ctx);\n-\n-public void deleteOwnerInfo(ByteString topic, Version version,\n-                            Callback<Void> callback, Object ctx);\n-\n-</code></pre>\n-\n-* @readOwnerInfo@: Read the owner info from the underlying key/value store. The implementation should take the responsibility of deserializing the metadata into a __HubInfo__ object identifying a hub server. Also, its current __version__ needs to be returned for future updates. If there is no owner info found for a topic, null value is returned.\n-\n-* @writeOwnerInfo@: Write the owner info into the underlying key/value store with the given __version__. If the current __version__ in underlying key/value store doesn't equal to the provided __version__, the write should be rejected with __BadVersionException__. The new __version__ should be returned for a successful write. __NoTopicOwnerInfoException__ is returned if no owner info found for a topic.\n-\n-* @deleteOwnerInfo@: Delete the owner info from key/value store with the given __version__. The owner info should be removed if the current __version__ in key/value store is equal to the provided __version__. Otherwise, the deletion should be rejected with __BadVersionException__. __NoTopicOwnerInfoException__ is returned if no owner info is found for the topic.\n-\n-h2. Topic Persistence Info Management\n-\n-Similar as __TopicOwnershipManager__, an implementation of __TopicPersistenceManager__ is required to implement READ/WRITE/DELETE interfaces as below:\n-\n-<pre><code>\n-public void readTopicPersistenceInfo(ByteString topic,\n-                                     Callback<Versioned<LedgerRanges>> callback, Object ctx);\n-\n-public void writeTopicPersistenceInfo(ByteString topic, LedgerRanges ranges, Version version,\n-                                      Callback<Version> callback, Object ctx);\n-\n-public void deleteTopicPersistenceInfo(ByteString topic, Version version,\n-                                       Callback<Void> callback, Object ctx);\n-</code></pre>\n-\n-* @readTopicPersistenceInfo@: Read the persistence info from the underlying key/value store. The implementation should take the responsibility of deserializing the metadata into a __LedgerRanges__ object includes the ledgers used to store messages. Also, its current __version__ needs to be returned for future updates. If there is no persistence info found for a topic, a null value is returned.\n-\n-* @writeTopicPersistenceInfo@: Write the persistence info into the underlying key/value store with the given __version__. If the current __version__ in the underlying key/value store doesn't equal the provided __version__, the write should be rejected with __BadVersionException__. The new __version__ should be returned on a successful write. __NoTopicPersistenceInfoException__ is returned if no persistence info is found for a topic.\n-\n-* @deleteTopicPersistenceInfo@: Delete the persistence info from the key/value store with the given __version__. The owner info should be removed if the current __version__ in the key/value store equals the provided __version__. Otherwise, the deletion should be rejected with __BadVersionException__. __NoTopicPersistenceInfoException__ is returned if no persistence info is found for a topic.\n-\n-h2. Subscription Data Management\n-\n-__SubscriptionDataManager__ has similar READ/CREATE/WRITE/DELETE interfaces as other managers. Besides that, the implementation needs to implement __READ SUBSCRIPTIONS__ interface, which is to fetch all the subscriptions for a given topic.\n-\n-<pre><code>\n-public void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n-                                   Callback<Version> callback, Object ctx);\n-\n-public boolean isPartialUpdateSupported();\n-\n-public void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToUpdate, \n-                                   Version version, Callback<Version> callback, Object ctx);\n-\n-public void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToReplace,\n-                                    Version version, Callback<Version> callback, Object ctx);\n-\n-public void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Version version,\n-                                   Callback<Void> callback, Object ctx);\n-\n-public void readSubscriptionData(ByteString topic, ByteString subscriberId,\n-                                 Callback<Versioned<SubscriptionData>> callback, Object ctx);\n-\n-public void readSubscriptions(ByteString topic, Callback<Map<ByteString, Versioned<SubscriptionData>>> cb,\n-                              Object ctx);\n-</code></pre>\n-\n-h3. Create/Update Subscriptions\n-\n-The metadata for a subscription includes two parts, one is preferences and the other one is subscription state. __SubscriptionPreferences__ tracks all the preferences for a subscriber (etc. Application could store its customized preferences for message filtering), while __SubscriptionState__ is used internally to track the message consumption state for a given subscriber. These two kinds of metadata are quite different: __SubscriptionPreferences__ is not updated\n-frequently while __SubscriptionState__ is be updated frequently when messages are consumed. If the underlying key/value store supports independent field update for a given key (subscription), __SubscriptionPreferences__ and __SubscriptionState__ could be stored as two different fields for a given subscription. In this case __isPartialUpdateSupported__ should return true. Otherwise, __isPartialUpdateSupported__ should return false and the implementation should serialize/deserialize __SubscriptionData__ as an opaque blob.\n-\n-* @createSubscriptionData@: Create a subscription entry for a given topic. The initial __version__ would be returned for a success creation. __SubscriptionStateExistsException__ is returned if the subscription entry already exists.\n-\n-* @updateSubscriptionData/replaceSubscriptionData@: Update/replace the subscription data in the underlying key/value store with the given __version__. If the current __version__ in underlying key/value store doesn't equal to the provided __version__, the update should be rejected with __BadVersionException__. The new __version__ should be returned for a successful write. __NoSubscriptionStateException__ is returned if no subscription entry is found for a subscription (topic, subscriber).\n-\n-h3. Read Subscriptions\n-\n-* @readSubscriptionData@: Read the subscription data from the underlying key/value store. The implementation should take the responsibility of deserializing the metadata into a __SubscriptionData__ object including its preferences and subscription state. Also, its current __version__ needs to be returned for future updates. If there is no subscription data found for a subscription, a null value is returned.\n-\n-* @readSubscriptions@: Read all the subscription data from key/value store for a given topic. The implementation should take the responsibility of managing all subscription for a topic for efficient access.  An empty map is returned if there are no subscriptions found for a given topic.\n-\n-h3. Delete Subscription\n-\n-* @deleteSubscriptionData@: Delete the subscription data from the key/value store with given __version__ for a specific subscription (topic, subscriber). The subscription info should be removed if current __version__ in key/value store equals the provided __version__. Otherwise, the deletion should be rejected with __BadVersionException__. __NoSubscriptionStateException__ is returned if no subscription data is found for a subscription (topic, subscriber).\n-\n-h1. How to choose a key/value store for Hedwig.\n-\n-From the interface, several requirements needs to meet before picking up a key/value store for Hedwig:\n-\n-* @CAS@: The ability to do strict updates according to specific condition, i.e. a specific version (ZooKeeper) and same content (HBase).\n-* @Optimized for Writes@: The metadata access pattern for Hedwig is read first and continuous updates.\n-* @Optimized for retrieving all subscriptions for a topic@: Either hierarchical structures to maintain such relationships (ZooKeeper), or ordered key/value storage to cluster the subscription for a topic together, would provide efficient subscription data management.\n-\n-__ZooKeeper__ is the default implementation for Hedwig metadata management, which holds data in memory and provides filesystem-like namespace, meeting the above requirements. __ZooKeeper__ is suitable for most Hedwig usecases. However, if your application needs to manage millions of topics/subscriptions, a more scalable solution would be __HBase__, which also meet the above requirements."},{"sha":"ea01be671a7481532b1a49a49820b38b16f81119","filename":"doc/hedwigParams.textile","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigParams.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigParams.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigParams.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,92 +0,0 @@\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .        \n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-        \n-h1. Hedwig configuration parameters        \n-        \n-This page contains detailed information about configuration parameters used for Hubs, Regions, ZooKeeper, and BookKeeper.\n-        \n-h2. Hedwig server configuration parameters\n-\n-Please also refer to the configuration file that comes with the distribution: _hedwig-server/conf/hw_server.conf_.  \n-\n-h3. Region related parameters\n-\n-| @region@ | Region identifier. Default is \"standalone\". |\n-| @regions@ | List of region identifiers, space separated. Default is empty. |\n-| @inter_region_ssl_enabled (deprecated)@ | Enables SSL across regions. Default is false. *Since this parameter has been deprecated, use __ssl_enabled__ in _hedwig-server/conf/hw_region_client.conf_ to enable SSL across regions instead.* |\n-| @retry_remote_subscribe_thread_run_interval@ | This parameter is used to determine how often we run a thread to retry those failed remote subscriptions in asynchronous mode (in milliseconds). Default is 2 minutes. |\n-\n-h3. Hub server parameters\n-\n-| @standalone@ | Sets the hub server to run in standalone mode (no regions). Default is false. |\n-| @server_port@ | Sets the server port that receives client connections. Default is 4080. |\n-| @ssl_enabled@ | Enables SSL. Default is false. |\n-| @ssl_server_port@ | Sets the server port for SSL connections. Default is 9876. | \n-| @password@ | Password used for pkcs12 certificate.. Default is the empty string. |\n-| @cert_name@ | Sets the name of the SSL certificate if available as a resource. Default is the null string. |\n-| @cert_path@ | Sets the path to the SSL certificate if it is available as a file. Default is the null string. |\n-\n-h3. Read-ahead cache parameters\n-\n-| @readahead_enabled@ | Enables read-ahead. Enabled by default. | \n-| @readahead_count@ | Number of messages to read ahead. Default is 10. |\n-| @readahead_size@ | Maximum number of bytes to read during a scan. Default is 4 megabytes. |\n-\n-bq. Upon a range scan request for a given topic, two hints are provided as to when scanning should stop: the number of messages scanned and the total size of messages scanned. Scanning stops whenever one of these limits is exceeded.\n-\n-| @cache_size@ | Sets the size of the read-ahead cache. Default is the smallest of 2G or half the heap size. | \n-| @cache_entry_ttl@ | Sets TTL for cache entries. Each time adding new entry into the cache, those expired cache entries would be discarded. If the value is set to zero or less than zero, cache entry will not be evicted until the cache is fullfilled or the messages are already consumed. Default is 0. |\n-| @scan_backoff_ms@ | The backoff time (in milliseconds) to retry scans after failures. Default value is 1s (1000ms). Default is 1s. |\n-| @num_readahead_cache_threads@ | Sets the number of threads to be used for the read-ahead mechanism. Default is the number of cores as returned with a call to <code>Runtime.getRuntime().availableProcessors()</code>.|\n-\n-h3. Publish and subscription parameters \n-\n-| @max_message_size@ | Sets the maximum message size. Default is 1.2 megabytes. |\n-| @default_message_window_size@ | This parameter is used for setting the default maximum number of messages that can be delivered to a subscriber without being consumed. We pause delivery to a subscriber when reaching the window size. Default is unlimited (0). |\n-| @consume_interval@ | Sets the number of messages consumed before persisting information about consumed messages. A value greater than one avoids persisting information about consumed messages upon every consumed message. Default is 50.|\n-| @retention_secs@ | the interval to release a topic. If this parameter is greater than zero, then schedule a task to release an owned topic. Default is 0 (never released).\n-| @messages_consumed_thread_run_interval@ | Time interval (in milliseconds) to run messages consumed timer task to\n-delete those consumed ledgers in BookKeeper. Default is 1 minute (60,000 ms). |\n-\n-\n-h3. ZooKeeper parameters\n- \n-| @zk_host@ | Sets the ZooKeeper list of servers. Default is localhost:2181. |\n-| @zk_timeout@ | Sets the ZooKeeper session timeout. Default is 2s. |\n-\n-h3. BookKeeper parameters\n-\n-| @bk_ensemble_size@ | Sets the ensemble size. Default is 3. |\n-| @bk_write_quorum_size@ | Sets the write quorum size. Default is 2. |\n-| @bk_ack_quorum_size@ | Sets the ack quorum size. Default is 2. |\n-\n-bq. Note that the ack quorum size must be equal or smaller than the write quorum size.\n-\n-| @max_entries_per_ledger@ | Maximum number of entries before we roll a ledger. Default is unlimited (0). |\n-\n-h3. Metadata parameters\n-\n-| @zk_prefix@ | Sets the ZooKeeper path prefix. Default is _/hedwig_. |\n-| @metadata_manager_based_topic_manager_enabled@ | Enables the use of a metadata manager for topic management. Default is false. |\n-| @metadata_manager_factory_class@ | Sets the default factory for the metadata manager. Default is null. |\n-\n-h2. Region manager configuration parameters\n-\n-Please also refer to the configuration file that comes with the distribution: _hedwig-server/conf/hw_region_client.conf_.\n-\n-| @ssl_enabled@ | This parameter is a boolean flag indicating if communication with the server should be done via SSL for encryption. The Hedwig server hubs also need to be SSL enabled for this to work. Default value is false. |\n-| @max_message_size@ | Sets the maximum message size in bytes. The default value is 2 MB (2097152). |\n-| @max_server_redirects@ | Sets the maximum number of redirects we permit before signaling an error. Default value is 2. |\n-| @auto_send_consume_message_enabled@ | A flag indicating whether the client library should automatically send consume messages to the server. Default value is true. |\n-| @consumed_messages_buffer_size@ | Sets the number of messages we buffer before sending a consume message to the server. Default value is 5. |\n-| @max_outstanding_messages@ | Support for client side throttling, sets the maximum number of outstanding messages. Default value is 10. |\n-| @server_ack_response_timeout@ | Sets the timeout (in milliseconds) before we error out any existing requests. Default value is 30s (30,000). |\n-        "},{"sha":"58ff1cf1546ed9544ba732e3cd53b8cf1ad20731","filename":"doc/hedwigUser.textile","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigUser.textile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/doc/hedwigUser.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigUser.textile?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,63 +0,0 @@\n-Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n-        you may not use this file except in compliance with the License. You may\n-        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n-        .        \n-        Unless required by applicable law or agreed to in writing,\n-        software distributed under the License is distributed on an \"AS IS\"\n-        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-        implied. See the License for the specific language governing permissions\n-        and limitations under the License.\n-        .\n-\n-h1. Design\n-\n-In Hedwig, clients publish messages associated with a topic, and they subscribe to a topic to receive all messages published with that topic. Clients are associated with (publish to and subscribe from) a Hedwig _instance_ (also referred to as a _region_), which consists of a number of servers called _hubs_. The hubs partition up topic ownership among themselves, and all publishes and subscribes to a topic must be done to its owning hub. When a client doesn't know the owning hub, it tries a default hub, which may redirect the client.\n-\n-Running a Hedwig instance requires a Zookeeper server and at least three Bookkeeper servers.\n-\n-An instance is designed to run within a datacenter. For wide-area messaging across datacenters, specify in the server configuration the set of default servers for each of the other instances. Dissemination among instances currently takes place over an all-to-all topology. Local subscriptions cause the hub to subscribe to all other regions on this topic, so that the local region receives all updates to it. Future work includes allowing the user to overlay alternative topologies.\n-\n-Because all messages on a topic go through a single hub per region, all messages within a region are ordered. This means that, for a given topic, messages are delivered in the same order to all subscribers within a region, and messages from any particular region are delivered in the same order to all subscribers globally, but messages from different regions may be delivered in different orders to different regions. Providing global ordering is prohibitively expensive in the wide area. However, in Hedwig clients such as PNUTS, the lack of global ordering is not a problem, as PNUTS serializes all updates to a table row at a single designated master for that row.\n-\n-Topics are independent; Hedwig provides no ordering across different topics.\n-\n-Version vectors are associated with each topic and serve as the identifiers for each message. Vectors consist of one component per region. A component value is the region's local sequence number on the topic, and is incremented each time a hub persists a message (published either locally or remotely) to BK.\n-\n-TODO: More on how version vectors are to be used, and on maintaining vector-maxes.\n-\n-h1. Entry Points\n-\n-The main class for running the server is @org.apache.hedwig.server.netty.PubSubServer@. It takes a single argument, which is a \"Commons Configuration\":http://commons.apache.org/configuration/ file. Currently, for configuration, the source is the documentation. See @org.apache.hedwig.server.conf.ServerConfiguration@ for server configuration parameters.\n-\n-The client is a library intended to be consumed by user applications. It takes a Commons Configuration object, for which the source/documentation is in @org.apache.hedwig.client.conf.ClientConfiguration@.\n-\n-h1. Deployment\n-\n-h2. Limits\n-\n-Because the current implementation uses a single socket per subscription, the Hedwig requires a high @ulimit@ on the number of open file descriptors. Non-root users can only use up to the limit specified in @/etc/security/limits.conf@; to raise this to 1024^2, as root, modify the &quot;nofile&quot; line in /etc/security/limits.conf on all hubs.\n-\n-h2. Running Servers\n-\n-Hedwig requires BookKeeper to run. For BookKeeper setup instructions see \"BookKeeper Getting Started\":./bookkeeperStarted.html.\n-\n-To start a Hedwig hub server:\n-\n-@hedwig-server/bin/hedwig server@\n-\n-Hedwig takes its configuration from hedwig-server/conf/hw_server.conf by default. To change location of the conf file, modify the HEDWIG_SERVER_CONF environment variable.\n-\n-h1. Debugging\n-\n-You can attach an Eclipse debugger (or any debugger) to a Java process running on a remote host, as long as it has been started with the appropriate JVM flags. (See the Building Hedwig document to set up your Eclipse environment.) To launch something using @bin/hedwig@ with debugger attachment enabled, prefix the command with @HEDWIG_EXTRA_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,address=5000@, e.g.:\n-\n-@HEDWIG_EXTRA_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,address=5000 hedwig-server/bin/hedwig server@\n-\n-h1. Logging\n-\n-Hedwig uses \"slf4j\":http://www.slf4j.org for logging, with the log4j bindings enabled by default. To enable logging from hedwig, create a log4j.properties file and point the environment variable HEDWIG_LOG_CONF to the file. The path to the log4j.properties file must be absolute.\n-\n-@export HEDWIG_LOG_CONF=/tmp/log4j.properties@\n-@hedwig-server/bin/hedwig server@\n-\n-"},{"sha":"97553cc4128832512a1dc00face2ace42d98cf17","filename":"doc/index.textile","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/doc/index.textile","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/doc/index.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/index.textile?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -26,8 +26,6 @@ Once familiar with the basic concepts, developers can consult the \"BookKeeper Ja\n \n *Contributor* documentation is less organized, \"BookKeeper Internals\":./bookkeeperInternals.html is a good place to start. From there you can check out our \"wiki\":https://cwiki.apache.org/confluence/display/BOOKKEEPER/Index and ask questions on our \"mailing lists\":/lists.html or \"IRC\":/irc.html.\n \n-Hedwig documentation can be found \"here\":./hedwigDocs.html.\n-\n h3. All documents\n \n * Overview"},{"sha":"b3fb314f9432dbb4b06aac103b4a7afb449c05ba","filename":"doc/metastore.textile","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/doc/metastore.textile","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/doc/metastore.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/metastore.textile?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -14,11 +14,11 @@ Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n \n h1. Metastore Interface\n \n-Although Apache BookKeeper provides \"LedgerManager\":./bookkeeperMetadata.html and \"Hedwig Metadata Managers\":./hedwigMetadata.html for users to plugin different metadata storages for both BookKeeper and Hedwig, it is quite difficult to implement a correct and efficient manager version based on the knowledge for both projects. The __MetaStore__ interface extracts the commonality of the metadata storage interfaces and is provided for users to focus on adapting the underlying storage itself w/o having to worry about the detailed logic for BookKeeper and Hedwig.\n+Although Apache BookKeeper provides \"LedgerManager\":./bookkeeperMetadata.html for users to plugin different metadata storages for BookKeeper, it is quite difficult to implement a correct and efficient manager version based on the knowledge. The __MetaStore__ interface extracts the commonality of the metadata storage interfaces and is provided for users to focus on adapting the underlying storage itself w/o having to worry about the detailed logic for BookKeeper.\n \n h2. MetaStore\n \n-The __MetaStore__ interface provide users with access to __MetastoreTable__s used for BookKeeper and Hedwig metadata management. There are two kinds of table defined in a __MetaStore__, __MetastoreTable__ which provides basic __PUT__,__GET__,__REMOVE__,__SCAN__ operations and which does not assume any ordering requirements from the underlying storage; and __MetastoreScannableTable__ which is derived from __MetastoreTable__, but *does* assume that data is stored in key order in the underlying storage.\n+The __MetaStore__ interface provide users with access to __MetastoreTable__s used for BookKeeper metadata management. There are two kinds of table defined in a __MetaStore__, __MetastoreTable__ which provides basic __PUT__,__GET__,__REMOVE__,__SCAN__ operations and which does not assume any ordering requirements from the underlying storage; and __MetastoreScannableTable__ which is derived from __MetastoreTable__, but *does* assume that data is stored in key order in the underlying storage.\n \n * @getName@: Return the name of the __MetaStore__.\n * @getVersion@: Return current __MetaStore__ plugin version.\n@@ -44,4 +44,4 @@ __MetastoreScannableTable__ is identical to a __MetastoreTable__ except that it\n \n h2. How to organize your metadata.\n \n-Some metadata in Hedwig and BookKeeper does not need to be stored in the order of the ledger id or the topic. You could use kind of hash table to store metadata for them. These metadata are topic ownership and topic persistence info. Besides that, subscription state and ledger metadata must be stored in key order due to the current logic in Hedwig/BookKeeper.\n+Some metadata in BookKeeper does not need to be stored in the order of the ledger id or the topic. You could use kind of hash table to store metadata for them. These metadata are topic ownership and topic persistence info. Besides that, subscription state and ledger metadata must be stored in key order due to the current logic in BookKeeper."},{"sha":"b8648e0702aa3a832df16dc7d7efdd4898c6f2bf","filename":"formatter.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/formatter.xml","raw_url":"https://github.com/apache/bookkeeper/raw/9a8d62b1d1231f2fe6feca7e0c407a426a1278d5/formatter.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/formatter.xml?ref=9a8d62b1d1231f2fe6feca7e0c407a426a1278d5","patch":"@@ -17,7 +17,7 @@\n \r\n <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n <profiles version=\"11\">\r\n-<profile kind=\"CodeFormatterProfile\" name=\"Hedwig\" version=\"11\">\r\n+<profile kind=\"CodeFormatterProfile\" name=\"BookKeeper\" version=\"11\">\r\n <setting id=\"org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags\" value=\"insert\"/>\r\n <setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation\" value=\"insert\"/>\r\n <setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters\" value=\"do not insert\"/>\r"},{"sha":"744885e7710a6ff6ff6d346abd91e62e8d4500bf","filename":"hedwig-client-jms/pom.xml","status":"removed","additions":0,"deletions":301,"changes":301,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/pom.xml?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,301 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\n-         xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n-  <modelVersion>4.0.0</modelVersion>\n-  <parent>\n-    <groupId>org.apache.bookkeeper</groupId>\n-    <artifactId>bookkeeper</artifactId>\n-    <version>4.4.0-SNAPSHOT</version>\n-  </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n-  <artifactId>hedwig-client-jms</artifactId>\n-  <name>hedwig-client-jms</name>\n-  <url>http://maven.apache.org</url>\n-\n-  <dependencies>\n-    <dependency>\n-      <groupId>com.google.protobuf</groupId>\n-      <artifactId>protobuf-java</artifactId>\n-      <version>2.4.1</version>\n-      <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>junit</groupId>\n-      <artifactId>junit</artifactId>\n-      <version>4.8.1</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <!-- As suggested by Matthieu - Using geronimo-spec-jms instead of ver=1.1, groupId=java.jms, artifcatId=jms -->\n-    <dependency>\n-      <groupId>geronimo-spec</groupId>\n-      <artifactId>geronimo-spec-jms</artifactId>\n-      <version>1.1-rc4</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-client</artifactId>\n-      <version>${project.parent.version}</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-protocol</artifactId>\n-      <version>${project.parent.version}</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server</artifactId>\n-      <version>${project.parent.version}</version>\n-      <scope>test</scope>\n-      <type>test-jar</type>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-server</artifactId>\n-      <version>${project.parent.version}</version>\n-      <scope>test</scope>\n-      <type>test-jar</type>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>hedwig-server</artifactId>\n-      <version>${project.parent.version}</version>\n-      <scope>test</scope>\n-      <type>jar</type>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.bookkeeper</groupId>\n-      <artifactId>bookkeeper-server</artifactId>\n-      <version>${project.parent.version}</version>\n-      <scope>test</scope>\n-      <type>jar</type>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.zookeeper</groupId>\n-      <artifactId>zookeeper</artifactId>\n-      <version>${zookeeper.version}</version>\n-      <type>test-jar</type>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>log4j</groupId>\n-      <artifactId>log4j</artifactId>\n-      <version>1.2.15</version>\n-      <scope>provided</scope>\n-      <exclusions>\n-        <exclusion>\n-          <groupId>javax.mail</groupId>\n-          <artifactId>mail</artifactId>\n-        </exclusion>\n-        <exclusion>\n-          <groupId>javax.jms</groupId>\n-          <artifactId>jms</artifactId>\n-        </exclusion>\n-        <exclusion>\n-          <groupId>com.sun.jdmk</groupId>\n-          <artifactId>jmxtools</artifactId>\n-        </exclusion>\n-        <exclusion>\n-          <groupId>com.sun.jmx</groupId>\n-          <artifactId>jmxri</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-  </dependencies>\n-\n-  <build>\n-    <testResources>\n-      <testResource>\n-        <directory>src/test/resources</directory>\n-        <includes>\n-          <include>log4j.properties</include>\n-        </includes>\n-      </testResource>\n-    </testResources>\n-    <plugins>\n-      <plugin>\n-        <groupId>org.codehaus.mojo</groupId>\n-        <artifactId>javacc-maven-plugin</artifactId>\n-        <version>2.6</version>\n-        <executions>\n-          <execution>\n-            <id>jjtree-javacc</id>\n-            <goals>\n-              <goal>jjtree-javacc</goal>\n-            </goals>\n-            <configuration>\n-              <sourceDirectory>${basedir}/src/main/grammar/javacc</sourceDirectory>\n-              <packageName>org.apache.hedwig.jms.selector</packageName>\n-            </configuration>\n-            <phase>generate-sources</phase>\n-          </execution>\n-        </executions>\n-      </plugin>\n-\n-      <plugin>\n-        <groupId>org.apache.maven.plugins</groupId>\n-        <artifactId>maven-surefire-plugin</artifactId>\n-        <version>2.9</version>\n-        <configuration>\n-          <!-- Skip the default running of this plug-in (or everything is run twice...see below) -->\n-          <skip>true</skip>\n-          <!-- Show 100% of the lines from the stack trace (doesn't work ?) -->\n-          <trimStackTrace>false</trimStackTrace>\n-          <systemProperties>\n-            <property>\n-              <name>log4j.configuration</name>\n-              <value>log4j.properties</value>\n-            </property>\n-            <property>\n-              <name>java.net.preferIPv4Stack</name>\n-              <value>true</value>\n-            </property>\n-            <property>\n-              <name>com.sun.management.jmxremote</name>\n-              <value>true</value>\n-            </property>\n-            <property>\n-              <name>com.sun.management.jmxremote.local.only</name>\n-              <value>true</value>\n-            </property>\n-            <property>\n-              <name>com.sun.management.jmxremote.ssl</name>\n-              <value>false</value>\n-            </property>\n-            <property>\n-              <name>com.sun.management.jmxremote.authenticate</name>\n-              <value>false</value>\n-            </property>\n-            <property>\n-              <name>java.rmi.server.hostname</name>\n-              <value>localhost</value>\n-            </property>\n-            <!--\n-                <property>\n-                <name>com.sun.management.jmxremote.port</name>\n-                <value>39999</value>\n-                </property>\n-            -->\n-          </systemProperties>\n-          <!-- <forkMode>always</forkMode> -->\n-          <forkMode>pertest</forkMode>\n-          <argLine>-Xmx1G</argLine>\n-        </configuration>\n-\n-        <executions>\n-          <execution>\n-            <id>unit-tests</id>\n-            <phase>test</phase>\n-            <goals>\n-              <goal>test</goal>\n-            </goals>\n-            <configuration>\n-              <skip>false</skip>\n-              <!-- run everything other than activemq testcases -->\n-              <excludes>\n-                <exclude>org/apache/activemq/**/Test*.java</exclude>\n-                <exclude>org/apache/activemq/**/*Test.java</exclude>\n-                <exclude>org/apache/activemq/**/*TestCase.java</exclude>\n-              </excludes>\n-            </configuration>\n-          </execution>\n-        </executions>\n-      </plugin>\n-\n-      <plugin>\n-        <groupId>org.apache.rat</groupId>\n-        <artifactId>apache-rat-plugin</artifactId>\n-        <version>0.7</version>\n-        <configuration>\n-          <excludes>\n-            <!-- exclude generated file //-->\n-            <exclude>**/JmsHeader.java</exclude>\n-          </excludes>\n-        </configuration>\n-      </plugin>\n-\n-      <plugin>\n-        <groupId>org.codehaus.mojo</groupId>\n-        <artifactId>findbugs-maven-plugin</artifactId>\n-        <configuration>\n-          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile>\n-        </configuration>\n-      </plugin>\n-\n-    </plugins>\n-  </build>\n-  <profiles>\n-    <profile>\n-      <id>protobuf</id>\n-      <build>\n-        <plugins>\n-          <plugin>\n-            <artifactId>maven-antrun-plugin</artifactId>\n-            <executions>\n-              <execution>\n-                <phase>generate-sources</phase>\n-                <id>default-cli</id>\n-                <configuration>\n-                  <target>\n-                    <exec executable=\"protoc\" failonerror=\"true\">\n-                      <arg value=\"--java_out=src/main/java\" />\n-                      <arg value=\"src/main/protobuf/JmsHeader.proto\" />\n-                    </exec>\n-                  </target>\n-                </configuration>\n-                <goals>\n-                  <goal>run</goal>\n-                </goals>\n-              </execution>\n-            </executions>\n-          </plugin>\n-        </plugins>\n-      </build>\n-    </profile>\n-    <profile>\n-      <id>activemqtests</id>\n-      <build>\n-        <plugins>\n-          <plugin>\n-            <groupId>org.apache.maven.plugins</groupId>\n-            <artifactId>maven-surefire-plugin</artifactId>\n-            <version>2.9</version>\n-            <executions>\n-              <execution>\n-                <id>integration-tests</id>\n-                <phase>test</phase>\n-                <goals>\n-                  <goal>test</goal>\n-                </goals>\n-                <configuration>\n-                  <skip>false</skip>\n-                  <includes>\n-                    <!-- run the activemq testcases -->\n-                    <include>org/apache/activemq/**/Test*.java</include>\n-                    <include>org/apache/activemq/**/*Test.java</include>\n-                    <include>org/apache/activemq/**/*TestCase.java</include>\n-                  </includes>\n-                </configuration>\n-              </execution>\n-            </executions>\n-          </plugin>\n-        </plugins>\n-      </build>\n-    </profile>\n-  </profiles>\n-</project>"},{"sha":"b118681733b0d7a33883b614d6687aae70802874","filename":"hedwig-client-jms/src/main/grammar/javacc/readme.html","status":"removed","additions":0,"deletions":26,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/grammar/javacc/readme.html","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/grammar/javacc/readme.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/grammar/javacc/readme.html?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,26 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-\n-Contains the grammar to define and support selectors in our JMS provider. <br/>\n-Maven handles generation of the code based on this, and the JMS provider code has rest of the\n-implementation which depends on this generated code to implement selectors in our provider.<br/>\n-Please refer to <a href=\"../../java/org/apache/hedwig/jms/selector/package-info.html\">\n-../../java/org/apache/hedwig/jms/selector/package-info.html</a> for more information. <br/>\n-\n-<p/>\n-Based loosely off java and sql grammar from javacc."},{"sha":"a141b8b51338f06569618c6b3b6bf27155c56b2c","filename":"hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt","status":"removed","additions":0,"deletions":689,"changes":689,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,689 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-/* This is based on the Java1.0.2.jj grammar */\n-\n-options {\n-  MULTI=true;\n-  // JAVA_UNICODE_ESCAPE = true;\n-  // LOOKAHEAD = 1;\n-  FORCE_LA_CHECK = false;\n-  NODE_EXTENDS=\"MyNode\";\n-  VISITOR = true;\n-  STATIC = false;\n-  VISITOR_DATA_TYPE = \"SelectorEvalState\";\n-  VISITOR_EXCEPTION = \"SelectorEvaluationException\";\n-\n-/*\n-  DEBUG_PARSER = true ;\n-  DEBUG_LOOKAHEAD = true ;\n-  DEBUG_TOKEN_MANAGER = true ;\n-  */\n-}\n-\n-PARSER_BEGIN(SelectorParser)\n-\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.message.MessageImpl;\n-import org.apache.hedwig.jms.message.TextMessageImpl;\n-\n-import java.io.StringReader;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.LinkedHashMap;\n-\n-\n-public class SelectorParser {\n-\n-  // It contains no state (as of now).\n-  private static final InterpretSelectorParserVisitor interpreter = new InterpretSelectorParserVisitor();\n-  private static final TreeDumperSelectorParserVisitor treeDumper = new TreeDumperSelectorParserVisitor();\n-\n-  public static Boolean evaluateSelector(final Node ast, final MessageImpl message) {\n-  if (MyNode.logger.isTraceEnabled()) {\n-      MyNode.logger.trace(\"--- Dump AST START ---\");\n-      try {\n-        ast.jjtAccept(treeDumper, new SelectorEvalState(null));\n-      } catch (SelectorEvaluationException e) {\n-        MyNode.logger.trace(\"Unable to run debug visitor \" + message + \", exception : \" + e + \" ... ignoring.\", e);\n-      }\n-      MyNode.logger.trace(\"--- Dump AST DONE---\");\n-    }\n-    final SelectorEvalState data = new SelectorEvalState(message);\n-    try {\n-        ast.jjtAccept(interpreter, data);\n-        if (1 != data.getStack().size() ||\n-                SelectorConstant.SelectorDataType.BOOLEAN != data.getStack().peek().type){\n-            if (MyNode.logger.isDebugEnabled())\n-                MyNode.logger.debug(\"Expected only a single boolean in stack, obtained : \" + data.getStack());\n-            return null;\n-        }\n-        return data.getStack().peek().getBoolValue();\n-    } catch (SelectorEvaluationException e) {\n-        if (MyNode.logger.isDebugEnabled())\n-            MyNode.logger.debug(\"Unable to run interpreter on \" + message + \", exception : \"\n-                                + e + \" ... ignoring message\", e);\n-        return null;\n-    }\n-  }\n-\n-  private static final int CACHED_AST_SIZE = Integer.getInteger(\"CACHED_AST_SIZE\", 128);\n-  private static final LinkedHashMap<String, Node> parsedSelectorCache\n-       = new LinkedHashMap<String, Node>(CACHED_AST_SIZE, 0.75f, true){\n-    @Override\n-    protected boolean removeEldestEntry(Map.Entry<String, Node> eldest) {\n-      return size() > CACHED_AST_SIZE;\n-    }\n-  };\n-\n-  public static Node parseMessageSelector(String messageSelector) throws ParseException {\n-    if (MyNode.logger.isTraceEnabled()) {\n-      MyNode.logger.trace(\"Parse '\" + messageSelector + \"'\");\n-    }\n-    synchronized (parsedSelectorCache){\n-      if (parsedSelectorCache.containsKey(messageSelector)) return parsedSelectorCache.get(messageSelector);\n-    }\n-    Node retval = null;\n-    try {\n-      SelectorParser parser = new SelectorParser(new StringReader(messageSelector));\n-      parser.Expression();\n-      retval = parser.jjtree.rootNode();\n-      return retval;\n-    } catch (TokenMgrError rmErr){\n-      // It throws an error ! seriously ? ... sigh !\n-      if (MyNode.logger.isDebugEnabled()) {\n-        MyNode.logger.debug(\"Unable to parse selector expression - recieved error \", rmErr);\n-      }\n-      throw new ParseException(rmErr.toString());\n-    } finally {\n-        synchronized (parsedSelectorCache){\n-          parsedSelectorCache.put(messageSelector, retval);\n-        }\n-    }\n-  }\n-\n-  public static void main(String[] args) throws ParseException, SelectorEvaluationException  {\n-      MessageImpl message = new TextMessageImpl(null, \"test\");\n-      SelectorEvalState data = new SelectorEvalState(message);\n-      SelectorParserVisitor visitor = new InterpretSelectorParserVisitor();\n-      for (String arg : args){\n-          Node node = parseMessageSelector(arg);\n-          node.jjtAccept(visitor, data);\n-\n-          if (1 != data.getStack().size()){\n-            throw new IllegalArgumentException(\"Invalid proposition '\" + arg\n-                                               + \"'. Unexpected result stack : \" + data.getStack());\n-          }\n-          else System.out.println(\"Result : \" + data.getStack().peek());\n-      }\n-  }\n-\n-  private String unescapeSingleQuotes(String str){\n-    final int len = str.length();\n-    final StringBuilder retval = new StringBuilder();\n-\n-    int offset = 0;\n-    while (true){\n-      int indx = str.indexOf('\\'', offset);\n-      if (-1 == indx) break;\n-      if (indx + 1 >= len) break;\n-\n-      retval.append(str.substring(offset, indx + 1));\n-      offset = indx + 1;\n-      if ('\\'' == str.charAt(indx + 1)) offset ++;\n-    }\n-    if (offset < len) retval.append(str.substring(offset));\n-    return retval.toString();\n-  }\n-\n-  public String parseString(final Token token, boolean canBeNull) throws ParseException{\n-    if (canBeNull && null == token) return null;\n-\n-    final String str = token.image;\n-    final int len = str.length();\n-    if (len >= 2 && '\\'' == str.charAt(0) && '\\'' == str.charAt(len - 1)){\n-      String tstr = str.substring(1, len - 1);\n-      tstr = unescapeSingleQuotes(tstr);\n-      return tstr;\n-    }\n-    if (!\"''\".equals(str)) throw new ParseException(\"Unexpected string : \" + str);\n-    return \"\";\n-  }\n-\n-  public String parseString(final Token token) throws ParseException{\n-    return parseString(token, false);\n-  }\n-\n-  public String parseIdentifier(Token identifier) throws ParseException{\n-    // nothing to parse actually ...\n-    final String identifierName = identifier.image;\n-    if (\"null\".equalsIgnoreCase(identifierName) ||\n-          \"true\".equalsIgnoreCase(identifierName) ||\n-          \"false\".equalsIgnoreCase(identifierName)){\n-      throw new ParseException(\"Invalid identifier name : \" + identifierName);\n-    }\n-\n-    if (\"NOT\".equalsIgnoreCase(identifierName) ||\n-          \"AND\".equalsIgnoreCase(identifierName) ||\n-          \"OR\".equalsIgnoreCase(identifierName) ||\n-          \"BETWEEN\".equalsIgnoreCase(identifierName) ||\n-          \"LIKE\".equalsIgnoreCase(identifierName) ||\n-          \"IN\".equalsIgnoreCase(identifierName) ||\n-          \"IS\".equalsIgnoreCase(identifierName) ||\n-          \"ESCAPE\".equalsIgnoreCase(identifierName)){\n-      throw new ParseException(\"Invalid identifier name : \" + identifierName);\n-    }\n-\n-    return identifierName;\n-  }\n-}\n-\n-\n-PARSER_END(SelectorParser)\n-\n-SKIP : /* WHITE SPACE */\n-{\n-  \" \"\n-| \"\\t\"\n-| \"\\n\"\n-| \"\\r\"\n-| \"\\f\"\n-}\n-\n-/*\n-SKIP :\n-{\n-  \" \"\n-| \"\\t\"\n-| \"\\f\"\n-}\n-*/\n-\n-// As per 3.8.1.3 Special Notes, I SHOULD NOT be supporting SQL comments ... but what the heck :-)\n-/* COMMENTS */\n-/*\n-SKIP:\n-{\n-  <SINGLE_LINE_COMMENT: \"--\" (~[\"\\n\",\"\\r\"])* (\"\\n\"|\"\\r\"|\"\\r\\n\")>\n-| <MULTI_LINE_COMMENT: \"/*\" (~[\"*\"])* \"*\" (\"*\" | (~[\"*\",\"/\"] (~[\"*\"])* \"*\"))* \"/\">\n-}\n-*/\n-\n-TOKEN : /* SEPARATORS */\n-{\n-  < LPAREN: \"(\" >\n-| < RPAREN: \")\" >\n-}\n-\n-TOKEN : /* OPERATORS */\n-{\n-  < EQ: \"=\" >\n-| < GT: \">\" >\n-| < LT: \"<\" >\n-| < LE: \"<=\" >\n-| < GE: \">=\" >\n-| < NE: \"<>\" >\n-\n-| < PLUS: \"+\" >\n-| < MINUS: \"-\" >\n-| < STAR: \"*\" >\n-| < SLASH: \"/\" >\n-| < COMMA: \",\" >\n-}\n-\n-TOKEN[IGNORE_CASE] :\n-{\n-\n-  < NULL : \"NULL\" >\n-\n-| < NOT : \"NOT\" >\n-| < AND : \"AND\" >\n-| < OR : \"OR\" >\n-\n-| < BETWEEN : \"BETWEEN\" >\n-| < LIKE : \"LIKE\" >\n-| < IN : \"IN\" >\n-| < IS : \"IS\" >\n-| < ESCAPE : \"ESCAPE\" >\n-}\n-\n-\n-\n-TOKEN[IGNORE_CASE] : /* Boolean literal - case-insensitive */\n-{\n-  < BOOLEAN_LITERAL: \"true\" | \"false\" >\n-}\n-\n-\n-TOKEN : /* IDENTIFIER */\n-{\n-  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >\n-|\n-  < #LETTER:\n-      [\n-       \"\\u0024\",\n-       \"\\u0041\"-\"\\u005a\",\n-       \"\\u005f\",\n-       \"\\u0061\"-\"\\u007a\",\n-       \"\\u00c0\"-\"\\u00d6\",\n-       \"\\u00d8\"-\"\\u00f6\",\n-       \"\\u00f8\"-\"\\u00ff\",\n-       \"\\u0100\"-\"\\u1fff\",\n-       \"\\u3040\"-\"\\u318f\",\n-       \"\\u3300\"-\"\\u337f\",\n-       \"\\u3400\"-\"\\u3d2d\",\n-       \"\\u4e00\"-\"\\u9fff\",\n-       \"\\uf900\"-\"\\ufaff\"\n-      ]\n-  >\n-|\n-  < #DIGIT:\n-      [\n-       \"\\u0030\"-\"\\u0039\",\n-       \"\\u0660\"-\"\\u0669\",\n-       \"\\u06f0\"-\"\\u06f9\",\n-       \"\\u0966\"-\"\\u096f\",\n-       \"\\u09e6\"-\"\\u09ef\",\n-       \"\\u0a66\"-\"\\u0a6f\",\n-       \"\\u0ae6\"-\"\\u0aef\",\n-       \"\\u0b66\"-\"\\u0b6f\",\n-       \"\\u0be7\"-\"\\u0bef\",\n-       \"\\u0c66\"-\"\\u0c6f\",\n-       \"\\u0ce6\"-\"\\u0cef\",\n-       \"\\u0d66\"-\"\\u0d6f\",\n-       \"\\u0e50\"-\"\\u0e59\",\n-       \"\\u0ed0\"-\"\\u0ed9\",\n-       \"\\u1040\"-\"\\u1049\"\n-      ]\n-  >\n-}\n-\n-\n-TOKEN : /* LITERALS */\n-{\n-  < FLOATING_POINT_LITERAL:\n-    // ([\"+\",\"-\"])?\n-      (\n-        ([\"0\"-\"9\"])+ \".\" ([\"0\"-\"9\"])* (<EXPONENT>)? ([\"f\",\"F\",\"d\",\"D\"])?\n-      | \".\" ([\"0\"-\"9\"])+ (<EXPONENT>)? ([\"f\",\"F\",\"d\",\"D\"])?\n-      | ([\"0\"-\"9\"])+ <EXPONENT> ([\"f\",\"F\",\"d\",\"D\"])?\n-      | ([\"0\"-\"9\"])+ (<EXPONENT>)? [\"f\",\"F\",\"d\",\"D\"]\n-      )\n-  >\n-|\n-  < #EXPONENT: [\"e\",\"E\"] ([\"+\",\"-\"])? ([\"0\"-\"9\"])+ >\n-|\n-  // Scrapping the earlier more complicated definition of string listern.\n-  // This is not required on second thoughts - a simpler definition will suffice.\n-   < STRING_LITERAL: \"'\" (~[\"'\"])* \"'\" (\"'\" (~[\"'\"])* \"'\")*>\n-  |\n-  < INTEGER_LITERAL: // ([\"+\",\"-\"])?\n-    [\"0\"-\"9\"] ([\"0\"-\"9\"])* >\n-}\n-\n-\n-\n-\n-void Expression () #void : {}\n-{\n-  ExpressionChoice()\n-  <EOF>\n-}\n-\n-void ExpressionChoice() #void : {}\n-{\n-  LOOKAHEAD(OrLogicalTerm())\n-  OrLogicalTerm() |\n-\n-  AndLogicalTermChoice()\n-}\n-\n-void OrLogicalTerm () #void : {}\n-{\n-  AndLogicalTermChoice() (\n-    ( ( <OR> AndLogicalTermChoice() )\n-      {\n-        jjtThis.setExprFunction(LogicalComparisonFunction.OR_FUNCTION);\n-      }\n-    ) #OrExpr(2)\n-  ) +\n-}\n-\n-void AndLogicalTermChoice() #void : {}\n-{\n-  LOOKAHEAD(AndLogicalTerm())\n-  AndLogicalTerm() |\n-\n-  NotLogicalTermChoice()\n-}\n-\n-void AndLogicalTerm () #void : {}\n-{\n-  NotLogicalTermChoice() (\n-    ( ( <AND> NotLogicalTermChoice() )\n-      {\n-        jjtThis.setExprFunction(LogicalComparisonFunction.AND_FUNCTION);\n-      }\n-    ) #AndExpr(2)\n-  ) +\n-}\n-\n-void NotLogicalTermChoice() #void : {}\n-{\n-  LOOKAHEAD(NotLogicalTerm())\n-  NotLogicalTerm() |\n-\n-  RelationTermChoice()\n-}\n-\n-void NotLogicalTerm () #void : {}\n-{\n-  ( ( <NOT> RelationTermChoice() )\n-    {\n-      jjtThis.setExprFunction(UnaryExprFunction.NOT_FUNCTION);\n-    }\n-  ) #NotExpr(1)\n-}\n-\n-void RelationTermChoice () #void : {}\n-{\n-  LOOKAHEAD(RelationTermOptions())\n-  RelationTermOptions() |\n-\n-  ArithmeticTermChoice()\n-}\n-\n-void RelationTermOptions() #void : {}\n-{\n-\n-  ArithmeticTermChoice()\n-\n-  (\n-    ( ( <GT> ArithmeticTermChoice() )\n-      {\n-        jjtThis.setExprFunction(ValueComparisonFunction.GREATER_THAN_FUNCTION);\n-      }\n-    ) #GreaterThan(2) |\n-\n-    ( ( <LT> ArithmeticTermChoice() )\n-      {\n-        jjtThis.setExprFunction(ValueComparisonFunction.LESS_THAN_FUNCTION);\n-      }\n-    ) #LessThan(2) |\n-\n-    ( ( <LE> ArithmeticTermChoice() )\n-      {\n-        jjtThis.setExprFunction(ValueComparisonFunction.LESS_THAN_EQUAL_TO_FUNCTION);\n-      }\n-    ) #LessThanEqualTo(2) |\n-\n-    ( ( <GE> ArithmeticTermChoice() )\n-      {\n-        jjtThis.setExprFunction(ValueComparisonFunction.GREATER_THAN_EQUAL_TO_FUNCTION);\n-      }\n-    ) #GreaterThanEqualTo(2) |\n-\n-    ( ( <EQ> ArithmeticTermChoice() )\n-      {\n-        jjtThis.setExprFunction(ValueComparisonFunction.EQUAL_TO_FUNCTION);\n-      }\n-    ) #EqualTo(2) |\n-\n-    ( ( <NE> ArithmeticTermChoice() )\n-      {\n-        jjtThis.setExprFunction(ValueComparisonFunction.NOT_EQUAL_TO_FUNCTION);\n-      }\n-    ) #NotEqualTo(2) |\n-\n-\n-    LOOKAHEAD(IsNullTerm())\n-    // LOOKAHEAD(2)\n-    IsNullTerm() |\n-\n-    LOOKAHEAD(BetweenTerm())\n-    // LOOKAHEAD(2)\n-    BetweenTerm() |\n-\n-    LOOKAHEAD(InTerm())\n-    // LOOKAHEAD(2)\n-    InTerm() |\n-\n-    LOOKAHEAD(LikeTerm())\n-    // LOOKAHEAD(2)\n-    LikeTerm()\n-  )\n-\n-}\n-\n-\n-\n-void IsNullTerm() #void : {\n-  Token notToken = null;\n-}\n-{\n-  ( ( <IS> ( notToken=<NOT> )? <NULL> )\n-    {\n-      jjtThis.setExprFunction(new PropertyExprFunction.IsNullExpr(null != notToken));\n-    } ) #IsNullExpr(1)\n-}\n-\n-\n-void BetweenTerm() #void : {\n-  Token notToken = null;\n-}\n-{\n-\n-  ( ( ( notToken=<NOT> )? <BETWEEN> ArithmeticTermChoice() <AND> ArithmeticTermChoice() )\n-  {\n-    jjtThis.setExprFunction(new PropertyExprFunction.BetweenExpr(null != notToken));\n-  } ) #BetweenExpr(3)\n-}\n-\n-\n-void InTerm() #void : {\n-  Token notToken = null;\n-}\n-{\n-  ( ( ( notToken=<NOT> )? <IN> <LPAREN> StringVarargParams() <RPAREN> )\n-  {\n-      jjtThis.setExprFunction(new PropertyExprFunction.InExpr(null != notToken));\n-  } ) #InExpr(2)\n-}\n-\n-void LikeTerm() #void : {\n-  Token notToken = null;\n-  Token likePattern = null;\n-  Token escapeCharacter = null;\n-}\n-{\n-  ( ( ( notToken=<NOT> )? <LIKE> likePattern=<STRING_LITERAL> ( <ESCAPE> escapeCharacter=<STRING_LITERAL> )? )\n-  {\n-    jjtThis.setExprFunction(new PropertyExprFunction.LikeExpr(\n-      parseString(likePattern),\n-      parseString(escapeCharacter, true),\n-      null != notToken));\n-  } ) #LikeExpr(1)\n-}\n-\n-\n-\n-\n-\n-void ArithmeticTermChoice () #void : {}\n-{\n-  LOOKAHEAD(AddTerm())\n-  AddTerm() |\n-\n-  MultTermChoice()\n-}\n-\n-void AddTerm () #void : {}\n-{\n-\n-  MultTermChoice() (\n-     ( (<PLUS> MultTermChoice() )\n-       {\n-         jjtThis.setExprFunction(BinaryArithmeticFunction.ADD_FUNCTION);\n-       }\n-     ) #AddExpr(2) |\n-\n-     ( (<MINUS> MultTermChoice() )\n-       {\n-         jjtThis.setExprFunction(BinaryArithmeticFunction.SUB_FUNCTION);\n-       }\n-     ) #SubExpr(2)\n-  ) +\n-}\n-\n-void MultTermChoice() #void : {}\n-{\n-  LOOKAHEAD(MultTerm())\n-  MultTerm() |\n-\n-  UnaryUnitChoice()\n-}\n-\n-void MultTerm() #void : {}\n-{\n-  UnaryUnitChoice() (\n-     ( ( <SLASH> UnaryUnitChoice() )\n-       {\n-         jjtThis.setExprFunction(BinaryArithmeticFunction.DIVIDE_FUNCTION);\n-       }\n-     ) #DivideExpr(2) |\n-\n-     ( ( <STAR> UnaryUnitChoice() )\n-     {\n-       jjtThis.setExprFunction(BinaryArithmeticFunction.MULTIPLY_FUNCTION);\n-     }\n-    ) #MultiplyExpr(2)\n-  ) +\n-}\n-\n-\n-void UnaryUnitChoice() #void : {}\n-{\n-  LOOKAHEAD(UnaryUnit())\n-  UnaryUnit() |\n-\n-  BasicUnit()\n-}\n-\n-void UnaryUnit() #void : {}\n-{\n-  LOOKAHEAD( <MINUS> BasicUnit() )\n-  ( ( <MINUS> BasicUnit() )\n-    {\n-      jjtThis.setExprFunction(UnaryArithmeticFunction.NEGATE_FUNCTION);\n-    }\n-  ) #NegateExpr(1) |\n-\n-  // Ignore if + value.\n-  LOOKAHEAD( <PLUS> BasicUnit() )\n-  ( ( <PLUS> BasicUnit() )\n-    {\n-      // noop\n-    }\n-  )\n-}\n-\n-void BasicUnit() #void :  {\n-  Token identifier = null;\n-}\n-{\n-  // An expression within braces for grouping\n-\n-  // LOOKAHEAD(<LPAREN> ExpressionChoice() <RPAREN>)\n-  (<LPAREN> ExpressionChoice() <RPAREN>) |\n-\n-  // LOOKAHEAD(Constant())\n-  Constant() |\n-\n-  // LOOKAHEAD(<IDENTIFIER>)\n-  ( ( identifier=<IDENTIFIER> )\n-  {\n-    jjtThis.setExprFunction(new PropertyExprFunction.LookupExpr(parseIdentifier(identifier)));\n-  } ) #LookupExpr(0)\n-}\n-\n-\n-\n-void Constant() : {\n-  Token bt, it, ft;\n-  Token st;\n-}\n-{\n-  bt=<BOOLEAN_LITERAL>\n-  {\n-    jjtThis.setConstantValue(new SelectorConstant(Boolean.parseBoolean(bt.image.toLowerCase())));\n-  } |\n-  ft=<FLOATING_POINT_LITERAL>\n-  {\n-    jjtThis.setConstantValue(new SelectorConstant(Double.parseDouble(ft.image)));\n-  }\n-  |\n-  st=<STRING_LITERAL>\n-  {\n-    jjtThis.setConstantValue(new SelectorConstant(parseString(st)));\n-  } |\n-  it=<INTEGER_LITERAL>\n-  {\n-    jjtThis.setConstantValue(new SelectorConstant(Integer.parseInt(it.image)));\n-  }\n-}\n-\n-\n-void StringVarargParams() : {\n-  Token st;\n-}\n-{\n-  st=<STRING_LITERAL>\n-  {\n-    Set<String> set = new HashSet<String>(4);\n-    set.add(parseString(st));\n-    jjtThis.setConstantValue(new SelectorConstant(set));\n-  }\n-\n-  ( ( <COMMA> st=<STRING_LITERAL> )\n-  {\n-    jjtThis.addToStringSet(parseString(st));\n-  }\n-  )*\n-\n-}"},{"sha":"1a77fcfeec29a5780c758a7e49a1440070b15cfd","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java","status":"removed","additions":0,"deletions":476,"changes":476,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,476 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.jms.Connection;\n-import javax.jms.ConnectionConsumer;\n-import javax.jms.ConnectionMetaData;\n-import javax.jms.Destination;\n-import javax.jms.ExceptionListener;\n-import javax.jms.InvalidClientIDException;\n-import javax.jms.JMSException;\n-import javax.jms.Queue;\n-import javax.jms.QueueConnection;\n-import javax.jms.ServerSessionPool;\n-import javax.jms.Topic;\n-import javax.jms.TopicConnection;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-/**\n- * Implementation of jmx Connection\n- * MUST be MT-safe (2.8)\n- */\n-public abstract class ConnectionImpl implements Connection, TopicConnection, QueueConnection {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ConnectionImpl.class);\n-\n-    // Copied from old HedwigConnectoin\n-    // TODO move to a constants class?\n-    public static final String HEDWIG_CLIENT_CONFIG_FILE = \"hedwig.client.config.file\";\n-    private static final Set<String> globalClientIdSet = new HashSet<String>(16);\n-\n-    private final String user;\n-    private final String password;\n-\n-    // Will be set to a random string if unspecified - we do not have a way (currently) for admin\n-    // specified value ...\n-    // Note, using the system property means\n-    // private String clientID = System.getProperty(\"HEDWIG_CLIENT_ID\", null);\n-    private volatile String clientID = null;\n-\n-    // I do not like locking on 'this' inspite of the perf diff - allows 'others' to lock on our\n-    // lock object (client code for example) : leaks MT-safety.\n-    private final Object lockObject = new Object();\n-\n-    // Call this when there are issues (primarily connection issues imo).\n-    // There are two issues with supporting this :\n-    // a) we do not follow jms featureSelection of connection -> multiple sessions; for us, connection does not\n-    // represent underlying connection to\n-    // hedwig, but session does. So the basic featureSelection does not fit.\n-    // b) from what I see, hedwig-client does not expose the ability to do this. (it automatically reconnects)\n-    // hence we do not support this yet.\n-    private volatile ExceptionListener exceptionListener;\n-\n-    // connection 'starts' in stopped mode.\n-    // Until it is started, NO messages MUST be delivered - 4.3.3\n-    private StateManager connectionState = new StateManager(StateManager.State.STOPPED, lockObject);\n-\n-    private final List<SessionImpl> sessionList = new ArrayList<SessionImpl>(4);\n-    private final ConnectionMetaData metadata = new ConnectionMetaDataImpl();\n-\n-    protected ConnectionImpl() {\n-        this.user = null;\n-        this.password = null;\n-    }\n-\n-    protected ConnectionImpl(String user, String password) {\n-        this.user = user;\n-        this.password = password;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public SessionImpl createSession(boolean transacted, int acknowledgeMode)  throws JMSException {\n-        return createSessionImpl(transacted, acknowledgeMode, null);\n-    }\n-\n-    protected SessionImpl createSessionImpl(boolean transacted, int acknowledgeMode,\n-                                            MessagingSessionFacade.DestinationType type)  throws JMSException {\n-        final boolean needStart;\n-        synchronized (lockObject){\n-            if (connectionState.isInCloseMode())\n-              throw new javax.jms.IllegalStateException(\"Connection closed\");\n-            if (connectionState.isTransitionState()) {\n-                connectionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                // Not expected actually, present to guard against future changes ...\n-                if (connectionState.isTransitionState())\n-                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                if (connectionState.isClosed()) throw new JMSException(\"Connection already closed\");\n-\n-            }\n-\n-            assert StateManager.State.STOPPED == connectionState.getCurrentState() ||\n-                    StateManager.State.STARTED == connectionState.getCurrentState();\n-\n-            // create within lock, so that it can register with connection, etc ...\n-            // session = new SessionImpl(this, transacted, acknowledgeMode);\n-            final SessionImpl session = createSessionInstance(transacted, acknowledgeMode, type);\n-            sessionList.add(session);\n-            needStart = connectionState.isStarted();\n-\n-            if (needStart) session.start();\n-            return session;\n-        }\n-    }\n-\n-    protected abstract SessionImpl createSessionInstance(boolean transacted, int acknowledgeMode,\n-                                                         MessagingSessionFacade.DestinationType type)\n-        throws JMSException;\n-\n-    public boolean removeSession(SessionImpl session){\n-        // simply remove.\n-        synchronized (lockObject){\n-            return sessionList.remove(session);\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public String getClientID() {\n-        return clientID;\n-    }\n-\n-    /**\n-     * Allow clientID to be set only if it is NOT administratively configured for connection. (4.3.2)\n-     * Since we do not work (yet) within the context of a container, this aspect is a TODO for now.\n-     *\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void setClientID(String clientID) throws InvalidClientIDException, javax.jms.IllegalStateException {\n-        if (null == clientID) throw new InvalidClientIDException(\"clientId specified is null\");\n-\n-        synchronized (globalClientIdSet){\n-            if (globalClientIdSet.contains(clientID))\n-              throw new InvalidClientIDException(\"clientId '\" + clientID + \"' already in use in this provider\");\n-            if (null != this.clientID && !this.clientID.equals(clientID))\n-              throw new javax.jms.IllegalStateException(\"clientID already set to \" + this.clientID +\n-                  \", cant override to \" + clientID);\n-            this.clientID = clientID;\n-            globalClientIdSet.add(clientID);\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public ConnectionMetaData getMetaData() throws JMSException {\n-        // return new ConnectionMetaDataImpl();\n-        return metadata;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public ExceptionListener getExceptionListener() throws JMSException {\n-        return exceptionListener;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void setExceptionListener(ExceptionListener exceptionListener) throws JMSException {\n-        this.exceptionListener = exceptionListener;\n-    }\n-\n-    public void initConnectionClientID() throws javax.jms.IllegalStateException, InvalidClientIDException {\n-        synchronized (lockObject){\n-            // default to hedwig_client_id ?\n-            if (null == clientID) setClientID(SessionImpl.generateRandomString());\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void start() throws JMSException {\n-\n-        final StateManager.State prevState;\n-        final List<SessionImpl> sessionListCopy;\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Attempting to start connection\");\n-\n-        synchronized (lockObject){\n-            if (connectionState.isStarted()) return ;\n-            if (connectionState.isClosed()) throw new JMSException(\"Connection already closed\");\n-\n-            if (connectionState.isTransitionState()){\n-                connectionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                // Not expected actually, present to guard against future changes ...\n-                if (connectionState.isTransitionState())\n-                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                if (connectionState.isClosed()) throw new JMSException(\"Connection already closed\");\n-                if (connectionState.isStarted()) return ;\n-\n-                assert connectionState.isStopped();\n-                // try again ...\n-            }\n-\n-            prevState = connectionState.getCurrentState();\n-            connectionState.setCurrentState(StateManager.State.STARTING);\n-            initConnectionClientID();\n-            sessionListCopy = new ArrayList<SessionImpl>(sessionList);\n-        }\n-\n-        StateManager.State nextState = prevState;\n-        try {\n-            // There will be only one thread down here ...\n-\n-            // start any provider specific implementation bootstrap ...\n-            doStart(user, password);\n-            // Copy to prevent concurrent mod exceptions.\n-            if (logger.isTraceEnabled()) logger.trace(\"Starting \" + sessionListCopy.size() + \" sessions\");\n-            for (SessionImpl session : sessionListCopy) {\n-                try {\n-                    session.start();\n-                } catch (JMSException jex){\n-                    // log the error and ignore\n-                    if (logger.isInfoEnabled()) logger.info(\"exception starting session : \" + jex);\n-                    DebugUtil.dumpJMSStacktrace(logger, jex);\n-                }\n-            }\n-            nextState = StateManager.State.STARTED;\n-        } finally {\n-            // set status and notify.\n-            synchronized (lockObject){\n-                connectionState.setCurrentState(nextState);\n-                lockObject.notifyAll();\n-            }\n-        }\n-    }\n-\n-\n-    protected String getUser(){\n-        return user;\n-    }\n-    protected String getPassword(){\n-        return password;\n-    }\n-\n-    protected abstract void doStart(String user, String password) throws JMSException;\n-    protected abstract void doStop();\n-    protected abstract void doClose();\n-\n-    @Override\n-    public void stop() throws JMSException {\n-\n-        final StateManager.State prevState;\n-        final List<SessionImpl> sessionListCopy;\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Attempting to stop connection\");\n-\n-        synchronized (lockObject){\n-            if (connectionState.isClosed()) throw new JMSException(\"Already closed\");\n-            if (connectionState.isStopped()) return ;\n-\n-            if (connectionState.isTransitionState()){\n-                connectionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                // Not expected actually, present to guard against future changes ...\n-                if (connectionState.isTransitionState())\n-                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                if (connectionState.isClosed()) throw new JMSException(\"Already closed\");\n-                if (connectionState.isStopped()) return ;\n-\n-                assert connectionState.isStarted();\n-\n-                // try (again ?) ...\n-            }\n-\n-            prevState = connectionState.getCurrentState();\n-            connectionState.setCurrentState(StateManager.State.STOPPING);\n-            sessionListCopy = new ArrayList<SessionImpl>(sessionList);\n-        }\n-\n-        StateManager.State nextState = prevState;\n-        try {\n-            // In case there are any specific changes to be done.\n-            // Copy to prevent concurrent mod exceptions.\n-\n-            // Stop all sessions - doing this within MT-safe block to prevent any possibility of race conditions.\n-            // Potentially expensive, but it is a tradeoff between correctness and performance :-(\n-            if (logger.isTraceEnabled()) logger.trace(\"Stopping \" + sessionListCopy.size() + \" sessions\");\n-            for (SessionImpl session : sessionListCopy) {\n-                try {\n-                    session.stop();\n-                } catch (JMSException jex){\n-                    // log the error and ignore\n-                    if (logger.isInfoEnabled()) logger.info(\"exception closing session : \" + jex);\n-                    DebugUtil.dumpJMSStacktrace(logger, jex);\n-                }\n-            }\n-            // stop connection AFTER session's are stopped.\n-            doStop();\n-            nextState = StateManager.State.STOPPED;\n-        } finally {\n-            // set status and notify.\n-            synchronized (lockObject){\n-                lockObject.notifyAll();\n-                connectionState.setCurrentState(nextState);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws JMSException {\n-\n-        final StateManager.State prevState;\n-        final List<SessionImpl> sessionListCopy;\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Attempting to close connection\");\n-\n-        synchronized (lockObject){\n-            if (connectionState.isClosed()) return ;\n-            if (! connectionState.isStopped()) {\n-                if (connectionState.isTransitionState()){\n-                    connectionState.waitForTransientStateChange(\n-                            StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                    // Not expected actually, present to guard against future changes ...\n-                    if (connectionState.isTransitionState())\n-                      throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                    if (connectionState.isClosed()) return ;\n-\n-                    assert connectionState.isStarted() || connectionState.isStopped();\n-                }\n-            }\n-\n-            prevState = connectionState.getCurrentState();\n-            connectionState.setCurrentState(StateManager.State.CLOSING);\n-            sessionListCopy = new ArrayList<SessionImpl>(sessionList);\n-        }\n-\n-        StateManager.State nextState = prevState;\n-\n-        try {\n-            // Copy to prevent concurrent mod exceptions.\n-\n-            // Close all sessions - doing this within MT-safe block to prevent any possibility of race conditions.\n-            // Potentially expensive, but it is a tradeoff between correctness and performance :-(\n-            if (logger.isTraceEnabled()) logger.trace(\"Closing \" + sessionListCopy.size() + \" sessions\");\n-            for (SessionImpl session : sessionListCopy) {\n-                try {\n-                    session.close();\n-                } catch (Exception ex){\n-                    // log the error and ignore\n-                    if (logger.isDebugEnabled()) logger.debug(\"exception closing session\", ex);\n-                    else if (logger.isInfoEnabled()) logger.info(\"exception closing session : \" + ex);\n-                }\n-            }\n-            doClose();\n-            synchronized (globalClientIdSet){\n-                assert (null != getClientID());\n-                globalClientIdSet.remove(getClientID());\n-            }\n-            nextState = StateManager.State.CLOSED;\n-        } finally {\n-            // set status and notify.\n-            synchronized (lockObject){\n-                lockObject.notifyAll();\n-\n-                if (StateManager.State.CLOSED == nextState && !connectionState.isClosed()) {\n-                    // clear sessions.\n-                    sessionList.clear();\n-                }\n-                // set after everything is done.\n-                connectionState.setCurrentState(nextState);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector,\n-                                                       ServerSessionPool sessionPool, int maxMessages)\n-        throws JMSException {\n-\n-        throw new JMSException(\"Unsupported\");\n-    }\n-\n-    @Override\n-    public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName,\n-                                                              String messageSelector, ServerSessionPool sessionPool,\n-                                                              int maxMessages)\n-        throws JMSException {\n-\n-        throw new JMSException(\"Unsupported\");\n-    }\n-\n-    @Override\n-    public ConnectionConsumer createConnectionConsumer(Queue queue, String s,\n-                                                       ServerSessionPool serverSessionPool, int maxMessages)\n-        throws JMSException {\n-\n-        throw new JMSException(\"Unsupported\");\n-    }\n-\n-\n-    @Override\n-    public ConnectionConsumer createConnectionConsumer(Topic topic, String messageSelector,\n-                                                       ServerSessionPool sessionPool, int maxMessages)\n-        throws JMSException {\n-\n-        throw new JMSException(\"Unsupported\");\n-    }\n-\n-    public boolean isInStartMode() {\n-        return connectionState.isInStartMode();\n-    }\n-\n-    protected abstract MessagingSessionFacade createMessagingSessionFacade(SessionImpl session) throws JMSException;\n-\n-\n-    // required to catch resource leaks ...\n-    @Override\n-    protected void finalize() throws Throwable {\n-        super.finalize();\n-        if (!connectionState.isClosed()) {\n-            if (logger.isErrorEnabled()) logger.error(\"Connection was NOT closed before it went out of scope\");\n-            close();\n-        }\n-    }\n-\n-    private static final int LOCALLY_SENT_MESSAGE_ID_CACHE_SIZE =\n-        Integer.getInteger(\"LOCALLY_SENT_MESSAGE_ID_CACHE_SIZE\", 1024);\n-    // This is gaurded by publishedMessageIds\n-    private final LRUCacheSet<String> publishedMessageIds =\n-        new LRUCacheSet<String>(LOCALLY_SENT_MESSAGE_ID_CACHE_SIZE, true);\n-\n-    boolean isLocallyPublished(String messageId){\n-\n-        if (null == messageId) return false;\n-\n-        synchronized(publishedMessageIds){\n-            return publishedMessageIds.contains(messageId);\n-        }\n-    }\n-\n-    void addToLocallyPublishedMessageIds(String messageId){\n-\n-        if (null == messageId) return ;\n-\n-        synchronized(publishedMessageIds){\n-            publishedMessageIds.add(messageId);\n-        }\n-    }\n-}"},{"sha":"12210ac2e59c273709a57fcbc1d140b68e5d7048","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,77 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms;\n-\n-import javax.jms.ConnectionMetaData;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-\n-/**\n- * Metadata about the provider and/or connection.\n- */\n-public class ConnectionMetaDataImpl implements ConnectionMetaData {\n-    public static final int JMS_MAJOR_VERSION = 1;\n-    public static final int JMS_MINOR_VERSION = 1;\n-    // What should be the value ?\n-    public static final String PROVIDER_NAME = \"hedwig.jms.provider\";\n-\n-    public static final int PROVIDER_MAJOR_VERSION = 1;\n-    public static final int PROVIDER_MINOR_VERSION = 0;\n-\n-    @Override\n-    public String getJMSVersion() {\n-        return JMS_MAJOR_VERSION + \".\" + JMS_MINOR_VERSION;\n-    }\n-\n-    @Override\n-    public int getJMSMajorVersion() {\n-        return JMS_MAJOR_VERSION;\n-    }\n-\n-    @Override\n-    public int getJMSMinorVersion() {\n-        return JMS_MINOR_VERSION;\n-    }\n-\n-    @Override\n-    public String getJMSProviderName() {\n-        return PROVIDER_NAME;\n-    }\n-\n-    @Override\n-    public String getProviderVersion() {\n-        return getJMSVersion();\n-    }\n-\n-    @Override\n-    public int getProviderMajorVersion() {\n-        return PROVIDER_MAJOR_VERSION;\n-    }\n-\n-    @Override\n-    public int getProviderMinorVersion() {\n-        return PROVIDER_MINOR_VERSION;\n-    }\n-\n-    // None right now ... add more as required.\n-    @Override\n-    public Enumeration getJMSXPropertyNames() {\n-        // return Collections.emptyEnumeration();\n-        return Collections.enumeration(Collections.emptyList());\n-    }\n-}"},{"sha":"0e6d27fb462536c50cc5350c022e7f3c911198c1","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java","status":"removed","additions":0,"deletions":69,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,69 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms;\n-\n-import javax.jms.JMSException;\n-import java.io.PrintStream;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-import org.slf4j.Logger;\n-\n-/**\n- * Contains some Debug Util methods.\n- */\n-public final class DebugUtil {\n-\n-  public static void dumpAllStacktraces(Logger logger) {\n-        logger.debug(generateDumpAllStacktraces());\n-    }\n-\n-    public static void dumpAllStacktraces(PrintStream out) {\n-        out.println(generateDumpAllStacktraces());\n-    }\n-\n-    private static String generateDumpAllStacktraces(){\n-        Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();\n-\n-        StringBuilder sb = new StringBuilder();\n-\n-        sb.append(\"Dump start\\n---\\n\");\n-        for (Map.Entry<Thread, StackTraceElement[]> entry : map.entrySet()){\n-            sb.append(\"Thread \").append(entry.getKey()).append(\"\\n\");\n-            for (StackTraceElement traceElement : entry.getValue())\n-                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\n-\n-        }\n-        sb.append(\"---\\nDump done\\n\");\n-\n-        return sb.toString();\n-    }\n-\n-    public static void dumpJMSStacktrace(Logger logger, JMSException jex) {\n-\n-        assert logger.isDebugEnabled();\n-\n-        final Exception linkedException = jex.getLinkedException();\n-        logger.debug(\"exception\" , jex);\n-        if (null != linkedException)  {\n-            logger.debug(\"due to\" , linkedException);\n-        }\n-    }\n-}"},{"sha":"a9e1d50fe1d5c79ba5542698f3a5d66dce14ab09","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java","status":"removed","additions":0,"deletions":104,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,104 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms;\n-\n-import java.util.Collection;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * An LRUCacheMap\n- */\n-class LRUCacheMap<K, V> implements Map<K, V> {\n-    private final int maxSize;\n-    private final Map<K, V> cache;\n-\n-    public LRUCacheMap(int maxSize, boolean accessOrder){\n-        this.maxSize = maxSize;\n-\n-        this.cache = new LinkedHashMap<K, V>(maxSize, 0.75f, accessOrder){\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n-                boolean retval = super.removeEldestEntry(eldest);\n-                return retval || super.size() > LRUCacheMap.this.maxSize;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public int size() {\n-        return cache.size();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return cache.isEmpty();\n-    }\n-\n-    @Override\n-    public boolean containsKey(Object key) {\n-        return cache.containsKey(key);\n-    }\n-\n-    @Override\n-    public boolean containsValue(Object value) {\n-        return cache.containsValue(value);\n-    }\n-\n-    @Override\n-    public V get(Object key) {\n-        return cache.get(key);\n-    }\n-\n-    @Override\n-    public V put(K key, V value) {\n-        return cache.put(key, value);\n-    }\n-\n-    @Override\n-    public V remove(Object key) {\n-        return cache.remove(key);\n-    }\n-\n-    @Override\n-    public void putAll(Map<? extends K, ? extends V> m) {\n-        cache.putAll(m);\n-    }\n-\n-    @Override\n-    public void clear() {\n-        cache.clear();\n-    }\n-\n-    @Override\n-    public Set<K> keySet() {\n-        return cache.keySet();\n-    }\n-\n-    @Override\n-    public Collection<V> values() {\n-        return cache.values();\n-    }\n-\n-    @Override\n-    public Set<Entry<K, V>> entrySet() {\n-        return cache.entrySet();\n-    }\n-}"},{"sha":"72ce593a02183e73ec1efb25fad41e6242903412","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java","status":"removed","additions":0,"deletions":115,"changes":115,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,115 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n-* An LRUCache (set) based on the LRUCacheMap.\n-*/\n-public class LRUCacheSet<E> implements Set<E> {\n-\n-    private final int maxSize;\n-    private final Map<E, E> cache;\n-\n-    public LRUCacheSet(int maxSize, boolean accessOrder){\n-        this.maxSize = maxSize;\n-\n-        this.cache = new LinkedHashMap<E, E>(maxSize, 0.75f, accessOrder){\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<E, E> eldest) {\n-                boolean retval = super.removeEldestEntry(eldest);\n-                return retval || super.size() > LRUCacheSet.this.maxSize;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public int size() {\n-        return cache.size();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return cache.isEmpty();\n-    }\n-\n-    @Override\n-    public boolean contains(Object val) {\n-        return cache.containsKey(val);\n-    }\n-\n-    @Override\n-    public Iterator<E> iterator() {\n-        return cache.keySet().iterator();\n-    }\n-\n-    @Override\n-    public Object[] toArray() {\n-        return cache.keySet().toArray();\n-    }\n-\n-    @Override\n-    public <T> T[] toArray(T[] a) {\n-        return cache.keySet().toArray(a);\n-    }\n-\n-    @Override\n-    public boolean add(E val) {\n-        return null == cache.put(val, val);\n-    }\n-\n-    @Override\n-    public boolean remove(Object val) {\n-        if (! contains(val)) return false;\n-        cache.remove(val);\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean containsAll(Collection<?> c) {\n-        return cache.keySet().containsAll(c);\n-    }\n-\n-    @Override\n-    public boolean addAll(Collection<? extends E> c) {\n-        boolean retval = false;\n-        for (E e : c) retval = retval | add(e);\n-        return retval;\n-    }\n-\n-    @Override\n-    public boolean retainAll(Collection<?> c) {\n-        return cache.keySet().retainAll(c);\n-    }\n-\n-    @Override\n-    public boolean removeAll(Collection<?> c) {\n-        return cache.keySet().removeAll(c);\n-    }\n-\n-    @Override\n-    public void clear() {\n-        cache.clear();\n-    }\n-}"},{"sha":"63cf0cc8e9be7888ff2dc1658eee2037ad2813d4","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java","status":"removed","additions":0,"deletions":421,"changes":421,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,421 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.MessageConsumer;\n-import javax.jms.Queue;\n-import javax.jms.QueueBrowser;\n-import javax.jms.QueueReceiver;\n-import javax.jms.QueueSender;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.Topic;\n-import javax.jms.TopicPublisher;\n-import javax.jms.TopicSubscriber;\n-\n-/**\n- * Encapsulates the actual implementation away from the rest of the system. <br/>\n- * This will allow us to, potentially, change the underlying messaging implementation with minimal\n- * disruption to the provide code.<br/>\n- * <p/>\n- * Note that provider specific validation to conform to JMS spec must be done BEFORE invoking the\n- * business methods here.<br/>\n- * These are supposed to handle ONLY implementation specific logic, not JMS specific constraint\n- * enforcement(s), etc.<br/>\n- * <p/>\n- * Since hedwig itself might undergo changes due to the JMS provider effort, this will allow us to\n- * decouple the changes.<br/>\n- * In addition, it is an easy way for us to create proxy objects to allow for testing various\n- * aspects of the provider without depending\n- * on hedwig itself (via test facade impl's). <br/>\n- * <p/>\n- * Most of the javadoc's are pretty much verbatim copied from corresponding JMS javadoc's :-)\n- *\n- * <p/>\n- * Note that, typically, actual ConnectionImpl and MessagingSessionFacade used are tightly coupled.\n- * ConnectionImpl is the base class to the actual implementations ...\n- */\n-public interface MessagingSessionFacade {\n-\n-\n-\n-    public enum DestinationType { QUEUE, TOPIC }\n-\n-    /**\n-     * Starts the session.\n-     *\n-     * @throws JMSException If we are unable to initialize hedwig client (typically).\n-     */\n-    public void start() throws JMSException;\n-\n-    /**\n-     * Stop the session.\n-     *\n-     * @throws JMSException If we are unable to stop hedwig client (typically).\n-     */\n-    public void stop() throws JMSException;\n-\n-    /**\n-     * Close the session.\n-     */\n-    public void close();\n-\n-    /**\n-     * Given a destination, find out if it is a queue or topic. Required for createProducer(),\n-     * createConsumer() methods in session.\n-     * @param destination The specified destination.\n-     * @return Its type.\n-     * @throws javax.jms.JMSException In case of internal errors.\n-     */\n-    public DestinationType findDestinationType(String destination) throws JMSException;\n-\n-    /**\n-     * Given a destination, find out if it is a queue or topic. Required for createProducer(),\n-     * createConsumer() methods in session.\n-     * @param destination The specified destination.\n-     * @return Its type.\n-     * @throws javax.jms.JMSException In case of internal errors.\n-     */\n-    public DestinationType findDestinationType(Destination destination) throws JMSException;\n-\n-    /**\n-     * Create a topic publisher to the specified destination.\n-     * @param destination The topic to publish to\n-     * @return A topic publisher for the topic specified\n-     * @throws javax.jms.JMSException In case of internal error.\n-     */\n-    public TopicPublisher createTopicPublisher(Destination destination) throws JMSException;\n-\n-\n-    /**\n-     * Create a queue sender to the specified destination.\n-     * @param destination The queue to publish to\n-     * @return A queue sender for the queue specified\n-     * @throws javax.jms.JMSException In case of internal error.\n-     */\n-    public QueueSender createQueueSender(Destination destination) throws JMSException;\n-\n-    /**\n-     * Create a topic subscriber for the specified destination.\n-     * @param destination The topic name\n-     * @return Topic subscriber for the topic.\n-     * @throws javax.jms.JMSException In case of internal error.\n-     */\n-    public TopicSubscriber createTopicSubscriber(Destination destination) throws JMSException;\n-\n-    /**\n-     * Create a queue receiver for the specified destination.\n-     * @param destination The queue name\n-     * @return Queue receiver for the queue.\n-     * @throws javax.jms.JMSException In case of internal error.\n-     */\n-    public QueueReceiver createQueueReceiver(Destination destination) throws JMSException;\n-\n-    /**\n-     * Create a queue receiver for the specified destination.\n-     * @param destination destination\n-     * @param messageSelector selector to apply\n-     * @return A queue receiver conforming to the constraints.\n-     * @throws javax.jms.JMSException In case of internal error or unsatisfiable constraints.\n-     */\n-    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector) throws JMSException;\n-\n-    /**\n-     * Create a topic subscriber for the specified destination.\n-     * @param destination destination\n-     * @param messageSelector selector to apply\n-     * @param noLocal should locally published messages be received. Note, for now, we do not (yet) support this.\n-     * @return A topic subscriber conforming to the constraints.\n-     * @throws javax.jms.JMSException In case of internal error or unsatisfiable constraints.\n-     */\n-    public TopicSubscriber createTopicSubscriber(Destination destination, String messageSelector,\n-                                                 boolean noLocal) throws JMSException;\n-\n-    /**\n-     * Create a queue receiver for the specified destination.\n-     * @param destination destination\n-     * @param messageSelector selector to apply\n-     * @param noLocal should locally published messages be received. Note, for now, we do not (yet) support this.\n-     * @return A queue receiver conforming to the constraints.\n-     * @throws javax.jms.JMSException In case of internal error or unsatisfiable constraints.\n-     */\n-    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector,\n-                                             boolean noLocal) throws JMSException;\n-\n-\n-    /**\n-     * Creates a durable subscriber to the specified topic. <br/>\n-     * <p/>\n-     * If a client needs to receive all the messages published on a topic, including the ones\n-     * published while the\n-     * subscriber is inactive, it uses a durable TopicSubscriber.\n-     * The JMS provider retains a record of this durable subscription and insures that all messages\n-     * from the\n-     * topic's publishers are retained until they are acknowledged by this durable subscriber or\n-     * they have expired.\n-     * <p/>\n-     * Sessions with durable subscribers must always provide the same client identifier.\n-     * In addition, each client must specify a subscribedId that uniquely identifies (within client\n-     * identifier) each durable\n-     * subscription it creates. Only one session at a time can have a TopicSubscriber for a particular\n-     * durable subscription.\n-     * <p/>\n-     * A client can change an existing durable subscription by creating a durable TopicSubscriber\n-     * with the same subscribedId\n-     * and a new topic and/or message selector.\n-     * Changing a durable subscriber is equivalent to unsubscribing (deleting) the old one and\n-     * creating a new one.\n-     * <p/>\n-     * In some cases, a connection may both publish and subscribe to a topic.\n-     * The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of messages\n-     * published by its own connection.\n-     * The default value for this attribute is false.\n-     *\n-     * @param topic The topic to subscribe to.\n-     * @param subscribedId Name used to identify the subscription. This should be a combination\n-     *  of the client-id and the session and is expected to be unique.\n-     * Only a single subscription can be active for a given subscribedId.\n-     * @return The topicsubscriber which will recieve messages for the topic.\n-     * @throws JMSException if failure due to some error\n-     */\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException;\n-\n-    /**\n-     * Creates a durable subscriber to the specified topic. <br/>\n-     * <p/>\n-     * If a client needs to receive all the messages published on a topic, including the ones published while the\n-     * subscriber is inactive, it uses a durable TopicSubscriber.\n-     * The JMS provider retains a record of this durable subscription and insures that all messages\n-     * from the\n-     * topic's publishers are retained until they are acknowledged by this durable subscriber or\n-     * they have expired.\n-     * <p/>\n-     * Sessions with durable subscribers must always provide the same client identifier.\n-     * In addition, each client must specify a subscribedId that uniquely identifies (within client\n-     * identifier) each durable\n-     * subscription it creates. Only one session at a time can have a TopicSubscriber for a particular\n-     * durable subscription.\n-     * <p/>\n-     * A client can change an existing durable subscription by creating a durable TopicSubscriber with\n-     * the same subscribedId\n-     * and a new topic and/or message selector.\n-     * Changing a durable subscriber is equivalent to unsubscribing (deleting) the old one and\n-     * creating a new one.\n-     * <p/>\n-     * In some cases, a connection may both publish and subscribe to a topic.\n-     * The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of messages\n-     * published by its own connection.\n-     * The default value for this attribute is false.\n-     *\n-     * @param topic The topic to subscribe to.\n-     * @param subscribedId Name used to identify the subscription. This should be a combination of\n-     *  the client-id and the session and is expected to be unique.\n-     * Only a single subscription can be active for a given subscribedId.\n-     * @param messageSelector The selector to filter the messages on.\n-     * @param noLocal Should local messages be delivered or not.\n-     * Note that noLocal implementation is NOT currently supported by hedwig and should be simulated\n-     *  by us in the provider ...\n-     * @return The topicsubscriber which will recieve messages for the topic.\n-     * @throws JMSException if failure due to some error\n-     */\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId,\n-                                                   String messageSelector, boolean noLocal) throws JMSException;\n-\n-    /**\n-     *\n-     * @param queue The queue\n-     * @return Create a queue browser for the specified queue.\n-     */\n-    public QueueBrowser createBrowser(Queue queue) throws JMSException;\n-\n-    /**\n-     *\n-     * @param queue The queue\n-     * @param messageSelector The selector to apply\n-     * @return Create a queue browser for the specified queue.\n-     */\n-    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException;\n-\n-    /**\n-     * Creates a TemporaryTopic object. Its lifetime will be that of the Connection unless it is deleted earlier.\n-     * JMS VIOLATION: Most probably we will violate JMS spec here since session &lt;-&gt; hedwig\n-     * connection and not connection &lt;-&gt; hedwig connection ...\n-     * This is, assuming ofcourse, that we can create temporary topic's !\n-     *\n-     * @return A temporary topic.\n-     * @throws JMSException In case of exceptions creating a queue.\n-     */\n-    public TemporaryTopic createTemporaryTopic() throws JMSException;\n-\n-\n-    /**\n-     * Creates a TemporaryQueue object. Its lifetime will be that of the Connection unless it is deleted earlier.\n-     * JMS VIOLATION: Most probably we will violate JMS spec here since session &lt;-&gt; hedwig\n-     * connection and not connection &lt;-&gt; hedwig connection ...\n-     * This is, assuming ofcourse, that we can create temporary topic's !\n-     *\n-     * @return A temporary queue.\n-     * @throws JMSException In case of exceptions creating a queue.\n-     */\n-    public TemporaryQueue createTemporaryQueue() throws JMSException;\n-\n-    /**\n-     * Starts a durable subscription for a client.\n-     *\n-     * @param topicName The topic name\n-     * @param subscribedId The subscription subscribedId\n-     * @throws JMSException In case of exceptions unsubscribing.\n-     */\n-    public void subscribeToTopic(String topicName, String subscribedId) throws JMSException;\n-\n-    /**\n-     * Unsubscribes a durable subscription that has been created by a client.\n-     * <p/>\n-     * This method deletes the state being maintained on behalf of the subscriber by its provider.\n-     * <p/>\n-     * <br/>\n-     * Note that it is erroneous for a client to delete a durable subscription while there is an\n-     * active MessageConsumer or TopicSubscriber for the subscription,\n-     * or while a consumed message is part of a pending transaction or has not been acknowledged in the session.\n-     * <br/> <b>This validation MUST be done BEFORE invoking this method !</b>\n-     *\n-     * @param topicName The topic name\n-     * @param subscribedId The subscription subscribedId\n-     * @throws JMSException In case of exceptions unsubscribing.\n-     */\n-    public void unsubscribeFromTopic(String topicName, String subscribedId) throws JMSException;\n-\n-    /**\n-     * Starts delivery of messages from a Topic. <br/>\n-     *\n-     * @param topicName The topic name\n-     * @param subscribedId The subscription subscribedId\n-     * @throws JMSException In case of exceptions unsubscribing.\n-     */\n-    public void startTopicDelivery(String topicName, String subscribedId) throws JMSException;\n-\n-    /**\n-     * Starts delivery of messages from a Queue. <br/>\n-     *\n-     * @param queueName The queue name\n-     * @param subscriberId The subscription subscribedId\n-     * @throws JMSException In case of exceptions unsubscribing.\n-     */\n-    public void startQueueDelivery(String queueName, String subscriberId) throws JMSException;\n-\n-    /**\n-     * Stops delivery of messages from a Topic. <br/>\n-     *\n-     * @param topicName The topic name\n-     * @param subscribedId The subscription subscribedId\n-     * @throws JMSException In case of exceptions unsubscribing.\n-     */\n-    public void stopTopicDelivery(String topicName, String subscribedId) throws JMSException;\n-\n-    /**\n-     * Stops delivery of messages from a Queue. <br/>\n-     *\n-     * @param queueName The queue name\n-     * @param subscribedId The subscription subscribedId\n-     * @throws JMSException In case of exceptions unsubscribing.\n-     */\n-    public void stopQueueDelivery(String queueName, String subscribedId) throws JMSException;\n-\n-    /**\n-     * Register an unacknowledged message. This is to be used when session is going to NOT manage\n-     * acknowledgements and\n-     * expects clients to explicitly call message.acknowledge().\n-     * This is true when : session is not transacted and it is in CLIENT_ACKNOWLEDGE mode.\n-     *\n-     * Note that invocation of this method MUST be in the order it was received from the server :\n-     * since hedwig does ack-until-N.\n-     *\n-     * @param message The un-ack message.\n-     */\n-    public void registerUnAcknowledgedMessage(SessionImpl.ReceivedMessage message);\n-\n-    /**\n-     * Acknowledge the jms message to hedwig.\n-     *\n-     * @param message The message to acknowledge.\n-     * @throws javax.jms.JMSException In case of internal errors while sending acknowledgement to hedwig\n-     */\n-    public void acknowledge(MessageImpl message) throws JMSException;\n-\n-    /**\n-     * Get the subscriber id of the TopicSubscriber.\n-     * @param topicSubscriber This must be a topic subscriber created using this facade.\n-     * @return The subscriber id of the subscriber.\n-     * @throws JMSException Typically in case this is NOT an instance compatible with this facade.\n-     */\n-    public String getSubscriberId(TopicSubscriber topicSubscriber) throws JMSException;\n-\n-    /**\n-     * Get the subscriber id of the QueueReceiver.\n-     * @param queueReceiver  This must be a queue receiver created using this facade.\n-     * @return The subscriber id of the subscriber.\n-     * @throws JMSException Typically in case this is NOT an instance compatible with this facade.\n-     */\n-    public String getSubscriberId(QueueReceiver queueReceiver) throws JMSException;\n-\n-    /**\n-     * Enqueue a message for consumption by the subscriber.\n-     * This happens when there are one or more 'recieve()' calls possible.\n-     * <p/>\n-     * The typically flow is : client DOES NOT use <br/>\n-     * {@link javax.jms.Session#setMessageListener(javax.jms.MessageListener)}<br/>\n-     * but directly creates One or more Subscribers via (For Topics) :<br/>\n-     * {@link javax.jms.Session#createConsumer(javax.jms.Destination)},<br/>\n-     * {@link javax.jms.Session#createConsumer(javax.jms.Destination, String)},<br/>\n-     * {@link javax.jms.Session#createConsumer(javax.jms.Destination, String, boolean)},<br/>\n-     * Or directly using Topic api using.<br/>\n-     * {@link javax.jms.TopicSession#createSubscriber(javax.jms.Topic)},<br/>\n-     * {@link javax.jms.TopicSession#createSubscriber(javax.jms.Topic, String, boolean)},<br/>\n-     * {@link javax.jms.TopicSession#createDurableSubscriber(javax.jms.Topic, String)},<br/>\n-     * {@link javax.jms.TopicSession#createDurableSubscriber(javax.jms.Topic, String, String, boolean)}<br/>\n-     * <p/>\n-     * The message is the enqueued in the subscriber for subsequent consumption by<br/>\n-     * {@link javax.jms.TopicSubscriber#receive()} or variants,<br/>\n-     * {@link javax.jms.MessageConsumer#receive()} or variants.<br/>\n-     *\n-     * @param subscriber The subscriber of the message.\n-     * @param receivedMessage The message to dispatch.\n-     * @param addFirst Add to begining of the received list or at end. (usually addFirst == true for\n-     * txn rollback recovery).\n-     * @throws javax.jms.JMSException If not a valid subscriber (for now).\n-     * @return Was the message successfully enqueud to the subscriber. Typically fails if already closed.\n-     */\n-    public boolean enqueueReceivedMessage(MessageConsumer subscriber, SessionImpl.ReceivedMessage receivedMessage,\n-                                          boolean addFirst) throws JMSException;\n-\n-\n-    /**\n-     *\n-     * Publish a message to the topic specified.\n-     *\n-     * @param topicName The topic to publish to.\n-     * @param message The message to send.\n-     * @throws JMSException In case of errors publishing message.\n-     * @return The message-id to be set as JMSMessageID\n-     */\n-    public String publish(String topicName, MessageImpl message) throws JMSException;\n-}"},{"sha":"7689d3b20cf2dc60eea3b11114548d3fb9cff6d6","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,61 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms;\n-\n-/**\n- * A simple utility class to ship values around even particularly when variable is immutable\n- * (like pass from inner class to outer context).\n- */\n-public final class Mutable<T> {\n-    private T value;\n-\n-    public Mutable(T value){\n-        this.value = value;\n-    }\n-\n-    public T getValue() {\n-        return value;\n-    }\n-\n-    public void setValue(T value) {\n-        this.value = value;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"\" + value;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        Mutable mutable = (Mutable) o;\n-\n-        if (value != null ? !value.equals(mutable.value) : mutable.value != null) return false;\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return value != null ? value.hashCode() : 0;\n-    }\n-}"},{"sha":"f86d9559b5c8869f39e57a21002929bd10b065d1","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java","status":"removed","additions":0,"deletions":2009,"changes":2009,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,2009 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms;\n-\n-import org.apache.hedwig.jms.message.BytesMessageImpl;\n-import org.apache.hedwig.jms.message.MapMessageImpl;\n-import org.apache.hedwig.jms.message.MessageImpl;\n-import org.apache.hedwig.jms.message.MessageUtil;\n-import org.apache.hedwig.jms.message.ObjectMessageImpl;\n-import org.apache.hedwig.jms.message.StreamMessageImpl;\n-import org.apache.hedwig.jms.message.TextMessageImpl;\n-import org.apache.hedwig.jms.selector.Node;\n-import org.apache.hedwig.jms.selector.SelectorParser;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.jms.BytesMessage;\n-import javax.jms.Destination;\n-import javax.jms.InvalidDestinationException;\n-import javax.jms.JMSException;\n-import javax.jms.MapMessage;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.ObjectMessage;\n-import javax.jms.Queue;\n-import javax.jms.QueueBrowser;\n-import javax.jms.QueueReceiver;\n-import javax.jms.QueueSender;\n-import javax.jms.Session;\n-import javax.jms.StreamMessage;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.TextMessage;\n-import javax.jms.Topic;\n-import javax.jms.TopicPublisher;\n-import javax.jms.TopicSubscriber;\n-import javax.jms.TransactionRolledBackException;\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-/**\n- * Implementation of jms Session.\n- * IS NOT MT-safe (2.8) - except for close()\n- *\n- * We are yet to support/implement this - must pass a flag through constructor on \"how\" this object\n- * was created and use that to throw exception...\n- *\n- */\n-public class SessionImpl implements Session {\n-\n-\n-    private final static Logger logger = LoggerFactory.getLogger(SessionImpl.class);\n-\n-    // 8k, too high ?\n-    public static final int MAX_SESSION_BUFFERED_MESSAGES =\n-        Integer.getInteger(\"Session.MAX_BUFFERED_MESSAGES\", 1024 * 8);\n-    // 0.5k too low/high ?\n-    public static final int MAX_SUBSCRIBER_BUFFERED_MESSAGES =\n-        Integer.getInteger(\"Session.MAX_SUBSCRIBER_BUFFERED_MESSAGES\", 512);\n-\n-    // Number of attempts to retry and see if a transaction keeps getting rolled back as part\n-    // of async delivery of messages.\n-    public static final int RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS =\n-        Integer.getInteger(\"Session.RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS\", 9);\n-\n-    private final boolean transacted;\n-    private final int acknowledgeMode;\n-    private volatile MessageListener messageListener = null;\n-\n-    private final ConnectionImpl connection;\n-    private final MessagingSessionFacade sessionFacade;\n-\n-    private final Object lockObject = new Object();\n-    // Message processing locks on this object itself - everything else on lockObject. This is to\n-    // prevent interactions with hedwig threading idioms.\n-    // messageList is a leaf in call graph - so it must not cause MT interactions with other locks\n-    // acquired prior to it.\n-    private final List<ReceivedMessage> messageList = new LinkedList<ReceivedMessage>();\n-    private final List<TransactedReceiveOperation> rolledbackMessageList\n-        = new LinkedList<TransactedReceiveOperation>();\n-\n-    private StateManager sessionState = new StateManager(StateManager.State.STOPPED, lockObject);\n-\n-    // Simply encapsulating all state within a single class.\n-    private final Subscriptions subscriptions = new Subscriptions();\n-\n-    private boolean messageListenerThreadStarted = false;\n-    private final Thread messageListenerThread;\n-    private boolean messageListenerThreadFinished = false;\n-\n-    public SessionImpl(ConnectionImpl connection, boolean transacted, int acknowledgeMode) throws JMSException {\n-        if (Session.AUTO_ACKNOWLEDGE != acknowledgeMode &&\n-            Session.CLIENT_ACKNOWLEDGE != acknowledgeMode &&\n-            Session.DUPS_OK_ACKNOWLEDGE != acknowledgeMode){\n-            // On;y if not transacted !\n-            if (!transacted){\n-                throw new javax.jms.IllegalStateException(\"Unknown/unsupported acknowledgeMode specified : \" +\n-                    acknowledgeMode);\n-            }\n-        }\n-        this.transacted = transacted;\n-        this.acknowledgeMode = acknowledgeMode;\n-        this.connection = connection;\n-        this.sessionFacade = connection.createMessagingSessionFacade(this);\n-        this.messageListenerThread = new Thread(this, \"JMS message listener thread\");\n-        // not daemon, right ?\n-        this.messageListenerThread.setDaemon(false);\n-    }\n-\n-    @Override\n-    public BytesMessage createBytesMessage() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new BytesMessageImpl(this);\n-    }\n-\n-    @Override\n-    public MapMessage createMapMessage() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new MapMessageImpl(this);\n-    }\n-\n-    @Override\n-    public Message createMessage() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new MessageImpl(this);\n-    }\n-\n-    @Override\n-    public ObjectMessage createObjectMessage() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new ObjectMessageImpl(this, null);\n-    }\n-\n-    @Override\n-    public ObjectMessage createObjectMessage(Serializable serializable) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new ObjectMessageImpl(this, serializable);\n-    }\n-\n-    @Override\n-    public StreamMessage createStreamMessage() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new StreamMessageImpl(this);\n-    }\n-\n-    @Override\n-    public TextMessage createTextMessage() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new TextMessageImpl(this);\n-    }\n-\n-    @Override\n-    public TextMessage createTextMessage(String payload) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        return new TextMessageImpl(this, payload);\n-    }\n-\n-    @Override\n-    public boolean getTransacted() {\n-        return transacted;\n-    }\n-\n-    @Override\n-    public int getAcknowledgeMode() {\n-        return acknowledgeMode;\n-    }\n-\n-    @Override\n-    public void commit() throws JMSException {\n-        // Apparently, we can send even if connection is not open ?\n-        // if (!sessionState.isStarted()) throw new javax.jms.IllegalStateException(\"Session not open\");\n-        if (!getTransacted()) throw new javax.jms.IllegalStateException(\"Session not transacted\");\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        commitTransactionState();\n-    }\n-\n-    @Override\n-    public void rollback() throws JMSException {\n-        if (!sessionState.isStarted()) throw new javax.jms.IllegalStateException(\"Session not open\");\n-        if (!getTransacted()) throw new javax.jms.IllegalStateException(\"Session not transacted\");\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        rollbackTransactionState();\n-    }\n-\n-    void start() throws JMSException {\n-        final StateManager.State prevState;\n-        final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> subscriptionToSubscriberMapCopy;\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Attempting to start session\");\n-\n-        synchronized (lockObject){\n-            // Do not throw exception, it might be connection starting while another thread might\n-            // be doing a close() - there is a\n-            // potential race there !\n-            // if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-            if (isClosed()) return ;\n-            if (sessionState.isStarted()) return ;\n-\n-            if (sessionState.isTransitionState()){\n-                sessionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                // Not expected actually, present to guard against future changes ...\n-                if (sessionState.isTransitionState())\n-                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-                if (sessionState.isStarted()) return ;\n-\n-                assert sessionState.isStopped();\n-                // try again ...\n-            }\n-\n-            prevState = sessionState.getCurrentState();\n-            sessionState.setCurrentState(StateManager.State.STARTING);\n-\n-            // Copy to prevent concurrent mod exceptions - is it required here ? Not sure ...\n-            subscriptionToSubscriberMapCopy = subscriptions.createSubscriptionToSubscriberMapCopy();\n-        }\n-\n-        StateManager.State nextState = prevState;\n-\n-        try {\n-            rollbackTransactionState();\n-            // Note: this part of the code IS thread-safe for our private state.\n-\n-            // Validate state - in terms of listener's, etc : we are relying on the single thread semantics of JMS\n-            // to NOT do any complex locking, etc.\n-\n-            if (null != getMessageListener()){\n-                // There CANNOT be any subscriber with listeners registered.\n-                for (MessageConsumer consumer : subscriptions.getAllConsumersSet()){\n-                    if (null != consumer.getMessageListener()) {\n-                        throw new JMSException(\"Session's message listener is already set - \" +\n-                            \"cannot have a consumer with listener also set.\");\n-                    }\n-                }\n-            }\n-\n-\n-            sessionFacade.start();\n-\n-            if (logger.isTraceEnabled()) logger.trace(\"Starting \" + subscriptionToSubscriberMapCopy.size() +\n-                \" subscribers\");\n-\n-            // Subscribe to all the subscriberId's\n-            for (Map.Entry<Subscription, CopyOnWriteArrayList<MessageConsumer>> entry :\n-                    subscriptionToSubscriberMapCopy.entrySet()){\n-\n-                if (entry.getValue().isEmpty()) continue;\n-                if (entry.getKey().isTopic()){\n-                    TopicSubscription topicSubscription = (TopicSubscription) entry.getKey();\n-                    try {\n-                        sessionFacade.subscribeToTopic(topicSubscription.topicName, topicSubscription.subscriberId);\n-                    } catch (JMSException e) {\n-                        // Log and ignore\n-                        // This CAN fail, it is ok to fail !\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"(Potentially Benign error) Error subscribing from topic for entry : \" +\n-                                topicSubscription);\n-                            DebugUtil.dumpJMSStacktrace(logger, e);\n-                        }\n-                    }\n-                    try {\n-                        sessionFacade.startTopicDelivery(topicSubscription.topicName,\n-                            topicSubscription.subscriberId);\n-                    } catch (JMSException e) {\n-                        // Log and ignore\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Error starting topic delivery for entry : \" + entry.getKey());\n-                            DebugUtil.dumpJMSStacktrace(logger, e);\n-                        }\n-                    }\n-                }\n-                else {\n-                    assert entry.getKey().isQueue();\n-\n-                    QueueSubscription queueSubscription = (QueueSubscription) entry.getKey();\n-\n-                    // There is no notion like subscription to queue, right ?\n-                    /*\n-                    try {\n-                        sessionFacade.subscribeToQueue(queueSubscription.queueName,\n-                          queueSubscription.subscriberId);\n-                    } catch (JMSException e) {\n-                        // Log and ignore\n-                        // This CAN fail, it is ok to fail !\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"(Potentially Benign error) Error subscribing from queue for entry : \" +\n-                              queueSubscription);\n-                            Util.dumpJMSStacktrace(logger, e);\n-                        }\n-                    }\n-                    */\n-                    try {\n-                        sessionFacade.startQueueDelivery(queueSubscription.queueName, queueSubscription.subscriberId);\n-                    } catch (JMSException e) {\n-                        // Log and ignore\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Error starting queue delivery for entry : \" + entry.getKey());\n-                            DebugUtil.dumpJMSStacktrace(logger, e);\n-                        }\n-                    }\n-                }\n-            }\n-            nextState = StateManager.State.STARTED;\n-        } finally {\n-            // set status and notify.\n-            synchronized (lockObject){\n-                lockObject.notifyAll();\n-                sessionState.setCurrentState(nextState);\n-            }\n-        }\n-    }\n-\n-    void stop() throws JMSException {\n-        final StateManager.State prevState;\n-        final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> subscriptionToSubscriberMapCopy;\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Attempting to stop connection\");\n-\n-        synchronized (lockObject){\n-            if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-            if (sessionState.isStopped()) return ;\n-\n-            if (sessionState.isTransitionState()){\n-                sessionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                // Not expected actually, present to guard against future changes ...\n-                if (sessionState.isTransitionState())\n-                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-                if (sessionState.isStopped()) return ;\n-\n-                assert sessionState.isStarted();\n-\n-                // try again ...\n-            }\n-\n-            prevState = sessionState.getCurrentState();\n-            sessionState.setCurrentState(StateManager.State.STOPPING);\n-\n-            // Copy to prevent concurrent mod exceptions.\n-            subscriptionToSubscriberMapCopy = subscriptions.createSubscriptionToSubscriberMapCopy();\n-        }\n-\n-        StateManager.State nextState = prevState;\n-        try {\n-            rollbackTransactionState();\n-            // In case there are other things to be done ...\n-\n-            // Unsubscribe to all the subscriberId's\n-            if (logger.isTraceEnabled()) logger.trace(\"Stopping \" +\n-                subscriptionToSubscriberMapCopy.size() + \" subscribers\");\n-            for (Map.Entry<Subscription, CopyOnWriteArrayList<MessageConsumer>> entry :\n-                    subscriptionToSubscriberMapCopy.entrySet()){\n-\n-                if (entry.getValue().isEmpty()) continue;\n-                if (entry.getKey().isTopic()){\n-                    TopicSubscription topicSubscription = (TopicSubscription) entry.getKey();\n-                    try {\n-                        stopTopicDelivery(topicSubscription.topicName, topicSubscription.subscriberId);\n-                    } catch (JMSException e) {\n-                        // Log and ignore\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Error unsubscribing from topic for entry : \" + topicSubscription);\n-                            DebugUtil.dumpJMSStacktrace(logger, e);\n-                        }\n-                    }\n-                }\n-                else {\n-                  assert entry.getKey().isQueue();\n-\n-                  QueueSubscription queueSubscription = (QueueSubscription) entry.getKey();\n-                  try {\n-                      stopQueueDelivery(queueSubscription.queueName, queueSubscription.subscriberId);\n-                  } catch (JMSException e) {\n-                      // Log and ignore\n-                      if (logger.isDebugEnabled()) {\n-                          logger.debug(\"Error unsubscribing from queue for entry : \" + queueSubscription);\n-                          DebugUtil.dumpJMSStacktrace(logger, e);\n-                      }\n-                  }\n-                }\n-            }\n-            // stop facade AFTER subscriber's are stopped.\n-            sessionFacade.stop();\n-            nextState = StateManager.State.STOPPED;\n-        } finally {\n-            synchronized (lockObject){\n-                lockObject.notifyAll();\n-                sessionState.setCurrentState(nextState);\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     *\n-     * Closes the session. <br/>\n-     * Since a provider may allocate some resources on behalf of a session outside the JVM, clients\n-     * should close the resources\n-     * when they are not needed. Relying on garbage collection to eventually reclaim these resources\n-     * may not be timely enough.<br/>\n-     * <p/>\n-     * There is no need to close the producers and consumers of a closed session.\n-     * <p/>\n-     *\n-     *\n-     * A blocked message consumer receive call returns null when this session is closed.\n-     * <p/>\n-     * Closing a transacted session must roll back the transaction in progress.<br/>\n-     * This method is the only Session method that can be called concurrently.<br/>\n-     * Invoking any other Session method on a closed session must throw a JMSException.IllegalStateException.<br/>\n-     * Closing a closed session must not throw an exception.<br/>\n-     *\n-     */\n-    private static final ThreadLocal<Boolean> closeFromWithinListener = new ThreadLocal<Boolean>(){\n-        @Override\n-        protected Boolean initialValue() {\n-            return false;\n-        }\n-    };\n-\n-    @Override\n-    public void close() throws JMSException {\n-        final StateManager.State prevState;\n-        final Set<MessageConsumer> subscriberSetCopy = Collections.newSetFromMap(\n-            new IdentityHashMap<MessageConsumer, Boolean>());\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Attempting to close session\");\n-\n-        synchronized (lockObject){\n-            if (isClosed()) return ;\n-            if (! sessionState.isStopped()) {\n-                if (sessionState.isTransitionState()){\n-                    sessionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n-                    // Not expected actually, present to guard against future changes ...\n-                    if (sessionState.isTransitionState())\n-                      throw new JMSException(\"Connection did not make state change to steady state ?\");\n-\n-                    if (isClosed()) return ;\n-\n-                    assert sessionState.isStarted() || sessionState.isStopped();\n-                }\n-            }\n-\n-            prevState = sessionState.getCurrentState();\n-            sessionState.setCurrentState(StateManager.State.CLOSING);\n-            // Copy to prevent concurrent mod exceptions.\n-            subscriberSetCopy.addAll(subscriptions.getAllConsumersSet());\n-        }\n-\n-        StateManager.State nextState = prevState;\n-\n-        try {\n-            rollbackTransactionState();\n-            connection.removeSession(this);\n-\n-            // Close all publishers - doing this within synchronized block to prevent any possibility\n-            // of race conditions.\n-            // Potentially expensive, but it is a tradeoff between correctness and performance :-(\n-            if (logger.isTraceEnabled()) logger.trace(\"Closing \" + subscriberSetCopy.size() + \" subscribers\");\n-            for (MessageConsumer subscriber : subscriberSetCopy){\n-                try {\n-                    subscriber.close();\n-                } catch (JMSException e) {\n-                    // Log and ignore\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Error unsubscribing from destination for entry : \" + subscriber);\n-                        DebugUtil.dumpJMSStacktrace(logger, e);\n-                    }\n-                }\n-            }\n-            sessionFacade.close();\n-            nextState = StateManager.State.CLOSED;\n-        } finally {\n-\n-            // set status and notify.\n-            synchronized (lockObject){\n-                lockObject.notifyAll();\n-                sessionState.setCurrentState(nextState);\n-            }\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(this + \"Waiting for messageListenerThreadStarted \" +\n-            messageListenerThreadStarted + \", messageListenerThreadFinished \" + messageListenerThreadFinished);\n-\n-        // spin on messageListenerThreadFinished\n-        // spin ONLY if we are NOT within the listener already !\n-        if (! closeFromWithinListener.get()){\n-            synchronized (lockObject){\n-                long waitTime = 100;\n-                long retryCount = StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE / waitTime;\n-                if (messageListenerThreadStarted) {\n-                    while (!messageListenerThreadFinished) {\n-                        try {\n-                            lockObject.wait(waitTime);\n-                        } catch (InterruptedException e) {\n-                            // ignore ...\n-                            if (logger.isDebugEnabled()) logger.debug(\"interrupted ?\", e);\n-                        }\n-                        retryCount --;\n-                        // Fail if we have waiting long enough ... hardcoded for now.\n-                        if (retryCount <= 0) break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Waiting for messageListenerThreadFinished \" +\n-            messageListenerThreadFinished + \" DONE\");\n-    }\n-\n-    @Override\n-    public void recover() throws JMSException {\n-        // Typically will be in stopped state.\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (getTransacted())\n-          throw new javax.jms.IllegalStateException(\"cannot invoke recover in transacted session.\");\n-        throw new JMSException(\"recovery : TODO\");\n-    }\n-\n-    @Override\n-    public MessageListener getMessageListener() {\n-        return messageListener;\n-    }\n-\n-    @Override\n-    public void setMessageListener(final MessageListener messageListener) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        // Explicitly forbidding it for now : leads to too many complexities otherwise.\n-        // start session ONLY AFTER you have set the listener.\n-        if (messageListener != this.messageListener && sessionState.isInStartMode()) {\n-            throw new JMSException(\"Set the message listener BEFORE starting session (and/or connection)\");\n-        }\n-\n-        this.messageListener = messageListener;\n-    }\n-\n-    @Override\n-    public void run() {\n-        if (logger.isTraceEnabled()) logger.trace(\"Session thread started\");\n-        try {\n-            while (!isClosed()){\n-                final List<ReceivedMessage> messageListCopy;\n-                final List<TransactedReceiveOperation> rolledbackMessageListCopy;\n-                final MessageListener msglistener;\n-                synchronized (lockObject){\n-                    while (!isClosed() &&\n-                            (!sessionState.isStarted() ||\n-                                (null == getMessageListener() && 0 == subscriptions.getNumSubscribers()) ||\n-                                (messageList.isEmpty() && rolledbackMessageList.isEmpty())\n-                            )\n-                        ) {\n-                        // Check for buffer over-run's due to no listener being available !\n-                        if (messageList.size() > MAX_SESSION_BUFFERED_MESSAGES){\n-                            // simply discard it with an error logged.\n-                            if (logger.isInfoEnabled()) logger.info(\"Discarding \" + messageList.size() +\n-                                \" messages since there are no consumers for them\");\n-                            messageList.clear();\n-                        }\n-                        // Check for buffer over-run's due to no listener being available !\n-                        if (rolledbackMessageList.size() > MAX_SESSION_BUFFERED_MESSAGES){\n-                            // simply discard it with an error logged.\n-                            if (logger.isInfoEnabled()) logger.info(\"Discarding \" + rolledbackMessageList.size() +\n-                                \" messages since there are no consumers for them from recovered list.\");\n-                            rolledbackMessageList.clear();\n-                        }\n-\n-                        if (logger.isTraceEnabled()) logger.trace(this + \"sessionState : \" + sessionState +\n-                            \", listener \" + getMessageListener() + \", numSubscribers : \" +\n-                            subscriptions.getNumSubscribers());\n-                        try {\n-                            lockObject.wait(500);\n-                        } catch (InterruptedException e) {\n-                            // Should we ignore this ? There is no way this thread can be interrupted currently -\n-                            // while closing it will cause issues !\n-                            // Log and forget\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Ignoring interrupted exception\", e);\n-                            }\n-                        }\n-                    }\n-\n-                    if (isClosed()) break;\n-                    msglistener = getMessageListener();\n-                    messageListCopy = new ArrayList<ReceivedMessage>(messageList);\n-                    rolledbackMessageListCopy = new ArrayList<TransactedReceiveOperation>(rolledbackMessageList);\n-                    messageList.clear();\n-                    rolledbackMessageList.clear();\n-                    assert subscriptions.getNumSubscribers() > 0 || null != msglistener;\n-                }\n-\n-                if (logger.isTraceEnabled()) logger.trace(\"Processing \" + messageListCopy.size() +\n-                    \" messages using listener ? \" + (null != msglistener));\n-\n-                dispatchReceivedMessagesToSubscribers(msglistener, messageListCopy, rolledbackMessageListCopy);\n-            }\n-        } finally {\n-            String msg = null;\n-            synchronized (lockObject){\n-                lockObject.notifyAll();\n-                messageListenerThreadFinished = true;\n-                if (logger.isTraceEnabled()) msg = \"Exiting thread and setting \" +\n-                    messageListenerThreadFinished;\n-            }\n-            if (logger.isTraceEnabled()) logger.trace(msg);\n-        }\n-    }\n-\n-    private void dispatchReceivedMessagesToSubscribers(MessageListener sessionMessageListener,\n-                                                       List<ReceivedMessage> messageListCopy,\n-                                                       List<TransactedReceiveOperation> rolledbackMessageListCopy) {\n-        assert null != messageListCopy;\n-\n-        // Doing it before processing messageList.\n-        handleRollbackInDispatch(rolledbackMessageListCopy);\n-\n-        for (final ReceivedMessage receivedMessage : messageListCopy){\n-\n-            if (isClosed()) break;\n-\n-            // It is possible that previous listener rolledback transaction ... check that before\n-            // delivering the other messages !\n-            // Else we will mess up the oder of message delivery.\n-            {\n-                int retryCount = 0;\n-                while (retryCount < RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS){\n-                    if (! handleRollbackInDispatch(null)) break;\n-                    retryCount ++;\n-                }\n-                if (RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS == retryCount){\n-                    // we cant do much - close session and abort.\n-                    try {\n-                        SessionImpl.this.close();\n-                    } catch (JMSException e) {\n-                        if (logger.isDebugEnabled()) logger.debug(\"Exception closing session\", e);\n-                    }\n-                    return ;\n-                }\n-            }\n-\n-            final Subscription subscription = createSubscription(receivedMessage.destinationType,\n-                receivedMessage.originalMessage.getSourceName(), receivedMessage.originalMessage.getSubscriberId());\n-\n-            // COW - so no need to worry about concurrent-mod's or inconsistent states - other than\n-            // potential stale state,\n-            // which is fine since MessageConsumer's are essentially immutable from basic state point\n-            // of view (subscriberId, destination).\n-            CopyOnWriteArrayList<? extends MessageConsumer> subscriberList =\n-                subscriptions.getSubscribers(subscription);\n-            if (null == subscriberList) continue;\n-\n-            if (! subscriberList.listIterator().hasNext()) continue;\n-\n-            // For selector support - pick up the last register\n-            Node ast = subscriptions.getSelectorExpression(subscription);\n-            if (logger.isTraceEnabled()) logger.trace(\"subscription : \" + subscription + \", selector : \" + ast);\n-            if (null != ast){\n-                // final Boolean value = SelectorParser.evaluateSelector(ast, receivedMessage.originalMessage);\n-                final Boolean value = SelectorParser.evaluateSelector(ast, receivedMessage.msg);\n-\n-                if (null == value){\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Unable to evaluate selector ? ... ignoring message\");\n-                        logger.debug(\"Message : \" + receivedMessage.msg);\n-                    }\n-                    receivedMessage.originalMessage.getAckRunnable().run();\n-                    continue;\n-                }\n-                if (! Boolean.TRUE.equals(value)){\n-                    if (logger.isTraceEnabled()) logger.trace(\"Selector DID NOT evaluate to true (\" +\n-                        value + \"), ignore message ignoring message\");\n-                    receivedMessage.originalMessage.getAckRunnable().run();\n-                    continue;\n-                }\n-            }\n-\n-\n-            if (null != sessionMessageListener){\n-                // Since there was atleast one subscriber when we started this loop (which might\n-                // not be case anymore, but that is just an uncontrollable harmless race)\n-                // we can send it to messageListener for the session.\n-                if (logger.isTraceEnabled()) logger.trace(\"Dispatching \" + receivedMessage.originalMessage +\n-                    \" to session listener\");\n-\n-                if (isMessageExpired(receivedMessage.originalMessage)){\n-                    // message already expired.\n-                    // This means we acknowledge for all subscribers with this subscription id ...\n-                    receivedMessage.originalMessage.getAckRunnable().run();\n-                    continue;\n-                }\n-\n-                try {\n-                    final MessageImpl message = MessageUtil.createCloneForDispatch(this,\n-                        receivedMessage.originalMessage, receivedMessage.originalMessage.getSourceName(),\n-                        receivedMessage.originalMessage.getSubscriberId());\n-                    deliverToListener(sessionMessageListener, receivedMessage, message, false);\n-                } catch (JMSException e) {\n-                    // Unexpected not to be able to clone ...\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Unexpected exception trying to process message\");\n-                        DebugUtil.dumpJMSStacktrace(logger, e);\n-                    }\n-                }\n-                continue;\n-            }\n-\n-            for (final MessageConsumer subscriber : subscriberList){\n-                if (isClosed()) break;\n-                try {\n-                    final MessageListener subscriberListener = subscriber.getMessageListener();\n-                    // Clone - since each subscrber can modify the message.  We are optimizing this\n-                    // to clone only if subscriberList\n-                    // has more than one subscriber to avoid the (potentially) expensive creation.\n-                    if (getNoLocal(subscription, subscriber)){\n-                        if (isLocallyPublished(receivedMessage.originalMessage.getJMSMessageID())){\n-                            // This means we acknowledge for all subscribers with this subscription id ...\n-                            receivedMessage.originalMessage.getAckRunnable().run();\n-                            continue;\n-                        }\n-                    }\n-                    if (isMessageExpired(receivedMessage.originalMessage)){\n-                        receivedMessage.originalMessage.getAckRunnable().run();\n-                        continue;\n-                    }\n-\n-                    final MessageImpl message = MessageUtil.createCloneForDispatch(this,\n-                        receivedMessage.originalMessage, receivedMessage.originalMessage.getSourceName(),\n-                        receivedMessage.originalMessage.getSubscriberId());\n-\n-                    if (logger.isTraceEnabled()) logger.trace(\"Dispatching \" + message +\n-                        \" to subscriber subscriberListener ? \" + (subscriberListener != null));\n-\n-                    if (null != subscriberListener) {\n-                        deliverToListener(subscriberListener, receivedMessage, message, false);\n-                    }\n-                    else {\n-                        sessionFacade.enqueueReceivedMessage(subscriber,\n-                            new ReceivedMessage(receivedMessage.originalMessage, message,\n-                                receivedMessage.destinationType), false);\n-                    }\n-\n-                    if (logger.isTraceEnabled()) logger.trace(\"Dispatching \" + message +\n-                        \" to subscriberListener ? \" + (subscriberListener != null) + \", DONE\");\n-                } catch (JMSException e) {\n-                    // Unexpected not to be able to clone ...\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Unexpected exception trying to process message\", e);\n-                    }\n-                    continue ;\n-                }\n-            }\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"dispatchReceivedMessagesToSubscribers() DONE\");\n-    }\n-\n-    private boolean getNoLocal(Subscription subscription, MessageConsumer subscriber) throws JMSException {\n-        if (subscription.isTopic()) return ((TopicSubscriber) subscriber).getNoLocal();\n-        // nothing equivalent for queue.\n-        // if (subscription.isQueue()) return ((QueueReceiver) subscriber).getNoLocal();\n-        return false;\n-    }\n-\n-    // Note that rollback can happen WHILE a listener is being run - so we need to check this\n-    // between EACH message delivery :-(\n-    // Not just as part of block draining of the queue.\n-    // returns true if there was any async operation to rollback (specifically async !).\n-    private boolean handleRollbackInDispatch(List<TransactedReceiveOperation> rolledbackMessageListCopy) {\n-        if (null == rolledbackMessageListCopy) {\n-            // Attempt to drain the queue.\n-            synchronized (lockObject){\n-                if (rolledbackMessageList.isEmpty()) return false;\n-                rolledbackMessageListCopy = new ArrayList<TransactedReceiveOperation>(rolledbackMessageList);\n-                rolledbackMessageList.clear();\n-            }\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"rolledbackMessageList (\" +\n-            rolledbackMessageListCopy.size() + \") ... \" + rolledbackMessageListCopy);\n-\n-        LinkedList<TransactedReceiveOperation> listenerDeliveryList = new LinkedList<TransactedReceiveOperation>();\n-        for (TransactedReceiveOperation receiveOp : rolledbackMessageListCopy){\n-            if (isClosed()) break;\n-            receiveOp.recover(listenerDeliveryList);\n-        }\n-        for (TransactedReceiveOperation receiveOp : listenerDeliveryList){\n-            if (isClosed()) break;\n-            receiveOp.recoverForListener();\n-        }\n-\n-        return listenerDeliveryList.size() > 0;\n-    }\n-\n-    private void deliverToListener(MessageListener sessionMessageListener, ReceivedMessage receivedMessage,\n-                                   MessageImpl theMessage, boolean redelivery) {\n-\n-      // NOT re-enterent method ...\n-        closeFromWithinListener.set(true);\n-        try {\n-            int errorRetry = 0;\n-            boolean success = false;\n-            final int retryFor =\n-                    (!getTransacted() &&\n-                            (Session.AUTO_ACKNOWLEDGE == getAcknowledgeMode() ||\n-                                    Session.CLIENT_ACKNOWLEDGE == getAcknowledgeMode()))\n-                    ? 3 : 1;\n-\n-            while (errorRetry < retryFor && !isClosed()){\n-                try {\n-                    if (redelivery || errorRetry > 0) theMessage.setJMSRedelivered(true);\n-\n-                    // Changed my mind, always ack the message before processing it. This seems to\n-                    // be consistent with activemq testcases too ...\n-                    handleAutomaticMessageAcknowledgement(receivedMessage, sessionMessageListener);\n-                    sessionMessageListener.onMessage(theMessage);\n-                    success = true;\n-                    break ;\n-                } catch (RuntimeException rEx){\n-                    // Badly behaved client, retry ...\n-                    if (logger.isInfoEnabled())\n-                      logger.info(\"Unexpected runtime exception from client message listener.\", rEx);\n-                }\n-                errorRetry ++;\n-            }\n-\n-            if (isClosed()) return ;\n-\n-            if (!success){\n-                // If failed, then reset transaction state - so that next txn will not get affected by this.\n-                rollbackTransactionState();\n-                // We gave up deliverying message ...\n-                if (retryFor > 1) {\n-                    if (logger.isInfoEnabled())\n-                      logger.info(\"Delivery of message to listener resulted in repeated failures, \" +\n-                          \" dropping message -  session recovery should be used to handle it.\");\n-                }\n-                else {\n-                    if (logger.isInfoEnabled()) logger.info(\"Use session recovery to handle message\");\n-                }\n-            }\n-        } finally {\n-            closeFromWithinListener.remove();\n-        }\n-    }\n-\n-    public MessagingSessionFacade.DestinationType findDestinationType(String destination) throws JMSException {\n-        return sessionFacade.findDestinationType(destination);\n-    }\n-\n-    public MessagingSessionFacade.DestinationType findDestinationType(Destination destination) throws JMSException {\n-        return sessionFacade.findDestinationType(destination);\n-    }\n-\n-    @Override\n-    public MessageProducer createProducer(Destination destination) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        connection.initConnectionClientID();\n-\n-        return createProducerImpl(findDestinationType(destination), destination);\n-    }\n-\n-    private MessageProducer createProducerImpl(MessagingSessionFacade.DestinationType type,\n-                                               Destination destination) throws JMSException {\n-        switch (type){\n-            case QUEUE:\n-                return sessionFacade.createQueueSender(destination);\n-            case TOPIC:\n-                return sessionFacade.createTopicPublisher(destination);\n-            default:\n-                throw new JMSException(\"Unable to find destination type \" + destination +\n-                    \", please use explicit queue/topic methods to create producer\");\n-        }\n-    }\n-\n-    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n-    protected TopicPublisher createPublisherImpl(Topic topic) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == topic) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return (TopicPublisher) createProducerImpl(MessagingSessionFacade.DestinationType.TOPIC, topic);\n-    }\n-\n-\n-    @Override\n-    public MessageConsumer createConsumer(Destination destination) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == destination) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return createConsumerImpl(findDestinationType(destination), destination);\n-    }\n-\n-    private MessageConsumer createConsumerImpl(MessagingSessionFacade.DestinationType type,\n-                                               Destination destination) throws JMSException {\n-        switch (type){\n-            case QUEUE:\n-                return sessionFacade.createQueueReceiver(destination);\n-            case TOPIC:\n-                return sessionFacade.createTopicSubscriber(destination);\n-            default:\n-                throw new JMSException(\"Unable to find destination type \" + destination +\n-                    \", please use explicit queue/topic methods to create consumer\");\n-        }\n-    }\n-\n-    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n-    protected TopicSubscriber createSubscriberImpl(Topic topic) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == topic) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return (TopicSubscriber) createConsumerImpl(MessagingSessionFacade.DestinationType.TOPIC, topic);\n-    }\n-\n-    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n-    protected TopicSubscriber createSubscriberImpl(Topic topic, String messageSelector, boolean noLocal)\n-        throws JMSException {\n-\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == topic) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return (TopicSubscriber) createConsumerImpl(MessagingSessionFacade.DestinationType.TOPIC,\n-            topic, messageSelector, noLocal);\n-    }\n-\n-\n-    @Override\n-    public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == destination) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return createConsumer(destination, messageSelector, false);\n-    }\n-\n-    @Override\n-    public MessageConsumer createConsumer(Destination destination, String messageSelector,\n-                                          boolean noLocal) throws JMSException {\n-\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == destination) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return createConsumerImpl(findDestinationType(destination), destination, messageSelector, noLocal);\n-    }\n-\n-    private MessageConsumer createConsumerImpl(MessagingSessionFacade.DestinationType type, Destination destination,\n-                                               String messageSelector, boolean noLocal) throws JMSException {\n-        switch (type){\n-            case QUEUE:\n-                return sessionFacade.createQueueReceiver(destination, messageSelector, noLocal);\n-            case TOPIC:\n-                return sessionFacade.createTopicSubscriber(destination, messageSelector, noLocal);\n-            default:\n-                throw new JMSException(\"Unable to find destination type \" + destination +\n-                    \", please use explicit queue/topic methods to create consumer\");\n-        }\n-    }\n-\n-    // TODO: Check if it is actually a Queue !\n-    @Override\n-    public Queue createQueue(String queueName) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        return (Queue) getDestination(MessagingSessionFacade.DestinationType.QUEUE, queueName);\n-    }\n-\n-    // delegate to this IF this method can be invoked (specifically, if not TopicSession)\n-    protected QueueReceiver createReceiverImpl(Queue queue) throws JMSException {\n-        return sessionFacade.createQueueReceiver(queue);\n-    }\n-\n-    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n-    protected QueueReceiver createReceiverImpl(Queue queue, String messageSelector) throws JMSException {\n-        return sessionFacade.createQueueReceiver(queue, messageSelector);\n-    }\n-\n-    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n-    protected QueueSender createSenderImpl(Queue queue) throws JMSException {\n-        return sessionFacade.createQueueSender(queue);\n-    }\n-\n-    // TODO: Check if it is actually a Topic !\n-    @Override\n-    public Topic createTopic(String topicName) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        if (null == topicName) throw new InvalidDestinationException(\"Illegal destination\");\n-        connection.initConnectionClientID();\n-\n-        return (Topic) getDestination(MessagingSessionFacade.DestinationType.TOPIC, topicName);\n-    }\n-\n-    @Override\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        if (null == topic) throw new InvalidDestinationException(\"Illegal destination\");\n-        if (null == subscribedId) throw new JMSException(\"Illegal subscribedId\");\n-        connection.initConnectionClientID();\n-\n-        subscriptions.registerSubscriberIdToTopic(subscribedId, topic.getTopicName());\n-        return sessionFacade.createDurableSubscriber(topic, createSubscriberId(subscribedId));\n-    }\n-\n-    @Override\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId, String messageSelector,\n-                                                   boolean noLocal) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        if (null == topic) throw new InvalidDestinationException(\"Illegal destination\");\n-        if (null == subscribedId) throw new JMSException(\"Illegal subscribedId\");\n-        connection.initConnectionClientID();\n-\n-        subscriptions.registerSubscriberIdToTopic(subscribedId, topic.getTopicName());\n-        return sessionFacade.createDurableSubscriber(topic, createSubscriberId(subscribedId),\n-            messageSelector, noLocal);\n-    }\n-\n-    @Override\n-    public void unsubscribe(String subscribedId) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        final String topicName = subscriptions.findTopicNameForSubscriberId(subscribedId);\n-        sessionFacade.unsubscribeFromTopic(topicName, createSubscriberId(subscribedId));\n-    }\n-\n-    public String createSubscriberId(final String subscribedId) throws JMSException {\n-        final String clientId = connection.getClientID();\n-        StringBuilder sb = new StringBuilder();\n-\n-        // Some arbitrary combination of client id and subscriber id.\n-        sb.append(\"CLIENT_ID:\");\n-        sb.append(clientId);\n-        sb.append('|');\n-        sb.append(\"SUBSCRIBER_ID:\");\n-        sb.append(subscribedId);\n-\n-        return sb.toString();\n-    }\n-\n-    /*\n-    public String createTemporaryTopicId() throws JMSException {\n-        final String clientId = connection.getClientID();\n-        StringBuilder sb = new StringBuilder();\n-\n-        // Some arbitrary combination of client id and subscriber id.\n-        sb.append(\"CLIENT_ID:\");\n-        sb.append(clientId);\n-        sb.append('|');\n-        sb.append(\"TOPIC_ID:\");\n-        sb.append(generateRandomString());\n-\n-        return sb.toString();\n-    }\n-    */\n-\n-    @Override\n-    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        return sessionFacade.createBrowser(queue);\n-    }\n-\n-    @Override\n-    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        return sessionFacade.createBrowser(queue, messageSelector);\n-    }\n-\n-    @Override\n-    public TemporaryQueue createTemporaryQueue() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        return sessionFacade.createTemporaryQueue();\n-    }\n-\n-    @Override\n-    public TemporaryTopic createTemporaryTopic() throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-\n-        return sessionFacade.createTemporaryTopic();\n-    }\n-\n-    public void subscriberCreated() {\n-        // subscriberCreatedCount ++;\n-    }\n-\n-    public void acknowledge(MessageImpl message) throws JMSException {\n-        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n-        // If NOT in explicit acknowledge mode, ignore request.\n-        if (Session.CLIENT_ACKNOWLEDGE != getAcknowledgeMode()) return;\n-        // If in transaction, ignore request.\n-        if (getTransacted()) return ;\n-\n-        sessionFacade.acknowledge(message);\n-    }\n-\n-    public String toName(Destination destination) throws JMSException {\n-        if (destination instanceof Topic) return ((Topic)destination).getTopicName();\n-        if (destination instanceof Queue) return ((Queue)destination).getQueueName();\n-\n-        throw new javax.jms.IllegalStateException(\"Unknown/unsupported destination \" + destination);\n-    }\n-\n-    public static Topic asTopic(final String topicName){\n-        return new Topic() {\n-            @Override\n-            public String getTopicName() throws JMSException {\n-                return topicName;\n-            }\n-\n-            @Override\n-            public String toString(){\n-                return topicName;\n-            }\n-        };\n-    }\n-\n-\n-    public static Queue asQueue(final String queueName){\n-        return new Queue() {\n-            @Override\n-            public String getQueueName() throws JMSException {\n-                return queueName;\n-            }\n-\n-            @Override\n-            public String toString(){\n-                return queueName;\n-            }\n-        };\n-    }\n-    // TODO: Convert to JNDI lookup.\n-    public Destination getDestination(final MessagingSessionFacade.DestinationType type,\n-                                      final String destination) throws JMSException {\n-        switch (type){\n-            case TOPIC:\n-                return asTopic(destination);\n-            case QUEUE:\n-                return asQueue(destination);\n-            default:\n-                throw new JMSException(\"Unknown destination type \" + type +\n-                    \" for destination \" + destination);\n-        }\n-    }\n-\n-    public static String generateRandomString() {\n-        // UUID is expensive, but using it for now ...\n-        return UUID.randomUUID().toString();\n-    }\n-\n-    public void registerTopicSubscriptionInfo(TopicSubscription topicSubscription, Node selectorAst) {\n-        subscriptions.registerTopicSubscriptionSelector(topicSubscription, selectorAst);\n-    }\n-\n-    public void registerQueueSubscriptionInfo(QueueSubscription queueSubscription, Node selectorAst) {\n-        subscriptions.registerQueueSubscriptionSelector(queueSubscription, selectorAst);\n-    }\n-\n-    // returns true IF we need to do an explicit subscribe to the topic (there was NO subscription to it earlier).\n-    public void registerTopicSubscriber(TopicSubscriber topicSubscriber) throws JMSException {\n-        registerSubscriber(topicSubscriber, MessagingSessionFacade.DestinationType.TOPIC,\n-            topicSubscriber.getTopic().getTopicName(), sessionFacade.getSubscriberId(topicSubscriber));\n-    }\n-\n-    public void registerQueueSubscriber(QueueReceiver queueReceiver) throws JMSException {\n-        registerSubscriber(queueReceiver, MessagingSessionFacade.DestinationType.QUEUE,\n-            queueReceiver.getQueue().getQueueName(), sessionFacade.getSubscriberId(queueReceiver));\n-    }\n-\n-    private void registerSubscriber(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n-                                   final String destination, final String subscriberId) throws JMSException {\n-\n-        assert MessagingSessionFacade.DestinationType.QUEUE == type ||\n-            MessagingSessionFacade.DestinationType.TOPIC == type;\n-\n-        boolean needSubscription = false;\n-        boolean needDelivery = false;\n-        if (logger.isTraceEnabled()) logger.trace(\"Registering ... \" + subscriber + \" for \" + destination +\n-            \", sid \" + subscriberId);\n-\n-        synchronized (lockObject){\n-            if (sessionState.isInCloseMode()) throw new JMSException(\"Already closed\");\n-\n-            // already subscribed.\n-            if (! subscriptions.addToSubscriberSet(subscriber)) return ;\n-\n-            if (subscriptions.addToSubscribers(subscriber, type, destination, subscriberId)) {\n-                // needSubscription = sessionState.isStarted();\n-                needSubscription = ! sessionState.isInCloseMode();\n-                needDelivery = sessionState.isStarted();\n-            }\n-        }\n-\n-        // TODO: There is a potential race here between registering/starting subscription and\n-        // stopping/closing subscription(s) elsewhere.\n-        // We should resolve it by taking a per List lock (which is gauranteed to be non-null here)\n-        // and a per List subscription status.\n-        // For now, NOT handling crazy edge-cases like this - under most circumsances, this will\n-        // fail for other reasons anyway !\n-\n-        // Session must be used by clients only in a thread safe manner, since it is ok to do this\n-        // outside the lock.\n-        if (needSubscription){\n-            if (logger.isTraceEnabled()) logger.trace(\"Subscribing ... \" + subscriber + \" for \" +\n-                destination + \", sid \" + subscriberId);\n-\n-            if (MessagingSessionFacade.DestinationType.TOPIC == type){\n-                // Only for topic's, right ?\n-                try {\n-                    sessionFacade.subscribeToTopic(destination, subscriberId);\n-                } catch (JMSException e){\n-                    // It might be possible for this to fail ...\n-                    // Log and ignore\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Error subscribing from topic for entry : \" + subscriberId);\n-                        DebugUtil.dumpJMSStacktrace(logger, e);\n-                    }\n-                }\n-            }\n-            if (logger.isTraceEnabled()) logger.trace(\"Subscribing ... \" + subscriber + \" for \" +\n-                destination + \", sid \" + subscriberId + \" DONE\");\n-        }\n-\n-        if (needDelivery) {\n-            if (MessagingSessionFacade.DestinationType.TOPIC == type){\n-                if (logger.isTraceEnabled()) logger.trace(\"Topic delivery ... \" + subscriber + \" for \" +\n-                    destination + \", sid \" + subscriberId);\n-                sessionFacade.startTopicDelivery(destination, subscriberId);\n-                if (logger.isTraceEnabled()) logger.trace(\"Topic delivery ... \" + subscriber + \" for \" +\n-                    destination + \", sid \" + subscriberId + \" DONE\");\n-            }\n-            else {\n-                if (logger.isTraceEnabled()) logger.trace(\"Queue delivery ... \" + subscriber + \" for \" +\n-                    destination + \", sid \" + subscriberId);\n-                sessionFacade.startQueueDelivery(destination, subscriberId);\n-                if (logger.isTraceEnabled()) logger.trace(\"Queue delivery ... \" + subscriber + \" for \" +\n-                    destination + \", sid \" + subscriberId + \" DONE\");\n-            }\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"registerSubscriber ... \" + messageListenerThreadStarted);\n-        if (! messageListenerThreadStarted){\n-            try {\n-                this.messageListenerThread.start();\n-            } catch (IllegalThreadStateException  itse){\n-                // ignore\n-                // This should not happen, it will happen when Session is used in an MT-unsafe manner,\n-                // contrary to what is expected from JMS.\n-                if (logger.isDebugEnabled()) logger.debug(\"Unexpected\", itse);\n-            }\n-            messageListenerThreadStarted = true;\n-        }\n-        if (logger.isTraceEnabled()) logger.trace(\"registerSubscriber ... DONE\");\n-    }\n-\n-    public void unregisterTopicSubscriber(TopicSubscriber topicSubscriber) throws JMSException {\n-        unregisterSubscriber(topicSubscriber, MessagingSessionFacade.DestinationType.TOPIC,\n-            topicSubscriber.getTopic().getTopicName(), sessionFacade.getSubscriberId(topicSubscriber));\n-    }\n-\n-    public void unregisterQueueReceiver(QueueReceiver queueReceiver) throws JMSException {\n-        unregisterSubscriber(queueReceiver, MessagingSessionFacade.DestinationType.QUEUE,\n-            queueReceiver.getQueue().getQueueName(), sessionFacade.getSubscriberId(queueReceiver));\n-    }\n-\n-    private void unregisterSubscriber(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n-                                      final String destination, final String subscriberId) throws JMSException {\n-\n-        assert MessagingSessionFacade.DestinationType.QUEUE == type ||\n-            MessagingSessionFacade.DestinationType.TOPIC == type;\n-        final boolean stopDelivery;\n-\n-        synchronized (lockObject){\n-            // if in closing, continue on anyway ...\n-            if (isClosed()) return ;\n-\n-            stopDelivery = subscriptions.removeSubscriber(subscriber, type, destination, subscriberId);\n-            if (stopDelivery) {\n-                if (! subscriptions.getAllConsumersSet().remove(subscriber)) return ;\n-            }\n-        }\n-\n-        // Session is expected to be used in a MT safe manner, since it is MT-unsafe.\n-        if (stopDelivery){\n-            if (MessagingSessionFacade.DestinationType.TOPIC == type){\n-                stopTopicDelivery(destination, subscriberId);\n-            }\n-            else {\n-                stopQueueDelivery(destination, subscriberId);\n-            }\n-        }\n-    }\n-\n-    public void handleAutomaticMessageAcknowledgement(ReceivedMessage receivedMessage,\n-                                                      MessageListener sessionMessageListener) {\n-        doHandleAutomaticMessageAcknowledgement(new TransactedReceiveOperation(receivedMessage,\n-            sessionMessageListener));\n-    }\n-\n-    public void handleAutomaticMessageAcknowledgement(ReceivedMessage receivedMessage, MessageConsumer subscriber) {\n-        doHandleAutomaticMessageAcknowledgement(new TransactedReceiveOperation(receivedMessage, subscriber));\n-    }\n-\n-    // This is a provider internal method.\n-    private void doHandleAutomaticMessageAcknowledgement(TransactedReceiveOperation receiveOperation) {\n-        if (isClosed()) return ;\n-        // If in transaction, ignore.\n-        if (transacted) {\n-            enqueueReceiveWithinTransaction(receiveOperation);\n-            return ;\n-        }\n-\n-        if (Session.AUTO_ACKNOWLEDGE == getAcknowledgeMode() ||\n-            Session.DUPS_OK_ACKNOWLEDGE == getAcknowledgeMode()){\n-            // Ignore (any) exceptions which might be thrown ...\n-            try {\n-                if (logger.isTraceEnabled()) logger.trace(\"acknowledging ... \" + receiveOperation);\n-                receiveOperation.receivedMessage.originalMessage.getAckRunnable().run();\n-            } catch (Exception ex){\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Ignoring exception while sending ack ... \", ex);\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    public void unsubscribeFromTopic(String topicName, String subscribedId) throws JMSException {\n-        sessionFacade.unsubscribeFromTopic(topicName, subscribedId);\n-    }\n-\n-    public void stopTopicDelivery(String topicName, String subscribedId) throws JMSException {\n-        sessionFacade.stopTopicDelivery(topicName, subscribedId);\n-    }\n-\n-    public void stopQueueDelivery(String queueName, String subscribedId) throws JMSException {\n-        sessionFacade.stopQueueDelivery(queueName, subscribedId);\n-    }\n-\n-    public void messageReceived(final MessageImpl msg, MessagingSessionFacade.DestinationType type)\n-        throws JMSException {\n-\n-        String traceMsg = null;\n-        ReceivedMessage receivedMessage = new ReceivedMessage(msg, msg, type);\n-        synchronized (lockObject){\n-            // ignore if closed ... continue on if in closing state.\n-            if (isClosed()) return ;\n-            messageList.add(receivedMessage);\n-\n-            if (!getTransacted() && CLIENT_ACKNOWLEDGE == getAcknowledgeMode()) {\n-                sessionFacade.registerUnAcknowledgedMessage(receivedMessage);\n-            }\n-\n-            lockObject.notifyAll();\n-            if (logger.isTraceEnabled()) traceMsg = \"messageReceived from \" + msg.getSourceName() +\n-                \", for \" + msg.getSubscriberId() + \" = \" + msg;\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(traceMsg);\n-    }\n-\n-    // A simple immutable datastructure to hold details about a message which has been recieved.\n-    public static class ReceivedMessage {\n-        // Ensure that the original message is NOT modified in any way !\n-        public final MessageImpl originalMessage;\n-        // This is the message returned to the client : to the listener and/or in the TopicSubscriberImpl -\n-        // created as a\n-        // clone of the originalMessage.\n-        public final MessageImpl msg;\n-\n-        public final MessagingSessionFacade.DestinationType destinationType;\n-\n-        private ReceivedMessage(MessageImpl originalMessage, MessageImpl msg,\n-                                MessagingSessionFacade.DestinationType destinationType) {\n-            this.originalMessage = originalMessage;\n-            this.msg = msg;\n-            this.destinationType = destinationType;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"ReceivedMessage\");\n-            sb.append(\"{originalMessage=\").append(originalMessage);\n-            sb.append(\", msg=\").append(msg);\n-            sb.append(\", destinationType=\").append(destinationType);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    // required to catch resource leaks ...\n-    @Override\n-    protected void finalize() throws Throwable {\n-        super.finalize();\n-        if (!sessionState.isInCloseMode()) {\n-            if (logger.isErrorEnabled()) logger.error(\"Session was NOT closed before it went out of scope\");\n-            close();\n-        }\n-    }\n-\n-    public boolean isClosed() {\n-        return sessionState.isClosed();\n-    }\n-\n-\n-    // TODO: Introduce a daemon thread which periodically updates this - each call to\n-    // System.currentTimeMillis is a native call\n-    // And can be very expensive if there are a lot of concurrent invocations to it : learnings\n-    // from XMPP server circa 2006 !\n-    public static long currentTimeMillis() {\n-        return System.currentTimeMillis();\n-    }\n-\n-    public Subscription createSubscription(MessagingSessionFacade.DestinationType type, String name,\n-                                           String subscriberId){\n-        switch(type){\n-          case QUEUE:\n-              return new QueueSubscription(name, subscriberId);\n-          case TOPIC:\n-              return new TopicSubscription(name, subscriberId);\n-          default:\n-              throw new IllegalArgumentException(\"Unknown destination type \" + type +\n-                  \" for destination \" + name + \", subscriberId \" + subscriberId);\n-        }\n-    }\n-    public interface Subscription {\n-        public boolean isTopic();\n-        public boolean isQueue();\n-    }\n-\n-    public static final class TopicSubscription implements Subscription {\n-        public final String topicName;\n-        public final String subscriberId;\n-\n-        public TopicSubscription(String topicName, String subscriberId) {\n-            if (null == topicName || null == subscriberId) {\n-                throw new NullPointerException(\"Unexpected null as parameter topicName: \" +\n-                    topicName + \", subscriberId: \" + subscriberId);\n-            }\n-            this.topicName = topicName;\n-            this.subscriberId = subscriberId;\n-        }\n-\n-        public boolean isTopic() { return true; }\n-\n-        public boolean isQueue() { return false; }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-\n-            TopicSubscription that = (TopicSubscription) o;\n-\n-            if (!subscriberId.equals(that.subscriberId)) return false;\n-            if (!topicName.equals(that.topicName)) return false;\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = topicName.hashCode();\n-            result = 31 * result + subscriberId.hashCode();\n-            return result;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"TopicSubscription\");\n-            sb.append(\"{topicName='\").append(topicName).append('\\'');\n-            sb.append(\", subscriberId='\").append(subscriberId).append('\\'');\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    public static final class QueueSubscription implements Subscription {\n-        public final String queueName;\n-        public final String subscriberId;\n-\n-        public QueueSubscription(String queueName, String subscriberId) {\n-            if (null == queueName || null == subscriberId) {\n-                throw new NullPointerException(\"Unexpected null as parameter queueName: \" +\n-                    queueName + \", subscriberId: \" + subscriberId);\n-            }\n-            this.queueName = queueName;\n-            this.subscriberId = subscriberId;\n-        }\n-\n-        public boolean isTopic() { return false; }\n-\n-        public boolean isQueue() { return true; }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-\n-            QueueSubscription that = (QueueSubscription) o;\n-\n-            if (!subscriberId.equals(that.subscriberId)) return false;\n-            if (!queueName.equals(that.queueName)) return false;\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = queueName.hashCode();\n-            result = 31 * result + subscriberId.hashCode();\n-            return result;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"QueueSubscription\");\n-            sb.append(\"{queueName='\").append(queueName).append('\\'');\n-            sb.append(\", subscriberId='\").append(subscriberId).append('\\'');\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-\n-    private static interface TransactedOperation {\n-        public void rollback();\n-        public void commit() throws JMSException;\n-        public boolean requiresStartedSession();\n-    }\n-\n-    private class TransactedSendOperation implements TransactedOperation {\n-        private final String destination;\n-        private final MessageImpl messageImpl;\n-        private final Message userMessage;\n-\n-        private TransactedSendOperation(String destination, MessageImpl messageImpl, Message userMessage) {\n-            this.destination = destination;\n-            this.messageImpl = messageImpl;\n-            this.userMessage = userMessage;\n-        }\n-\n-\n-        @Override\n-        public void commit() throws JMSException {\n-            String msgId = SessionImpl.this.sessionFacade.publish(destination, messageImpl);\n-            if (userMessage instanceof MessageImpl) ((MessageImpl) userMessage).setJMSMessageIDInternal(msgId);\n-            else userMessage.setJMSMessageID(msgId);\n-        }\n-\n-        public void rollback() {\n-            // noop ...\n-        }\n-\n-        @Override\n-        public boolean requiresStartedSession() {\n-            return false;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"TransactedSendOperation\");\n-            sb.append(\"{destination='\").append(destination).append('\\'');\n-            sb.append(\", messageImpl=\").append(messageImpl);\n-            sb.append(\", userMessage=\").append(userMessage);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    private class TransactedReceiveOperation implements TransactedOperation {\n-        private final ReceivedMessage receivedMessage;\n-        private final MessageListener sessionMessageListener;\n-        private final MessageConsumer subscriber;\n-\n-        private TransactedReceiveOperation(ReceivedMessage receivedMessage, MessageListener sessionMessageListener) {\n-            this.receivedMessage = receivedMessage;\n-            this.sessionMessageListener = sessionMessageListener;\n-            this.subscriber = null;\n-        }\n-\n-        private TransactedReceiveOperation(ReceivedMessage receivedMessage, MessageConsumer subscriber) {\n-            this.receivedMessage = receivedMessage;\n-            this.subscriber = subscriber;\n-            this.sessionMessageListener = null;\n-        }\n-\n-        @Override\n-        public boolean requiresStartedSession() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void rollback() {\n-\n-            // async dispatch ...\n-            if (null != sessionMessageListener) {\n-                synchronized (SessionImpl.this.lockObject){\n-                    rolledbackMessageList.add(this);\n-                    SessionImpl.this.lockObject.notifyAll();\n-                }\n-            }\n-            // If rollback in sync mode, do in same thread - else a rollback, receive WILL see messages\n-            // in different order !\n-            // This is also required since in async mode, session IS NOT MT-safe - and so is\n-            // expecting this behavior.\n-            else if (null != subscriber){\n-                try {\n-                    MessageImpl theMessage = MessageUtil.createCloneForDispatch(SessionImpl.this,\n-                            receivedMessage.originalMessage,\n-                            receivedMessage.originalMessage.getSourceName(),\n-                            receivedMessage.originalMessage.getSubscriberId());\n-                    theMessage.setJMSRedelivered(true);\n-\n-                    sessionFacade.enqueueReceivedMessage(subscriber,\n-                            new ReceivedMessage(receivedMessage.originalMessage, theMessage,\n-                                receivedMessage.destinationType), true);\n-                } catch (JMSException e) {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Unable to enqueue received message to\");\n-                        DebugUtil.dumpJMSStacktrace(logger, e);\n-                    }\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void commit() throws JMSException {\n-            try {\n-                receivedMessage.originalMessage.getAckRunnable().run();\n-            } catch (Exception ex){\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Ignoring exception while sending ack ... \", ex);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Recovery is slightly tricky - we have two cases here :\n-         * a) Messages which to be consumed via subscriber which support the sync mode - via receive(), variants.\n-         * b) Messages which are to be consumed via the subscriber or session's async mode - via listener.\n-         *\n-         *\n-         * We have to ensure that message recovery will result in the exact SAME order of message\n-         * delivery to client as it was done first time\n-         * (when rollback was triggered).\n-         * To ensure this, the recover method is called in REVERSE order in which operations were\n-         * enqueued in the txn (log) queue.\n-         *\n-         * To handle (a), sessionFacade.enqueueReceivedMessage pushes message to begining of pending\n-         * message queue in subscriber.\n-         * Taken along with reverse order of unwinding of txn log, this ensure the desired behavior for (a).\n-         *\n-         * To ensure desired behavior for (b), we pass a listenerDeliveryList as parameter - which is\n-         * used to maintain the\n-         * order of how to invoke onMessage to recover for async dispatch. Note: we keep adding to\n-         * begining of this list to ensure that\n-         * in the end, oldest message in txn log is the first message in listenerDeliveryList when\n-         * we attempt recovery.\n-         *\n-         */\n-        public void recover(LinkedList<TransactedReceiveOperation> listenerDeliveryList) {\n-            // Do the actual recovery ...\n-            if (null != subscriber){\n-                // already handled in rollback ...\n-                assert false : \"unexpected ...\";\n-            }\n-            else if (null != sessionMessageListener){\n-                listenerDeliveryList.addFirst(this);\n-            }\n-        }\n-\n-        public void recoverForListener(){\n-            assert null == subscriber;\n-            assert null != sessionMessageListener;\n-\n-            try {\n-                final MessageImpl message = MessageUtil.createCloneForDispatch(SessionImpl.this,\n-                        receivedMessage.originalMessage,\n-                        receivedMessage.originalMessage.getSourceName(),\n-                        receivedMessage.originalMessage.getSubscriberId());\n-                deliverToListener(sessionMessageListener, receivedMessage, message, true);\n-            } catch (JMSException e) {\n-                // Unexpected not to be able to clone ...\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Unexpected exception trying to process message\");\n-                    DebugUtil.dumpJMSStacktrace(logger, e);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"TransactedReceiveOperation\");\n-            sb.append(\"{receivedMessage=\").append(receivedMessage);\n-            sb.append(\", sessionMessageListener=\").append(sessionMessageListener);\n-            sb.append(\", subscriber=\").append(subscriber);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-\n-    // For txn support.\n-    private final Object transactionLock = new Object();\n-    private final List<TransactedOperation> transactedOperation = new LinkedList<TransactedOperation>();\n-\n-    private void rollbackTransactionState(){\n-        final ArrayList<TransactedOperation> transactedOperationCopy;\n-        synchronized (transactionLock){\n-            transactedOperationCopy = new ArrayList<TransactedOperation>(transactedOperation);\n-            transactedOperation.clear();\n-        }\n-        rollbackTransactionState(transactedOperationCopy);\n-    }\n-\n-    private void rollbackTransactionState(ArrayList<TransactedOperation> transactedOperationCopy){\n-\n-        if (logger.isDebugEnabled()) logger.debug(\"Attempting to rollback \" +\n-            transactedOperationCopy.size() + \" operations\");\n-        if (logger.isTraceEnabled()) logger.trace(\"Operations : \" + transactedOperationCopy);\n-\n-        // Rollback MUST be in reverse order !\n-        final int size = transactedOperationCopy.size();\n-        for (int i = size - 1;i >= 0; i --){\n-            TransactedOperation op = transactedOperationCopy.get(i);\n-            op.rollback();\n-        }\n-    }\n-\n-\n-    // Note: the messageImpl MUST be a copy of what the user sent - so that modifications by user\n-    // WILL NOT affect this.\n-    public void enqueuePublishWithinTransaction(String topicName, MessageImpl messageImpl, Message userMessage) {\n-        TransactedSendOperation sendOperation = new TransactedSendOperation(topicName, messageImpl, userMessage);\n-        synchronized (transactionLock){\n-            transactedOperation.add(sendOperation);\n-        }\n-    }\n-\n-    private void enqueueReceiveWithinTransaction(TransactedReceiveOperation receiveOperation) {\n-        synchronized (transactionLock){\n-            transactedOperation.add(receiveOperation);\n-        }\n-    }\n-\n-    private void commitTransactionState() throws JMSException {\n-        final ArrayList<TransactedOperation> transactedOperationCopy;\n-        synchronized (transactionLock){\n-            transactedOperationCopy = new ArrayList<TransactedOperation>(transactedOperation);\n-            transactedOperation.clear();\n-        }\n-\n-        if (!sessionState.isStarted()){\n-            // Ensure that there are ONLY send op's - else throw TransactionRolledBackException : we\n-            // cannot ack message !\n-            for (TransactedOperation op : transactedOperationCopy){\n-                if (op.requiresStartedSession())\n-                  throw new TransactionRolledBackException(\"Commit failed : session is not open - cant ack message\");\n-            }\n-        }\n-\n-        for (TransactedOperation op : transactedOperationCopy){\n-            try {\n-                op.commit();\n-            } catch (JMSException jEx){\n-                if (logger.isDebugEnabled()) logger.debug(\"Commit failed for \" + op, jEx);\n-                rollbackTransactionState(transactedOperationCopy);\n-                TransactionRolledBackException trbEx = new TransactionRolledBackException(\"Commit failed\");\n-                trbEx.setLinkedException(jEx);\n-                throw trbEx;\n-            }\n-        }\n-    }\n-\n-    public boolean isMessageExpired(MessageImpl message) {\n-        return 0 != message.getJMSExpiration() && SessionImpl.currentTimeMillis() > message.getJMSExpiration();\n-    }\n-\n-    public boolean isLocallyPublished(String messageId) {\n-        return connection.isLocallyPublished(messageId);\n-    }\n-\n-    public void addToLocallyPublishedMessageIds(String messageId) {\n-        connection.addToLocallyPublishedMessageIds(messageId);\n-    }\n-\n-    public ConnectionImpl getConnection() {\n-        return connection;\n-    }\n-\n-    private static final class Subscriptions {\n-        // Keeps track of number of subscribers created. This will prevent setMessageListener form\n-        // succeeding in case subscriberCreatedCount > 0\n-        // Their use is mutually exclusive.\n-        // private int subscriberCreatedCount = 0;\n-        private AtomicInteger numSubscribers = new AtomicInteger(0);\n-\n-        private final ConcurrentHashMap<TopicSubscription, Node> topicSubscriptionToSelectorMap =\n-            new ConcurrentHashMap<TopicSubscription, Node>(32);\n-        private final ConcurrentHashMap<QueueSubscription, Node> queueSubscriptionToSelectorMap =\n-            new ConcurrentHashMap<QueueSubscription, Node>(32);\n-\n-        // We make use of concurrent api for this map (and its list) since we will be reading\n-        // it heavily concurrently while modifying it rarely.\n-        private final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> topicSubscriptionToSubscriberMap =\n-            new ConcurrentHashMap<Subscription, CopyOnWriteArrayList<MessageConsumer>>();\n-        private final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> queueSubscriptionToSubscriberMap =\n-            new ConcurrentHashMap<Subscription, CopyOnWriteArrayList<MessageConsumer>>();\n-\n-        // The value for the key is irrelevant - there is not\n-        private final Set<MessageConsumer> allConsumersSet = Collections.newSetFromMap(\n-            new IdentityHashMap<MessageConsumer, Boolean>());\n-\n-        private static final int SUBSCRIBER_ID_TO_DESTINATION_CACHE_SIZE =\n-            Integer.getInteger(\"SUBSCRIBER_ID_TO_DESTINATION_CACHE_SIZE\", 1024);\n-        // This is guarded by subscriberIdTo<Destination> lock - query/modify ONLY in that context !\n-        private final Map<String, String> topicSubscriberIdToTopicName =\n-            new LRUCacheMap<String, String>(SUBSCRIBER_ID_TO_DESTINATION_CACHE_SIZE, true);\n-\n-        public Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> createSubscriptionToSubscriberMapCopy() {\n-          Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> retval\n-              = new HashMap<Subscription, CopyOnWriteArrayList<MessageConsumer>>();\n-          retval.putAll(topicSubscriptionToSubscriberMap);\n-          retval.putAll(queueSubscriptionToSubscriberMap);\n-          return retval;\n-        }\n-\n-        public Set<MessageConsumer> getAllConsumersSet() {\n-          return allConsumersSet;\n-        }\n-\n-        public CopyOnWriteArrayList<? extends MessageConsumer> getSubscribers(Subscription subscription) {\n-            if (subscription.isTopic()) {\n-                assert subscription instanceof TopicSubscription;\n-                return topicSubscriptionToSubscriberMap.get(subscription);\n-            }\n-            if (subscription.isQueue()) {\n-                assert subscription instanceof QueueSubscription;\n-                return queueSubscriptionToSubscriberMap.get(subscription);\n-            }\n-            throw new IllegalArgumentException(\"Unknown subscription type \" + subscription);\n-        }\n-\n-        public Node getSelectorExpression(Subscription subscription) {\n-            if (subscription.isTopic()) {\n-                assert subscription instanceof TopicSubscription;\n-                return topicSubscriptionToSelectorMap.get(subscription);\n-            }\n-            if (subscription.isQueue()) {\n-                assert subscription instanceof QueueSubscription;\n-                return queueSubscriptionToSelectorMap.get(subscription);\n-            }\n-            throw new IllegalArgumentException(\"Unknown subscription type \" + subscription);\n-        }\n-\n-        public void registerSubscriberIdToTopic(String subscribedId, String topicName) throws JMSException {\n-            synchronized (topicSubscriberIdToTopicName){\n-                String currentTopicName = topicSubscriberIdToTopicName.get(subscribedId);\n-                if (null != currentTopicName && !currentTopicName.equals(topicName)) {\n-                    throw new JMSException(\"There is already a subscription in this session for \" +\n-                        \"same subscriberId for topic \" + currentTopicName);\n-                }\n-                topicSubscriberIdToTopicName.put(subscribedId, topicName);\n-            }\n-        }\n-\n-        public String findTopicNameForSubscriberId(String subscribedId) throws JMSException {\n-            synchronized (topicSubscriberIdToTopicName){\n-                String topicName = topicSubscriberIdToTopicName.get(subscribedId);\n-                if (null == topicName){\n-                    throw new JMSException(\"Unable to find topicName for subscriberId \" + subscribedId);\n-                }\n-                return topicName;\n-            }\n-        }\n-\n-        public void registerTopicSubscriptionSelector(TopicSubscription topicSubscription, Node selectorAst) {\n-            topicSubscriptionToSelectorMap.put(topicSubscription, selectorAst);\n-        }\n-\n-        public void registerQueueSubscriptionSelector(QueueSubscription queueSubscription, Node selectorAst) {\n-            queueSubscriptionToSelectorMap.put(queueSubscription, selectorAst);\n-        }\n-\n-        public boolean addToSubscriberSet(MessageConsumer consumer) {\n-            return allConsumersSet.add(consumer);\n-        }\n-\n-        public boolean addToSubscribers(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n-                                        String destination, String subscriberId) {\n-            switch (type){\n-              case QUEUE :\n-                return createIfMissingAndAdd(queueSubscriptionToSubscriberMap,\n-                    new QueueSubscription(destination, subscriberId),\n-                    subscriber);\n-              case TOPIC:\n-                return createIfMissingAndAdd(topicSubscriptionToSubscriberMap,\n-                    new TopicSubscription(destination, subscriberId),\n-                    subscriber);\n-              default:\n-                  throw new IllegalArgumentException(\"Unknown subscription type \" + type);\n-            }\n-        }\n-\n-        public boolean removeSubscriber(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n-                                        String destination, String subscriberId) {\n-            boolean retval = false;\n-            switch (type){\n-                case TOPIC:\n-                {\n-                    final CopyOnWriteArrayList<MessageConsumer> subscriberList =\n-                        topicSubscriptionToSubscriberMap.get(new TopicSubscription(destination, subscriberId));\n-                    if (null != subscriberList) {\n-                        if (subscriberList.remove(subscriber)){\n-                            numSubscribers.decrementAndGet();\n-                            if (subscriberList.isEmpty()){\n-                                // Unsubscribe\n-                                retval = true;\n-                            }\n-                        }\n-                    }\n-                    else retval = true;\n-                    break;\n-                }\n-                case QUEUE:\n-                {\n-                    final CopyOnWriteArrayList<MessageConsumer> subscriberList =\n-                        queueSubscriptionToSubscriberMap.get(new QueueSubscription(destination, subscriberId));\n-                    if (null != subscriberList) {\n-                        if (subscriberList.remove(subscriber)){\n-                            numSubscribers.decrementAndGet();\n-                            if (subscriberList.isEmpty()){\n-                                // Unsubscribe\n-                                retval = true;\n-                            }\n-                        }\n-                    }\n-                    else retval = true;\n-                    break;\n-                }\n-                default:\n-                    throw new IllegalArgumentException(\"Unknown subscription type \" + type);\n-            }\n-            return retval;\n-        }\n-\n-        // returns true IF a new list is inserted.\n-        private boolean createIfMissingAndAdd(Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> map,\n-                                              Subscription key, MessageConsumer value) {\n-            boolean retval = false;\n-            if (!map.containsKey(key)) {\n-                map.put(key, new CopyOnWriteArrayList<MessageConsumer>());\n-            }\n-\n-            List<MessageConsumer>  list = map.get(key);\n-            if (list.isEmpty()) retval = true;\n-            if (!list.contains(value)) {\n-                list.add(value);\n-                numSubscribers.incrementAndGet();\n-            }\n-            return retval;\n-        }\n-\n-        public int getNumSubscribers() {\n-            return numSubscribers.get();\n-        }\n-    }\n-}"},{"sha":"26db51499e2337ce62f3abd59a3a40dbf0059920","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java","status":"removed","additions":0,"deletions":179,"changes":179,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,179 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms;\n-\n-import org.slf4j.Logger;\n-\n-import javax.jms.JMSException;\n-\n-\n-/**\n-    Specific to jms package - NOT to be used elsewhere.\n-\n-    The util class allows for managing the current readiness 'state' of the object which hosts it\n-    along the axis of StateManager.State while being MT safe. Right now, both Connection and Session make use of it.\n-\n-    The lockObject is used to do timed wait's (which the host object will notify on) in case of async state changes.\n-\n-\n-    This is not a general purpose code, but specific to state transitions mentioned in jms spec.\n-\n-\n-    All use of the class goes like this :\n-\n-\n-    StateManager.State prevState;\n-    acquire lock:\n-        if in transition state, wait.\n-        if in expected state, return.\n-        if in error state, return/throw exception.\n-        if in valid state transition state -\n-            prevState = currentState.\n-            set to corresponding transition state (STARTING, CLOSING, etc).\n-        Other method specific changes.\n-    release lock:\n-\n-    nextState = prevState (in case state change failed, revert).\n-\n-    try {\n-        attempt state change.\n-        on success nextState = next valid state for this method.\n-    } finally {\n-        acquire lock:\n-          change state to nextState\n-        release lock:\n-    }\n-\n-    * So at any given point of time, the state will be in transition ONLY when there is an attempt\n-            being made to transition.\n-    * The state will always be in a final state at all other points of time.\n-    * No attempt will be made to change state while a transition state is currently in progress.\n- */\n-final class StateManager {\n-  public static final long WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE =\n-      Long.getLong(\"WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE\", 16000L);\n-\n-  static enum State {\n-        STARTING(true, false, true),\n-        STARTED(true, false, false),\n-        STOPPING(false, false, true),\n-        STOPPED(false, false, false),\n-        CLOSING(false, true, true),\n-        CLOSED(false, true, false);\n-\n-        private final boolean inStartMode;\n-        private final boolean inCloseMode;\n-        private final boolean inTransitionMode;\n-\n-        State(boolean inStartMode, boolean inCloseMode, boolean inTransitionMode) {\n-            this.inStartMode = inStartMode;\n-            this.inCloseMode = inCloseMode;\n-            this.inTransitionMode = inTransitionMode;\n-        }\n-\n-        public boolean isInStartMode() {\n-            return inStartMode;\n-        }\n-\n-        public boolean isInCloseMode() {\n-            return inCloseMode;\n-        }\n-\n-        public boolean isInTransitionMode() {\n-            return inTransitionMode;\n-        }\n-    }\n-\n-    // DO NOT do something silly like State.STARTING == currentState || State.STARTED == currentState, etc !\n-    private volatile State currentState;\n-    private final Object lockObject;\n-\n-    StateManager(State startStart, Object lockObject){\n-        this.currentState = startStart;\n-        this.lockObject = lockObject;\n-    }\n-\n-    State getCurrentState() {\n-        return currentState;\n-    }\n-\n-    boolean isStarted() {\n-        return State.STARTED == currentState;\n-    }\n-\n-    boolean isInStartMode() {\n-        return currentState.isInStartMode();\n-    }\n-\n-    boolean isStopped() {\n-        return State.STOPPED == currentState;\n-    }\n-\n-    boolean isClosed() {\n-        return State.CLOSED == currentState;\n-    }\n-\n-    // NOT locking explicitly : typically, already locked on lockObject\n-    boolean isInCloseMode() {\n-        return currentState.isInCloseMode();\n-    }\n-\n-    // NOT locking explicitly : typically, already locked on lockObject\n-    boolean isTransitionState() {\n-        return currentState.isInTransitionMode();\n-    }\n-\n-    void setCurrentState(State currentState) {\n-        this.currentState = currentState;\n-    }\n-\n-    // NOT locking explicitly : MUST be already locked on lockObject\n-    void waitForTransientStateChange(long timeout, Logger logger) throws JMSException {\n-        final long startTime = SessionImpl.currentTimeMillis();\n-        final int WAIT_UNIT = 100;\n-        int retryCount = (int)(timeout / WAIT_UNIT);\n-\n-        while (isTransitionState()) {\n-            try {\n-                // If we are NOT locked on lockObject, this will throw exception !\n-                lockObject.wait(WAIT_UNIT);\n-            } catch (InterruptedException e) {\n-                // bubble it up.\n-                JMSException jex = new JMSException(\"Thread interrupted ... \" + e);\n-                jex.setLinkedException(e);\n-                throw jex;\n-            }\n-            retryCount --;\n-            if (retryCount <= 0) {\n-                if (logger.isDebugEnabled()) DebugUtil.dumpAllStacktraces(logger);\n-                // throw new JMSException(\"wait timeout \" + (SessionImpl.currentTimeMillis() - startTime));\n-                throw new JMSException(\"wait for \" + (SessionImpl.currentTimeMillis() - startTime) + \" timeout\");\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"StateManager\");\n-        sb.append(\"{currentState=\").append(currentState);\n-        sb.append('}');\n-        return sb.toString();\n-    }\n-}"},{"sha":"2e0cddd7ca8d93ba7cfffda620213100b56b1230","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java","status":"removed","additions":0,"deletions":106,"changes":106,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,106 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.jndi;\n-\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-\n-import javax.jms.ConnectionFactory;\n-import javax.naming.Name;\n-import javax.naming.NamingException;\n-import javax.naming.directory.InitialDirContext;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Hashtable;\n-import java.util.Set;\n-\n-/**\n- * Based (very very loosely) on\n- * <a href=\"http://docs.oracle.com/javase/1.3/docs/guide/jndi/spec/spi/jndispi.fm.html\">jndi guide</a>. <br/>\n- * The InitialContext implementation clients should be using to get to our implementation. <br/>\n- * It is possible (by configuring via administrative means for example) to use a different DirContext\n- * to get to our provider implementation\n- * if the various classes exposed are the same as exposed via this DirContext.<br/>\n- * <p/>\n- * Ideally, the env property\n- * {@link javax.naming.Context.INITIAL_CONTEXT_FACTORY} \"java.naming.factory.initial\" is set to our factory\n- * {@link HedwigInitialContextFactory} classname which will return this InitialDirContext.\n- */\n-public class HedwigInitialContext extends InitialDirContext {\n-\n-    public static final String CONNECTION_FACTORY_NAME = \"jms/ConnectionFactory\";\n-    public static final String TOPIC_CONNECTION_FACTORY_NAME = \"jms/TopicConnectionFactory\";\n-    // public static final String QUEUE_CONNECTION_FACTORY_NAME = \"jms/QueueConnectionFactory\";\n-\n-    // Hardcoding to point to HedwigConnectionFactoryImpl by default.\n-    private static final Set<String> defaultNamesMapping;\n-    static {\n-        Set<String> set = new HashSet<String>(8);\n-\n-        // The actual name's for the various factories are bound by an admin. For convinence sake,\n-        // we are providing default bindings.\n-\n-        // The default connection\n-        set.add(\"jms/ConnectionFactory\");\n-        set.add(\"jms/TopicConnectionFactory\");\n-        // Add in future - for now, we do not support it.\n-        // set.add(\"jms/QueueConnectionFactory\");\n-\n-\n-        set.add(\"ConnectionFactory\");\n-        set.add(\"TopicConnectionFactory\");\n-        // Add in future - for now, we do not support it.\n-        // set.add(\"QueueConnectionFactory\");\n-        defaultNamesMapping = Collections.unmodifiableSet(set);\n-    }\n-\n-    protected HedwigInitialContext(boolean lazy) throws NamingException {\n-        super(lazy);\n-    }\n-\n-    public HedwigInitialContext() throws NamingException {\n-        super();\n-    }\n-\n-    public HedwigInitialContext(Hashtable<?, ?> environment) throws NamingException {\n-        super(environment);\n-    }\n-\n-    private ConnectionFactory ourLookup(String name){\n-        if (defaultNamesMapping.contains(name)){\n-            return new HedwigConnectionFactoryImpl();\n-        }\n-\n-        return null;\n-    }\n-\n-    @Override\n-    public Object lookup(String name) throws NamingException {\n-        ConnectionFactory factory = ourLookup(name);\n-        if (null != factory) return factory;\n-\n-        return super.lookup(name);\n-    }\n-\n-    @Override\n-    public Object lookup(Name name) throws NamingException {\n-        ConnectionFactory factory = ourLookup(name.toString());\n-        if (null != factory) return factory;\n-\n-        return super.lookup(name);\n-    }\n-}\n\\ No newline at end of file"},{"sha":"b701aad3256b689b0e7048cb784a5c9d89fd6f0d","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java","status":"removed","additions":0,"deletions":33,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,33 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.jndi;\n-\n-import javax.naming.Context;\n-import javax.naming.NamingException;\n-import javax.naming.spi.InitialContextFactory;\n-import java.util.Hashtable;\n-\n-/**\n- * See HedwigInitialContext for more information.\n- */\n-public class HedwigInitialContextFactory implements InitialContextFactory {\n-    @Override\n-    public Context getInitialContext(Hashtable<?, ?> environment) throws NamingException {\n-        return new HedwigInitialContext(environment);\n-    }\n-}"},{"sha":"bab5787c4c6d7849888e41872a34c034fbb08248","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,65 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-\n-Contains some default SHIM's to interface with JNDI - so that clients can use our JMS provider without\n-ANY code level ties.<br/>\n-The ideal way to use JNDI is to have administrator configure JNDI such that a well-known jndi NAME is\n-bound to \"org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl\" for Topic and JMS connection factory. <br/>\n-<p/>\n-<p/>\n-Alternatively, if the user is NOT within an admin controlled JNDI environment, there are two other\n-common options : <br/>\n-<ul>\n-  <li>Set the \"java.naming.factory.initial\" environment property to our Context factory\n-    \"org.apache.hedwig.jms.jndi.HedwigInitialContextFactory\"</li>\n-  <li>Directly instantiate the \"org.apache.hedwig.jms.jndi.HedwigInitialContext\" as a JNDI InitialContext\n-    and pull the relevant factories, via it.</li>\n-</ul>\n-\n-In either of these two cases, we expose 6 well defined 'names' for users, to pull the relevant\n-factories from the JNDI context.\n-<table border=\"1\">\n-  <tr>\n-    <th>JNDI name</th>\n-    <th>Connection factory</th>\n-  </tr>\n-  <tr>\n-    <td>jms/ConnectionFactory</td>\n-    <td>ConnectionFactory</td>\n-  </tr>\n-  <tr>\n-    <td>jms/TopicConnectionFactory</td>\n-    <td>TopicConnectionFactory</td>\n-  </tr>\n-  <tr>\n-    <td>jms/QueueConnectionFactory</td>\n-    <td>QueueConnectionFactory</td>\n-  </tr>\n-  <tr>\n-    <td>ConnectionFactory</td>\n-    <td>ConnectionFactory</td>\n-  </tr>\n-  <tr>\n-    <td>TopicConnectionFactory</td>\n-    <td>TopicConnectionFactory</td>\n-  </tr>\n-  <tr>\n-    <td>QueueConnectionFactory</td>\n-    <td>QueueConnectionFactory</td>\n-  </tr>\n-</table>"},{"sha":"fb564dcd5c23e9471741c7a8c439ef48140482cb","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java","status":"removed","additions":0,"deletions":657,"changes":657,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,657 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-\n-import javax.jms.BytesMessage;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageEOFException;\n-import javax.jms.MessageNotReadableException;\n-import javax.jms.MessageNotWriteableException;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.util.Map;\n-\n-/**\n- * To be used for raw bytes ...\n- */\n-public class BytesMessageImpl extends MessageImpl implements BytesMessage {\n-    private ReadOnlyMessage readOnlyMessage;\n-    private WriteOnlyMessage writeOnlyMessage;\n-    private boolean readMode;\n-\n-    public BytesMessageImpl(SessionImpl session) throws JMSException {\n-        super(session);\n-        clearBody();\n-    }\n-\n-    // To clone a message\n-    public BytesMessageImpl(SessionImpl session, BytesMessageImpl message, String sourceTopicName,\n-                            String subscriberId) throws JMSException {\n-        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n-        try {\n-            if (message.readMode){\n-                this.readOnlyMessage = new ReadOnlyMessage(message.readOnlyMessage.getDataCopy());\n-                this.writeOnlyMessage = null;\n-            }\n-            else {\n-                this.readOnlyMessage = null;\n-                this.writeOnlyMessage = new WriteOnlyMessage(message.writeOnlyMessage.getPayloadAsBytes());\n-            }\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-        this.readMode = message.readMode;\n-    }\n-\n-    // To clone a message from a BytesMessage which is NOT BytesMessageImpl\n-    // Changing order of parameter to NOT accidentally clash with the constructor above.\n-    // This is midly confusing, but helps a lot in preventing accidental bugs !\n-    public BytesMessageImpl(BytesMessage message, SessionImpl session) throws JMSException {\n-        super((Message) message, session);\n-\n-        if (message instanceof BytesMessageImpl) {\n-            throw new JMSException(\"Coding bug - should use this constructor ONLY for non \" +\n-                \"BytesMessageImpl messages\");\n-        }\n-\n-        // copy the bytes ...\n-        final byte[] data;\n-        {\n-            final long length = message.getBodyLength();\n-            if (length < 0 || length >= Integer.MAX_VALUE) throw new JMSException(\"Unreasonably \" +\n-                \"large value for body Length : \" + length);\n-\n-            data = new byte[(int) length];\n-            int read = 0;\n-            while (read < length){\n-                int sz = message.readBytes(data, read);\n-                read += sz;\n-            }\n-        }\n-\n-        try {\n-            this.writeOnlyMessage = new WriteOnlyMessage(data);\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-        this.readOnlyMessage  = null;\n-        this.readMode = true;\n-    }\n-\n-    public BytesMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n-                            String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n-        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n-\n-        this.readOnlyMessage = new ReadOnlyMessage(message.getBody().toByteArray());\n-        this.writeOnlyMessage = null;\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    protected MessageUtil.SupportedMessageTypes  getJmsMessageType() {\n-        return MessageUtil.SupportedMessageTypes.BYTES;\n-    }\n-\n-    protected boolean isBodyEmpty(){\n-        return false;\n-    }\n-\n-    @Override\n-    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n-        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n-        super.populateBuilderWithHeaders(builder);\n-\n-        // Now set body and type.\n-        try {\n-            builder.setBody(ByteString.copyFrom(getPayloadData()));\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-\n-        return builder.build();\n-    }\n-\n-    @Override\n-    public long getBodyLength() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        return readOnlyMessage.getBodyLength();\n-    }\n-\n-    @Override\n-    public boolean readBoolean() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readBoolean();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public byte readByte() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readByte();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readUnsignedByte() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readUnsignedByte();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public short readShort() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readShort();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readUnsignedShort() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readUnsignedShort();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public char readChar() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readChar();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readInt() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readInt();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public long readLong() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readLong();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public float readFloat() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readFloat();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public double readDouble() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readDouble();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public String readUTF() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readUTF();\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readBytes(byte[] data) throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readBytes(data);\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readBytes(byte[] data, int length) throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readBytes(data, length);\n-        } catch (IOException eof){\n-            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n-            eofEx.setLinkedException(eof);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeBoolean(boolean val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeBoolean(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeByte(byte val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeByte(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeShort(short val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeShort(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeChar(char val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeChar(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeInt(int val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeInt(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeLong(long val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeLong(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeFloat(float val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeFloat(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeDouble(double val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeDouble(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeUTF(String val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeUTF(val);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeBytes(byte[] data) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeBytes(data);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeBytes(byte[] data, int offset, int length) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeBytes(data, offset, length);\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    // This method is ONLY supposed to be used for object form of primitive types !\n-    @Override\n-    public void writeObject(Object obj) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            // unrolling it\n-            if (obj instanceof Boolean) {\n-                writeOnlyMessage.writeBoolean((Boolean) obj);\n-            }\n-            else if (obj instanceof Byte) {\n-                writeOnlyMessage.writeByte((Byte) obj);\n-            }\n-            else if (obj instanceof Short) {\n-                writeOnlyMessage.writeShort((Short) obj);\n-            }\n-            else if (obj instanceof Character) {\n-                writeOnlyMessage.writeChar((Character) obj);\n-            }\n-            else if (obj instanceof Integer) {\n-                writeOnlyMessage.writeInt((Integer) obj);\n-            }\n-            else if (obj instanceof Long) {\n-                writeOnlyMessage.writeLong((Long) obj);\n-            }\n-            else if (obj instanceof Float) {\n-                writeOnlyMessage.writeFloat((Float) obj);\n-            }\n-            else if (obj instanceof Double) {\n-                writeOnlyMessage.writeDouble((Double) obj);\n-            }\n-            else if (obj instanceof String) {\n-                writeOnlyMessage.writeUTF((String) obj);\n-            }\n-            else if (obj instanceof byte[]) {\n-                writeOnlyMessage.writeBytes((byte[]) obj);\n-            }\n-            else{\n-                throw new JMSException(\"Unsupported type for obj : \" + obj.getClass());\n-            }\n-        } catch (IOException ioEx){\n-            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void reset() throws JMSException {\n-        if (this.readMode) return ;\n-        try {\n-            this.readOnlyMessage = new ReadOnlyMessage(writeOnlyMessage.getPayloadAsBytes());\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to convert write-only message to read-only message .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-        this.readMode = true;\n-        this.writeOnlyMessage = null;\n-    }\n-\n-    @Override\n-    public void clearBody() throws JMSException {\n-        super.clearBody();\n-        this.writeOnlyMessage = new WriteOnlyMessage();\n-        this.readOnlyMessage = null;\n-        this.readMode = false;\n-    }\n-\n-    private byte[] getPayloadData() throws IOException {\n-        if (readMode) return readOnlyMessage.getDataCopy();\n-        return writeOnlyMessage.getPayloadAsBytes();\n-    }\n-\n-    @Override\n-    BytesMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId)\n-        throws JMSException {\n-        return new BytesMessageImpl(session, this, sourceTopicName, subscriberId);\n-    }\n-\n-    // Using java object's instead of primitives to avoid having to store schema separately.\n-    private static class ReadOnlyMessage {\n-\n-        private final DataInputStream dis;\n-        private final byte[] data;\n-\n-        public ReadOnlyMessage(byte[] data) {\n-            this.dis = new DataInputStream(new ByteArrayInputStream(data));\n-            this.data = data;\n-        }\n-\n-        public byte[] getDataCopy(){\n-            byte[] retval = new byte[data.length];\n-            System.arraycopy(data, 0, retval, 0, retval.length);\n-            return retval;\n-        }\n-\n-        public int getBodyLength() {\n-            return data.length;\n-        }\n-\n-        public boolean readBoolean() throws IOException {\n-            return dis.readBoolean();\n-        }\n-\n-        public byte readByte() throws IOException {\n-            return dis.readByte();\n-        }\n-\n-        public int readUnsignedByte() throws IOException {\n-            return dis.readUnsignedByte();\n-        }\n-\n-        public short readShort() throws IOException {\n-            return dis.readShort();\n-        }\n-\n-        public int readUnsignedShort() throws IOException {\n-            return dis.readUnsignedShort();\n-        }\n-\n-        public char readChar() throws IOException {\n-            return dis.readChar();\n-        }\n-\n-        public int readInt() throws IOException {\n-            return dis.readInt();\n-        }\n-\n-        public long readLong() throws IOException {\n-            return dis.readLong();\n-        }\n-\n-        public float readFloat() throws IOException {\n-            return dis.readFloat();\n-        }\n-\n-        public double readDouble() throws IOException {\n-            return dis.readDouble();\n-        }\n-\n-        public String readUTF() throws IOException {\n-            return dis.readUTF();\n-        }\n-\n-        public int readBytes(byte[] data) throws IOException {\n-            return dis.read(data);\n-        }\n-\n-        public int readBytes(byte[] data, int length) throws IOException {\n-            if (length < 0 || length > data.length)\n-              throw new IndexOutOfBoundsException(\"Invalid length specified : \" + length + \", data : \" + data.length);\n-            return dis.read(data, 0, length);\n-        }\n-    }\n-\n-    private static class WriteOnlyMessage {\n-\n-        private final ByteArrayOutputStream baos;\n-        private final DataOutputStream dos;\n-\n-        public WriteOnlyMessage(){\n-            baos = new ByteArrayOutputStream();\n-            dos = new DataOutputStream(baos);\n-        }\n-\n-        public WriteOnlyMessage(byte[] data) throws IOException {\n-            baos = new ByteArrayOutputStream();\n-            dos = new DataOutputStream(baos);\n-            dos.write(data);\n-        }\n-\n-        public byte[] getPayloadAsBytes() throws IOException {\n-            dos.flush();\n-            return baos.toByteArray();\n-        }\n-\n-        public void writeBoolean(boolean val) throws IOException {\n-            dos.writeBoolean(val);\n-        }\n-\n-        public void writeByte(byte val) throws IOException {\n-            dos.writeByte(val);\n-        }\n-\n-        public void writeShort(short val) throws IOException {\n-            dos.writeShort(val);\n-        }\n-\n-        public void writeChar(char val) throws IOException {\n-            dos.writeChar(val);\n-        }\n-\n-        public void writeInt(int val) throws IOException {\n-            dos.writeInt(val);\n-        }\n-\n-        public void writeLong(long val) throws IOException {\n-            dos.writeLong(val);\n-        }\n-\n-        public void writeFloat(float val) throws IOException {\n-            dos.writeFloat(val);\n-        }\n-\n-        public void writeDouble(double val) throws IOException {\n-            dos.writeDouble(val);\n-        }\n-\n-        public void writeUTF(String val) throws IOException {\n-            dos.writeUTF(val);\n-        }\n-\n-        public void writeBytes(byte[] data) throws IOException {\n-            dos.write(data);\n-        }\n-\n-        public void writeBytes(byte[] data, int offset, int length) throws IOException {\n-            dos.write(data, offset, length);\n-        }\n-    }\n-}\n\\ No newline at end of file"},{"sha":"af806fb4a5bbd39d078da93df892e424f9b036c2","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java","status":"removed","additions":0,"deletions":295,"changes":295,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,295 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-\n-import javax.jms.JMSException;\n-import javax.jms.MapMessage;\n-import javax.jms.Message;\n-import javax.jms.MessageNotWriteableException;\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-\n-/**\n- * There is a weaker expectation of ordering and strong expectation of &lt;key, value&gt; container for data.\n- */\n-public class MapMessageImpl extends MessageImpl implements MapMessage {\n-    private final Map<String, Object> payload = new LinkedHashMap<String, Object>(4);\n-    private boolean readMode;\n-\n-    public MapMessageImpl(SessionImpl session) throws JMSException {\n-        super(session);\n-        clearBody();\n-    }\n-\n-    public MapMessageImpl(SessionImpl session, MapMessageImpl message, String sourceTopicName,\n-                          String subscriberId) throws JMSException {\n-        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n-        this.payload.putAll(message.payload);\n-        this.readMode = message.readMode;\n-    }\n-\n-    // To clone a message from a MapMessage which is NOT MapMessageImpl\n-    // Changing order of parameter to NOT accidentally clash with the constructor above.\n-    // This is midly confusing, but helps a lot in preventing accidental bugs !\n-    public MapMessageImpl(MapMessage message, SessionImpl session) throws JMSException {\n-        super((Message) message, session);\n-\n-        if (message instanceof MapMessageImpl) {\n-            throw new JMSException(\"Coding bug - should use this constructor ONLY for non MapMessageImpl messages\");\n-        }\n-\n-\n-        Enumeration keys = message.getMapNames();\n-        while (keys.hasMoreElements()){\n-            Object key = keys.nextElement();\n-            if (!(key instanceof String))\n-              throw new JMSException(\"Unsupported type (expected String) for key : \" + key);\n-\n-            String skey = (String) key;\n-            this.payload.put(skey, message.getObject(skey));\n-        }\n-        this.readMode = false;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public MapMessageImpl(SessionImpl session, PubSubProtocol.Message message,\n-                          Map<String, Object> properties, String sourceTopicName, String subscriberId,\n-                          Runnable ackRunnable) throws JMSException {\n-        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n-        try {\n-            this.payload.putAll((Map<String, Object>) MessageUtil.bytesToObject(message.getBody().toByteArray()));\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    protected MessageUtil.SupportedMessageTypes  getJmsMessageType() {\n-        return MessageUtil.SupportedMessageTypes.MAP;\n-    }\n-\n-    protected boolean isBodyEmpty(){\n-        return false;\n-    }\n-\n-    @Override\n-    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n-        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n-        super.populateBuilderWithHeaders(builder);\n-\n-        // Now set body and type.\n-        try {\n-            builder.setBody(ByteString.copyFrom(MessageUtil.objectToBytes(this.payload)));\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-\n-        return builder.build();\n-    }\n-\n-    @Override\n-    public boolean getBoolean(String name) throws JMSException {\n-        return MessageUtil.asBoolean(payload.get(name));\n-    }\n-\n-    @Override\n-    public byte getByte(String name) throws JMSException {\n-        return MessageUtil.asByte(payload.get(name));\n-    }\n-\n-    @Override\n-    public short getShort(String name) throws JMSException {\n-        return MessageUtil.asShort(payload.get(name));\n-    }\n-\n-    @Override\n-    public char getChar(String name) throws JMSException {\n-        return MessageUtil.asChar(payload.get(name));\n-    }\n-\n-    @Override\n-    public int getInt(String name) throws JMSException {\n-        return MessageUtil.asInteger(payload.get(name));\n-    }\n-\n-    @Override\n-    public long getLong(String name) throws JMSException {\n-        return MessageUtil.asLong(payload.get(name));\n-    }\n-\n-    @Override\n-    public float getFloat(String name) throws JMSException {\n-        return MessageUtil.asFloat(payload.get(name));\n-    }\n-\n-    @Override\n-    public double getDouble(String name) throws JMSException {\n-        return MessageUtil.asDouble(payload.get(name));\n-    }\n-\n-    @Override\n-    public String getString(String name) throws JMSException {\n-        return MessageUtil.asString(payload.get(name));\n-    }\n-\n-    @Override\n-    public byte[] getBytes(String name) throws JMSException {\n-        return MessageUtil.asBytes(payload.get(name));\n-    }\n-\n-    @Override\n-    public Object getObject(String name) throws JMSException {\n-        return payload.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration getMapNames() throws JMSException {\n-        return Collections.enumeration(payload.keySet());\n-    }\n-\n-    @Override\n-    public void setBoolean(String name, boolean value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-    }\n-\n-    @Override\n-    public void setByte(String name, byte value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setShort(String name, short value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setChar(String name, char value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setInt(String name, int value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setLong(String name, long value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setFloat(String name, float value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setDouble(String name, double value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setString(String name, String value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setBytes(String name, byte[] value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setBytes(String name, byte[] value, int i, int i1) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public void setObject(String name, Object value) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n-        payload.put(name, value);\n-\n-    }\n-\n-    @Override\n-    public boolean itemExists(String name) throws JMSException {\n-        return payload.containsKey(name);\n-    }\n-\n-    @Override\n-    public void clearBody() throws JMSException {\n-        super.clearBody();\n-        // allow read and write.\n-        this.payload.clear();\n-        this.readMode = false;\n-    }\n-\n-    @Override\n-    public void reset() throws JMSException {\n-        if (this.readMode) return ;\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    MapMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId) throws JMSException {\n-        return new MapMessageImpl(session, this, sourceTopicName, subscriberId);\n-    }\n-}"},{"sha":"d13feb033427fbe9cdce8118224ccd66df3ad838","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java","status":"removed","additions":0,"deletions":872,"changes":872,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,872 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.message.header.MetadataProcessor;\n-import org.apache.hedwig.jms.selector.SelectorEvaluationException;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageFormatException;\n-import javax.jms.MessageNotWriteableException;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Implementation of a message.\n- */\n-public class MessageImpl implements Message {\n-\n-    // This is of type byte for now - enough ?\n-    public static final String JMS_MESSAGE_TYPE_KEY = \"jmsBodyType\";\n-    // 'others' (non-jms clients) can depend on this boolean metadata property : for now, part\n-    // of jms values directly due to how metadata is being designed !\n-    // sigh :-(\n-    public static final String EMPTY_BODY_KEY = \"bodyEmpty\";\n-\n-\n-    private final static Logger logger = LoggerFactory.getLogger(MessageImpl.class);\n-\n-    public static final String JMS_MESSAGE_ID = \"JMSMessageID\";\n-    public static final String JMS_TIMESTAMP = \"JMSTimestamp\";\n-    public static final String JMS_CORRELATION_ID = \"JMSCorrelationID\";\n-    public static final String JMS_REPLY_TO = \"JMSReplyTo\";\n-    public static final String JMS_DESTINATION = \"JMSDestination\";\n-    public static final String JMS_DELIVERY_MODE = \"JMSDeliveryMode\";\n-    public static final String JMS_REDELIVERED = \"JMSRedelivered\";\n-    public static final String JMS_TYPE = \"JMSType\";\n-    public static final String JMS_EXPIRATION = \"JMSExpiration\";\n-    public static final String JMS_PRIORITY = \"JMSPriority\";\n-\n-    private static final Set<String> standardProperties;\n-    static {\n-        Set<String> set = new HashSet<String>(16);\n-        set.add(JMS_MESSAGE_ID);\n-        set.add(JMS_TIMESTAMP);\n-        set.add(JMS_CORRELATION_ID);\n-\n-        set.add(JMS_REPLY_TO);\n-        set.add(JMS_DESTINATION);\n-        set.add(JMS_DELIVERY_MODE);\n-\n-        // Currently simulated in provider - NOT from hedwig.\n-        set.add(JMS_REDELIVERED);\n-        set.add(JMS_TYPE);\n-\n-        set.add(JMS_EXPIRATION);\n-        set.add(JMS_PRIORITY);\n-\n-        standardProperties = Collections.unmodifiableSet(set);\n-    }\n-\n-    private final SessionImpl session;\n-    private final String serverJmsMessageId;\n-\n-    private String jmsMessageId;\n-    private long jmsTimestamp = 0;\n-    private String jmsCorrelationID;\n-\n-    private Destination jmsReplyTo;\n-    private Destination jmsDestination;\n-    private int jmsDeliveryMode = DeliveryMode.PERSISTENT;\n-\n-    private boolean jmsRedelivered;\n-    private String jmsType;\n-\n-    private long jmsExpiration = 0L;\n-    private int jmsPriority = Message.DEFAULT_PRIORITY;\n-\n-    // Note: this DOES NOT contain standard headers - which are explicitly handled.\n-    private boolean propertiesReadOnly = false;\n-    protected Map<String, Object> properties = new HashMap<String, Object>(4);\n-\n-    // key == standard property.\n-    private Set<String> standardPropertiesExists = new HashSet<String>(16);\n-    private Set<String> standardPropertiesExistsForWire = new HashSet<String>(16);\n-\n-    private final String sourceName;\n-    private final String subscriberId;\n-\n-    private final Runnable ackRunnable;\n-\n-    // This is to be set to true ONLY for testing - NOT otherwise !\n-    // The JMS api DOES NOT expose this ...\n-    // private boolean allowSpecifyJMSMessageIDForTest;\n-\n-    //private final PubSubProtocol.Message rawMessage;\n-\n-    public MessageImpl(SessionImpl session){\n-        this.session = session;\n-\n-        this.sourceName = null;\n-        this.subscriberId = null;\n-        this.ackRunnable = null;\n-        this.serverJmsMessageId = null;\n-        // this.rawMessage = null;\n-    }\n-\n-    MessageImpl(SessionImpl session, MessageImpl message, String sourceName, String subscriberId)\n-        throws JMSException {\n-        this.session = session;\n-        this.sourceName = sourceName;\n-        this.subscriberId = subscriberId;\n-        this.ackRunnable = message.getAckRunnable();\n-        this.serverJmsMessageId = message.getServerJmsMessageId();\n-        // this.rawMessage = null;\n-\n-        // Copy all properties from message to this class.\n-\n-        this.properties.putAll(message.properties);\n-\n-        // Now copy rest of the state over ...\n-        if (message.propertyExists(JMS_MESSAGE_ID)) setJMSMessageIDInternal(message.getJMSMessageID());\n-        if (message.propertyExists(JMS_TIMESTAMP)) setJMSTimestamp(message.getJMSTimestamp());\n-        if (message.propertyExists(JMS_CORRELATION_ID)) setJMSCorrelationID(message.getJMSCorrelationID());\n-        // We do not support this right now.\n-        // if (message.propertyExists(JMS_CORRELATION_ID_AS_BYTES))\n-        //    setJMSCorrelationIDAsBytes(message.getJMSCorrelationIDAsBytes());\n-        if (message.propertyExists(JMS_REPLY_TO)) setJMSReplyTo(message.getJMSReplyTo());\n-        if (message.propertyExists(JMS_DESTINATION)) setJMSDestination(message.getJMSDestination());\n-        if (message.propertyExists(JMS_DELIVERY_MODE)) setJMSDeliveryMode(message.getJMSDeliveryMode());\n-        if (message.propertyExists(JMS_REDELIVERED)) setJMSRedelivered(message.getJMSRedelivered());\n-        if (message.propertyExists(JMS_TYPE)) setJMSType(message.getJMSType());\n-        if (message.propertyExists(JMS_EXPIRATION)) setJMSExpiration(message.getJMSExpiration());\n-        if (message.propertyExists(JMS_PRIORITY)) setJMSPriority(message.getJMSPriority());\n-\n-        this.propertiesReadOnly = message.propertiesReadOnly;\n-    }\n-\n-    // To clone a message from a Message which is NOT MessageImpl\n-    // Changing order of parameter to NOT accidentally clash with the constructor above.\n-    // This is midly confusing, but helps a lot in preventing accidental bugs !\n-    MessageImpl(Message message, SessionImpl session) throws JMSException {\n-        this.session = session;\n-        this.sourceName = null;\n-        this.subscriberId = null;\n-        this.ackRunnable = null;\n-        this.serverJmsMessageId = null;\n-        // this.rawMessage = null;\n-\n-        assert (! (message instanceof MessageImpl ));\n-\n-        // Copy all properties from message to this class.\n-        Enumeration names = message.getPropertyNames();\n-        while (names.hasMoreElements()){\n-            Object name = names.nextElement();\n-            if (!(name instanceof String))\n-              throw new JMSException(\"Unsupported type (expected String) for key : \" + name);\n-\n-            String sname = (String) name;\n-            this.properties.put(sname, message.getObjectProperty(sname));\n-        }\n-\n-        // Now copy rest of the state over ...\n-        // JMS VIOLATION: we will be unable to check for propertyExists after this,\n-        //  at sender and receiver side ... sigh :-(\n-        setJMSMessageIDInternal(message.getJMSMessageID());\n-        setJMSTimestamp(message.getJMSTimestamp());\n-        setJMSCorrelationID(message.getJMSCorrelationID());\n-        // We do not support this right now.\n-        // setJMSCorrelationIDAsBytes(message.getJMSCorrelationIDAsBytes());\n-        setJMSReplyTo(message.getJMSReplyTo());\n-        setJMSDestination(message.getJMSDestination());\n-        setJMSDeliveryMode(message.getJMSDeliveryMode());\n-        setJMSRedelivered(message.getJMSRedelivered());\n-        setJMSType(message.getJMSType());\n-        setJMSExpiration(message.getJMSExpiration());\n-        setJMSPriority(message.getJMSPriority());\n-\n-        // Should be able to modify, right ?\n-        this.propertiesReadOnly = false;\n-\n-        // remove all jms standard keys from properties now : this should ideally result in zero\n-        // removals ... but we never know with client code !\n-        for (String key : standardProperties) properties.remove(key);\n-    }\n-\n-    MessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n-                String sourceName, String subscriberId, Runnable ackRunnable) throws JMSException {\n-        this.session = session;\n-        this.sourceName = sourceName;\n-        this.subscriberId = subscriberId;\n-        this.ackRunnable = ackRunnable;\n-        // this.rawMessage = message;\n-\n-        // setJMSMessageID(getStringProperty(properties, JMS_MESSAGE_ID));\n-        setJMSMessageIDInternal(MessageUtil.generateJMSMessageIdFromSeqId(message.getMsgId()));\n-        this.serverJmsMessageId = getJMSMessageID();\n-\n-        if (properties.containsKey(JMS_TIMESTAMP)) setJMSTimestamp(getLongProperty(properties, JMS_TIMESTAMP));\n-        if (properties.containsKey(JMS_CORRELATION_ID)) setJMSCorrelationID(\n-            getStringProperty(properties, JMS_CORRELATION_ID));\n-        if (null != getStringProperty(properties, JMS_REPLY_TO)) {\n-            setJMSReplyTo(\n-                    session.getDestination(session.findDestinationType(getStringProperty(properties, JMS_REPLY_TO)),\n-                        getStringProperty(properties, JMS_REPLY_TO)\n-                    ));\n-        }\n-        if (null != getStringProperty(properties, JMS_DESTINATION)) {\n-            setJMSDestination(\n-                    session.getDestination(session.findDestinationType(\n-                        getStringProperty(properties, JMS_DESTINATION)),\n-                        getStringProperty(properties, JMS_DESTINATION)\n-                    ));\n-        }\n-\n-        if (properties.containsKey(JMS_DELIVERY_MODE)) setJMSDeliveryMode(\n-            getIntProperty(properties, JMS_DELIVERY_MODE));\n-        if (properties.containsKey(JMS_TYPE)) setJMSType(getStringProperty(properties, JMS_TYPE));\n-\n-        if (properties.containsKey(JMS_EXPIRATION)) setJMSExpiration(\n-            getLongProperty(properties, JMS_EXPIRATION));\n-        if (properties.containsKey(JMS_PRIORITY)) setJMSPriority(\n-            getIntProperty(properties, JMS_PRIORITY));\n-\n-\n-        // remove all jms standard keys from properties now : this should result in zero removals ...\n-        // but adding anyway.\n-        for (String key : standardProperties) properties.remove(key);\n-\n-        // Immutable after reading from stream !\n-        this.propertiesReadOnly = true;\n-        this.properties.putAll(properties);\n-    }\n-\n-    protected MessageUtil.SupportedMessageTypes getJmsMessageType(){\n-        // Validate against coding bug ... this MUST be overridden in all subclasses.\n-        if (getClass() != MessageImpl.class)\n-          throw new IllegalStateException(\"This method must be overridden by subclasses. class : \" + getClass());\n-        return MessageUtil.SupportedMessageTypes.ONLY_MESSAGE;\n-    }\n-\n-    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n-        // This is to be called ONLY from the base class - all children MUST override it and NOT delegate to it.\n-        if (getClass() != MessageImpl.class) {\n-            throw new JMSException(\"Unexpected to call MessageImpl's generateHedwigMessage from subclass \" +\n-                getClass());\n-        }\n-\n-        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n-        populateBuilderWithHeaders(builder);\n-        // no body - will be appropriately set in populateBuilderWithHeaders().\n-        return builder.build();\n-    }\n-\n-    protected boolean isBodyEmpty(){\n-        return true;\n-    }\n-\n-    /*\n-    protected void markEmptyBody(PubSubProtocol.Message.Builder builder) {\n-        MetadataProcessor.addBooleanProperty(builder, EMPTY_BODY_KEY, true);\n-        builder.setBody(ByteString.EMPTY);\n-    }\n-    */\n-\n-    protected boolean hasBodyFromProperties() {\n-        // if key missing (common case), then there is body.\n-        if (!properties.containsKey(EMPTY_BODY_KEY)) return true;\n-        // If present, then check if it is a boolean of value true.\n-        Object value = properties.get(EMPTY_BODY_KEY);\n-\n-        // special case null.\n-        if (null == value) return true;\n-        if (value instanceof Boolean) return ! (Boolean) value;\n-\n-        // unknown type ...\n-        logger.info(\"Unknown type for value of \" + EMPTY_BODY_KEY + \" in message properties : \" + value);\n-        // assume true by default.\n-        return true;\n-    }\n-\n-\n-    protected final void populateBuilderWithHeaders(PubSubProtocol.Message.Builder builder) throws JMSException {\n-\n-        Map<String, Object> propertiesCopy = new HashMap<String, Object>(properties);\n-        if (isBodyEmpty()) {\n-            propertiesCopy.put(EMPTY_BODY_KEY, true);\n-            builder.setBody(ByteString.EMPTY);\n-        }\n-        // Not setting unless required to reduce message size - change this ?\n-        // else propertiesCopy.put(EMPTY_BODY_KEY, false);\n-\n-        Iterator<Map.Entry<String, Object>> iter = propertiesCopy.entrySet().iterator();\n-        while (iter.hasNext()){\n-            Map.Entry<String, Object> entry = iter.next();\n-            if (standardProperties.contains(entry.getKey())) {\n-                if (logger.isInfoEnabled())\n-                  logger.info(\"Ignoring user attempt to set standard property as application property : \" + entry);\n-                iter.remove();\n-            }\n-        }\n-\n-\n-        // set jms message type.\n-        propertiesCopy.put(JMS_MESSAGE_TYPE_KEY, getJmsMessageType().getType());\n-        if (standardPropertiesExistsForWire.contains(JMS_CORRELATION_ID))\n-          propertiesCopy.put(JMS_CORRELATION_ID, getJMSCorrelationID());\n-\n-        // unsupported for now.\n-        // if (standardPropertiesExistsForWire.contains(JMS_CORRELATION_ID_AS_BYTES))\n-        //    propertiesCopy.put(JMS_CORRELATION_ID_AS_BYTES, getJMSCorrelationIDAsBytes());\n-        if (standardPropertiesExistsForWire.contains(JMS_DELIVERY_MODE))\n-          propertiesCopy.put(JMS_DELIVERY_MODE, getJMSDeliveryMode());\n-\n-        if (standardPropertiesExistsForWire.contains(JMS_DESTINATION))\n-          propertiesCopy.put(JMS_DESTINATION, session.toName(getJMSDestination()));\n-        if (standardPropertiesExistsForWire.contains(JMS_EXPIRATION))\n-          propertiesCopy.put(JMS_EXPIRATION, getJMSExpiration());\n-\n-        // This can be set by client - but we ignore it in hedwig.\n-        // if (standardPropertiesExistsForWire.contains(JMS_MESSAGE_ID))\n-        //    propertiesCopy.put(JMS_MESSAGE_ID, getJMSMessageID());\n-\n-        // We do not support priority - but we are gong to allow it to be specified : this is\n-        // for selectors to set conditions on it !\n-        if (standardPropertiesExistsForWire.contains(JMS_PRIORITY))\n-          propertiesCopy.put(JMS_PRIORITY, getJMSPriority());\n-\n-        // this is not to be sent to hedwig.\n-        // if (standardPropertiesExistsForWire.contains(JMS_REDELIVERED))\n-        //    propertiesCopy.put(JMS_REDELIVERED, getJMSRedelivered());\n-\n-        if (standardPropertiesExistsForWire.contains(JMS_REPLY_TO))\n-          propertiesCopy.put(JMS_REPLY_TO, session.toName(getJMSReplyTo()));\n-\n-\n-        propertiesCopy.put(JMS_TIMESTAMP, getJMSTimestamp());\n-        if (standardPropertiesExistsForWire.contains(JMS_TYPE)) propertiesCopy.put(JMS_TYPE, getJMSType());\n-\n-\n-        MetadataProcessor.addHeaders(builder, propertiesCopy);\n-    }\n-\n-    @Override\n-    public String getJMSMessageID() {\n-        return jmsMessageId;\n-    }\n-\n-    @Override\n-    public void setJMSMessageID(String jmsMessageId) throws JMSException {\n-        // JMS VIOLATION ... we are NOT allowing client to override jms message-id.\n-        // if (!allowSpecifyJMSMessageIDForTest)\n-        //    throw new JMSException(\"We do not allow setting jms message id. This will be ignored by hedwig anyway.\");\n-        if (logger.isDebugEnabled()) logger.debug(\"Setting this is irrelevant - we override it anyway - \" +\n-            \" hedwig does not allow specifying it explictly.\");\n-        setJMSMessageIDInternal(jmsMessageId);\n-    }\n-\n-    public void setJMSMessageIDInternal(String jmsMessageId) throws JMSException {\n-        this.jmsMessageId = jmsMessageId;\n-        if (null != jmsMessageId){\n-            // We do not allow sending the property over wire.\n-            this.standardPropertiesExists.add(JMS_MESSAGE_ID);\n-            // this.standardPropertiesExistsForWire.add(JMS_MESSAGE_ID);\n-        }\n-        else {\n-            this.standardPropertiesExists.remove(JMS_MESSAGE_ID);\n-            // this.standardPropertiesExistsForWire.remove(JMS_MESSAGE_ID);\n-        }\n-    }\n-\n-    // The immutable message Id set by the server.\n-    public String getServerJmsMessageId() {\n-        return serverJmsMessageId;\n-    }\n-\n-    @Override\n-    public long getJMSTimestamp() {\n-        return jmsTimestamp;\n-    }\n-\n-    @Override\n-    public void setJMSTimestamp(long jmsTimestamp) {\n-        this.jmsTimestamp = jmsTimestamp;\n-        this.standardPropertiesExists.add(JMS_TIMESTAMP);\n-        // this.standardPropertiesExistsForWire.add(JMS_TIMESTAMP);\n-    }\n-\n-    @Override\n-    public byte[] getJMSCorrelationIDAsBytes() {\n-        throw new UnsupportedOperationException(\"unsupported\");\n-    }\n-\n-    @Override\n-    public void setJMSCorrelationIDAsBytes(byte[] bytes) {\n-        throw new UnsupportedOperationException(\"unsupported\");\n-    }\n-\n-    @Override\n-    public void setJMSCorrelationID(String jmsCorrelationID) {\n-        this.jmsCorrelationID = jmsCorrelationID;\n-        if (null != jmsCorrelationID){\n-            this.standardPropertiesExists.add(JMS_CORRELATION_ID);\n-            this.standardPropertiesExistsForWire.add(JMS_CORRELATION_ID);\n-        }\n-        else {\n-            this.standardPropertiesExists.remove(JMS_CORRELATION_ID);\n-            this.standardPropertiesExistsForWire.remove(JMS_CORRELATION_ID);\n-        }\n-    }\n-\n-    @Override\n-    public String getJMSCorrelationID() {\n-        return jmsCorrelationID;\n-    }\n-\n-    @Override\n-    public Destination getJMSReplyTo() {\n-        return jmsReplyTo;\n-    }\n-\n-    @Override\n-    public void setJMSReplyTo(Destination jmsReplyTo) {\n-        this.jmsReplyTo = jmsReplyTo;\n-        if (null != jmsReplyTo){\n-            this.standardPropertiesExists.add(JMS_REPLY_TO);\n-            this.standardPropertiesExistsForWire.add(JMS_REPLY_TO);\n-        }\n-        else {\n-            this.standardPropertiesExists.remove(JMS_REPLY_TO);\n-            this.standardPropertiesExistsForWire.remove(JMS_REPLY_TO);\n-        }\n-    }\n-\n-    @Override\n-    public Destination getJMSDestination() {\n-        return jmsDestination;\n-    }\n-\n-    @Override\n-    public void setJMSDestination(Destination jmsDestination) {\n-        this.jmsDestination = jmsDestination;\n-        if (null != jmsDestination){\n-            this.standardPropertiesExists.add(JMS_DESTINATION);\n-            this.standardPropertiesExistsForWire.add(JMS_DESTINATION);\n-        }\n-        else {\n-            this.standardPropertiesExists.remove(JMS_DESTINATION);\n-            this.standardPropertiesExistsForWire.remove(JMS_DESTINATION);\n-        }\n-    }\n-\n-    @Override\n-    public int getJMSDeliveryMode() {\n-        return jmsDeliveryMode;\n-    }\n-\n-    @Override\n-    public void setJMSDeliveryMode(int jmsDeliveryMode) {\n-        this.jmsDeliveryMode = jmsDeliveryMode;\n-        this.standardPropertiesExists.add(JMS_DELIVERY_MODE);\n-        this.standardPropertiesExistsForWire.add(JMS_DELIVERY_MODE);\n-    }\n-\n-    @Override\n-    public boolean getJMSRedelivered() {\n-        return jmsRedelivered;\n-    }\n-\n-    @Override\n-    public void setJMSRedelivered(boolean jmsRedelivered) {\n-        this.jmsRedelivered = jmsRedelivered;\n-        this.standardPropertiesExists.add(JMS_REDELIVERED);\n-        // this.standardPropertiesExistsForWire.add(JMS_REDELIVERED);\n-    }\n-\n-    @Override\n-    public String getJMSType() {\n-        return jmsType;\n-    }\n-\n-    @Override\n-    public void setJMSType(String jmsType) {\n-        this.jmsType = jmsType;\n-        if (null != jmsType){\n-            this.standardPropertiesExists.add(JMS_TYPE);\n-            this.standardPropertiesExistsForWire.add(JMS_TYPE);\n-        }\n-        else {\n-            this.standardPropertiesExists.remove(JMS_TYPE);\n-            this.standardPropertiesExistsForWire.remove(JMS_TYPE);\n-        }\n-    }\n-\n-    @Override\n-    public long getJMSExpiration() {\n-        return jmsExpiration;\n-    }\n-\n-    @Override\n-    public void setJMSExpiration(long jmsExpiration) {\n-        // We simulate it now !\n-        // if (logger.isInfoEnabled()) logger.info(\"JMSExpiration is not supported right now by Hedwig ...\");\n-        this.jmsExpiration = jmsExpiration;\n-\n-        if (0 != jmsExpiration){\n-            this.standardPropertiesExists.add(JMS_EXPIRATION);\n-            this.standardPropertiesExistsForWire.add(JMS_EXPIRATION);\n-        }\n-        else {\n-            this.standardPropertiesExists.remove(JMS_EXPIRATION);\n-            this.standardPropertiesExistsForWire.remove(JMS_EXPIRATION);\n-        }\n-    }\n-\n-    @Override\n-    public int getJMSPriority() {\n-        return jmsPriority;\n-    }\n-\n-    @Override\n-    public void setJMSPriority(int jmsPriority) {\n-        this.jmsPriority = jmsPriority;\n-        this.standardPropertiesExists.add(JMS_PRIORITY);\n-        // Sent over wire ?\n-        this.standardPropertiesExistsForWire.add(JMS_PRIORITY);\n-    }\n-\n-    @Override\n-    public void clearProperties() {\n-        this.propertiesReadOnly = false;\n-        properties.clear();\n-    }\n-\n-    /**\n-     * JMS VIOLATION ? The spec & javadoc is unclear as to whether this method must include jms\n-     * standard properties or not.\n-     * But going by javadoc of\n-     * @see #getPropertyNames() , we have this specified :\n-     * \"Note that JMS standard header fields are not considered properties and are not returned\n-     * in this enumeration.\"\n-     * Which indicates this method must not include standard properties.\n-     */\n-    @Override\n-    public boolean propertyExists(String key) {\n-        if (!standardProperties.contains(key)) return properties.containsKey(key);\n-\n-        // Evaluate depending on type of property.\n-        return standardPropertiesExists.contains(key);\n-    }\n-\n-    @Override\n-    public boolean getBooleanProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getBooleanProperty(properties, key);\n-    }\n-\n-    private boolean getBooleanProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asBoolean(properties.get(key));\n-    }\n-\n-    @Override\n-    public byte getByteProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getByteProperty(properties, key);\n-    }\n-\n-    private byte getByteProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asByte(properties.get(key));\n-    }\n-\n-    @Override\n-    public short getShortProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getShortProperty(properties, key);\n-    }\n-\n-    private short getShortProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asShort(properties.get(key));\n-    }\n-\n-    @Override\n-    public int getIntProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getIntProperty(properties, key);\n-    }\n-\n-    private int getIntProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asInteger(properties.get(key));\n-    }\n-\n-    @Override\n-    public long getLongProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getLongProperty(properties, key);\n-    }\n-\n-    private long getLongProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asLong(properties.get(key));\n-    }\n-\n-    @Override\n-    public float getFloatProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getFloatProperty(properties, key);\n-    }\n-\n-    private float getFloatProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asFloat(properties.get(key));\n-    }\n-\n-    @Override\n-    public double getDoubleProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getDoubleProperty(properties, key);\n-    }\n-\n-    private double getDoubleProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asDouble(properties.get(key));\n-    }\n-\n-    public Object getSelectorProcessingPropertyValue(String key) throws SelectorEvaluationException {\n-        if (properties.containsKey(key)) return properties.get(key);\n-        if (! standardProperties.contains(key)) return null;\n-\n-        if (JMS_MESSAGE_ID.equals(key)) return getJMSMessageID();\n-        if (JMS_TIMESTAMP.equals(key)) return getJMSTimestamp();\n-        if (JMS_CORRELATION_ID.equals(key)) return getJMSCorrelationID();\n-        // We do not support this right now.\n-        // if (JMS_CORRELATION_ID_AS_BYTES.equals(key)) return getJMSCorrelationIDAsBytes();\n-        if (JMS_REPLY_TO.equals(key)) return getJMSReplyTo();\n-        if (JMS_DESTINATION.equals(key)) return getJMSDestination();\n-        if (JMS_DELIVERY_MODE.equals(key)) {\n-            // 3.8.1.3 Special Notes \"When used in a message selector JMSDeliveryMode is treated as having the\n-            // values ‘PERSISTENT’ and ‘NON_PERSISTENT’.\"\n-            final int deliveryMode = getJMSDeliveryMode();\n-            if (DeliveryMode.PERSISTENT == deliveryMode) return \"PERSISTENT\";\n-            if (DeliveryMode.NON_PERSISTENT == deliveryMode) return \"NON_PERSISTENT\";\n-            // unknown !\n-            if (logger.isInfoEnabled()) logger.info(\"Unknown delivery mode specified ... \" + deliveryMode);\n-            return null;\n-        }\n-        if (JMS_REDELIVERED.equals(key)) return getJMSRedelivered();\n-        if (JMS_TYPE.equals(key)) return getJMSType();\n-        if (JMS_EXPIRATION.equals(key)) return getJMSExpiration();\n-        if (JMS_PRIORITY.equals(key)) return getJMSPriority();\n-\n-        throw new SelectorEvaluationException(\"Unable to retrieve value for key : '\" + key + \"'\");\n-    }\n-\n-    @Override\n-    public String getStringProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        return getStringProperty(properties, key);\n-    }\n-\n-    private String getStringProperty(Map<String, Object> properties, String key) throws JMSException {\n-        return MessageUtil.asString(properties.get(key));\n-    }\n-\n-    @Override\n-    public Object getObjectProperty(String key) throws JMSException {\n-        checkIfStandardProperty(key);\n-        // if (!propertyExists(key)) return null;\n-\n-        return properties.get(key);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getPropertyNames() throws JMSException {\n-        return Collections.enumeration(properties.keySet());\n-    }\n-\n-    @Override\n-    public void setBooleanProperty(String key, boolean value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setByteProperty(String key, byte value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setShortProperty(String key, short value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setIntProperty(String key, int value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setLongProperty(String key, long value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setFloatProperty(String key, float value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setDoubleProperty(String key, double value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setStringProperty(String key, String value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-        properties.put(key, value);\n-    }\n-\n-    @Override\n-    public void setObjectProperty(String key, Object value) throws JMSException {\n-        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n-        if (propertiesReadOnly)\n-          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n-              key + \" = \" + value);\n-        checkIfStandardProperty(key);\n-\n-        if (null == value ||\n-                value instanceof Boolean ||\n-                value instanceof Byte ||\n-                value instanceof Short ||\n-                value instanceof Integer ||\n-                value instanceof Long ||\n-                value instanceof Float ||\n-                value instanceof Double ||\n-                value instanceof byte[] ||\n-                value instanceof String) {\n-            properties.put(key, value);\n-            return ;        }\n-\n-        throw new MessageFormatException(\"Unsupported type for value \" + value.getClass());\n-    }\n-\n-    // JMS VIOLATION ?\n-    // I am not sure if getting and setting standard properties is allowed via the generic\n-    // get/set methods : the spec seems unclear on it.\n-    // Some javadocs seem to indicate it is NOT allowed. Hence this check ...\n-    // If it is allowed in JMS - to support it, we will need to have a if/else block within each set/get\n-    // which delegates to corresponding jms header set/get ...\n-    private void checkIfStandardProperty(String key) throws JMSException {\n-        if (standardProperties.contains(key))\n-          throw new JMSException(\"Cannot get/set standard JMS properties using *Property api\");\n-    }\n-\n-    @Override\n-    public void acknowledge() throws JMSException {\n-        session.acknowledge(this);\n-    }\n-\n-    @Override\n-    public void clearBody() throws JMSException {\n-        // Clear the body of the message.\n-    }\n-\n-    public String getSourceName() {\n-        return sourceName;\n-    }\n-\n-    public String getSubscriberId() {\n-        return subscriberId;\n-    }\n-\n-    MessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId) throws JMSException {\n-        if (MessageImpl.class != getClass()) {\n-            throw new JMSException(\"Unexpected to call MessageImpl's createClone from subclass \" + getClass());\n-        }\n-        return new MessageImpl(session, this, sourceTopicName, subscriberId);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"MessageImpl\");\n-        sb.append(\"{session=\").append(session);\n-        sb.append(\", jmsMessageId='\").append(jmsMessageId).append('\\'');\n-        sb.append(\", jmsTimestamp=\").append(jmsTimestamp);\n-        sb.append(\", jmsCorrelationID='\").append(jmsCorrelationID).append('\\'');\n-        sb.append(\", jmsReplyTo=\").append(jmsReplyTo);\n-        sb.append(\", jmsDestination=\").append(jmsDestination);\n-        sb.append(\", jmsDeliveryMode=\").append(jmsDeliveryMode);\n-        sb.append(\", jmsRedelivered=\").append(jmsRedelivered);\n-        sb.append(\", jmsType='\").append(jmsType).append('\\'');\n-        sb.append(\", jmsExpiration=\").append(jmsExpiration);\n-        sb.append(\", jmsPriority=\").append(jmsPriority);\n-        sb.append(\", properties=\").append(properties);\n-        sb.append(\", standardPropertiesExists=\").append(standardPropertiesExists);\n-        sb.append(\", standardPropertiesExistsForWire=\").append(standardPropertiesExistsForWire);\n-        sb.append(\", sourceName='\").append(sourceName).append('\\'');\n-        sb.append(\", subscriberId='\").append(subscriberId).append('\\'');\n-        sb.append('}');\n-        return sb.toString();\n-    }\n-\n-    void reset() throws JMSException {\n-        // noop ... children will override to do needful.\n-    }\n-\n-    public Runnable getAckRunnable() {\n-        return ackRunnable;\n-    }\n-}"},{"sha":"15b75ee737bbf6d50a6d7fa033186af70d718952","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java","status":"removed","additions":0,"deletions":444,"changes":444,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,444 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.message.header.MetadataProcessor;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-\n-import javax.jms.BytesMessage;\n-import javax.jms.JMSException;\n-import javax.jms.MapMessage;\n-import javax.jms.Message;\n-import javax.jms.MessageFormatException;\n-import javax.jms.ObjectMessage;\n-import javax.jms.StreamMessage;\n-import javax.jms.TextMessage;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n-\n-/**\n- * Bunch of simple util methods to reduce code in the implementation.\n- */\n-public class MessageUtil {\n-\n-    // The various message types supported.\n-    public enum SupportedMessageTypes {\n-      ONLY_MESSAGE((byte) 0),\n-      TEXT((byte) 1),\n-      BYTES((byte) 2),\n-      MAP((byte) 3),\n-      STREAM((byte) 4),\n-      OBJECT((byte) 5);\n-\n-      private final byte type;\n-      private SupportedMessageTypes(byte type){\n-        this.type = type;\n-      }\n-\n-      public byte getType() {\n-        return type;\n-      }\n-    }\n-\n-    private static final Map<Byte, SupportedMessageTypes> valueToSupportedMessageType;\n-    static {\n-        SupportedMessageTypes[] arr = SupportedMessageTypes.values();\n-        Map<Byte, SupportedMessageTypes> map = new HashMap<Byte, SupportedMessageTypes>(arr.length);\n-        for (SupportedMessageTypes type : arr){\n-            map.put(type.getType(), type);\n-        }\n-        valueToSupportedMessageType = Collections.unmodifiableMap(map);\n-    }\n-\n-    public static boolean asBoolean(Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return false;\n-        if (null == value) return Boolean.valueOf((String) value);\n-\n-        if (value instanceof Boolean) return (Boolean) value;\n-        if (value instanceof String) return Boolean.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static byte asByte(Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return 0;\n-        if (null == value) return Byte.valueOf((String) value);\n-\n-        if (value instanceof Byte) return (Byte) value;\n-        if (value instanceof String) return Byte.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static short asShort(Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return 0;\n-        if (null == value) return Short.valueOf((String) value);\n-\n-        if (value instanceof Byte) return (Byte) value;\n-        if (value instanceof Short) return (Short) value;\n-        if (value instanceof String) return Short.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static int asInteger(Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return 0;\n-        if (null == value) return Integer.valueOf((String) value);\n-\n-        if (value instanceof Byte) return (Byte) value;\n-        if (value instanceof Short) return (Short) value;\n-        if (value instanceof Integer) return (Integer) value;\n-        if (value instanceof String) return Integer.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static long asLong(Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return 0;\n-        if (null == value) return Long.valueOf((String) value);\n-\n-        if (value instanceof Byte) return (Byte) value;\n-        if (value instanceof Short) return (Short) value;\n-        if (value instanceof Integer) return (Integer) value;\n-        if (value instanceof Long) return (Long) value;\n-        if (value instanceof String) return Long.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static float asFloat(Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return 0.0f;\n-        if (null == value) return Float.valueOf((String) value);\n-\n-        if (value instanceof Float) return (Float) value;\n-        if (value instanceof String) return Float.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static double asDouble (Object value) throws MessageFormatException {\n-        // The JMS spec explicitly wants us to raise NPE !\n-        // if (null == value) return 0.0;\n-        if (null == value) return Double.valueOf((String) value);\n-\n-        if (value instanceof Float) return (Float) value;\n-        if (value instanceof Double ) return (Double) value;\n-        if (value instanceof String) return Double.valueOf((String) value);\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static Double asDoubleSelectorProcessing(Object value) throws MessageFormatException {\n-        if (null == value) return null;\n-\n-        if (value instanceof Float) return (double) (Float) value;\n-        if (value instanceof Double ) return (Double) value;\n-\n-        if (value instanceof Long) return (double) (Long) value;\n-        if (value instanceof Integer) return (double) (Integer) value;\n-        if (value instanceof Short) return (double) (Short) value;\n-        if (value instanceof Byte) return (double) (Byte) value;\n-\n-        return null;\n-    }\n-\n-    public static Integer asIntegerSelectorProcessing(Object value) throws MessageFormatException {\n-        if (null == value) return null;\n-\n-        if (value instanceof Float) return (int) (float) (Float) value;\n-        if (value instanceof Double ) return (int) (double) (Double) value;\n-\n-        if (value instanceof Long) return (int) (long) (Long) value;\n-        if (value instanceof Integer) return (Integer) value;\n-        if (value instanceof Short) return (int) (Short) value;\n-        if (value instanceof Byte) return (int) (Byte) value;\n-\n-        return null;\n-    }\n-\n-    public static String asString(Object value) {\n-        if (null == value) return null;\n-\n-        if (value instanceof String) return (String) value;\n-        // converts from boolean, byte, short, char, int, long, float and double to String.\n-        return \"\" + value;\n-    }\n-\n-    public static char asChar(Object value) throws MessageFormatException {\n-        // treat it as integer with null\n-        if (null == value) return (char) 0;\n-\n-        // only from/to char\n-        if (value instanceof Character) return (Character) value;\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static byte[] asBytes(Object value) throws MessageFormatException {\n-        if (null == value || value instanceof byte[]) return (byte[]) value;\n-        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n-    }\n-\n-    public static boolean isValidKey(String key) {\n-        return null != key && 0 != key.length();\n-    }\n-\n-    public static byte[] objectToBytes(Object obj) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n-        ObjectOutputStream oos = new ObjectOutputStream(baos);\n-        try {\n-            oos.writeObject(obj);\n-            oos.flush();\n-        } finally {\n-            try { oos.close(); } catch (IOException ioEx) { /* ignore */ }\n-        }\n-\n-        return baos.toByteArray();\n-    }\n-\n-    public static Object bytesToObject(byte[] data) throws IOException {\n-        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));\n-        try {\n-            return ois.readObject();\n-        } catch (ClassNotFoundException  cnfEx){\n-            // unexpected !\n-            throw new IllegalStateException(\"Unexpected\", cnfEx);\n-        } finally {\n-            try { ois.close(); } catch(IOException ioEx) { /* ignore */ }\n-        }\n-    }\n-\n-\n-\n-    public static MessageImpl processHedwigMessage(SessionImpl session, PubSubProtocol.Message message,\n-                                                   String sourceTopicName, String subscriberId,\n-                                                   Runnable ackRunnable) throws JMSException {\n-        Map<String, Object> map = MetadataProcessor.parseHeaders(message);\n-\n-        Object jmsBodyTypeValue = map.get(MessageImpl.JMS_MESSAGE_TYPE_KEY);\n-        // Should we treat these as bytes message by default ?\n-        // if (! (jmsBodyTypeValue instanceof Byte) )\n-        //    throw new JMSException(\"Unsupported message : \" + message + \", unable to determine jms message type \" +\n-        //      jmsBodyTypeValue);\n-        if (! (jmsBodyTypeValue instanceof Byte) ) jmsBodyTypeValue = (Byte) SupportedMessageTypes.BYTES.getType();\n-\n-        SupportedMessageTypes type = valueToSupportedMessageType.get((Byte) jmsBodyTypeValue);\n-        switch (type){\n-            case STREAM:\n-                return new StreamMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n-            case MAP:\n-                return new MapMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n-            case TEXT:\n-                return new TextMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n-            case OBJECT:\n-                return new ObjectMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n-            case BYTES:\n-                return new BytesMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n-            case ONLY_MESSAGE:\n-                return new MessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n-            default:\n-                throw new JMSException(\"Unsupported message type : \" + type + \" for message \" + message);\n-        }\n-    }\n-\n-    public static MessageImpl createMessageCopy(SessionImpl session, Message message) throws JMSException {\n-        if (message instanceof MessageImpl) {\n-            return createMessageImplCopy(session, (MessageImpl) message);\n-        }\n-\n-        if (message instanceof BytesMessage) {\n-            return new BytesMessageImpl((BytesMessage) message, session);\n-        }\n-        if (message instanceof MapMessage) {\n-            return new MapMessageImpl((MapMessage) message, session);\n-        }\n-        if (message instanceof ObjectMessage) {\n-            return new ObjectMessageImpl((ObjectMessage) message, session);\n-        }\n-        if (message instanceof StreamMessage) {\n-            return new StreamMessageImpl((StreamMessage) message, session);\n-        }\n-        if (message instanceof TextMessage) {\n-            return new TextMessageImpl((TextMessage) message, session);\n-        }\n-\n-        return new MessageImpl(message, session);\n-    }\n-\n-    private static MessageImpl createMessageImplCopy(SessionImpl session, MessageImpl message)\n-        throws JMSException {\n-\n-        if (message instanceof BytesMessageImpl) {\n-            return new BytesMessageImpl(session, (BytesMessageImpl) message, message.getSourceName(),\n-                message.getSubscriberId());\n-        }\n-        if (message instanceof MapMessageImpl) {\n-            return new MapMessageImpl(session, (MapMessageImpl) message, message.getSourceName(),\n-                message.getSubscriberId());\n-        }\n-        if (message instanceof ObjectMessageImpl) {\n-            return new ObjectMessageImpl(session, (ObjectMessageImpl) message, message.getSourceName(),\n-                message.getSubscriberId());\n-        }\n-        if (message instanceof StreamMessageImpl) {\n-            return new StreamMessageImpl(session, (StreamMessageImpl) message, message.getSourceName(),\n-                message.getSubscriberId());\n-        }\n-        if (message instanceof TextMessageImpl) {\n-            return new TextMessageImpl(session, (TextMessageImpl) message, message.getSourceName(),\n-                message.getSubscriberId());\n-        }\n-\n-        return new MessageImpl(session, message, message.getSourceName(), message.getSubscriberId());\n-    }\n-\n-    private static final String JMS_MESSAGE_ID_PREFIX = \"ID:\";\n-    private static final String LOCAL_PREFIX = \"LOCAL(\";\n-    private static final String REMOTE_PREFIX = \"REMOTE(\";\n-    private static final char SEQ_ID_SUFFIX = ')';\n-    private static final char REMOTE_RECORD_SEPARATOR = ',';\n-    private static final char REMOTE_RECORD_SEQ_ID_PREFIX = '[';\n-    private static final char REMOTE_RECORD_SEQ_ID_SUFFIX = ']';\n-    private static final Pattern remoteMessageIdSplitPattern = Pattern.compile(\"\" + REMOTE_RECORD_SEPARATOR);\n-\n-    /**\n-     * Based on\n-     * {@link org.apache.hedwig.admin.console.ReadTopic#formatMessage(PubSubProtocol.Message)}\n-     *\n-     * This is tightly coupled with\n-     * @see #generateSeqIdFromJMSMessageId(String)\n-     *\n-     * @param seqId The sequence id to convert to string.\n-     * @return The string representation of the seq-id.\n-     */\n-    public static String generateJMSMessageIdFromSeqId(final PubSubProtocol.MessageSeqId seqId) {\n-        StringBuilder sb = new StringBuilder();\n-        // mandatory prefix for system generated id's.\n-        sb.append(JMS_MESSAGE_ID_PREFIX);\n-\n-        if (seqId.hasLocalComponent()) {\n-            sb.append(LOCAL_PREFIX).append(seqId.getLocalComponent()).append(SEQ_ID_SUFFIX);\n-        } else {\n-            List<PubSubProtocol.RegionSpecificSeqId> remoteIds = seqId.getRemoteComponentsList();\n-            boolean first = true;\n-\n-            sb.append(REMOTE_PREFIX);\n-            for (PubSubProtocol.RegionSpecificSeqId rssid : remoteIds) {\n-                if (!first) sb.append(REMOTE_RECORD_SEPARATOR);\n-                first = false;\n-                sb.append(rssid.getRegion().toStringUtf8());\n-                sb.append(REMOTE_RECORD_SEQ_ID_PREFIX);\n-                sb.append(rssid.getSeqId());\n-                sb.append(REMOTE_RECORD_SEQ_ID_SUFFIX);\n-            }\n-            sb.append(SEQ_ID_SUFFIX);\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    /**\n-     * Based on\n-     * {@link org.apache.hedwig.admin.console.ReadTopic#formatMessage(PubSubProtocol.Message)}\n-     *\n-     * This is tightly coupled with\n-     * @see #generateJMSMessageIdFromSeqId(org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId)\n-     * @param messageId The message id to convert to string.\n-     * @return The seq-id\n-     * @throws javax.jms.JMSException In case of exceptions doing the conversion.\n-     */\n-    public static PubSubProtocol.MessageSeqId generateSeqIdFromJMSMessageId(final String messageId)\n-        throws JMSException {\n-        if (null == messageId || !messageId.startsWith(JMS_MESSAGE_ID_PREFIX)) {\n-            throw new JMSException(\"Invalid messageId specified '\" + messageId + \"'\");\n-        }\n-\n-        PubSubProtocol.MessageSeqId.Builder builder = PubSubProtocol.MessageSeqId.newBuilder();\n-        // local ?\n-        if (messageId.regionMatches(JMS_MESSAGE_ID_PREFIX.length(), LOCAL_PREFIX, 0, LOCAL_PREFIX.length())){\n-            try {\n-                long seqId = Long.parseLong(messageId.substring(JMS_MESSAGE_ID_PREFIX.length() +\n-                    LOCAL_PREFIX.length(), messageId.length() - 1));\n-                builder.setLocalComponent(seqId);\n-            } catch (NumberFormatException nfEx){\n-                JMSException jEx = new JMSException(\"Unable to parse local seq id from '\" +\n-                    messageId + \"' .. \" + nfEx);\n-                jEx.setLinkedException(nfEx);\n-                throw jEx;\n-            }\n-        }\n-        else {\n-            assert messageId.regionMatches(JMS_MESSAGE_ID_PREFIX.length(), REMOTE_PREFIX, 0,\n-                REMOTE_PREFIX.length());\n-\n-            final String[] remoteParts;\n-            {\n-                final String remoteMessageId = messageId.substring(JMS_MESSAGE_ID_PREFIX.length() +\n-                    REMOTE_PREFIX.length(), messageId.length() - 1);\n-                // Should ew stop using pattern and move to using indexOf's ?\n-                remoteParts = remoteMessageIdSplitPattern.split(remoteMessageId);\n-            }\n-\n-            for (String remote : remoteParts){\n-                if (REMOTE_RECORD_SEQ_ID_SUFFIX != remote.charAt(remote.length() - 1))\n-                  throw new JMSException(\"Invalid remote region snippet (no seq suffix) '\" +\n-                      remote + \"' within '\" + messageId);\n-                final int regionIndx = remote.indexOf(REMOTE_RECORD_SEQ_ID_PREFIX);\n-                if (-1 == regionIndx)\n-                  throw new JMSException(\"Invalid remote region snippet (no region) '\" + remote +\n-                      \"' within '\" + messageId);\n-                final String region = remote.substring(0, regionIndx);\n-                final long seqId;\n-\n-\n-                try {\n-                    seqId = Long.parseLong(remote.substring(regionIndx + 1, remote.length() - 1));\n-                } catch (NumberFormatException nfEx){\n-                    JMSException jEx = new JMSException(\"Unable to parse remote seq id from '\" +\n-                        remote + \"' within '\" + messageId + \"' .. \" + nfEx);\n-                    jEx.setLinkedException(nfEx);\n-                    throw jEx;\n-                }\n-\n-                PubSubProtocol.RegionSpecificSeqId.Builder rbuilder =\n-                    PubSubProtocol.RegionSpecificSeqId.newBuilder();\n-                rbuilder.setRegion(ByteString.copyFromUtf8(region));\n-                rbuilder.setSeqId(seqId);\n-                builder.addRemoteComponents(rbuilder);\n-            }\n-        }\n-\n-        return builder.build();\n-    }\n-\n-    public static MessageImpl createCloneForDispatch(SessionImpl session, MessageImpl msg,\n-                                                     String sourceTopicName, String subscriberId) throws JMSException {\n-        MessageImpl retval = msg.createClone(session, sourceTopicName, subscriberId);\n-        retval.reset();\n-        return retval;\n-    }\n-}"},{"sha":"ba26c4c1b55a1b6e6a441ef4bc33a6841f520d1a","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java","status":"removed","additions":0,"deletions":168,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,168 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageNotWriteableException;\n-import javax.jms.ObjectMessage;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-import java.util.Map;\n-\n-/**\n- * read/write serializable java object ...\n- *\n- */\n-public class ObjectMessageImpl extends MessageImpl implements ObjectMessage {\n-    private Serializable payload;\n-    private boolean readMode;\n-\n-    public ObjectMessageImpl(SessionImpl session, Serializable payload) {\n-        super(session);\n-        this.payload = payload;\n-        this.readMode = false;\n-    }\n-\n-    public ObjectMessageImpl(SessionImpl session, ObjectMessageImpl message, String sourceTopicName,\n-                             String subscriberId) throws JMSException {\n-        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n-\n-        this.payload = copySerializable(message.getObject());\n-        this.readMode = message.readMode;\n-    }\n-\n-    private Serializable copySerializable(Serializable object) throws JMSException {\n-        try {\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n-            ObjectOutputStream oos = new ObjectOutputStream(baos);\n-            oos.writeObject(object);\n-            oos.flush();\n-            oos.close();\n-            baos.flush();\n-            baos.close();\n-\n-            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n-            return (Serializable) ois.readObject();\n-        } catch (IOException e){\n-            JMSException jmsEx = new javax.jms.IllegalStateException(\"Unexpected exception\");\n-            jmsEx.setLinkedException(e);\n-            throw jmsEx;\n-        } catch (ClassNotFoundException e) {\n-            JMSException jmsEx = new javax.jms.IllegalStateException(\"Unexpected exception\");\n-            jmsEx.setLinkedException(e);\n-            throw jmsEx;\n-        }\n-    }\n-\n-    // To clone a message from a ObjectMessage which is NOT ObjectMessageImpl\n-    // Changing order of parameter to NOT accidentally clash with the constructor above.\n-    // This is midly confusing, but helps a lot in preventing accidental bugs !\n-    public ObjectMessageImpl(ObjectMessage message, SessionImpl session) throws JMSException {\n-        super((Message) message, session);\n-\n-        if (message instanceof ObjectMessageImpl) {\n-            throw new JMSException(\"Coding bug - should use this constructor ONLY for non ObjectMessageImpl messages\");\n-        }\n-\n-\n-        this.payload = message.getObject();\n-        this.readMode = false;\n-    }\n-\n-    public ObjectMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n-                             String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n-        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n-\n-        try {\n-            this.payload = hasBodyFromProperties() ?\n-                (Serializable) MessageUtil.bytesToObject(message.getBody().toByteArray()) : null;\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    protected MessageUtil.SupportedMessageTypes getJmsMessageType() {\n-        return MessageUtil.SupportedMessageTypes.OBJECT;\n-    }\n-\n-    @Override\n-    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n-        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n-        super.populateBuilderWithHeaders(builder);\n-\n-        // Now set body and type.\n-        try {\n-            if (! isBodyEmpty()) builder.setBody(ByteString.copyFrom(MessageUtil.objectToBytes(this.payload)));\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-\n-        return builder.build();\n-    }\n-\n-    protected boolean isBodyEmpty(){\n-        return null == this.payload;\n-    }\n-\n-    @Override\n-    public void setObject(Serializable payload) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        this.payload = payload;\n-    }\n-\n-    @Override\n-    public Serializable getObject() throws JMSException {\n-        return payload;\n-    }\n-\n-    @Override\n-    public void clearBody() throws JMSException {\n-        super.clearBody();\n-        // allow read and write.\n-        this.payload = null;\n-        this.readMode = false;\n-    }\n-\n-    @Override\n-    public void reset() throws JMSException {\n-        if (this.readMode) return ;\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    ObjectMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId)\n-        throws JMSException {\n-\n-        return new ObjectMessageImpl(session, this, sourceTopicName, subscriberId);\n-    }\n-}"},{"sha":"2aa74a2e690aabe2300d5a9e34d85b06d1bb0e71","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java","status":"removed","additions":0,"deletions":752,"changes":752,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,752 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.Mutable;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-\n-import javax.jms.IllegalStateException;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageEOFException;\n-import javax.jms.MessageNotReadableException;\n-import javax.jms.MessageNotWriteableException;\n-import javax.jms.StreamMessage;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.util.ArrayDeque;\n-import java.util.Arrays;\n-import java.util.Deque;\n-import java.util.Map;\n-\n-/**\n- * Though similar to BytesMessageImpl, the difference is that BytesMessage expects the user to know\n- * the schema while\n- * StreamMessage user expects type conversion, etc.\n- *\n- * In our case, the stream is not a true open stream to the server; it is buffered in memory.\n- */\n-public class StreamMessageImpl extends MessageImpl implements StreamMessage {\n-    private ReadOnlyMessage readOnlyMessage;\n-    private WriteOnlyMessage writeOnlyMessage;\n-    private boolean readMode;\n-\n-    public StreamMessageImpl(SessionImpl session) throws JMSException {\n-        super(session);\n-        clearBody();\n-    }\n-\n-    // To clone a message\n-    public StreamMessageImpl(SessionImpl session, StreamMessageImpl message, String sourceTopicName,\n-                             String subscriberId) throws JMSException {\n-        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n-        try {\n-            if (message.readMode){\n-                this.readOnlyMessage = new ReadOnlyMessage(message.getPayloadData());\n-                this.writeOnlyMessage = null;\n-            }\n-            else {\n-                this.readOnlyMessage = null;\n-                this.writeOnlyMessage = new WriteOnlyMessage(message.getPayloadData());\n-            }\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-\n-        this.readMode = message.readMode;\n-    }\n-\n-    // To clone a message from a StreamMessage which is NOT StreamMessageImpl\n-    // Changing order of parameter to NOT accidentally clash with the constructor above.\n-    // This is midly confusing, but helps a lot in preventing accidental bugs !\n-    public StreamMessageImpl(StreamMessage message, SessionImpl session) throws JMSException {\n-        super((Message) message, session);\n-\n-        if (message instanceof StreamMessageImpl) {\n-            throw new JMSException(\"Coding bug - should use this constructor ONLY for non StreamMessageImpl messages\");\n-        }\n-\n-        final byte[] data;\n-        try {\n-            WriteOnlyMessage wom = new WriteOnlyMessage();\n-            try {\n-                Object obj;\n-                while (null != (obj = message.readObject())){\n-                    wom.writeObject(obj);\n-                }\n-            } catch (EOFException eof){\n-                // ignore ...\n-            }\n-            data = wom.getPayloadAsBytes(null);\n-        } catch (IOException e) {\n-            JMSException jEx = new JMSException(\"Unable to write to internal message .. \" + e);\n-            jEx.setLinkedException(e);\n-            throw jEx;\n-        }\n-\n-        this.writeOnlyMessage = new WriteOnlyMessage(data);\n-\n-        this.readOnlyMessage  = null;\n-        this.readMode = false;\n-    }\n-\n-    StreamMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n-                      String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n-        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n-\n-        final byte[] data = message.getBody().toByteArray();\n-        try {\n-            this.readOnlyMessage = new ReadOnlyMessage(data);\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-\n-        this.writeOnlyMessage = null;\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    protected MessageUtil.SupportedMessageTypes getJmsMessageType() {\n-        return MessageUtil.SupportedMessageTypes.STREAM;\n-    }\n-\n-    protected boolean isBodyEmpty(){\n-        return false;\n-    }\n-\n-    @Override\n-    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n-        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n-        super.populateBuilderWithHeaders(builder);\n-\n-        // Now set body and type.\n-        try {\n-            byte[] data = getPayloadData();\n-            builder.setBody(ByteString.copyFrom(data));\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-\n-        return builder.build();\n-    }\n-\n-\n-    @Override\n-    public boolean readBoolean() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readBoolean();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public byte readByte() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readByte();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public short readShort() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readShort();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public char readChar() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readChar();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readInt() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readInt();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public long readLong() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readLong();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public float readFloat() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readFloat();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public double readDouble() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readDouble();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public String readString() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readString();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public int readBytes(byte[] data) throws JMSException {\n-        throw new UnsupportedOperationException(\"Please use readObject - this method is not supported\");\n-    }\n-\n-    @Override\n-    public Object readObject() throws JMSException {\n-        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n-        try {\n-            return readOnlyMessage.readObject();\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"ioEx ?\");\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeBoolean(boolean val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeBoolean(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeByte(byte val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeByte(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeShort(short val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeShort(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeChar(char val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeChar(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeInt(int val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeInt(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeLong(long val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeLong(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeFloat(float val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeFloat(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeDouble(double val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeDouble(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeString(String val) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeString(val);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeBytes(byte[] data) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeBytes(data);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void writeBytes(byte[] data, int offset, int length) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeBytes(data, offset, length);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    // This method is ONLY supposed to be used for object form of primitive types !\n-    @Override\n-    public void writeObject(Object obj) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        try {\n-            writeOnlyMessage.writeObject(obj);\n-        } catch (IOException ioEx){\n-            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n-            eofEx.setLinkedException(ioEx);\n-            throw eofEx;\n-        }\n-    }\n-\n-    @Override\n-    public void reset() throws JMSException {\n-        if (this.readMode) return ;\n-        this.readMode = true;\n-        try {\n-            byte[] data = writeOnlyMessage.getPayloadAsBytes(null);\n-            this.readOnlyMessage = new ReadOnlyMessage(data);\n-        } catch (IOException e) {\n-            JMSException ex = new JMSException(\"cant convert to read only message ... unexpected actually .. \" + e);\n-            ex.setLinkedException(e);\n-            throw ex;\n-        }\n-        this.writeOnlyMessage = null;\n-    }\n-\n-    @Override\n-    public void clearBody() throws JMSException {\n-        super.clearBody();\n-        this.writeOnlyMessage = new WriteOnlyMessage();\n-        this.readOnlyMessage = null;\n-        this.readMode = false;\n-    }\n-\n-    private byte[] getPayloadData() throws IOException, IllegalStateException {\n-        if (readMode) return readOnlyMessage.getDataCopy();\n-\n-        Mutable<byte[]> preCloseData = new Mutable<byte[]>(null);\n-        byte[] data = writeOnlyMessage.getPayloadAsBytes(preCloseData);\n-\n-        writeOnlyMessage = new WriteOnlyMessage(preCloseData.getValue());\n-        return data;\n-    }\n-\n-\n-    @Override\n-    StreamMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId)\n-        throws JMSException {\n-        return new StreamMessageImpl(session, this, sourceTopicName, subscriberId);\n-    }\n-\n-    // Using java object's instead of primitives to avoid having to store schema separately.\n-    private static class ReadOnlyMessage {\n-\n-        private final ObjectInputStream ois;\n-        private final byte[] data;\n-        private final Deque<Object> unreadObjects = new ArrayDeque<Object>(4);\n-\n-        public ReadOnlyMessage(byte[] data) throws IOException {\n-            this.data = data;\n-            this.ois = new ObjectInputStream(new ByteArrayInputStream(data));\n-        }\n-\n-        public byte[] getDataCopy(){\n-            return Arrays.copyOf(data, data.length);\n-        }\n-\n-        private void unreadObject(Object obj) {\n-            unreadObjects.push(obj);\n-        }\n-\n-        private Object readNextObject() throws IOException, JMSException {\n-            try {\n-                if (! unreadObjects.isEmpty()) return unreadObjects.pop();\n-\n-                return ois.readObject();\n-            } catch (ClassNotFoundException e) {\n-                // unexpected !\n-                javax.jms.IllegalStateException jEx =\n-                    new javax.jms.IllegalStateException(\"Unexpected not to be able to resolve class\");\n-                jEx.setLinkedException(e);\n-                throw jEx;\n-            } catch (EOFException eof) {\n-                throw new MessageEOFException(\"eof\");\n-            }\n-        }\n-\n-        public boolean readBoolean() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Boolean value = MessageUtil.asBoolean(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public byte readByte() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Byte value = MessageUtil.asByte(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public short readShort() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Short value = MessageUtil.asShort(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public char readChar() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Character value = MessageUtil.asChar(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public int readInt() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Integer value = MessageUtil.asInteger(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public long readLong() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Long value = MessageUtil.asLong(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public float readFloat() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Float value = MessageUtil.asFloat(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public double readDouble() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                Double value = MessageUtil.asDouble(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public String readString() throws IOException, JMSException {\n-            Object obj = readNextObject();\n-            boolean failed = true;\n-            try {\n-                String value = MessageUtil.asString(obj);\n-                failed = false;\n-                return value;\n-            } finally {\n-                if (failed) unreadObject(obj);\n-            }\n-        }\n-\n-        public Object readObject() throws IOException, JMSException {\n-            return readNextObject();\n-        }\n-    }\n-\n-    private static class WriteOnlyMessage {\n-\n-        private final ByteArrayOutputStream baos;\n-        // private ObjectOutputStream oos;\n-        private final ObjectOutputStream oos;\n-\n-        public WriteOnlyMessage() throws JMSException {\n-            baos = new ByteArrayOutputStream();\n-            try {\n-                oos = new ObjectOutputStream(baos);\n-            } catch (IOException e) {\n-                IllegalStateException jEx =\n-                    new IllegalStateException(\"Unexpected to not be able to create empty write only message\");\n-                jEx.setLinkedException(e);\n-                throw jEx;\n-            }\n-        }\n-\n-        private WriteOnlyMessage(final byte[] data) throws IllegalStateException {\n-            baos = new ByteArrayOutputStream();\n-            try {\n-                if (null != data) baos.write(data);\n-                baos.flush();\n-                oos = new ObjectOutputStream(baos){\n-                    // Do not write the header if data is based on already materialized stream.\n-                    protected void writeStreamHeader() throws IOException {\n-                        if (null == data || 0 == data.length) super.writeStreamHeader();\n-                    }\n-                };\n-            } catch (IOException e) {\n-                IllegalStateException jEx =\n-                    new IllegalStateException(\"Unexpected to not be able to create empty write only message\");\n-                jEx.setLinkedException(e);\n-                throw jEx;\n-            }\n-        }\n-\n-        public byte[] getPayloadAsBytes(Mutable<byte[]> preCloseData) throws IOException {\n-            oos.flush();\n-            baos.flush();\n-            if (null != preCloseData) preCloseData.setValue(baos.toByteArray());\n-            oos.close();\n-            baos.flush();\n-            baos.close();\n-            // oos = null;\n-            return baos.toByteArray();\n-        }\n-\n-        public void writeBoolean(boolean val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeByte(byte val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeShort(short val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeChar(char val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeInt(int val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeLong(long val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeFloat(float val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeDouble(double val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeString(String val) throws IOException {\n-            oos.writeObject(val);\n-        }\n-\n-        public void writeBytes(byte[] data) throws IOException {\n-            oos.writeObject(data);\n-        }\n-\n-        // copy and write as a single byte array.\n-        public void writeBytes(byte[] data, int offset, int length) throws IOException {\n-            byte[] arr = new byte[length];\n-            System.arraycopy(data, offset, arr, 0, length);\n-            writeBytes(arr);\n-        }\n-\n-        public void writeObject(Object obj) throws JMSException, IOException {\n-            // unrolling it\n-            if (obj instanceof Boolean) {\n-                writeBoolean((Boolean) obj);\n-            }\n-            else if (obj instanceof Byte) {\n-                writeByte((Byte) obj);\n-            }\n-            else if (obj instanceof Short) {\n-                writeShort((Short) obj);\n-            }\n-            else if (obj instanceof Character) {\n-                writeChar((Character) obj);\n-            }\n-            else if (obj instanceof Integer) {\n-                writeInt((Integer) obj);\n-            }\n-            else if (obj instanceof Long) {\n-                writeLong((Long) obj);\n-            }\n-            else if (obj instanceof Float) {\n-                writeFloat((Float) obj);\n-            }\n-            else if (obj instanceof Double) {\n-                writeDouble((Double) obj);\n-            }\n-            else if (obj instanceof String) {\n-                writeString((String) obj);\n-            }\n-            else if (obj instanceof byte[]) {\n-                writeBytes((byte[]) obj);\n-            }\n-            else{\n-                throw new JMSException(\"Unsupported type for obj : \" + obj.getClass());\n-            }\n-        }\n-    }\n-}\n\\ No newline at end of file"},{"sha":"dc3a3ca4e8298471e06fc307d37a3cdc40da70b3","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java","status":"removed","additions":0,"deletions":135,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,135 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.message;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageNotWriteableException;\n-import javax.jms.TextMessage;\n-import java.util.Map;\n-\n-/**\n- * read/write text message ...\n- */\n-public class TextMessageImpl extends MessageImpl implements TextMessage {\n-    private String payload;\n-    private boolean readMode;\n-\n-    public TextMessageImpl(SessionImpl session) {\n-        super(session);\n-        this.readMode = false;\n-    }\n-\n-    public TextMessageImpl(SessionImpl session, String payload) {\n-        super(session);\n-        this.payload = payload;\n-        this.readMode = false;\n-    }\n-\n-    public TextMessageImpl(SessionImpl session, TextMessageImpl message, String sourceTopicName,\n-                           String subscriberId) throws JMSException {\n-        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n-\n-        this.payload = message.getText();\n-        this.readMode = message.readMode;\n-    }\n-\n-\n-    // To clone a message from a TextMessage which is NOT TextMessageImpl\n-    // Changing order of parameter to NOT accidentally clash with the constructor above.\n-    // This is midly confusing, but helps a lot in preventing accidental bugs !\n-    public TextMessageImpl(TextMessage message, SessionImpl session) throws JMSException {\n-        super((Message) message, session);\n-\n-        if (message instanceof TextMessageImpl) {\n-            throw new JMSException(\"Coding bug - should use this constructor ONLY for non TextMessageImpl messages\");\n-        }\n-\n-        this.payload = message.getText();\n-        this.readMode = false;\n-    }\n-\n-    public TextMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n-                           String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n-        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n-\n-        this.payload = hasBodyFromProperties() ? message.getBody().toStringUtf8() : null;\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    protected MessageUtil.SupportedMessageTypes getJmsMessageType() {\n-        return MessageUtil.SupportedMessageTypes.TEXT;\n-    }\n-\n-    @Override\n-    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n-        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n-        super.populateBuilderWithHeaders(builder);\n-        if (! isBodyEmpty()) builder.setBody(ByteString.copyFromUtf8(this.payload));\n-        return builder.build();\n-    }\n-\n-    protected boolean isBodyEmpty(){\n-        return null == this.payload;\n-    }\n-\n-    @Override\n-    public void setText(String payload) throws JMSException {\n-        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n-        this.payload = payload;\n-    }\n-\n-    @Override\n-    public String getText() throws JMSException {\n-        return payload;\n-    }\n-\n-    @Override\n-    public void clearBody() throws JMSException {\n-        super.clearBody();\n-        this.payload = null;\n-        this.readMode = false;\n-    }\n-\n-    @Override\n-    public void reset() throws JMSException {\n-        if (this.readMode) return ;\n-        this.readMode = true;\n-    }\n-\n-    @Override\n-    TextMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId) throws JMSException {\n-        return new TextMessageImpl(session, this, sourceTopicName, subscriberId);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"TextMessageImpl\");\n-        sb.append(\"{payload='\").append(payload).append('\\'');\n-        sb.append(\", readMode=\").append(readMode);\n-        sb.append(\", parent=\").append(super.toString());\n-        sb.append('}');\n-        return sb.toString();\n-    }\n-}"},{"sha":"c4b51233e6c750c1d0ba5d5c52f9ff5573f01e9c","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java","status":"removed","additions":0,"deletions":1126,"changes":1126,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,1126 +0,0 @@\n-// Generated by the protocol buffer compiler.  DO NOT EDIT!\n-// source: src/main/protobuf/JmsHeader.proto\n-\n-package org.apache.hedwig.jms.message.header;\n-\n-public final class JmsHeader {\n-  private JmsHeader() {}\n-  public static void registerAllExtensions(\n-      com.google.protobuf.ExtensionRegistry registry) {\n-  }\n-  public enum ProtocolVersion\n-      implements com.google.protobuf.ProtocolMessageEnum {\n-    VERSION_ONE(0, 1),\n-    ;\n-    \n-    public static final int VERSION_ONE_VALUE = 1;\n-    \n-    \n-    public final int getNumber() { return value; }\n-    \n-    public static ProtocolVersion valueOf(int value) {\n-      switch (value) {\n-        case 1: return VERSION_ONE;\n-        default: return null;\n-      }\n-    }\n-    \n-    public static com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>\n-        internalGetValueMap() {\n-      return internalValueMap;\n-    }\n-    private static com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>\n-        internalValueMap =\n-          new com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>() {\n-            public ProtocolVersion findValueByNumber(int number) {\n-              return ProtocolVersion.valueOf(number);\n-            }\n-          };\n-    \n-    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n-        getValueDescriptor() {\n-      return getDescriptor().getValues().get(index);\n-    }\n-    public final com.google.protobuf.Descriptors.EnumDescriptor\n-        getDescriptorForType() {\n-      return getDescriptor();\n-    }\n-    public static final com.google.protobuf.Descriptors.EnumDescriptor\n-        getDescriptor() {\n-      return org.apache.hedwig.jms.message.header.JmsHeader.getDescriptor().getEnumTypes().get(0);\n-    }\n-    \n-    private static final ProtocolVersion[] VALUES = {\n-      VERSION_ONE, \n-    };\n-    \n-    public static ProtocolVersion valueOf(\n-        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n-      if (desc.getType() != getDescriptor()) {\n-        throw new java.lang.IllegalArgumentException(\n-          \"EnumValueDescriptor is not for this type.\");\n-      }\n-      return VALUES[desc.getIndex()];\n-    }\n-    \n-    private final int index;\n-    private final int value;\n-    \n-    private ProtocolVersion(int index, int value) {\n-      this.index = index;\n-      this.value = value;\n-    }\n-    \n-    // @@protoc_insertion_point(enum_scope:Hedwig.Jms.Header.ProtocolVersion)\n-  }\n-  \n-  public interface JmsValueOrBuilder\n-      extends com.google.protobuf.MessageOrBuilder {\n-    \n-    // required .Hedwig.Jms.Header.JmsValue.ValueType type = 1;\n-    boolean hasType();\n-    org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType getType();\n-    \n-    // optional bool booleanValue = 2;\n-    boolean hasBooleanValue();\n-    boolean getBooleanValue();\n-    \n-    // optional sint32 byteValue = 3;\n-    boolean hasByteValue();\n-    int getByteValue();\n-    \n-    // optional sint32 shortValue = 4;\n-    boolean hasShortValue();\n-    int getShortValue();\n-    \n-    // optional sint32 intValue = 5;\n-    boolean hasIntValue();\n-    int getIntValue();\n-    \n-    // optional sint64 longValue = 6;\n-    boolean hasLongValue();\n-    long getLongValue();\n-    \n-    // optional float floatValue = 7;\n-    boolean hasFloatValue();\n-    float getFloatValue();\n-    \n-    // optional double doubleValue = 8;\n-    boolean hasDoubleValue();\n-    double getDoubleValue();\n-    \n-    // optional string stringValue = 9;\n-    boolean hasStringValue();\n-    String getStringValue();\n-    \n-    // optional bytes bytesValue = 10;\n-    boolean hasBytesValue();\n-    com.google.protobuf.ByteString getBytesValue();\n-  }\n-  public static final class JmsValue extends\n-      com.google.protobuf.GeneratedMessage\n-      implements JmsValueOrBuilder {\n-    // Use JmsValue.newBuilder() to construct.\n-    private JmsValue(Builder builder) {\n-      super(builder);\n-    }\n-    private JmsValue(boolean noInit) {}\n-    \n-    private static final JmsValue defaultInstance;\n-    public static JmsValue getDefaultInstance() {\n-      return defaultInstance;\n-    }\n-    \n-    public JmsValue getDefaultInstanceForType() {\n-      return defaultInstance;\n-    }\n-    \n-    public static final com.google.protobuf.Descriptors.Descriptor\n-        getDescriptor() {\n-      return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_descriptor;\n-    }\n-    \n-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n-        internalGetFieldAccessorTable() {\n-      return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable;\n-    }\n-    \n-    public enum ValueType\n-        implements com.google.protobuf.ProtocolMessageEnum {\n-      BOOLEAN(0, 1),\n-      BYTE(1, 2),\n-      SHORT(2, 3),\n-      INT(3, 4),\n-      LONG(4, 5),\n-      FLOAT(5, 6),\n-      DOUBLE(6, 7),\n-      STRING(7, 8),\n-      BYTES(8, 9),\n-      ;\n-      \n-      public static final int BOOLEAN_VALUE = 1;\n-      public static final int BYTE_VALUE = 2;\n-      public static final int SHORT_VALUE = 3;\n-      public static final int INT_VALUE = 4;\n-      public static final int LONG_VALUE = 5;\n-      public static final int FLOAT_VALUE = 6;\n-      public static final int DOUBLE_VALUE = 7;\n-      public static final int STRING_VALUE = 8;\n-      public static final int BYTES_VALUE = 9;\n-      \n-      \n-      public final int getNumber() { return value; }\n-      \n-      public static ValueType valueOf(int value) {\n-        switch (value) {\n-          case 1: return BOOLEAN;\n-          case 2: return BYTE;\n-          case 3: return SHORT;\n-          case 4: return INT;\n-          case 5: return LONG;\n-          case 6: return FLOAT;\n-          case 7: return DOUBLE;\n-          case 8: return STRING;\n-          case 9: return BYTES;\n-          default: return null;\n-        }\n-      }\n-      \n-      public static com.google.protobuf.Internal.EnumLiteMap<ValueType>\n-          internalGetValueMap() {\n-        return internalValueMap;\n-      }\n-      private static com.google.protobuf.Internal.EnumLiteMap<ValueType>\n-          internalValueMap =\n-            new com.google.protobuf.Internal.EnumLiteMap<ValueType>() {\n-              public ValueType findValueByNumber(int number) {\n-                return ValueType.valueOf(number);\n-              }\n-            };\n-      \n-      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n-          getValueDescriptor() {\n-        return getDescriptor().getValues().get(index);\n-      }\n-      public final com.google.protobuf.Descriptors.EnumDescriptor\n-          getDescriptorForType() {\n-        return getDescriptor();\n-      }\n-      public static final com.google.protobuf.Descriptors.EnumDescriptor\n-          getDescriptor() {\n-        return org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDescriptor().getEnumTypes().get(0);\n-      }\n-      \n-      private static final ValueType[] VALUES = {\n-        BOOLEAN, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE, STRING, BYTES, \n-      };\n-      \n-      public static ValueType valueOf(\n-          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n-        if (desc.getType() != getDescriptor()) {\n-          throw new java.lang.IllegalArgumentException(\n-            \"EnumValueDescriptor is not for this type.\");\n-        }\n-        return VALUES[desc.getIndex()];\n-      }\n-      \n-      private final int index;\n-      private final int value;\n-      \n-      private ValueType(int index, int value) {\n-        this.index = index;\n-        this.value = value;\n-      }\n-      \n-      // @@protoc_insertion_point(enum_scope:Hedwig.Jms.Header.JmsValue.ValueType)\n-    }\n-    \n-    private int bitField0_;\n-    // required .Hedwig.Jms.Header.JmsValue.ValueType type = 1;\n-    public static final int TYPE_FIELD_NUMBER = 1;\n-    private org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType type_;\n-    public boolean hasType() {\n-      return ((bitField0_ & 0x00000001) == 0x00000001);\n-    }\n-    public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType getType() {\n-      return type_;\n-    }\n-    \n-    // optional bool booleanValue = 2;\n-    public static final int BOOLEANVALUE_FIELD_NUMBER = 2;\n-    private boolean booleanValue_;\n-    public boolean hasBooleanValue() {\n-      return ((bitField0_ & 0x00000002) == 0x00000002);\n-    }\n-    public boolean getBooleanValue() {\n-      return booleanValue_;\n-    }\n-    \n-    // optional sint32 byteValue = 3;\n-    public static final int BYTEVALUE_FIELD_NUMBER = 3;\n-    private int byteValue_;\n-    public boolean hasByteValue() {\n-      return ((bitField0_ & 0x00000004) == 0x00000004);\n-    }\n-    public int getByteValue() {\n-      return byteValue_;\n-    }\n-    \n-    // optional sint32 shortValue = 4;\n-    public static final int SHORTVALUE_FIELD_NUMBER = 4;\n-    private int shortValue_;\n-    public boolean hasShortValue() {\n-      return ((bitField0_ & 0x00000008) == 0x00000008);\n-    }\n-    public int getShortValue() {\n-      return shortValue_;\n-    }\n-    \n-    // optional sint32 intValue = 5;\n-    public static final int INTVALUE_FIELD_NUMBER = 5;\n-    private int intValue_;\n-    public boolean hasIntValue() {\n-      return ((bitField0_ & 0x00000010) == 0x00000010);\n-    }\n-    public int getIntValue() {\n-      return intValue_;\n-    }\n-    \n-    // optional sint64 longValue = 6;\n-    public static final int LONGVALUE_FIELD_NUMBER = 6;\n-    private long longValue_;\n-    public boolean hasLongValue() {\n-      return ((bitField0_ & 0x00000020) == 0x00000020);\n-    }\n-    public long getLongValue() {\n-      return longValue_;\n-    }\n-    \n-    // optional float floatValue = 7;\n-    public static final int FLOATVALUE_FIELD_NUMBER = 7;\n-    private float floatValue_;\n-    public boolean hasFloatValue() {\n-      return ((bitField0_ & 0x00000040) == 0x00000040);\n-    }\n-    public float getFloatValue() {\n-      return floatValue_;\n-    }\n-    \n-    // optional double doubleValue = 8;\n-    public static final int DOUBLEVALUE_FIELD_NUMBER = 8;\n-    private double doubleValue_;\n-    public boolean hasDoubleValue() {\n-      return ((bitField0_ & 0x00000080) == 0x00000080);\n-    }\n-    public double getDoubleValue() {\n-      return doubleValue_;\n-    }\n-    \n-    // optional string stringValue = 9;\n-    public static final int STRINGVALUE_FIELD_NUMBER = 9;\n-    private java.lang.Object stringValue_;\n-    public boolean hasStringValue() {\n-      return ((bitField0_ & 0x00000100) == 0x00000100);\n-    }\n-    public String getStringValue() {\n-      java.lang.Object ref = stringValue_;\n-      if (ref instanceof String) {\n-        return (String) ref;\n-      } else {\n-        com.google.protobuf.ByteString bs = \n-            (com.google.protobuf.ByteString) ref;\n-        String s = bs.toStringUtf8();\n-        if (com.google.protobuf.Internal.isValidUtf8(bs)) {\n-          stringValue_ = s;\n-        }\n-        return s;\n-      }\n-    }\n-    private com.google.protobuf.ByteString getStringValueBytes() {\n-      java.lang.Object ref = stringValue_;\n-      if (ref instanceof String) {\n-        com.google.protobuf.ByteString b = \n-            com.google.protobuf.ByteString.copyFromUtf8((String) ref);\n-        stringValue_ = b;\n-        return b;\n-      } else {\n-        return (com.google.protobuf.ByteString) ref;\n-      }\n-    }\n-    \n-    // optional bytes bytesValue = 10;\n-    public static final int BYTESVALUE_FIELD_NUMBER = 10;\n-    private com.google.protobuf.ByteString bytesValue_;\n-    public boolean hasBytesValue() {\n-      return ((bitField0_ & 0x00000200) == 0x00000200);\n-    }\n-    public com.google.protobuf.ByteString getBytesValue() {\n-      return bytesValue_;\n-    }\n-    \n-    private void initFields() {\n-      type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n-      booleanValue_ = false;\n-      byteValue_ = 0;\n-      shortValue_ = 0;\n-      intValue_ = 0;\n-      longValue_ = 0L;\n-      floatValue_ = 0F;\n-      doubleValue_ = 0D;\n-      stringValue_ = \"\";\n-      bytesValue_ = com.google.protobuf.ByteString.EMPTY;\n-    }\n-    private byte memoizedIsInitialized = -1;\n-    public final boolean isInitialized() {\n-      byte isInitialized = memoizedIsInitialized;\n-      if (isInitialized != -1) return isInitialized == 1;\n-      \n-      if (!hasType()) {\n-        memoizedIsInitialized = 0;\n-        return false;\n-      }\n-      memoizedIsInitialized = 1;\n-      return true;\n-    }\n-    \n-    public void writeTo(com.google.protobuf.CodedOutputStream output)\n-                        throws java.io.IOException {\n-      getSerializedSize();\n-      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n-        output.writeEnum(1, type_.getNumber());\n-      }\n-      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n-        output.writeBool(2, booleanValue_);\n-      }\n-      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n-        output.writeSInt32(3, byteValue_);\n-      }\n-      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n-        output.writeSInt32(4, shortValue_);\n-      }\n-      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n-        output.writeSInt32(5, intValue_);\n-      }\n-      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n-        output.writeSInt64(6, longValue_);\n-      }\n-      if (((bitField0_ & 0x00000040) == 0x00000040)) {\n-        output.writeFloat(7, floatValue_);\n-      }\n-      if (((bitField0_ & 0x00000080) == 0x00000080)) {\n-        output.writeDouble(8, doubleValue_);\n-      }\n-      if (((bitField0_ & 0x00000100) == 0x00000100)) {\n-        output.writeBytes(9, getStringValueBytes());\n-      }\n-      if (((bitField0_ & 0x00000200) == 0x00000200)) {\n-        output.writeBytes(10, bytesValue_);\n-      }\n-      getUnknownFields().writeTo(output);\n-    }\n-    \n-    private int memoizedSerializedSize = -1;\n-    public int getSerializedSize() {\n-      int size = memoizedSerializedSize;\n-      if (size != -1) return size;\n-    \n-      size = 0;\n-      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeEnumSize(1, type_.getNumber());\n-      }\n-      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeBoolSize(2, booleanValue_);\n-      }\n-      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeSInt32Size(3, byteValue_);\n-      }\n-      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeSInt32Size(4, shortValue_);\n-      }\n-      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeSInt32Size(5, intValue_);\n-      }\n-      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeSInt64Size(6, longValue_);\n-      }\n-      if (((bitField0_ & 0x00000040) == 0x00000040)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeFloatSize(7, floatValue_);\n-      }\n-      if (((bitField0_ & 0x00000080) == 0x00000080)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeDoubleSize(8, doubleValue_);\n-      }\n-      if (((bitField0_ & 0x00000100) == 0x00000100)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeBytesSize(9, getStringValueBytes());\n-      }\n-      if (((bitField0_ & 0x00000200) == 0x00000200)) {\n-        size += com.google.protobuf.CodedOutputStream\n-          .computeBytesSize(10, bytesValue_);\n-      }\n-      size += getUnknownFields().getSerializedSize();\n-      memoizedSerializedSize = size;\n-      return size;\n-    }\n-    \n-    private static final long serialVersionUID = 0L;\n-    @java.lang.Override\n-    protected java.lang.Object writeReplace()\n-        throws java.io.ObjectStreamException {\n-      return super.writeReplace();\n-    }\n-    \n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n-        com.google.protobuf.ByteString data)\n-        throws com.google.protobuf.InvalidProtocolBufferException {\n-      return newBuilder().mergeFrom(data).buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n-        com.google.protobuf.ByteString data,\n-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n-        throws com.google.protobuf.InvalidProtocolBufferException {\n-      return newBuilder().mergeFrom(data, extensionRegistry)\n-               .buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(byte[] data)\n-        throws com.google.protobuf.InvalidProtocolBufferException {\n-      return newBuilder().mergeFrom(data).buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n-        byte[] data,\n-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n-        throws com.google.protobuf.InvalidProtocolBufferException {\n-      return newBuilder().mergeFrom(data, extensionRegistry)\n-               .buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(java.io.InputStream input)\n-        throws java.io.IOException {\n-      return newBuilder().mergeFrom(input).buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n-        java.io.InputStream input,\n-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n-        throws java.io.IOException {\n-      return newBuilder().mergeFrom(input, extensionRegistry)\n-               .buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseDelimitedFrom(java.io.InputStream input)\n-        throws java.io.IOException {\n-      Builder builder = newBuilder();\n-      if (builder.mergeDelimitedFrom(input)) {\n-        return builder.buildParsed();\n-      } else {\n-        return null;\n-      }\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseDelimitedFrom(\n-        java.io.InputStream input,\n-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n-        throws java.io.IOException {\n-      Builder builder = newBuilder();\n-      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n-        return builder.buildParsed();\n-      } else {\n-        return null;\n-      }\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n-        com.google.protobuf.CodedInputStream input)\n-        throws java.io.IOException {\n-      return newBuilder().mergeFrom(input).buildParsed();\n-    }\n-    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n-        com.google.protobuf.CodedInputStream input,\n-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n-        throws java.io.IOException {\n-      return newBuilder().mergeFrom(input, extensionRegistry)\n-               .buildParsed();\n-    }\n-    \n-    public static Builder newBuilder() { return Builder.create(); }\n-    public Builder newBuilderForType() { return newBuilder(); }\n-    public static Builder newBuilder(org.apache.hedwig.jms.message.header.JmsHeader.JmsValue prototype) {\n-      return newBuilder().mergeFrom(prototype);\n-    }\n-    public Builder toBuilder() { return newBuilder(this); }\n-    \n-    @java.lang.Override\n-    protected Builder newBuilderForType(\n-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n-      Builder builder = new Builder(parent);\n-      return builder;\n-    }\n-    public static final class Builder extends\n-        com.google.protobuf.GeneratedMessage.Builder<Builder>\n-       implements org.apache.hedwig.jms.message.header.JmsHeader.JmsValueOrBuilder {\n-      public static final com.google.protobuf.Descriptors.Descriptor\n-          getDescriptor() {\n-        return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_descriptor;\n-      }\n-      \n-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n-          internalGetFieldAccessorTable() {\n-        return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable;\n-      }\n-      \n-      // Construct using org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.newBuilder()\n-      private Builder() {\n-        maybeForceBuilderInitialization();\n-      }\n-      \n-      private Builder(BuilderParent parent) {\n-        super(parent);\n-        maybeForceBuilderInitialization();\n-      }\n-      private void maybeForceBuilderInitialization() {\n-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n-        }\n-      }\n-      private static Builder create() {\n-        return new Builder();\n-      }\n-      \n-      public Builder clear() {\n-        super.clear();\n-        type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n-        bitField0_ = (bitField0_ & ~0x00000001);\n-        booleanValue_ = false;\n-        bitField0_ = (bitField0_ & ~0x00000002);\n-        byteValue_ = 0;\n-        bitField0_ = (bitField0_ & ~0x00000004);\n-        shortValue_ = 0;\n-        bitField0_ = (bitField0_ & ~0x00000008);\n-        intValue_ = 0;\n-        bitField0_ = (bitField0_ & ~0x00000010);\n-        longValue_ = 0L;\n-        bitField0_ = (bitField0_ & ~0x00000020);\n-        floatValue_ = 0F;\n-        bitField0_ = (bitField0_ & ~0x00000040);\n-        doubleValue_ = 0D;\n-        bitField0_ = (bitField0_ & ~0x00000080);\n-        stringValue_ = \"\";\n-        bitField0_ = (bitField0_ & ~0x00000100);\n-        bytesValue_ = com.google.protobuf.ByteString.EMPTY;\n-        bitField0_ = (bitField0_ & ~0x00000200);\n-        return this;\n-      }\n-      \n-      public Builder clone() {\n-        return create().mergeFrom(buildPartial());\n-      }\n-      \n-      public com.google.protobuf.Descriptors.Descriptor\n-          getDescriptorForType() {\n-        return org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDescriptor();\n-      }\n-      \n-      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue getDefaultInstanceForType() {\n-        return org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDefaultInstance();\n-      }\n-      \n-      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue build() {\n-        org.apache.hedwig.jms.message.header.JmsHeader.JmsValue result = buildPartial();\n-        if (!result.isInitialized()) {\n-          throw newUninitializedMessageException(result);\n-        }\n-        return result;\n-      }\n-      \n-      private org.apache.hedwig.jms.message.header.JmsHeader.JmsValue buildParsed()\n-          throws com.google.protobuf.InvalidProtocolBufferException {\n-        org.apache.hedwig.jms.message.header.JmsHeader.JmsValue result = buildPartial();\n-        if (!result.isInitialized()) {\n-          throw newUninitializedMessageException(\n-            result).asInvalidProtocolBufferException();\n-        }\n-        return result;\n-      }\n-      \n-      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue buildPartial() {\n-        org.apache.hedwig.jms.message.header.JmsHeader.JmsValue result = new org.apache.hedwig.jms.message.header.JmsHeader.JmsValue(this);\n-        int from_bitField0_ = bitField0_;\n-        int to_bitField0_ = 0;\n-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n-          to_bitField0_ |= 0x00000001;\n-        }\n-        result.type_ = type_;\n-        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n-          to_bitField0_ |= 0x00000002;\n-        }\n-        result.booleanValue_ = booleanValue_;\n-        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {\n-          to_bitField0_ |= 0x00000004;\n-        }\n-        result.byteValue_ = byteValue_;\n-        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {\n-          to_bitField0_ |= 0x00000008;\n-        }\n-        result.shortValue_ = shortValue_;\n-        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {\n-          to_bitField0_ |= 0x00000010;\n-        }\n-        result.intValue_ = intValue_;\n-        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {\n-          to_bitField0_ |= 0x00000020;\n-        }\n-        result.longValue_ = longValue_;\n-        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {\n-          to_bitField0_ |= 0x00000040;\n-        }\n-        result.floatValue_ = floatValue_;\n-        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {\n-          to_bitField0_ |= 0x00000080;\n-        }\n-        result.doubleValue_ = doubleValue_;\n-        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {\n-          to_bitField0_ |= 0x00000100;\n-        }\n-        result.stringValue_ = stringValue_;\n-        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {\n-          to_bitField0_ |= 0x00000200;\n-        }\n-        result.bytesValue_ = bytesValue_;\n-        result.bitField0_ = to_bitField0_;\n-        onBuilt();\n-        return result;\n-      }\n-      \n-      public Builder mergeFrom(com.google.protobuf.Message other) {\n-        if (other instanceof org.apache.hedwig.jms.message.header.JmsHeader.JmsValue) {\n-          return mergeFrom((org.apache.hedwig.jms.message.header.JmsHeader.JmsValue)other);\n-        } else {\n-          super.mergeFrom(other);\n-          return this;\n-        }\n-      }\n-      \n-      public Builder mergeFrom(org.apache.hedwig.jms.message.header.JmsHeader.JmsValue other) {\n-        if (other == org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDefaultInstance()) return this;\n-        if (other.hasType()) {\n-          setType(other.getType());\n-        }\n-        if (other.hasBooleanValue()) {\n-          setBooleanValue(other.getBooleanValue());\n-        }\n-        if (other.hasByteValue()) {\n-          setByteValue(other.getByteValue());\n-        }\n-        if (other.hasShortValue()) {\n-          setShortValue(other.getShortValue());\n-        }\n-        if (other.hasIntValue()) {\n-          setIntValue(other.getIntValue());\n-        }\n-        if (other.hasLongValue()) {\n-          setLongValue(other.getLongValue());\n-        }\n-        if (other.hasFloatValue()) {\n-          setFloatValue(other.getFloatValue());\n-        }\n-        if (other.hasDoubleValue()) {\n-          setDoubleValue(other.getDoubleValue());\n-        }\n-        if (other.hasStringValue()) {\n-          setStringValue(other.getStringValue());\n-        }\n-        if (other.hasBytesValue()) {\n-          setBytesValue(other.getBytesValue());\n-        }\n-        this.mergeUnknownFields(other.getUnknownFields());\n-        return this;\n-      }\n-      \n-      public final boolean isInitialized() {\n-        if (!hasType()) {\n-          \n-          return false;\n-        }\n-        return true;\n-      }\n-      \n-      public Builder mergeFrom(\n-          com.google.protobuf.CodedInputStream input,\n-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n-          throws java.io.IOException {\n-        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n-          com.google.protobuf.UnknownFieldSet.newBuilder(\n-            this.getUnknownFields());\n-        while (true) {\n-          int tag = input.readTag();\n-          switch (tag) {\n-            case 0:\n-              this.setUnknownFields(unknownFields.build());\n-              onChanged();\n-              return this;\n-            default: {\n-              if (!parseUnknownField(input, unknownFields,\n-                                     extensionRegistry, tag)) {\n-                this.setUnknownFields(unknownFields.build());\n-                onChanged();\n-                return this;\n-              }\n-              break;\n-            }\n-            case 8: {\n-              int rawValue = input.readEnum();\n-              org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType value = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.valueOf(rawValue);\n-              if (value == null) {\n-                unknownFields.mergeVarintField(1, rawValue);\n-              } else {\n-                bitField0_ |= 0x00000001;\n-                type_ = value;\n-              }\n-              break;\n-            }\n-            case 16: {\n-              bitField0_ |= 0x00000002;\n-              booleanValue_ = input.readBool();\n-              break;\n-            }\n-            case 24: {\n-              bitField0_ |= 0x00000004;\n-              byteValue_ = input.readSInt32();\n-              break;\n-            }\n-            case 32: {\n-              bitField0_ |= 0x00000008;\n-              shortValue_ = input.readSInt32();\n-              break;\n-            }\n-            case 40: {\n-              bitField0_ |= 0x00000010;\n-              intValue_ = input.readSInt32();\n-              break;\n-            }\n-            case 48: {\n-              bitField0_ |= 0x00000020;\n-              longValue_ = input.readSInt64();\n-              break;\n-            }\n-            case 61: {\n-              bitField0_ |= 0x00000040;\n-              floatValue_ = input.readFloat();\n-              break;\n-            }\n-            case 65: {\n-              bitField0_ |= 0x00000080;\n-              doubleValue_ = input.readDouble();\n-              break;\n-            }\n-            case 74: {\n-              bitField0_ |= 0x00000100;\n-              stringValue_ = input.readBytes();\n-              break;\n-            }\n-            case 82: {\n-              bitField0_ |= 0x00000200;\n-              bytesValue_ = input.readBytes();\n-              break;\n-            }\n-          }\n-        }\n-      }\n-      \n-      private int bitField0_;\n-      \n-      // required .Hedwig.Jms.Header.JmsValue.ValueType type = 1;\n-      private org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n-      public boolean hasType() {\n-        return ((bitField0_ & 0x00000001) == 0x00000001);\n-      }\n-      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType getType() {\n-        return type_;\n-      }\n-      public Builder setType(org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType value) {\n-        if (value == null) {\n-          throw new NullPointerException();\n-        }\n-        bitField0_ |= 0x00000001;\n-        type_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearType() {\n-        bitField0_ = (bitField0_ & ~0x00000001);\n-        type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional bool booleanValue = 2;\n-      private boolean booleanValue_ ;\n-      public boolean hasBooleanValue() {\n-        return ((bitField0_ & 0x00000002) == 0x00000002);\n-      }\n-      public boolean getBooleanValue() {\n-        return booleanValue_;\n-      }\n-      public Builder setBooleanValue(boolean value) {\n-        bitField0_ |= 0x00000002;\n-        booleanValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearBooleanValue() {\n-        bitField0_ = (bitField0_ & ~0x00000002);\n-        booleanValue_ = false;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional sint32 byteValue = 3;\n-      private int byteValue_ ;\n-      public boolean hasByteValue() {\n-        return ((bitField0_ & 0x00000004) == 0x00000004);\n-      }\n-      public int getByteValue() {\n-        return byteValue_;\n-      }\n-      public Builder setByteValue(int value) {\n-        bitField0_ |= 0x00000004;\n-        byteValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearByteValue() {\n-        bitField0_ = (bitField0_ & ~0x00000004);\n-        byteValue_ = 0;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional sint32 shortValue = 4;\n-      private int shortValue_ ;\n-      public boolean hasShortValue() {\n-        return ((bitField0_ & 0x00000008) == 0x00000008);\n-      }\n-      public int getShortValue() {\n-        return shortValue_;\n-      }\n-      public Builder setShortValue(int value) {\n-        bitField0_ |= 0x00000008;\n-        shortValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearShortValue() {\n-        bitField0_ = (bitField0_ & ~0x00000008);\n-        shortValue_ = 0;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional sint32 intValue = 5;\n-      private int intValue_ ;\n-      public boolean hasIntValue() {\n-        return ((bitField0_ & 0x00000010) == 0x00000010);\n-      }\n-      public int getIntValue() {\n-        return intValue_;\n-      }\n-      public Builder setIntValue(int value) {\n-        bitField0_ |= 0x00000010;\n-        intValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearIntValue() {\n-        bitField0_ = (bitField0_ & ~0x00000010);\n-        intValue_ = 0;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional sint64 longValue = 6;\n-      private long longValue_ ;\n-      public boolean hasLongValue() {\n-        return ((bitField0_ & 0x00000020) == 0x00000020);\n-      }\n-      public long getLongValue() {\n-        return longValue_;\n-      }\n-      public Builder setLongValue(long value) {\n-        bitField0_ |= 0x00000020;\n-        longValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearLongValue() {\n-        bitField0_ = (bitField0_ & ~0x00000020);\n-        longValue_ = 0L;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional float floatValue = 7;\n-      private float floatValue_ ;\n-      public boolean hasFloatValue() {\n-        return ((bitField0_ & 0x00000040) == 0x00000040);\n-      }\n-      public float getFloatValue() {\n-        return floatValue_;\n-      }\n-      public Builder setFloatValue(float value) {\n-        bitField0_ |= 0x00000040;\n-        floatValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearFloatValue() {\n-        bitField0_ = (bitField0_ & ~0x00000040);\n-        floatValue_ = 0F;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional double doubleValue = 8;\n-      private double doubleValue_ ;\n-      public boolean hasDoubleValue() {\n-        return ((bitField0_ & 0x00000080) == 0x00000080);\n-      }\n-      public double getDoubleValue() {\n-        return doubleValue_;\n-      }\n-      public Builder setDoubleValue(double value) {\n-        bitField0_ |= 0x00000080;\n-        doubleValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearDoubleValue() {\n-        bitField0_ = (bitField0_ & ~0x00000080);\n-        doubleValue_ = 0D;\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // optional string stringValue = 9;\n-      private java.lang.Object stringValue_ = \"\";\n-      public boolean hasStringValue() {\n-        return ((bitField0_ & 0x00000100) == 0x00000100);\n-      }\n-      public String getStringValue() {\n-        java.lang.Object ref = stringValue_;\n-        if (!(ref instanceof String)) {\n-          String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();\n-          stringValue_ = s;\n-          return s;\n-        } else {\n-          return (String) ref;\n-        }\n-      }\n-      public Builder setStringValue(String value) {\n-        if (value == null) {\n-    throw new NullPointerException();\n-  }\n-  bitField0_ |= 0x00000100;\n-        stringValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearStringValue() {\n-        bitField0_ = (bitField0_ & ~0x00000100);\n-        stringValue_ = getDefaultInstance().getStringValue();\n-        onChanged();\n-        return this;\n-      }\n-      void setStringValue(com.google.protobuf.ByteString value) {\n-        bitField0_ |= 0x00000100;\n-        stringValue_ = value;\n-        onChanged();\n-      }\n-      \n-      // optional bytes bytesValue = 10;\n-      private com.google.protobuf.ByteString bytesValue_ = com.google.protobuf.ByteString.EMPTY;\n-      public boolean hasBytesValue() {\n-        return ((bitField0_ & 0x00000200) == 0x00000200);\n-      }\n-      public com.google.protobuf.ByteString getBytesValue() {\n-        return bytesValue_;\n-      }\n-      public Builder setBytesValue(com.google.protobuf.ByteString value) {\n-        if (value == null) {\n-    throw new NullPointerException();\n-  }\n-  bitField0_ |= 0x00000200;\n-        bytesValue_ = value;\n-        onChanged();\n-        return this;\n-      }\n-      public Builder clearBytesValue() {\n-        bitField0_ = (bitField0_ & ~0x00000200);\n-        bytesValue_ = getDefaultInstance().getBytesValue();\n-        onChanged();\n-        return this;\n-      }\n-      \n-      // @@protoc_insertion_point(builder_scope:Hedwig.Jms.Header.JmsValue)\n-    }\n-    \n-    static {\n-      defaultInstance = new JmsValue(true);\n-      defaultInstance.initFields();\n-    }\n-    \n-    // @@protoc_insertion_point(class_scope:Hedwig.Jms.Header.JmsValue)\n-  }\n-  \n-  private static com.google.protobuf.Descriptors.Descriptor\n-    internal_static_Hedwig_Jms_Header_JmsValue_descriptor;\n-  private static\n-    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n-      internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable;\n-  \n-  public static com.google.protobuf.Descriptors.FileDescriptor\n-      getDescriptor() {\n-    return descriptor;\n-  }\n-  private static com.google.protobuf.Descriptors.FileDescriptor\n-      descriptor;\n-  static {\n-    java.lang.String[] descriptorData = {\n-      \"\\n!src/main/protobuf/JmsHeader.proto\\022\\021Hed\" +\n-      \"wig.Jms.Header\\\"\\343\\002\\n\\010JmsValue\\0223\\n\\004type\\030\\001 \\002(\" +\n-      \"\\0162%.Hedwig.Jms.Header.JmsValue.ValueType\" +\n-      \"\\022\\024\\n\\014booleanValue\\030\\002 \\001(\\010\\022\\021\\n\\tbyteValue\\030\\003 \\001(\" +\n-      \"\\021\\022\\022\\n\\nshortValue\\030\\004 \\001(\\021\\022\\020\\n\\010intValue\\030\\005 \\001(\\021\\022\" +\n-      \"\\021\\n\\tlongValue\\030\\006 \\001(\\022\\022\\022\\n\\nfloatValue\\030\\007 \\001(\\002\\022\\023\" +\n-      \"\\n\\013doubleValue\\030\\010 \\001(\\001\\022\\023\\n\\013stringValue\\030\\t \\001(\\t\" +\n-      \"\\022\\022\\n\\nbytesValue\\030\\n \\001(\\014\\\"n\\n\\tValueType\\022\\013\\n\\007BOO\" +\n-      \"LEAN\\020\\001\\022\\010\\n\\004BYTE\\020\\002\\022\\t\\n\\005SHORT\\020\\003\\022\\007\\n\\003INT\\020\\004\\022\\010\\n\\004\" +\n-      \"LONG\\020\\005\\022\\t\\n\\005FLOAT\\020\\006\\022\\n\\n\\006DOUBLE\\020\\007\\022\\n\\n\\006STRING\\020\",\n-      \"\\010\\022\\t\\n\\005BYTES\\020\\t*\\\"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSI\" +\n-      \"ON_ONE\\020\\001B(\\n$org.apache.hedwig.jms.messag\" +\n-      \"e.headerH\\001\"\n-    };\n-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n-      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n-        public com.google.protobuf.ExtensionRegistry assignDescriptors(\n-            com.google.protobuf.Descriptors.FileDescriptor root) {\n-          descriptor = root;\n-          internal_static_Hedwig_Jms_Header_JmsValue_descriptor =\n-            getDescriptor().getMessageTypes().get(0);\n-          internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable = new\n-            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n-              internal_static_Hedwig_Jms_Header_JmsValue_descriptor,\n-              new java.lang.String[] { \"Type\", \"BooleanValue\", \"ByteValue\", \"ShortValue\", \"IntValue\", \"LongValue\", \"FloatValue\", \"DoubleValue\", \"StringValue\", \"BytesValue\", },\n-              org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.class,\n-              org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.Builder.class);\n-          return null;\n-        }\n-      };\n-    com.google.protobuf.Descriptors.FileDescriptor\n-      .internalBuildGeneratedFileFrom(descriptorData,\n-        new com.google.protobuf.Descriptors.FileDescriptor[] {\n-        }, assigner);\n-  }\n-  \n-  // @@protoc_insertion_point(outer_class_scope)\n-}"},{"sha":"38fccd9bd81c01c7e7883c481812739a812caf9f","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java","status":"removed","additions":0,"deletions":163,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,163 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms.message.header;\n-\n-import com.google.protobuf.ByteString;\n-import com.google.protobuf.InvalidProtocolBufferException;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-/**\n- * Decouple rest of system from handling metadata/headers in hedwig.\n- * Since this part might change (and is shared across the system), changes to it should be isolated from rest of\n- * jms provider as much as possible so that they can evolve independently with minimal overlap.\n- */\n-public class MetadataProcessor {\n-\n-    private final static Logger logger = LoggerFactory.getLogger(MetadataProcessor.class);\n-\n-    public static Map<String, Object> parseHeaders(PubSubProtocol.Message message){\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n-        // if not header or properties, return empty map ...\n-        if (! message.hasHeader() || ! message.getHeader().hasProperties()) return properties;\n-\n-        // first, populate the map, then remove the standard headers from it.\n-        for (PubSubProtocol.Map.Entry entry : message.getHeader().getProperties().getEntriesList()){\n-            final JmsHeader.JmsValue value;\n-            try {\n-                ByteString data = entry.getValue();\n-                value = JmsHeader.JmsValue.parseFrom(data);\n-            } catch (InvalidProtocolBufferException e) {\n-                // incorrect type, we cant do much, ignore and continue.\n-                if (logger.isDebugEnabled()) logger.debug(\"Cant parse header \" +\n-                    entry.getKey() + \" as a jms value, ignoring\");\n-                continue;\n-            }\n-\n-            switch(value.getType()){\n-                case BOOLEAN:\n-                    properties.put(entry.getKey(), (boolean) value.getBooleanValue());\n-                    break;\n-                case BYTE:\n-                    properties.put(entry.getKey(), (byte) value.getByteValue());\n-                    break;\n-                case SHORT:\n-                    properties.put(entry.getKey(), (short) value.getShortValue());\n-                    break;\n-                case INT:\n-                    properties.put(entry.getKey(), (int) value.getIntValue());\n-                    break;\n-                case LONG:\n-                    properties.put(entry.getKey(), (long) value.getLongValue());\n-                    break;\n-                case FLOAT:\n-                    properties.put(entry.getKey(), (float) value.getFloatValue());\n-                    break;\n-                case DOUBLE:\n-                    properties.put(entry.getKey(), (double) value.getDoubleValue());\n-                    break;\n-                case STRING:\n-                    properties.put(entry.getKey(), (String) value.getStringValue());\n-                    break;\n-                case BYTES:\n-                    properties.put(entry.getKey(), value.getBytesValue());\n-                    break;\n-                default:\n-                    // future addition not yet supported ...\n-                    logger.info(\"Unknown metadata key type \" + value.getType() +\n-                        \" ... unsupported by jms provider. Ignoring\");\n-                    continue;\n-            }\n-        }\n-        return properties;\n-    }\n-\n-    public static void addHeaders(PubSubProtocol.Message.Builder builder, Map<String, Object> properties) {\n-        // Too many builder.addMetadata(...) code in this method, externalize to their own methods ? maybe later ...\n-        // add the user properties, and then override standard properties.\n-\n-        PubSubProtocol.Map.Builder mapBuilder = PubSubProtocol.Map.newBuilder();\n-\n-        for (Map.Entry<String, Object> entry : properties.entrySet()){\n-            // ignoring, right ?\n-            if (null == entry.getValue()) continue;\n-\n-            final JmsHeader.JmsValue.Builder jmsValueBuilder = JmsHeader.JmsValue.newBuilder();\n-\n-            final String key = entry.getKey();\n-            final Object value = entry.getValue();\n-            if (value instanceof Boolean){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.BOOLEAN);\n-                jmsValueBuilder.setBooleanValue((Boolean) value);\n-            }\n-            else if (value instanceof Byte){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.BYTE);\n-                jmsValueBuilder.setByteValue((Byte) value);\n-            }\n-            else if (value instanceof Short){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.SHORT);\n-                jmsValueBuilder.setShortValue((Short) value);\n-            }\n-            else if (value instanceof Integer){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.INT);\n-                jmsValueBuilder.setIntValue((Integer) value);\n-            }\n-            else if (value instanceof Long){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.LONG);\n-                jmsValueBuilder.setLongValue((Long) value);\n-            }\n-            else if (value instanceof Float){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.FLOAT);\n-                jmsValueBuilder.setFloatValue((Float) value);\n-            }\n-            else if (value instanceof Double){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.DOUBLE);\n-                jmsValueBuilder.setDoubleValue((Double) value);\n-            }\n-            else if (value instanceof String){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.STRING);\n-                jmsValueBuilder.setStringValue((String) value);\n-            }\n-            else if (value instanceof byte[]){\n-                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.BYTES);\n-                jmsValueBuilder.setBytesValue(ByteString.copyFrom((byte[]) value));\n-            }\n-            else {\n-                throw new IllegalArgumentException(\"Unknown property value type ? \" + entry);\n-            }\n-\n-\n-            PubSubProtocol.Map.Entry.Builder entryBuilder = PubSubProtocol.Map.Entry.newBuilder();\n-            entryBuilder.setKey(key);\n-            entryBuilder.setValue(jmsValueBuilder.build().toByteString());\n-\n-            mapBuilder.addEntries(entryBuilder.build());\n-        }\n-\n-        PubSubProtocol.MessageHeader.Builder messageHeaderBuilder = PubSubProtocol.MessageHeader.newBuilder();\n-        messageHeaderBuilder.setProperties(mapBuilder.build());\n-\n-        builder.setHeader(messageHeaderBuilder.build());\n-    }\n-}"},{"sha":"0cd78cb2dc86f2c77ded2e576de7271f872e5103","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html","status":"removed","additions":0,"deletions":29,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,29 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-Contains implementations of various Message's supported by JMS. <br/>\n-The implementations take care of these aspects : <br/>\n-<ul>\n-  <li>Provide a JMS compliant implementation for the different messages</li>\n-  <li>Allows the system to accept and convert Message's NOT created via this package.</li>\n-  <li>Allows system to generate hedwig wire-format messages from these JMS messages. (taken with above,\n-    it allows us to send any JMS message over wire).</li>\n-  <li>Allows system to parse hedwig wire-format messages into JMS messages</li>\n-</ul>\n-\n-Most of the implementation is hidden away and exposed via the MessagUtil - except for what is mandated\n-by JMS, and some state information required by hedwig."},{"sha":"e0150686eaf255b76abc8ca2292099ce6e9357f0","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,92 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-\n-<h3>Introduction</h3>\n-\n-Contains the basic (hedwig agnostic) aspects of the provider implementation <br/>\n-This package enforces (to a large part) the constraints expected by JMS api and maintains state and\n-manages the lifecycle of rest of the provider system. <br/>\n-<p/>\n-It depends only on message package.<br/>\n-It is decoupled from actual nitty-gritties of the hedwig specific aspects via a Facade - which\n-encapsulates all functionalities required off hedwig. <br/>\n-It is envisioned that we will have additional implementations for the facade as time goes by :\n-<ul>\n-  <li>Test mockup facade to test provider aspects decoupled from hedwig</li>\n-  <li>Facade's to experiment with add and/or modify functionality exposed to provider (support for\n-    Queue for example without modifying existing code).</li>\n-  <li>Facade's to experiment with add and/or modify functionality to hedwig itself.</li>\n-  <li>This space for rent :-)</li>\n-</ul>\n-\n-\n-<h3>Missing functionality</h3>\n-\n-Various aspects of JMS are currently unsupported - the detailed list is long, but the main caveats\n-with the provider currently are :\n-<ul>\n-\n-  <li>No support for Queues : Hedwig currently does not have a notion of JMS queue's for us to leverage.</li>\n-\n-  <li>No support for noLocal : Hedwig DOES NOT conform to JMS featureSelection of\n-    connection -(n)-> session -(n)-> publisher/subscriber. Each session has a hedwig connection.<br/>\n-Currently I am simulating noLocal, but this IS fragile and works for the duration of connection -\n-    ONLY until the message id is still in a LRUCache. As mentioned before, this is a kludge, and not\n-    a good solution.<br/>\n-  </li>\n-\n-  <li>Note that everything is durable in hedwig - so we do not support NON_PERSISTENT delivery mode.</li>\n-\n-  <li>Calling unsubscribe on a durable subscription will fail if it was NOT created in the current session. <br/>\n-    In hedwig, to unsubscribe, we need the subscription id and the topic ... <br/>\n-    To simulate unsubscribe(), we store the subscriberId to topicName mapping when a create* api is\n-    invoked. <br/>\n-    Hence, if create* was NOT called, then we have no way to infer which topic the subscription-id\n-    refers to from hedwig, and so cant unsubscribe. <br/>\n-    The workaround is - simply create a durable subsriber just as a workaround of this limitation -\n-    the topicName will be known to the user/client anyway.</li>\n-\n-  <li>Explicit session recovery is not supported.<br/>\n-Reconnection of hedwig session (either explicitly or implicitly by underlying client implementation) will\n-automatically trigger redelivery of un-acknowledged messages.\n-  </li>\n-\n-  <li>Because of the above, setting the JMSRedelivered flag is almost impossible in a consistent way.<br/>\n-Currently, we simulate it for redelivery due to provider side events : rollback of txn, exception\n-    in message listener (primarily). <br/>\n-At best we can simulate it with a kludge - at risk of potentially running out of resources ... this\n-    is being investigated : but unlikely to have a clean fix. <br/>\n-  </li>\n-\n-  <li>Hedwig only supports marking all messages until seq-id as received : while JMS indicates abilit\n-    y to acknowledge individual messages.<br/>\n-This distinction is currently unsupported. Investigating if we can do something about it.\n-  </li>\n-\n-  <li>JMS spec requires\n-    \"A connection's delivery of incoming messages can be temporarily stopped <br/>\n-using its stop() method. It can be restarted using its start() method. When the <br/>\n-connection is stopped, delivery to all the connection’s MessageConsumers is <br/>\n-inhibited: synchronous receives block, and messages are not delivered to <br/>\n-MessageListeners.\"<br/>\n-  We honour this for undelivered messages from server - but if stop is called while there are\n-    pending messages yet to be delivered to a listner (or buffered in subscriber for receive),\n-    then they will be delivered irrespective of stop().</li>\n-\n-</ul>\n-Hopefully I am not missing any of the big points ..."},{"sha":"a2845be563110ae8fd0e7cf36bc085b51e0d5196","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java","status":"removed","additions":0,"deletions":184,"changes":184,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,184 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-/**\n- * Binary arithematic of values ..\n- */\n-public abstract class BinaryArithmeticFunction extends BinaryExprFunction {\n-\n-    protected SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n-                                            MessageImpl message) throws SelectorEvaluationException {\n-\n-        switch (left.type) {\n-            case INT: {\n-                switch (right.type) {\n-                    case INT:\n-                        return new SelectorConstant(computeWithInt(left.getIntValue(), right.getIntValue()));\n-                    case DOUBLE:\n-                        return new SelectorConstant(computeWithInt(left.getIntValue(), right.getDoubleValue()));\n-                    default:\n-                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n-                            right.type + \". left : \" + left + \", right : \" + right);\n-                }\n-            }\n-            case DOUBLE: {\n-                switch (right.type) {\n-                    case INT:\n-                        return new SelectorConstant(computeWithDouble(left.getDoubleValue(), right.getIntValue()));\n-                    case DOUBLE:\n-                        return new SelectorConstant(computeWithDouble(left.getDoubleValue(), right.getDoubleValue()));\n-                    default:\n-                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n-                            right.type + \". left : \" + left + \", right : \" + right);\n-                }\n-            }\n-            case BOOLEAN:\n-            case STRING:\n-            default:\n-                throw new SelectorEvaluationException(getClass() + \" Unsupported type : \" + left.type +\n-                    \". left : \" + left + \", right : \" + right);\n-        }\n-    }\n-\n-\n-    protected abstract Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException;\n-\n-    protected abstract Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException;\n-\n-    protected abstract Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException;\n-\n-    protected abstract Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException;\n-\n-\n-    public static final BinaryArithmeticFunction ADD_FUNCTION = new BinaryArithmeticFunction() {\n-        @Override\n-        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return (double) left + right;\n-        }\n-\n-        @Override\n-        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left + right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left + right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left + (double) right;\n-        }\n-    };\n-\n-    public static final BinaryArithmeticFunction SUB_FUNCTION = new BinaryArithmeticFunction() {\n-        @Override\n-        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return (double) left - right;\n-        }\n-\n-        @Override\n-        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left - right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left - right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left - (double) right;\n-        }\n-    };\n-\n-    public static final BinaryArithmeticFunction MULTIPLY_FUNCTION = new BinaryArithmeticFunction() {\n-        @Override\n-        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return (double) left * right;\n-        }\n-\n-        @Override\n-        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left * right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left * right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left * (double) right;\n-        }\n-    };\n-\n-    public static final BinaryArithmeticFunction DIVIDE_FUNCTION = new BinaryArithmeticFunction() {\n-        @Override\n-        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            if ((double) 0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n-            return (double) left / right;\n-        }\n-\n-        @Override\n-        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            if ((int) 0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n-            return left / right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            if ((double) 0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n-            return left / right;\n-        }\n-\n-        @Override\n-        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            if (0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n-            return left / (double) right;\n-        }\n-    };\n-\n-\n-    @Override\n-    public String toString(){\n-        return getClass().getName();\n-    }\n-}"},{"sha":"6c41b6d0560c337ef82e39561283d4918c4af53b","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,51 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-/**\n- * Evaluate binary expressions - where there is a left and right expression to be evaluated.\n- */\n-public abstract class BinaryExprFunction implements ExprFunction {\n-\n-    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-        if (state.getStack().size() < 2)\n-            throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n-\n-        SelectorConstant right = state.getStack().pop();\n-        SelectorConstant left = state.getStack().pop();\n-\n-        SelectorConstant result = evaluateImpl(left, right, state.getMessage());\n-\n-        if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": left \" + left +\n-            \", right \" + right + \" -> \" + result);\n-\n-        if (null != result) state.getStack().push(result);\n-        else throw new SelectorEvaluationException(getClass() +\n-            \" Unexpected to return a null response in binary function evaluation\");\n-    }\n-\n-    protected abstract SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n-                                                     MessageImpl message) throws SelectorEvaluationException;\n-\n-    @Override\n-    public String toString(){\n-        return getClass().getName();\n-    }\n-}"},{"sha":"da708e3b57df48ba268bffdd3fc10f49a7cfaec4","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java","status":"removed","additions":0,"deletions":25,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,25 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-/**\n- * All function's referenced in the ast implement this interface to evaluate it result.\n- */\n-public interface ExprFunction {\n-    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException;\n-}"},{"sha":"143269fd7f67219631622d9d1c7c9f3652ad1bd1","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java","status":"removed","additions":0,"deletions":180,"changes":180,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,180 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-/**\n- * Visits the AST to evaluate the message (in the SelectorEvalState) against this ast parse tree to see if the\n- * message evaluates to true or false (whether to allow message to be submitted or not to consumers).\n- */\n-public class InterpretSelectorParserVisitor implements SelectorParserVisitor {\n-    @Override\n-    public Object visit(SimpleNode node, SelectorEvalState data) throws SelectorEvaluationException {\n-        throw new SelectorEvaluationException(getClass() + \" Should not result in this method being called !\");\n-    }\n-\n-    @Override\n-    public Object visit(ASTOrExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTAndExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTNotExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTGreaterThan node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLessThan node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLessThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTGreaterThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTNotEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTIsNullExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTBetweenExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTInExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLikeExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLookupExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTAddExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTSubExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTDivideExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTMultiplyExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTNegateExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        node.childrenAccept(this, data);\n-        node.getExprFunction().evaluate(data);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTConstant node, SelectorEvalState data) throws SelectorEvaluationException {\n-        // node.childrenAccept(this, data);\n-        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n-            \" parse error ? \" + node);\n-        data.getStack().push(node.getConstantValue());\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTStringVarargParams node, SelectorEvalState data) throws SelectorEvaluationException {\n-        // node.childrenAccept(this, data);\n-        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n-            \" parse error ? \" + node);\n-        data.getStack().push(node.getConstantValue());\n-        return null;\n-    }\n-}"},{"sha":"4db66f7851faec7378f85eed909ba08874ed68c9","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java","status":"removed","additions":0,"deletions":64,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,64 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-/**\n- * Logical comparison between two booleans.\n- */\n-public abstract class LogicalComparisonFunction extends BinaryExprFunction {\n-    public static final LogicalComparisonFunction AND_FUNCTION = new LogicalComparisonFunction() {\n-        @Override\n-        protected Boolean doComparison(Boolean left, Boolean right) {\n-            if (null == left || null == right) {\n-                return (Boolean.FALSE.equals(left) || Boolean.FALSE.equals(right)) ? false : null;\n-            }\n-            return left && right;\n-        }\n-    };\n-\n-    public static final LogicalComparisonFunction OR_FUNCTION = new LogicalComparisonFunction() {\n-        @Override\n-        protected Boolean doComparison(Boolean left, Boolean right) {\n-            if (null == left || null == right) {\n-                return (Boolean.TRUE.equals(left) || Boolean.TRUE.equals(right)) ? true : null;\n-            }\n-\n-            return left || right;\n-        }\n-    };\n-\n-\n-    protected abstract Boolean doComparison(Boolean left, Boolean right);\n-\n-    protected SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n-                                            MessageImpl message) throws SelectorEvaluationException {\n-        if (SelectorConstant.SelectorDataType.BOOLEAN != left.type ||\n-            SelectorConstant.SelectorDataType.BOOLEAN != right.type) {\n-            throw new SelectorEvaluationException(getClass() + \" Invalid value type ? \" + left + \", \" + right);\n-        }\n-\n-        return new SelectorConstant(doComparison(left.getBoolValue(), right.getBoolValue()));\n-    }\n-\n-    @Override\n-    public String toString(){\n-        return getClass().getName();\n-    }\n-}"},{"sha":"b23b3e105915515c883f048aa5e43c87d3fca609","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java","status":"removed","additions":0,"deletions":101,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,101 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Root of all nodes in the AST generated.\n- * Encapsulates state for evaluation of the ast by an interpreter.\n- */\n-public class MyNode {\n-\n-    final static Logger logger = LoggerFactory.getLogger(MyNode.class);\n-\n-    // This is se for case of constant value literals.\n-    private SelectorConstant selectorConstant;\n-\n-    // This is the actual expression to evaluate.\n-    private ExprFunction exprFunction;\n-\n-    // Called while interpreting ..\n-    public SelectorConstant getConstantValue() throws SelectorEvaluationException {\n-        if (null == selectorConstant)\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unexpected not to have evalData populated for \" + this);\n-        return selectorConstant;\n-    }\n-\n-    public void addToStringSet(String str) throws ParseException {\n-        if (null == selectorConstant) throw new ParseException(getClass() +\n-            \" Unexpected not to have evalData populated for \" + this);\n-        selectorConstant.addToStringSet(str);\n-    }\n-\n-    // Called while parsing ..\n-    public void setConstantValue(SelectorConstant selectorData) throws ParseException {\n-        if (null != this.selectorConstant)\n-            throw new ParseException(getClass() + \" Value already set ? prev : \" +\n-                this.selectorConstant + \", new : \" + selectorData);\n-\n-        if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(\"Setting constant value \" +\n-            selectorData + \" for \" + this);\n-\n-        this.selectorConstant = selectorData;\n-    }\n-\n-\n-    // Called while interpreting ..\n-    public ExprFunction getExprFunction() throws SelectorEvaluationException {\n-        if (null == exprFunction)\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unexpected not to have exprFunction populated for \" + this);\n-        return exprFunction;\n-    }\n-\n-    // Called while parsing ..\n-    public void setExprFunction(ExprFunction exprFunction) throws ParseException {\n-        if (null != this.exprFunction)\n-            throw new ParseException(getClass() + \" exprFunction already set ? prev : \" +\n-                this.exprFunction + \", new : \" + exprFunction);\n-\n-        if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(\"Setting function expr \" +\n-            exprFunction + \" for \" + this);\n-\n-        this.exprFunction = exprFunction;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"MyNode\");\n-        sb.append(\"{selectorConstant=\").append(selectorConstant);\n-        sb.append(\", exprFunction=\").append(exprFunction);\n-        sb.append('}');\n-        return sb.toString();\n-    }\n-\n-\n-\n-\n-    // Internal to the parser - DO NOT use outside !\n-    SelectorConstant getConstantValueInternal() { return selectorConstant; }\n-    ExprFunction getExprFunctionInternal() { return exprFunction; }\n-}"},{"sha":"83df4f100114a3f1372ac62d6645312ef29c2f40","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java","status":"removed","additions":0,"deletions":512,"changes":512,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,512 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-import java.util.regex.Pattern;\n-import java.util.regex.PatternSyntaxException;\n-\n-/**\n- * Handles property (and header) dereference against message evaluation (based on identifier specified).\n- */\n-public abstract class PropertyExprFunction implements ExprFunction {\n-\n-    public static class LookupExpr extends PropertyExprFunction {\n-        private final String identifier;\n-\n-        public LookupExpr(String identifier) {\n-            this.identifier = identifier;\n-        }\n-\n-        @Override\n-        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-            // No (stack) params required ...\n-\n-            SelectorConstant result = doEvaluate(state.getMessage());\n-            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": identifier '\" +\n-                identifier + \"' -> \" + result);\n-            state.getStack().push(result);\n-            return;\n-        }\n-\n-        private SelectorConstant doEvaluate(final MessageImpl message) throws SelectorEvaluationException {\n-\n-\n-            if (!message.propertyExists(identifier)) {\n-                // defaulting to String, does it matter ?\n-                return new SelectorConstant((String) null);\n-            }\n-\n-            final Object val = message.getSelectorProcessingPropertyValue(identifier);\n-\n-            if (val instanceof Byte) {\n-                return new SelectorConstant((int) (Byte) val);\n-            }\n-            if (val instanceof Short) {\n-                return new SelectorConstant((int) (Short) val);\n-            }\n-            if (val instanceof Integer) {\n-                return new SelectorConstant((Integer) val);\n-            }\n-            if (val instanceof Long) {\n-                long lval = (Long) val;\n-                if (lval >= (long) Integer.MAX_VALUE || lval <= (long) Integer.MIN_VALUE)\n-                    throw new SelectorEvaluationException(getClass() + \" long value \" + lval +\n-                        \" out of range for an int\");\n-\n-                return new SelectorConstant((int) lval);\n-            }\n-            if (val instanceof Boolean) {\n-                return new SelectorConstant((Boolean) val);\n-            }\n-            if (val instanceof Float) {\n-                return new SelectorConstant((double) (Float) val);\n-            }\n-            if (val instanceof Double) {\n-                return new SelectorConstant((Double) val);\n-            }\n-            if (val instanceof String) {\n-                return new SelectorConstant((String) val);\n-            }\n-\n-\n-            throw new SelectorEvaluationException(getClass() + \" Unable to interpret value '\" + val +\n-                \"' for identifier \" + identifier);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"LookupExpr\");\n-            sb.append(\"{identifier='\").append(identifier).append('\\'');\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    public static class IsNullExpr extends PropertyExprFunction {\n-\n-        private final boolean negate;\n-\n-        public IsNullExpr(boolean negate) {\n-            this.negate = negate;\n-        }\n-\n-        @Override\n-        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-\n-            final SelectorConstant result = doEvaluate(state);\n-            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \" -> \" + result);\n-            state.getStack().push(result);\n-        }\n-\n-        private SelectorConstant doEvaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-\n-            if (state.getStack().isEmpty())\n-                throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n-\n-            final SelectorConstant value = state.getStack().pop();\n-\n-            boolean result = value.isNull();\n-            if (negate) result = !result;\n-            return new SelectorConstant(result);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"IsNullExpr\");\n-            sb.append(\"{negate=\").append(negate);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    public static class InExpr extends PropertyExprFunction {\n-\n-        private final boolean negate;\n-\n-        public InExpr(boolean negate) {\n-            this.negate = negate;\n-        }\n-\n-        @Override\n-        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-            if (state.getStack().size() < 2)\n-                throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n-\n-            final SelectorConstant paramSet = state.getStack().pop();\n-            final SelectorConstant checkFor = state.getStack().pop();\n-\n-            final SelectorConstant result = doEvaluate(paramSet, checkFor);\n-            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": checkFor '\" +\n-                checkFor + \"', paramSet '\" + paramSet+ \"' -> \" + result);\n-\n-            state.getStack().push(result);\n-            return ;\n-\n-        }\n-\n-        private SelectorConstant doEvaluate(SelectorConstant paramSet, SelectorConstant checkFor)\n-            throws SelectorEvaluationException {\n-\n-            if (checkFor.isNull()){\n-                return new SelectorConstant((String) null);\n-            }\n-\n-            if (SelectorConstant.SelectorDataType.STRING_SET != paramSet.type) {\n-                throw new SelectorEvaluationException(getClass() + \" Expected string list, found : \" +\n-                    paramSet.type + \", for \" + paramSet);\n-            }\n-            if (SelectorConstant.SelectorDataType.STRING != checkFor.type){\n-                throw new SelectorEvaluationException(getClass() + \" Expected string , found : \" +\n-                    checkFor.type + \", for \" + checkFor);\n-            }\n-\n-            boolean result = paramSet.getStringSet().contains(checkFor.getStringValue());\n-            if (negate) result = !result;\n-            return new SelectorConstant(result);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"InExpr\");\n-            sb.append(\"{negate=\").append(negate);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    public static class LikeExpr extends PropertyExprFunction {\n-\n-        private final Pattern likePattern;\n-        private final String likePatternStr;\n-        private final boolean negate;\n-\n-        public LikeExpr(String likeExpression, String escapeCharacter, boolean negate) throws ParseException {\n-            if (null != escapeCharacter && 1 != escapeCharacter.length()) {\n-                throw new ParseException(getClass() + \" Escape character must be a single character : '\" +\n-                    escapeCharacter + \"'\");\n-            }\n-            this.likePatternStr = generateRegexpPattern(likeExpression, escapeCharacter);\n-            try {\n-                this.likePattern = Pattern.compile(this.likePatternStr, Pattern.DOTALL);\n-            } catch (PatternSyntaxException psEx){\n-                throw new ParseException(LikeExpr.class + \" Unable to compile '\" + likeExpression +\n-                    \"' into regexp Pattern using '\" + this.likePatternStr+ \"'\");\n-            }\n-            this.negate = negate;\n-        }\n-\n-        private static String generateRegexpWithoutWildcard(final String expression){\n-            int indxOffset = 0;\n-            int substringOffset = 0;\n-            StringBuilder sb = new StringBuilder();\n-            while (indxOffset < expression.length()){\n-                final int indxUnder = expression.indexOf('_', indxOffset);\n-                final int indxMod = expression.indexOf('%', indxOffset);\n-                if (-1 == indxUnder && -1 == indxMod) break;\n-\n-                final int indx;\n-\n-                if (-1 != indxUnder && -1 != indxMod) indx = Math.min(indxUnder, indxMod);\n-                else if (-1 != indxUnder) indx = indxUnder;\n-                else indx = indxMod;\n-\n-                if (indx != substringOffset) {\n-                    sb.append(Pattern.quote(expression.substring(substringOffset, indx)));\n-                }\n-                sb.append(indx == indxUnder ? \".\" : \".*\");\n-                substringOffset = indx + 1;\n-                indxOffset = indx + 1;\n-            }\n-            if (expression.length() != substringOffset) {\n-                sb.append(Pattern.quote(expression.substring(substringOffset)));\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        // If wildcard if prefixed with escapeChar, ignore it.\n-        private static String generateRegexpWithWildcard(final String expression, char escapeChar){\n-            int indxOffset = 0;\n-            int substringOffset = 0;\n-            StringBuilder sb = new StringBuilder();\n-            while (indxOffset < expression.length()){\n-                final int indxUnder = expression.indexOf('_', indxOffset);\n-                final int indxMod = expression.indexOf('%', indxOffset);\n-                if (-1 == indxUnder && -1 == indxMod) break;\n-\n-                final int indx;\n-\n-                if (-1 != indxUnder && -1 != indxMod) indx = Math.min(indxUnder, indxMod);\n-                else if (-1 != indxUnder) indx = indxUnder;\n-                else indx = indxMod;\n-\n-                if (indx > 0 && escapeChar == expression.charAt(indx - 1)) {\n-                    // ignore it.\n-                    indxOffset = indx + 1;\n-                    continue;\n-                }\n-\n-                if (indx != substringOffset) {\n-                    sb.append(Pattern.quote(expression.substring(substringOffset, indx)));\n-                }\n-                sb.append(indx == indxUnder ? \".\" : \".*\");\n-                substringOffset = indx + 1;\n-                indxOffset = indx + 1;\n-            }\n-            if (expression.length() != substringOffset) {\n-                sb.append(Pattern.quote(expression.substring(substringOffset)));\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        private static String generateRegexpPattern(final String likeExpression,\n-                                                    final String escapeCharacterStr) throws ParseException {\n-\n-            if (null == escapeCharacterStr){\n-                // Ok, hand-generating the pattern seems to be the only generic way to handle this, sigh :-(\n-\n-                String rpat = generateRegexpWithoutWildcard(likeExpression);\n-                return rpat;\n-            }\n-\n-            // expect this to be there ...\n-            final char escapeChar = escapeCharacterStr.charAt(0);\n-\n-            // Test when escapeChar == ']', '[' and '^'. done !\n-            String rpat = generateRegexpWithWildcard(likeExpression, escapeChar);\n-\n-            rpat = rpat.replace(escapeChar + \"%\", \"%\");\n-            rpat = rpat.replace(escapeChar + \"_\", \"_\");\n-\n-            return rpat;\n-        }\n-\n-        @Override\n-        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-\n-            if (state.getStack().isEmpty()) throw new SelectorEvaluationException(getClass() +\n-                \" stack corruption ? \" + state.getStack());\n-\n-            final SelectorConstant checkFor = state.getStack().pop();\n-\n-            final SelectorConstant result = doEvaluate(checkFor);\n-            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": checkFor '\" +\n-                checkFor + \"' -> \" + result);\n-\n-            state.getStack().push(result);\n-            return ;\n-        }\n-\n-        private SelectorConstant doEvaluate(SelectorConstant checkFor) throws SelectorEvaluationException {\n-            if (checkFor.isNull()){\n-                return new SelectorConstant((String) null);\n-            }\n-\n-            if (SelectorConstant.SelectorDataType.STRING != checkFor.type){\n-                throw new SelectorEvaluationException(getClass() + \" Expected string , found : \" +\n-                    checkFor.type + \", for \" + checkFor);\n-            }\n-\n-\n-            final String value = checkFor.getStringValue();\n-\n-            if (null == value) {\n-                return new SelectorConstant((Boolean) null);\n-            }\n-\n-            boolean result = likePattern.matcher(value).matches();\n-            if (negate) result = !result;\n-            return new SelectorConstant(result);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"LikeExpr\");\n-            sb.append(\"{likePatternStr=\").append(likePatternStr);\n-            sb.append(\", negate=\").append(negate);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-\n-    public static class BetweenExpr extends PropertyExprFunction {\n-\n-        private final boolean negate;\n-\n-        public BetweenExpr(boolean negate) {\n-            this.negate = negate;\n-        }\n-\n-        @Override\n-        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-            if (state.getStack().size() < 3){\n-                throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n-            }\n-\n-            final SelectorConstant right = state.getStack().pop();\n-            final SelectorConstant left = state.getStack().pop();\n-\n-            final SelectorConstant checkFor = state.getStack().pop();\n-\n-            final SelectorConstant result = doEvaluate(checkFor, left, right);\n-            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": left '\" + left +\n-                \"', right '\" + right + \"', checkFor '\" + checkFor + \"' -> \" + result);\n-            state.getStack().push(result);\n-        }\n-\n-        private SelectorConstant doEvaluate(final SelectorConstant checkFor, final SelectorConstant left,\n-                                            final SelectorConstant right) throws SelectorEvaluationException {\n-\n-            if (left.isNull() || right.isNull()) {\n-                // Unexpected for a bound to be null ...\n-                throw new SelectorEvaluationException(getClass() + \" Unexpected for left or right bound to be null \" +\n-                    left + \", \" + right);\n-            }\n-\n-            if (checkFor.isNull()){\n-                // If checkFor is null, then it cant be between anyway - return unknown.\n-                return new SelectorConstant((Boolean) null);\n-            }\n-\n-            final Boolean result;\n-\n-            // Between left and right ...\n-            switch (left.type) {\n-                case INT: {\n-                    switch (right.type) {\n-                        case INT: {\n-                            result = handleBetweenIntAndInt(checkFor, left.getIntValue(),\n-                                right.getIntValue());\n-                            break;\n-                        }\n-                        case DOUBLE: {\n-                            result = handleBetweenIntAndDouble(checkFor, left.getIntValue(),\n-                                right.getDoubleValue());\n-                            break;\n-                        }\n-                        default:\n-                            throw new SelectorEvaluationException(getClass() + \" Unsupported type for right \" +\n-                                right.type);\n-                    }\n-                    break;\n-                }\n-                case DOUBLE: {\n-                    switch (right.type) {\n-                        case INT: {\n-                            result = handleBetweenIntAndDouble(checkFor, right.getIntValue(),\n-                                left.getDoubleValue());\n-                            break;\n-                        }\n-                        case DOUBLE: {\n-                            result = handleBetweenDoubleAndDouble(checkFor, left.getDoubleValue(),\n-                                right.getDoubleValue());\n-                            break;\n-                        }\n-                        default:\n-                            throw new SelectorEvaluationException(getClass() +\n-                                \" Unsupported type for right \" + right.type);\n-                    }\n-                    break;\n-                }\n-                default:\n-                    throw new SelectorEvaluationException(getClass() + \" Unsupported type for left \" + right.type);\n-            }\n-\n-            if (null == result) {\n-                // Cannot find the result as the type we expected.\n-                return new SelectorConstant((Boolean) null);\n-            }\n-\n-\n-            return new SelectorConstant(negate ? !result : result);\n-        }\n-\n-        private Boolean handleBetweenIntAndInt(SelectorConstant checkFor, int intBound,\n-                                               int otherIntBound) throws SelectorEvaluationException {\n-            final int low = Math.min(intBound, otherIntBound);\n-            final int high = Math.max(intBound, otherIntBound);\n-\n-            assert ! checkFor.isNull();\n-\n-\n-            switch (checkFor.type){\n-                case INT:\n-                    return checkFor.getIntValue() >= low && checkFor.getIntValue() <= high;\n-                case DOUBLE:\n-                    return checkFor.getDoubleValue() >= low && checkFor.getDoubleValue() <= high;\n-                default:\n-                    throw new SelectorEvaluationException(getClass() +\n-                        \" Identifier value is of illegal type \" + checkFor.type + \" ... \" + checkFor);\n-            }\n-        }\n-\n-        private Boolean handleBetweenIntAndDouble(SelectorConstant checkFor, int intBound,\n-                                                  double doubleBound) throws SelectorEvaluationException {\n-            final double low = Math.min((double) intBound, doubleBound);\n-            final double high = Math.max((double) intBound, doubleBound);\n-\n-            assert ! checkFor.isNull();\n-\n-\n-            switch (checkFor.type){\n-                case INT:\n-                    return checkFor.getIntValue() >= low && checkFor.getIntValue() <= high;\n-                case DOUBLE:\n-                    return checkFor.getDoubleValue() >= low && checkFor.getDoubleValue() <= high;\n-                default:\n-                    throw new SelectorEvaluationException(getClass() +\n-                        \" Identifier value is of illegal type \" + checkFor.type + \" ... \" + checkFor);\n-            }\n-        }\n-\n-        private Boolean handleBetweenDoubleAndDouble(SelectorConstant checkFor, double doubleBound,\n-                                                     double otherDoubleBound) throws SelectorEvaluationException {\n-            final double low = Math.min(doubleBound, otherDoubleBound);\n-            final double high = Math.max(doubleBound, otherDoubleBound);\n-\n-            assert ! checkFor.isNull();\n-\n-\n-            switch (checkFor.type){\n-                case INT:\n-                    return checkFor.getIntValue() >= low && checkFor.getIntValue() <= high;\n-                case DOUBLE:\n-                    return checkFor.getDoubleValue() >= low && checkFor.getDoubleValue() <= high;\n-                default:\n-                    throw new SelectorEvaluationException(getClass() +\n-                        \" Identifier value is of illegal type \" + checkFor.type + \" ... \" + checkFor);\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"BetweenExpr\");\n-            sb.append(\"{negate=\").append(negate);\n-            sb.append('}');\n-            return sb.toString();\n-        }\n-    }\n-}\n\\ No newline at end of file"},{"sha":"e4af1c75d8ec6b47fa81432de654f7a240708a7f","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java","status":"removed","additions":0,"deletions":187,"changes":187,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,187 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import java.util.Collections;\n-import java.util.Set;\n-\n-/**\n- * A constant in the AST ends up getting pushed into the stack as this.\n- */\n-public class SelectorConstant {\n-\n-    public enum SelectorDataType {BOOLEAN, INT, DOUBLE, STRING, STRING_SET}\n-\n-    public final SelectorDataType type;\n-\n-    private final Boolean boolValue;\n-    private final Integer intValue;\n-    private final Double doubleValue;\n-    private final String stringValue;\n-\n-    private final Set<String> stringSet;\n-\n-    public SelectorConstant(Boolean boolValue) {\n-        this.type = SelectorDataType.BOOLEAN;\n-        this.boolValue = boolValue;\n-        this.intValue = null;\n-        this.doubleValue = null;\n-        this.stringValue = null;\n-        this.stringSet = null;\n-    }\n-\n-    public SelectorConstant(Integer intValue) {\n-        this.type = SelectorDataType.INT;\n-        this.boolValue = null;\n-        this.intValue = intValue;\n-        this.doubleValue = null;\n-        this.stringValue = null;\n-        this.stringSet = null;\n-    }\n-\n-    public SelectorConstant(Double doubleValue) {\n-        this.type = SelectorDataType.DOUBLE;\n-        this.boolValue = null;\n-        this.intValue = null;\n-        this.doubleValue = doubleValue;\n-        this.stringValue = null;\n-        this.stringSet = null;\n-    }\n-\n-    public SelectorConstant(String stringValue) {\n-        this.type = SelectorDataType.STRING;\n-        this.boolValue = null;\n-        this.intValue = null;\n-        this.doubleValue = null;\n-        this.stringValue = stringValue;\n-        this.stringSet = null;\n-    }\n-\n-    public SelectorConstant(Set<String> stringSet) {\n-        this.type = SelectorDataType.STRING_SET;\n-        this.boolValue = null;\n-        this.intValue = null;\n-        this.doubleValue = null;\n-        this.stringValue = null;\n-        this.stringSet = stringSet;\n-    }\n-\n-    public void addToStringSet(String value) throws ParseException {\n-        if (SelectorDataType.STRING_SET != type)\n-            throw new ParseException(getClass() + \" Attempting to add to a non-string_list type : \" + type);\n-        if (null == this.stringSet) throw new ParseException(getClass() +\n-            \" Attempting to add to a null string_list : \" + stringSet);\n-        this.stringSet.add(value);\n-    }\n-\n-    public boolean isNull() {\n-        switch (type) {\n-            case BOOLEAN:\n-                return null == boolValue;\n-            case INT:\n-                return null == intValue;\n-            case DOUBLE:\n-                return null == doubleValue;\n-            case STRING:\n-                return null == stringValue;\n-            case STRING_SET:\n-                return null == stringSet;\n-            default:\n-                throw new IllegalStateException(getClass() + \" Unknown type ? \" + type);\n-        }\n-    }\n-\n-    public boolean isTrue() throws SelectorEvaluationException {\n-        switch (type) {\n-            case BOOLEAN:\n-                return null != boolValue && Boolean.TRUE.equals(boolValue);\n-            default:\n-                throw new SelectorEvaluationException(getClass() + \" Unexpected type \" + type +\n-                    \", value \" + getValueAsString());\n-        }\n-    }\n-\n-    public String getValueAsString() throws SelectorEvaluationException {\n-        switch (type) {\n-            case BOOLEAN:\n-                return Boolean.toString(boolValue);\n-            case INT:\n-                return Integer.toString(intValue);\n-            case DOUBLE:\n-                return Double.toString(doubleValue);\n-            case STRING:\n-                return stringValue;\n-            case STRING_SET:\n-                return null != stringSet ? stringSet.toString() : \"null\";\n-            default:\n-                throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" + type);\n-        }\n-    }\n-\n-    public String toString() {\n-        try {\n-            switch (type) {\n-                case BOOLEAN:\n-                    return \"boolean : \" + getValueAsString();\n-                case INT:\n-                    return \"int : \" + getValueAsString();\n-                case DOUBLE:\n-                    return \"double : \" + getValueAsString();\n-                case STRING:\n-                    return \"string : \" + getValueAsString();\n-                case STRING_SET:\n-                    return \"string_list : \" + getValueAsString();\n-                default:\n-                    throw new IllegalStateException(getClass() + \" Unexpected type\");\n-            }\n-        } catch (SelectorEvaluationException seEx) {\n-            throw new IllegalStateException(getClass() + \" Unexpected exception\", seEx);\n-        }\n-    }\n-\n-    public Boolean getBoolValue() throws SelectorEvaluationException {\n-        if (SelectorDataType.BOOLEAN != type)\n-            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n-        return boolValue;\n-    }\n-\n-    public Integer getIntValue() throws SelectorEvaluationException {\n-        if (SelectorDataType.INT != type)\n-            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n-        return intValue;\n-    }\n-\n-    public Double getDoubleValue() throws SelectorEvaluationException {\n-        if (SelectorDataType.DOUBLE != type)\n-            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n-        return doubleValue;\n-    }\n-\n-    public String getStringValue() throws SelectorEvaluationException {\n-        if (SelectorDataType.STRING != type)\n-            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n-        return stringValue;\n-    }\n-\n-    public Set<String> getStringSet() throws SelectorEvaluationException {\n-        if (SelectorDataType.STRING_SET != type)\n-            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n-        // wrap to prevent changes ...\n-        return Collections.unmodifiableSet(stringSet);\n-    }\n-}"},{"sha":"d760e0c8c69830d916de7f962f914c7c335211d6","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,56 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-\n-/**\n- * Holds (any) state data required to evaluate a Selector.\n- */\n-public class SelectorEvalState {\n-    private final MessageImpl message;\n-    private final Deque<SelectorConstant> stack;\n-\n-    // Used ONLY for debugging ... it is sad that this is part of SelectorEvalState - but I dont\n-    // have time to do anything else right now !\n-    private int debugIndentCount = 0;\n-\n-    public SelectorEvalState(MessageImpl message) {\n-        this.message = message;\n-        this.stack = new ArrayDeque<SelectorConstant>(32);\n-    }\n-\n-    public MessageImpl getMessage() {\n-        return message;\n-    }\n-\n-    public Deque<SelectorConstant> getStack() {\n-        return stack;\n-    }\n-\n-    public int getDebugIndentCount() {\n-        return debugIndentCount;\n-    }\n-\n-    public void setDebugIndentCount(int debugIndentCount) {\n-        this.debugIndentCount = debugIndentCount;\n-    }\n-}"},{"sha":"7425189e99231bda7410d68e438f007e66f5bad2","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,39 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-/**\n- * Thrown when evaluating a selector.\n- */\n-public class SelectorEvaluationException extends Exception {\n-\n-    public SelectorEvaluationException() {\n-    }\n-\n-    public SelectorEvaluationException(String message) {\n-        super(message);\n-    }\n-\n-    public SelectorEvaluationException(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-\n-    public SelectorEvaluationException(Throwable cause) {\n-        super(cause);\n-    }\n-}"},{"sha":"dedda05f4d77f6ccd9505c223a1e01012ce2cc57","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java","status":"removed","additions":0,"deletions":261,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,261 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-/**\n- * To dump the AST - used ONLY for debugging\n- */\n-public class TreeDumperSelectorParserVisitor implements SelectorParserVisitor{\n-\n-    private static final int INDENT_PER_LEVEL = 4;\n-\n-    private static void emitDebug(SimpleNode node, SelectorEvalState data, boolean start)\n-        throws SelectorEvaluationException {\n-\n-        if (!start && 0 == node.jjtGetNumChildren()) return ;\n-\n-        final StringBuilder sb = new StringBuilder();\n-        int count = data.getDebugIndentCount();\n-        for (int i = 0;i < count * INDENT_PER_LEVEL; i ++){\n-            sb.append(' ');\n-        }\n-\n-        sb.append(node.getClass().getName()).append(\" -> \").append(node);\n-        sb.append(\", Constant -> \").append(node.getConstantValueInternal());\n-        sb.append(\", Func -> \").append(node.getExprFunctionInternal());\n-        if (0 != node.jjtGetNumChildren()) sb.append(start ? \" OPEN\" : \" CLOSE\");\n-\n-        MyNode.logger.trace(sb.toString());\n-    }\n-\n-    @Override\n-    public Object visit(SimpleNode node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTOrExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTAndExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTNotExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTGreaterThan node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLessThan node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLessThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTGreaterThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTNotEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTIsNullExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTBetweenExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTInExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLikeExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTAddExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTSubExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTDivideExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTMultiplyExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTNegateExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTLookupExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n-        node.childrenAccept(this, data);\n-        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n-        emitDebug(node, data, false);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTConstant node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n-            \" parse error ? \" + node);\n-        return null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTStringVarargParams node, SelectorEvalState data) throws SelectorEvaluationException {\n-        emitDebug(node, data, true);\n-        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n-            \" parse error ? \" + node);\n-        return null;\n-    }\n-}"},{"sha":"59170e7944e00ad9e0fbad0c3627a133e778a213","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,73 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-/**\n- * Unary arithematic operations\n- */\n-public abstract class UnaryArithmeticFunction implements ExprFunction {\n-\n-    public static final UnaryArithmeticFunction NEGATE_FUNCTION = new UnaryArithmeticFunction() {\n-\n-        @Override\n-        protected SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n-            throws SelectorEvaluationException {\n-\n-            switch (value.type) {\n-                case INT: {\n-                    Integer val = value.getIntValue();\n-                    if (null == val) return new SelectorConstant((Integer) null);\n-                    return new SelectorConstant(-(int) val);\n-                }\n-                case DOUBLE: {\n-                    Double val = value.getDoubleValue();\n-                    if (null == val) return new SelectorConstant((Double) null);\n-                    return new SelectorConstant(-(double) val);\n-                }\n-                default:\n-                    throw new SelectorEvaluationException(getClass() + \" Invalid value type ? \" + value);\n-            }\n-        }\n-    };\n-\n-    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-        if (state.getStack().size() < 1)\n-            throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n-\n-        SelectorConstant value = state.getStack().pop();\n-\n-        SelectorConstant result = evaluateImpl(value, state.getMessage());\n-\n-        if (null != result) state.getStack().push(result);\n-        else\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unexpected to return a null response in binary function evaluation\");\n-    }\n-\n-    protected abstract SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n-        throws SelectorEvaluationException;\n-\n-\n-\n-    @Override\n-    public String toString(){\n-        return getClass().getName();\n-    }\n-}"},{"sha":"c50514be715db173709a8ce9adc0158e6d453504","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,65 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-/**\n- * Unary function's.\n- */\n-public abstract class UnaryExprFunction implements ExprFunction {\n-\n-    public static final UnaryExprFunction NOT_FUNCTION = new UnaryExprFunction() {\n-\n-        @Override\n-        protected SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n-            throws SelectorEvaluationException {\n-            if (SelectorConstant.SelectorDataType.BOOLEAN != value.type) {\n-                throw new SelectorEvaluationException(getClass() + \" Invalid value type ? \" + value);\n-            }\n-\n-            final Boolean boolValue = value.getBoolValue();\n-            final Boolean result = null == boolValue ? null : !boolValue;\n-            return new SelectorConstant(result);\n-        }\n-    };\n-\n-    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n-        if (state.getStack().size() < 1)\n-            throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n-\n-        SelectorConstant value = state.getStack().pop();\n-\n-        SelectorConstant result = evaluateImpl(value, state.getMessage());\n-\n-        if (null != result) state.getStack().push(result);\n-        else\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unexpected to return a null response in binary function evaluation\");\n-    }\n-\n-    protected abstract SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n-        throws SelectorEvaluationException;\n-\n-\n-\n-    @Override\n-    public String toString(){\n-        return getClass().getName();\n-    }\n-}"},{"sha":"24957d374e1786df465588b017e02fb2dfa29bd0","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java","status":"removed","additions":0,"deletions":329,"changes":329,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,329 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.selector;\n-\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-/**\n- * Comparison of values ..\n- */\n-public abstract class ValueComparisonFunction extends BinaryExprFunction {\n-\n-    protected SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n-                                            MessageImpl message) throws SelectorEvaluationException {\n-\n-        switch (left.type) {\n-            case INT: {\n-                switch (right.type) {\n-                    case INT:\n-                        return new SelectorConstant(compareWithInt(left.getIntValue(), right.getIntValue()));\n-                    case DOUBLE:\n-                        return new SelectorConstant(compareWithInt(left.getIntValue(), right.getDoubleValue()));\n-                    default:\n-                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n-                            right.type + \". left : \" + left + \", right : \" + right);\n-                }\n-            }\n-            case DOUBLE: {\n-                switch (right.type) {\n-                    case INT:\n-                        return new SelectorConstant(compareWithDouble(left.getDoubleValue(), right.getIntValue()));\n-                    case DOUBLE:\n-                        return new SelectorConstant(compareWithDouble(left.getDoubleValue(), right.getDoubleValue()));\n-                    default:\n-                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n-                            right.type + \". left : \" + left + \", right : \" + right);\n-                }\n-            }\n-            case BOOLEAN: {\n-                switch (right.type) {\n-                    case BOOLEAN:\n-                        return new SelectorConstant(compareWithBoolean(left.getBoolValue(), right.getBoolValue()));\n-                    default:\n-                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n-                            right.type + \". left : \" + left + \", right : \" + right);\n-                }\n-            }\n-\n-            case STRING: {\n-                switch (right.type) {\n-                    case STRING:\n-                        return new SelectorConstant(compareWithString(left.getStringValue(), right.getStringValue()));\n-                    default:\n-                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n-                            right.type + \". left : \" + left + \", right : \" + right);\n-                }\n-            }\n-\n-            default:\n-                throw new SelectorEvaluationException(getClass() + \" Unsupported type : \" +\n-                    left.type + \". left : \" + left + \", right : \" + right);\n-        }\n-    }\n-\n-    protected abstract Boolean compareWithInt(Integer left, Double right) throws SelectorEvaluationException;\n-\n-    protected abstract Boolean compareWithInt(Integer left, Integer right) throws SelectorEvaluationException;\n-\n-    protected abstract Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException;\n-\n-    protected abstract Boolean compareWithDouble(Double left, Integer right) throws SelectorEvaluationException;\n-\n-    protected abstract Boolean compareWithString(String left, String right) throws SelectorEvaluationException;\n-\n-    protected abstract Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException;\n-\n-\n-    public static final ValueComparisonFunction GREATER_THAN_FUNCTION = new ValueComparisonFunction() {\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Double right) {\n-            if (null == left || null == right) return null;\n-            return (double) left > right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left > right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left > right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left > (double) right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass()\n-                    + \" Unsupported string comparison for greater_than operator\");\n-        }\n-\n-        @Override\n-        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass()\n-                    + \" Unsupported boolean comparison for greater_than operator\");\n-        }\n-    };\n-\n-\n-    public static final ValueComparisonFunction GREATER_THAN_EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Double right) {\n-            if (null == left || null == right) return null;\n-            return (double) left >= right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left >= right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left >= right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left >= (double) right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unsupported string comparison for greater_than operator\");\n-        }\n-\n-        @Override\n-        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unsupported boolean comparison for greater_than operator\");\n-        }\n-    };\n-\n-    public static final ValueComparisonFunction LESS_THAN_FUNCTION = new ValueComparisonFunction() {\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Double right) {\n-            if (null == left || null == right) return null;\n-            return (double) left < right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left < right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left < right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left < (double) right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unsupported string comparison for greater_than operator\");\n-        }\n-\n-        @Override\n-        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unsupported boolean comparison for greater_than operator\");\n-        }\n-    };\n-\n-\n-    public static final ValueComparisonFunction LESS_THAN_EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Double right) {\n-            if (null == left || null == right) return null;\n-            return (double) left <= right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left <= right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left <= right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left <= (double) right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unsupported string comparison for greater_than operator\");\n-        }\n-\n-        @Override\n-        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n-            throw new SelectorEvaluationException(getClass() +\n-                \" Unsupported boolean comparison for greater_than operator\");\n-        }\n-    };\n-\n-    public static final ValueComparisonFunction EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Double right) {\n-            if (null == left || null == right) return null;\n-            return (double) left == right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return (int) left == right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return (double) left == right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left == (double) right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left.equals(right);\n-        }\n-\n-        @Override\n-        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return left.equals(right);\n-        }\n-    };\n-\n-\n-    public static final ValueComparisonFunction NOT_EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Double right) {\n-            if (null == left || null == right) return null;\n-            return (double) left != right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithInt(Integer left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return (int) left != right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return (double) left != right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithDouble(Double left, Integer right) {\n-            if (null == left || null == right) return null;\n-            return left != (double) right;\n-        }\n-\n-        @Override\n-        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return !left.equals(right);\n-        }\n-\n-        @Override\n-        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n-            if (null == left || null == right) return null;\n-            return !left.equals(right);\n-        }\n-    };\n-\n-\n-\n-    @Override\n-    public String toString(){\n-        return getClass().getName();\n-    }\n-}"},{"sha":"e426eb84cad68b42b5917c5fa703eaac11cb9ef0","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html","status":"removed","additions":0,"deletions":35,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,35 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-\n-Contains implementation of the selector, associated files and interpreter. <br/>\n-This depends on files generated by the grammar at $HEDWIG_CLIENT_JMS/src/main/grammar/javacc/selector_grammar.jjt <br/>\n-<p/>\n-This package depends on message package to pull headers, etc. <br/>\n-<p/>\n-<p/>\n-The code essentially is split into three things :\n-<ul>\n-  <li>Basic implementation of the selector, interpreter and grammar interface code : split between this\n-    package and the generated package (of same name).</li>\n-  <li>State objects, visitor implementation, etc to help evaluate the generated AST based on the message.\n-    MyNode, SelectorConstant, SelectorEvalState, etc.</li>\n-  <li>The functions to evaluate and implement functionality - expose constructs to interpreter to evaluate.\n-    *Function classes.</li>\n-</ul>\n-\n-The code relies heavily on the javacc grammar and the interpreter generated based on it : so please modify with care !"},{"sha":"6ef09704fe04086f8d63175dff6a80c66bbcae82","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java","status":"removed","additions":0,"deletions":64,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,64 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import javax.jms.Connection;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.JMSException;\n-import javax.jms.TopicConnection;\n-import javax.jms.TopicConnectionFactory;\n-import javax.naming.NamingException;\n-import javax.naming.Reference;\n-import javax.naming.Referenceable;\n-import java.io.Serializable;\n-\n-/**\n- * Implementation of jmx ConnectionFactory\n- * MUST be MT-safe (2.8)\n- */\n-public class HedwigConnectionFactoryImpl implements ConnectionFactory, TopicConnectionFactory,\n-    Referenceable, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    @Override\n-    public HedwigConnectionImpl createConnection() throws JMSException {\n-        HedwigConnectionImpl retval = new HedwigConnectionImpl();\n-        return retval;\n-    }\n-\n-    @Override\n-    public HedwigConnectionImpl createConnection(String user, String password) throws JMSException {\n-        HedwigConnectionImpl retval = new HedwigConnectionImpl(user, password);\n-        return retval;\n-    }\n-\n-    @Override\n-    public Reference getReference() throws NamingException {\n-        return new Reference(getClass().getName());\n-    }\n-\n-    @Override\n-    public TopicConnection createTopicConnection() throws JMSException {\n-        return new HedwigConnectionImpl();\n-    }\n-\n-    @Override\n-    public TopicConnection createTopicConnection(String user, String password) throws JMSException {\n-        return new HedwigConnectionImpl(user, password);\n-    }\n-}"},{"sha":"98f4273c6715040f358c35df6036ccfa359ce639","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java","status":"removed","additions":0,"deletions":164,"changes":164,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,164 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.commons.configuration.ConfigurationException;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.jms.ConnectionImpl;\n-import org.apache.hedwig.jms.MessagingSessionFacade;\n-import org.apache.hedwig.jms.SessionImpl;\n-\n-import javax.jms.JMSException;\n-import java.io.File;\n-import java.io.IOException;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.net.URLStreamHandler;\n-\n-/**\n- * Returns the hedwig specific functionality of the Connection - which is tied to this spi impl.\n- * Coupled with HedwigMessagingSessionFacade.\n- *\n- */\n-public class HedwigConnectionImpl extends ConnectionImpl {\n-\n-    private ClientConfiguration hedwigClientConfig;\n-\n-    public HedwigConnectionImpl() throws JMSException {\n-        super();\n-        init(getUser(), getPassword());\n-    }\n-\n-    public HedwigConnectionImpl(String user, String password) throws JMSException {\n-        super (user, password);\n-        init(getUser(), getPassword());\n-    }\n-\n-    @Override\n-    protected SessionImpl createSessionInstance(boolean transacted, int acknowledgeMode,\n-                                                MessagingSessionFacade.DestinationType type) throws JMSException {\n-        if (null == type) return new SessionImpl(this, transacted, acknowledgeMode);\n-        switch (type){\n-            case QUEUE:\n-                return new QueueSessionImpl(this, transacted, acknowledgeMode);\n-            case TOPIC:\n-                return new TopicSessionImpl(this, transacted, acknowledgeMode);\n-            default:\n-                throw new JMSException(\"Unknown type \" + type);\n-        }\n-    }\n-\n-    @Override\n-    protected void doStart(String user, String password) throws JMSException {\n-        // noop for now ...\n-    }\n-\n-    protected void init(String user, String password) throws JMSException {\n-        // load to check sanity.\n-        hedwigClientConfig = loadConfig();\n-\n-        // TODO: Set configuration options specified by the user of api - user/passwd/etc.\n-    }\n-\n-    // copied from earlier code ...\n-    private ClientConfiguration loadConfig() throws JMSException {\n-        ClientConfiguration config = new ClientConfiguration();\n-\n-        // TODO: This is not very extensible and useful ... we need to pick the info from\n-        // configuration specified by user, NOT only from static files !\n-        // Also, we need to be able to support multiple configuration in a single client !\n-        // We need a better solution ....\n-\n-        try {\n-            // 1. try to load the client configuration as specified from a\n-            // system property\n-            if (System.getProperty(HEDWIG_CLIENT_CONFIG_FILE) != null) {\n-                File configFile = new File(System.getProperty(HEDWIG_CLIENT_CONFIG_FILE));\n-                if (!configFile.exists()) {\n-                    throw new JMSException(\n-                            \"Cannot create connection: cannot find Hedwig client configuration file specified as [\"\n-                                    + System.getProperty(HEDWIG_CLIENT_CONFIG_FILE) + \"]\");\n-                }\n-                config.loadConf(configFile.toURI().toURL());\n-            } else {\n-                // 2. try to load a \"hedwig-client.cfg\" file from the classpath\n-                config.loadConf(new URL(null, \"classpath://hedwig-client.cfg\", new URLStreamHandler() {\n-                    protected URLConnection openConnection(URL u) throws IOException {\n-                        // rely on the relevant classloader - not system classloader.\n-                        final URL resourceUrl = HedwigConnectionImpl.this.getClass().getClassLoader().\n-                            getResource(u.getPath());\n-                        return resourceUrl.openConnection();\n-                    }\n-                }));\n-            }\n-\n-        } catch (MalformedURLException e) {\n-            JMSException je = new JMSException(\"Cannot load Hedwig client configuration file \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (ConfigurationException e) {\n-            JMSException je = new JMSException(\"Cannot load Hedwig client configuration \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        }\n-\n-        /*\n-        System.out.println(\"getConsumedMessagesBufferSize : \" + config.getConsumedMessagesBufferSize());\n-        System.out.println(\"getDefaultServerHost : \" + config.getDefaultServerHost());\n-        System.out.println(\"isSSLEnabled : \" + config.isSSLEnabled());\n-        System.out.println(\"getMaximumMessageSize : \" + config.getMaximumMessageSize());\n-        System.out.println(\"getMaximumOutstandingMessages : \" + config.getMaximumOutstandingMessages());\n-        System.out.println(\"getMaximumServerRedirects : \"  + config.getMaximumServerRedirects());\n-        System.out.println(\"getServerAckResponseTimeout : \"  + config.getServerAckResponseTimeout());\n-        */\n-\n-        return config;\n-    }\n-\n-    public ClientConfiguration getHedwigClientConfig() {\n-        return hedwigClientConfig;\n-    }\n-\n-    @Override\n-    protected void doStop() {\n-        // nothing specific to be done.\n-    }\n-\n-    @Override\n-    protected void doClose(){\n-        // nothing specific to be done.\n-    }\n-\n-    @Override\n-    protected MessagingSessionFacade createMessagingSessionFacade(SessionImpl session) throws JMSException {\n-        return new HedwigMessagingSessionFacade(this, session);\n-    }\n-\n-    @Override\n-    public TopicSessionImpl createTopicSession(boolean transacted, int acknowledgeMode) throws JMSException {\n-        return (TopicSessionImpl) createSessionImpl(transacted, acknowledgeMode,\n-            MessagingSessionFacade.DestinationType.TOPIC);\n-    }\n-\n-    @Override\n-    public QueueSessionImpl createQueueSession(boolean transacted, int acknowledgeMode) throws JMSException {\n-        return (QueueSessionImpl) createSessionImpl(transacted, acknowledgeMode,\n-            MessagingSessionFacade.DestinationType.QUEUE);\n-    }\n-}"},{"sha":"4c23d5ce7b72a9f1aec221a916b485f2b0bbc560","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java","status":"removed","additions":0,"deletions":624,"changes":624,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,624 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.client.HedwigClient;\n-import org.apache.hedwig.client.api.MessageHandler;\n-import org.apache.hedwig.client.api.Publisher;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n-import org.apache.hedwig.client.exceptions.InvalidSubscriberIdException;\n-import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.jms.MessagingSessionFacade;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.DebugUtil;\n-import org.apache.hedwig.jms.message.MessageImpl;\n-import org.apache.hedwig.jms.message.MessageUtil;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n-import org.apache.hedwig.util.Callback;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.MessageConsumer;\n-import javax.jms.Queue;\n-import javax.jms.QueueBrowser;\n-import javax.jms.QueueReceiver;\n-import javax.jms.QueueSender;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.Topic;\n-import javax.jms.TopicPublisher;\n-import javax.jms.TopicSubscriber;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Set;\n-\n-/**\n- * Implementation of hedwig specific implementation. <br/>\n- * JMS VIOLATION: This implementation creates a single backend hedwig connection PER session - and\n- * DOES NOT share multiple sessoins on top of a single connection.\n- * <p/>\n- * This is a wilful violation of JMS specification, but exists only because Hedwig does not have\n- * any notion to support this. <br/>\n- * Once hedwig does allow for session multiplexing, we will need to revisit this (or create a new impl)\n- * to take into account the changes.\n- *\n- */\n-public class HedwigMessagingSessionFacade implements MessagingSessionFacade, MessageHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(HedwigMessagingSessionFacade.class);\n-\n-            // We simulate noLocal through the connection - which will be shared across sessions.\n-    private final HedwigConnectionImpl connection;\n-    private final SessionImpl session;\n-    private HedwigClient hedwigClient;\n-    private volatile boolean stopped = false;\n-\n-    /*\n-     Hedwig server has a ack-until-N approach to acknoledgements : that is, if we acknowledge message N,\n-     all previous N-1 message are also\n-     acknowledged.\n-     But hedwig-client DOES NOT support this : particularly in context of throttling.\n-\n-     So, when we are in CLIENT_ACKNOWLEDGE mode and NOT in transacted session, I am modifying the behavior\n-     to mirror expectation of both\n-     hedwig client and server here in SessionImpl itself (instead of facade where this probably belong better).\n-\n-     This approach does not seem to work fine due to implicit assumptions in hedwig client ... I am\n-     modifying it in following way :\n-     a) For each message receieved, maintain it in List.\n-     b) Acknowledging a message means traversing this list to find message with same seq-id : and\n-     acknowledge ALL message until that in the list.\n-     Since hedwig does ack until, inctead of individual ack, this violation of JMS spec is consistent with hedwig.\n-     Note that even though hedwig does ack until, hedwig client on other hand DOES NOT ! It will\n-     throttle connection if we do not ack individually ...\n-     sigh :-(\n-      */\n-    private final List<SessionImpl.ReceivedMessage> unAckMessageList = new LinkedList<SessionImpl.ReceivedMessage>();\n-\n-    // Both of these synchronized on deliveryStartInfoSet.\n-    private final Set<DeliveryStartInfo> deliveryStartInfoSet = new HashSet<DeliveryStartInfo>(32);\n-    private final Set<DeliveryStartInfo> subscribeInfoSet = new HashSet<DeliveryStartInfo>(32);\n-\n-    private static final class DeliveryStartInfo {\n-        private final String topicName;\n-        private final String subscriberId;\n-\n-        private DeliveryStartInfo(String subscriberId, String topicName) {\n-            this.subscriberId = subscriberId;\n-            this.topicName = topicName;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-\n-            DeliveryStartInfo that = (DeliveryStartInfo) o;\n-\n-            if (subscriberId != null ? !subscriberId.equals(that.subscriberId) : that.subscriberId != null)\n-                return false;\n-            if (topicName != null ? !topicName.equals(that.topicName) : that.topicName != null) return false;\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = topicName != null ? topicName.hashCode() : 0;\n-            result = 31 * result + (subscriberId != null ? subscriberId.hashCode() : 0);\n-            return result;\n-        }\n-    }\n-\n-\n-    public HedwigMessagingSessionFacade(HedwigConnectionImpl connection, SessionImpl session) throws JMSException {\n-        this.connection = connection;\n-        this.session = session;\n-        // always create client ...\n-        final ClientConfiguration cfg = connection.getHedwigClientConfig();\n-        if (null == cfg) throw new JMSException(\"Unable to fetch client config ?\");\n-        this.hedwigClient = new HedwigClient(cfg);\n-        resetStartInfoSet();\n-    }\n-\n-    @Override\n-    public void start() throws JMSException {\n-        if (!connection.isInStartMode()) throw new JMSException(\"Connection not yet started ?\");\n-        if (logger.isTraceEnabled()) logger.trace(\"Creating HedwigClient\");\n-        // create only if there is need for it.\n-        if (null == this.hedwigClient) {\n-            this.hedwigClient = new HedwigClient(connection.getHedwigClientConfig());\n-            resetStartInfoSet();\n-        }\n-        this.stopped = false;\n-    }\n-\n-    @Override\n-    public void stop() {\n-        // stopping does not inhibit send.\n-        if (logger.isTraceEnabled()) logger.trace(\"Stopping HedwigClient\");\n-        /*\n-        HedwigClient client = this.hedwigClient;\n-        this.hedwigClient = null;\n-        client.close();\n-        */\n-        this.stopped = true;\n-    }\n-\n-\n-    @Override\n-    public void close() {\n-        HedwigClient client = this.hedwigClient;\n-        resetStartInfoSet();\n-\n-        this.stopped = true;\n-        this.hedwigClient = null;\n-        if (logger.isTraceEnabled()) logger.trace(\"Closing HedwigClient\");\n-        client.close();\n-    }\n-\n-    private void resetStartInfoSet(){\n-        synchronized (deliveryStartInfoSet){\n-            deliveryStartInfoSet.clear();\n-            subscribeInfoSet.clear();\n-        }\n-    }\n-\n-    @Override\n-    public DestinationType findDestinationType(String destination) throws JMSException {\n-        // TODO: For now, we support ONLY topic's, so always returning that.\n-        return DestinationType.TOPIC;\n-    }\n-\n-    @Override\n-    public DestinationType findDestinationType(Destination destination) throws JMSException {\n-        if (destination instanceof Topic) return DestinationType.TOPIC;\n-        if (destination instanceof Queue) return DestinationType.QUEUE;\n-\n-        // TODO: For now, we support ONLY topic's, so always returning that when unknown.\n-        return DestinationType.TOPIC;\n-    }\n-\n-    @Override\n-    public TopicPublisher createTopicPublisher(Destination destination) throws JMSException {\n-        return new TopicPublisherImpl(this, session, null != destination ?\n-            session.createTopic(session.toName(destination)) : null);\n-    }\n-\n-    @Override\n-    public TopicSubscriber createTopicSubscriber(Destination destination) throws JMSException {\n-        session.subscriberCreated();\n-        connection.initConnectionClientID();\n-        return new TopicSubscriberImpl(session, session.createTopic(session.toName(destination)),\n-                session.createSubscriberId(SessionImpl.generateRandomString()), true);\n-    }\n-\n-    @Override\n-    public TopicSubscriber createTopicSubscriber(Destination destination,\n-                                                 String messageSelector, boolean noLocal) throws JMSException {\n-        session.subscriberCreated();\n-        connection.initConnectionClientID();\n-        return new TopicSubscriberImpl(session,\n-                session.createTopic(session.toName(destination)),\n-                session.createSubscriberId(SessionImpl.generateRandomString()), messageSelector, noLocal, true);\n-    }\n-\n-    @Override\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException {\n-        if (null != session.getMessageListener()) {\n-            throw new JMSException(\"Message listener is set - not other form of message receipt can be used\");\n-        }\n-        session.subscriberCreated();\n-\n-        TopicSubscriberImpl subscriber = new TopicSubscriberImpl(session, topic, subscribedId, false);\n-        subscriber.start();\n-        return subscriber;\n-    }\n-\n-    @Override\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId,\n-                                                   String messageSelector, boolean noLocal) throws JMSException {\n-        if (null != session.getMessageListener()) {\n-            throw new JMSException(\"Message listener is set - not other form of message receipt can be used\");\n-        }\n-        session.subscriberCreated();\n-        connection.initConnectionClientID();\n-\n-        return new TopicSubscriberImpl(session, topic, subscribedId, messageSelector, noLocal, false);\n-    }\n-\n-    /*\n-    @Override\n-    public void unsubscribe(String subscriberId) throws JMSException {\n-        throw new JMSException(\"Hedwig requires BOTH topic name and subscriberId to unsubscribe -\n-        unlike JMS. Need to figure this out.\");\n-    }\n-    */\n-\n-    // Note: order SENSITIVE !!\n-    @Override\n-    public void registerUnAcknowledgedMessage(SessionImpl.ReceivedMessage message) {\n-        synchronized (unAckMessageList){\n-            unAckMessageList.add(message);\n-        }\n-    }\n-\n-    @Override\n-    // public void acknowledge(String topicName, String subscriberId, String jmsMessageID)\n-    public void acknowledge(MessageImpl message) throws JMSException {\n-        if (this.stopped || null == hedwigClient)\n-          throw new javax.jms.IllegalStateException(\"session in stopped or closed state, cant acknowledge message\");\n-\n-        /*\n-         This approach does not seem to work fine due to implicit assumptions in hedwig client ...\n-         I am modifying it in following way :\n-         a) For each message receieved, maintain it in List.\n-         b) Acknowledging a message means traversing this list to find message with same seq-id :\n-         and acknowledge ALL message until that in the list.\n-         Since hedwig does ack until, inctead of individual ack, this violation of JMS spec is consistent with hedwig.\n-         Note that even though hedwig does ack until, hedwig client on other hand DOES NOT ! It will\n-          throttle connection if we do not ack individually ...\n-         sigh :-(\n-          */\n-        // sendAcknowledge(topicName, subscriberId, seqId);\n-\n-        LinkedList<SessionImpl.ReceivedMessage> ackList = new LinkedList<SessionImpl.ReceivedMessage>();\n-        synchronized (unAckMessageList){\n-            // Should I simply copy and release ?\n-            ListIterator<SessionImpl.ReceivedMessage> iter = unAckMessageList.listIterator();\n-\n-            boolean found = false;\n-            while (iter.hasNext()){\n-                if (iter.next().originalMessage.getServerJmsMessageId().equals(message.getServerJmsMessageId())){\n-                    found = true;\n-                    break;\n-                }\n-            }\n-\n-            // probably already acknowledged ?\n-            if (!found) return ;\n-            while (iter.hasPrevious()){\n-                ackList.addFirst(iter.previous());\n-                iter.remove();\n-            }\n-        }\n-\n-        // Now acknowledge the messages in ackList by running its runnable.\n-        if (logger.isTraceEnabled()) {\n-            logger.trace(\"facade acknowledge ackList (\" + ackList.size() + \") ... \" + ackList);\n-        }\n-        for (SessionImpl.ReceivedMessage msg : ackList){\n-            try {\n-                msg.originalMessage.getAckRunnable().run();\n-            } catch (Exception ex){\n-                // Ignore any exception thrown.\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Ignoring exception thrown while acknowledging messages\", ex);\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    private void sendAcknowledge(String topicName, String subscriberId, PubSubProtocol.MessageSeqId seqId)\n-        throws JMSException {\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Acknowledging \" +\n-            MessageUtil.generateJMSMessageIdFromSeqId(seqId) + \" for \" + topicName + \" by \" + subscriberId);\n-        try {\n-            hedwigClient.getSubscriber().consume(ByteString.copyFromUtf8(topicName),\n-                ByteString.copyFromUtf8(subscriberId), seqId);\n-        } catch (PubSubException.ClientNotSubscribedException e) {\n-            JMSException jEx = new JMSException(\"Client not subscribed .. \" + e);\n-            jEx.setLinkedException(e);\n-            throw jEx;\n-        }\n-    }\n-\n-\n-    public void subscribeToTopic(String topicName, String subscribedId) throws JMSException {\n-        if (null == hedwigClient)\n-          throw new javax.jms.IllegalStateException(\"session in closed state, cant subscribe to topic \" + topicName);\n-\n-        final DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n-        final boolean start;\n-        synchronized (deliveryStartInfoSet){\n-            start =  ! subscribeInfoSet.contains(info);\n-\n-            if (start) {\n-                subscribeInfoSet.add(info);\n-            }\n-        }\n-\n-        if (! start) {\n-            if (logger.isDebugEnabled()) logger.debug(\"Client already subscribed ?\");\n-            return ;\n-        }\n-\n-        try {\n-            SubscriptionOptions opts = SubscriptionOptions.newBuilder()\n-                .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();\n-            hedwigClient.getSubscriber().subscribe(ByteString.copyFromUtf8(topicName),\n-                    ByteString.copyFromUtf8(subscribedId), opts);\n-        } catch (PubSubException.CouldNotConnectException e) {\n-            JMSException je = new JMSException(\"receive failed, could not connect .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (PubSubException.ClientAlreadySubscribedException e) {\n-            JMSException je = new JMSException(\"receive failed, already subscribed .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (PubSubException.ServiceDownException e) {\n-            JMSException je = new JMSException(\"receive failed, hedwig service down .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (InvalidSubscriberIdException e) {\n-            JMSException je = new JMSException(\"receive failed, invalid subscriber .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        }\n-    }\n-\n-    public void unsubscribeFromTopic(String topicName, String subscribedId) throws JMSException {\n-        if (null == hedwigClient)\n-          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n-\n-        // Also implies removal of delivery, right ?\n-        final DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n-        synchronized (deliveryStartInfoSet){\n-            deliveryStartInfoSet.remove(info);\n-            subscribeInfoSet.remove(info);\n-        }\n-\n-        try {\n-            hedwigClient.getSubscriber().unsubscribe(ByteString.copyFromUtf8(topicName),\n-                ByteString.copyFromUtf8(subscribedId));\n-        } catch (PubSubException.CouldNotConnectException e) {\n-            JMSException je = new JMSException(\"receive failed, could not connect .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (PubSubException.ServiceDownException e) {\n-            JMSException je = new JMSException(\"receive failed, hedwig service down .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (InvalidSubscriberIdException e) {\n-            JMSException je = new JMSException(\"receive failed, invalid subscriber .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        } catch (PubSubException.ClientNotSubscribedException e) {\n-            JMSException je = new JMSException(\"receive failed, client not subscribed .. \" + e);\n-            je.setLinkedException(e);\n-            throw je;\n-        }\n-    }\n-\n-    public void stopTopicDelivery(String topicName, String subscribedId) throws JMSException {\n-        if (null == hedwigClient)\n-          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n-\n-        DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n-        synchronized (deliveryStartInfoSet){\n-            deliveryStartInfoSet.remove(info);\n-        }\n-\n-        try {\n-            hedwigClient.getSubscriber().stopDelivery(ByteString.copyFromUtf8(topicName),\n-                ByteString.copyFromUtf8(subscribedId));\n-        } catch (PubSubException.ClientNotSubscribedException e) {\n-            if (logger.isTraceEnabled()) logger.trace(\"Client not subscribed or already unsubscribed ? \", e);\n-        }\n-    }\n-\n-    public void startTopicDelivery(String topicName, String subscribedId) throws JMSException {\n-        if (null == hedwigClient)\n-          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n-\n-        final DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n-        final boolean start;\n-        synchronized (deliveryStartInfoSet){\n-            start =  ! deliveryStartInfoSet.contains(info);\n-\n-            if (start) {\n-                deliveryStartInfoSet.add(info);\n-            }\n-        }\n-\n-        if (! start) {\n-            if (logger.isDebugEnabled()) logger.debug(\"Client already started delivery ?\");\n-            return ;\n-        }\n-\n-        try {\n-            if (logger.isTraceEnabled()) logger.trace(\"Start topic delivery for \" + topicName +\n-                \", subscriberId \" + subscribedId);\n-            hedwigClient.getSubscriber().startDelivery(ByteString.copyFromUtf8(topicName),\n-                ByteString.copyFromUtf8(subscribedId), this);\n-            if (logger.isTraceEnabled()) logger.trace(\"Start topic delivery for \" + topicName +\n-                \", subscriberId \" + subscribedId + \" DONE\");\n-        } catch (PubSubException.ClientNotSubscribedException e) {\n-            if (logger.isDebugEnabled()) logger.debug(\"Client not subscribed or already unsubscribed ? \", e);\n-        } catch (AlreadyStartDeliveryException e) {\n-            if (logger.isDebugEnabled()) logger.debug(\"Client already started delivery ? \", e);\n-        }\n-    }\n-\n-    @Override\n-    public void deliver(ByteString topic, ByteString subscriberId, PubSubProtocol.Message msg,\n-                        final Callback<Void> callback, final Object context) {\n-        // Deliver the message to the session.\n-\n-        if (this.stopped) {\n-            if (logger.isDebugEnabled()) logger.debug(\"Ignoring message while in stopped mode .. topic - \" +\n-                topic.toStringUtf8() + \", subscriber - \" + subscriberId.toStringUtf8() + \", msg - \" + msg);\n-            return ;\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"recieved message from server : topic - \" +\n-                topic.toStringUtf8() + \", subscriber - \" + subscriberId.toStringUtf8() + \", msg - \" + msg);\n-\n-        // I am assuming that we can defer the acknowledgement of the message ...\n-        final String topicName = topic.toStringUtf8();\n-        final String sid = subscriberId.toStringUtf8();\n-        final PubSubProtocol.MessageSeqId seqId = msg.getMsgId();\n-        final Runnable ack = new Runnable(){\n-            public void run() {\n-                callback.operationFinished(context, null);\n-                // Only when auto-send is NOT enabled.\n-                if (! connection.getHedwigClientConfig().isAutoSendConsumeMessageEnabled()) {\n-                    try {\n-                        sendAcknowledge(topicName, sid, seqId);\n-                    } catch (JMSException e) {\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Unable to send acknowledgement ... \" + topicName + \", \" +\n-                                sid + \", seqId : \" + seqId);\n-                            DebugUtil.dumpJMSStacktrace(logger, e);\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-\n-        try {\n-            if (logger.isTraceEnabled()) logger.trace(\"Pushing to session \" + session);\n-\n-            MessageImpl messageImpl = MessageUtil.processHedwigMessage(session, msg, topicName, sid, ack);\n-            session.messageReceived(messageImpl, DestinationType.TOPIC);\n-        } catch (JMSException e) {\n-            // Unable to process the incoming message - log and ignore ?\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Unable to consume message\");\n-                DebugUtil.dumpJMSStacktrace(logger, e);\n-            }\n-        }\n-    }\n-\n-    public String getSubscriberId(TopicSubscriber topicSubscriber) throws JMSException {\n-        if (! (topicSubscriber instanceof TopicSubscriberImpl) )\n-          throw new JMSException(\"TopicSubscriber not instanceof of TopicSubscriberImpl ? \" +\n-              topicSubscriber.getClass());\n-\n-        return ((TopicSubscriberImpl) topicSubscriber).getSubscriberId();\n-    }\n-\n-    @Override\n-    public boolean enqueueReceivedMessage(MessageConsumer messageConsumer, SessionImpl.ReceivedMessage receivedMessage,\n-                                          boolean addFirst) throws JMSException {\n-        if (! (messageConsumer instanceof TopicSubscriberImpl) )\n-          throw new JMSException(\"TopicSubscriber not instanceof of TopicSubscriberImpl ? \" +\n-              messageConsumer.getClass());\n-\n-        return ((TopicSubscriberImpl) messageConsumer).enqueueReceivedMessage(receivedMessage, addFirst);\n-    }\n-\n-    public Publisher getPublisher() throws javax.jms.IllegalStateException {\n-        if (null == hedwigClient)\n-          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n-        return hedwigClient.getPublisher();\n-    }\n-\n-    public String publish(String topicName, MessageImpl message) throws JMSException {\n-        try {\n-            PubSubProtocol.PublishResponse response = getPublisher().publish(\n-                ByteString.copyFromUtf8(topicName), message.generateHedwigMessage());\n-            PubSubProtocol.MessageSeqId seqId =\n-                (null != response && response.hasPublishedMsgId() ? response.getPublishedMsgId() : null);\n-            if (null == seqId){\n-                // if (logger.isDebugEnabled())\n-                // logger.debug(\"Unexpected NOT to receive the sequence id in response to publish \" + response);\n-                logger.warn(\"Unexpected NOT to receive the sequence id in response to publish \" + response);\n-                return null;\n-            }\n-\n-            return MessageUtil.generateJMSMessageIdFromSeqId(seqId);\n-        } catch (PubSubException.CouldNotConnectException e) {\n-            JMSException jmsEx = new JMSException(\"Cant publish to \" + topicName + \" .. \" + e);\n-            jmsEx.setLinkedException(e);\n-            throw jmsEx;\n-        } catch (PubSubException.ServiceDownException e) {\n-            JMSException jmsEx = new JMSException(\"Cant publish to \" + topicName + \" .. \" + e);\n-            jmsEx.setLinkedException(e);\n-            throw jmsEx;\n-        }\n-    }\n-\n-    // Queue methods which are NOT supported yet.\n-    @Override\n-    public QueueSender createQueueSender(Destination destination) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public QueueReceiver createQueueReceiver(Destination destination) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector,\n-                                             boolean noLocal) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public String getSubscriberId(QueueReceiver queueReceiver) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public void stopQueueDelivery(String queueName, String subscribedId) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public void startQueueDelivery(String queueName, String subscriberId) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public TemporaryTopic createTemporaryTopic() throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-    @Override\n-    public TemporaryQueue createTemporaryQueue() throws JMSException {\n-        throw new JMSException(\"hedwig does not support queues yet\");\n-    }\n-\n-}"},{"sha":"a13e259eeb6d4974e6d1d837baebe38f961cd875","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,74 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.hedwig.jms.selector.Node;\n-import org.apache.hedwig.jms.selector.ParseException;\n-import org.apache.hedwig.jms.selector.SelectorParser;\n-\n-import javax.jms.InvalidSelectorException;\n-import javax.jms.JMSException;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-\n-/**\n- * Base class for consumers ...\n- */\n-public abstract class MessageConsumerImpl implements MessageConsumer {\n-    private final String messageSelector;\n-    private final Node selectorAst;\n-    // volatile to prevent need to lock and ensure visibility of mods across threads.\n-    private volatile MessageListener messageListener;\n-\n-    protected MessageConsumerImpl(String msgSelector) throws InvalidSelectorException {\n-        {\n-            msgSelector = null != msgSelector ? msgSelector.trim() : null;\n-            this.messageSelector = (null == msgSelector || 0 == msgSelector.length()) ?\n-                null : msgSelector;\n-        }\n-        try {\n-            this.selectorAst = null == this.messageSelector ?\n-                null : SelectorParser.parseMessageSelector(this.messageSelector);\n-        } catch (ParseException pEx) {\n-            InvalidSelectorException jmsEx =\n-                new InvalidSelectorException(\"Unable to parse selector '\" + this.messageSelector + \"'\");\n-            jmsEx.setLinkedException(pEx);\n-            throw jmsEx;\n-        }\n-    }\n-\n-    @Override\n-    public String getMessageSelector() {\n-        return messageSelector;\n-    }\n-\n-    public Node getSelectorAst() {\n-        return selectorAst;\n-    }\n-\n-    @Override\n-    public MessageListener getMessageListener() {\n-        return messageListener;\n-    }\n-\n-    @Override\n-    public void setMessageListener(MessageListener messageListener) throws JMSException {\n-        this.messageListener = messageListener;\n-    }\n-\n-}"},{"sha":"caf4b3e316804e7355f21ced76d3083abbcfb8e6","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java","status":"removed","additions":0,"deletions":117,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,117 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.hedwig.jms.SessionImpl;\n-\n-import javax.jms.DeliveryMode;\n-import javax.jms.JMSException;\n-import javax.jms.MessageProducer;\n-\n-/**\n- *\n- */\n-public abstract class MessageProducerImpl implements MessageProducer {\n-\n-    static final int DEFAULT_PRIORITY = 4;\n-\n-    private final SessionImpl session;\n-\n-    // We dont really use this - since we always populate message-id : found in response of publish.\n-    private boolean disableMessageID = false;\n-    // We can support this, but dont - will overly complicate some aspects of the code : deferring for now\n-    // (we will need to pass this around along all failure paths).\n-    private boolean disableMessageTimestamp = false;\n-    // Hedwig supports only PERSISTENT mode, so setting to anytihng else will just cause it to be ignored.\n-    private int deliveryMode = DeliveryMode.PERSISTENT;\n-    // Hedwig does not support priorities, so everything is at default priority !\n-    // this does not influence actual message delivery.\n-    private int defaultPriority = DEFAULT_PRIORITY;\n-    // Hedwig does not support TTL (iirc), so we allow setting/querying this, but it has no\n-    // actual impact on the message delivery/expiry.\n-    private long timeToLive = 0;\n-\n-    protected MessageProducerImpl(SessionImpl session) {\n-        this.session = session;\n-    }\n-\n-    @Override\n-    public void setDisableMessageID(boolean disableMessageID) throws JMSException {\n-        this.disableMessageID = disableMessageID;\n-    }\n-\n-    @Override\n-    public boolean getDisableMessageID() throws JMSException {\n-        return disableMessageID;\n-    }\n-\n-    protected SessionImpl getSession() {\n-        return session;\n-    }\n-\n-\n-    @Override\n-    public void setDisableMessageTimestamp(boolean disableMessageTimestamp) throws JMSException {\n-        this.disableMessageTimestamp = disableMessageTimestamp;\n-    }\n-\n-    @Override\n-    public boolean getDisableMessageTimestamp() throws JMSException {\n-        return disableMessageTimestamp;\n-    }\n-\n-    @Override\n-    public void setDeliveryMode(int deliveryMode) throws JMSException {\n-        if (DeliveryMode.NON_PERSISTENT != deliveryMode &&\n-            DeliveryMode.PERSISTENT != deliveryMode) {\n-            throw new JMSException(\"Invalid delivery mode specified : \" + deliveryMode);\n-        }\n-\n-        // if (DeliveryMode.NON_PERSISTENT == deliveryMode)\n-        // throw new JMSException(\"non-persistent delivery mode is not yet supported\");\n-        this.deliveryMode = deliveryMode;\n-    }\n-\n-    @Override\n-    public int getDeliveryMode() throws JMSException {\n-        return deliveryMode;\n-    }\n-\n-\n-    @Override\n-    public void setPriority(int defaultPriority) throws JMSException {\n-        // Not supported, we simply allow it to be set and retrieved ...\n-        this.defaultPriority = defaultPriority;\n-    }\n-\n-    @Override\n-    public int getPriority() throws JMSException {\n-        return defaultPriority;\n-    }\n-\n-\n-    @Override\n-    public void setTimeToLive(long timeToLive) throws JMSException {\n-        this.timeToLive = timeToLive;\n-    }\n-\n-    @Override\n-    public long getTimeToLive() throws JMSException {\n-        return timeToLive;\n-    }\n-}"},{"sha":"2beeea753a39889b8d3bf4b415cd5ab4cb2811fc","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,84 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.hedwig.jms.ConnectionImpl;\n-import org.apache.hedwig.jms.MessagingSessionFacade;\n-import org.apache.hedwig.jms.SessionImpl;\n-\n-import javax.jms.JMSException;\n-import javax.jms.Queue;\n-import javax.jms.QueueReceiver;\n-import javax.jms.QueueSender;\n-import javax.jms.QueueSession;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.Topic;\n-import javax.jms.TopicSubscriber;\n-\n-/**\n- * Queue specific impl\n- */\n-public class QueueSessionImpl extends SessionImpl implements QueueSession {\n-\n-    public QueueSessionImpl(ConnectionImpl connection, boolean transacted, int acknowledgeMode) throws JMSException {\n-        super(connection, transacted, acknowledgeMode);\n-    }\n-\n-    @Override\n-    public QueueReceiver createReceiver(Queue queue) throws JMSException {\n-        return super.createReceiverImpl(queue);\n-    }\n-\n-    @Override\n-    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n-        return super.createReceiverImpl(queue, messageSelector);\n-    }\n-\n-    @Override\n-    public QueueSender createSender(Queue queue) throws JMSException {\n-        return super.createSenderImpl(queue);\n-    }\n-\n-    // JMS requires these methods cant be called on QueueSession.\n-    @Override\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n-    }\n-\n-    @Override\n-    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId, String messageSelector,\n-                                                   boolean noLocal) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n-    }\n-\n-    @Override\n-    public TemporaryTopic createTemporaryTopic() throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n-    }\n-\n-    @Override\n-    public void unsubscribe(String subscribedId) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n-    }\n-\n-  @Override\n-    public Topic createTopic(String topicName) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n-    }\n-}"},{"sha":"23dfb54126ce2030451f663593defea6d2399fb3","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java","status":"removed","additions":0,"deletions":226,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,226 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.message.MessageImpl;\n-import org.apache.hedwig.jms.message.MessageUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.InvalidDestinationException;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.Topic;\n-import javax.jms.TopicPublisher;\n-\n-/**\n- *\n- */\n-public class TopicPublisherImpl extends MessageProducerImpl implements TopicPublisher {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(TopicPublisherImpl.class);\n-\n-    private final HedwigMessagingSessionFacade facade;\n-    private final Topic topic;\n-\n-    public TopicPublisherImpl(HedwigMessagingSessionFacade facade, SessionImpl session, Topic topic) {\n-        super(session);\n-        this.facade = facade;\n-        this.topic = topic;\n-    }\n-\n-    @Override\n-    public Topic getTopic() throws JMSException {\n-        return topic;\n-    }\n-\n-    @Override\n-    public void publish(Message message) throws JMSException {\n-        if (null == getTopic()) throw new UnsupportedOperationException(\"Need to specify topic\");\n-        publish(getTopic(), message);\n-    }\n-\n-    @Override\n-    public void publish(Topic topic, Message message) throws JMSException {\n-        publish(topic, message, getDeliveryMode(), getPriority(), getTimeToLive());\n-    }\n-\n-    @Override\n-    public void publish(Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {\n-        if (null == getTopic()) throw new UnsupportedOperationException(\"Need to specify topic\");\n-        publish(getTopic(), message, deliveryMode, priority, timeToLive);\n-    }\n-\n-    // all publish/send methods delegate to this ...\n-    @Override\n-    public void publish(final Topic topic, final Message message, final int deliveryMode,\n-                        final int priority, final long timeToLive) throws JMSException {\n-\n-        // Simulating this in provider ...\n-        // if (0 != timeToLive) throw new JMSException(\"We do not support TTL for messages right now.\n-        // Specified TTL : \" + timeToLive);\n-\n-        if (MessageProducerImpl.DEFAULT_PRIORITY != priority) {\n-            if (logger.isInfoEnabled())\n-              logger.info(\"We do not support message priorities right now. Specified priority : \" + priority);\n-        }\n-        if (DeliveryMode.PERSISTENT != deliveryMode) {\n-            if (logger.isInfoEnabled())\n-              logger.info(\"We support only PERSISTENT delivery mode. Unsupported mode : \" + deliveryMode);\n-        }\n-\n-        if (null == topic){\n-            throw new InvalidDestinationException(\"Topic must be specified to publish\");\n-        }\n-\n-        final MessageImpl copiedMessageImpl;\n-        if (message instanceof MessageImpl) copiedMessageImpl = MessageUtil.createCloneForDispatch(\n-            getSession(), (MessageImpl) message, topic.getTopicName(), null);\n-        else copiedMessageImpl = MessageUtil.createMessageCopy(getSession(), message);\n-\n-        // Note: Ensure that we set properties below on both message (user input) and copiedMessageImpl\n-        // (the cloned/copied message).\n-        // We are doing set on both instead of set followed by close/copy to prevent cases where message\n-        // implementation drops\n-        // headers (like our own impl earlier !)\n-\n-        // priority ...\n-        {\n-            // Set the message priority\n-            // 3.4.10 JMSPriority \"When a message is sent, this field is ignored. After completion of\n-            // the send, it holds the value specified by the method sending the message.\"\n-            // On other hand, we have\n-            // 3.4.12 Overriding Message Header Fields : \"JMS permits an administrator to configure\n-            // JMS to override the client-specified\n-            // values for JMSDeliveryMode, JMSExpiration and JMSPriority. If this is done, the header\n-            // field value must reflect the\n-            // administratively specified value.\"\n-            // For now, to unblock testcases, setting to msgPriority :-) Actually, I think we should\n-            // set it to Message.DEFAULT_PRIORITY ...\n-            message.setJMSPriority(priority);\n-            copiedMessageImpl.setJMSPriority(priority);\n-            // message.setJMSPriority(Message.DEFAULT_PRIORITY);\n-            // copiedMessageImpl.setJMSPriority(Message.DEFAULT_PRIORITY);\n-        }\n-\n-        // delivery mode ...\n-        {\n-\n-            // 3.4.2 JMSDeliveryMode \"The JMSDeliveryMode header field contains the delivery mode\n-            // specified when the message was sent.\n-            // When a message is sent, this field is ignored. After completion of the send, it holds\n-            // the delivery mode specified by the sending method.\"\n-            message.setJMSDeliveryMode(deliveryMode);\n-            copiedMessageImpl.setJMSDeliveryMode(deliveryMode);\n-        }\n-\n-        // destination ...\n-        {\n-            // 3.4.1 JMSDestination \"The JMSDestination header field contains the destination to which\n-            // the message is being sent.\n-            // When a message is sent, this field is ignored. After completion of the send, it holds\n-            // the destination object\n-            // specified by the sending method. When a message is received, its destination value\n-            // must be equivalent to the\n-            // value assigned when it was sent.\"\n-            message.setJMSDestination(getSession().createTopic(topic.getTopicName()));\n-            copiedMessageImpl.setJMSDestination(getSession().createTopic(topic.getTopicName()));\n-        }\n-\n-        {\n-            // 3.4.4 JMSTimestamp\n-            // \"The JMSTimestamp header field contains the time a message was handed off to a provider to be sent.\n-            // It is not the time the message was actually transmitted because the actual send may occur later\n-            // due to transactions or other client side queueing of messages.\"\n-            final long timestamp = SessionImpl.currentTimeMillis();\n-            message.setJMSTimestamp(timestamp);\n-            copiedMessageImpl.setJMSTimestamp(timestamp);\n-        }\n-\n-        if (timeToLive > 0) {\n-            final long expiryTime = SessionImpl.currentTimeMillis() + timeToLive;\n-            message.setJMSExpiration(expiryTime);\n-            copiedMessageImpl.setJMSExpiration(expiryTime);\n-        }\n-        else {\n-            // no expiry.\n-            message.setJMSExpiration(0);\n-        }\n-\n-\n-        if (getSession().getTransacted()){\n-            // enqueue if within transactions.\n-            getSession().enqueuePublishWithinTransaction(topic.getTopicName(), copiedMessageImpl, message);\n-            return ;\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Publishing message ... recepient \" + topic.getTopicName());\n-        // facade.getPublisher().publish(ByteString.copyFromUtf8(topic.getTopicName()),\n-        // copiedMessageImpl.generateHedwigMessage(this));\n-        String msgId = facade.publish(topic.getTopicName(), copiedMessageImpl);\n-        getSession().addToLocallyPublishedMessageIds(msgId);\n-        if (message instanceof MessageImpl) ((MessageImpl) message).setJMSMessageIDInternal(msgId);\n-        else message.setJMSMessageID(msgId);\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Publishing message ... recepient \" +\n-            topic.getTopicName() + \", msgId : \" + msgId + \" DONE\");\n-\n-        // This is not required, we already do this as part of copiedMessageImpl.generateHedwigMessage()\n-        // message.setJMSTimestamp(SessionImpl.currentTimeMillis());\n-\n-    }\n-\n-    @Override\n-    public Destination getDestination() throws JMSException {\n-        return topic;\n-    }\n-\n-    @Override\n-    public void close() throws JMSException {\n-        // This will be a noop actually ... session.close() takes care of closing the publisher.\n-    }\n-\n-    @Override\n-    public void send(Message message) throws JMSException {\n-        publish(message);\n-    }\n-\n-    @Override\n-    public void send(Destination destination, Message message) throws JMSException {\n-        if (!(destination instanceof Topic))\n-          throw new JMSException(\"Expected destination to be a Topic : \" + destination);\n-        publish((Topic) destination, message);\n-    }\n-\n-    @Override\n-    public void send(Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {\n-        publish(message, deliveryMode, priority, timeToLive);\n-    }\n-\n-    @Override\n-    public void send(Destination destination, Message message, int deliveryMode,\n-                     int priority, long timeToLive) throws JMSException {\n-        if (!(destination instanceof Topic))\n-          throw new JMSException(\"Expected destination to be a Topic : \" + destination);\n-\n-        publish((Topic) destination, message, deliveryMode, priority, timeToLive);\n-    }\n-}"},{"sha":"e96f9984207e7e373ee6d39dc798e6096d8d7f2b","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java","status":"removed","additions":0,"deletions":76,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,76 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.hedwig.jms.ConnectionImpl;\n-import org.apache.hedwig.jms.SessionImpl;\n-\n-import javax.jms.JMSException;\n-import javax.jms.Queue;\n-import javax.jms.QueueBrowser;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.Topic;\n-import javax.jms.TopicPublisher;\n-import javax.jms.TopicSession;\n-import javax.jms.TopicSubscriber;\n-\n-/**\n- * Topic specific impl\n- */\n-public class TopicSessionImpl extends SessionImpl implements TopicSession {\n-\n-    public TopicSessionImpl(ConnectionImpl connection, boolean transacted, int acknowledgeMode) throws JMSException {\n-        super(connection, transacted, acknowledgeMode);\n-    }\n-\n-    @Override\n-    public TopicSubscriber createSubscriber(Topic topic) throws JMSException {\n-        return super.createSubscriberImpl(topic);\n-    }\n-\n-    @Override\n-    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n-        return super.createSubscriberImpl(topic, messageSelector, noLocal);\n-    }\n-\n-    @Override\n-    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n-        return super.createPublisherImpl(topic);\n-    }\n-\n-    @Override\n-    public TemporaryQueue createTemporaryQueue() throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n-    }\n-\n-    @Override\n-    public Queue createQueue(String queueName) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n-    }\n-\n-    @Override\n-    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n-    }\n-\n-    @Override\n-    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n-        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n-    }\n-}"},{"sha":"4a51e8dd8eb2cccd68cfd5661c011fc31bfba520","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java","status":"removed","additions":0,"deletions":323,"changes":323,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,323 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.jms.spi;\n-\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.DebugUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.jms.InvalidSelectorException;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageListener;\n-import javax.jms.Topic;\n-import javax.jms.TopicSubscriber;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-/**\n- * Subscriber to a topic.\n- *\n- */\n-public class TopicSubscriberImpl extends MessageConsumerImpl implements TopicSubscriber {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(TopicSubscriberImpl.class);\n-\n-    private final SessionImpl session;\n-    private final Topic topic;\n-    private final String subscriberId;\n-    private final boolean noLocal;\n-\n-    private final boolean forceUnsubscribe;\n-    private volatile boolean registered = false;\n-    private boolean closed = false;\n-\n-    // Any publically exposed object MUST NOT rely on 'this' for its locking semantics unless it is\n-    // explicitly exposing this behavior.\n-    private final Object lockObject = new Object();\n-    private final LinkedList<SessionImpl.ReceivedMessage> pendingMessageList\n-        = new LinkedList<SessionImpl.ReceivedMessage>();\n-\n-    public TopicSubscriberImpl(SessionImpl session, Topic topic, String subscriberId,\n-                               boolean forceUnsubscribe) throws JMSException {\n-        super(null);\n-        this.session = session;\n-        this.topic = topic;\n-        this.subscriberId = subscriberId;\n-        // default is false right ?\n-        this.noLocal = false;\n-        this.forceUnsubscribe = forceUnsubscribe;\n-\n-        // I am not sure if we have to register with session immediately on create or not ...\n-        registerWithSession();\n-    }\n-\n-    public TopicSubscriberImpl(SessionImpl session, Topic topic, String subscriberId,\n-                               String messageSelector, boolean noLocal, boolean forceUnsubscribe) throws JMSException {\n-        super(messageSelector);\n-        this.session = session;\n-        this.topic = topic;\n-        this.subscriberId = subscriberId;\n-\n-        this.noLocal = noLocal;\n-        this.forceUnsubscribe = forceUnsubscribe;\n-\n-        if (null == getSelectorAst()){\n-            // Only if NOT empty string - treat empty string as null selector spec.\n-            if (null != messageSelector && 0 != messageSelector.trim().length()){\n-                throw new InvalidSelectorException(\"Invalid selector specified '\" + messageSelector + \"'\");\n-            }\n-        }\n-        else {\n-            session.registerTopicSubscriptionInfo(new SessionImpl.TopicSubscription(topic.getTopicName(),\n-                subscriberId), getSelectorAst());\n-        }\n-\n-        // I am not sure if we have to register with session immediately on create or not ...\n-        registerWithSession();\n-    }\n-\n-    @Override\n-    public Topic getTopic() {\n-        return topic;\n-    }\n-\n-    @Override\n-    public boolean getNoLocal() {\n-        return noLocal;\n-    }\n-\n-    public String getSubscriberId() {\n-        return subscriberId;\n-    }\n-\n-    @Override\n-    public void setMessageListener(MessageListener messageListener) throws JMSException {\n-        super.setMessageListener(messageListener);\n-        registerWithSession();\n-    }\n-\n-    private void registerWithSession() throws JMSException {\n-\n-        // Fail fast ... volatile perf hit is ok in comparison to rest.\n-        if (this.registered) return ;\n-\n-        final boolean register;\n-        synchronized (lockObject){\n-            // if (closed) throw new JMSException(\"Already closed\");\n-            if (closed) return ;\n-\n-            if (!this.registered) {\n-                this.registered = true;\n-                register = true;\n-            }\n-            else register = false;\n-        }\n-        if (register) this.session.registerTopicSubscriber(this);\n-    }\n-\n-    @Override\n-    public Message receive() throws JMSException {\n-        return receive(0);\n-    }\n-\n-\n-    @Override\n-    public Message receive(final long maxTimeout) throws JMSException {\n-        return receiveImpl(maxTimeout, true);\n-    }\n-\n-    private Message receiveImpl(final long maxTimeout, boolean canWait) throws JMSException {\n-        final long waitTimeout;\n-        final long startTime;\n-\n-        // periodically wake up !\n-        if (canWait){\n-            if (maxTimeout <= 0) waitTimeout = 1000;\n-            else {\n-                long duration = maxTimeout / 16;\n-                if (duration <= 0) duration = 1;\n-                waitTimeout = duration;\n-            }\n-            startTime = SessionImpl.currentTimeMillis();\n-        }\n-        else {\n-            waitTimeout = 0;\n-            startTime = 0;\n-        }\n-\n-        registerWithSession();\n-\n-        // check before lock ...\n-        if (null != getMessageListener()) {\n-          throw new javax.jms.IllegalStateException(\n-                  \"There is a message listener already subscribed for this subscriber\");\n-        }\n-\n-        final SessionImpl.ReceivedMessage message;\n-        final List<SessionImpl.ReceivedMessage> ackList = new ArrayList<SessionImpl.ReceivedMessage>(4);\n-\n-        synchronized (lockObject){\n-\n-outer:\n-            while (true) {\n-\n-                // Should we ignore cached messages instead of this ?\n-                // Once closed, wont help much anyway, right ?\n-                if (closed) {\n-                    message = null;\n-                    break outer;\n-                }\n-\n-                // While we waited, it could have been set.\n-                if (null != getMessageListener()) {\n-                  throw new javax.jms.IllegalStateException(\n-                          \"There is a message listener already subscribed for this subscriber\");\n-                }\n-\n-                while (canWait && pendingMessageList.isEmpty()){\n-\n-                    // Should we ignore cached messages instead of this ?\n-                    // Once closed, wont help much anyway, right ?\n-                    if (closed) {\n-                        message = null;\n-                        break outer;\n-                    }\n-\n-                    if (0 != maxTimeout && startTime + maxTimeout < SessionImpl.currentTimeMillis()) {\n-                        message = null;\n-                        break outer;\n-                    }\n-\n-                    try {\n-                        lockObject.wait(waitTimeout);\n-                    } catch (InterruptedException iEx){\n-                        JMSException jEx = new JMSException(\"Interrupted .. \" + iEx);\n-                        jEx.setLinkedException(iEx);\n-                        throw jEx;\n-                    }\n-                }\n-\n-\n-                if (pendingMessageList.isEmpty()) {\n-                    message = null;\n-                    break outer;\n-                }\n-                SessionImpl.ReceivedMessage tmessage = pendingMessageList.remove();\n-                ackList.add(tmessage);\n-\n-                if (noLocal){\n-                    if (session.isLocallyPublished(tmessage.originalMessage.getJMSMessageID())){\n-                        // find next message.\n-                        continue;\n-                    }\n-                }\n-                if (session.isMessageExpired(tmessage.originalMessage)) continue;\n-                // use this message then.\n-                message = tmessage;\n-                break;\n-            }\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"Acklist receive (\" + ackList.size() + \") ... \" + ackList);\n-        for (SessionImpl.ReceivedMessage ackMessage : ackList){\n-            session.handleAutomaticMessageAcknowledgement(ackMessage, this);\n-        }\n-\n-        if (logger.isTraceEnabled()) logger.trace(\"receive response \" + (null != message ? message.msg : null));\n-        return null != message ? message.msg : null;\n-   }\n-\n-    @Override\n-    public Message receiveNoWait() throws JMSException {\n-        return receiveImpl(0, false);\n-    }\n-\n-    @Override\n-    public void close() throws JMSException {\n-\n-        final boolean unregister;\n-        final boolean unsubscribe;\n-\n-        synchronized (lockObject){\n-            if (closed) return ;\n-            closed = true;\n-\n-            // This means that we drop all pending messages ...\n-            // gc friendly.\n-            pendingMessageList.clear();\n-\n-            unregister = registered;\n-            this.registered = false;\n-\n-            unsubscribe = this.forceUnsubscribe;\n-        }\n-\n-        if (unregister) this.session.unregisterTopicSubscriber(this);\n-\n-        // this.session.stopTopicDelivery(topic.getTopicName(), subscriberId);\n-        if (unsubscribe) session.unsubscribeFromTopic(topic.getTopicName(), subscriberId);\n-\n-        // nothing else to be done ...\n-    }\n-\n-    boolean enqueueReceivedMessage(SessionImpl.ReceivedMessage receivedMessage, final boolean addFirst) {\n-        if (logger.isTraceEnabled())\n-          logger.trace(\"Enqueing message \" + receivedMessage + \" to subscriber \" + subscriberId +\n-              \" for topic \" + topic.toString() + \", addFirst : \" + addFirst);\n-\n-        String infoMsg = null;\n-        String traceMsg = null;\n-        synchronized (lockObject){\n-            // ignore\n-            if (closed) return false;\n-            // If number of buffered messages > some max limit, evict them - else we run out of memory !\n-            if (pendingMessageList.size() > SessionImpl.MAX_SUBSCRIBER_BUFFERED_MESSAGES) {\n-                // simply discard it with an error logged.\n-                infoMsg = \"Discarding \" + pendingMessageList.size() + \" messages since there are no consumers for them\";\n-                pendingMessageList.clear();\n-            }\n-\n-            // Note: Selector evaluation will happen in SessionImpl.\n-            // if (!selectorMatched(receivedMessage)) return false;\n-\n-            if (addFirst) pendingMessageList.addFirst(receivedMessage);\n-            else pendingMessageList.add(receivedMessage);\n-\n-            lockObject.notifyAll();\n-            if (logger.isTraceEnabled()) traceMsg = \"pendingMessageList (\" + pendingMessageList.size() +\n-                \") : \\n\" + pendingMessageList + \"\\n---\\n next : \" + pendingMessageList.getFirst();\n-        }\n-\n-        if (null != infoMsg) logger.info(infoMsg);\n-        if (logger.isTraceEnabled() && null != traceMsg) logger.trace(traceMsg);\n-\n-        return true;\n-    }\n-\n-    public void start() {\n-        try {\n-            registerWithSession();\n-        } catch (JMSException jEx){\n-            // ignore.\n-            DebugUtil.dumpJMSStacktrace(logger, jEx);\n-        }\n-    }\n-}"},{"sha":"fe6c1e13359acaa55a5cdce2b5f75188be7282f2","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html","status":"removed","additions":0,"deletions":30,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,30 +0,0 @@\n-<!--\n-   Licensed to the Apache Software Foundation (ASF) under one or more\n-   contributor license agreements.  See the NOTICE file distributed with\n-   this work for additional information regarding copyright ownership.\n-   The ASF licenses this file to You under the Apache License, Version 2.0\n-   (the \"License\"); you may not use this file except in compliance with\n-   the License.  You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n--->\n-\n-\n-Contains all the implementation which interacts directly with Hedwig (except for message parsing\n-which is in message package). <br/>\n-The does not, typically, adhere to JMS MT-constraints - and needs to be MT-safe : it can be invoked\n-by underlying hedwig thread-pools and by client JMS invocations concurrently. <br/>\n-\n-Primarily provides :\n-<ul>\n-  <li>The HedwigConnectionImpl which is (by default) looked up via JNDI. This bootstraps access to rest of system.</li>\n-  <li>The default MessagingSessionFacade implementation for Hedwig.</li>\n-  <li>Associated implementations relevant to the classes exposed by the Facade - Topic handling\n-    (no support for Queue yet), etc</li>\n-</ul>"},{"sha":"2338587bcc56d2236503ce9c5beecbdbffaac2a9","filename":"hedwig-client-jms/src/main/protobuf/JmsHeader.proto","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/protobuf/JmsHeader.proto","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/protobuf/JmsHeader.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/protobuf/JmsHeader.proto?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,54 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-option java_package = \"org.apache.hedwig.jms.message.header\";\n-option optimize_for = SPEED;\n-// change ?\n-package Hedwig.Jms.Header;\n-\n-enum ProtocolVersion{\n-    VERSION_ONE = 1;\n-}\n-\n-message JmsValue {\n-    enum ValueType {\n-        BOOLEAN = 1;\n-        BYTE = 2;\n-        SHORT = 3;\n-        INT = 4;\n-        LONG = 5;\n-        FLOAT = 6;\n-        DOUBLE = 7;\n-        STRING = 8;\n-        // raw bytes. (custom correlation id, for example, uses this : though we dont support it right now).\n-        BYTES = 9;\n-    };\n-\n-    required ValueType type = 1;\n-\n-    optional bool booleanValue = 2;\n-    optional sint32 byteValue = 3;\n-    optional sint32 shortValue = 4;\n-    optional sint32 intValue = 5;\n-    optional sint64 longValue = 6;\n-    optional float floatValue = 7;\n-    optional double doubleValue = 8;\n-    optional string stringValue = 9;\n-    optional bytes bytesValue = 10;\n-}\n-\n-"},{"sha":"bae9e0907e7b3177f0ea5e86743e6a2e1dc24aa7","filename":"hedwig-client-jms/src/main/resources/findbugsExclude.xml","status":"removed","additions":0,"deletions":48,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/resources/findbugsExclude.xml?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,48 +0,0 @@\n-<!--\n-    Licensed to the Apache Software Foundation (ASF) under one\n-    or more contributor license agreements.  See the NOTICE file\n-    distributed with this work for additional information\n-    regarding copyright ownership.  The ASF licenses this file\n-    to you under the Apache License, Version 2.0 (the\n-    \"License\"); you may not use this file except in compliance\n-    with the License.  You may obtain a copy of the License at\n-\n-      http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-//-->\n-<FindBugsFilter>\n-  <Match>\n-    <!-- generated code, we can't be held responsible for findbugs in it //-->\n-    <Or>\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.message\\.header\\.JmsHeader.*\" />\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.SelectorParser.*\" />\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.SimpleCharStream.*\" />\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.ParseException.*\" />\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.SimpleNode.*\" />\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.TokenMgrError.*\" />\n-    </Or>\n-  </Match>\n-  <Match>\n-    <Or>\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.ValueComparisonFunction.*\" />\n-      <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.LogicalComparisonFunction.*\" />\n-    </Or>\n-    <Bug pattern=\"NP_BOOLEAN_RETURN_NULL\" />\n-  </Match>\n-  <Match>\n-    <Class name=\"~org\\.apache\\.hedwig\\.jms\\.selector\\.PropertyExprFunction.*\" />\n-    <Bug pattern=\"BX_UNBOXING_IMMEDIATELY_REBOXED\" />\n-  </Match>\n-  <Match>\n-    <Class name=\"~org\\.apache\\.hedwig\\.jms\\.message\\.MessageUtil\" />\n-    <Or>\n-      <Bug pattern=\"NP_LOAD_OF_KNOWN_NULL_VALUE\" />\n-      <Bug pattern=\"NP_NULL_PARAM_DEREF_NONVIRTUAL\" />\n-    </Or>\n-  </Match>\n-</FindBugsFilter>"},{"sha":"27d78f185b3ffd211c918e3f458df6bf0de7a8a2","filename":"hedwig-client-jms/src/main/resources/log4j.properties","status":"removed","additions":0,"deletions":35,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/main/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/resources/log4j.properties?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,35 +0,0 @@\n-#\n-#\n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-#\n-#   http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-#\n-#\n-\n-# log4j.rootLogger=trace, CONSOLE\n-# log4j.rootLogger=info, CONSOLE\n-log4j.rootLogger=off, CONSOLE\n-\n-log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n-log4j.appender.CONSOLE.Threshold=off\n-# log4j.appender.CONSOLE.Threshold=info\n-# log4j.appender.CONSOLE.Threshold=trace\n-log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n-log4j.logger.org.apache=OFF\n-# log4j.logger.org.apache=INFO\n-# log4j.logger.org.apache=TRACE\n-"},{"sha":"f4c0f7ec023e63a073597fa5540b5fb07ecbfda9","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,153 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import junit.framework.TestCase;\n-import org.apache.hedwig.JmsTestBase;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Enforces a test case to run for only an allotted time to prevent them from\n- * hanging and breaking the whole testing.\n- */\n-\n-public abstract class AutoFailTestSupport extends JmsTestBase {\n-    public static final int EXIT_SUCCESS = 0;\n-    public static final int EXIT_ERROR = 1;\n-    private static final Logger LOG = LoggerFactory.getLogger(AutoFailTestSupport.class);\n-\n-    private long maxTestTime = 5 * 60 * 1000; // 5 mins by default\n-    private Thread autoFailThread;\n-\n-    private boolean verbose = true;\n-    private boolean useAutoFail; // Disable auto fail by default\n-    private AtomicBoolean isTestSuccess;\n-\n-    protected void setUp() throws Exception {\n-        // Runs the auto fail thread before performing any setup\n-        if (isAutoFail()) {\n-            startAutoFailThread();\n-        }\n-        super.setUp();\n-    }\n-\n-    protected void tearDown() throws Exception {\n-        super.tearDown();\n-\n-        // Stops the auto fail thread only after performing any clean up\n-        stopAutoFailThread();\n-    }\n-\n-    /**\n-     * Manually start the auto fail thread. To start it automatically, just set\n-     * the auto fail to true before calling any setup methods. As a rule, this\n-     * method is used only when you are not sure, if the setUp and tearDown\n-     * method is propagated correctly.\n-     */\n-    public void startAutoFailThread() {\n-        setAutoFail(true);\n-        isTestSuccess = new AtomicBoolean(false);\n-        autoFailThread = new Thread(new Runnable() {\n-            public void run() {\n-                try {\n-                    // Wait for test to finish succesfully\n-                    Thread.sleep(getMaxTestTime());\n-                } catch (InterruptedException e) {\n-                    // This usually means the test was successful\n-                } finally {\n-                    // Check if the test was able to tear down succesfully,\n-                    // which usually means, it has finished its run.\n-                    if (!isTestSuccess.get()) {\n-                        LOG.error(\"Test case has exceeded the maximum allotted time to run of: \"\n-                                  + getMaxTestTime() + \" ms.\");\n-                        dumpAllThreads(getName());\n-                        System.exit(EXIT_ERROR);\n-                    }\n-                }\n-            }\n-        }, \"AutoFailThread\");\n-\n-        if (verbose) {\n-            LOG.info(\"Starting auto fail thread...\");\n-        }\n-\n-        LOG.info(\"Starting auto fail thread...\");\n-        autoFailThread.start();\n-    }\n-\n-    /**\n-     * Manually stops the auto fail thread. As a rule, this method is used only\n-     * when you are not sure, if the setUp and tearDown method is propagated\n-     * correctly.\n-     */\n-    public void stopAutoFailThread() {\n-        if (isAutoFail() && autoFailThread != null && autoFailThread.isAlive()) {\n-            isTestSuccess.set(true);\n-\n-            if (verbose) {\n-                LOG.info(\"Stopping auto fail thread...\");\n-            }\n-\n-            LOG.info(\"Stopping auto fail thread...\");\n-            autoFailThread.interrupt();\n-        }\n-    }\n-\n-    /**\n-     * Sets the auto fail value. As a rule, this should be used only before any\n-     * setup methods is called to automatically enable the auto fail thread in\n-     * the setup method of the test case.\n-     *\n-     * @param val\n-     */\n-    public void setAutoFail(boolean val) {\n-        this.useAutoFail = val;\n-    }\n-\n-    public boolean isAutoFail() {\n-        return this.useAutoFail;\n-    }\n-\n-    /**\n-     * The assigned value will only be reflected when the auto fail thread has\n-     * started its run. Value is in milliseconds.\n-     *\n-     * @param val\n-     */\n-    public void setMaxTestTime(long val) {\n-        this.maxTestTime = val;\n-    }\n-\n-    public long getMaxTestTime() {\n-        return this.maxTestTime;\n-    }\n-\n-    public static void dumpAllThreads(String prefix) {\n-        Map<Thread, StackTraceElement[]> stacks = Thread.getAllStackTraces();\n-        for (Entry<Thread, StackTraceElement[]> stackEntry : stacks.entrySet()) {\n-            System.err.println(prefix + \" \" + stackEntry.getKey());\n-            for(StackTraceElement element : stackEntry.getValue()) {\n-                System.err.println(\"     \" + element);\n-            }\n-        }\n-    }\n-}"},{"sha":"d4155a767083bb83a664462e7ad3cae49e847bbe","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java","status":"removed","additions":0,"deletions":250,"changes":250,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,250 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Poor mans way of getting JUnit to run a test case through a few different\n- * combinations of options. Usage: If you have a test case called testFoo what\n- * you want to run through a few combinations, of of values for the attributes\n- * age and color, you would something like: <code>\n- *    public void initCombosForTestFoo() {\n- *        addCombinationValues( \"age\", new Object[]{ new Integer(21), new Integer(30) } );\n- *        addCombinationValues( \"color\", new Object[]{\"blue\", \"green\"} );\n- *    }\n- * </code>\n- * The testFoo test case would be run for each possible combination of age and\n- * color that you setup in the initCombosForTestFoo method. Before each\n- * combination is run, the age and color fields of the test class are set to one\n- * of the values defined. This is done before the normal setUp method is called.\n- * If you want the test combinations to show up as separate test runs in the\n- * JUnit reports, add a suite method to your test case similar to: <code>\n- *     public static Test suite() {\n- *         return suite(FooTest.class);\n- *     }\n- * </code>\n- *\n- *\n- */\n-public abstract class CombinationTestSupport extends AutoFailTestSupport {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(CombinationTestSupport.class);\n-\n-    private HashMap<String, ComboOption> comboOptions = new HashMap<String, ComboOption>();\n-    private boolean combosEvaluated;\n-    private Map<String, Object> options;\n-\n-    static class ComboOption {\n-        final String attribute;\n-        final LinkedHashSet<Object> values = new LinkedHashSet<Object>();\n-\n-        public ComboOption(String attribute, Collection<Object> options) {\n-            this.attribute = attribute;\n-            this.values.addAll(options);\n-        }\n-    }\n-\n-    public void addCombinationValues(String attribute, Object[] options) {\n-        ComboOption co = this.comboOptions.get(attribute);\n-        if (co == null) {\n-            this.comboOptions.put(attribute, new ComboOption(attribute, Arrays.asList(options)));\n-        } else {\n-            co.values.addAll(Arrays.asList(options));\n-        }\n-    }\n-\n-    public void runBare() throws Throwable {\n-        if (combosEvaluated) {\n-            super.runBare();\n-        } else {\n-            CombinationTestSupport[] combinations = getCombinations();\n-            for (int i = 0; i < combinations.length; i++) {\n-                CombinationTestSupport test = combinations[i];\n-                if (getName() == null || getName().equals(test.getName())) {\n-                    test.runBare();\n-                }\n-            }\n-        }\n-    }\n-\n-    private void setOptions(Map<String, Object> options) throws NoSuchFieldException, IllegalAccessException {\n-        this.options = options;\n-        for (Iterator<String> iterator = options.keySet().iterator(); iterator.hasNext();) {\n-            String attribute = iterator.next();\n-            Object value = options.get(attribute);\n-            try {\n-                Field field = getClass().getField(attribute);\n-                field.set(this, value);\n-            } catch (Throwable e) {\n-                try {\n-                    boolean found = false;\n-                    String setterName = \"set\" + attribute.substring(0, 1).toUpperCase() +\n-                                        attribute.substring(1);\n-                    for(Method method : getClass().getMethods()) {\n-                        if (method.getName().equals(setterName)) {\n-                            method.invoke(this, value);\n-                            found = true;\n-                            break;\n-                        }\n-                    }\n-\n-                    if (!found) {\n-                        throw new NoSuchMethodError(\"No setter found for field: \" + attribute);\n-                    }\n-\n-                } catch(Throwable ex) {\n-                    LOG.info(\"Could not set field '\" + attribute + \"' to value '\" + value +\n-                             \"', make sure the field exists and is public or has a setter.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    private CombinationTestSupport[] getCombinations() {\n-        try {\n-            Method method = getClass().getMethod(\"initCombos\", (Class[])null);\n-            method.invoke(this, (Object[])null);\n-        } catch (Throwable e) {\n-        }\n-\n-        String name = getName().split(\" \")[0];\n-        String comboSetupMethodName = \"initCombosFor\" + Character.toUpperCase(name.charAt(0)) + name.substring(1);\n-        try {\n-            Method method = getClass().getMethod(comboSetupMethodName, (Class[])null);\n-            method.invoke(this, (Object[])null);\n-        } catch (Throwable e) {\n-        }\n-\n-        try {\n-            ArrayList<HashMap<String, Object>> expandedOptions = new ArrayList<HashMap<String, Object>>();\n-            expandCombinations(new ArrayList<ComboOption>(comboOptions.values()), expandedOptions);\n-\n-            if (expandedOptions.isEmpty()) {\n-                combosEvaluated = true;\n-                return new CombinationTestSupport[] {this};\n-            } else {\n-\n-                ArrayList<CombinationTestSupport> result = new ArrayList<CombinationTestSupport>();\n-                // Run the test case for each possible combination\n-                for (Iterator<HashMap<String, Object>> iter = expandedOptions.iterator(); iter.hasNext();) {\n-                    CombinationTestSupport combo = (CombinationTestSupport)TestSuite.createTest(getClass(), name);\n-                    combo.combosEvaluated = true;\n-                    combo.setOptions(iter.next());\n-                    result.add(combo);\n-                }\n-\n-                CombinationTestSupport rc[] = new CombinationTestSupport[result.size()];\n-                result.toArray(rc);\n-                return rc;\n-            }\n-        } catch (Throwable e) {\n-            combosEvaluated = true;\n-            return new CombinationTestSupport[] {this};\n-        }\n-\n-    }\n-\n-    private void expandCombinations(List<ComboOption> optionsLeft, List<HashMap<String, Object>> expandedCombos) {\n-        if (!optionsLeft.isEmpty()) {\n-            HashMap<String, Object> map;\n-            if (comboOptions.size() == optionsLeft.size()) {\n-                map = new HashMap<String, Object>();\n-                expandedCombos.add(map);\n-            } else {\n-                map = expandedCombos.get(expandedCombos.size() - 1);\n-            }\n-\n-            LinkedList<ComboOption> l = new LinkedList<ComboOption>(optionsLeft);\n-            ComboOption comboOption = l.removeLast();\n-            int i = 0;\n-            for (Iterator<Object> iter = comboOption.values.iterator(); iter.hasNext();) {\n-                Object value = iter.next();\n-                if (i != 0) {\n-                    map = new HashMap<String, Object>(map);\n-                    expandedCombos.add(map);\n-                }\n-                map.put(comboOption.attribute, value);\n-                expandCombinations(l, expandedCombos);\n-                i++;\n-            }\n-        }\n-    }\n-\n-    public static Test suite(Class<? extends CombinationTestSupport> clazz) {\n-        TestSuite suite = new TestSuite();\n-\n-        ArrayList<String> names = new ArrayList<String>();\n-        Method[] methods = clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            String name = methods[i].getName();\n-            if (names.contains(name) || !isPublicTestMethod(methods[i])) {\n-                continue;\n-            }\n-            names.add(name);\n-            Test test = TestSuite.createTest(clazz, name);\n-            if (test instanceof CombinationTestSupport) {\n-                CombinationTestSupport[] combinations = ((CombinationTestSupport)test).getCombinations();\n-                for (int j = 0; j < combinations.length; j++) {\n-                    suite.addTest(combinations[j]);\n-                }\n-            } else {\n-                suite.addTest(test);\n-            }\n-        }\n-        return suite;\n-    }\n-\n-    private static boolean isPublicTestMethod(Method m) {\n-        return isTestMethod(m) && Modifier.isPublic(m.getModifiers());\n-    }\n-\n-    private static boolean isTestMethod(Method m) {\n-        String name = m.getName();\n-        Class<?>[] parameters = m.getParameterTypes();\n-        Class<?> returnType = m.getReturnType();\n-        return parameters.length == 0 && name.startsWith(\"test\") && returnType.equals(Void.TYPE);\n-    }\n-\n-    public String getName() {\n-        return getName(false);\n-    }\n-\n-    public String getName(boolean original) {\n-        if (options != null && !original) {\n-            return super.getName() + \" \" + options;\n-        }\n-        return super.getName();\n-    }\n-}"},{"sha":"e1e85e5ee3b99c2fea3fc6ac9348ee4af7154619","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,73 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.JMSException;\n-import javax.jms.Session;\n-\n-import junit.framework.TestCase;\n-import org.apache.hedwig.JmsTestBase;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n-\n-public class ConnectionCleanupTest extends JmsTestBase {\n-\n-    private HedwigConnectionImpl connection;\n-    private HedwigConnectionFactoryImpl factory;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        this.factory = new HedwigConnectionFactoryImpl();\n-        connection = factory.createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        connection.close();\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * @throws JMSException\n-     */\n-    public void testChangeClientID() throws JMSException {\n-\n-        connection.setClientID(\"test\");\n-        connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-\n-        try {\n-            connection.setClientID(\"test\");\n-            fail(\"Should have received JMSException\");\n-        } catch (JMSException e) {\n-        }\n-\n-        connection.close();\n-        connection = factory.createConnection();\n-        connection.setClientID(\"test\");\n-\n-        connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-\n-        try {\n-            connection.setClientID(\"test\");\n-            fail(\"Should have received JMSException\");\n-        } catch (JMSException e) {\n-        }\n-    }\n-\n-}"},{"sha":"93e0615c450ef57d921e436dcf4a60006ee6a8d4","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,84 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Connection;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.Topic;\n-\n-public class ConsumerReceiveWithTimeoutTest extends TestSupport {\n-\n-    private Connection connection;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Test to check if consumer thread wakes up inside a receive(timeout) after\n-     * a message is dispatched to the consumer\n-     *\n-     * @throws javax.jms.JMSException\n-     */\n-    public void testConsumerReceiveBeforeMessageDispatched() throws JMSException {\n-\n-        connection.start();\n-\n-        final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        final Topic queue = session.createTopic(\"test\");\n-        MessageConsumer consumer = session.createConsumer(queue);\n-\n-        Thread t = new Thread() {\n-            public void run() {\n-                try {\n-                    // wait for 10 seconds to allow consumer.receive to be run\n-                    // first\n-                    Thread.sleep(10000);\n-                    MessageProducer producer = session.createProducer(queue);\n-                    producer.send(session.createTextMessage(\"Hello\"));\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        };\n-\n-        t.start();\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(60000);\n-        assertNotNull(msg);\n-        session.close();\n-\n-    }\n-\n-}"},{"sha":"685683762a4f04fe6f96461784338e5fba4d7da7","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,61 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.util.concurrent.TimeUnit;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-\n-\n-\n-\n-\n-/**\n- * User: gtully\n- */\n-public class ExpiryHogTest extends JmsMultipleClientsTestSupport {\n-    boolean sleep = false;\n-\n-    int numMessages = 4;\n-\n-    public void testImmediateDispatchWhenCacheDisabled() throws Exception {\n-        ConnectionFactory f = createConnectionFactory();\n-        destination = createDestination();\n-        startConsumers(f, destination);\n-        sleep = true;\n-        this.startProducers(f, destination, numMessages);\n-        allMessagesList.assertMessagesReceived(numMessages);\n-    }\n-\n-    protected TextMessage createTextMessage(Session session, String initText) throws Exception {\n-        if (sleep) {\n-            TimeUnit.SECONDS.sleep(10);\n-        }\n-        TextMessage msg = super.createTextMessage(session, initText);\n-        // what is the point of setting this !\n-        // msg.setJMSExpiration(4000);\n-        return msg;\n-    }\n-\n-    @Override\n-    protected void setUp() throws Exception {\n-        autoFail = false;\n-        persistent = true;\n-        super.setUp();\n-    }\n-}"},{"sha":"408b40e7ff4eac752aa63ac1055cf288976be475","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java","status":"removed","additions":0,"deletions":936,"changes":936,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,936 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.lang.Thread.UncaughtExceptionHandler;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import javax.jms.BytesMessage;\n-import javax.jms.DeliveryMode;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-import javax.jms.Topic;\n-\n-\n-\n-\n-import junit.framework.Test;\n-\n-\n-import javax.jms.Destination;\n-\n-import org.apache.hedwig.jms.MessagingSessionFacade;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n-import org.junit.Ignore;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Test cases used to test the JMS message consumer.\n- */\n-public class JMSConsumerTest extends JmsTestSupport {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(JMSConsumerTest.class);\n-\n-    public Destination destination;\n-    public int deliveryMode;\n-    public int prefetch;\n-    public int ackMode;\n-    public MessagingSessionFacade.DestinationType destinationType;\n-    public boolean durableConsumer;\n-\n-    public static Test suite() {\n-        return suite(JMSConsumerTest.class);\n-    }\n-\n-    public static void main(String[] args) {\n-        junit.textui.TestRunner.run(suite());\n-    }\n-\n-    public void initCombosForTestMessageListenerWithConsumerCanBeStopped() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),\n-                                                           Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new MessagingSessionFacade.DestinationType[] {\n-                MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testMessageListenerWithConsumerCanBeStopped() throws Exception {\n-\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch done1 = new CountDownLatch(1);\n-        final CountDownLatch done2 = new CountDownLatch(1);\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = (MessageConsumer)session.createConsumer(destination);\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                counter.incrementAndGet();\n-                if (counter.get() == 1) {\n-                    done1.countDown();\n-                }\n-                if (counter.get() == 2) {\n-                    done2.countDown();\n-                }\n-            }\n-        });\n-\n-        // Send a first message to make sure that the consumer dispatcher is\n-        // running\n-        sendMessages(session, destination, 1);\n-        assertTrue(done1.await(1, TimeUnit.SECONDS));\n-        assertEquals(1, counter.get());\n-\n-        // Stop the consumer.\n-        connection.stop();\n-\n-        // Send a message, but should not get delivered.\n-        sendMessages(session, destination, 1);\n-        assertFalse(done2.await(1, TimeUnit.SECONDS));\n-        assertEquals(1, counter.get());\n-\n-        // Start the consumer, and the message should now get delivered.\n-        connection.start();\n-        assertTrue(done2.await(1, TimeUnit.SECONDS));\n-        assertEquals(2, counter.get());\n-    }\n-\n-    public void testMessageListenerWithConsumerCanBeStoppedConcurently() throws Exception {\n-\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch closeDone = new CountDownLatch(1);\n-\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n-\n-        final Map<Thread, Throwable> exceptions =\n-            Collections.synchronizedMap(new HashMap<Thread, Throwable>());\n-        Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {\n-            public void uncaughtException(Thread t, Throwable e) {\n-                LOG.error(\"Uncaught exception:\", e);\n-                exceptions.put(t, e);\n-            }\n-        });\n-\n-        final int numOutStanding = (connection.getHedwigClientConfig().getMaximumOutstandingMessages() * 2 / 3) + 1;\n-\n-        final MessageConsumer consumer = (MessageConsumer)session.createConsumer(destination);\n-\n-        final class AckAndClose implements Runnable {\n-            private Message message;\n-\n-            public AckAndClose(Message m) {\n-                this.message = m;\n-            }\n-\n-            public void run() {\n-                try {\n-                    message.acknowledge();\n-                    int count = counter.incrementAndGet();\n-                    if (590 == count) {\n-                        // close in a separate thread is ok by jms\n-                        consumer.close();\n-                        closeDone.countDown();\n-                    }\n-                } catch (Exception e) {\n-                    LOG.error(\"Exception on close or ack:\", e);\n-                    exceptions.put(Thread.currentThread(), e);\n-                }\n-            }\n-        };\n-\n-        final AtomicInteger listenerReceivedCount = new AtomicInteger(0);\n-        // final ExecutorService executor = Executors.newSingleThreadExecutor();\n-        final ExecutorService executor = Executors.newCachedThreadPool();\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                // close can be in a different thread, but NOT acknowledge iirc\n-                // - this will not cause a problem for us though ...\n-                // ack and close eventually in separate thread\n-                int val = listenerReceivedCount.incrementAndGet();\n-                // System.out.println(\"message count : \" + val + \", message : \" + m);\n-                executor.execute(new AckAndClose(m));\n-                // new AckAndClose(m).run();\n-            }\n-        });\n-\n-        // preload the queue\n-        sendMessages(session, destination, 600);\n-\n-        assert closeDone.await(10, TimeUnit.SECONDS) :\n-        \"closeDone : \" + closeDone.getCount() + \", counter : \" + counter.get()\n-            + \", listenerReceivedCount : \" + listenerReceivedCount.get();\n-        // await possible exceptions\n-        Thread.sleep(1000);\n-        assertTrue(\"no exceptions: \" + exceptions, exceptions.isEmpty());\n-    }\n-\n-\n-    public void initCombosForTestMutiReceiveWithPrefetch1() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"ackMode\", new Object[] {\n-                Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),\n-                Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testMutiReceiveWithPrefetch1() throws Exception {\n-\n-        // Set prefetch to 1\n-        connection.start();\n-\n-        // Use all the ack modes\n-        Session session = connection.createSession(false, ackMode);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        // Make sure 4 messages were delivered.\n-        Message message = null;\n-        for (int i = 0; i < 4; i++) {\n-            message = consumer.receive(1000);\n-            assertNotNull(message);\n-        }\n-        assertNull(consumer.receiveNoWait());\n-        assert null != message;\n-        message.acknowledge();\n-    }\n-\n-    public void initCombosForTestDurableConsumerSelectorChange() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testDurableConsumerSelectorChange() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test\");\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageProducer producer = session.createProducer(destination);\n-        producer.setDeliveryMode(deliveryMode);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic)destination, \"test\", \"color='red'\", false);\n-\n-        // Send the messages\n-        TextMessage message = session.createTextMessage(\"1st\");\n-        message.setStringProperty(\"color\", \"red\");\n-        producer.send(message);\n-\n-        Message m = consumer.receive(1000);\n-        assertNotNull(m);\n-        assertEquals(\"1st\", ((TextMessage)m).getText());\n-\n-        // Change the subscription.\n-        consumer.close();\n-        consumer = session.createDurableSubscriber((Topic)destination, \"test\", \"color='blue'\", false);\n-\n-        message = session.createTextMessage(\"2nd\");\n-        message.setStringProperty(\"color\", \"red\");\n-        producer.send(message);\n-        message = session.createTextMessage(\"3rd\");\n-        message.setStringProperty(\"color\", \"blue\");\n-        producer.send(message);\n-\n-        // Selector should skip the 2nd message.\n-        m = consumer.receive(1000);\n-        assertNotNull(m);\n-        assertEquals(\"3rd\", ((TextMessage)m).getText());\n-\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void initCombosForTestSendReceiveBytesMessage() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testSendReceiveBytesMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        BytesMessage message = session.createBytesMessage();\n-        message.writeBoolean(true);\n-        message.writeBoolean(false);\n-        producer.send(message);\n-\n-        // Make sure only 1 message was delivered.\n-        BytesMessage m = (BytesMessage)consumer.receive(1000);\n-        assertNotNull(m);\n-        assertTrue(m.readBoolean());\n-        assertFalse(m.readBoolean());\n-\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void initCombosForTestSetMessageListenerAfterStart() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testSetMessageListenerAfterStart() throws Exception {\n-\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch done = new CountDownLatch(1);\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        // See if the message get sent to the listener\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                counter.incrementAndGet();\n-                if (counter.get() == 4) {\n-                    done.countDown();\n-                }\n-            }\n-        });\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n-        Thread.sleep(200);\n-\n-        // Make sure only 4 messages were delivered.\n-        assertEquals(4, counter.get());\n-    }\n-\n-    public void initCombosForTestPassMessageListenerIntoCreateConsumer() {\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testPassMessageListenerIntoCreateConsumer() throws Exception {\n-\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch done = new CountDownLatch(1);\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        SessionImpl session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                counter.incrementAndGet();\n-                if (counter.get() == 4) {\n-                    done.countDown();\n-                }\n-            }\n-        });\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n-        Thread.sleep(200);\n-\n-        // Make sure only 4 messages were delivered.\n-        assertEquals(4, counter.get());\n-    }\n-\n-    public void initCombosForTestMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"ackMode\", new Object[] {Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() throws Exception {\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch sendDone = new CountDownLatch(1);\n-        final CountDownLatch got2Done = new CountDownLatch(1);\n-\n-        // Set prefetch to 1\n-        // This test case does not work if optimized message dispatch is used as\n-        // the main thread send block until the consumer receives the\n-        // message. This test depends on thread decoupling so that the main\n-        // thread can stop the consumer thread.\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-1\");\n-        connection.start();\n-\n-        // Use all the ack modes\n-        Session session = connection.createSession(false, ackMode);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n-        consumer.setMessageListener(new MessageListener() {\n-            private final HedwigConnectionImpl _connection = connection;\n-            public void onMessage(Message m) {\n-                try {\n-                    TextMessage tm = (TextMessage)m;\n-                    LOG.info(\"Got in first listener: \" + tm.getText());\n-                    assertEquals(messageTextPrefix + counter.get(), tm.getText());\n-                    counter.incrementAndGet();\n-                    if (counter.get() == 2) {\n-                        sendDone.await();\n-                        _connection.close();\n-                        got2Done.countDown();\n-                    }\n-                    // will fail when we close connection when counter == 2 !\n-                    tm.acknowledge();\n-                } catch (Throwable e) {\n-                    // e.printStackTrace();\n-                }\n-            }\n-        });\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-        sendDone.countDown();\n-\n-        // Wait for first 2 messages to arrive.\n-        assert got2Done.await(5, TimeUnit.SECONDS) :\n-        \"counter1 : \" + counter.get() + \", got2Done : \" + got2Done.getCount() + \", sendDone : \" + sendDone.getCount();\n-\n-        // Re-start connection.\n-        connection.close();\n-        connection = (HedwigConnectionImpl)factory.createConnection();\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-1\");\n-        connections.add(connection);\n-\n-        // Pickup the remaining messages.\n-        final CountDownLatch done2 = new CountDownLatch(1);\n-        session = connection.createSession(false, ackMode);\n-        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                try {\n-                    TextMessage tm = (TextMessage)m;\n-                    LOG.info(\"Got in second listener: \" + tm.getText());\n-                    // order is not guaranteed as the connection is started before the listener is set.\n-                    // assertEquals(messageTextPrefix + counter.get(), tm.getText());\n-                    counter.incrementAndGet();\n-                    tm.acknowledge();\n-                    if (counter.get() == 4) {\n-                        done2.countDown();\n-                    }\n-                } catch (Throwable e) {\n-                    LOG.error(\"unexpected ex onMessage: \", e);\n-                }\n-            }\n-        });\n-\n-        connection.start();\n-\n-        assert done2.await(2000, TimeUnit.MILLISECONDS) :\n-        \"count2 : \" + done2.getCount() + \", counter : \" + counter.get();\n-        Thread.sleep(200);\n-\n-        // assert msg 2 was redelivered as close() from onMessages() will only ack in auto_ack and dups_ok mode\n-        assert 5 == counter.get(): \"count3 : \" + done2.getCount() + \", counter : \" + counter.get();\n-    }\n-\n-    public void initCombosForTestMessageListenerAutoAckOnCloseWithPrefetch1() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"ackMode\", new Object[] {\n-                Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testMessageListenerAutoAckOnCloseWithPrefetch1() throws Exception {\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch sendDone = new CountDownLatch(1);\n-        final CountDownLatch got2Done = new CountDownLatch(1);\n-\n-        // Set prefetch to 1\n-        // This test case does not work if optimized message dispatch is used as\n-        // the main thread send block until the consumer receives the\n-        // message. This test depends on thread decoupling so that the main\n-        // thread can stop the consumer thread.\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-2\");\n-        connection.start();\n-\n-        // Use all the ack modes\n-        Session session = connection.createSession(false, ackMode);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n-        final List<Message> receivedMessages = new ArrayList<Message>(8);\n-        consumer.setMessageListener(new MessageListener() {\n-            final HedwigConnectionImpl _connection = connection;\n-            public void onMessage(Message m) {\n-                try {\n-                    TextMessage tm = (TextMessage)m;\n-                    LOG.info(\"Got in first listener: \" + tm.getText());\n-                    assertEquals(messageTextPrefix + counter.get(), tm.getText());\n-                    counter.incrementAndGet();\n-                    m.acknowledge();\n-                    receivedMessages.add(m);\n-                    if (counter.get() == 2) {\n-                        sendDone.await();\n-                        _connection.close();\n-                        got2Done.countDown();\n-                    }\n-                } catch (Throwable e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        });\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-        sendDone.countDown();\n-\n-        // Wait for first 2 messages to arrive.\n-        assert got2Done.await(5, TimeUnit.SECONDS) :\n-        \"counter : \" + counter.get() + \", got2Done : \" + got2Done.getCount() + \", sendDone : \" + sendDone.getCount();\n-\n-        // Re-start connection.\n-        connection.close();\n-        connection = (HedwigConnectionImpl)factory.createConnection();\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-2\");\n-        connections.add(connection);\n-\n-        // Pickup the remaining messages.\n-        final CountDownLatch done2 = new CountDownLatch(1);\n-        session = connection.createSession(false, ackMode);\n-        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                try {\n-                    TextMessage tm = (TextMessage)m;\n-                    LOG.info(\"Got in second listener: \" + tm.getText());\n-                    counter.incrementAndGet();\n-                    m.acknowledge();\n-                    receivedMessages.add(m);\n-                    if (counter.get() == 4) {\n-                        done2.countDown();\n-                    }\n-                } catch (Throwable e) {\n-                    LOG.error(\"unexpected ex onMessage: \", e);\n-                }\n-            }\n-        });\n-\n-        connection.start();\n-\n-        assert done2.await(5, TimeUnit.SECONDS) : \"count : \" + done2.getCount() + \", counter : \" + counter.get();\n-        Thread.sleep(200);\n-\n-        // close from onMessage with Auto_ack will ack\n-        // Make sure only 4 messages were delivered.\n-        assert 4 == counter.get() :\n-        \"counter : \" + counter.get() + \", got2Done : \" + got2Done.getCount() + \", sendDone : \"\n-            + sendDone.getCount() + \", messages : \" + receivedMessages;\n-    }\n-\n-    public void initCombosForTestMessageListenerWithConsumerWithPrefetch1() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testMessageListenerWithConsumerWithPrefetch1() throws Exception {\n-\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch done = new CountDownLatch(1);\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                counter.incrementAndGet();\n-                if (counter.get() == 4) {\n-                    done.countDown();\n-                }\n-            }\n-        });\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n-        Thread.sleep(200);\n-\n-        // Make sure only 4 messages were delivered.\n-        assertEquals(4, counter.get());\n-    }\n-\n-    public void initCombosForTestMessageListenerWithConsumer() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testMessageListenerWithConsumer() throws Exception {\n-\n-        final AtomicInteger counter = new AtomicInteger(0);\n-        final CountDownLatch done = new CountDownLatch(1);\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        consumer.setMessageListener(new MessageListener() {\n-            public void onMessage(Message m) {\n-                counter.incrementAndGet();\n-                if (counter.get() == 4) {\n-                    done.countDown();\n-                }\n-            }\n-        });\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n-        Thread.sleep(200);\n-\n-        // Make sure only 4 messages were delivered.\n-        assertEquals(4, counter.get());\n-    }\n-\n-    public void initCombosForTestUnackedWithPrefetch1StayInQueue() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"ackMode\", new Object[] {\n-                Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),\n-                Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testUnackedWithPrefetch1StayInQueue() throws Exception {\n-\n-        // Set prefetch to 1\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-3\");\n-        connection.start();\n-\n-        // Use all the ack modes\n-        Session session = connection.createSession(false, ackMode);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id3\");\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        // Only pick up the first 2 messages.\n-        Message message = null;\n-        for (int i = 0; i < 2; i++) {\n-            message = consumer.receive(1000);\n-            assertNotNull(message);\n-            assert (message instanceof TextMessage);\n-            assert (((TextMessage) message).getText().equals(messageTextPrefix  + i))\n-                : \"Received message \" + ((TextMessage) message).getText() + \" .. i = \" + i;\n-        }\n-        assert null != message;\n-        message.acknowledge();\n-\n-        connection.close();\n-        connection = (HedwigConnectionImpl)factory.createConnection();\n-        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-3\");\n-        // Use all the ack modes\n-        session = connection.createSession(false, ackMode);\n-        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id3\");\n-        connections.add(connection);\n-        connection.start();\n-\n-        // Pickup the rest of the messages.\n-        for (int i = 0; i < 2; i++) {\n-            message = consumer.receive(1000);\n-            assertNotNull(message);\n-            assert (message instanceof TextMessage);\n-            assert (((TextMessage) message).getText().equals(messageTextPrefix  + (i + 2))) :\n-            \"Received message \" + ((TextMessage) message).getText() + \" .. i = \" + i;\n-        }\n-        message.acknowledge();\n-        // assertNull(consumer.receiveNoWait());\n-        {\n-            Message msg = consumer.receiveNoWait();\n-            assert null == msg : \"Unexpected message \" + msg;\n-        }\n-\n-    }\n-\n-    public void initCombosForTestPrefetch1MessageNotDispatched() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-    }\n-\n-    public void testPrefetch1MessageNotDispatched() throws Exception {\n-\n-        // Set prefetch to 1\n-        connection.start();\n-\n-        Session session = connection.createSession(true, 0);\n-        destination = SessionImpl.asTopic(\"TEST\");\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        // The prefetch should fill up with 1 message.\n-        // Since prefetch is still full, the 2nd message should get dispatched\n-        // to another consumer.. lets create the 2nd consumer test that it does\n-        // make sure it does.\n-        HedwigConnectionImpl connection2 = (HedwigConnectionImpl)factory.createConnection();\n-        connection2.start();\n-        connections.add(connection2);\n-        Session session2 = connection2.createSession(true, 0);\n-        MessageConsumer consumer2 = session2.createConsumer(destination);\n-\n-        // Send 2 messages to the destination.\n-        sendMessages(session, destination, 2);\n-        session.commit();\n-\n-        // Pick up the first message.\n-        Message message1 = consumer.receive(1000);\n-        assertNotNull(message1);\n-        assertNotNull(consumer.receive(1000));\n-\n-        // Pick up the 2nd messages.\n-        Message message2 = consumer2.receive(5000);\n-        assertNotNull(message2);\n-        assertNotNull(consumer2.receive(1000));\n-\n-        session.commit();\n-        session2.commit();\n-\n-        assertNull(consumer.receiveNoWait());\n-\n-    }\n-\n-    public void initCombosForTestDontStart() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] { MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testDontStart() throws Exception {\n-\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        // Send the messages\n-        sendMessages(session, destination, 1);\n-\n-        // Make sure no messages were delivered.\n-        assertNull(consumer.receive(1000));\n-    }\n-\n-    public void initCombosForTestStartAfterSend() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testStartAfterSend() throws Exception {\n-\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        // Send the messages\n-        sendMessages(session, destination, 1);\n-\n-        // Start the conncection after the message was sent.\n-        connection.start();\n-\n-        // Make sure only 1 message was delivered.\n-        assertNotNull(consumer.receive(1000));\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void initCombosForTestReceiveMessageWithConsumer() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testReceiveMessageWithConsumer() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        // Send the messages\n-        sendMessages(session, destination, 1);\n-\n-        // Make sure only 1 message was delivered.\n-        Message m = consumer.receive(1000);\n-        assertNotNull(m);\n-        assertEquals(\"0\", ((TextMessage)m).getText());\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-\n-    public void testDupsOkConsumer() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);\n-        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id4\");\n-\n-        // Send the messages\n-        sendMessages(session, destination, 4);\n-\n-        // Make sure only 4 message are delivered.\n-        for( int i=0; i < 4; i++){\n-            Message m = consumer.receive(1000);\n-            assertNotNull(m);\n-        }\n-        assertNull(consumer.receive(1000));\n-\n-        // Close out the consumer.. no other messages should be left on the queue.\n-        consumer.close();\n-\n-        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id4\");\n-        assertNull(consumer.receive(1000));\n-    }\n-\n-    public void testRedispatchOfUncommittedTx() throws Exception {\n-\n-        connection.start();\n-        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n-\n-        sendMessages(connection, destination, 2);\n-\n-        assertNotNull(consumer.receive(1000));\n-        assertNotNull(consumer.receive(1000));\n-\n-        // install another consumer while message dispatch is unacked/uncommitted\n-\n-        // no commit so will auto rollback and get re-dispatched to redisptachConsumer\n-        session.close();\n-\n-        Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        MessageConsumer redispatchConsumer\n-            = redispatchSession.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n-\n-        Message msg = redispatchConsumer.receive(1000);\n-        assertNotNull(msg);\n-        // assertTrue(\"redelivered flag set\", msg.getJMSRedelivered());\n-\n-        msg = redispatchConsumer.receive(1000);\n-        assertNotNull(msg);\n-        // assertTrue(msg.getJMSRedelivered());\n-        redispatchSession.commit();\n-\n-        assertNull(redispatchConsumer.receive(500));\n-        redispatchSession.close();\n-    }\n-\n-\n-    public void testRedispatchOfRolledbackTx() throws Exception {\n-\n-        connection.start();\n-        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n-\n-        sendMessages(connection, destination, 2);\n-\n-        assertNotNull(consumer.receive(1000));\n-        assertNotNull(consumer.receive(1000));\n-\n-        // install another consumer while message dispatch is unacked/uncommitted\n-\n-        session.rollback();\n-        session.close();\n-\n-        Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        MessageConsumer redispatchConsumer\n-            = redispatchSession.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n-\n-        Message msg = redispatchConsumer.receive(1000);\n-        assertNotNull(msg);\n-        // assertTrue(msg.getJMSRedelivered());\n-        msg = redispatchConsumer.receive(1000);\n-        assertNotNull(msg);\n-        // assertTrue(msg.getJMSRedelivered());\n-        redispatchSession.commit();\n-\n-        assertNull(redispatchConsumer.receive(500));\n-        redispatchSession.close();\n-    }\n-\n-    public void initCombosForTestAckOfExpired() {\n-        addCombinationValues(\"destinationType\",\n-                new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testAckOfExpired() throws Exception {\n-        HedwigConnectionFactoryImpl fact = new HedwigConnectionFactoryImpl();\n-        connection = fact.createConnection();\n-\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = (Destination) (destinationType == MessagingSessionFacade.DestinationType.QUEUE ?\n-                session.createTopic(\"test\") : session.createTopic(\"test\"));\n-\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-            MessageProducer producer = sendSession.createProducer(destination);\n-        final int count = 4;\n-\n-\n-        // producer.setTimeToLive(0);\n-        for (int i = 0; i < count; i++) {\n-            TextMessage message = sendSession.createTextMessage(\"no expiry\" + i);\n-            producer.send(message);\n-        }\n-\n-        MessageConsumer amqConsumer = (MessageConsumer) consumer;\n-\n-        for(int i=0; i<count; i++) {\n-            TextMessage msg = (TextMessage) amqConsumer.receive();\n-            assertNotNull(msg);\n-            assertTrue(\"message has \\\"no expiry\\\" text: \" + msg.getText(), msg.getText().contains(\"no expiry\"));\n-\n-            // force an ack when there are expired messages\n-            msg.acknowledge();\n-        }\n-    }\n-}"},{"sha":"343919a9573575613b2779b50fc9e24406dbaebf","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java","status":"removed","additions":0,"deletions":76,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,76 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import javax.jms.Message;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class JMSDurableTopicRedeliverTest extends JmsTopicRedeliverTest {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(JMSDurableTopicRedeliverTest.class);\n-\n-    protected void setUp() throws Exception {\n-        durable = true;\n-        super.setUp();\n-    }\n-\n-    /**\n-     * Sends and consumes the messages.\n-     *\n-     * @throws Exception\n-     */\n-    public void testRedeliverNewSession() throws Exception {\n-        String text = \"TEST: \" + System.currentTimeMillis();\n-        Message sendMessage = session.createTextMessage(text);\n-\n-        if (verbose) {\n-            LOG.info(\"About to send a message: \" + sendMessage + \" with text: \" + text);\n-        }\n-        producer.send(producerDestination, sendMessage);\n-\n-        // receive but don't acknowledge\n-        Message unackMessage = consumer.receive(1000);\n-        assertNotNull(unackMessage);\n-        String unackId = unackMessage.getJMSMessageID();\n-        assertEquals(((TextMessage)unackMessage).getText(), text);\n-        assertFalse(unackMessage.getJMSRedelivered());\n-        consumeSession.close();\n-        consumer.close();\n-\n-        // receive then acknowledge\n-        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        consumer = createConsumer();\n-        Message ackMessage = consumer.receive(1000);\n-        assertNotNull(ackMessage);\n-        ackMessage.acknowledge();\n-        String ackId = ackMessage.getJMSMessageID();\n-        assertEquals(((TextMessage)ackMessage).getText(), text);\n-        // assertTrue(ackMessage.getJMSRedelivered());\n-        assertEquals(unackId, ackId);\n-        consumeSession.close();\n-        consumer.close();\n-\n-        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        consumer = createConsumer();\n-        assertNull(consumer.receive(1000));\n-    }\n-}"},{"sha":"24551f381c3b57af08a2ebfea57a7955eae2c48e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java","status":"removed","additions":0,"deletions":165,"changes":165,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,165 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Connection;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-import javax.jms.Topic;\n-\n-/**\n- *\n- */\n-public class JMSIndividualAckTest extends TestSupport {\n-\n-    private Connection connection;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if acknowledged messages are being consumed.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testAckedMessageAreConsumed() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getQueueName());\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        // Reset the session.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        msg = consumer.receive(1000);\n-        assertNull(msg);\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests if acknowledged messages are being consumed.\n-     *\n-     * @throws JMSException\n-     */\n-    // This test cant, unfortunately, pass\n-    //- in hedwig, acknowledge is a ACKNOWLEDGE UNTIL. So the last ack will ack all messages until then ...\n-    /*\n-    public void testLastMessageAcked() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getQueueName());\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        TextMessage msg1 = session.createTextMessage(\"msg1\");\n-        TextMessage msg2 = session.createTextMessage(\"msg2\");\n-        TextMessage msg3 = session.createTextMessage(\"msg3\");\n-        producer.send(msg1);\n-        producer.send(msg2);\n-        producer.send(msg3);\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        // Reset the session.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertEquals(msg1,msg);\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertEquals(msg2,msg);\n-        msg = consumer.receive(1000);\n-        assertNull(msg);\n-        session.close();\n-    }\n-    */\n-\n-    /**\n-     * Tests if unacknowledged messages are being re-delivered when the consumer connects again.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testUnAckedMessageAreNotConsumedOnSessionClose() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getQueueName());\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        // Don't ack the message.\n-\n-        // Reset the session.  This should cause the unacknowledged message to be re-delivered.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-    protected String getQueueName() {\n-        return getClass().getName() + \".\" + getName();\n-    }\n-\n-}"},{"sha":"cee1698ada8286ea408c2f45ea72f7fe2b4d1a27","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java","status":"removed","additions":0,"deletions":504,"changes":504,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,504 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.net.URISyntaxException;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Vector;\n-\n-import javax.jms.BytesMessage;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.MapMessage;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageEOFException;\n-import javax.jms.MessageFormatException;\n-import javax.jms.MessageProducer;\n-import javax.jms.ObjectMessage;\n-import javax.jms.Session;\n-import javax.jms.StreamMessage;\n-import javax.jms.TextMessage;\n-\n-import junit.framework.Test;\n-import org.apache.hedwig.jms.MessagingSessionFacade;\n-import org.apache.hedwig.jms.message.StreamMessageImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-\n-import javax.jms.Destination;\n-\n-/**\n- * Test cases used to test the JMS message consumer.\n- */\n-public class JMSMessageTest extends JmsTestSupport {\n-\n-    public Destination destination;\n-    public int deliveryMode = DeliveryMode.NON_PERSISTENT;\n-    public int prefetch;\n-    public int ackMode;\n-    public MessagingSessionFacade.DestinationType destinationType = MessagingSessionFacade.DestinationType.TOPIC;\n-    public boolean durableConsumer;\n-\n-    /**\n-     * Run all these tests in both marshaling and non-marshaling mode.\n-     */\n-    public void initCombos() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),\n-                                                           Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testTextMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // Send the message.\n-        {\n-            TextMessage message = session.createTextMessage();\n-            message.setText(\"Hi\");\n-            producer.send(message);\n-        }\n-\n-        // Check the Message\n-        {\n-            TextMessage message = (TextMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-            assertEquals(\"Hi\", message.getText());\n-        }\n-\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public static Test suite() {\n-        return suite(JMSMessageTest.class);\n-    }\n-\n-    public static void main(String[] args) {\n-        junit.textui.TestRunner.run(suite());\n-    }\n-\n-    protected ConnectionFactory createConnectionFactory() throws URISyntaxException {\n-        HedwigConnectionFactoryImpl factory = new HedwigConnectionFactoryImpl();\n-        return factory;\n-    }\n-\n-    public void testBytesMessageLength() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // Send the message\n-        {\n-            BytesMessage message = session.createBytesMessage();\n-            message.writeInt(1);\n-            message.writeInt(2);\n-            message.writeInt(3);\n-            message.writeInt(4);\n-            producer.send(message);\n-        }\n-\n-        // Check the message.\n-        {\n-            BytesMessage message = (BytesMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-            assertEquals(16, message.getBodyLength());\n-        }\n-\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void testObjectMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // send the message.\n-        {\n-            ObjectMessage message = session.createObjectMessage();\n-            message.setObject(\"Hi\");\n-            producer.send(message);\n-        }\n-\n-        // Check the message\n-        {\n-            ObjectMessage message = (ObjectMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-            assertEquals(\"Hi\", message.getObject());\n-        }\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void testBytesMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // Send the message\n-        {\n-            BytesMessage message = session.createBytesMessage();\n-            message.writeBoolean(true);\n-            producer.send(message);\n-        }\n-\n-        // Check the message\n-        {\n-            BytesMessage message = (BytesMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-            assertTrue(message.readBoolean());\n-\n-            try {\n-                message.readByte();\n-                fail(\"Expected exception not thrown.\");\n-            } catch (MessageEOFException e) {\n-            }\n-\n-        }\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void testStreamMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // Send the message.\n-        {\n-            StreamMessage message = session.createStreamMessage();\n-            message.writeString(\"This is a test to see how it works.\");\n-            producer.send(message);\n-        }\n-\n-        // Check the message.\n-        {\n-            StreamMessage message = (StreamMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-\n-            // Invalid conversion should throw exception and not move the stream\n-            // position.\n-            try {\n-                message.readByte();\n-                fail(\"Should have received NumberFormatException\");\n-            } catch (NumberFormatException e) {\n-            } catch (MessageFormatException e) {\n-            }\n-\n-            assertEquals(\"This is a test to see how it works.\", message.readString());\n-\n-            // Invalid conversion should throw exception and not move the stream\n-            // position.\n-            try {\n-                message.readByte();\n-                fail(\"Should have received MessageEOFException\");\n-            } catch (MessageEOFException e) {\n-            }\n-        }\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void testMapMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // send the message.\n-        {\n-            MapMessage message = session.createMapMessage();\n-            message.setBoolean(\"boolKey\", true);\n-            producer.send(message);\n-        }\n-\n-        // get the message.\n-        {\n-            MapMessage message = (MapMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-            assertTrue(message.getBoolean(\"boolKey\"));\n-        }\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    static class ForeignMessage implements TextMessage {\n-\n-        public int deliveryMode;\n-\n-        private String messageId;\n-        private long timestamp;\n-        private String correlationId;\n-        private Destination replyTo;\n-        private Destination destination;\n-        private boolean redelivered;\n-        private String type;\n-        private long expiration;\n-        private int priority;\n-        private String text;\n-        private HashMap<String, Object> props = new HashMap<String, Object>();\n-\n-        public String getJMSMessageID() throws JMSException {\n-            return messageId;\n-        }\n-\n-        public void setJMSMessageID(String arg0) throws JMSException {\n-            messageId = arg0;\n-        }\n-\n-        public long getJMSTimestamp() throws JMSException {\n-            return timestamp;\n-        }\n-\n-        public void setJMSTimestamp(long arg0) throws JMSException {\n-            timestamp = arg0;\n-        }\n-\n-        public byte[] getJMSCorrelationIDAsBytes() throws JMSException {\n-            return null;\n-        }\n-\n-        public void setJMSCorrelationIDAsBytes(byte[] arg0) throws JMSException {\n-        }\n-\n-        public void setJMSCorrelationID(String arg0) throws JMSException {\n-            correlationId = arg0;\n-        }\n-\n-        public String getJMSCorrelationID() throws JMSException {\n-            return correlationId;\n-        }\n-\n-        public Destination getJMSReplyTo() throws JMSException {\n-            return replyTo;\n-        }\n-\n-        public void setJMSReplyTo(Destination arg0) throws JMSException {\n-            replyTo = arg0;\n-        }\n-\n-        public Destination getJMSDestination() throws JMSException {\n-            return destination;\n-        }\n-\n-        public void setJMSDestination(Destination arg0) throws JMSException {\n-            destination = arg0;\n-        }\n-\n-        public int getJMSDeliveryMode() throws JMSException {\n-            return deliveryMode;\n-        }\n-\n-        public void setJMSDeliveryMode(int arg0) throws JMSException {\n-            deliveryMode = arg0;\n-        }\n-\n-        public boolean getJMSRedelivered() throws JMSException {\n-            return redelivered;\n-        }\n-\n-        public void setJMSRedelivered(boolean arg0) throws JMSException {\n-            redelivered = arg0;\n-        }\n-\n-        public String getJMSType() throws JMSException {\n-            return type;\n-        }\n-\n-        public void setJMSType(String arg0) throws JMSException {\n-            type = arg0;\n-        }\n-\n-        public long getJMSExpiration() throws JMSException {\n-            return expiration;\n-        }\n-\n-        public void setJMSExpiration(long arg0) throws JMSException {\n-            expiration = arg0;\n-        }\n-\n-        public int getJMSPriority() throws JMSException {\n-            return priority;\n-        }\n-\n-        public void setJMSPriority(int arg0) throws JMSException {\n-            priority = arg0;\n-        }\n-\n-        public void clearProperties() throws JMSException {\n-        }\n-\n-        public boolean propertyExists(String arg0) throws JMSException {\n-            return false;\n-        }\n-\n-        public boolean getBooleanProperty(String arg0) throws JMSException {\n-            return false;\n-        }\n-\n-        public byte getByteProperty(String arg0) throws JMSException {\n-            return 0;\n-        }\n-\n-        public short getShortProperty(String arg0) throws JMSException {\n-            return 0;\n-        }\n-\n-        public int getIntProperty(String arg0) throws JMSException {\n-            return 0;\n-        }\n-\n-        public long getLongProperty(String arg0) throws JMSException {\n-            return 0;\n-        }\n-\n-        public float getFloatProperty(String arg0) throws JMSException {\n-            return 0;\n-        }\n-\n-        public double getDoubleProperty(String arg0) throws JMSException {\n-            return 0;\n-        }\n-\n-        public String getStringProperty(String arg0) throws JMSException {\n-            return (String)props.get(arg0);\n-        }\n-\n-        public Object getObjectProperty(String arg0) throws JMSException {\n-            return props.get(arg0);\n-        }\n-\n-        public Enumeration getPropertyNames() throws JMSException {\n-            return new Vector<String>(props.keySet()).elements();\n-        }\n-\n-        public void setBooleanProperty(String arg0, boolean arg1) throws JMSException {\n-        }\n-\n-        public void setByteProperty(String arg0, byte arg1) throws JMSException {\n-        }\n-\n-        public void setShortProperty(String arg0, short arg1) throws JMSException {\n-        }\n-\n-        public void setIntProperty(String arg0, int arg1) throws JMSException {\n-        }\n-\n-        public void setLongProperty(String arg0, long arg1) throws JMSException {\n-        }\n-\n-        public void setFloatProperty(String arg0, float arg1) throws JMSException {\n-        }\n-\n-        public void setDoubleProperty(String arg0, double arg1) throws JMSException {\n-        }\n-\n-        public void setStringProperty(String arg0, String arg1) throws JMSException {\n-            props.put(arg0, arg1);\n-        }\n-\n-        public void setObjectProperty(String arg0, Object arg1) throws JMSException {\n-            props.put(arg0, arg1);\n-        }\n-\n-        public void acknowledge() throws JMSException {\n-        }\n-\n-        public void clearBody() throws JMSException {\n-        }\n-\n-        public void setText(String arg0) throws JMSException {\n-            text = arg0;\n-        }\n-\n-        public String getText() throws JMSException {\n-            return text;\n-        }\n-    }\n-\n-    public void testForeignMessage() throws Exception {\n-\n-        // Receive a message with the JMS API\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageProducer producer = session.createProducer(destination);\n-\n-        // Send the message.\n-        {\n-            ForeignMessage message = new ForeignMessage();\n-            message.text = \"Hello\";\n-            message.setStringProperty(\"test\", \"value\");\n-            // long timeToLive = 10000L;\n-            long timeToLive = 0L;\n-            long start = System.currentTimeMillis();\n-            producer.send(message, Session.AUTO_ACKNOWLEDGE, 7, timeToLive);\n-            long end = System.currentTimeMillis();\n-\n-\n-            //validate jms spec 1.1 section 3.4.11 table 3.1\n-            // JMSDestination, JMSDeliveryMode,  JMSPriority, JMSMessageID, and JMSTimestamp\n-            //must be set by sending a message.\n-\n-            // This is NOT specified in the spec !\n-            // exception for jms destination as the format is provider defined so it is only set on the copy\n-            // assertNull(message.getJMSDestination());\n-\n-            assertEquals(Session.AUTO_ACKNOWLEDGE, message.getJMSDeliveryMode());\n-            // assertTrue(start  + timeToLive <= message.getJMSExpiration());\n-            // assertTrue(end + timeToLive >= message.getJMSExpiration());\n-            assertEquals(7, message.getJMSPriority());\n-            assertNotNull(message.getJMSMessageID());\n-            assertTrue(start <= message.getJMSTimestamp());\n-            assertTrue(end >= message.getJMSTimestamp());\n-        }\n-\n-        // Validate message is OK.\n-        {\n-            TextMessage message = (TextMessage)consumer.receive(1000);\n-            assertNotNull(message);\n-            assertEquals(\"Hello\", message.getText());\n-            assertEquals(\"value\", message.getStringProperty(\"test\"));\n-        }\n-\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-}"},{"sha":"cadb071d5ade1de32dbf691998e5acb45b1e8948","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java","status":"removed","additions":0,"deletions":109,"changes":109,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,109 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.DeliveryMode;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-\n-import junit.framework.Test;\n-\n-import javax.jms.Destination;\n-\n-import org.apache.hedwig.jms.MessagingSessionFacade;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.message.MessageImpl;\n-\n-public class JMSUsecaseTest extends JmsTestSupport {\n-\n-    public Destination destination;\n-    public int deliveryMode;\n-    public int prefetch;\n-    public MessagingSessionFacade.DestinationType destinationType;\n-    public boolean durableConsumer;\n-\n-    public static Test suite() {\n-        return suite(JMSUsecaseTest.class);\n-    }\n-\n-    public static void main(String[] args) {\n-        junit.textui.TestRunner.run(suite());\n-    }\n-\n-    public void initCombosForTestSendReceive() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testSendReceive() throws Exception {\n-        // Send a message to the broker.\n-        connection.start();\n-        SessionImpl session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        destination = createDestination(session, destinationType);\n-        MessageProducer producer = session.createProducer(destination);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        MessageImpl message = new MessageImpl(session);\n-        producer.send(message);\n-\n-        // Make sure only 1 message was delivered.\n-        assertNotNull(consumer.receive(1000));\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-    public void initCombosForTestSendReceiveTransacted() {\n-        addCombinationValues(\"deliveryMode\", new Object[] {\n-                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n-        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n-    }\n-\n-    public void testSendReceiveTransacted() throws Exception {\n-        // Send a message to the broker.\n-        connection.start();\n-        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        destination = createDestination(session, destinationType);\n-        MessageProducer producer = session.createProducer(destination);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        producer.send(session.createTextMessage(\"test\"));\n-\n-        // Message should not be delivered until commit.\n-        assertNull(consumer.receiveNoWait());\n-        session.commit();\n-\n-        // Make sure only 1 message was delivered.\n-        Message message = consumer.receive(1000);\n-        assertNotNull(message);\n-        assertFalse(message.getJMSRedelivered());\n-        assertNull(consumer.receiveNoWait());\n-\n-        // Message should be redelivered is rollback is used.\n-        session.rollback();\n-\n-        // Make sure only 1 message was delivered.\n-        message = consumer.receive(2000);\n-        assertNotNull(message);\n-        assertTrue(message.getJMSRedelivered());\n-        assertNull(consumer.receiveNoWait());\n-\n-        // If we commit now, the message should not be redelivered.\n-        session.commit();\n-        assertNull(consumer.receiveNoWait());\n-    }\n-\n-}"},{"sha":"ec5243f6725bb237f35a5b38d3149793e68470db","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,77 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import javax.jms.Connection;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-\n-public class JmsAutoAckListenerTest extends TestSupport implements MessageListener {\n-\n-    private Connection connection;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if acknowleged messages are being consumed.\n-     *\n-     * @throws javax.jms.JMSException\n-     */\n-    public void testAckedMessageAreConsumed() throws Exception {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"test\");\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        consumer.setMessageListener(this);\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-\n-        Thread.sleep(10000);\n-        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        // Attempt to Consume the message...check if message was acknowledge\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        Message msg = consumer.receive(1000);\n-        assertNull(msg);\n-\n-        session.close();\n-    }\n-\n-    public void onMessage(Message message) {\n-        assertNotNull(message);\n-\n-    }\n-}"},{"sha":"13eaa2742f91df69d586b5e006eed437160b81d7","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java","status":"removed","additions":0,"deletions":75,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,75 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import javax.jms.Connection;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-\n-public class JmsAutoAckTest extends TestSupport {\n-\n-    private Connection connection;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if acknowleged messages are being consumed.\n-     *\n-     * @throws javax.jms.JMSException\n-     */\n-    public void testAckedMessageAreConsumed() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"test\");\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-\n-        // Reset the session.\n-        session.close();\n-        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        msg = consumer.receive(1000);\n-        assertNull(msg);\n-\n-        session.close();\n-    }\n-}"},{"sha":"dd914b5f2fda3e934a93539c8a2bfa35e8d17cb2","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java","status":"removed","additions":0,"deletions":204,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,204 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import javax.jms.BytesMessage;\n-import javax.jms.Connection;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.DeliveryMode;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-\n-import junit.framework.Test;\n-\n-\n-\n-import javax.jms.Destination;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Benchmarks the broker by starting many consumer and producers against the\n- * same destination. Make sure you run with jvm option -server (makes a big\n- * difference). The tests simulate storing 1000 1k jms messages to see the rate\n- * of processing msg/sec.\n- */\n-public class JmsBenchmark extends JmsTestSupport {\n-    private static final transient Logger LOG = LoggerFactory.getLogger(JmsBenchmark.class);\n-\n-    private static final long SAMPLE_DELAY = Integer.parseInt(System.getProperty(\"SAMPLE_DELAY\", \"\" + 1000 * 5));\n-    private static final long SAMPLES = Integer.parseInt(System.getProperty(\"SAMPLES\", \"10\"));\n-    private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\",\n-                                                                                    \"\" + 1000 * 60));\n-    private static final int PRODUCER_COUNT = Integer.parseInt(System.getProperty(\"PRODUCER_COUNT\", \"10\"));\n-    private static final int CONSUMER_COUNT = Integer.parseInt(System.getProperty(\"CONSUMER_COUNT\", \"10\"));\n-\n-    public Destination destination;\n-\n-    public static Test suite() {\n-        return suite(JmsBenchmark.class);\n-    }\n-\n-    public static void main(String[] args) {\n-        junit.textui.TestRunner.run(JmsBenchmark.class);\n-    }\n-\n-    public void initCombos() {\n-        addCombinationValues(\"destination\", new Object[] {SessionImpl.asTopic(\"TEST\")});\n-    }\n-\n-    protected ConnectionFactory createConnectionFactory() throws URISyntaxException, IOException {\n-        return new HedwigConnectionFactoryImpl();\n-    }\n-\n-    /**\n-     * @throws Throwable\n-     */\n-    public void testConcurrentSendReceive() throws Throwable {\n-\n-        final Semaphore connectionsEstablished = new Semaphore(1 - (CONSUMER_COUNT + PRODUCER_COUNT));\n-        final Semaphore workerDone = new Semaphore(1 - (CONSUMER_COUNT + PRODUCER_COUNT));\n-        final CountDownLatch sampleTimeDone = new CountDownLatch(1);\n-\n-        final AtomicInteger producedMessages = new AtomicInteger(0);\n-        final AtomicInteger receivedMessages = new AtomicInteger(0);\n-\n-        final Callable producer = new Callable() {\n-            public Object call() throws JMSException, InterruptedException {\n-                Connection connection = factory.createConnection();\n-                connections.add(connection);\n-                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-                MessageProducer producer = session.createProducer(destination);\n-                producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n-                BytesMessage message = session.createBytesMessage();\n-                message.writeBytes(new byte[1024]);\n-                connection.start();\n-                connectionsEstablished.release();\n-\n-                while (!sampleTimeDone.await(0, TimeUnit.MILLISECONDS)) {\n-                    producer.send(message);\n-                    producedMessages.incrementAndGet();\n-                }\n-\n-                connection.close();\n-                workerDone.release();\n-                return null;\n-            }\n-        };\n-\n-        final Callable consumer = new Callable() {\n-            public Object call() throws JMSException, InterruptedException {\n-                Connection connection = factory.createConnection();\n-                connections.add(connection);\n-                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-                MessageConsumer consumer = session.createConsumer(destination);\n-\n-                consumer.setMessageListener(new MessageListener() {\n-                    public void onMessage(Message msg) {\n-                        receivedMessages.incrementAndGet();\n-                    }\n-                });\n-                connection.start();\n-\n-                connectionsEstablished.release();\n-                sampleTimeDone.await();\n-\n-                connection.close();\n-                workerDone.release();\n-                return null;\n-            }\n-        };\n-\n-        final Throwable workerError[] = new Throwable[1];\n-        for (int i = 0; i < PRODUCER_COUNT; i++) {\n-            new Thread(\"Producer:\" + i) {\n-                public void run() {\n-                    try {\n-                        producer.call();\n-                    } catch (Throwable e) {\n-                        e.printStackTrace();\n-                        workerError[0] = e;\n-                    }\n-                }\n-            }.start();\n-        }\n-\n-        for (int i = 0; i < CONSUMER_COUNT; i++) {\n-            new Thread(\"Consumer:\" + i) {\n-                public void run() {\n-                    try {\n-                        consumer.call();\n-                    } catch (Throwable e) {\n-                        e.printStackTrace();\n-                        workerError[0] = e;\n-                    }\n-                }\n-            }.start();\n-        }\n-\n-        LOG.info(getName() + \": Waiting for Producers and Consumers to startup.\");\n-        connectionsEstablished.acquire();\n-        LOG.info(\"Producers and Consumers are now running.  Waiting for system to reach steady state: \"\n-                 + (SAMPLE_DELAY / 1000.0f) + \" seconds\");\n-        Thread.sleep(1000 * 10);\n-\n-        LOG.info(\"Starting sample: \" + SAMPLES + \" each lasting \" + (SAMPLE_DURATION / 1000.0f) + \" seconds\");\n-\n-        for (int i = 0; i < SAMPLES; i++) {\n-\n-            long start = System.currentTimeMillis();\n-            producedMessages.set(0);\n-            receivedMessages.set(0);\n-\n-            Thread.sleep(SAMPLE_DURATION);\n-\n-            long end = System.currentTimeMillis();\n-            int r = receivedMessages.get();\n-            int p = producedMessages.get();\n-\n-            LOG.info(\"published: \" + p + \" msgs at \" + (p * 1000f / (end - start)) + \" msgs/sec, \"\n-                     + \"consumed: \" + r + \" msgs at \" + (r * 1000f / (end - start)) + \" msgs/sec\");\n-        }\n-\n-        LOG.info(\"Sample done.\");\n-        sampleTimeDone.countDown();\n-\n-        workerDone.acquire();\n-        if (workerError[0] != null) {\n-            throw workerError[0];\n-        }\n-\n-    }\n-\n-}"},{"sha":"78d7fb3de4597a348f9cdf381302bdf9d57f1e71","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,127 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import javax.jms.Connection;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-\n-public class JmsClientAckListenerTest extends TestSupport implements MessageListener {\n-\n-    private Connection connection;\n-    private boolean dontAck;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if acknowleged messages are being consumed.\n-     *\n-     * @throws javax.jms.JMSException\n-     */\n-    public void testAckedMessageAreConsumed() throws Exception {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"test\");\n-        MessageProducer producer = session.createProducer(queue);\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        consumer.setMessageListener(this);\n-\n-        Thread.sleep(10000);\n-\n-        // Reset the session.\n-        session.close();\n-\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        Message msg = consumer.receive(1000);\n-        assertNull(msg);\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests if unacknowleged messages are being redelivered when the consumer\n-     * connects again.\n-     *\n-     * @throws javax.jms.JMSException\n-     */\n-    public void testUnAckedMessageAreNotConsumedOnSessionClose() throws Exception {\n-        connection.start();\n-        // don't aknowledge message on onMessage() call\n-        dontAck = true;\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"test\");\n-        MessageProducer producer = session.createProducer(queue);\n-        // Consume the message...\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        consumer.setMessageListener(this);\n-\n-        // Don't ack the message.\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Reset the session. This should cause the Unacked message to be\n-        // redelivered.\n-        session.close();\n-\n-        Thread.sleep(10000);\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        Message msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-    public void onMessage(Message message) {\n-\n-        assertNotNull(message);\n-        if (!dontAck) {\n-            try {\n-                message.acknowledge();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-\n-        }\n-\n-    }\n-}"},{"sha":"c4aa3c6d70ba91bac5053c95465d44642f8829d0","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,148 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import javax.jms.Connection;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-\n-public class JmsClientAckTest extends TestSupport {\n-\n-    private Connection connection;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if acknowledged messages are being consumed.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testAckedMessageAreConsumed() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getQueueName());\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        // Reset the session.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        msg = consumer.receive(1000);\n-        assertNull(msg);\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests if acknowledged messages are being consumed.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testLastMessageAcked() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getQueueName());\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        producer.send(session.createTextMessage(\"Hello\"));\n-        producer.send(session.createTextMessage(\"Hello2\"));\n-        producer.send(session.createTextMessage(\"Hello3\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        // Reset the session.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        msg = consumer.receive(1000);\n-        assertNull(msg);\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests if unacknowledged messages are being re-delivered when the consumer connects again.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testUnAckedMessageAreNotConsumedOnSessionClose() throws JMSException {\n-        connection.start();\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getQueueName());\n-        MessageProducer producer = session.createProducer(queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n-        producer.send(session.createTextMessage(\"Hello\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        // Don't ack the message.\n-\n-        // Reset the session.  This should cause the unacknowledged message to be re-delivered.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-    protected String getQueueName() {\n-        return getClass().getName() + \".\" + getName();\n-    }\n-\n-}"},{"sha":"36496146654eafde7506438d53f85f762dff51e7","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java","status":"removed","additions":0,"deletions":169,"changes":169,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,169 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import org.apache.hedwig.jms.DebugUtil;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import java.util.Random;\n-import java.util.Vector;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import javax.jms.Connection;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-import javax.jms.Topic;\n-\n-public class JmsConnectionStartStopTest extends TestSupport {\n-\n-    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory\n-        .getLog(JmsConnectionStartStopTest.class);\n-\n-    private Connection startedConnection;\n-    private Connection stoppedConnection;\n-\n-    /**\n-     * @see junit.framework.TestCase#setUp()\n-     */\n-    protected void setUp() throws Exception {\n-\n-        super.setUp();\n-        LOG.info(getClass().getClassLoader().getResource(\"log4j.properties\"));\n-\n-        HedwigConnectionFactoryImpl factory = createConnectionFactory();\n-        startedConnection = factory.createConnection();\n-        startedConnection.start();\n-        stoppedConnection = factory.createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        stoppedConnection.close();\n-        startedConnection.close();\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if the consumer receives the messages that were sent before the\n-     * connection was started.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testStoppedConsumerHoldsMessagesTillStarted() throws JMSException {\n-        Session startedSession = startedConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Session stoppedSession = stoppedConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-\n-        // Setup the consumers.\n-        Topic topic = startedSession.createTopic(\"test\");\n-        MessageConsumer startedConsumer = startedSession.createConsumer(topic);\n-        MessageConsumer stoppedConsumer = stoppedSession.createConsumer(topic);\n-\n-        // Send the message.\n-        MessageProducer producer = startedSession.createProducer(topic);\n-        TextMessage message = startedSession.createTextMessage(\"Hello\");\n-        producer.send(message);\n-\n-        // Test the assertions.\n-        Message m = startedConsumer.receive(1000);\n-        assertNotNull(m);\n-\n-        m = stoppedConsumer.receive(1000);\n-        assertNull(m);\n-\n-        stoppedConnection.start();\n-        m = stoppedConsumer.receive(5000);\n-        assertNotNull(m);\n-\n-        startedSession.close();\n-        stoppedSession.close();\n-    }\n-\n-    /**\n-     * Tests if the consumer is able to receive messages eveb when the\n-     * connecction restarts multiple times.\n-     *\n-     * @throws Exception\n-     */\n-    public void testMultipleConnectionStops() throws Exception {\n-        testStoppedConsumerHoldsMessagesTillStarted();\n-        stoppedConnection.stop();\n-        testStoppedConsumerHoldsMessagesTillStarted();\n-        stoppedConnection.stop();\n-        testStoppedConsumerHoldsMessagesTillStarted();\n-    }\n-\n-\n-    public void testConcurrentSessionCreateWithStart() throws Exception {\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(50, Integer.MAX_VALUE,\n-                                      60L, TimeUnit.SECONDS,\n-                                      new SynchronousQueue<Runnable>());\n-        final Vector<Throwable> exceptions = new Vector<Throwable>();\n-        final Random rand = new Random();\n-        final int numIterations = 100;\n-        final CountDownLatch latch = new CountDownLatch(numIterations * 2);\n-        Runnable createSessionTask = new Runnable() {\n-            public void run() {\n-                try {\n-                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(10));\n-                    latch.countDown();\n-                    stoppedConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                    exceptions.add(e);\n-                }\n-            }\n-        };\n-\n-        Runnable startStopTask = new Runnable() {\n-            public void run() {\n-                try {\n-                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(10));\n-                    latch.countDown();\n-                    stoppedConnection.start();\n-                    stoppedConnection.stop();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                    exceptions.add(e);\n-                }\n-            }\n-        };\n-\n-        for (int i=0; i<numIterations; i++) {\n-            executor.execute(createSessionTask);\n-            executor.execute(startStopTask);\n-        }\n-\n-        executor.shutdown();\n-        final long remaining;\n-        {\n-            boolean terminated = executor.awaitTermination(30, TimeUnit.SECONDS);\n-            remaining = latch.getCount();\n-            if (!terminated){\n-                DebugUtil.dumpAllStacktraces(System.err);\n-            }\n-            assertTrue(\"executor terminated. remaining : \" + remaining, terminated);\n-        }\n-        assertTrue(\"remaining : \" + remaining + \", no exceptions: \" + exceptions, exceptions.isEmpty());\n-    }\n-}"},{"sha":"aaf47f2d0ad64e2c6ea314250d293bc95b12d689","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java","status":"removed","additions":0,"deletions":157,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,157 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import java.util.Vector;\n-\n-import org.apache.hedwig.JmsTestBase;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import javax.jms.Connection;\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-\n-import junit.framework.TestCase;\n-\n-\n-public class JmsConsumerResetActiveListenerTest extends JmsTestBase {\n-\n-    private Connection connection;\n-    private HedwigConnectionFactoryImpl factory;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        factory = new HedwigConnectionFactoryImpl();\n-        connection = factory.createConnection();\n-    }\n-\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * verify the (undefined by spec) behaviour of setting a listener while receiving a message.\n-     *\n-     * @throws Exception\n-     */\n-    public void testSetListenerFromListener() throws Exception {\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Destination dest = session.createTopic(\"Queue-\" + getName());\n-        final MessageConsumer consumer = session.createConsumer(dest);\n-\n-        final CountDownLatch latch = new CountDownLatch(2);\n-        final AtomicBoolean first = new AtomicBoolean(true);\n-        final Vector<Object> results = new Vector<Object>();\n-        consumer.setMessageListener(new MessageListener() {\n-\n-            public void onMessage(Message message) {\n-                if (first.compareAndSet(true, false)) {\n-                    try {\n-                        consumer.setMessageListener(this);\n-                        results.add(message);\n-                    } catch (JMSException e) {\n-                        results.add(e);\n-                    }\n-                } else {\n-                    results.add(message);\n-                }\n-                latch.countDown();\n-            }\n-        });\n-\n-        connection.start();\n-\n-        MessageProducer producer = session.createProducer(dest);\n-        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n-        producer.send(session.createTextMessage(\"First\"));\n-        producer.send(session.createTextMessage(\"Second\"));\n-\n-        assertTrue(\"we did not timeout\", latch.await(5, TimeUnit.SECONDS));\n-\n-        assertEquals(\"we have a result\", 2, results.size());\n-        Object result = results.get(0);\n-        assertTrue(result instanceof TextMessage);\n-        assertEquals(\"result is first\", \"First\", ((TextMessage)result).getText());\n-        result = results.get(1);\n-        assertTrue(result instanceof TextMessage);\n-        assertEquals(\"result is first\", \"Second\", ((TextMessage)result).getText());\n-    }\n-\n-    /**\n-     * and a listener on a new consumer, just in case.\n-      *\n-     * @throws Exception\n-     */\n-    public void testNewConsumerSetListenerFromListener() throws Exception {\n-        final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        final Destination dest = session.createTopic(\"Queue-\" + getName());\n-        final MessageConsumer consumer = session.createConsumer(dest);\n-\n-        final CountDownLatch latch = new CountDownLatch(2);\n-        final AtomicBoolean first = new AtomicBoolean(true);\n-        final Vector<Object> results = new Vector<Object>();\n-        consumer.setMessageListener(new MessageListener() {\n-\n-            public void onMessage(Message message) {\n-                if (first.compareAndSet(true, false)) {\n-                    try {\n-                        MessageConsumer anotherConsumer = session.createConsumer(dest);\n-                        anotherConsumer.setMessageListener(this);\n-                        results.add(message);\n-                    } catch (JMSException e) {\n-                        results.add(e);\n-                    }\n-                } else {\n-                    results.add(message);\n-                }\n-                latch.countDown();\n-            }\n-        });\n-\n-        connection.start();\n-\n-        MessageProducer producer = session.createProducer(dest);\n-        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n-        producer.send(session.createTextMessage(\"First\"));\n-        producer.send(session.createTextMessage(\"Second\"));\n-\n-        assertTrue(\"we did not timeout\", latch.await(5, TimeUnit.SECONDS));\n-\n-        assertEquals(\"we have a result\", 2, results.size());\n-        Object result = results.get(0);\n-        assertTrue(result instanceof TextMessage);\n-        assertEquals(\"result is first\", \"First\", ((TextMessage)result).getText());\n-        result = results.get(1);\n-        assertTrue(result instanceof TextMessage);\n-        assertEquals(\"result is first\", \"Second\", ((TextMessage)result).getText());\n-    }\n- }"},{"sha":"218bbe5dcd873f89ed91bc41a0610613f470ad2d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,96 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Connection;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.Topic;\n-\n-public class JmsCreateConsumerInOnMessageTest extends TestSupport implements MessageListener {\n-\n-    private Connection connection;\n-    private Session publisherSession;\n-    private Session consumerSession;\n-    private MessageConsumer consumer;\n-    private MessageConsumer testConsumer;\n-    private MessageProducer producer;\n-    private Topic topic;\n-    private Object lock = new Object();\n-\n-    /*\n-     * @see junit.framework.TestCase#setUp()\n-     */\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        super.topic = true;\n-        connection = createConnection(false);\n-        connection.setClientID(\"connection:\" + getSubject());\n-        publisherSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        topic = (Topic)super.createDestination(\"Test.Topic\");\n-        consumer = consumerSession.createConsumer(topic);\n-        consumer.setMessageListener(this);\n-        producer = publisherSession.createProducer(topic);\n-        connection.start();\n-    }\n-\n-    /*\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        connection.close();\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Tests if a consumer can be created asynchronusly\n-     *\n-     * @throws Exception\n-     */\n-    public void testCreateConsumer() throws Exception {\n-        Message msg = super.createMessage();\n-        producer.send(msg);\n-        if (testConsumer == null) {\n-            synchronized (lock) {\n-                lock.wait(3000);\n-            }\n-        }\n-        assertTrue(testConsumer != null);\n-    }\n-\n-    /**\n-     * Use the asynchronous subscription mechanism\n-     *\n-     * @param message\n-     */\n-    public void onMessage(Message message) {\n-        try {\n-            testConsumer = consumerSession.createConsumer(topic);\n-            consumerSession.createProducer(topic);\n-            synchronized (lock) {\n-                lock.notify();\n-            }\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            assertTrue(false);\n-        }\n-    }\n-}"},{"sha":"548e7a81f291df2f8801c50a8f00a43b9b41fdb4","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java","status":"removed","additions":0,"deletions":26,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,26 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-\n-public class JmsDurableTopicSelectorTest extends JmsTopicSelectorTest {\n-    public void setUp() throws Exception {\n-        durable = true;\n-        super.setUp();\n-    }\n-}"},{"sha":"b2e2ed736587d087f9d453d4e3374f88e9a494e5","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,87 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Connection;\n-import javax.jms.Destination;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-import javax.jms.Topic;\n-\n-import org.apache.activemq.test.JmsTopicSendReceiveTest;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class JmsDurableTopicSendReceiveTest extends JmsTopicSendReceiveTest {\n-    private static final Logger LOG = LoggerFactory.getLogger(JmsDurableTopicSendReceiveTest.class);\n-\n-    protected Connection connection2;\n-    protected Session session2;\n-    protected Session consumeSession2;\n-    protected MessageConsumer consumer2;\n-    protected MessageProducer producer2;\n-    protected Destination consumerDestination2;\n-    protected Destination producerDestination2;\n-\n-    /**\n-     * Set up a durable suscriber test.\n-     *\n-     * @see junit.framework.TestCase#setUp()\n-     */\n-    protected void setUp() throws Exception {\n-        this.durable = true;\n-        super.setUp();\n-    }\n-\n-    /**\n-     * Test if all the messages sent are being received.\n-     *\n-     * @throws Exception\n-     */\n-    public void testSendWhileClosed() throws Exception {\n-        connection2 = createConnection(false);\n-        if (null == connection.getClientID()) connection2.setClientID(getName() + \"test\");\n-        connection2.start();\n-        session2 = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        producer2 = session2.createProducer(null);\n-        producer2.setDeliveryMode(deliveryMode);\n-        producerDestination2 = session2.createTopic(getProducerSubject() + \"2\");\n-        Thread.sleep(1000);\n-\n-        consumeSession2 = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        consumerDestination2 = session2.createTopic(getConsumerSubject() + \"2\");\n-        consumer2 = consumeSession2.createDurableSubscriber((Topic)consumerDestination2, getName());\n-        Thread.sleep(1000);\n-        consumer2.close();\n-        TextMessage message = session2.createTextMessage(\"test\");\n-        message.setStringProperty(\"test\", \"test\");\n-        message.setJMSType(\"test\");\n-        producer2.send(producerDestination2, message);\n-        LOG.info(\"Creating durable consumer\");\n-        consumer2 = consumeSession2.createDurableSubscriber((Topic)consumerDestination2, getName());\n-        Message msg = consumer2.receive(1000);\n-        assertNotNull(msg);\n-        assertEquals(((TextMessage)msg).getText(), \"test\");\n-        assertEquals(msg.getJMSType(), \"test\");\n-        assertEquals(msg.getStringProperty(\"test\"), \"test\");\n-        connection2.stop();\n-        connection2.close();\n-    }\n-}"},{"sha":"c0da42febbbea1aea5d8283dd048cdd3abda121c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,38 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Topic;\n-import javax.jms.DeliveryMode;\n-\n-import org.apache.activemq.test.JmsResourceProvider;\n-\n-public class JmsDurableTopicTransactionTest extends JmsTopicTransactionTest {\n-\n-    /**\n-     * @see JmsTransactionTestSupport#getJmsResourceProvider()\n-     */\n-    protected JmsResourceProvider getJmsResourceProvider() {\n-        JmsResourceProvider provider = new JmsResourceProvider();\n-        provider.setTopic(true);\n-        provider.setDeliveryMode(DeliveryMode.PERSISTENT);\n-        provider.setClientID(getClass().getName());\n-        provider.setDurableName(getName());\n-        return provider;\n-    }\n-\n-}"},{"sha":"3873a0f48525032aa57d90bef4c8c9401cf23665","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java","status":"removed","additions":0,"deletions":281,"changes":281,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,281 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.net.URI;\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import javax.jms.Connection;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-import javax.jms.TopicSubscriber;\n-\n-\n-\n-import javax.jms.Destination;\n-\n-\n-import org.apache.activemq.util.MessageIdList;\n-\n-/**\n- * Test case support used to test multiple message comsumers and message\n- * producers connecting to a single broker.\n- */\n-public class JmsMultipleClientsTestSupport extends CombinationTestSupport {\n-\n-    protected Map<MessageConsumer, MessageIdList> consumers\n-        = new HashMap<MessageConsumer, MessageIdList>(); // Map of consumer with messages received\n-    protected int consumerCount = 1;\n-    protected int producerCount = 1;\n-\n-    protected int messageSize = 1024;\n-\n-    protected boolean useConcurrentSend = true;\n-    protected boolean autoFail = true;\n-    protected boolean durable;\n-    public boolean topic;\n-    protected boolean persistent;\n-\n-    protected Destination destination;\n-    protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());\n-    protected MessageIdList allMessagesList = new MessageIdList();\n-\n-    private AtomicInteger producerLock;\n-\n-    protected void startProducers(Destination dest, int msgCount) throws Exception {\n-        startProducers(createConnectionFactory(), dest, msgCount);\n-    }\n-\n-    protected void startProducers(final ConnectionFactory factory,\n-                                  final Destination dest, final int msgCount) throws Exception {\n-        // Use concurrent send\n-        if (useConcurrentSend) {\n-            producerLock = new AtomicInteger(producerCount);\n-\n-            for (int i = 0; i < producerCount; i++) {\n-                Thread t = new Thread(new Runnable() {\n-                    public void run() {\n-                        try {\n-                            sendMessages(factory.createConnection(), dest, msgCount);\n-                        } catch (Exception e) {\n-                            e.printStackTrace();\n-                        }\n-\n-                        synchronized (producerLock) {\n-                            producerLock.decrementAndGet();\n-                            producerLock.notifyAll();\n-                        }\n-                    }\n-                });\n-\n-                t.start();\n-            }\n-\n-            // Wait for all producers to finish sending\n-            synchronized (producerLock) {\n-                while (producerLock.get() != 0) {\n-                    producerLock.wait(2000);\n-                }\n-            }\n-\n-            // Use serialized send\n-        } else {\n-            for (int i = 0; i < producerCount; i++) {\n-                sendMessages(factory.createConnection(), dest, msgCount);\n-            }\n-        }\n-    }\n-\n-    protected void sendMessages(Connection connection, Destination destination, int count) throws Exception {\n-        connections.add(connection);\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        MessageProducer producer = session.createProducer(destination);\n-        producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);\n-\n-        for (int i = 0; i < count; i++) {\n-            TextMessage msg = createTextMessage(session, \"\" + i);\n-            producer.send(msg);\n-        }\n-\n-        producer.close();\n-        session.close();\n-        connection.close();\n-    }\n-\n-    protected TextMessage createTextMessage(Session session, String initText) throws Exception {\n-        TextMessage msg = session.createTextMessage();\n-\n-        // Pad message text\n-        if (initText.length() < messageSize) {\n-            char[] data = new char[messageSize - initText.length()];\n-            Arrays.fill(data, '*');\n-            String str = new String(data);\n-            msg.setText(initText + str);\n-\n-            // Do not pad message text\n-        } else {\n-            msg.setText(initText);\n-        }\n-\n-        return msg;\n-    }\n-\n-    protected void startConsumers(Destination dest) throws Exception {\n-        startConsumers(createConnectionFactory(), dest);\n-    }\n-\n-    protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {\n-        MessageConsumer consumer;\n-        for (int i = 0; i < consumerCount; i++) {\n-            if (durable && topic) {\n-                consumer = createDurableSubscriber(factory.createConnection(), dest, \"consumer\" + (i + 1));\n-            } else {\n-                consumer = createMessageConsumer(factory.createConnection(), dest);\n-            }\n-            MessageIdList list = new MessageIdList();\n-            list.setParent(allMessagesList);\n-            consumer.setMessageListener(list);\n-            consumers.put(consumer, list);\n-        }\n-    }\n-\n-    protected MessageConsumer createMessageConsumer(Connection conn, Destination dest) throws Exception {\n-        connections.add(conn);\n-\n-        Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        final MessageConsumer consumer = sess.createConsumer(dest);\n-        conn.start();\n-\n-        return consumer;\n-    }\n-\n-    protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {\n-        conn.setClientID(name);\n-        connections.add(conn);\n-        conn.start();\n-\n-        Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);\n-\n-        return consumer;\n-    }\n-\n-    protected void waitForAllMessagesToBeReceived(int messageCount) throws Exception {\n-        allMessagesList.waitForMessagesToArrive(messageCount);\n-    }\n-\n-    protected Destination createDestination() throws JMSException {\n-        String name = \".\" + getClass().getName() + \".\" + getName();\n-        // ensure not inadvertently composite because of combos\n-        name = name.replace(' ','_');\n-        name = name.replace(',','&');\n-        if (topic) {\n-            destination = SessionImpl.asTopic(\"Topic\" + name);\n-            return (Destination)destination;\n-        } else {\n-            destination = SessionImpl.asTopic(\"Queue\" + name);\n-            return (Destination)destination;\n-        }\n-    }\n-\n-    protected ConnectionFactory createConnectionFactory() throws Exception {\n-        return new HedwigConnectionFactoryImpl();\n-    }\n-\n-    protected void setUp() throws Exception {\n-        super.setAutoFail(autoFail);\n-        super.setUp();\n-    }\n-\n-    protected void tearDown() throws Exception {\n-        for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {\n-            Connection conn = iter.next();\n-            try {\n-                conn.close();\n-            } catch (Throwable e) {\n-            }\n-        }\n-        allMessagesList.flushMessages();\n-        consumers.clear();\n-        super.tearDown();\n-    }\n-\n-    /*\n-     * Some helpful assertions for multiple consumers.\n-     */\n-    protected void assertConsumerReceivedAtLeastXMessages(MessageConsumer consumer, int msgCount) {\n-        MessageIdList messageIdList = consumers.get(consumer);\n-        messageIdList.assertAtLeastMessagesReceived(msgCount);\n-    }\n-\n-    protected void assertConsumerReceivedAtMostXMessages(MessageConsumer consumer, int msgCount) {\n-        MessageIdList messageIdList = consumers.get(consumer);\n-        messageIdList.assertAtMostMessagesReceived(msgCount);\n-    }\n-\n-    protected void assertConsumerReceivedXMessages(MessageConsumer consumer, int msgCount) {\n-        MessageIdList messageIdList = consumers.get(consumer);\n-        messageIdList.assertMessagesReceivedNoWait(msgCount);\n-    }\n-\n-    protected void assertEachConsumerReceivedAtLeastXMessages(int msgCount) {\n-        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n-            assertConsumerReceivedAtLeastXMessages(i.next(), msgCount);\n-        }\n-    }\n-\n-    protected void assertEachConsumerReceivedAtMostXMessages(int msgCount) {\n-        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n-            assertConsumerReceivedAtMostXMessages(i.next(), msgCount);\n-        }\n-    }\n-\n-    protected void assertEachConsumerReceivedXMessages(int msgCount) {\n-        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n-            assertConsumerReceivedXMessages(i.next(), msgCount);\n-        }\n-    }\n-\n-    protected void assertTotalMessagesReceived(int msgCount) {\n-        allMessagesList.assertMessagesReceivedNoWait(msgCount);\n-\n-        // now lets count the individual messages received\n-        int totalMsg = 0;\n-        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n-            MessageIdList messageIdList = consumers.get(i.next());\n-            totalMsg += messageIdList.getMessageCount();\n-        }\n-        assertEquals(\"Total of consumers message count\", msgCount, totalMsg);\n-    }\n-}"},{"sha":"fba706456fdcb2fc0e88bd39de9cddae63a53f38","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java","status":"removed","additions":0,"deletions":380,"changes":380,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,380 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import javax.jms.Connection;\n-\n-import org.apache.hedwig.JmsTestBase;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-import javax.jms.Topic;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n-public class JmsRedeliveredTest extends JmsTestBase {\n-\n-    private Connection connection;\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see junit.framework.TestCase#setUp()\n-     */\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    /**\n-     * Creates a connection.\n-     *\n-     * @return connection\n-     * @throws Exception\n-     */\n-    protected Connection createConnection() throws Exception {\n-        HedwigConnectionFactoryImpl factory = new HedwigConnectionFactoryImpl();\n-        return factory.createConnection();\n-    }\n-\n-    /**\n-     * Tests if a message unacknowledged message gets to be resent when the\n-     * session is closed and then a new consumer session is created.\n-     *\n-     */\n-    public void testTopicSessionCloseMarksMessageRedelivered() throws JMSException {\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"queue-\" + getName());\n-        MessageProducer producer = createProducer(session, queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        producer.send(createTextMessage(session));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n-        // Don't ack the message.\n-\n-        // Reset the session. This should cause the Unacked message to be\n-        // redelivered.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        // Since we only simulate this in provider, we cannot do this across consumers !\n-        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-\n-    public void testTopicSessionCloseMarksUnAckedMessageRedelivered() throws JMSException {\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"queue-\" + getName());\n-        MessageProducer producer = createProducer(session, queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        producer.send(createTextMessage(session, \"1\"));\n-        producer.send(createTextMessage(session, \"2\"));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n-        assertEquals(\"1\", ((TextMessage)msg).getText());\n-        msg.acknowledge();\n-\n-        // Don't ack the message.\n-        msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n-        assertEquals(\"2\", ((TextMessage)msg).getText());\n-\n-        // Reset the session. This should cause the Unacked message to be\n-        // redelivered.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        assertEquals(\"2\", ((TextMessage)msg).getText());\n-        // Since we only simulate this in provider, we cannot do this across consumers !\n-        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests session recovery and that the redelivered message is marked as\n-     * such. Session uses client acknowledgement, the destination is a queue.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testTopicRecoverMarksMessageRedelivered() throws Exception {\n-        connection.setClientID(getName());\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"queue-\" + getName());\n-        MessageProducer producer = createProducer(session, queue);\n-        MessageConsumer consumer = session.createDurableSubscriber(queue, getName() + \" - subscriber\");\n-        producer.send(createTextMessage(session));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n-        // Don't ack the message.\n-\n-        // We DO NOT support session recovery\n-        // - to unblock this test, I am stopp'ing and start'ing connection : not the same, but ...\n-        // Reset the session. This should cause the Unacked message to be\n-        // redelivered.\n-        // session.recover();\n-        connection.close();\n-        connection = createConnection();\n-        connection.setClientID(getName());\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        consumer = session.createDurableSubscriber(queue, getName() + \" - subscriber\");\n-        connection.start();\n-\n-        // Attempt to Consume the message...\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests rollback message to be marked as redelivered. Session uses client\n-     * acknowledgement and the destination is a queue.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testTopicRollbackMarksMessageRedelivered() throws JMSException {\n-        connection.start();\n-\n-        Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(\"queue-\" + getName());\n-        MessageProducer producer = createProducer(session, queue);\n-        MessageConsumer consumer = session.createConsumer(queue);\n-        producer.send(createTextMessage(session));\n-        session.commit();\n-\n-        // Get the message... Should not be redelivered.\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n-\n-        // Rollback.. should cause redelivery.\n-        session.rollback();\n-\n-        // Attempt to Consume the message...\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n-\n-        session.commit();\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests if the message gets to be re-delivered when the session closes and\n-     * that the re-delivered message is marked as such. Session uses client\n-     * acknowledgment, the destination is a topic and the consumer is a durable\n-     * subscriber.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testDurableTopicSessionCloseMarksMessageRedelivered() throws JMSException {\n-        connection.setClientID(getName());\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-        Topic topic = session.createTopic(\"topic-\" + getName());\n-        MessageConsumer consumer = session.createDurableSubscriber(topic, \"sub1\");\n-\n-        // This case only works with persistent messages since transient\n-        // messages\n-        // are dropped when the consumer goes offline.\n-        MessageProducer producer = session.createProducer(topic);\n-        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n-        producer.send(createTextMessage(session));\n-\n-        // Consume the message...\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be re-delivered.\", msg.getJMSRedelivered());\n-        // Don't ack the message.\n-\n-        // Reset the session. This should cause the Unacked message to be\n-        // re-delivered.\n-        session.close();\n-        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n-\n-        // Attempt to Consume the message...\n-        consumer = session.createDurableSubscriber(topic, \"sub1\");\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        // Since we only simulate this in provider, we cannot do this across consumers !\n-        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n-        msg.acknowledge();\n-\n-        session.close();\n-    }\n-\n-    /**\n-     * Tests rollback message to be marked as redelivered. Session uses client\n-     * acknowledgement and the destination is a topic.\n-     *\n-     * @throws JMSException\n-     */\n-    public void testDurableTopicRollbackMarksMessageRedelivered() throws JMSException {\n-        if (null == connection.getClientID()) connection.setClientID(getName());\n-        connection.start();\n-\n-        Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);\n-        Topic topic = session.createTopic(\"topic-\" + getName());\n-        MessageConsumer consumer = session.createDurableSubscriber(topic, \"sub1\");\n-\n-        MessageProducer producer = createProducer(session, topic);\n-        producer.send(createTextMessage(session));\n-        session.commit();\n-\n-        // Get the message... Should not be redelivered.\n-        Message msg = consumer.receive(1000);\n-        assertNotNull(msg);\n-        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n-\n-        // Rollback.. should cause redelivery.\n-        session.rollback();\n-\n-        // Attempt to Consume the message...\n-        msg = consumer.receive(2000);\n-        assertNotNull(msg);\n-        assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n-\n-        session.commit();\n-        session.close();\n-    }\n-\n-    /**\n-     * Creates a text message.\n-     *\n-     * @param session\n-     * @return TextMessage.\n-     * @throws JMSException\n-     */\n-    private TextMessage createTextMessage(Session session) throws JMSException {\n-        return createTextMessage(session, \"Hello\");\n-    }\n-\n-    private TextMessage createTextMessage(Session session, String txt) throws JMSException {\n-        return session.createTextMessage(txt);\n-    }\n-\n-    /**\n-     * Creates a producer.\n-     *\n-     * @param session\n-     * @param queue - destination.\n-     * @return MessageProducer\n-     * @throws JMSException\n-     */\n-    private MessageProducer createProducer(Session session, Destination queue) throws JMSException {\n-        MessageProducer producer = session.createProducer(queue);\n-        producer.setDeliveryMode(getDeliveryMode());\n-        return producer;\n-    }\n-\n-    /**\n-     * Returns delivery mode.\n-     *\n-     * @return int - persistent delivery mode.\n-     */\n-    protected int getDeliveryMode() {\n-        return DeliveryMode.PERSISTENT;\n-    }\n-\n-    /**\n-     * Run the JmsRedeliverTest with the delivery mode set as persistent.\n-     */\n-    public static final class PersistentCase extends JmsRedeliveredTest {\n-\n-        /**\n-         * Returns delivery mode.\n-         *\n-         * @return int - persistent delivery mode.\n-         */\n-        protected int getDeliveryMode() {\n-            return DeliveryMode.PERSISTENT;\n-        }\n-    }\n-\n-    /**\n-     * Run the JmsRedeliverTest with the delivery mode set as non-persistent.\n-     */\n-    public static final class TransientCase extends JmsRedeliveredTest {\n-\n-        /**\n-         * Returns delivery mode.\n-         *\n-         * @return int - non-persistent delivery mode.\n-         */\n-        protected int getDeliveryMode() {\n-            return DeliveryMode.NON_PERSISTENT;\n-        }\n-    }\n-\n-    public static Test suite() {\n-        TestSuite suite = new TestSuite();\n-        suite.addTestSuite(PersistentCase.class);\n-        suite.addTestSuite(TransientCase.class);\n-        return suite;\n-    }\n-}"},{"sha":"82572be43fb84719989042af5f1c975d059ffd47","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java","status":"removed","additions":0,"deletions":339,"changes":339,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,339 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.activemq;\n-\n-\n-import javax.jms.Topic;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import javax.jms.Connection;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-\n-\n-import org.apache.hedwig.jms.SessionImpl;\n-import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class JmsRollbackRedeliveryTest extends AutoFailTestSupport {\n-    protected static final Logger LOG = LoggerFactory.getLogger(JmsRollbackRedeliveryTest.class);\n-    final int nbMessages = 10;\n-    final String destinationName = \"Destination\";\n-    boolean consumerClose = true;\n-    boolean rollback = true;\n-\n-    public void setUp() throws Exception {\n-        setAutoFail(true);\n-        super.setUp();\n-    }\n-\n-    public void tearDown() throws Exception {\n-        super.tearDown();\n-    }\n-\n-    public void testRedelivery() throws Exception {\n-        doTestRedelivery(false);\n-    }\n-\n-    public void testRedeliveryWithInterleavedProducer() throws Exception {\n-        doTestRedelivery(true);\n-    }\n-\n-    public void doTestRedelivery(boolean interleaveProducer) throws Exception {\n-\n-        ConnectionFactory connectionFactory = new HedwigConnectionFactoryImpl();\n-        Connection connection = connectionFactory.createConnection();\n-        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n-        Destination destination = session.createTopic(destinationName);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        connection.start();\n-\n-        if (interleaveProducer) {\n-            populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);\n-        } else {\n-            populateDestination(nbMessages, destinationName, connection);\n-        }\n-        // Consume messages and rollback transactions\n-        {\n-            AtomicInteger received = new AtomicInteger();\n-            Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();\n-            while (received.get() < nbMessages) {\n-                TextMessage msg = (TextMessage) consumer.receive(6000000);\n-                if (msg != null) {\n-                    if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {\n-                        LOG.info(\"Received message \" + msg.getText()\n-                                 + \" (\" + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n-                        assertTrue(msg.getJMSRedelivered());\n-                        // assertEquals(2, msg.getLongProperty(\"JMSXDeliveryCount\"));\n-                        session.commit();\n-                    } else {\n-                        LOG.info(\"Rollback message \" + msg.getText() + \" id: \" +  msg.getJMSMessageID());\n-                        assertFalse(\"should not have redelivery flag set, id: \"\n-                                    + msg.getJMSMessageID(), msg.getJMSRedelivered());\n-                        session.rollback();\n-                    }\n-                }\n-            }\n-            consumer.close();\n-            session.close();\n-        }\n-    }\n-\n-    public void testRedeliveryOnSingleConsumer() throws Exception {\n-\n-        ConnectionFactory connectionFactory =\n-            new HedwigConnectionFactoryImpl();\n-        Connection connection = connectionFactory.createConnection();\n-        connection.start();\n-        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n-        Destination destination = session.createTopic(destinationName);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-\n-        populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);\n-\n-        // Consume messages and rollback transactions\n-        {\n-            AtomicInteger received = new AtomicInteger();\n-            Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();\n-            while (received.get() < nbMessages) {\n-                TextMessage msg = (TextMessage) consumer.receive(6000000);\n-                if (msg != null) {\n-                    if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {\n-                        LOG.info(\"Received message \" + msg.getText() + \" (\"\n-                                 + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n-                        assertTrue(msg.getJMSRedelivered());\n-                        session.commit();\n-                    } else {\n-                        LOG.info(\"Rollback message \" + msg.getText() + \" id: \" +  msg.getJMSMessageID());\n-                        session.rollback();\n-                    }\n-                }\n-            }\n-            consumer.close();\n-            session.close();\n-        }\n-    }\n-\n-    public void testRedeliveryOnSingleSession() throws Exception {\n-\n-        ConnectionFactory connectionFactory =\n-            new HedwigConnectionFactoryImpl();\n-        Connection connection = connectionFactory.createConnection();\n-        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n-        Destination destination = session.createTopic(destinationName);\n-        MessageConsumer consumer = session.createConsumer(destination);\n-        connection.start();\n-\n-        populateDestination(nbMessages, destinationName, connection);\n-\n-        // Consume messages and rollback transactions\n-        {\n-            AtomicInteger received = new AtomicInteger();\n-            Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();\n-            while (received.get() < nbMessages) {\n-                TextMessage msg = (TextMessage) consumer.receive(6000000);\n-                if (msg != null) {\n-                    if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {\n-                        LOG.info(\"Received message \" + msg.getText() + \" (\"\n-                                 + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n-                        assertTrue(msg.getJMSRedelivered());\n-                        session.commit();\n-                    } else {\n-                        LOG.info(\"Rollback message \" + msg.getText() + \" id: \" +  msg.getJMSMessageID());\n-                        session.rollback();\n-                    }\n-                }\n-            }\n-            consumer.close();\n-            session.close();\n-        }\n-    }\n-\n-    // AMQ-1593\n-    public void testValidateRedeliveryCountOnRollback() throws Exception {\n-\n-        final int numMessages = 1;\n-        ConnectionFactory connectionFactory =\n-            new HedwigConnectionFactoryImpl();\n-        Connection connection = connectionFactory.createConnection();\n-        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        Destination destination = session.createTopic(destinationName);\n-\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-1\");\n-        connection.start();\n-\n-        populateDestination(numMessages, destinationName, connection);\n-\n-        {\n-            AtomicInteger received = new AtomicInteger();\n-            // hardcoded, we actually allow for infinite rollback/redelivery ...\n-            final int maxRetries = 5;\n-            while (received.get() < maxRetries) {\n-                TextMessage msg = (TextMessage) consumer.receive(1000);\n-                assert msg != null;\n-                if (msg != null) {\n-                    LOG.info(\"Received message \" + msg.getText() + \" (\"\n-                             + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n-                    session.rollback();\n-                }\n-            }\n-            session.close();\n-            consumeMessage(connection, \"subscriber-id-1\");\n-        }\n-    }\n-\n-    // AMQ-1593\n-    public void testValidateRedeliveryCountOnRollbackWithPrefetch0() throws Exception {\n-\n-       final int numMessages = 1;\n-       ConnectionFactory connectionFactory =\n-            new HedwigConnectionFactoryImpl();\n-        Connection connection = connectionFactory.createConnection();\n-        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        Destination destination = session.createTopic(destinationName);\n-\n-        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-2\");\n-        connection.start();\n-\n-        populateDestination(numMessages, destinationName, connection);\n-\n-        {\n-            AtomicInteger received = new AtomicInteger();\n-            // hardcoded, we actually allow for infinite rollback/redelivery ...\n-            final int maxRetries = 5;\n-            while (received.get() < maxRetries) {\n-                TextMessage msg = (TextMessage) consumer.receive(1000);\n-                assert msg != null;\n-                if (msg != null) {\n-                    LOG.info(\"Received message \" + msg.getText() + \" (\"\n-                             + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n-                    session.rollback();\n-                }\n-            }\n-\n-            session.close();\n-            consumeMessage(connection, \"subscriber-id-2\");\n-        }\n-    }\n-\n-\n-    private void consumeMessage(Connection connection, String subscriberId)\n-            throws JMSException {\n-        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-        Destination destination = session.createTopic(destinationName);\n-        MessageConsumer consumer;\n-        if (null == subscriberId) consumer = session.createConsumer(destination);\n-        else consumer = session.createDurableSubscriber((Topic) destination, subscriberId);\n-\n-        TextMessage msg = (TextMessage) consumer.receive(1000);\n-        assertNotNull(msg);\n-        session.commit();\n-        session.close();\n-    }\n-\n-    public void testRedeliveryPropertyWithNoRollback() throws Exception {\n-        final int numMessages = 1;\n-        ConnectionFactory connectionFactory =\n-            new HedwigConnectionFactoryImpl();\n-        Connection connection = connectionFactory.createConnection();\n-        // ensure registration of durable subscription\n-        {\n-            connection.setClientID(getName() + \"-client-id-1\");\n-            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-            Destination destination = session.createTopic(destinationName);\n-\n-            MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-3\");\n-        }\n-        connection.start();\n-\n-        populateDestination(numMessages, destinationName, connection);\n-        connection.close();\n-        {\n-            AtomicInteger received = new AtomicInteger();\n-            // hardcoded, we actually allow for infinite rollback/redelivery ...\n-            final int maxRetries = 5;\n-            while (received.get() < maxRetries) {\n-                connection = connectionFactory.createConnection();\n-                connection.setClientID(getName() + \"-client-id-1\");\n-                connection.start();\n-                Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n-                Destination destination = session.createTopic(destinationName);\n-\n-                MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-3\");\n-                TextMessage msg = (TextMessage) consumer.receive(2000);\n-                assert msg != null;\n-                if (msg != null) {\n-                    LOG.info(\"Received message \" + msg.getText() + \" (\"\n-                             + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n-                }\n-                session.close();\n-                connection.close();\n-            }\n-            connection = connectionFactory.createConnection();\n-            connection.setClientID(getName() + \"-client-id-1\");\n-            connection.start();\n-            consumeMessage(connection, \"subscriber-id-3\");\n-        }\n-    }\n-\n-    private void populateDestination(final int nbMessages,\n-            final String destinationName, Connection connection)\n-            throws JMSException {\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Destination destination = session.createTopic(destinationName);\n-        MessageProducer producer = session.createProducer(destination);\n-        for (int i = 1; i <= nbMessages; i++) {\n-            producer.send(session.createTextMessage(\"<hello id='\" + i + \"'/>\"));\n-        }\n-        producer.close();\n-        session.close();\n-    }\n-\n-\n-    private void populateDestinationWithInterleavedProducer(final int nbMessages,\n-            final String destinationName, Connection connection)\n-            throws JMSException {\n-        Session session1 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Destination destination1 = session1.createTopic(destinationName);\n-        MessageProducer producer1 = session1.createProducer(destination1);\n-        Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Destination destination2 = session2.createTopic(destinationName);\n-        MessageProducer producer2 = session2.createProducer(destination2);\n-\n-        for (int i = 1; i <= nbMessages; i++) {\n-            if (i%2 == 0) {\n-                producer1.send(session1.createTextMessage(\"<hello id='\" + i + \"'/>\"));\n-            } else {\n-                producer2.send(session2.createTextMessage(\"<hello id='\" + i + \"'/>\"));\n-            }\n-        }\n-        producer1.close();\n-        session1.close();\n-        producer2.close();\n-        session2.close();\n-    }\n-\n-}"},{"sha":"62a17150c8d9ffce52e1c493bb68d12fccce4bb9","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java","status":"removed","additions":0,"deletions":234,"changes":234,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,234 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.TextMessage;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class JmsSendReceiveTestSupport extends TestSupport implements MessageListener {\n-    private static final Logger LOG = LoggerFactory.getLogger(JmsSendReceiveTestSupport.class);\n-\n-    protected int messageCount = 100;\n-    protected String[] data;\n-    protected Session session;\n-    protected MessageConsumer consumer;\n-    protected MessageProducer producer;\n-    protected Destination consumerDestination;\n-    protected Destination producerDestination;\n-    protected List<Message> messages = createConcurrentList();\n-    protected boolean topic = true;\n-    protected boolean durable;\n-    protected int deliveryMode = DeliveryMode.PERSISTENT;\n-    protected final Object lock = new Object();\n-    protected boolean verbose;\n-\n-    /*\n-     * @see junit.framework.TestCase#setUp()\n-     */\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        String temp = System.getProperty(\"messageCount\");\n-\n-        if (temp != null) {\n-            int i = Integer.parseInt(temp);\n-            if (i > 0) {\n-                messageCount = i;\n-            }\n-        }\n-\n-        LOG.info(\"Message count for test case is: \" + messageCount);\n-        data = new String[messageCount];\n-\n-        for (int i = 0; i < messageCount; i++) {\n-            data[i] = \"Text for message: \" + i + \" at \" + new Date();\n-        }\n-    }\n-\n-    /**\n-     * Sends and consumes the messages.\n-     *\n-     * @throws Exception\n-     */\n-    public void testSendReceive() throws Exception {\n-        messages.clear();\n-        for (int i = 0; i < data.length; i++) {\n-            Message message = session.createTextMessage(data[i]);\n-            message.setStringProperty(\"stringProperty\", data[i]);\n-            message.setIntProperty(\"intProperty\", i);\n-\n-            if (verbose) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"About to send a message: \" + message + \" with text: \" + data[i]);\n-                }\n-            }\n-\n-            sendToProducer(producer, producerDestination, message);\n-            messageSent();\n-        }\n-\n-        assertMessagesAreReceived();\n-        LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n-    }\n-\n-    /**\n-     * Sends a message to a destination using the supplied producer\n-     * @param producer\n-     * @param producerDestination\n-     * @param message\n-     * @throws JMSException\n-     */\n-    protected void sendToProducer(MessageProducer producer,\n-            Destination producerDestination, Message message) throws JMSException {\n-        producer.send(producerDestination, message);\n-    }\n-\n-    /**\n-     * Asserts messages are received.\n-     *\n-     * @throws JMSException\n-     */\n-    protected void assertMessagesAreReceived() throws JMSException {\n-        waitForMessagesToBeDelivered();\n-        assertMessagesReceivedAreValid(messages);\n-    }\n-\n-    /**\n-     * Tests if the messages received are valid.\n-     *\n-     * @param receivedMessages - list of received messages.\n-     * @throws JMSException\n-     */\n-    protected void assertMessagesReceivedAreValid(List<Message> receivedMessages) throws JMSException {\n-        List<Object> copyOfMessages = Arrays.asList(receivedMessages.toArray());\n-        int counter = 0;\n-\n-        if (data.length != copyOfMessages.size()) {\n-            for (Iterator<Object> iter = copyOfMessages.iterator(); iter.hasNext();) {\n-                TextMessage message = (TextMessage)iter.next();\n-                if (LOG.isInfoEnabled()) {\n-                    LOG.info(\"<== \" + counter++ + \" = \" + message.getText());\n-                }\n-            }\n-        }\n-\n-        assertEquals(\"Not enough messages received\", data.length, receivedMessages.size());\n-\n-        for (int i = 0; i < data.length; i++) {\n-            TextMessage received = (TextMessage)receivedMessages.get(i);\n-            String text = received.getText();\n-            String stringProperty = received.getStringProperty(\"stringProperty\");\n-            int intProperty = received.getIntProperty(\"intProperty\");\n-\n-            if (verbose) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.info(\"Received Text: \" + text);\n-                }\n-            }\n-\n-            assertEquals(\"Message: \" + i, data[i], text);\n-            assertEquals(data[i], stringProperty);\n-            assertEquals(i, intProperty);\n-        }\n-    }\n-\n-    /**\n-     * Waits for messages to be delivered.\n-     */\n-    protected void waitForMessagesToBeDelivered() {\n-        long maxWaitTime = 30000;\n-        long waitTime = maxWaitTime;\n-        long start = (maxWaitTime <= 0) ? 0 : System.currentTimeMillis();\n-\n-        synchronized (lock) {\n-            while (messages.size() < data.length && waitTime >= 0) {\n-                try {\n-                    lock.wait(200);\n-                } catch (InterruptedException e) {\n-                    e.printStackTrace();\n-                }\n-\n-                waitTime = maxWaitTime - (System.currentTimeMillis() - start);\n-            }\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.jms.MessageListener#onMessage(javax.jms.Message)\n-     */\n-    public synchronized void onMessage(Message message) {\n-        consumeMessage(message, messages);\n-    }\n-\n-    /**\n-     * Consumes messages.\n-     *\n-     * @param message - message to be consumed.\n-     * @param messageList -list of consumed messages.\n-     */\n-    protected void consumeMessage(Message message, List<Message> messageList) {\n-        if (verbose) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.info(\"Received message: \" + message);\n-            }\n-        }\n-\n-        messageList.add(message);\n-\n-        if (messageList.size() >= data.length) {\n-            synchronized (lock) {\n-                lock.notifyAll();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns the ArrayList as a synchronized list.\n-     *\n-     * @return List\n-     */\n-    protected List<Message> createConcurrentList() {\n-        return Collections.synchronizedList(new ArrayList<Message>());\n-    }\n-\n-    /**\n-     * Just a hook so can insert failure tests\n-     *\n-     * @throws Exception\n-     */\n-    protected void messageSent() throws Exception {\n-\n-    }\n-}"},{"sha":"82d2108baf6b8a132f7066005260a9c479007841","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java","status":"removed","additions":0,"deletions":239,"changes":239,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,239 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-import java.util.Date;\n-import java.util.Vector;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.jms.Connection;\n-import javax.jms.DeliveryMode;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.Topic;\n-\n-import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class JmsSendReceiveWithMessageExpirationTest extends TestSupport {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(JmsSendReceiveWithMessageExpirationTest.class);\n-\n-    protected int messageCount = 100;\n-    protected String[] data;\n-    protected Session session;\n-    protected Destination consumerDestination;\n-    protected Destination producerDestination;\n-    protected boolean durable;\n-    protected int deliveryMode = DeliveryMode.PERSISTENT;\n-    protected long timeToLive = 5000;\n-    protected boolean verbose;\n-\n-    protected Connection connection;\n-\n-    protected void setUp() throws Exception {\n-\n-        super.setUp();\n-\n-        data = new String[messageCount];\n-\n-        for (int i = 0; i < messageCount; i++) {\n-            data[i] = \"Text for message: \" + i + \" at \" + new Date();\n-        }\n-\n-        connectionFactory = createConnectionFactory();\n-        connection = createConnection(!durable);\n-\n-        if (durable) {\n-            connection.setClientID(getClass().getName());\n-        }\n-\n-        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-    }\n-\n-    /**\n-     * Test consuming an expired queue.\n-     *\n-     * @throws Exception\n-     */\n-    public void testConsumeExpiredQueue() throws Exception {\n-\n-        MessageProducer producer = createProducer(timeToLive);\n-\n-        consumerDestination = session.createTopic(getConsumerSubject());\n-        producerDestination = session.createTopic(getProducerSubject());\n-\n-        MessageConsumer consumer = createConsumer();\n-        connection.start();\n-\n-        for (int i = 0; i < data.length; i++) {\n-            Message message = session.createTextMessage(data[i]);\n-            message.setStringProperty(\"stringProperty\", data[i]);\n-            message.setIntProperty(\"intProperty\", i);\n-\n-            if (verbose) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"About to send a queue message: \" + message + \" with text: \" + data[i]);\n-                }\n-            }\n-\n-            producer.send(producerDestination, message, producer.getDeliveryMode(),\n-                          producer.getPriority(), timeToLive);\n-        }\n-\n-        // sleeps a second longer than the expiration time.\n-        // Basically waits till queue expires.\n-        Thread.sleep(timeToLive + 1000);\n-\n-        // message should have expired.\n-        assertNull(consumer.receive(1000));\n-    }\n-\n-    /**\n-     * Sends and consumes the messages to a queue destination.\n-     *\n-     * @throws Exception\n-     */\n-    public void testConsumeQueue() throws Exception {\n-\n-        MessageProducer producer = createProducer(0);\n-\n-        consumerDestination = session.createTopic(getConsumerSubject());\n-        producerDestination = session.createTopic(getProducerSubject());\n-\n-        MessageConsumer consumer = createConsumer();\n-        connection.start();\n-\n-        for (int i = 0; i < data.length; i++) {\n-            Message message = session.createTextMessage(data[i]);\n-            message.setStringProperty(\"stringProperty\", data[i]);\n-            message.setIntProperty(\"intProperty\", i);\n-\n-            if (verbose) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"About to send a queue message: \" + message + \" with text: \" + data[i]);\n-                }\n-            }\n-\n-            producer.send(producerDestination, message);\n-        }\n-\n-        // should receive a queue since there is no expiration.\n-        assertNotNull(consumer.receive(1000));\n-    }\n-\n-    /**\n-     * Test consuming an expired topic.\n-     *\n-     * @throws Exception\n-     */\n-    public void testConsumeExpiredTopic() throws Exception {\n-\n-        MessageProducer producer = createProducer(timeToLive);\n-\n-        consumerDestination = session.createTopic(getConsumerSubject());\n-        producerDestination = session.createTopic(getProducerSubject());\n-\n-        MessageConsumer consumer = createConsumer();\n-        connection.start();\n-\n-        for (int i = 0; i < data.length; i++) {\n-            Message message = session.createTextMessage(data[i]);\n-            message.setStringProperty(\"stringProperty\", data[i]);\n-            message.setIntProperty(\"intProperty\", i);\n-\n-            if (verbose) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"About to send a topic message: \" + message + \" with text: \" + data[i]);\n-                }\n-            }\n-\n-            producer.send(producerDestination, message);\n-        }\n-\n-        // sleeps a second longer than the expiration time.\n-        // Basically waits till topic expires.\n-        Thread.sleep(timeToLive + 1000);\n-\n-        // message should have expired.\n-        assertNull(consumer.receive(1000));\n-    }\n-\n-    /**\n-     * Sends and consumes the messages to a topic destination.\n-     *\n-     * @throws Exception\n-     */\n-    public void testConsumeTopic() throws Exception {\n-\n-        MessageProducer producer = createProducer(0);\n-\n-        consumerDestination = session.createTopic(getConsumerSubject());\n-        producerDestination = session.createTopic(getProducerSubject());\n-\n-        MessageConsumer consumer = createConsumer();\n-        connection.start();\n-\n-        for (int i = 0; i < data.length; i++) {\n-            Message message = session.createTextMessage(data[i]);\n-            message.setStringProperty(\"stringProperty\", data[i]);\n-            message.setIntProperty(\"intProperty\", i);\n-\n-            if (verbose) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"About to send a topic message: \" + message + \" with text: \" + data[i]);\n-                }\n-            }\n-\n-            producer.send(producerDestination, message);\n-        }\n-\n-        // should receive a topic since there is no expiration.\n-        assertNotNull(consumer.receive(1000));\n-    }\n-\n-    protected MessageProducer createProducer(long timeToLive) throws JMSException {\n-        MessageProducer producer = session.createProducer(null);\n-        producer.setDeliveryMode(deliveryMode);\n-        producer.setTimeToLive(timeToLive);\n-\n-        return producer;\n-    }\n-\n-    protected MessageConsumer createConsumer() throws JMSException {\n-        if (durable) {\n-            LOG.info(\"Creating durable consumer\");\n-            return session.createDurableSubscriber((Topic)consumerDestination, getName());\n-        }\n-        return session.createConsumer(consumerDestination);\n-    }\n-\n-    protected void tearDown() throws Exception {\n-        LOG.info(\"Dumping stats...\");\n-        LOG.info(\"Closing down connection\");\n-\n-        session.close();\n-        connection.close();\n-        super.tearDown();\n-    }\n-\n-}"},{"sha":"7b60106ec70858e54dfccb6241ecaac575f5338c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java","status":"removed","additions":0,"deletions":107,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9","patch":"@@ -1,107 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.activemq;\n-\n-\n-import javax.jms.Connection;\n-import javax.jms.DeliveryMode;\n-import javax.jms.JMSException;\n-import javax.jms.MessageConsumer;\n-import javax.jms.MessageListener;\n-import javax.jms.MessageProducer;\n-import javax.jms.Session;\n-import javax.jms.Topic;\n-import javax.jms.Message;\n-\n-public class JmsSendWithAsyncCallbackTest extends TestSupport {\n-\n-    private Connection connection;\n-\n-    protected void setUp() throws Exception {\n-        super.setUp();\n-        connection = createConnection();\n-    }\n-\n-    /**\n-     * @see junit.framework.TestCase#tearDown()\n-     */\n-    protected void tearDown() throws Exception {\n-        if (connection != null) {\n-            connection.close();\n-            connection = null;\n-        }\n-        super.tearDown();\n-    }\n-\n-    public void testAsyncCallbackIsFaster() throws JMSException, InterruptedException {\n-        connection.start();\n-\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getName());\n-\n-        // setup a consumer to drain messages..\n-        MessageConsumer consumer = session.createConsumer(queue);\n-        consumer.setMessageListener(new MessageListener() {\n-            @Override\n-            public void onMessage(Message message) {\n-            }\n-        });\n-\n-        // warmup...\n-        for(int i=0; i < 10; i++) {\n-            benchmarkNonCallbackRate();\n-            benchmarkCallbackRate();\n-        }\n-\n-        double callbackRate = benchmarkCallbackRate();\n-        double nonCallbackRate = benchmarkNonCallbackRate();\n-\n-        System.out.println(String.format(\"AsyncCallback Send rate: %,.2f m/s\", callbackRate));\n-        System.out.println(String.format(\"NonAsyncCallback Send rate: %,.2f m/s\", nonCallbackRate));\n-\n-        // there is no such requirement in hedwig case :-)\n-        // The async style HAS to be faster than the non-async style..\n-        // assertTrue( callbackRate/nonCallbackRate > 1.5 );\n-    }\n-\n-    private double benchmarkNonCallbackRate() throws JMSException {\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getName());\n-        int count = 1000;\n-        MessageProducer producer = session.createProducer(queue);\n-        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n-        long start = System.currentTimeMillis();\n-        for (int i = 0; i < count; i++) {\n-            producer.send(session.createTextMessage(\"Hello\"));\n-        }\n-        return 1000.0 * count / (System.currentTimeMillis() - start);\n-    }\n-\n-    private double benchmarkCallbackRate() throws JMSException, InterruptedException {\n-        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n-        Topic queue = session.createTopic(getName());\n-        int count = 1000;\n-        MessageProducer producer = session.createProducer(queue);\n-        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n-        long start = System.currentTimeMillis();\n-        for (int i = 0; i < count; i++) {\n-            producer.send(session.createTextMessage(\"Hello\"));\n-        }\n-        return 1000.0 * count / (System.currentTimeMillis() - start);\n-    }\n-\n-}"},{"sha":"82ec6aefa3cedf5c078dc571dcbaeb60bd4517e6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"78afcdde52fe48a38f0e49078714d95386ce0981","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java","status":"removed","additions":0,"deletions":101,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ac25e58e066bd54e8f2b6b32db71fbf8b0757886","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java","status":"removed","additions":0,"deletions":176,"changes":176,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"73dd2edb5d15cfb76e37968fc3a5873bd204132e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java","status":"removed","additions":0,"deletions":212,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e75d6fe9b31466dd09382b60da5d146e5a63687c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java","status":"removed","additions":0,"deletions":33,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"dc590d87b982b625e78ca028e3d55f39ec0c2124","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java","status":"removed","additions":0,"deletions":95,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"36f4bebede7af8afa02d6bd3b1cbaebfe5fd4f85","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java","status":"removed","additions":0,"deletions":116,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f122176289c951b754bacd7f3a0e540bd324da5c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e7fd5bf03a1bd3fa911adf8617d1e47735288f4f","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"81060f6a270ac32201e4e12c4f22936f0ed59b20","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java","status":"removed","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"23a9121a3223066fdf673c7eda74f52b4051d6df","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java","status":"removed","additions":0,"deletions":692,"changes":692,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"5593dafc59d5e4ab78c40103ac48bc89e36281da","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java","status":"removed","additions":0,"deletions":164,"changes":164,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"735d701ebbbd39d3eebec7ab25188415a81f76b5","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java","status":"removed","additions":0,"deletions":193,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"002fea04116088f13df2060b81bfbd63d83f7921","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java","status":"removed","additions":0,"deletions":145,"changes":145,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fd838ab28f9011c6f5b84ce12c0655beba6bf2a6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java","status":"removed","additions":0,"deletions":151,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"4b12ccca1f3252d60241601fe39c3946e23e2847","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java","status":"removed","additions":0,"deletions":91,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"1d187240e4c77264422e3640fd14c34e2dbc184b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java","status":"removed","additions":0,"deletions":129,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"4facc3dc3a9baa5280d1f06d3c11864b6c02f380","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java","status":"removed","additions":0,"deletions":138,"changes":138,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c5d9b0c2fcf4a1408481b01968e758aaba370a96","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java","status":"removed","additions":0,"deletions":222,"changes":222,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"814981415236fcb587bd5c33c0fed4d4f51706bf","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java","status":"removed","additions":0,"deletions":98,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"66880af9c96463c11a338adba9aab34c2590f127","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a47ba67185180a4a8a114520008840e72fdbd156","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a03fab9671685b343070130722c5a1e96360af3a","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java","status":"removed","additions":0,"deletions":171,"changes":171,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8959de26fe156dff0e393a7405c37d608d9ab331","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java","status":"removed","additions":0,"deletions":212,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f05e4820e15033e9f71b183396b2f8ecd1b0fe1b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"9eefad588cdbd246b04b18c5a87bc4696b304ecc","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java","status":"removed","additions":0,"deletions":139,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a65b2c0bb70c36a39b39b4c3fb589bd6fc90a452","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java","status":"removed","additions":0,"deletions":125,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7942667d2b7d284d6a9da8d775599dd9e407d277","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java","status":"removed","additions":0,"deletions":78,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e9092110d0ca8bd1dd611ea6b6f04e58b8d47169","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c10d3bf2cfbf7dd5a3163b96fed853076c8a7f78","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0d32d490e79bf5ee423b3729a3ab8b1d8d33eed8","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java","status":"removed","additions":0,"deletions":79,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a2e2b7d4adc8a9b187a1f07a0d0a9cc6324e256e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java","status":"removed","additions":0,"deletions":37,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"5df97e5a84237ac364dec016699f2a272ef75130","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java","status":"removed","additions":0,"deletions":181,"changes":181,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c670dbda47351b0daed033b4f2ccaecbdb46bcce","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7b66d77ec37e5abef23febb7ecd097abae1a6c0d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"45bfc2826bc8e6030636e615e167c2c6b4fdc671","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e05770edcadf814fb5937f9863b80b68ce9a1da2","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java","status":"removed","additions":0,"deletions":237,"changes":237,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"bc150df3461fffad145e0aba43c75f94c17a13a8","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java","status":"removed","additions":0,"deletions":273,"changes":273,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0fcde3394ec03d8ddecf0f0b738d2b674ca76bde","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java","status":"removed","additions":0,"deletions":116,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6f55fcbf3763f80c7ada40cb320916f781115188","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java","status":"removed","additions":0,"deletions":35,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"2d4a633fa7fe7c79d1496d4ac1eb1785ff4c73a8","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java","status":"removed","additions":0,"deletions":129,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6de9021bee196b87f7301ad9c5ed268463855453","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java","status":"removed","additions":0,"deletions":261,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0bc8a8e6b8d6deb0489d60bc9bdc35448cc27ab3","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java","status":"removed","additions":0,"deletions":71,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"5bc1a079794352110e84f9a4409554eb16fa341c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b4da7a70e10fdad19d9b8d68ca93043caf49b4cc","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7ea8cc02573b948e423485472c33262a849d5c52","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7833e019c3720720a65ef6aad4e58757ce767044","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java","status":"removed","additions":0,"deletions":145,"changes":145,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"087c5ef4ba9e928700c844dfcf53357248a767da","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java","status":"removed","additions":0,"deletions":413,"changes":413,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b14ef718c50552a9ec9ccc5bbbaedd97547e17bb","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java","status":"removed","additions":0,"deletions":322,"changes":322,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fa79d69ea1a85ad6ff7a2840847e267efad82f5e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java","status":"removed","additions":0,"deletions":214,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c4fa74de491bf5d9b53c7d747c0212fa5abc7033","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java","status":"removed","additions":0,"deletions":192,"changes":192,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a9272793d7575be2bf73cd27c2c61e62fb8311b6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java","status":"removed","additions":0,"deletions":628,"changes":628,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b8d12da0fa03c9f4ac7c37eaa16999171a4b242d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java","status":"removed","additions":0,"deletions":256,"changes":256,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0a9968b50f8f50fadf378ea041ee37363ff2fc8b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java","status":"removed","additions":0,"deletions":119,"changes":119,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"edf180b819b2f00ab3b59df71831e164a1fef31e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"adfb47dc7c0df2a11613fd6caf83a89c71a3978d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java","status":"removed","additions":0,"deletions":340,"changes":340,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fa7b0eae6534393d42aecbb1fa09322b966cbc2c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java","status":"removed","additions":0,"deletions":241,"changes":241,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"3f570df014ca89eccbb5fecd591a58e502dfd194","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6fd3ef5e618c39df78278dd1ea8def0cd6af91a5","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"31d021946de943231020b3c006c4bf29b7293f7b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java","status":"removed","additions":0,"deletions":66,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0327f664bd02f11b14542e67ce56eb88e6e18d69","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java","status":"removed","additions":0,"deletions":107,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c2902cf85729ce2b6b8535b2ce0c9c7a1d26e129","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java","status":"removed","additions":0,"deletions":157,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"2c1e24ce4287859f7e4c06615bbbc9169e5e3fb1","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java","status":"removed","additions":0,"deletions":300,"changes":300,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"375004be89d3a4c498246fe6250c8cf2b72a1517","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java","status":"removed","additions":0,"deletions":161,"changes":161,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6b9a2f9c865a0996080489823d0a307e7cc836f3","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java","status":"removed","additions":0,"deletions":120,"changes":120,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"1f9ce8ef91393588580716bb8165eee77ece59f6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java","status":"removed","additions":0,"deletions":86,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c4f55d4cfbb7ab363600cecd5456c090aaba3ebc","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java","status":"removed","additions":0,"deletions":82,"changes":82,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"197e3fdb9be75118ff9a11b708052f5e9fae1847","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java","status":"removed","additions":0,"deletions":29,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a9584a83ce3ab60c753156653be3c63af64dc85a","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java","status":"removed","additions":0,"deletions":267,"changes":267,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"12dfe3af8a7081186408c9eced3fe503c3037b3e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"49537627247223c489f4085610f28be64f0d5867","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"1a89fe5ea63cd4e8429aafb376e84da91dce98d3","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ecf8830ea8d0b10d33aef09323a8751a4e3da1fe","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java","status":"removed","additions":0,"deletions":95,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"be64fc4ce6112546bb5e0332167c6017457e2ee0","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java","status":"removed","additions":0,"deletions":337,"changes":337,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"918dbbf11b97e4a9b658461b3907e26771df9dc3","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java","status":"removed","additions":0,"deletions":376,"changes":376,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7895b1d73d45caede79d77a8d430d286545cf653","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"96e4a11649f279bf27e38c74a65338082d8dd155","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java","status":"removed","additions":0,"deletions":399,"changes":399,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"4d4a36d3f2f6ba37b60e2e952704545ab4b92e97","filename":"hedwig-client/conf/hw_client.conf","status":"removed","additions":0,"deletions":22,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/conf/hw_client.conf","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/conf/hw_client.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/conf/hw_client.conf?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"30f0dfb3d703f1ce7cf80c5989e1f63459dd96d4","filename":"hedwig-client/pom.xml","status":"removed","additions":0,"deletions":142,"changes":142,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/pom.xml?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"308407cf611e970d9160b3137214d0388872f81a","filename":"hedwig-client/src/main/cpp/Makefile.am","status":"removed","additions":0,"deletions":44,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/Makefile.am?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f6fd377f8d847ea6234b229074ae02e5b6c00083","filename":"hedwig-client/src/main/cpp/README","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/README","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/README","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/README?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"420049eca3564dd70362b6d980574d0c36cf4fc5","filename":"hedwig-client/src/main/cpp/aminclude.am","status":"removed","additions":0,"deletions":186,"changes":186,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/aminclude.am","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/aminclude.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/aminclude.am?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f5ac9c7aa8c15b8ea71b0e2ddc078eca5ace74e9","filename":"hedwig-client/src/main/cpp/c-doc.Doxyfile","status":"removed","additions":0,"deletions":1267,"changes":1267,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/c-doc.Doxyfile","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/c-doc.Doxyfile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/c-doc.Doxyfile?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"efc6e05c96107f4fd10c20103edc1e36935b4aee","filename":"hedwig-client/src/main/cpp/configure.ac","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/configure.ac","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/configure.ac","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/configure.ac?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"1e7eea1644da3e9730b75a08a173bdee47efbffc","filename":"hedwig-client/src/main/cpp/hedwig-0.1.pc.in","status":"removed","additions":0,"deletions":30,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/hedwig-0.1.pc.in","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/hedwig-0.1.pc.in","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/hedwig-0.1.pc.in?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"80e961b077d373a13d31c8acda00f5aa694e8cfb","filename":"hedwig-client/src/main/cpp/inc/hedwig/callback.h","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/callback.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/callback.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/callback.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7b914bcfa8de97f6075cfb1b7ed94cd3ba48735b","filename":"hedwig-client/src/main/cpp/inc/hedwig/client.h","status":"removed","additions":0,"deletions":98,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/client.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/client.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/client.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b44fed96eed9bdd3265fadc4bbba063cae683bf1","filename":"hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ea08838df9130d648be5984a38ca6991287cc8cc","filename":"hedwig-client/src/main/cpp/inc/hedwig/publish.h","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/publish.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/publish.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/publish.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"4bc718c2a1652fae51c9f1d655a165daa970235e","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"removed","additions":0,"deletions":71,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f19a3da8339280f1f88095b7471b74151c81a1d5","filename":"hedwig-client/src/main/cpp/lib/Makefile.am","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/Makefile.am?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b980e53bf0a57532c521547a80bd60230245a6cb","filename":"hedwig-client/src/main/cpp/lib/channel.cpp","status":"removed","additions":0,"deletions":801,"changes":801,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/channel.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/channel.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c9ef2892aed586edeb6d963c9074e3473cdb4a5f","filename":"hedwig-client/src/main/cpp/lib/channel.h","status":"removed","additions":0,"deletions":438,"changes":438,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/channel.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/channel.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e98c45293fa6030c5a2494fbbc7b1aaa8ea89f17","filename":"hedwig-client/src/main/cpp/lib/client.cpp","status":"removed","additions":0,"deletions":66,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/client.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/client.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/client.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"40114d6e8ec47e0f6ebabe9105173e8ad5b07dc9","filename":"hedwig-client/src/main/cpp/lib/clientimpl.cpp","status":"removed","additions":0,"deletions":738,"changes":738,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/clientimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/clientimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fd7915ccd53bec12dc5f03e38f61f5f9d6e03bb0","filename":"hedwig-client/src/main/cpp/lib/clientimpl.h","status":"removed","additions":0,"deletions":493,"changes":493,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/clientimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/clientimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"24d458e06d871729e7b3a573da0ba82cd207386c","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"removed","additions":0,"deletions":277,"changes":277,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0639f4a80fda82e09b8be1a855385089daf49bc7","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"af3560c5d3dc3c91dddceb2e68a86d4238c2a180","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b6a75040a4fea40ba4e05adc02f43439b7f6d824","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.h","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/eventdispatcher.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/eventdispatcher.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"9e062dcf03e17e068f61a3dfc8d4d3d83166185d","filename":"hedwig-client/src/main/cpp/lib/exceptions.cpp","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/exceptions.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/exceptions.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/exceptions.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"07d884c2ce43ad8f3781dc2f76eb009319fa8558","filename":"hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"2d24bd5c9763e02e324df3ec76fa86f81a16e74d","filename":"hedwig-client/src/main/cpp/lib/filterablemessagehandler.h","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/filterablemessagehandler.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/filterablemessagehandler.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/filterablemessagehandler.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8c8767a8be5170f0922fbe481690af68f2a4d00f","filename":"hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp","status":"removed","additions":0,"deletions":566,"changes":566,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8e9711e794f403a9b449594f8e5a7fe8a5944a33","filename":"hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h","status":"removed","additions":0,"deletions":193,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/multiplexsubscriberimpl.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"033f17c4e61ea1157ab8aaa724d7e6960fe9f6ee","filename":"hedwig-client/src/main/cpp/lib/publisherimpl.cpp","status":"removed","additions":0,"deletions":134,"changes":134,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/publisherimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/publisherimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/publisherimpl.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"335a219226d7880c83fb8d9d59945d23a158f0c8","filename":"hedwig-client/src/main/cpp/lib/publisherimpl.h","status":"removed","additions":0,"deletions":66,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/publisherimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/publisherimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/publisherimpl.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"3f59e1b1c01726e275070f1de06a702ae1bd2274","filename":"hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","status":"removed","additions":0,"deletions":495,"changes":495,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b73fa81ea703018e9996c200231aec0038658661","filename":"hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","status":"removed","additions":0,"deletions":196,"changes":196,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/simplesubscriberimpl.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8573ceabc87c16f5b52da9d04c80eeb675893a50","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"removed","additions":0,"deletions":687,"changes":687,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0cdf5f17c295276f698b67734804c97f8e1b80ab","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"removed","additions":0,"deletions":338,"changes":338,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b5a7cc081b47b5c552e2ac21cf4282079efb6962","filename":"hedwig-client/src/main/cpp/lib/util.cpp","status":"removed","additions":0,"deletions":183,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/util.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/util.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a7741e2afc03a9d49c1da971c148841c672293a2","filename":"hedwig-client/src/main/cpp/lib/util.h","status":"removed","additions":0,"deletions":128,"changes":128,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/lib/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8cc46662f6229fea2ccf523e19eb504af87aa66b","filename":"hedwig-client/src/main/cpp/m4/ax_boost_asio.m4","status":"removed","additions":0,"deletions":111,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_boost_asio.m4","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_boost_asio.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_boost_asio.m4?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8f935f6bc61377ff824f9af0a1d3f44bdd9d8d20","filename":"hedwig-client/src/main/cpp/m4/ax_boost_base.m4","status":"removed","additions":0,"deletions":252,"changes":252,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_boost_base.m4","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_boost_base.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_boost_base.m4?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fb7e5308610737a97b1e20b71e1cc174dc71cb26","filename":"hedwig-client/src/main/cpp/m4/ax_boost_thread.m4","status":"removed","additions":0,"deletions":149,"changes":149,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_boost_thread.m4","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_boost_thread.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_boost_thread.m4?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6334fd41223259652f99dc0b9206b65a0eef4fb5","filename":"hedwig-client/src/main/cpp/m4/ax_doxygen.m4","status":"removed","additions":0,"deletions":533,"changes":533,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_doxygen.m4","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/ax_doxygen.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_doxygen.m4?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"648f43c4abcbf55e901c677013237bc54067f932","filename":"hedwig-client/src/main/cpp/m4/gtest.m4","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/gtest.m4","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/m4/gtest.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/gtest.m4?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"1917d7e9fa6707e2501b63aff4bb9b92a991e179","filename":"hedwig-client/src/main/cpp/scripts/log4cxx.conf","status":"removed","additions":0,"deletions":44,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/log4cxx.conf","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/log4cxx.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/log4cxx.conf?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"83fd132fed15de2285c90729e169a8be90109175","filename":"hedwig-client/src/main/cpp/scripts/network-delays.sh","status":"removed","additions":0,"deletions":68,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/network-delays.sh","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/network-delays.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/network-delays.sh?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"cd8563a620b27007d33b54df1ee3c582e2b287fe","filename":"hedwig-client/src/main/cpp/scripts/server-control.sh","status":"removed","additions":0,"deletions":170,"changes":170,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/server-control.sh","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/server-control.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/server-control.sh?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"85e1f747fbd498e458a4186da1a3fceb67e6e665","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"removed","additions":0,"deletions":175,"changes":175,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"d55100cc584e7752daa19330fc9e79a1405beb60","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7c08c9765b4058e53bb79e7cc9a763e070f07fa4","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"9315e72a2fae3f6ec3f8bbe9983a487ced383223","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"removed","additions":0,"deletions":216,"changes":216,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"907d95da72386364160b455dfae5079db3a738c9","filename":"hedwig-client/src/main/cpp/test/messagefiltertest.cpp","status":"removed","additions":0,"deletions":248,"changes":248,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/messagefiltertest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/messagefiltertest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messagefiltertest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"534d9ef49470d25d142d7b106c416f1cb78ee34c","filename":"hedwig-client/src/main/cpp/test/multiplextest.cpp","status":"removed","additions":0,"deletions":418,"changes":418,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/multiplextest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/multiplextest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/multiplextest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"46b146ab8950fd80675d9d2224a4fbefa5545cfc","filename":"hedwig-client/src/main/cpp/test/publishtest.cpp","status":"removed","additions":0,"deletions":318,"changes":318,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/publishtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/publishtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/publishtest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"9baba1d8ed2ba82e9e44ed76ba08cc411c25faf2","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"removed","additions":0,"deletions":735,"changes":735,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"3ee736a1a4cd0e1c9a1aecc29e78eb1e76b2a5f4","filename":"hedwig-client/src/main/cpp/test/subscribetest.cpp","status":"removed","additions":0,"deletions":253,"changes":253,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/subscribetest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/subscribetest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/subscribetest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c75bc3f1fb1155d44c2a9aefb2214a5197209a64","filename":"hedwig-client/src/main/cpp/test/test.sh","status":"removed","additions":0,"deletions":21,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/test.sh","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/test.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/test.sh?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"9dd0d9ff91b6b8d88dc7d5eeb16aef5655e421a6","filename":"hedwig-client/src/main/cpp/test/throttledeliverytest.cpp","status":"removed","additions":0,"deletions":159,"changes":159,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/throttledeliverytest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/throttledeliverytest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/throttledeliverytest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"dd5b5bfa7bef7c7d3ccbcb85006343946e886b2f","filename":"hedwig-client/src/main/cpp/test/util.h","status":"removed","additions":0,"deletions":201,"changes":201,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e5b6d75afb37288a9d338bd193b2a1ac1cfb34c5","filename":"hedwig-client/src/main/cpp/test/utiltest.cpp","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/utiltest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/cpp/test/utiltest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/utiltest.cpp?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"4092a47f9bafabef8a2da41b0780f8147ed2a6a8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/HedwigClient.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/HedwigClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/HedwigClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/HedwigClient.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"891148fe25897d9498167a56f35172a3ea2f6531","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Client.java","status":"removed","additions":0,"deletions":42,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Client.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Client.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Client.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f312a36bfb358d6eebc32510a552d83dc1e2c511","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","status":"removed","additions":0,"deletions":48,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a4fdb043bfa28dfea541a7719f22221dd0008acf","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7e05c0e69997e4a3f3d843dfc7aceabccfeadcd8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","status":"removed","additions":0,"deletions":380,"changes":380,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"531840ff251a23e23a1c0c784a47150194b46d2d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","status":"removed","additions":0,"deletions":144,"changes":144,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"38dfc3cd90f3ca41536a72840d3617b6c8a86c0d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"3efe22da20938a875dee575044d9c5e4e9d234b0","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","status":"removed","additions":0,"deletions":191,"changes":191,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e7b15f26a2ffef6e44573adf95a011e296007fd8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"cc5e93778a041724de8a050276fcc3497f14c21b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","status":"removed","additions":0,"deletions":165,"changes":165,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"836a9d228e13a023586abbf56b8fea674aee4dd0","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","status":"removed","additions":0,"deletions":171,"changes":171,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"346d74b34b1a728f38b0a74e036fc88b1c0e8474","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"63547a0fdafff58646fe83f713c16d9741aa0abd","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"removed","additions":0,"deletions":179,"changes":179,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"064cec12d379684adec3a4f33a46f22625919783","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"5f468e6d3f5b05408946f3485861e8004d13f030","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","status":"removed","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"3e543569f09f1dab37b23542115faeb85c088e85","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","status":"removed","additions":0,"deletions":37,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"22b44b16f649b0efd93b9530164ae9aad9b962e5","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c9aeb385307340e75c03e24195d333ef0fbc5933","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"da6d4e7d39ee0a1359a9f2dcb364697e3ae25384","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"4a3c99f0f42beea2858fc203a824a1d93a2a3885","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b8a6787806218d916cf41e56453574e992c4879d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","status":"removed","additions":0,"deletions":156,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c5b58a0cea09347f4adac25139469cc4db216d8d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java","status":"removed","additions":0,"deletions":78,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"32517b0a3cf47def2b646b0f31780571210640d0","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","status":"removed","additions":0,"deletions":117,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"3f5fbcd58c3faff33e6652589be1fa6503b5f099","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","status":"removed","additions":0,"deletions":94,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8b2e9d1515308cb6b99dda0669a90fd461ce37a6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","status":"removed","additions":0,"deletions":69,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6b2a9655367f6e9c932d84ceb44e7997021423ee","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"removed","additions":0,"deletions":180,"changes":180,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0d3e8a678d4eca2bee3d3f6f2625d7962f865516","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","status":"removed","additions":0,"deletions":80,"changes":80,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a6ba2a68848f118679b7303b116f865e69fcb707","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","status":"removed","additions":0,"deletions":183,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"94e0a808e7858020c4d0f3692126b7590bc169bb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","status":"removed","additions":0,"deletions":70,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"340cec57553513c96524c12f7f2826648107581e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6fae6bb2588d6d6b666df72793c3628c16fba38e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","status":"removed","additions":0,"deletions":160,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8ae0e8207e171f4d8b79ca9e605f573709884ca0","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"removed","additions":0,"deletions":128,"changes":128,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"271d1eb665e0517b61f5bf0943c97f392555a317","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"removed","additions":0,"deletions":151,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"0eda2900635969d12fffada2ad0cf08fe5a1396f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"removed","additions":0,"deletions":422,"changes":422,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"1d4f95555ac34c9ddff68e913c0b865b09de581c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","status":"removed","additions":0,"deletions":221,"changes":221,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ffe866108ec54a3fbf082d91e198bf53ecaabf18","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"dc2cf8bc2007377fe4d57c39bf407a481c00bf39","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java","status":"removed","additions":0,"deletions":42,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"614efa17de4de2086eb7f276ef1692bbbeb1c0af","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","status":"removed","additions":0,"deletions":622,"changes":622,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"7fcfc44194adaaeace29913a094ca18004e18202","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","status":"removed","additions":0,"deletions":365,"changes":365,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"10506d821af6e15a71ec4ab531dc54ccf319e425","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","status":"removed","additions":0,"deletions":382,"changes":382,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ab86f236091e4a2db5364bd392cc2ad537e3cedb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"065b2f75e7979b954733b9383081f42e56d8462a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c41a3290e5adfca9e9486eedff0fc2bde44f5d95","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","status":"removed","additions":0,"deletions":280,"changes":280,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fd58747b87182b2df95e3a5d25ddfd609e3bb0a5","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","status":"removed","additions":0,"deletions":371,"changes":371,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"a91bbf8dbb7bb64edbb884522c09f666959c2fe6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"17d24018ca17f77354506ee354b126006f15719c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","status":"removed","additions":0,"deletions":108,"changes":108,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c7a71cbe1abe55aa0eda641c92132e08da8cc85c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","status":"removed","additions":0,"deletions":111,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"caa0734e4069f4fcddb4d936832ca9d07d146996","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","status":"removed","additions":0,"deletions":314,"changes":314,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"9b8ebe049b622fb7b85d69b12b16dcd1679dc994","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","status":"removed","additions":0,"deletions":129,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"c43108a90f140d7a4eb5ef9c6ecf46d4140b6608","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"fb0a7d960bed702239461a4c6f68fdac2475935c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","status":"removed","additions":0,"deletions":358,"changes":358,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ee5bd905701f4f33a8af5d60fa9951a8bcc1a1c3","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","status":"removed","additions":0,"deletions":273,"changes":273,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"d14f0536adfad9339708d2dfc6881972d40285f2","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"07236a5e816319e6cb1f3b63828bf3e23ac9e2a8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"ee488ba56f882a3194753fa02de54dc2aaf2cf36","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"33c5a53bd3afa6888ecb13690dd0967d0bf5e0a8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","status":"removed","additions":0,"deletions":66,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"57232ba375d47db6d15dece98d6cd50dc77f0cad","filename":"hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"96ef0d97d9ed34287e33f534878e9b583848d412","filename":"hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java","status":"removed","additions":0,"deletions":24,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"e654038b4498c85cd21b438053265aea58856ad0","filename":"hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"6b473ad6e7642df67a472daa417f990fbcd6b770","filename":"hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"f4c22488675a95fc1d0a9b54f5f710fb7696860c","filename":"hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"78deef1de2f2ecb8853a5cf4b3ae7717d70b2b01","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8f0fda8166f21c507e3a9088f1e1e0e4cf1f3cb4","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","status":"removed","additions":0,"deletions":183,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"8f5f1cae9c5788524b1fb1bb57922f63a652737a","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"},{"sha":"b8ae82ffbb99899a109396cb19b747d1e1652092","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","raw_url":"https://github.com/apache/bookkeeper/raw/410ff7263a477d4b75a43d006adde3549225a4b9/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java?ref=410ff7263a477d4b75a43d006adde3549225a4b9"}]}

