{"sha":"9b1e561cb5e4f081f40bf8b751bcc2c16226092e","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5YjFlNTYxY2I1ZTRmMDgxZjQwYmY4Yjc1MWJjYzJjMTYyMjYwOTJl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-01-21T16:26:23Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-01-21T16:26:23Z"},"message":"BOOKKEEPER-661: Turn readonly back to writable if spaces are reclaimed. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1560066 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"32c648d0b6dde3685792d19e27aaf0c35a39c2e5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/32c648d0b6dde3685792d19e27aaf0c35a39c2e5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9b1e561cb5e4f081f40bf8b751bcc2c16226092e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9b1e561cb5e4f081f40bf8b751bcc2c16226092e","html_url":"https://github.com/apache/bookkeeper/commit/9b1e561cb5e4f081f40bf8b751bcc2c16226092e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"23f3760dd5d79e6894616834aa41d59089c9548a","url":"https://api.github.com/repos/apache/bookkeeper/commits/23f3760dd5d79e6894616834aa41d59089c9548a","html_url":"https://github.com/apache/bookkeeper/commit/23f3760dd5d79e6894616834aa41d59089c9548a"}],"stats":{"total":479,"additions":383,"deletions":96},"files":[{"sha":"bb190efa3451f24769bf89e8b68fdaa02e09d48f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -144,6 +144,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-696: stats collection on bookkeeper client (Aniruddha, ivank via sijie)\n \n+        BOOKKEEPER-661: Turn readonly back to writable if spaces are reclaimed. (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"39c58f8907f3d87922be7ab8938af80991a180f6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":132,"deletions":50,"changes":182,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -65,6 +65,7 @@\n import org.apache.zookeeper.Watcher.Event.EventType;\n import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -96,7 +97,7 @@\n     // ZK registration path for this bookie\n     private final String bookieRegistrationPath;\n \n-    private LedgerDirsManager ledgerDirsManager;\n+    private final LedgerDirsManager ledgerDirsManager;\n     private LedgerDirsManager indexDirsManager;\n \n     // ZooKeeper client instance for the Bookie\n@@ -116,6 +117,7 @@\n     final ConcurrentMap<Long, byte[]> masterKeyCache = new ConcurrentHashMap<Long, byte[]>();\n \n     final private String zkBookieRegPath;\n+    final private String zkBookieReadOnlyPath;\n \n     final private AtomicBoolean readOnly = new AtomicBoolean(false);\n \n@@ -244,6 +246,7 @@ public static void checkDirectoryStructure(File dir) throws IOException {\n \n             final AtomicBoolean oldDataExists = new AtomicBoolean(false);\n             parent.list(new FilenameFilter() {\n+                    @Override\n                     public boolean accept(File dir, String name) {\n                         if (name.endsWith(\".txn\") || name.endsWith(\".idx\") || name.endsWith(\".log\")) {\n                             oldDataExists.set(true);\n@@ -443,7 +446,9 @@ public Bookie(ServerConfiguration conf)\n         handles = new HandleFactoryImpl(ledgerStorage);\n \n         // ZK ephemeral node for this Bookie.\n-        zkBookieRegPath = this.bookieRegistrationPath + getMyId();\n+        String myID = getMyId();\n+        zkBookieRegPath = this.bookieRegistrationPath + myID;\n+        zkBookieReadOnlyPath = this.bookieRegistrationPath + BookKeeperConstants.READONLY + \"/\" + myID;\n     }\n \n     private String getMyId() throws UnknownHostException {\n@@ -502,6 +507,7 @@ public void process(int journalVersion, long offset, ByteBuffer recBuff) throws\n         });\n     }\n \n+    @Override\n     synchronized public void start() {\n         setDaemon(true);\n         LOG.debug(\"I'm starting a bookie with journal directory {}\", journalDirectory.getName());\n@@ -582,6 +588,18 @@ public void fatalError() {\n                 LOG.error(\"Fatal error reported by ledgerDirsManager\");\n                 triggerBookieShutdown(ExitCode.BOOKIE_EXCEPTION);\n             }\n+\n+            @Override\n+            public void diskWritable(File disk) {\n+                // Transition to writable mode when a disk becomes writable again.\n+                transitionToWritableMode();\n+            }\n+\n+            @Override\n+            public void diskJustWritable(File disk) {\n+                // Transition to writable mode when a disk becomes writable again.\n+                transitionToWritableMode();\n+            }\n         };\n     }\n \n@@ -644,6 +662,56 @@ private ZooKeeper instantiateZookeeperClient(ServerConfiguration conf)\n         return newZookeeper(conf.getZkServers(), conf.getZkTimeout());\n     }\n \n+    /**\n+     * Check existence of <i>regPath</i> and wait it expired if possible\n+     *\n+     * @param regPath\n+     *          reg node path.\n+     * @return true if regPath exists, otherwise return false\n+     * @throws IOException if can't create reg path\n+     */\n+    protected boolean checkRegNodeAndWaitExpired(String regPath) throws IOException {\n+        final CountDownLatch prevNodeLatch = new CountDownLatch(1);\n+        Watcher zkPrevRegNodewatcher = new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                // Check for prev znode deletion. Connection expiration is\n+                // not handling, since bookie has logic to shutdown.\n+                if (EventType.NodeDeleted == event.getType()) {\n+                    prevNodeLatch.countDown();\n+                }\n+            }\n+        };\n+        try {\n+            Stat stat = zk.exists(regPath, zkPrevRegNodewatcher);\n+            if (null != stat) {\n+                // if the ephemeral owner isn't current zookeeper client\n+                // wait for it to be expired.\n+                if (stat.getEphemeralOwner() != zk.getSessionId()) {\n+                    LOG.info(\"Previous bookie registration znode: {} exists, so waiting zk sessiontimeout:\"\n+                            + \" {} ms for znode deletion\", regPath, conf.getZkTimeout());\n+                    // waiting for the previous bookie reg znode deletion\n+                    if (!prevNodeLatch.await(conf.getZkTimeout(), TimeUnit.MILLISECONDS)) {\n+                        throw new NodeExistsException(regPath);\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        } catch (KeeperException ke) {\n+            LOG.error(\"ZK exception checking and wait ephemeral znode {} expired : \", regPath, ke);\n+            throw new IOException(\"ZK exception checking and wait ephemeral znode \"\n+                    + regPath + \" expired\", ke);\n+        } catch (InterruptedException ie) {\n+            LOG.error(\"Interrupted checking and wait ephemeral znode {} expired : \", regPath, ie);\n+            throw new IOException(\"Interrupted checking and wait ephemeral znode \"\n+                    + regPath + \" expired\", ie);\n+        }\n+    }\n+\n     /**\n      * Register as an available bookie\n      */\n@@ -654,39 +722,14 @@ protected void registerBookie(ServerConfiguration conf) throws IOException {\n         }\n \n         // ZK ephemeral node for this Bookie.\n-        String zkBookieRegPath = this.bookieRegistrationPath\n-            + StringUtils.addrToString(getBookieAddress(conf));\n-        final CountDownLatch prevNodeLatch = new CountDownLatch(1);\n         try{\n-            Watcher zkPrevRegNodewatcher = new Watcher() {\n-                @Override\n-                public void process(WatchedEvent event) {\n-                    // Check for prev znode deletion. Connection expiration is\n-                    // not handling, since bookie has logic to shutdown.\n-                    if (EventType.NodeDeleted == event.getType()) {\n-                        prevNodeLatch.countDown();\n-                    }\n-                }\n-            };\n-            if (null != zk.exists(zkBookieRegPath, zkPrevRegNodewatcher)) {\n-                LOG.info(\"Previous bookie registration znode: \"\n-                        + zkBookieRegPath\n-                        + \" exists, so waiting zk sessiontimeout: \"\n-                        + conf.getZkTimeout() + \"ms for znode deletion\");\n-                // waiting for the previous bookie reg znode deletion\n-                if (!prevNodeLatch.await(conf.getZkTimeout(),\n-                        TimeUnit.MILLISECONDS)) {\n-                    throw new KeeperException.NodeExistsException(\n-                            zkBookieRegPath);\n-                }\n+            if (!checkRegNodeAndWaitExpired(zkBookieRegPath)) {\n+                // Create the ZK ephemeral node for this Bookie.\n+                zk.create(zkBookieRegPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                        CreateMode.EPHEMERAL);\n             }\n-\n-            // Create the ZK ephemeral node for this Bookie.\n-            zk.create(zkBookieRegPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n-                    CreateMode.EPHEMERAL);\n         } catch (KeeperException ke) {\n-            LOG.error(\"ZK exception registering ephemeral Znode for Bookie!\",\n-                    ke);\n+            LOG.error(\"ZK exception registering ephemeral Znode for Bookie!\", ke);\n             // Throw an IOException back up. This will cause the Bookie\n             // constructor to error out. Alternatively, we could do a System\n             // exit here as this is a fatal error.\n@@ -701,12 +744,43 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n-    /*\n+    /**\n+     * Transition the bookie from readOnly mode to writable\n+     */\n+    @VisibleForTesting\n+    public void transitionToWritableMode() {\n+        if (!readOnly.compareAndSet(true, false)) {\n+            return;\n+        }\n+        LOG.info(\"Transitioning Bookie to Writable mode and will serve read/write requests.\");\n+        try {\n+            this.registerBookie(conf);\n+        } catch (IOException e) {\n+            LOG.warn(\"Error in transitioning back to writable mode : \", e);\n+            transitionToReadOnlyMode();\n+            return;\n+        }\n+        // clear the readonly state\n+        try {\n+            zk.delete(zkBookieReadOnlyPath, -1);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            LOG.warn(\"Interrupted clearing readonly state while transitioning to writable mode : \", e);\n+            return;\n+        } catch (KeeperException e) {\n+            // if we failed when deleting the readonly flag in zookeeper, it is OK since client would\n+            // already see the bookie in writable list. so just log the exception\n+            LOG.warn(\"Failed to delete bookie readonly state in zookeeper : \", e);\n+            return;\n+        }\n+    }\n+\n+    /**\n      * Transition the bookie to readOnly mode\n      */\n     @VisibleForTesting\n     public void transitionToReadOnlyMode() {\n-        if (shuttingdown == true) {\n+        if (shuttingdown) {\n             return;\n         }\n \n@@ -734,12 +808,18 @@ public void transitionToReadOnlyMode() {\n                     // this node is just now created by someone.\n                 }\n             }\n-            // Create the readonly node\n-            zk.create(this.bookieRegistrationPath\n-                    + BookKeeperConstants.READONLY + \"/\" + getMyId(),\n-                    new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n-            // Clear the current registered node\n-            zk.delete(zkBookieRegPath, -1);\n+            if (!checkRegNodeAndWaitExpired(zkBookieReadOnlyPath)) {\n+                // Create the readonly node\n+                zk.create(zkBookieReadOnlyPath,\n+                        new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+            }\n+            try {\n+                // Clear the current registered node\n+                zk.delete(zkBookieRegPath, -1);\n+            } catch (KeeperException.NoNodeException nne) {\n+                LOG.warn(\"No writable bookie registered node {} when transitioning to readonly\",\n+                        zkBookieRegPath, nne);\n+            }\n         } catch (IOException e) {\n             LOG.error(\"Error in transition to ReadOnly Mode.\"\n                     + \" Shutting down\", e);\n@@ -837,6 +917,7 @@ void triggerBookieShutdown(final int exitCode) {\n         LOG.info(\"Triggering shutdown of Bookie-{} with exitCode {}\",\n                  conf.getBookiePort(), exitCode);\n         BookieThread th = new BookieThread(\"BookieShutdownTrigger\") {\n+            @Override\n             public void run() {\n                 Bookie.this.shutdown(exitCode);\n             }\n@@ -897,14 +978,14 @@ synchronized int shutdown(int exitCode) {\n         return this.exitCode;\n     }\n \n-    /** \n+    /**\n      * Retrieve the ledger descriptor for the ledger which entry should be added to.\n-     * The LedgerDescriptor returned from this method should be eventually freed with \n+     * The LedgerDescriptor returned from this method should be eventually freed with\n      * #putHandle().\n      *\n      * @throws BookieException if masterKey does not match the master key of the ledger\n      */\n-    private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey) \n+    private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey)\n             throws IOException, BookieException {\n         long ledgerId = entry.getLong();\n         LedgerDescriptor l = handles.getHandle(ledgerId, masterKey);\n@@ -932,7 +1013,7 @@ protected void addEntryByLedgerId(long ledgerId, ByteBuffer entry)\n     }\n \n     /**\n-     * Add an entry to a ledger as specified by handle. \n+     * Add an entry to a ledger as specified by handle.\n      */\n     private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCallback cb, Object ctx)\n             throws IOException, BookieException {\n@@ -947,11 +1028,11 @@ private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCa\n \n     /**\n      * Add entry to a ledger, even if the ledger has previous been fenced. This should only\n-     * happen in bookie recovery or ledger recovery cases, where entries are being replicates \n+     * happen in bookie recovery or ledger recovery cases, where entries are being replicates\n      * so that they exist on a quorum of bookies. The corresponding client side call for this\n      * is not exposed to users.\n      */\n-    public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey) \n+    public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n             throws IOException, BookieException {\n         try {\n             LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n@@ -963,8 +1044,8 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n             throw new IOException(e);\n         }\n     }\n-    \n-    /** \n+\n+    /**\n      * Add entry to a ledger.\n      * @throws BookieException.LedgerFencedException if the ledger is fenced\n      */\n@@ -1026,6 +1107,7 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n     static class CounterCallback implements WriteCallback {\n         int count;\n \n+        @Override\n         synchronized public void writeComplete(int rc, long l, long e, InetSocketAddress addr, Object ctx) {\n             count--;\n             if (count == 0) {\n@@ -1046,7 +1128,7 @@ synchronized public void waitZero() throws InterruptedException {\n \n     /**\n      * Format the bookie server data\n-     * \n+     *\n      * @param conf\n      *            ServerConfiguration\n      * @param isInteractive\n@@ -1135,7 +1217,7 @@ private static boolean cleanDir(File dir) {\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    public static void main(String[] args) \n+    public static void main(String[] args)\n             throws IOException, InterruptedException, BookieException, KeeperException {\n         Bookie b = new Bookie(new ServerConfiguration());\n         b.start();"},{"sha":"a02bb05f54f944a4bbb649de82417faade85c8ae","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":13,"deletions":3,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -42,8 +42,8 @@\n import java.util.List;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -62,8 +62,8 @@\n     private static final Logger LOG = LoggerFactory.getLogger(EntryLogger.class);\n \n     volatile File currentDir;\n-    private LedgerDirsManager ledgerDirsManager;\n-    private AtomicBoolean shouldCreateNewEntryLog = new AtomicBoolean(false);\n+    private final LedgerDirsManager ledgerDirsManager;\n+    private final AtomicBoolean shouldCreateNewEntryLog = new AtomicBoolean(false);\n \n     private long logId;\n     private volatile long leastUnflushedLogId;\n@@ -233,6 +233,16 @@ public void allDisksFull() {\n             public void fatalError() {\n                 // Nothing to handle here. Will be handled in Bookie\n             }\n+\n+            @Override\n+            public void diskWritable(File disk) {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n+\n+            @Override\n+            public void diskJustWritable(File disk) {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n         };\n     }\n "},{"sha":"74c6ec2d3840e39a016383571f98b1ec8e3a51d0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -276,13 +276,20 @@ public void clean(long ledgerId) {\n         lastMinorCompactionTime = lastMajorCompactionTime = MathUtils.now();\n     }\n \n-    synchronized void forceGC() {\n+    public synchronized void enableForceGC() {\n         if (forceGarbageCollection.compareAndSet(false, true)) {\n             LOG.info(\"Forced garbage collection triggered by thread: {}\", Thread.currentThread().getName());\n             notify();\n         }\n     }\n \n+    public void disableForceGC() {\n+        if (forceGarbageCollection.compareAndSet(true, false)) {\n+            LOG.info(\"{} disabled force garbage collection since bookie has enough space now.\", Thread\n+                    .currentThread().getName());\n+        }\n+    }\n+\n     @Override\n     public void run() {\n         while (running) {"},{"sha":"9f674ad6f92189a2da739b65c8ba36625b63b597","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -23,6 +23,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.LinkedList;\n@@ -367,6 +368,16 @@ public void allDisksFull() {\n             public void fatalError() {\n                 // Nothing to handle here. Will be handled in Bookie\n             }\n+\n+            @Override\n+            public void diskWritable(File disk) {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n+\n+            @Override\n+            public void diskJustWritable(File disk) {\n+                // Nothing to handle here. Will be handled in Bookie\n+            }\n         };\n     }\n "},{"sha":"85cc029c5b03b302c0f18732d31d91b5885e8dda","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":15,"deletions":3,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -111,23 +111,35 @@ public void diskFailed(File disk) {\n \n             @Override\n             public void diskAlmostFull(File disk) {\n-                gcThread.forceGC();\n+                gcThread.enableForceGC();\n             }\n \n             @Override\n             public void diskFull(File disk) {\n-                gcThread.forceGC();\n+                gcThread.enableForceGC();\n             }\n \n             @Override\n             public void allDisksFull() {\n-                gcThread.forceGC();\n+                gcThread.enableForceGC();\n             }\n \n             @Override\n             public void fatalError() {\n                 // do nothing.\n             }\n+\n+            @Override\n+            public void diskWritable(File disk) {\n+                // we have enough space now, disable force gc.\n+                gcThread.disableForceGC();\n+            }\n+\n+            @Override\n+            public void diskJustWritable(File disk) {\n+                // if a disk is just writable, we still need force gc.\n+                gcThread.enableForceGC();\n+            }\n         };\n     }\n "},{"sha":"bad99cb070fa291dce5e15b0393ac48cd32d4d41","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"modified","additions":97,"deletions":36,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -84,6 +84,13 @@ public LedgerDirsManager(ServerConfiguration conf, File[] dirs) {\n         return writableLedgerDirectories;\n     }\n \n+    /**\n+     * @return full-filled ledger dirs.\n+     */\n+    public List<File> getFullFilledLedgerDirs() {\n+        return filledDirs;\n+    }\n+\n     /**\n      * Get dirs, which are full more than threshold\n      */\n@@ -114,6 +121,34 @@ public void addToFilledDirs(File dir) {\n         }\n     }\n \n+    /**\n+     * Add the dir to writable dirs list.\n+     *\n+     * @param dir Dir\n+     */\n+    public void addToWritableDirs(File dir, boolean underWarnThreshold) {\n+        if (writableLedgerDirectories.contains(dir)) {\n+            return;\n+        }\n+        LOG.info(\"{} becomes writable. Adding it to writable dirs list.\", dir);\n+        // Update writable dirs list\n+        List<File> updatedWritableDirs = new ArrayList<File>(writableLedgerDirectories);\n+        updatedWritableDirs.add(dir);\n+        writableLedgerDirectories = updatedWritableDirs;\n+        // Update the filled dirs list\n+        List<File> newDirs = new ArrayList<File>(filledDirs);\n+        newDirs.removeAll(writableLedgerDirectories);\n+        filledDirs = newDirs;\n+        // Notify listeners about disk writable\n+        for (LedgerDirsListener listener : listeners) {\n+            if (underWarnThreshold) {\n+                listener.diskWritable(dir);\n+            } else {\n+                listener.diskJustWritable(dir);\n+            }\n+        }\n+    }\n+\n     /**\n      * Returns one of the ledger dir from writable dirs list randomly.\n      */\n@@ -198,48 +233,58 @@ public LedgerDirsMonitor(int interval) {\n \n         @Override\n         public void run() {\n-            try {\n-                while (true) {\n-                    List<File> writableDirs;\n+            while (true) {\n+                List<File> writableDirs;\n+                try {\n+                    writableDirs = getWritableLedgerDirs();\n+                } catch (NoWritableLedgerDirException e) {\n+                    for (LedgerDirsListener listener : listeners) {\n+                        listener.allDisksFull();\n+                    }\n+                    break;\n+                }\n+                // Check all writable dirs disk space usage.\n+                for (File dir : writableDirs) {\n                     try {\n-                        writableDirs = getWritableLedgerDirs();\n-                    } catch (NoWritableLedgerDirException e) {\n+                        diskChecker.checkDir(dir);\n+                    } catch (DiskErrorException e) {\n+                        // Notify disk failure to all listeners\n                         for (LedgerDirsListener listener : listeners) {\n-                            listener.allDisksFull();\n+                            LOG.warn(\"{} has errors.\", dir, e);\n+                            listener.diskFailed(dir);\n                         }\n-                        break;\n-                    }\n-                    // Check all writable dirs disk space usage.\n-                    for (File dir : writableDirs) {\n-                        try {\n-                            diskChecker.checkDir(dir);\n-                        } catch (DiskErrorException e) {\n-                            // Notify disk failure to all listeners\n-                            for (LedgerDirsListener listener : listeners) {\n-                                LOG.warn(\"{} has errors.\", dir, e);\n-                                listener.diskFailed(dir);\n-                            }\n-                        } catch (DiskWarnThresholdException e) {\n-                            for (LedgerDirsListener listener : listeners) {\n-                                listener.diskAlmostFull(dir);\n-                            }\n-                        } catch (DiskOutOfSpaceException e) {\n-                            // Notify disk full to all listeners\n-                            addToFilledDirs(dir);\n+                    } catch (DiskWarnThresholdException e) {\n+                        for (LedgerDirsListener listener : listeners) {\n+                            listener.diskAlmostFull(dir);\n                         }\n+                    } catch (DiskOutOfSpaceException e) {\n+                        // Notify disk full to all listeners\n+                        addToFilledDirs(dir);\n                     }\n+                }\n+                List<File> fullfilledDirs = new ArrayList<File>(getFullFilledLedgerDirs());\n+                // Check all full-filled disk space usage\n+                for (File dir : fullfilledDirs) {\n                     try {\n-                        Thread.sleep(interval);\n-                    } catch (InterruptedException e) {\n-                        LOG.info(\"LedgerDirsMonitor thread is interrupted\");\n-                        break;\n+                        diskChecker.checkDir(dir);\n+                        addToWritableDirs(dir, true);\n+                    } catch (DiskErrorException e) {\n+                        //Notify disk failure to all the listeners\n+                        for (LedgerDirsListener listener : listeners) {\n+                            listener.diskFailed(dir);\n+                        }\n+                    } catch (DiskWarnThresholdException e) {\n+                        // the full-filled dir become writable but still above warn threshold\n+                        addToWritableDirs(dir, false);\n+                    } catch (DiskOutOfSpaceException e) {\n+                        // the full-filled dir is still full-filled\n                     }\n                 }\n-            } catch (Exception e) {\n-                LOG.error(\"Error Occured while checking disks\", e);\n-                // Notify disk failure to all listeners\n-                for (LedgerDirsListener listener : listeners) {\n-                    listener.fatalError();\n+                try {\n+                    Thread.sleep(interval);\n+                } catch (InterruptedException e) {\n+                    LOG.info(\"LedgerDirsMonitor thread is interrupted\");\n+                    break;\n                 }\n             }\n             LOG.info(\"LedgerDirsMonitorThread exited!\");\n@@ -278,7 +323,7 @@ public NoWritableLedgerDirException(String errMsg) {\n     public static interface LedgerDirsListener {\n         /**\n          * This will be notified on disk failure/disk error\n-         * \n+         *\n          * @param disk\n          *            Failed disk\n          */\n@@ -293,12 +338,28 @@ public NoWritableLedgerDirException(String errMsg) {\n \n         /**\n          * This will be notified on disk detected as full\n-         * \n+         *\n          * @param disk\n          *            Filled disk\n          */\n         void diskFull(File disk);\n \n+        /**\n+         * This will be notified on disk detected as writable and under warn threshold\n+         *\n+         * @param disk\n+         *          Writable disk\n+         */\n+        void diskWritable(File disk);\n+\n+        /**\n+         * This will be notified on disk detected as writable but still in warn threshold\n+         *\n+         * @param disk\n+         *          Writable disk\n+         */\n+        void diskJustWritable(File disk);\n+\n         /**\n          * This will be notified whenever all disks are detected as full.\n          */"},{"sha":"d70b1cb1dd3f772ef2044508432bd62427746e9e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","status":"modified","additions":26,"deletions":2,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -32,8 +32,6 @@\n import org.jboss.netty.channel.ChannelException;\n import junit.framework.Assert;\n \n-import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n@@ -122,6 +120,32 @@ protected Bookie newBookie(ServerConfiguration conf)\n                 ExitCode.ZK_REG_FAIL, bkServer.getExitCode());\n     }\n \n+    @Test(timeout = 20000)\n+    public void testBookieRegistrationWithSameZooKeeperClient() throws Exception {\n+        File tmpDir = File.createTempFile(\"bookie\", \"test\");\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+\n+        final ServerConfiguration conf = TestBKConfiguration.newServerConfiguration()\n+                .setZkServers(null).setJournalDirName(tmpDir.getPath())\n+                .setLedgerDirNames(new String[] { tmpDir.getPath() });\n+\n+        final String bkRegPath = conf.getZkAvailableBookiesPath() + \"/\"\n+                + InetAddress.getLocalHost().getHostAddress() + \":\"\n+                + conf.getBookiePort();\n+\n+        MockBookie b = new MockBookie(conf);\n+        b.zk = zkc;\n+        b.testRegisterBookie(conf);\n+        Assert.assertNotNull(\"Bookie registration node doesn't exists!\",\n+                             zkc.exists(bkRegPath, false));\n+\n+        // test register bookie again if the registeration node is created by itself.\n+        b.testRegisterBookie(conf);\n+        Assert.assertNotNull(\"Bookie registration node doesn't exists!\",\n+                zkc.exists(bkRegPath, false));\n+    }\n+\n     /**\n      * Verify the bookie reg. Restarting bookie server will wait for the session\n      * timeout when previous reg node exists in zk. On zNode delete event,"},{"sha":"c9605e5968edfd672a684de9c4f3615de91f3221","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -205,7 +205,7 @@ public void checkpointComplete(Checkpoint checkPoint, boolean compact)\n         storage.start();\n         long startTime = MathUtils.now();\n         Thread.sleep(2000);\n-        storage.gcThread.forceGC();\n+        storage.gcThread.enableForceGC();\n         Thread.sleep(1000);\n         // Minor and Major compaction times should be larger than when we started\n         // this test."},{"sha":"8f5864dc5cec4a80a7d8cd37104bc5878cc53f07","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -340,5 +340,13 @@ public void allDisksFull() {\n         @Override\n         public void fatalError() {\n         }\n+\n+        @Override\n+        public void diskWritable(File disk) {\n+        }\n+\n+        @Override\n+        public void diskJustWritable(File disk) {\n+        }\n     }\n }"},{"sha":"262a73c882c946a5e5c6db74c2af1f2362980dae","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","status":"modified","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b1e561cb5e4f081f40bf8b751bcc2c16226092e/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java?ref=9b1e561cb5e4f081f40bf8b751bcc2c16226092e","patch":"@@ -30,6 +30,7 @@\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.junit.Test;\n \n /**\n  * Test to verify the readonly feature of bookies\n@@ -43,6 +44,7 @@ public ReadOnlyBookieTest() {\n     /**\n      * Check readonly bookie\n      */\n+    @Test(timeout = 60000)\n     public void testBookieShouldServeAsReadOnly() throws Exception {\n         killBookie(0);\n         baseConf.setReadOnlyModeEnabled(true);\n@@ -66,6 +68,7 @@ public void testBookieShouldServeAsReadOnly() throws Exception {\n \n         try {\n             ledger.addEntry(\"data\".getBytes());\n+            fail(\"Should fail to add entry since there isn't enough bookies alive.\");\n         } catch (BKException.BKNotEnoughBookiesException e) {\n             // Expected\n         }\n@@ -84,9 +87,73 @@ public void testBookieShouldServeAsReadOnly() throws Exception {\n         }\n     }\n \n+    @Test(timeout = 60000)\n+    public void testBookieShouldTurnWritableFromReadOnly() throws Exception {\n+        killBookie(0);\n+        baseConf.setReadOnlyModeEnabled(true);\n+        startNewBookie();\n+        LedgerHandle ledger = bkc.createLedger(2, 2, DigestType.MAC,\n+                \"\".getBytes());\n+\n+        // Check new bookie with readonly mode enabled.\n+        File[] ledgerDirs = bsConfs.get(1).getLedgerDirs();\n+        assertEquals(\"Only one ledger dir should be present\", 1,\n+                ledgerDirs.length);\n+        Bookie bookie = bs.get(1).getBookie();\n+        LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+\n+        for (int i = 0; i < 10; i++) {\n+            ledger.addEntry(\"data\".getBytes());\n+        }\n+\n+        File testDir = new File(ledgerDirs[0], \"current\");\n+\n+        // Now add the current ledger dir to filled dirs list\n+        ledgerDirsManager.addToFilledDirs(testDir);\n+\n+        try {\n+            ledger.addEntry(\"data\".getBytes());\n+            fail(\"Should fail to add entry since there isn't enough bookies alive.\");\n+        } catch (BKException.BKNotEnoughBookiesException e) {\n+            // Expected\n+        }\n+        LOG.info(\"bookie is running {}, readonly {}.\", bookie.isRunning(), bookie.isReadOnly());\n+        assertTrue(\"Bookie should be running and converted to readonly mode\",\n+                bookie.isRunning() && bookie.isReadOnly());\n+\n+        // refresh the bookkeeper client\n+        bkc.readBookiesBlocking();\n+        // should fail to create ledger\n+        try {\n+            bkc.createLedger(2, 2, DigestType.MAC, \"\".getBytes());\n+            fail(\"Should fail to create a ledger since there isn't enough bookies alive.\");\n+        } catch (BKException.BKNotEnoughBookiesException bke) {\n+            // Expected.\n+        }\n+\n+        // Now add the current ledger dir back to writable dirs list\n+        ledgerDirsManager.addToWritableDirs(testDir, true);\n+\n+        LOG.info(\"bookie is running {}, readonly {}.\", bookie.isRunning(), bookie.isReadOnly());\n+        assertTrue(\"Bookie should be running and converted back to writable mode\", bookie.isRunning()\n+                && !bookie.isReadOnly());\n+        // force client to read bookies\n+        bkc.readBookiesBlocking();\n+        LedgerHandle newLedger = bkc.createLedger(2, 2, DigestType.MAC, \"\".getBytes());\n+        for (int i = 0; i < 10; i++) {\n+            newLedger.addEntry(\"data\".getBytes());\n+        }\n+        Enumeration<LedgerEntry> readEntries = newLedger.readEntries(0, 9);\n+        while (readEntries.hasMoreElements()) {\n+            LedgerEntry entry = readEntries.nextElement();\n+            assertEquals(\"Entry should contain correct data\", \"data\", new String(entry.getEntry()));\n+        }\n+    }\n+\n     /**\n      * check readOnlyModeEnabled=false\n      */\n+    @Test(timeout = 60000)\n     public void testBookieShutdownIfReadOnlyModeNotEnabled() throws Exception {\n         File[] ledgerDirs = bsConfs.get(1).getLedgerDirs();\n         assertEquals(\"Only one ledger dir should be present\", 1,\n@@ -105,6 +172,7 @@ public void testBookieShutdownIfReadOnlyModeNotEnabled() throws Exception {\n \n         try {\n             ledger.addEntry(\"data\".getBytes());\n+            fail(\"Should fail to add entry since there isn't enough bookies alive.\");\n         } catch (BKException.BKNotEnoughBookiesException e) {\n             // Expected\n         }\n@@ -120,6 +188,7 @@ public void testBookieShutdownIfReadOnlyModeNotEnabled() throws Exception {\n     /**\n      * Check multiple ledger dirs\n      */\n+    @Test(timeout = 60000)\n     public void testBookieContinueWritingIfMultipleLedgersPresent()\n             throws Exception {\n         startNewBookieWithMultipleLedgerDirs(2);\n@@ -171,6 +240,7 @@ private void startNewBookieWithMultipleLedgerDirs(int numOfLedgerDirs)\n     /**\n      * Test ledger creation with readonly bookies\n      */\n+    @Test(timeout = 60000)\n     public void testLedgerCreationShouldFailWithReadonlyBookie() throws Exception {\n         killBookie(1);\n         baseConf.setReadOnlyModeEnabled(true);"}]}

