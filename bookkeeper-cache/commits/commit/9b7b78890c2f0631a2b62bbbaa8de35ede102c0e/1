{"sha":"9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5YjdiNzg4OTBjMmYwNjMxYTJiNjJiYmJhYThkZTM1ZWRlMTAyYzBl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-09T16:13:10Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-09T16:13:10Z"},"message":"BOOKKEEPER-204: Provide a MetaStore interface, and a mock implementation. (Jiannan Wang via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1407520 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6c4c7d1c14970660eb28163187c43d60242634f1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6c4c7d1c14970660eb28163187c43d60242634f1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","html_url":"https://github.com/apache/bookkeeper/commit/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c32437ad4ff1d1e267f885a0bd67100cebb57ba6","url":"https://api.github.com/repos/apache/bookkeeper/commits/c32437ad4ff1d1e267f885a0bd67100cebb57ba6","html_url":"https://github.com/apache/bookkeeper/commit/c32437ad4ff1d1e267f885a0bd67100cebb57ba6"}],"stats":{"total":2330,"additions":2330,"deletions":0},"files":[{"sha":"19111c5d426fcfefb1fdbd67625def3cb71797f4","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -180,6 +180,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-444: Refactor pending read op to make speculative reads possible (ivank)\n \n+        BOOKKEEPER-204: Provide a MetaStore interface, and a mock implementation. (Jiannan Wang via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"a1350dc7d77b18efc32b6460cc1cae85ce9cbffa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MSException.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,214 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+@SuppressWarnings(\"serial\")\n+public abstract class MSException extends Exception {\n+\n+    /**\n+     * return codes\n+     */\n+    public static enum Code {\n+        OK (0, \"OK\"),\n+        BadVersion (-1, \"Version conflict\"),\n+        NoKey (-2, \"Key does not exist\"),\n+        KeyExists (-3, \"Key exists\"),\n+        NoEntries (-4, \"No entries found\"),\n+\n+        InterruptedException (-100, \"Operation interrupted\"),\n+        IllegalOp (-101, \"Illegal operation\"),\n+        ServiceDown (-102, \"Metadata service is down\"),\n+        OperationFailure(-103, \"Operaion failed on metadata storage server side\");\n+\n+        private static final Map<Integer, Code> codes\n+            = new HashMap<Integer, Code>();\n+\n+        static {\n+            for (Code c : EnumSet.allOf(Code.class)) {\n+                codes.put(c.code, c);\n+            }\n+        }\n+\n+        private final int code;\n+        private final String description;\n+\n+        private Code(int code, String description) {\n+            this.code = code;\n+            this.description = description;\n+        }\n+\n+        /**\n+         * Get the int value for a particular Code.\n+         *\n+         * @return error code as integer\n+         */\n+        public int getCode() {\n+            return code;\n+        }\n+\n+        /**\n+         * Get the description for a particular Code.\n+         *\n+         * @return error description\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+\n+        /**\n+         * Get the Code value for a particular integer error code.\n+         *\n+         * @param code int error code\n+         * @return Code value corresponding to specified int code, or null.\n+         */\n+        public static Code get(int code) {\n+            return codes.get(code);\n+        }\n+    }\n+\n+    private final Code code;\n+\n+    MSException(Code code, String errMsg) {\n+        super(code.getDescription() + \" : \" + errMsg);\n+        this.code = code;\n+    }\n+\n+    MSException(Code code, String errMsg, Throwable cause) {\n+        super(code.getDescription() + \" : \" + errMsg, cause);\n+        this.code = code;\n+    }\n+\n+    public Code getCode() {\n+        return this.code;\n+    }\n+\n+    public static MSException create(Code code) {\n+        return create(code, \"\", null);\n+    }\n+\n+    public static MSException create(Code code, String errMsg) {\n+        return create(code, errMsg, null);\n+    }\n+\n+    public static MSException create(Code code, String errMsg, Throwable cause) {\n+        switch (code) {\n+            case BadVersion:\n+                return new BadVersionException(errMsg, cause);\n+            case NoKey:\n+                return new NoKeyException(errMsg, cause);\n+            case KeyExists:\n+                return new KeyExistsException(errMsg, cause);\n+            case InterruptedException:\n+                return new MSInterruptedException(errMsg, cause);\n+            case IllegalOp:\n+                return new IllegalOpException(errMsg, cause);\n+            case ServiceDown:\n+                return new ServiceDownException(errMsg, cause);\n+            case OperationFailure:\n+                return new OperationFailureException(errMsg, cause);\n+            case OK:\n+            default:\n+                throw new IllegalArgumentException(\"Invalid exception code\");\n+        }\n+    }\n+\n+    public static class BadVersionException extends MSException {\n+        public BadVersionException(String errMsg) {\n+            super(Code.BadVersion, errMsg);\n+        }\n+\n+        public BadVersionException(String errMsg, Throwable cause) {\n+            super(Code.BadVersion, errMsg, cause);\n+        }\n+    }\n+\n+    public static class NoKeyException extends MSException {\n+        public NoKeyException(String errMsg) {\n+            super(Code.NoKey, errMsg);\n+        }\n+\n+        public NoKeyException(String errMsg, Throwable cause) {\n+            super(Code.NoKey, errMsg, cause);\n+        }\n+    }\n+\n+    // Exception would be thrown in a cursor if no entries found\n+    public static class NoEntriesException extends MSException {\n+        public NoEntriesException(String errMsg) {\n+            super(Code.NoEntries, errMsg);\n+        }\n+\n+        public NoEntriesException(String errMsg, Throwable cause) {\n+            super(Code.NoEntries, errMsg, cause);\n+        }\n+    }\n+\n+    public static class KeyExistsException extends MSException {\n+        public KeyExistsException(String errMsg) {\n+            super(Code.KeyExists, errMsg);\n+        }\n+\n+        public KeyExistsException(String errMsg, Throwable cause) {\n+            super(Code.KeyExists, errMsg, cause);\n+        }\n+    }\n+\n+    public static class MSInterruptedException extends MSException {\n+        public MSInterruptedException(String errMsg) {\n+            super(Code.InterruptedException, errMsg);\n+        }\n+\n+        public MSInterruptedException(String errMsg, Throwable cause) {\n+            super(Code.InterruptedException, errMsg, cause);\n+        }\n+    }\n+\n+    public static class IllegalOpException extends MSException {\n+        public IllegalOpException(String errMsg) {\n+            super(Code.IllegalOp, errMsg);\n+        }\n+\n+        public IllegalOpException(String errMsg, Throwable cause) {\n+            super(Code.IllegalOp, errMsg, cause);\n+        }\n+    }\n+\n+    public static class ServiceDownException extends MSException {\n+        public ServiceDownException(String errMsg) {\n+            super(Code.ServiceDown, errMsg);\n+        }\n+\n+        public ServiceDownException(String errMsg, Throwable cause) {\n+            super(Code.ServiceDown, errMsg, cause);\n+        }\n+    }\n+\n+    public static class OperationFailureException extends MSException {\n+        public OperationFailureException(String errMsg) {\n+            super(Code.OperationFailure, errMsg);\n+        }\n+\n+        public OperationFailureException(String errMsg, Throwable cause) {\n+            super(Code.OperationFailure, errMsg, cause);\n+        }\n+    }\n+}"},{"sha":"29fd3294468598d497e40b74768330a103468925","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetaStore.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,79 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import org.apache.commons.configuration.Configuration;\n+\n+/**\n+ * Metadata Store Interface.\n+ */\n+public interface MetaStore {\n+    /**\n+     * Return the name of the plugin.\n+     *\n+     * @return the plugin name.\n+     */\n+    public String getName();\n+\n+    /**\n+     * Get the plugin verison.\n+     *\n+     * @return the plugin version.\n+     */\n+    public int getVersion();\n+\n+    /**\n+     * Initialize the meta store.\n+     *\n+     * @param config\n+     *          Configuration object passed to metastore\n+     * @param msVersion\n+     *          Version to initialize the metastore\n+     * @throws MetastoreException when failed to initialize\n+     */\n+    public void init(Configuration config, int msVersion)\n+    throws MetastoreException;\n+\n+    /**\n+     * Close the meta store.\n+     */\n+    public void close();\n+\n+    /**\n+     * Create a metastore table.\n+     *\n+     * @param name\n+     *          Table name.\n+     * @return a metastore table\n+     * @throws MetastoreException when failed to create the metastore table.\n+     */\n+    public MetastoreTable createTable(String name)\n+    throws MetastoreException;\n+\n+    /**\n+     * Create a scannable metastore table.\n+     *\n+     * @param name\n+     *          Table name.\n+     * @return a metastore scannable table\n+     * @throws MetastoreException when failed to create the metastore table.\n+     */\n+    public MetastoreScannableTable createScannableTable(String name)\n+    throws MetastoreException;\n+\n+}"},{"sha":"78c709c15fe0c4cf158a695c98bf256fd7ce10ce","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCallback.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,25 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+public interface MetastoreCallback<T> {\n+    /**\n+     * @see MSException.Code\n+     */\n+    public void complete(int rc, T value, Object ctx);\n+}"},{"sha":"f4f9d65a1292f517cd2d37ec850cb4a25cb851f9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreCursor.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Iterator;\n+\n+public interface MetastoreCursor extends Closeable {\n+\n+    public static MetastoreCursor EMPTY_CURSOR = new MetastoreCursor() {\n+        @Override\n+        public boolean hasMoreEntries() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<MetastoreTableItem> readEntries(int numEntries)\n+        throws MSException {\n+            throw new MSException.NoEntriesException(\"No entries left in the cursor.\");\n+        }\n+\n+        @Override\n+        public void asyncReadEntries(int numEntries, ReadEntriesCallback callback, Object ctx) {\n+            callback.complete(MSException.Code.NoEntries.getCode(), null, ctx);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+    };\n+\n+    public static interface ReadEntriesCallback extends\n+        MetastoreCallback<Iterator<MetastoreTableItem>> {\n+    }\n+\n+    /**\n+     * Is there any entries left in the cursor to read.\n+     *\n+     * @return true if there is entries left, false otherwise.\n+     */\n+    public boolean hasMoreEntries();\n+\n+    /**\n+     * Read entries from the cursor, up to the specified <code>numEntries</code>.\n+     * The returned list can be smaller.\n+     *\n+     * @param numEntries\n+     *            maximum number of entries to read\n+     * @return the iterator of returned entries.\n+     * @throws MSException when failed to read entries from the cursor.\n+     */\n+    public Iterator<MetastoreTableItem> readEntries(int numEntries)\n+    throws MSException;\n+\n+    /**\n+     * Asynchronously read entries from the cursor, up to the specified <code>numEntries</code>.\n+     *\n+     * @see #readEntries(int)\n+     * @param numEntries\n+     *            maximum number of entries to read\n+     * @param callback\n+     *            callback object\n+     * @param ctx\n+     *            opaque context\n+     */\n+    public void asyncReadEntries(int numEntries, ReadEntriesCallback callback, Object ctx);\n+}"},{"sha":"c85b36ad4704d9f42bbb555cc85033697f1ee95a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreException.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+@SuppressWarnings(\"serial\")\n+public class MetastoreException extends Exception {\n+\n+    public MetastoreException(String message) {\n+        super(message);\n+    }\n+\n+    public MetastoreException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+    public MetastoreException(Throwable t) {\n+        super(t);\n+    }\n+}"},{"sha":"bedbf8b082a5f801781b29c9d2fcd8a408362fe9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreFactory.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,33 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+\n+public class MetastoreFactory {\n+\n+    public static MetaStore createMetaStore(String name)\n+    throws MetastoreException {\n+        try {\n+            return ReflectionUtils.newInstance(name, MetaStore.class);\n+        } catch (Throwable t) {\n+            throw new MetastoreException(\"Failed to instantiate metastore : \" + name);\n+        }\n+    }\n+\n+}"},{"sha":"036cdb6299ad655bb511b149c0e7f08b5d355508","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreScannableTable.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.util.Set;\n+\n+public interface MetastoreScannableTable extends MetastoreTable {\n+\n+    // Used by cursor, etc when they want to start at the beginning of a table\n+    public static final String EMPTY_START_KEY = null;\n+    // Last row in a table.\n+    public static final String EMPTY_END_KEY = null;\n+    // the order to loop over a table\n+    public static enum Order {\n+        ASC,\n+        DESC\n+    }\n+\n+    /**\n+     * Open a cursor to loop over the entries belonging to a key range,\n+     * which returns all fields for each entry.\n+     *\n+     * <p>\n+     * Return Code:<br/>\n+     * {@link MSException.Code.OK}: an opened cursor<br/>\n+     * {@link MSException.Code.IllegalOp}/{@link MSException.Code.ServiceDown}:\n+     * other issues\n+     * </p>\n+     *\n+     * @param firstKey\n+     *            Key to start scanning. If it is {@link EMPTY_START_KEY}, it starts\n+     *            from first key (inclusive).\n+     * @param firstInclusive\n+     *            true if firstKey is to be included in the returned view.\n+     * @param lastKey\n+     *            Key to stop scanning. If it is {@link EMPTY_END_KEY}, scan ends at\n+     *            the lastKey of the table (inclusive).\n+     * @param lastInclusive\n+     *            true if lastKey is to be included in the returned view.\n+     * @param order\n+     *            the order to loop over the entries\n+     * @param cb\n+     *            Callback to return an opened cursor.\n+     * @param ctx\n+     *            Callback context\n+     */\n+    public void openCursor(String firstKey, boolean firstInclusive,\n+                           String lastKey, boolean lastInclusive,\n+                           Order order,\n+                           MetastoreCallback<MetastoreCursor> cb,\n+                           Object ctx);\n+\n+    /**\n+     * Open a cursor to loop over the entries belonging to a key range,\n+     * which returns the specified <code>fields</code> for each entry.\n+     *\n+     * <p>\n+     * Return Code:<br/>\n+     * {@link MSException.Code.OK}: an opened cursor<br/>\n+     * {@link MSException.Code.IllegalOp}/{@link MSException.Code.ServiceDown}:\n+     * other issues\n+     * </p>\n+     *\n+     * @param firstKey\n+     *            Key to start scanning. If it is {@link EMPTY_START_KEY}, it starts\n+     *            from first key (inclusive).\n+     * @param firstInclusive\n+     *            true if firstKey is to be included in the returned view.\n+     * @param lastKey\n+     *            Key to stop scanning. If it is {@link EMPTY_END_KEY}, scan ends at\n+     *            the lastKey of the table (inclusive).\n+     * @param lastInclusive\n+     *            true if lastKey is to be included in the returned view.\n+     * @param order\n+     *            the order to loop over the entries\n+     * @param fields\n+     *            Fields to select\n+     * @param cb\n+     *            Callback to return an opened cursor.\n+     * @param ctx\n+     *            Callback context\n+     */\n+    public void openCursor(String firstKey, boolean firstInclusive,\n+                           String lastKey, boolean lastInclusive,\n+                           Order order, Set<String> fields,\n+                           MetastoreCallback<MetastoreCursor> cb,\n+                           Object ctx);\n+\n+}"},{"sha":"a75bfdd2e299ffbe86c026557cd6feac700ecf5a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java","status":"added","additions":172,"deletions":0,"changes":172,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTable.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,172 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+public interface MetastoreTable {\n+\n+    // select all fields when reading or scanning entries\n+    public static final Set<String> ALL_FIELDS = null;\n+    // select non fields to return when reading/scanning entries\n+    public static final Set<String> NON_FIELDS = new HashSet<String>();\n+\n+    /**\n+     * Get table name.\n+     *\n+     * @return table name\n+     */\n+    public String getName();\n+\n+    /**\n+     * Get all fields of a key.\n+     *\n+     * <p>\n+     * Return Code:<ul>\n+     * <li>{@link MSException.Code.OK}: success returning the key</li>\n+     * <li>{@link MSException.Code.NoKey}: no key found</li>\n+     * <li>{@link MSException.Code.IllegalOp}/{@link MSException.Code.ServiceDown}: other issues</li>\n+     * </ul></p>\n+     *\n+     * @param key\n+     *          Key Name\n+     * @param cb\n+     *          Callback to return all fields of the key\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void get(String key, MetastoreCallback<Versioned<Value>> cb, Object ctx);\n+\n+    /**\n+     * Get specified fields of a key.\n+     *\n+     * <p>\n+     * Return Code:<ul>\n+     * <li>{@link MSException.Code.OK}: success returning the key</li>\n+     * <li>{@link MSException.Code.NoKey}: no key found</li>\n+     * <li>{@link MSException.Code.IllegalOp}/{@link MSException.Code.ServiceDown}: other issues</li>\n+     * </ul></p>\n+     *\n+     * @param key\n+     *          Key Name\n+     * @param fields\n+     *          Fields to return\n+     * @param cb\n+     *          Callback to return specified fields of the key\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void get(String key, Set<String> fields,\n+                    MetastoreCallback<Versioned<Value>> cb, Object ctx);\n+\n+    /**\n+     * Update a key according to its version.\n+     *\n+     * <p>\n+     * Return Code:<ul>\n+     * <li>{@link MSException.Code.OK}: success updating the key</li>\n+     * <li>{@link MSException.Code.BadVersion}: failed to update the key due to bad version</li>\n+     * <li>{@link MSException.Code.NoKey}: no key found to update data, if not provided {@link Version.NEW}</li>\n+     * <li>{@link MSException.Code.KeyExists}: entry exists providing {@link Version.NEW}</li>\n+     * <li>{@link MSException.Code.IllegalOp}/{@link MSException.Code.ServiceDown}: other issues</li>\n+     * </ul></p>\n+     *\n+     * The key is updated only when the version matches its current version.\n+     * In particular, if the provided version is:<ul>\n+     * <li>{@link Version.ANY}: update the data without comparing its version.\n+     *      <b>Note this usage is not encouraged since it may mess up data consistency.</b></li>\n+     * <li>{@link Version.NEW}: create the entry if it doesn't exist before;\n+     *      Otherwise return {@link MSException.Code.KeyExists}.</li>\n+     * </ul>\n+     *\n+     * @param key\n+     *          Key Name\n+     * @param value\n+     *          Value to update.\n+     * @param version\n+     *          Version specified to update.\n+     * @param cb\n+     *          Callback to return new version after updated.\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void put(String key, Value value, Version version, MetastoreCallback<Version> cb, Object ctx);\n+\n+    /**\n+     * Remove a key by its version.\n+     *\n+     * The key is removed only when the version matches its current version.\n+     * If <code>version</code> is {@link Version.ANY}, the key would be removed directly.\n+     *\n+     * <p>\n+     * Return Code:<ul>\n+     * <li>{@link MSException.Code.OK}: success updating the key</li>\n+     * <li>{@link MSException.Code.NoKey}: if the key doesn't exist.</li>\n+     * <li>{@link MSException.Code.BadVersion}: failed to delete the key due to bad version</li>\n+     * <li>{@link MSException.Code.IllegalOp}/{@link MSException.Code.ServiceDown}: other issues</li>\n+     * </ul></p>\n+     *\n+     * @param key\n+     *          Key Name.\n+     * @param version\n+     *          Version specified to remove.\n+     * @param cb\n+     *          Callback to return all fields of the key\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void remove(String key, Version version,\n+                       MetastoreCallback<Void> cb, Object ctx);\n+\n+    /**\n+     * Open a cursor to loop over all the entries of the table,\n+     * which returns all fields for each entry.\n+     * The returned cursor doesn't need to guarantee any order,\n+     * since the underlying might be a hash table or an order table.\n+     *\n+     * @param cb\n+     *          Callback to return an opened cursor\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void openCursor(MetastoreCallback<MetastoreCursor> cb, Object ctx);\n+\n+    /**\n+     * Open a cursor to loop over all the entries of the table,\n+     * which returns the specified <code>fields</code> for each entry.\n+     * The returned cursor doesn't need to guarantee any order,\n+     * since the underlying might be a hash table or an order table.\n+     *\n+     * @param fields\n+     *          Fields to select\n+     * @param cb\n+     *          Callback to return an opened cursor\n+     * @param ctx\n+     *          Callback context\n+     */\n+    public void openCursor(Set<String> fields,\n+                           MetastoreCallback<MetastoreCursor> cb, Object ctx);\n+\n+    /**\n+     * Close the table.\n+     */\n+    public void close();\n+}"},{"sha":"c874b3f3deaa4e235305c3e74585014192d0a9ac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/MetastoreTableItem.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,70 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+/**\n+ * Identify an item in a metastore table.\n+ */\n+public class MetastoreTableItem {\n+\n+    private String key;\n+    private Versioned<Value> value;\n+\n+    public MetastoreTableItem(String key, Versioned<Value> value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Get the key of the table item.\n+     *\n+     * @return key of table item.\n+     */\n+    public String getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Set the key of the item.\n+     *\n+     * @param key Key\n+     */\n+    public void setKey(String key) {\n+        this.key = key;\n+    }\n+\n+    /**\n+     * Get the value of the item.\n+     *\n+     * @return value of the item.\n+     */\n+    public Versioned<Value> getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Set the value of the item.\n+     *\n+     * @return value of the item.\n+     */\n+    public void setValue(Versioned<Value> value) {\n+        this.value = value;\n+    }\n+}"},{"sha":"b3e661d5276e9e17a9581a0904043d48bbd6ae02","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java","status":"added","additions":154,"deletions":0,"changes":154,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/Value.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,154 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import com.google.common.primitives.UnsignedBytes;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.HashFunction;\n+import com.google.common.hash.Hashing;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Collections;\n+\n+import static org.apache.bookkeeper.metastore.MetastoreTable.ALL_FIELDS;\n+\n+public class Value {\n+    static final Comparator<byte[]> comparator =\n+        UnsignedBytes.lexicographicalComparator();\n+\n+    protected Map<String, byte[]> fields;\n+\n+    public Value() {\n+        fields = new HashMap<String, byte[]>();\n+    }\n+\n+    public Value(Value v) {\n+        fields = new HashMap<String, byte[]>(v.fields);\n+    }\n+\n+    public byte[] getField(String field) {\n+        return fields.get(field);\n+    }\n+\n+    public Value setField(String field, byte[] data) {\n+        fields.put(field, data);\n+        return this;\n+    }\n+\n+    public Value clearFields() {\n+        fields.clear();\n+        return this;\n+    }\n+\n+    public Set<String> getFields() {\n+        return fields.keySet();\n+    }\n+\n+    public Map<String, byte[]> getFieldsMap() {\n+        return Collections.unmodifiableMap(fields);\n+    }\n+\n+    /**\n+     * Select parts of fields.\n+     *\n+     * @param fields\n+     *            Parts of fields\n+     * @return new value with specified fields\n+     */\n+    public Value project(Set<String> fields) {\n+        if (ALL_FIELDS == fields) {\n+            return new Value(this);\n+        }\n+        Value v = new Value();\n+        for (String f : fields) {\n+            byte[] data = this.fields.get(f);\n+            v.setField(f, data);\n+        }\n+        return v;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        HashFunction hf = Hashing.murmur3_32();\n+        Hasher hc = hf.newHasher();\n+        for (String key : fields.keySet()) {\n+            hc.putString(key);\n+        }\n+        return hc.hash().asInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof Value)) {\n+            return false;\n+        }\n+        Value other = (Value) o;\n+        if (fields.size() != other.fields.size()) {\n+            return false;\n+        }\n+        for (String f : fields.keySet()) {\n+            byte[] v1 = fields.get(f);\n+            byte[] v2 = other.fields.get(f);\n+            if (0 != comparator.compare(v1, v2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Merge other value.\n+     *\n+     * @param other\n+     *          Other Value\n+     */\n+    public Value merge(Value other) {\n+        for (Map.Entry<String, byte[]> entry : other.fields.entrySet()) {\n+            if (null == entry.getValue()) {\n+                fields.remove(entry.getKey());\n+            } else {\n+                fields.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (Map.Entry<String, byte[]> entry : fields.entrySet()) {\n+            String f = entry.getKey();\n+            if (null == f) {\n+                f = \"NULL\";\n+            }\n+            String value;\n+            if (null == entry.getValue()) {\n+                value = \"NONE\";\n+            } else {\n+                value = new String(entry.getValue());\n+            }\n+            sb.append(\"('\").append(f).append(\"'=\").append(value).append(\")\");\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+}"},{"sha":"4a141d3a941c45ad0c0dfc285b8b41afffbf01b1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetaStore.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetaStore.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,81 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore.mock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.bookkeeper.metastore.MetaStore;\n+import org.apache.bookkeeper.metastore.MetastoreException;\n+import org.apache.bookkeeper.metastore.MetastoreTable;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n+import org.apache.commons.configuration.Configuration;\n+\n+public class MockMetaStore implements MetaStore {\n+\n+    static final int CUR_VERSION = 1;\n+\n+    static Map<String, MockMetastoreTable> tables =\n+        new HashMap<String, MockMetastoreTable>();\n+\n+    // for test\n+    public static void reset() {\n+        tables.clear();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return getClass().getName();\n+    }\n+\n+    @Override\n+    public int getVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public void init(Configuration conf, int msVersion)\n+    throws MetastoreException {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void close() {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public MetastoreTable createTable(String name) {\n+        return createMockTable(name);\n+    }\n+\n+    @Override\n+    public MetastoreScannableTable createScannableTable(String name) {\n+        return createMockTable(name);\n+    }\n+\n+    private MockMetastoreTable createMockTable(String name) {\n+        MockMetastoreTable t = tables.get(name);\n+        if (t == null) {\n+            t = new MockMetastoreTable(this, name);\n+            tables.put(name, t);\n+        }\n+        return t;\n+    }\n+\n+}"},{"sha":"954ccddd713145613fb089ba7ec65e52127aa221","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreCursor.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreCursor.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreCursor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreCursor.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,98 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore.mock;\n+\n+import static org.apache.bookkeeper.metastore.mock.MockMetastoreTable.cloneValue;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.apache.bookkeeper.metastore.MSException;\n+import org.apache.bookkeeper.metastore.MSException.Code;\n+import org.apache.bookkeeper.metastore.MetastoreCursor;\n+import org.apache.bookkeeper.metastore.MetastoreTableItem;\n+import org.apache.bookkeeper.metastore.Value;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+class MockMetastoreCursor implements MetastoreCursor {\n+\n+    private final ScheduledExecutorService scheduler;\n+    private final Iterator<Map.Entry<String, Versioned<Value>>> iter;\n+    private final Set<String> fields;\n+\n+    public MockMetastoreCursor(NavigableMap<String, Versioned<Value>> map, Set<String> fields,\n+            ScheduledExecutorService scheduler) {\n+        this.iter = map.entrySet().iterator();\n+        this.fields = fields;\n+        this.scheduler = scheduler;\n+    }\n+\n+    @Override\n+    public boolean hasMoreEntries() {\n+        return iter.hasNext();\n+    }\n+\n+    @Override\n+    public Iterator<MetastoreTableItem> readEntries(int numEntries)\n+    throws MSException {\n+        if (numEntries < 0) {\n+            throw MSException.create(Code.IllegalOp);\n+        }\n+        return unsafeReadEntries(numEntries);\n+    }\n+\n+    @Override\n+    public void asyncReadEntries(final int numEntries, final ReadEntriesCallback cb, final Object ctx) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (numEntries < 0) {\n+                    cb.complete(Code.IllegalOp.getCode(), null, ctx);\n+                    return;\n+                }\n+                Iterator<MetastoreTableItem> result = unsafeReadEntries(numEntries);\n+                cb.complete(Code.OK.getCode(), result, ctx);\n+            }\n+        });\n+    }\n+\n+    private Iterator<MetastoreTableItem> unsafeReadEntries(int numEntries) {\n+        List<MetastoreTableItem> entries = new ArrayList<MetastoreTableItem>();\n+        int nCount = 0;\n+        while (iter.hasNext() && nCount < numEntries) {\n+            Map.Entry<String, Versioned<Value>> entry = iter.next();\n+            Versioned<Value> value = entry.getValue();\n+            Versioned<Value> vv = cloneValue(value.getValue(), value.getVersion(), fields);\n+            String key = entry.getKey();\n+            entries.add(new MetastoreTableItem(key, vv));\n+            ++nCount;\n+        }\n+        return entries.iterator();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        // do nothing\n+    }\n+}"},{"sha":"df33a1ad44c22974dda2720c0112a4d9bf63fcb1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreTable.java","status":"added","additions":341,"deletions":0,"changes":341,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreTable.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreTable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/mock/MockMetastoreTable.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,341 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore.mock;\n+\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.apache.bookkeeper.metastore.MSException.Code;\n+import org.apache.bookkeeper.metastore.MetastoreCallback;\n+import org.apache.bookkeeper.metastore.MetastoreCursor;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n+import org.apache.bookkeeper.metastore.Value;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+public class MockMetastoreTable implements MetastoreScannableTable {\n+\n+    public static class MockVersion implements Version {\n+        int version;\n+\n+        public MockVersion(int v) {\n+            this.version = v;\n+        }\n+\n+        public MockVersion(MockVersion v) {\n+            this.version = v.version;\n+        }\n+\n+        public synchronized MockVersion incrementVersion() {\n+            ++version;\n+            return this;\n+        }\n+\n+        @Override\n+        public Occurred compare(Version v) {\n+            if (null == v) {\n+                throw new NullPointerException(\"Version is not allowed to be null.\");\n+            }\n+            if (v == Version.NEW) {\n+                return Occurred.AFTER;\n+            } else if (v == Version.ANY) {\n+                return Occurred.CONCURRENTLY;\n+            } else if (!(v instanceof MockVersion)) {\n+                throw new IllegalArgumentException(\"Invalid version type\");\n+            }\n+            MockVersion mv = (MockVersion)v;\n+            int res = version - mv.version;\n+            if (res == 0) {\n+                return Occurred.CONCURRENTLY;\n+            } else if (res < 0) {\n+                return Occurred.BEFORE;\n+            } else {\n+                return Occurred.AFTER;\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (null == obj ||\n+                !(obj instanceof MockVersion)) {\n+                return false;\n+            }\n+            MockVersion v = (MockVersion)obj;\n+            return 0 == (version - v.version);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"version=\" + version;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return version;\n+        }\n+    }\n+\n+    private String name;\n+    private TreeMap<String, Versioned<Value>> map = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    public MockMetastoreTable(MockMetaStore metastore, String name) {\n+        this.map = new TreeMap<String, Versioned<Value>>();\n+        this.name = name;\n+        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+    }\n+\n+    @Override\n+    public String getName () {\n+        return this.name;\n+    }\n+\n+    static Versioned<Value> cloneValue(Value value, Version version, Set<String> fields) {\n+        if (null != value) {\n+            Value newValue = new Value();\n+            if (ALL_FIELDS == fields) {\n+                fields = value.getFields();\n+            }\n+            for (String f : fields) {\n+                newValue.setField(f, value.getField(f));\n+            }\n+            value = newValue;\n+        }\n+\n+        if (null == version) {\n+            throw new NullPointerException(\"Version isn't allowed to be null.\");\n+        }\n+        if (Version.ANY != version && Version.NEW != version) {\n+            if (version instanceof MockVersion) {\n+                version = new MockVersion(((MockVersion)version).version);\n+            } else {\n+                throw new IllegalStateException(\"Wrong version type.\");\n+            }\n+        }\n+        return new Versioned<Value>(value, version);\n+    }\n+\n+    @Override\n+    public void get(final String key, final MetastoreCallback<Versioned<Value>> cb, final Object ctx) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                scheduleGet(key, ALL_FIELDS, cb, ctx);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void get(final String key, final Set<String> fields, final MetastoreCallback<Versioned<Value>> cb,\n+            final Object ctx) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                scheduleGet(key, fields, cb, ctx);\n+            }\n+        });\n+    }\n+\n+    public synchronized void scheduleGet(String key, Set<String> fields, MetastoreCallback<Versioned<Value>> cb,\n+            Object ctx) {\n+        if (null == key) {\n+            cb.complete(Code.IllegalOp.getCode(), null, ctx);\n+            return;\n+        }\n+        Versioned<Value> vv = mockGet(key);\n+        int rc = null == vv ? Code.NoKey.getCode() : Code.OK.getCode();\n+        if (vv != null) {\n+            vv = cloneValue(vv.getValue(), vv.getVersion(), fields);\n+        }\n+        cb.complete(rc, vv, ctx);\n+    }\n+\n+    @Override\n+    public void put(final String key, final Value value, final Version version, final MetastoreCallback<Version> cb,\n+            final Object ctx) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (null == key || null == value || null == version) {\n+                    cb.complete(Code.IllegalOp.getCode(), null, ctx);\n+                    return;\n+                }\n+                Result<Version> result = mockPut(key, value, version);\n+                cb.complete(result.code.getCode(), result.value, ctx);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void remove(final String key, final Version version, final MetastoreCallback<Void> cb, final Object ctx) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (null == key || null == version) {\n+                    cb.complete(Code.IllegalOp.getCode(), null, ctx);\n+                    return;\n+                }\n+                Code code = mockRemove(key, version);\n+                cb.complete(code.getCode(), null, ctx);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void openCursor(MetastoreCallback<MetastoreCursor> cb, Object ctx) {\n+        openCursor(EMPTY_START_KEY, true, EMPTY_END_KEY, true, Order.ASC,\n+                   ALL_FIELDS, cb, ctx);\n+    }\n+\n+    @Override\n+    public void openCursor(Set<String> fields,\n+                           MetastoreCallback<MetastoreCursor> cb, Object ctx) {\n+        openCursor(EMPTY_START_KEY, true, EMPTY_END_KEY, true, Order.ASC,\n+                   fields, cb, ctx);\n+    }\n+\n+    @Override\n+    public void openCursor(String firstKey, boolean firstInclusive,\n+                           String lastKey, boolean lastInclusive,\n+                           Order order, MetastoreCallback<MetastoreCursor> cb,\n+                           Object ctx) {\n+        openCursor(firstKey, firstInclusive, lastKey, lastInclusive,\n+                   order, ALL_FIELDS, cb, ctx);\n+    }\n+\n+    @Override\n+    public void openCursor(final String firstKey, final boolean firstInclusive,\n+                           final String lastKey, final boolean lastInclusive,\n+                           final Order order, final Set<String> fields,\n+                           final MetastoreCallback<MetastoreCursor> cb, final Object ctx) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                Result<MetastoreCursor> result = mockOpenCursor(firstKey, firstInclusive, lastKey, lastInclusive,\n+                        order, fields);\n+                cb.complete(result.code.getCode(), result.value, ctx);\n+            }\n+        });\n+    }\n+\n+    private synchronized Versioned<Value> mockGet(String key) {\n+        return map.get(key);\n+    }\n+\n+    private synchronized Code mockRemove(String key, Version version) {\n+        Versioned<Value> vv = map.get(key);\n+        if (null == vv) {\n+            return Code.NoKey;\n+        }\n+        if (Version.Occurred.CONCURRENTLY != vv.getVersion().compare(version)) {\n+            return Code.BadVersion;\n+        }\n+        map.remove(key);\n+        return Code.OK;\n+    }\n+\n+    static class Result<T> {\n+        Code code;\n+        T value;\n+\n+        public Result(Code code, T value) {\n+            this.code = code;\n+            this.value = value;\n+        }\n+    }\n+\n+    private synchronized Result<Version> mockPut(String key, Value value, Version version) {\n+        Versioned<Value> vv = map.get(key);\n+        if (vv == null) {\n+            if (Version.NEW != version) {\n+                return new Result<Version>(Code.NoKey, null);\n+            }\n+            vv = cloneValue(value, version, ALL_FIELDS);\n+            vv.setVersion(new MockVersion(0));\n+            map.put(key, vv);\n+            return new Result<Version>(Code.OK, new MockVersion(0));\n+        }\n+        if (Version.NEW == version) {\n+            return new Result<Version>(Code.KeyExists, null);\n+        }\n+        if (Version.Occurred.CONCURRENTLY != vv.getVersion().compare(version)) {\n+            return new Result<Version>(Code.BadVersion, null);\n+        }\n+        vv.setVersion(((MockVersion)vv.getVersion()).incrementVersion());\n+        vv.setValue(vv.getValue().merge(value));\n+        return new Result<Version>(Code.OK, new MockVersion((MockVersion)vv.getVersion()));\n+    }\n+\n+    private synchronized Result<MetastoreCursor> mockOpenCursor(\n+            String firstKey, boolean firstInclusive,\n+            String lastKey, boolean lastInclusive,\n+            Order order, Set<String> fields) {\n+        if (0 == map.size()) {\n+            return new Result<MetastoreCursor>(Code.OK, MetastoreCursor.EMPTY_CURSOR);\n+        }\n+\n+        boolean isLegalCursor = false;\n+        NavigableMap<String, Versioned<Value>> myMap = null;\n+        if (Order.ASC == order) {\n+            myMap = map;\n+            if (EMPTY_END_KEY == lastKey ||\n+                lastKey.compareTo(myMap.lastKey()) > 0) {\n+                lastKey = myMap.lastKey();\n+                lastInclusive = true;\n+            }\n+            if (EMPTY_START_KEY == firstKey ||\n+                firstKey.compareTo(myMap.firstKey()) < 0) {\n+                firstKey = myMap.firstKey();\n+                firstInclusive = true;\n+            }\n+            if (firstKey.compareTo(lastKey) <= 0) {\n+                isLegalCursor = true;\n+            }\n+        } else if (Order.DESC == order) {\n+            myMap = map.descendingMap();\n+            if (EMPTY_START_KEY == lastKey ||\n+                lastKey.compareTo(myMap.lastKey()) < 0) {\n+                lastKey = myMap.lastKey();\n+                lastInclusive = true;\n+            }\n+            if (EMPTY_END_KEY == firstKey ||\n+                firstKey.compareTo(myMap.firstKey()) > 0) {\n+                firstKey = myMap.firstKey();\n+                firstInclusive = true;\n+            }\n+            if (firstKey.compareTo(lastKey) >= 0) {\n+                isLegalCursor = true;\n+            }\n+        }\n+\n+        if (!isLegalCursor || null == myMap) {\n+            return new Result<MetastoreCursor>(Code.IllegalOp, null);\n+        }\n+        MetastoreCursor cursor = new MockMetastoreCursor(\n+                myMap.subMap(firstKey, firstInclusive, lastKey, lastInclusive), fields, scheduler);\n+        return new Result<MetastoreCursor>(Code.OK, cursor);\n+    }\n+\n+    @Override\n+    public void close() {\n+        // do nothing\n+    }\n+}"},{"sha":"51201e999ee05328861c1d8245c805bd7f6c96cf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreScannableTableAsyncToSyncConverter.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,59 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n+\n+public class MetastoreScannableTableAsyncToSyncConverter extends\n+             MetastoreTableAsyncToSyncConverter {\n+\n+    private MetastoreScannableTable scannableTable;\n+\n+    public MetastoreScannableTableAsyncToSyncConverter(\n+            MetastoreScannableTable table) {\n+        super(table);\n+        this.scannableTable = table;\n+    }\n+\n+    public MetastoreCursor openCursor(String firstKey, boolean firstInclusive,\n+                                      String lastKey, boolean lastInclusive,\n+                                      Order order)\n+    throws MSException {\n+        HeldValue<MetastoreCursor> retValue = new HeldValue<MetastoreCursor>();\n+        // make the actual async call\n+        this.scannableTable.openCursor(firstKey, firstInclusive, lastKey, lastInclusive,\n+                                       order, retValue, null);\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+    public MetastoreCursor openCursor(String firstKey, boolean firstInclusive,\n+                                      String lastKey, boolean lastInclusive,\n+                                      Order order, Set<String> fields)\n+    throws MSException {\n+        HeldValue<MetastoreCursor> retValue = new HeldValue<MetastoreCursor>();\n+        // make the actual async call\n+        this.scannableTable.openCursor(firstKey, firstInclusive, lastKey, lastInclusive,\n+                                       order, fields, retValue, null);\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+}"},{"sha":"4c061abd485038537298318cff85126ea9dee64e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/MetastoreTableAsyncToSyncConverter.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.metastore.MetastoreCallback;\n+import org.apache.bookkeeper.metastore.MetastoreTable;\n+import org.apache.bookkeeper.metastore.MSException;\n+import org.apache.bookkeeper.metastore.MSException.Code;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+// Converts async calls to sync calls for MetastoreTable. Currently not\n+// intended to be used other than for simple functional tests, however,\n+// could be developed into a sync API.\n+\n+public class MetastoreTableAsyncToSyncConverter {\n+\n+    static class HeldValue<T> implements MetastoreCallback<T> {\n+        private CountDownLatch countDownLatch = new CountDownLatch(1);\n+        private int code;\n+        private T value = null;\n+\n+        void waitCallback() throws MSException {\n+            try {\n+                countDownLatch.await(10, TimeUnit.SECONDS);\n+            } catch (InterruptedException ie) {\n+                throw MSException.create(Code.InterruptedException);\n+            }\n+\n+            if (Code.OK.getCode() != code) {\n+                throw MSException.create(Code.get(code));\n+            }\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+\n+        @Override\n+        public void complete(int rc, T value, Object ctx) {\n+            this.code = rc;\n+            this.value = value;\n+            countDownLatch.countDown();\n+        }\n+    }\n+\n+    protected MetastoreTable table;\n+\n+    public MetastoreTableAsyncToSyncConverter(MetastoreTable table) {\n+        this.table = table;\n+    }\n+\n+    public Versioned<Value> get(String key) throws MSException {\n+        HeldValue<Versioned<Value>> retValue =\n+            new HeldValue<Versioned<Value>>();\n+\n+        // make the actual async call\n+        this.table.get(key, retValue, null);\n+\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+    public Versioned<Value> get(String key, Set<String> fields)\n+    throws MSException {\n+        HeldValue<Versioned<Value>> retValue =\n+            new HeldValue<Versioned<Value>>();\n+\n+        // make the actual async call\n+        this.table.get(key, fields, retValue, null);\n+\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+    public void remove(String key, Version version) throws MSException {\n+        HeldValue<Void> retValue = new HeldValue<Void>();\n+\n+        // make the actual async call\n+        this.table.remove(key, version, retValue, null);\n+\n+        retValue.waitCallback();\n+    }\n+\n+    public Version put(String key, Value value, Version version)\n+    throws MSException {\n+        HeldValue<Version> retValue = new HeldValue<Version>();\n+\n+        // make the actual async call\n+        this.table.put(key, value, version, retValue, null);\n+\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+    public MetastoreCursor openCursor() throws MSException {\n+        HeldValue<MetastoreCursor> retValue = new HeldValue<MetastoreCursor>();\n+        // make the actual async call\n+        this.table.openCursor(retValue, null);\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+    public MetastoreCursor openCursor(Set<String> fields) throws MSException {\n+        HeldValue<MetastoreCursor> retValue = new HeldValue<MetastoreCursor>();\n+        // make the actual async call\n+        this.table.openCursor(fields, retValue, null);\n+        retValue.waitCallback();\n+        return retValue.getValue();\n+    }\n+\n+}"},{"sha":"d528a18b4effad0eb232935e89906abe456739c3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","status":"added","additions":649,"deletions":0,"changes":649,"blob_url":"https://github.com/apache/bookkeeper/blob/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","raw_url":"https://github.com/apache/bookkeeper/raw/9b7b78890c2f0631a2b62bbbaa8de35ede102c0e/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/metastore/TestMetaStore.java?ref=9b7b78890c2f0631a2b62bbbaa8de35ede102c0e","patch":"@@ -0,0 +1,649 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.metastore;\n+\n+import static org.apache.bookkeeper.metastore.MetastoreScannableTable.EMPTY_END_KEY;\n+import static org.apache.bookkeeper.metastore.MetastoreScannableTable.EMPTY_START_KEY;\n+import static org.apache.bookkeeper.metastore.MetastoreTable.ALL_FIELDS;\n+import static org.apache.bookkeeper.metastore.MetastoreTable.NON_FIELDS;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.bookkeeper.metastore.MSException.Code;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n+import org.apache.bookkeeper.metastore.mock.MockMetaStore;\n+import org.apache.bookkeeper.metastore.mock.MockMetastoreTable.MockVersion;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.commons.configuration.CompositeConfiguration;\n+import org.apache.commons.configuration.Configuration;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+public class TestMetaStore extends TestCase {\n+    final static Logger logger = LoggerFactory.getLogger(TestMetaStore.class);\n+\n+    protected final static String TABLE = \"myTable\";\n+    protected final static String RECORDID = \"test\";\n+    protected final static String FIELD_NAME = \"name\";\n+    protected final static String FIELD_COUNTER = \"counter\";\n+\n+    protected String getFieldFromValue(Value value, String field) {\n+        byte[] v = value.getField(field);\n+        return v == null ? null : new String(v);\n+    }\n+\n+    protected static Value makeValue(String name, Integer counter) {\n+        Value data = new Value();\n+\n+        if (name != null) {\n+            data.setField(FIELD_NAME, name.getBytes());\n+        }\n+\n+        if (counter != null) {\n+            data.setField(FIELD_COUNTER, counter.toString().getBytes());\n+        }\n+\n+        return data;\n+    }\n+\n+    protected class Record {\n+        String name;\n+        Integer counter;\n+        Version version;\n+\n+        public Record() {\n+        }\n+\n+        public Record(String name, Integer counter, Version version) {\n+            this.name = name;\n+            this.counter = counter;\n+            this.version = version;\n+        }\n+\n+        public Record(Versioned<Value> vv) {\n+            version = vv.getVersion();\n+\n+            Value value = vv.getValue();\n+            if (value == null) {\n+                return;\n+            }\n+\n+            name = getFieldFromValue(value, FIELD_NAME);\n+            String c = getFieldFromValue(value, FIELD_COUNTER);\n+            if (c != null) {\n+                counter = new Integer(c);\n+            }\n+        }\n+\n+        public Version getVersion() {\n+            return version;\n+        }\n+\n+        public Value getValue() {\n+            return TestMetaStore.makeValue(name, counter);\n+        }\n+\n+        public Versioned<Value> getVersionedValue() {\n+            return new Versioned<Value>(getValue(), version);\n+        }\n+\n+        public void merge(String name, Integer counter, Version version) {\n+            if (name != null) {\n+                this.name = name;\n+            }\n+            if (counter != null) {\n+                this.counter = counter;\n+            }\n+            if (version != null) {\n+                this.version = version;\n+            }\n+        }\n+\n+        public void merge(Record record) {\n+            merge(record.name, record.counter, record.version);\n+        }\n+\n+        public void checkEqual(Versioned<Value> vv) {\n+            Version v = vv.getVersion();\n+            Value value = vv.getValue();\n+\n+            assertEquals(name, getFieldFromValue(value, FIELD_NAME));\n+\n+            String c = getFieldFromValue(value, FIELD_COUNTER);\n+            if (counter == null) {\n+                assertNull(c);\n+            } else {\n+                assertEquals(counter.toString(), c);\n+            }\n+\n+            assertTrue(isEqualVersion(version, v));\n+        }\n+\n+    }\n+\n+    protected MetaStore metastore;\n+    protected MetastoreScannableTable myActualTable;\n+    protected MetastoreScannableTableAsyncToSyncConverter myTable;\n+\n+    protected String getMetaStoreName() {\n+        return MockMetaStore.class.getName();\n+    }\n+\n+    protected Configuration getConfiguration() {\n+        return new CompositeConfiguration();\n+    }\n+\n+    protected Version newBadVersion() {\n+        return new MockVersion(-1);\n+    }\n+\n+    protected Version nextVersion(Version version) {\n+        if (Version.NEW == version) {\n+            return new MockVersion(0);\n+        }\n+        if (Version.ANY == version) {\n+            return Version.ANY;\n+        }\n+        assertTrue(version instanceof MockVersion);\n+        return new MockVersion(((MockVersion) version).incrementVersion());\n+    }\n+\n+    private void checkVersion(Version v) {\n+        assertNotNull(v);\n+        if (v != Version.NEW && v != Version.ANY) {\n+            assertTrue(v instanceof MockVersion);\n+        }\n+    }\n+\n+    protected boolean isEqualVersion(Version v1, Version v2) {\n+        checkVersion(v1);\n+        checkVersion(v2);\n+        return v1.compare(v2) == Version.Occurred.CONCURRENTLY;\n+    }\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        metastore = MetastoreFactory.createMetaStore(getMetaStoreName());\n+        Configuration config = getConfiguration();\n+        metastore.init(config, metastore.getVersion());\n+\n+        myActualTable = metastore.createScannableTable(TABLE);\n+        myTable = new MetastoreScannableTableAsyncToSyncConverter(myActualTable);\n+\n+        // setup a clean environment\n+        clearTable();\n+    }\n+\n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        // also clear table after test\n+        clearTable();\n+\n+        myActualTable.close();\n+        metastore.close();\n+    }\n+\n+    void checkExpectedValue(Versioned<Value> vv, String expectedName,\n+                            Integer expectedCounter, Version expectedVersion) {\n+        Record expected = new Record(expectedName, expectedCounter, expectedVersion);\n+        expected.checkEqual(vv);\n+    }\n+\n+    protected Integer getRandom() {\n+        return (int)Math.random()*65536;\n+    }\n+\n+    protected Versioned<Value> getRecord(String recordId) throws Exception {\n+        try {\n+            return myTable.get(recordId);\n+        } catch (MSException.NoKeyException nke) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * get record with specific fields, assume record EXIST!\n+     */\n+    protected Versioned<Value> getExistRecordFields(String recordId, Set<String> fields)\n+    throws Exception {\n+        Versioned<Value> retValue = myTable.get(recordId, fields);\n+        return retValue;\n+    }\n+\n+    /**\n+     * put and check fields\n+     */\n+    protected void putAndCheck(String recordId, String name,\n+                                      Integer counter, Version version,\n+                                      Record expected, Code expectedCode)\n+    throws Exception {\n+        Version retVersion = null;\n+        Code code = Code.OperationFailure;\n+        try {\n+            retVersion = myTable.put(recordId, makeValue(name, counter), version);\n+            code = Code.OK;\n+        } catch (MSException.BadVersionException bve) {\n+            code = Code.BadVersion;\n+        } catch (MSException.NoKeyException nke) {\n+            code = Code.NoKey;\n+        } catch (MSException.KeyExistsException kee) {\n+            code = Code.KeyExists;\n+        }\n+        assertEquals(expectedCode, code);\n+\n+        // get and check all fields of record\n+        if (Code.OK == code) {\n+            assertTrue(isEqualVersion(retVersion, nextVersion(version)));\n+            expected.merge(name, counter, retVersion);\n+        }\n+\n+        Versioned<Value> existedVV = getRecord(recordId);\n+        if (null == expected) {\n+            assertNull(existedVV);\n+        } else {\n+            expected.checkEqual(existedVV);\n+        }\n+    }\n+\n+    protected void clearTable() throws Exception {\n+        MetastoreCursor cursor = myTable.openCursor();\n+        if (!cursor.hasMoreEntries()) {\n+            return;\n+        }\n+        while (cursor.hasMoreEntries()) {\n+            Iterator<MetastoreTableItem> iter = cursor.readEntries(99);\n+            while (iter.hasNext()) {\n+                MetastoreTableItem item = iter.next();\n+                String key = item.getKey();\n+                myTable.remove(key, Version.ANY);\n+            }\n+        }\n+        cursor.close();\n+    }\n+\n+    /**\n+     * Test (get, get partial field, remove) on non-existent element.\n+     */\n+    @Test\n+    public void testNonExistent() throws Exception {\n+        // get\n+        try {\n+            myTable.get(RECORDID);\n+            fail(\"Should fail to get a non-existent key\");\n+        } catch (MSException.NoKeyException nke) {\n+        }\n+\n+        // get partial field\n+        Set<String> fields =\n+            new HashSet<String>(Arrays.asList(new String[] { FIELD_COUNTER }));\n+        try {\n+            myTable.get(RECORDID, fields);\n+            fail(\"Should fail to get a non-existent key with specified fields\");\n+        } catch (MSException.NoKeyException nke) {\n+        }\n+\n+        // remove\n+        try {\n+            myTable.remove(RECORDID, Version.ANY);\n+            fail(\"Should fail to delete a non-existent key\");\n+        } catch (MSException.NoKeyException nke) {\n+        }\n+    }\n+\n+    /**\n+     * Test usage of get operation on (full and partial) fields.\n+     */\n+    @Test\n+    public void testGet() throws Exception {\n+        Versioned<Value> vv;\n+\n+        final Set<String> fields =\n+            new HashSet<String>(Arrays.asList(new String[] { FIELD_NAME }));\n+\n+        final String name = \"get\";\n+        final Integer counter = getRandom();\n+\n+        // put test item\n+        Version version = myTable.put(RECORDID, makeValue(name, counter), Version.NEW);\n+        assertNotNull(version);\n+\n+        // fetch with all fields\n+        vv = getExistRecordFields(RECORDID, ALL_FIELDS);\n+        checkExpectedValue(vv, name, counter, version);\n+\n+        // partial get name\n+        vv = getExistRecordFields(RECORDID, fields);\n+        checkExpectedValue(vv, name, null, version);\n+\n+        // non fields\n+        vv = getExistRecordFields(RECORDID, NON_FIELDS);\n+        checkExpectedValue(vv, null, null, version);\n+\n+        // get null key should fail\n+        try {\n+            getExistRecordFields(null, NON_FIELDS);\n+            fail(\"Should fail to get null key with NON fields\");\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+        try {\n+            getExistRecordFields(null, ALL_FIELDS);\n+            fail(\"Should fail to get null key with ALL fields.\");\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+        try {\n+            getExistRecordFields(null, fields);\n+            fail(\"Should fail to get null key with fields \" + fields);\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+    }\n+\n+    /**\n+     * Test usage of put operation with (full and partial) fields.\n+     */\n+    @Test\n+    public void testPut() throws Exception {\n+        final Integer counter = getRandom();\n+        final String name = \"put\";\n+\n+        Version version;\n+\n+        /**\n+         * test correct version put\n+         */\n+        // put test item\n+        version = myTable.put(RECORDID, makeValue(name, counter), Version.NEW);\n+        assertNotNull(version);\n+        Record expected = new Record(name, counter, version);\n+\n+        // correct version put with only name field changed\n+        putAndCheck(RECORDID, \"name1\", null, expected.getVersion(), expected, Code.OK);\n+\n+        // correct version put with only counter field changed\n+        putAndCheck(RECORDID, null, counter + 1, expected.getVersion(), expected, Code.OK);\n+\n+        // correct version put with all fields filled\n+        putAndCheck(RECORDID, \"name2\", counter + 2, expected.getVersion(), expected, Code.OK);\n+\n+        // test put exist entry with Version.ANY\n+        checkPartialPut(\"put exist entry with Version.ANY\", Version.ANY, expected, Code.OK);\n+\n+        /**\n+         * test bad version put\n+         */\n+        // put to existed entry with Version.NEW\n+        badVersionedPut(Version.NEW, Code.KeyExists);\n+        // put to existed entry with bad version\n+        badVersionedPut(newBadVersion(), Code.BadVersion);\n+\n+        // remove the entry\n+        myTable.remove(RECORDID, Version.ANY);\n+\n+        // put to non-existent entry with bad version\n+        badVersionedPut(newBadVersion(), Code.NoKey);\n+        // put to non-existent entry with Version.ANY\n+        badVersionedPut(Version.ANY, Code.NoKey);\n+\n+        /**\n+         * test illegal arguments\n+         */\n+        illegalPut(null, Version.NEW);\n+        illegalPut(makeValue(\"illegal value\", getRandom()), null);\n+        illegalPut(null, null);\n+    }\n+\n+    protected void badVersionedPut(Version badVersion, Code expectedCode) throws Exception {\n+        Versioned<Value> vv = getRecord(RECORDID);\n+        Record expected = null;\n+\n+        if (expectedCode != Code.NoKey) {\n+            assertNotNull(vv);\n+            expected = new Record(vv);\n+        }\n+\n+        checkPartialPut(\"badVersionedPut\", badVersion, expected, expectedCode);\n+    }\n+\n+    protected void checkPartialPut(String name, Version version, Record expected, Code expectedCode)\n+            throws Exception {\n+        Integer counter;\n+\n+        // bad version put with all fields filled\n+        counter = getRandom();\n+        putAndCheck(RECORDID, name + counter, counter, version, expected, expectedCode);\n+\n+        // bad version put with only name field changed\n+        counter = getRandom();\n+        putAndCheck(RECORDID, name + counter, null, version, expected, expectedCode);\n+\n+        // bad version put with only counter field changed\n+        putAndCheck(RECORDID, null, counter, version, expected, expectedCode);\n+    }\n+\n+    protected void illegalPut(Value value, Version version) throws MSException {\n+        try {\n+            myTable.put(RECORDID, value, version);\n+            fail(\"Should fail to do versioned put with illegal arguments\");\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+    }\n+\n+    /**\n+     * Test usage of (unconditional remove, BadVersion remove, CorrectVersion\n+     * remove) operation.\n+     */\n+    @Test\n+    public void testRemove() throws Exception {\n+        final Integer counter = getRandom();\n+        final String name = \"remove\";\n+        Version version;\n+\n+        // insert test item\n+        version = myTable.put(RECORDID, makeValue(name, counter), Version.NEW);\n+        assertNotNull(version);\n+\n+        // test unconditional remove\n+        myTable.remove(RECORDID, Version.ANY);\n+\n+        // insert test item\n+        version = myTable.put(RECORDID, makeValue(name, counter), Version.NEW);\n+        assertNotNull(version);\n+\n+        // test remove with bad version\n+        try {\n+            myTable.remove(RECORDID, Version.NEW);\n+            fail(\"Should fail to remove a given key with bad version\");\n+        } catch (MSException.BadVersionException bve) {\n+        }\n+        try {\n+            myTable.remove(RECORDID, newBadVersion());\n+            fail(\"Should fail to remove a given key with bad version\");\n+        } catch (MSException.BadVersionException bve) {\n+        }\n+\n+        // test remove with correct version\n+        myTable.remove(RECORDID, version);\n+    }\n+\n+    protected void openCursorTest(MetastoreCursor cursor, Map<String, Value> expectedValues,\n+                                  int numEntriesPerScan) throws Exception {\n+        try {\n+            Map<String, Value> entries = Maps.newHashMap();\n+            while (cursor.hasMoreEntries()) {\n+                Iterator<MetastoreTableItem> iter = cursor.readEntries(numEntriesPerScan);\n+                while (iter.hasNext()) {\n+                    MetastoreTableItem item = iter.next();\n+                    entries.put(item.getKey(), item.getValue().getValue());\n+                }\n+            }\n+            MapDifference<String, Value> diff = Maps.difference(expectedValues, entries);\n+            assertTrue(diff.areEqual());\n+        } finally {\n+            cursor.close();\n+        }\n+    }\n+\n+    void openRangeCursorTest(String firstKey, boolean firstInclusive,\n+                             String lastKey, boolean lastInclusive,\n+                             Order order, Set<String> fields,\n+                             Iterator<Map.Entry<String, Value>> expectedValues,\n+                             int numEntriesPerScan) throws Exception {\n+        MetastoreCursor cursor = myTable.openCursor(firstKey, firstInclusive,\n+                                                    lastKey, lastInclusive,\n+                                                    order, fields);\n+        try {\n+            while (cursor.hasMoreEntries()) {\n+                Iterator<MetastoreTableItem> iter = cursor.readEntries(numEntriesPerScan);\n+                while (iter.hasNext()) {\n+                    assertTrue(expectedValues.hasNext());\n+                    MetastoreTableItem item = iter.next();\n+                    Map.Entry<String, Value> expectedItem = expectedValues.next();\n+                    assertEquals(expectedItem.getKey(), item.getKey());\n+                    assertEquals(expectedItem.getValue(), item.getValue().getValue());\n+                }\n+            }\n+            assertFalse(expectedValues.hasNext());\n+        } finally {\n+            cursor.close();\n+        }\n+    }\n+\n+    /**\n+     * Test usage of (scan) operation on (full and partial) fields.\n+     */\n+    @Test\n+    public void testOpenCursor() throws Exception {\n+\n+        TreeMap<String, Value> allValues = Maps.newTreeMap();\n+        TreeMap<String, Value> partialValues = Maps.newTreeMap();\n+        TreeMap<String, Value> nonValues = Maps.newTreeMap();\n+\n+        Set<String> counterFields = Sets.newHashSet(FIELD_COUNTER);\n+\n+        for (int i=5; i<24; i++) {\n+            char c = (char)('a' + i);\n+            String key = String.valueOf(c);\n+            Value v = makeValue(\"value\" + i, i);\n+            Value cv = v.project(counterFields);\n+            Value nv = v.project(NON_FIELDS);\n+\n+            myTable.put(key, new Value(v), Version.NEW);\n+            allValues.put(key, v);\n+            partialValues.put(key, cv);\n+            nonValues.put(key, nv);\n+        }\n+\n+        // test open cursor\n+        MetastoreCursor cursor = myTable.openCursor(ALL_FIELDS);\n+        openCursorTest(cursor, allValues, 7);\n+\n+        cursor = myTable.openCursor(counterFields);\n+        openCursorTest(cursor, partialValues, 7);\n+\n+        cursor = myTable.openCursor(NON_FIELDS);\n+        openCursorTest(cursor, nonValues, 7);\n+\n+        // test order inclusive exclusive\n+        Iterator<Map.Entry<String, Value>> expectedIterator;\n+\n+        expectedIterator = allValues.subMap(\"l\", true, \"u\", true).entrySet().iterator();\n+        openRangeCursorTest(\"l\", true, \"u\", true, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.descendingMap().subMap(\"u\", true, \"l\", true)\n+                           .entrySet().iterator();\n+        openRangeCursorTest(\"u\", true, \"l\", true, Order.DESC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.subMap(\"l\", false, \"u\", false).entrySet().iterator();\n+        openRangeCursorTest(\"l\", false, \"u\", false, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.descendingMap().subMap(\"u\", false, \"l\", false)\n+                           .entrySet().iterator();\n+        openRangeCursorTest(\"u\", false, \"l\", false, Order.DESC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.subMap(\"l\", true, \"u\", false).entrySet().iterator();\n+        openRangeCursorTest(\"l\", true, \"u\", false, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.descendingMap().subMap(\"u\", true, \"l\", false)\n+                           .entrySet().iterator();\n+        openRangeCursorTest(\"u\", true, \"l\", false, Order.DESC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.subMap(\"l\", false, \"u\", true).entrySet().iterator();\n+        openRangeCursorTest(\"l\", false, \"u\", true, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.descendingMap().subMap(\"u\", false, \"l\", true)\n+                           .entrySet().iterator();\n+        openRangeCursorTest(\"u\", false, \"l\", true, Order.DESC, ALL_FIELDS, expectedIterator, 7);\n+\n+        // test out of range\n+        String firstKey = \"f\";\n+        String lastKey = \"x\";\n+        expectedIterator = allValues.subMap(firstKey, true, lastKey, true)\n+                           .entrySet().iterator();\n+        openRangeCursorTest(\"a\", true, \"z\", true, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.subMap(\"l\", true, lastKey, true).entrySet().iterator();\n+        openRangeCursorTest(\"l\", true, \"z\", true, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        expectedIterator = allValues.subMap(firstKey, true, \"u\", true).entrySet().iterator();\n+        openRangeCursorTest(\"a\", true, \"u\", true, Order.ASC, ALL_FIELDS, expectedIterator, 7);\n+\n+        // test EMPTY_START_KEY and EMPTY_END_KEY\n+        expectedIterator = allValues.subMap(firstKey, true, \"u\", true).entrySet().iterator();\n+        openRangeCursorTest(EMPTY_START_KEY, true, \"u\", true, Order.ASC, ALL_FIELDS,\n+                            expectedIterator, 7);\n+\n+        expectedIterator = allValues.descendingMap().subMap(lastKey, true, \"l\", true)\n+                           .entrySet().iterator();\n+        openRangeCursorTest(EMPTY_END_KEY, true, \"l\", true, Order.DESC, ALL_FIELDS,\n+                            expectedIterator, 7);\n+\n+        // test illegal arguments\n+        try {\n+            myTable.openCursor(\"a\", true, \"z\", true, Order.DESC, ALL_FIELDS);\n+            fail(\"Should fail with wrong range\");\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+        try {\n+            myTable.openCursor(\"z\", true, \"a\", true, Order.ASC, ALL_FIELDS);\n+            fail(\"Should fail with wrong range\");\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+        try {\n+            myTable.openCursor(\"a\", true, \"z\", true, null, ALL_FIELDS);\n+            fail(\"Should fail with null order\");\n+        } catch (MSException.IllegalOpException ioe) {\n+        }\n+    }\n+\n+}"}]}

