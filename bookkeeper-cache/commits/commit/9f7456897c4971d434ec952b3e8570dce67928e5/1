{"sha":"9f7456897c4971d434ec952b3e8570dce67928e5","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5Zjc0NTY4OTdjNDk3MWQ0MzRlYzk1MmIzZTg1NzBkY2U2NzkyOGU1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-08-20T10:50:35Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-08-20T10:50:35Z"},"message":"BOOKKEEPER-668: Race between PerChannelBookieClient#channelDisconnected() and disconnect() calls can make clients hang while add/reading entries in case of multiple bookie failures (sijie & ivank via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1515768 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f680042189cc9e2b04098c640da63b29b6f86dd9","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/f680042189cc9e2b04098c640da63b29b6f86dd9"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9f7456897c4971d434ec952b3e8570dce67928e5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9f7456897c4971d434ec952b3e8570dce67928e5","html_url":"https://github.com/apache/bookkeeper/commit/9f7456897c4971d434ec952b3e8570dce67928e5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9f7456897c4971d434ec952b3e8570dce67928e5/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f28beba4006b903d027308d631203afd4f46fca7","url":"https://api.github.com/repos/apache/bookkeeper/commits/f28beba4006b903d027308d631203afd4f46fca7","html_url":"https://github.com/apache/bookkeeper/commit/f28beba4006b903d027308d631203afd4f46fca7"}],"stats":{"total":102,"additions":93,"deletions":9},"files":[{"sha":"fd059f2b15a0493f6435eb47ddc3d9be6edd6f97","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/9f7456897c4971d434ec952b3e8570dce67928e5/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/9f7456897c4971d434ec952b3e8570dce67928e5/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=9f7456897c4971d434ec952b3e8570dce67928e5","patch":"@@ -58,6 +58,8 @@ Release 4.2.2 - Unreleased\n \n         BOOKKEEPER-667: Client write will fail with BadMetadataVersion in case of multiple Bookie failures with AutoRecovery enabled (sijie via ivank)\n \n+        BOOKKEEPER-668: Race between PerChannelBookieClient#channelDisconnected() and disconnect() calls can make clients hang while add/reading entries in case of multiple bookie failures (sijie & ivank via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-579: TestSubAfterCloseSub was put in a wrong package (sijie via ivank)"},{"sha":"5e147ce11e2f8026434fe987b9ff96b51d66bf8c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":16,"deletions":9,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/9f7456897c4971d434ec952b3e8570dce67928e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/9f7456897c4971d434ec952b3e8570dce67928e5/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=9f7456897c4971d434ec952b3e8570dce67928e5","patch":"@@ -397,10 +397,16 @@ void errorOutReadKey(final CompletionKey key) {\n             public void safeRun() {\n \n                 ReadCompletion readCompletion = readCompletions.remove(key);\n+                String bAddress = \"null\";\n+                Channel c = channel;\n+                if(c != null) {\n+                    bAddress = c.getRemoteAddress().toString();\n+                }\n \n                 if (readCompletion != null) {\n-                    LOG.error(\"Could not write  request for reading entry: \" + key.entryId + \" ledger-id: \"\n-                              + key.ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+                    LOG.error(\"Could not write request for reading entry: {}\"\n+                              + \" ledger-id: {} bookie: {}\",\n+                              new Object[] { key.entryId, key.ledgerId, bAddress });\n \n                     readCompletion.cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n                                                         key.ledgerId, key.entryId, null, readCompletion.ctx);\n@@ -419,10 +425,12 @@ public void safeRun() {\n \n                 if (addCompletion != null) {\n                     String bAddress = \"null\";\n-                    if(channel != null)\n-                        bAddress = channel.getRemoteAddress().toString();\n-                    LOG.error(\"Could not write request for adding entry: \" + key.entryId + \" ledger-id: \"\n-                              + key.ledgerId + \" bookie: \" + bAddress);\n+                    Channel c = channel;\n+                    if(c != null) {\n+                        bAddress = c.getRemoteAddress().toString();\n+                    }\n+                    LOG.error(\"Could not write request for adding entry: {} ledger-id: {} bookie: {}\",\n+                              new Object[] { key.entryId, key.ledgerId, bAddress });\n \n                     addCompletion.cb.writeComplete(BKException.Code.BookieHandleNotAvailableException, key.ledgerId,\n                                                    key.entryId, addr, addCompletion.ctx);\n@@ -486,9 +494,8 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n         if (c != null) {\n             closeChannel(c);\n         }\n-        if (this.channel == c) {\n-            errorOutOutstandingEntries();\n-        }\n+\n+        errorOutOutstandingEntries();\n \n         synchronized (this) {\n             if (this.channel == c"},{"sha":"fbd281b738eaf457421044e46d904b2122e852eb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/9f7456897c4971d434ec952b3e8570dce67928e5/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/9f7456897c4971d434ec952b3e8570dce67928e5/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=9f7456897c4971d434ec952b3e8570dce67928e5","patch":"@@ -29,11 +29,20 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n+import java.nio.ByteBuffer;\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.PerChannelBookieClient.ConnectionState;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n@@ -202,9 +211,75 @@ public void run() {\n         disconnectThread.join();\n         checkThread.join();\n         assertFalse(\"Failure in threads, check logs\", shouldFail.get());\n+        client.close();\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+\n+    /**\n+     * Test that requests are completed even if the channel is disconnected\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-668}\n+     */\n+    @Test(timeout=60000)\n+    public void testRequestCompletesAfterDisconnectRace() throws Exception {\n+        ServerConfiguration conf = killBookie(0);\n+\n+        Bookie delayBookie = new Bookie(conf) {\n+            @Override\n+            public ByteBuffer readEntry(long ledgerId, long entryId)\n+                    throws IOException, NoLedgerException {\n+                try {\n+                    Thread.sleep(3000);\n+                } catch (InterruptedException ie) {\n+                    throw new IOException(\"Interrupted waiting\", ie);\n+                }\n+                return super.readEntry(ledgerId, entryId);\n+            }\n+        };\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf, delayBookie));\n+\n+        ClientSocketChannelFactory channelFactory\n+            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+                                                Executors.newCachedThreadPool());\n+        final OrderedSafeExecutor executor = new OrderedSafeExecutor(1);\n+        InetSocketAddress addr = getBookie(0);\n+        AtomicLong bytesOutstanding = new AtomicLong(0);\n+\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n+                                                                         addr, bytesOutstanding);\n+        final CountDownLatch completion = new CountDownLatch(1);\n+        final ReadEntryCallback cb = new ReadEntryCallback() {\n+                @Override\n+                public void readEntryComplete(int rc, long ledgerId, long entryId,\n+                                              ChannelBuffer buffer, Object ctx) {\n+                    completion.countDown();\n+                }\n+            };\n \n+        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(final int rc, Void result) {\n+                if (rc != BKException.Code.OK) {\n+                    executor.submitOrdered(1, new SafeRunnable() {\n+                        @Override\n+                        public void safeRun() {\n+                            cb.readEntryComplete(rc, 1, 1, null, null);\n+                        }\n+                    });\n+                    return;\n+                }\n+\n+                client.readEntryAndFenceLedger(1, \"00000111112222233333\".getBytes(), 1, cb, null);\n+            }\n+        });\n+\n+        Thread.sleep(1000);\n+        client.disconnect();\n         client.close();\n         channelFactory.releaseExternalResources();\n         executor.shutdown();\n+\n+        assertTrue(\"Request should have completed\", completion.await(5, TimeUnit.SECONDS));\n     }\n }"}]}

