{"sha":"a01067bb2003e6836acc638b734581844eb08324","node_id":"MDY6Q29tbWl0MTU3NTk1NjphMDEwNjdiYjIwMDNlNjgzNmFjYzYzOGI3MzQ1ODE4NDRlYjA4MzI0","commit":{"author":{"name":"Benjamin Reed","email":"breed@apache.org","date":"2011-08-23T22:38:29Z"},"committer":{"name":"Benjamin Reed","email":"breed@apache.org","date":"2011-08-23T22:38:29Z"},"message":"BOOKKEEPER-38: Bookie Server doesn't exit when its zookeeper session is expired. So the process is hang there.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1160915 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8c665ad8a15c3a210618c9451c933ac121fc0393","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8c665ad8a15c3a210618c9451c933ac121fc0393"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a01067bb2003e6836acc638b734581844eb08324","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a01067bb2003e6836acc638b734581844eb08324","html_url":"https://github.com/apache/bookkeeper/commit/a01067bb2003e6836acc638b734581844eb08324","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a01067bb2003e6836acc638b734581844eb08324/comments","author":{"login":"breed","id":143779,"node_id":"MDQ6VXNlcjE0Mzc3OQ==","avatar_url":"https://avatars.githubusercontent.com/u/143779?v=4","gravatar_id":"","url":"https://api.github.com/users/breed","html_url":"https://github.com/breed","followers_url":"https://api.github.com/users/breed/followers","following_url":"https://api.github.com/users/breed/following{/other_user}","gists_url":"https://api.github.com/users/breed/gists{/gist_id}","starred_url":"https://api.github.com/users/breed/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/breed/subscriptions","organizations_url":"https://api.github.com/users/breed/orgs","repos_url":"https://api.github.com/users/breed/repos","events_url":"https://api.github.com/users/breed/events{/privacy}","received_events_url":"https://api.github.com/users/breed/received_events","type":"User","site_admin":false},"committer":{"login":"breed","id":143779,"node_id":"MDQ6VXNlcjE0Mzc3OQ==","avatar_url":"https://avatars.githubusercontent.com/u/143779?v=4","gravatar_id":"","url":"https://api.github.com/users/breed","html_url":"https://github.com/breed","followers_url":"https://api.github.com/users/breed/followers","following_url":"https://api.github.com/users/breed/following{/other_user}","gists_url":"https://api.github.com/users/breed/gists{/gist_id}","starred_url":"https://api.github.com/users/breed/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/breed/subscriptions","organizations_url":"https://api.github.com/users/breed/orgs","repos_url":"https://api.github.com/users/breed/repos","events_url":"https://api.github.com/users/breed/events{/privacy}","received_events_url":"https://api.github.com/users/breed/received_events","type":"User","site_admin":false},"parents":[{"sha":"a772663c8e7051396bac5bae5b4ba7bc7ec75e78","url":"https://api.github.com/repos/apache/bookkeeper/commits/a772663c8e7051396bac5bae5b4ba7bc7ec75e78","html_url":"https://github.com/apache/bookkeeper/commit/a772663c8e7051396bac5bae5b4ba7bc7ec75e78"}],"stats":{"total":147,"additions":130,"deletions":17},"files":[{"sha":"2d5642b2ab2f1ba7ebfd62eaeb8c99ddc39795ef","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/a01067bb2003e6836acc638b734581844eb08324/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/a01067bb2003e6836acc638b734581844eb08324/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=a01067bb2003e6836acc638b734581844eb08324","patch":"@@ -30,6 +30,8 @@ BUGFIXES:\n \n   BOOKKEEPER-29: BookieRecoveryTest fails intermittently (ivank, fpj via fpj)\n \n+  BOOKKEEPER-38: Bookie Server doesn't exit when its zookeeper session is expired. So the process is hang there. (Sijie Guo via breed)\n+\n  hedwig-server/\n \n   BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)"},{"sha":"1673addcf40c632682e018e341bbddf093ec3398","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":77,"deletions":15,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/a01067bb2003e6836acc638b734581844eb08324/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/a01067bb2003e6836acc638b734581844eb08324/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=a01067bb2003e6836acc638b734581844eb08324","patch":"@@ -38,6 +38,7 @@\n import java.util.concurrent.LinkedBlockingQueue;\n \n import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.CreateMode;\n@@ -60,13 +61,14 @@\n     final File journalDirectory;\n \n     final File ledgerDirectories[];\n-    \n+\n     // ZK registration path for this bookie\n     static final String BOOKIE_REGISTRATION_PATH = \"/ledgers/available/\";\n \n     // ZooKeeper client instance for the Bookie\n     ZooKeeper zk;\n-    \n+    private volatile boolean isZkExpired = true;\n+\n     // Running flag\n     private volatile boolean running = false;\n \n@@ -134,6 +136,7 @@ public void run() {\n         }\n     }\n     SyncThread syncThread = new SyncThread();\n+\n     public Bookie(int port, String zkServers, File journalDirectory, File ledgerDirectories[]) throws IOException {\n         this.journalDirectory = journalDirectory;\n         this.ledgerDirectories = ledgerDirectories;\n@@ -206,6 +209,10 @@ public Bookie(int port, String zkServers, File journalDirectory, File ledgerDire\n         LOG.debug(\"I'm starting a bookie with journal directory \" + journalDirectory.getName());\n         start();\n         syncThread.start();\n+        // set running here. \n+        // since bookie server use running as a flag to tell bookie server whether it is alive\n+        // if setting it in bookie thread, the watcher might run before bookie thread.\n+        running = true;\n     }\n \n     /**\n@@ -217,16 +224,9 @@ private void instantiateZookeeperClient(int port, String zkServers) throws IOExc\n             zk = null;\n             return;\n         }\n+        int zkTimeout = Integer.getInteger(\"zkTimeout\", 10000);\n         // Create the ZooKeeper client instance\n-        zk = new ZooKeeper(zkServers, 10000, new Watcher() {\n-            @Override\n-            public void process(WatchedEvent event) {\n-                // TODO: handle session disconnects and expires\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n-                }\n-            }\n-        });\n+        zk = newZookeeper(zkServers, zkTimeout);\n         // Create the ZK ephemeral node for this Bookie.\n         try {\n             zk.create(BOOKIE_REGISTRATION_PATH + InetAddress.getLocalHost().getHostAddress() + \":\" + port, new byte[0],\n@@ -239,6 +239,60 @@ public void process(WatchedEvent event) {\n             throw new IOException(e);\n         }\n     }\n+    \n+    /** \n+     * Create a new zookeeper client to zk cluster.\n+     * \n+     * <p>\n+     * Bookie Server just used zk client when syncing ledgers for garbage collection.\n+     * So when zk client is expired, it means this bookie server is not available in\n+     * bookie server list. The bookie client will be notified for its expiration. No\n+     * more bookie request will be sent to this server. So it's better to exit when zk\n+     * expired.\n+     * </p>\n+     * <p>\n+     * Since there are lots of bk operations cached in queue, so we wait for all the operations\n+     * are processed and quit. It is done by calling <b>shutdown</b>.\n+     * </p>\n+     *\n+     * @param zkServers the quorum list of zk servers\n+     * @param sessionTimeout session timeout of zk connection\n+     *\n+     * @return zk client instance\n+     */\n+    private ZooKeeper newZookeeper(final String zkServers,\n+            final int sessionTimeout) throws IOException {\n+        ZooKeeper newZk = new ZooKeeper(zkServers, sessionTimeout,\n+                new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        // handle session disconnects and expires\n+                        if (event.getType()\n+                                .equals(Watcher.Event.EventType.None)) {\n+                            if (event.getState().equals(\n+                                    Watcher.Event.KeeperState.Disconnected)) {\n+                                LOG.warn(\"ZK client has been disconnected to the ZK server!\");\n+                            } else if (event.getState().equals(\n+                                    Watcher.Event.KeeperState.SyncConnected)) {\n+                                LOG.info(\"ZK client has been reconnected to the ZK server!\");\n+                            }\n+                        }\n+                        // Check for expired connection.\n+                        if (event.getState().equals(\n+                                Watcher.Event.KeeperState.Expired)) {\n+                            LOG.error(\"ZK client connection to the ZK server has expired!\");\n+                            isZkExpired = true;\n+                            try {\n+                                shutdown();\n+                            } catch (InterruptedException ie) {\n+                                System.exit(-1);\n+                            }\n+                        }\n+                    }\n+                });\n+        isZkExpired = false;\n+        return newZk;\n+    }\n \n     private static int fullRead(FileChannel fc, ByteBuffer bb) throws IOException {\n         int total = 0;\n@@ -397,7 +451,7 @@ public void run() {\n             long nextPrealloc = preAllocSize;\n             long lastFlushPosition = 0;\n             logFile.write(zeros, nextPrealloc);\n-            running = true;\n+\n             // TODO: Currently, when we roll over the journal logs, the older\n             // ones are never garbage collected. We should remove a journal log\n             // once all of its entries have been synced with the entry logs.\n@@ -418,7 +472,11 @@ public void run() {\n                         toFlush.clear();\n                     }\n                 }\n-                if (qe == null) {\n+                if (isZkExpired) {\n+                    LOG.warn(\"Exiting... zk client has expired.\");\n+                    break;\n+                }\n+                if (qe == null) { // no more queue entry\n                     continue;\n                 }\n                 lenBuff.clear();\n@@ -440,7 +498,6 @@ public void run() {\n         } catch (Exception e) {\n             LOG.fatal(\"Bookie thread exiting\", e);\n         }\n-        running = false;\n     }\n \n     private FileChannel openChannel(long logId) throws FileNotFoundException {\n@@ -450,7 +507,10 @@ private FileChannel openChannel(long logId) throws FileNotFoundException {\n         return logFile;\n     }\n \n-    public void shutdown() throws InterruptedException {\n+    public synchronized void shutdown() throws InterruptedException {\n+        if (!running) { // avoid shutdown twice\n+          return;\n+        }\n         // Shutdown the ZK client\n         if(zk != null) zk.close();\n         this.interrupt();\n@@ -462,6 +522,8 @@ public void shutdown() throws InterruptedException {\n         }\n         // Shutdown the EntryLogger which has the GarbageCollector Thread running\n         entryLogger.shutdown();\n+        // setting running to false here, so watch thread in bookie server know it only after bookie shut down\n+        running = false;\n     }\n     \n     public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)"},{"sha":"c246a941a14a84bbdab6aee3b45445681695f1a1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":51,"deletions":2,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/a01067bb2003e6836acc638b734581844eb08324/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/a01067bb2003e6836acc638b734581844eb08324/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=a01067bb2003e6836acc638b734581844eb08324","patch":"@@ -40,6 +40,7 @@\n     NIOServerFactory nioServerFactory;\n     private volatile boolean running = false;\n     Bookie bookie;\n+    DeathWatcher deathWatcher;\n     static Logger LOG = Logger.getLogger(BookieServer.class);\n \n     public BookieServer(int port, String zkServers, File journalDirectory, File ledgerDirectories[]) throws IOException {\n@@ -50,22 +51,70 @@ public BookieServer(int port, String zkServers, File journalDirectory, File ledg\n     public void start() throws IOException {\n         nioServerFactory = new NIOServerFactory(port, this);\n         running = true;\n+        deathWatcher = new DeathWatcher();\n+        deathWatcher.start();\n     }\n \n-    public void shutdown() throws InterruptedException {\n-        running = false;\n+    public synchronized void shutdown() throws InterruptedException {\n+        if (!running) {\n+            return;\n+        }\n         nioServerFactory.shutdown();\n         bookie.shutdown();\n+        running = false;\n     }\n \n     public boolean isRunning(){\n         return bookie.isRunning() && nioServerFactory.isRunning() && running;\n     }\n \n+    /**\n+     * Whether bookie is running?\n+     *\n+     * @return true if bookie is running, otherwise return false\n+     */\n+    public boolean isBookieRunning() {\n+        return bookie.isRunning();\n+    }\n+\n+    /**\n+     * Whether nio server is running?\n+     *\n+     * @return true if nio server is running, otherwise return false\n+     */\n+    public boolean isNioServerRunning() {\n+        return nioServerFactory.isRunning();\n+    }\n+\n     public void join() throws InterruptedException {\n         nioServerFactory.join();\n     }\n \n+    /**\n+     * A thread to watch whether bookie & nioserver is still alive\n+     */\n+    class DeathWatcher extends Thread {\n+        @Override\n+        public void run() {\n+            int watchInterval = Integer.getInteger(\"bookie_death_watch_interval\", 1000);\n+            while(true) {\n+                try {\n+                    Thread.sleep(watchInterval);\n+                } catch (InterruptedException ie) {\n+                    // do nothing\n+                }\n+                if (!isBookieRunning() || !isNioServerRunning()) {\n+                    try {\n+                        shutdown();\n+                    } catch (InterruptedException ie) {\n+                        System.exit(-1);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * @param args\n      * @throws IOException"}]}

