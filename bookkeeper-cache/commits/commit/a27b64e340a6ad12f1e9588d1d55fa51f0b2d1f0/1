{"sha":"a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","node_id":"MDY6Q29tbWl0MTU3NTk1NjphMjdiNjRlMzQwYTZhZDEyZjFlOTU4OGQxZDU1ZmE1MWYwYjJkMWYw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-02T21:24:33Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-02T21:24:33Z"},"message":"BOOKKEEPER-55: SubscribeReconnectRetryTask might retry subscription endlessly when another subscription is already successfully created previously (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1428059 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ebfe0f4b97d785334a31460479ef667c3513f1e1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ebfe0f4b97d785334a31460479ef667c3513f1e1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","html_url":"https://github.com/apache/bookkeeper/commit/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"7b2b91579000bc99d6fdded3aefb349975058c6f","url":"https://api.github.com/repos/apache/bookkeeper/commits/7b2b91579000bc99d6fdded3aefb349975058c6f","html_url":"https://github.com/apache/bookkeeper/commit/7b2b91579000bc99d6fdded3aefb349975058c6f"}],"stats":{"total":423,"additions":324,"deletions":99},"files":[{"sha":"72d16721eb7e1fe2a486b08ff91c41b6a949390e","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -183,6 +183,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-470: Possible infinite loop in simple.SubscribeReconnectCallback (sijie via ivank)\n \n+        BOOKKEEPER-55: SubscribeReconnectRetryTask might retry subscription endlessly when another subscription is already successfully created previously (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-302: No more messages delivered when hub server scans messages over two ledgers. (sijie via ivank)"},{"sha":"245e0744ebb10a0a1c807861eae41c0dd8aedb59","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"modified","additions":14,"deletions":1,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -20,6 +20,7 @@\n import java.util.List;\n \n import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.netty.HChannel;\n import org.apache.hedwig.protocol.PubSubProtocol;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n@@ -82,6 +83,8 @@\n     // For synchronous calls, this variable is used to know when the background\n     // async process for it has completed, set in the VoidCallback.\n     public boolean isDone = false;\n+    // Record the original channel for a resubscribe request\n+    private HChannel origChannel = null;\n \n     // Constructor for all types of PubSub request data to send to the server\n     public PubSubData(final ByteString topic, final Message msg, final ByteString subscriberId,\n@@ -106,10 +109,20 @@ public void setCallback(Callback<PubSubProtocol.ResponseBody> callback) {\n     }\n \n     public void operationFinishedToCallback(Object context, PubSubProtocol.ResponseBody response){\n-\n         callback.operationFinished(context, response);\n     }\n \n+    public boolean isResubscribeRequest() {\n+        return null != origChannel;\n+    }\n+\n+    public HChannel getOriginalChannelForResubscribe() {\n+        return origChannel;\n+    }\n+\n+    public void setOriginalChannelForResubscribe(HChannel channel) {\n+        this.origChannel = channel;\n+    }\n \n     // Clear all of the stored servers we've contacted or attempted to in this\n     // request."},{"sha":"c9aeb385307340e75c03e24195d333ef0fbc5933","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception when the client failed to resubscribe\n+ * when topic moved or subscription is closed.\n+ */\n+public class ResubscribeException extends Exception {\n+\n+    public ResubscribeException(String message) {\n+        super(message);\n+    }\n+\n+    public ResubscribeException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+}"},{"sha":"0c676a13c909580f1aa85105fa54d1eb6469e273","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","status":"modified","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -75,6 +75,50 @@ public HChannel addChannel(T key, HChannel channel) {\n         }\n     }\n \n+    /**\n+     * Replace channel only if currently mapped to the given <code>oldChannel</code>.\n+     *\n+     * @param key\n+     *            Key\n+     * @param oldChannel\n+     *            Old Channel\n+     * @param newChannel\n+     *            New Channel\n+     * @return true if replaced successfully, otherwise false.\n+     */\n+    public boolean replaceChannel(T key, HChannel oldChannel, HChannel newChannel) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                if (null != oldChannel) oldChannel.close();\n+                if (null != newChannel) newChannel.close();\n+                return false;\n+            }\n+            if (null == oldChannel) {\n+                HChannel existedChannel = channels.putIfAbsent(key, newChannel);\n+                if (null != existedChannel) {\n+                    logger.info(\"Channel for {} already exists, so no need to replace it.\", key);\n+                    newChannel.close();\n+                    return false;\n+                } else {\n+                    logger.debug(\"Storing a new channel for {}.\", key);\n+                    return true;\n+                }\n+            } else {\n+                if (channels.replace(key, oldChannel, newChannel)) {\n+                    logger.debug(\"Replacd channel {} for {}.\", oldChannel, key);\n+                    oldChannel.close();\n+                    return true;\n+                } else {\n+                    newChannel.close();\n+                    return false;\n+                }\n+            }\n+        } finally {\n+            this.closedLock.readLock().unlock();\n+        }\n+    }\n+\n     /**\n      * Returns the channel bound with <code>key</code>.\n      *"},{"sha":"928f72f0577076f0380617965374a1042a87150d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","status":"modified","additions":34,"deletions":22,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -62,6 +62,7 @@\n import org.apache.hedwig.protoextensions.MessageIdUtils;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n import org.apache.hedwig.util.SubscriptionListener;\n import static org.apache.hedwig.util.VarArgs.va;\n \n@@ -98,8 +99,8 @@ protected ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n     protected ActiveSubscriber createActiveSubscriber(\n         ClientConfiguration cfg, AbstractHChannelManager channelManager,\n         TopicSubscriber ts, PubSubData op, SubscriptionPreferences preferences,\n-        Channel channel) {\n-        return new ActiveSubscriber(cfg, channelManager, ts, op, preferences, channel);\n+        Channel channel, HChannel hChannel) {\n+        return new ActiveSubscriber(cfg, channelManager, ts, op, preferences, channel, hChannel);\n     }\n \n     @Override\n@@ -129,33 +130,30 @@ public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n                 }\n             }\n \n-            ActiveSubscriber ss = createActiveSubscriber(cfg, aChannelManager, ts,\n-                                                         pubSubData, preferences, channel);\n-            boolean success = false;\n+            Either<StatusCode, HChannel> result;\n+            StatusCode statusCode;\n+            ActiveSubscriber ss = null;\n             // Store the Subscribe state\n             disconnectLock.readLock().lock();\n             try {\n-                ActiveSubscriber oldSS = subscriptions.putIfAbsent(ts, ss);\n-                if (null != oldSS) {\n-                    logger.warn(\"Subscribe {} has existed in channel {}.\",\n-                                va(ts, channel));\n-                    success = false;\n-                } else {\n-                    logger.debug(\"Succeed to add subscription {} in channel {}.\",\n-                                 va(ts, channel));\n-                    success = true;\n+                result = handleSuccessResponse(ts, pubSubData, channel);\n+                statusCode = result.left();\n+                if (StatusCode.SUCCESS == statusCode) {\n+                    ss = createActiveSubscriber(\n+                        cfg, aChannelManager, ts, pubSubData, preferences, channel, result.right());\n+                    statusCode = addSubscription(ts, ss);\n                 }\n             } finally {\n                 disconnectLock.readLock().unlock();\n             }\n-            if (success) {\n-                handleSuccessResponse(ts, ss, channel);\n+            if (StatusCode.SUCCESS == statusCode) {\n+                postHandleSuccessResponse(ts, ss);\n                 // Response was success so invoke the callback's operationFinished\n                 // method.\n                 pubSubData.getCallback().operationFinished(pubSubData.context, null);\n             } else {\n-                ClientAlreadySubscribedException exception =\n-                    new ClientAlreadySubscribedException(\"Client is already subscribed for \" + ts);\n+                PubSubException exception = PubSubException.create(statusCode,\n+                    \"Client is already subscribed for \" + ts);\n                 pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n             }\n             break;\n@@ -195,13 +193,27 @@ public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n      *\n      * @param ts\n      *          Topic Subscriber.\n-     * @param ss\n-     *          Active Subscriber Object handle subscription actions for the subscriber.\n+     * @param pubSubData\n+     *          Pub/Sub Request data for this subscribe request.\n      * @param channel\n      *          Subscription Channel.\n+     * @return status code to indicate what happened\n      */\n-    protected abstract void handleSuccessResponse(TopicSubscriber ts, ActiveSubscriber as,\n-                                                  Channel channel);\n+    protected abstract Either<StatusCode, HChannel> handleSuccessResponse(\n+        TopicSubscriber ts, PubSubData pubSubData, Channel channel);\n+\n+    protected void postHandleSuccessResponse(TopicSubscriber ts, ActiveSubscriber ss) {\n+        // do nothing now\n+    }\n+\n+    private StatusCode addSubscription(TopicSubscriber ts, ActiveSubscriber ss) {\n+        ActiveSubscriber oldSS = subscriptions.putIfAbsent(ts, ss);\n+        if (null != oldSS) {\n+            return StatusCode.CLIENT_ALREADY_SUBSCRIBED;\n+        } else {\n+            return StatusCode.SUCCESS;\n+        }\n+    }\n \n     @Override\n     public void handleSubscribeMessage(PubSubResponse response) {"},{"sha":"aac132101af4ce3be8e0226ddd238cbf4804b6af","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -34,6 +34,7 @@\n import org.apache.hedwig.client.data.PubSubData;\n import org.apache.hedwig.client.data.TopicSubscriber;\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.netty.HChannel;\n import org.apache.hedwig.client.netty.NetUtils;\n import org.apache.hedwig.client.netty.FilterableMessageHandler;\n import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n@@ -64,6 +65,7 @@\n \n     // the underlying netty channel to send request\n     protected final Channel channel;\n+    protected final HChannel hChannel;\n \n     // Counter for the number of consumed messages so far to buffer up before we\n     // send the Consume message back to the server along with the last/largest\n@@ -99,13 +101,15 @@ public ActiveSubscriber(ClientConfiguration cfg,\n                             AbstractHChannelManager channelManager,\n                             TopicSubscriber ts, PubSubData op,\n                             SubscriptionPreferences preferences,\n-                            Channel channel) {\n+                            Channel channel,\n+                            HChannel hChannel) {\n         this.cfg = cfg;\n         this.channelManager = channelManager;\n         this.topicSubscriber = ts;\n         this.op = op;\n         this.preferences = preferences;\n         this.channel = channel;\n+        this.hChannel = hChannel;\n     }\n \n     /**\n@@ -368,6 +372,7 @@ public void resubscribeIfNecessary(SubscriptionEvent event) {\n                                     channelManager, retryWaitTime);\n         op.setCallback(resubscribeCb);\n         op.context = null;\n+        op.setOriginalChannelForResubscribe(hChannel);\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Resubscribe {} with origSubData {}\",\n                          va(topicSubscriber, op));"},{"sha":"4774d4110869f78d886fa24ac5005e5229d07af4","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -25,6 +25,7 @@\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ResubscribeException;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.util.Callback;\n import static org.apache.hedwig.util.VarArgs.va;\n@@ -77,6 +78,12 @@ public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n \n     @Override\n     public void operationFailed(Object ctx, PubSubException exception) {\n+        if (exception instanceof ResubscribeException) {\n+            // it might be caused by closesub when resubscribing.\n+            // so we don't need to retry resubscribe again\n+            logger.warn(\"Failed to resubscribe {} : but it is caused by closesub when resubscribing. \"\n+                        + \"so we don't need to retry subscribe again.\", origSubData);\n+        }\n         // If the resubscribe fails, just keep retrying the subscribe\n         // request. There isn't a way to flag to the application layer that\n         // a topic subscription has failed. So instead, we'll just keep"},{"sha":"f28a6b27fd21ccf9fb12fd665761c4be2ee02138","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -48,6 +48,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n import static org.apache.hedwig.util.VarArgs.va;\n \n \n@@ -61,6 +62,9 @@\n     // Find which HChannel that a given TopicSubscriber used.\n     protected final CleanupChannelMap<InetSocketAddress> subscriptionChannels;\n \n+    // A index map for each topic subscriber is served by which subscription channel\n+    protected final CleanupChannelMap<TopicSubscriber> sub2Channels;\n+\n     // Concurrent Map to store Message handler for each topic + sub id combination.\n     // Store it here instead of in SubscriberResponseHandler as we don't want to lose the handler\n     // user set when connection is recovered\n@@ -74,6 +78,7 @@ public MultiplexHChannelManager(ClientConfiguration cfg,\n                                     ChannelFactory socketFactory) {\n         super(cfg, socketFactory);\n         subscriptionChannels = new CleanupChannelMap<InetSocketAddress>();\n+        sub2Channels = new CleanupChannelMap<TopicSubscriber>();\n         subscriptionChannelPipelineFactory =\n             new MultiplexSubscriptionChannelPipelineFactory(cfg, this);\n     }\n@@ -296,4 +301,19 @@ protected void closeSubscriptionChannels() {\n         subscriptionChannels.close();\n     }\n \n+    protected Either<Boolean, HChannel> storeSubscriptionChannel(\n+        TopicSubscriber topicSubscriber, PubSubData txn, HChannel channel) {\n+        boolean replaced = sub2Channels.replaceChannel(\n+            topicSubscriber, txn.getOriginalChannelForResubscribe(), channel);\n+        if (replaced) {\n+            return Either.of(replaced, channel);\n+        } else {\n+            return Either.of(replaced, null);\n+        }\n+    }\n+\n+    protected boolean removeSubscriptionChannel(\n+        TopicSubscriber topicSubscriber, HChannel channel) {\n+        return sub2Channels.removeChannel(topicSubscriber, channel);\n+    }\n }"},{"sha":"ec111da1fa33b01fe0a1ed3cfda951899f2eb2c8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","status":"modified","additions":22,"deletions":3,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -36,7 +36,9 @@\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n import static org.apache.hedwig.util.VarArgs.va;\n \n public class MultiplexSubscribeResponseHandler extends AbstractSubscribeResponseHandler {\n@@ -72,9 +74,25 @@ public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n     }\n \n     @Override\n-    protected void handleSuccessResponse(TopicSubscriber ts, ActiveSubscriber as,\n-                                         Channel channel) {\n-        // do nothing now\n+    protected Either<StatusCode, HChannel> handleSuccessResponse(\n+        TopicSubscriber ts, PubSubData pubSubData, Channel channel) {\n+        // Store the mapping for the TopicSubscriber to the Channel.\n+        // This is so we can control the starting and stopping of\n+        // message deliveries from the server on that Channel. Store\n+        // this only on a successful ack response from the server.\n+        Either<Boolean, HChannel> result =\n+            sChannelManager.storeSubscriptionChannel(ts, pubSubData, hChannel);\n+        if (result.left()) {\n+            return Either.of(StatusCode.SUCCESS, result.right());\n+        } else {\n+            StatusCode code;\n+            if (pubSubData.isResubscribeRequest()) {\n+                code = StatusCode.RESUBSCRIBE_EXCEPTION;\n+            } else {\n+                code = StatusCode.CLIENT_ALREADY_SUBSCRIBED;\n+            }\n+            return Either.of(code, null);\n+        }\n     }\n \n     @Override\n@@ -92,6 +110,7 @@ public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n             @Override\n             public void operationFinished(Object ctx, ResponseBody respBody) {\n                 removeSubscription(topicSubscriber, ss);\n+                sChannelManager.removeSubscriptionChannel(topicSubscriber, hChannel);\n                 callback.operationFinished(context, null);\n             }\n "},{"sha":"0734e229f98db76da630eb51f803a65c92a6a66f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","status":"modified","additions":11,"deletions":4,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -31,10 +31,10 @@\n import org.apache.hedwig.client.api.MessageHandler;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.data.PubSubData;\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n-\n import org.apache.hedwig.client.netty.CleanupChannelMap;\n import org.apache.hedwig.client.netty.HChannel;\n import org.apache.hedwig.client.netty.NetUtils;\n@@ -48,6 +48,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n import static org.apache.hedwig.util.VarArgs.va;\n \n /**\n@@ -103,12 +104,18 @@ protected HChannel createAndStoreSubscriptionChannel(InetSocketAddress host) {\n                                 getSubscriptionChannelPipelineFactory());\n     }\n \n-    protected HChannel storeSubscriptionChannel(TopicSubscriber topicSubscriber,\n-                                                Channel channel) {\n+    protected Either<Boolean, HChannel> storeSubscriptionChannel(\n+        TopicSubscriber topicSubscriber, PubSubData txn, Channel channel) {\n         InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n         HChannel newHChannel = new HChannelImpl(host, channel, this,\n                                                 getSubscriptionChannelPipelineFactory());\n-        return topicSubscriber2Channel.addChannel(topicSubscriber, newHChannel);\n+        boolean replaced = topicSubscriber2Channel.replaceChannel(\n+            topicSubscriber, txn.getOriginalChannelForResubscribe(), newHChannel);\n+        if (replaced) {\n+            return Either.of(replaced, newHChannel);\n+        } else {\n+            return Either.of(replaced, null);\n+        }\n     }\n \n     @Override"},{"sha":"7dd320ced43b6e28e54ca1ccd7d2d247cf04affe","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","status":"modified","additions":29,"deletions":35,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -36,6 +36,7 @@\n import org.apache.hedwig.client.data.TopicSubscriber;\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.HChannel;\n import org.apache.hedwig.client.netty.HChannelManager;\n import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n import org.apache.hedwig.client.netty.impl.AbstractSubscribeResponseHandler;\n@@ -51,6 +52,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n import org.apache.hedwig.protoextensions.MessageIdUtils;\n import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n \n public class SimpleSubscribeResponseHandler extends AbstractSubscribeResponseHandler {\n \n@@ -73,8 +75,9 @@ public SimpleActiveSubscriber(ClientConfiguration cfg,\n                                       AbstractHChannelManager channelManager,\n                                       TopicSubscriber ts, PubSubData op,\n                                       SubscriptionPreferences preferences,\n-                                      Channel channel) {\n-            super(cfg, channelManager, ts, op, preferences, channel);\n+                                      Channel channel,\n+                                      HChannel hChannel) {\n+            super(cfg, channelManager, ts, op, preferences, channel, hChannel);\n             outstandingMsgSet = Collections.newSetFromMap(\n                     new ConcurrentHashMap<Message, Boolean>(\n                             cfg.getMaximumOutstandingMessages(), 1.0f));\n@@ -175,8 +178,8 @@ protected SimpleSubscribeResponseHandler(ClientConfiguration cfg,\n     protected ActiveSubscriber createActiveSubscriber(\n         ClientConfiguration cfg, AbstractHChannelManager channelManager,\n         TopicSubscriber ts, PubSubData op, SubscriptionPreferences preferences,\n-        Channel channel) {\n-        return new SimpleActiveSubscriber(cfg, channelManager, ts, op, preferences, channel);\n+        Channel channel, HChannel hChannel) {\n+        return new SimpleActiveSubscriber(cfg, channelManager, ts, op, preferences, channel, hChannel);\n     }\n \n     @Override\n@@ -234,17 +237,32 @@ public void handleSubscribeMessage(PubSubResponse response) {\n     }\n \n     @Override\n-    protected void handleSuccessResponse(TopicSubscriber ts, ActiveSubscriber as,\n-                                         Channel channel) {\n-        synchronized (this) {\n-            origTopicSubscriber = ts;\n-            origActiveSubscriber = as;\n-        }\n+    protected Either<StatusCode, HChannel> handleSuccessResponse(\n+        TopicSubscriber ts, PubSubData pubSubData, Channel channel) {\n         // Store the mapping for the TopicSubscriber to the Channel.\n         // This is so we can control the starting and stopping of\n         // message deliveries from the server on that Channel. Store\n         // this only on a successful ack response from the server.\n-        sChannelManager.storeSubscriptionChannel(ts, channel);\n+        Either<Boolean, HChannel> result =\n+            sChannelManager.storeSubscriptionChannel(ts, pubSubData, channel);\n+        if (result.left()) {\n+            return Either.of(StatusCode.SUCCESS, result.right());\n+        } else {\n+            StatusCode code;\n+            if (pubSubData.isResubscribeRequest()) {\n+                code = StatusCode.RESUBSCRIBE_EXCEPTION;\n+            } else {\n+                code = StatusCode.CLIENT_ALREADY_SUBSCRIBED;\n+            }\n+            return Either.of(code, null);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void postHandleSuccessResponse(\n+        TopicSubscriber ts, ActiveSubscriber as) {\n+        origTopicSubscriber = ts;\n+        origActiveSubscriber = as;\n     }\n \n     @Override\n@@ -256,28 +274,4 @@ public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n         callback.operationFinished(context, (ResponseBody)null);\n     }\n \n-    @Override\n-    protected void resubscribeIfNecessary(final ActiveSubscriber ss,\n-                                          final SubscriptionEvent event) {\n-        final TopicSubscriber ts = ss.getTopicSubscriber();\n-        // clear subscription status\n-        sChannelManager.asyncCloseSubscription(ts, new Callback<ResponseBody>() {\n-\n-            @Override\n-            public void operationFinished(Object ctx, ResponseBody result) {\n-                finish();\n-            }\n-\n-            @Override\n-            public void operationFailed(Object ctx, PubSubException exception) {\n-                finish();\n-            }\n-\n-            private void finish() {\n-                SimpleSubscribeResponseHandler.super.resubscribeIfNecessary(ss, event);\n-            }\n-\n-        }, null);\n-    }\n-\n }"},{"sha":"8bd2763c99944c478e5a35175aaf43c9c9e8f23f","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -74,6 +74,8 @@ public static PubSubException create(StatusCode code, String msg) {\n             return new TopicOwnerInfoExistsException(msg);\n         } else if (code == StatusCode.INVALID_MESSAGE_FILTER) {\n             return new InvalidMessageFilterException(msg);\n+        } else if (code == StatusCode.RESUBSCRIBE_EXCEPTION) {\n+            return new ResubscribeException(msg);\n         }\n         /*\n          * Insert new ones here\n@@ -103,6 +105,12 @@ public ClientNotSubscribedException(String msg) {\n         }\n     }\n \n+    public static class ResubscribeException extends PubSubException {\n+        public ResubscribeException(String msg) {\n+            super(StatusCode.RESUBSCRIBE_EXCEPTION, msg);\n+        }\n+    }\n+\n     public static class MalformedRequestException extends PubSubException {\n         public MalformedRequestException(String msg) {\n             super(StatusCode.MALFORMED_REQUEST, msg);"},{"sha":"4bba8cc849c1e10354c7e022f94b23e6a2e88d4f","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":29,"deletions":25,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -236,19 +236,20 @@ private SubscriptionEvent(int index, int value) {\n     CLIENT_NOT_SUBSCRIBED(4, 404),\n     COULD_NOT_CONNECT(5, 405),\n     TOPIC_BUSY(6, 406),\n-    NOT_RESPONSIBLE_FOR_TOPIC(7, 501),\n-    SERVICE_DOWN(8, 502),\n-    UNCERTAIN_STATE(9, 503),\n-    INVALID_MESSAGE_FILTER(10, 504),\n-    BAD_VERSION(11, 520),\n-    NO_TOPIC_PERSISTENCE_INFO(12, 521),\n-    TOPIC_PERSISTENCE_INFO_EXISTS(13, 522),\n-    NO_SUBSCRIPTION_STATE(14, 523),\n-    SUBSCRIPTION_STATE_EXISTS(15, 524),\n-    NO_TOPIC_OWNER_INFO(16, 525),\n-    TOPIC_OWNER_INFO_EXISTS(17, 526),\n-    UNEXPECTED_CONDITION(18, 600),\n-    COMPOSITE(19, 700),\n+    RESUBSCRIBE_EXCEPTION(7, 407),\n+    NOT_RESPONSIBLE_FOR_TOPIC(8, 501),\n+    SERVICE_DOWN(9, 502),\n+    UNCERTAIN_STATE(10, 503),\n+    INVALID_MESSAGE_FILTER(11, 504),\n+    BAD_VERSION(12, 520),\n+    NO_TOPIC_PERSISTENCE_INFO(13, 521),\n+    TOPIC_PERSISTENCE_INFO_EXISTS(14, 522),\n+    NO_SUBSCRIPTION_STATE(15, 523),\n+    SUBSCRIPTION_STATE_EXISTS(16, 524),\n+    NO_TOPIC_OWNER_INFO(17, 525),\n+    TOPIC_OWNER_INFO_EXISTS(18, 526),\n+    UNEXPECTED_CONDITION(19, 600),\n+    COMPOSITE(20, 700),\n     ;\n     \n     public static final int SUCCESS_VALUE = 0;\n@@ -258,6 +259,7 @@ private SubscriptionEvent(int index, int value) {\n     public static final int CLIENT_NOT_SUBSCRIBED_VALUE = 404;\n     public static final int COULD_NOT_CONNECT_VALUE = 405;\n     public static final int TOPIC_BUSY_VALUE = 406;\n+    public static final int RESUBSCRIBE_EXCEPTION_VALUE = 407;\n     public static final int NOT_RESPONSIBLE_FOR_TOPIC_VALUE = 501;\n     public static final int SERVICE_DOWN_VALUE = 502;\n     public static final int UNCERTAIN_STATE_VALUE = 503;\n@@ -284,6 +286,7 @@ public static StatusCode valueOf(int value) {\n         case 404: return CLIENT_NOT_SUBSCRIBED;\n         case 405: return COULD_NOT_CONNECT;\n         case 406: return TOPIC_BUSY;\n+        case 407: return RESUBSCRIBE_EXCEPTION;\n         case 501: return NOT_RESPONSIBLE_FOR_TOPIC;\n         case 502: return SERVICE_DOWN;\n         case 503: return UNCERTAIN_STATE;\n@@ -327,7 +330,7 @@ public StatusCode findValueByNumber(int number) {\n     }\n     \n     private static final StatusCode[] VALUES = {\n-      SUCCESS, MALFORMED_REQUEST, NO_SUCH_TOPIC, CLIENT_ALREADY_SUBSCRIBED, CLIENT_NOT_SUBSCRIBED, COULD_NOT_CONNECT, TOPIC_BUSY, NOT_RESPONSIBLE_FOR_TOPIC, SERVICE_DOWN, UNCERTAIN_STATE, INVALID_MESSAGE_FILTER, BAD_VERSION, NO_TOPIC_PERSISTENCE_INFO, TOPIC_PERSISTENCE_INFO_EXISTS, NO_SUBSCRIPTION_STATE, SUBSCRIPTION_STATE_EXISTS, NO_TOPIC_OWNER_INFO, TOPIC_OWNER_INFO_EXISTS, UNEXPECTED_CONDITION, COMPOSITE, \n+      SUCCESS, MALFORMED_REQUEST, NO_SUCH_TOPIC, CLIENT_ALREADY_SUBSCRIBED, CLIENT_NOT_SUBSCRIBED, COULD_NOT_CONNECT, TOPIC_BUSY, RESUBSCRIBE_EXCEPTION, NOT_RESPONSIBLE_FOR_TOPIC, SERVICE_DOWN, UNCERTAIN_STATE, INVALID_MESSAGE_FILTER, BAD_VERSION, NO_TOPIC_PERSISTENCE_INFO, TOPIC_PERSISTENCE_INFO_EXISTS, NO_SUBSCRIPTION_STATE, SUBSCRIPTION_STATE_EXISTS, NO_TOPIC_OWNER_INFO, TOPIC_OWNER_INFO_EXISTS, UNEXPECTED_CONDITION, COMPOSITE, \n     };\n     \n     public static StatusCode valueOf(\n@@ -16621,21 +16624,22 @@ public Builder clearNumTopics() {\n       \"\\013UNSUBSCRIBE\\020\\003\\022\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rST\" +\n       \"OP_DELIVERY\\020\\005\\022\\025\\n\\021CLOSESUBSCRIPTION\\020\\006*D\\n\\021\" +\n       \"SubscriptionEvent\\022\\017\\n\\013TOPIC_MOVED\\020\\001\\022\\036\\n\\032SU\" +\n-      \"BSCRIPTION_FORCED_CLOSED\\020\\002*\\205\\004\\n\\nStatusCod\" +\n+      \"BSCRIPTION_FORCED_CLOSED\\020\\002*\\241\\004\\n\\nStatusCod\" +\n       \"e\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\" +\n       \"\\n\\rNO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUB\" +\n       \"SCRIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\",\n       \"\\n\\021COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\" +\n-      \"\\036\\n\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVI\" +\n-      \"CE_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026INVA\" +\n-      \"LID_MESSAGE_FILTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\" +\n-      \"\\036\\n\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC\" +\n-      \"_PERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCR\" +\n-      \"IPTION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EX\" +\n-      \"ISTS\\020\\214\\004\\022\\030\\n\\023NO_TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027TOP\" +\n-      \"IC_OWNER_INFO_EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_CO\" +\n-      \"NDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apache\",\n-      \".hedwig.protocolH\\001\"\n+      \"\\032\\n\\025RESUBSCRIBE_EXCEPTION\\020\\227\\003\\022\\036\\n\\031NOT_RESPO\" +\n+      \"NSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVICE_DOWN\\020\\366\\003\\022\\024\" +\n+      \"\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026INVALID_MESSAGE_\" +\n+      \"FILTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\\036\\n\\031NO_TOPIC_\" +\n+      \"PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC_PERSISTENCE\" +\n+      \"_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCRIPTION_STATE\" +\n+      \"\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EXISTS\\020\\214\\004\\022\\030\\n\\023N\" +\n+      \"O_TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027TOPIC_OWNER_INF\" +\n+      \"O_EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_CONDITION\\020\\330\\004\\022\\016\",\n+      \"\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apache.hedwig.prot\" +\n+      \"ocolH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {"},{"sha":"c31f0a6986d0a7c93ceecf249f461c0d115fcd70","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -248,6 +248,7 @@ enum StatusCode{\n     CLIENT_NOT_SUBSCRIBED = 404;\n     COULD_NOT_CONNECT = 405;\n     TOPIC_BUSY = 406;\n+    RESUBSCRIBE_EXCEPTION = 407;\n     \n     //server-side errors (5xx)\n     NOT_RESPONSIBLE_FOR_TOPIC = 501;"},{"sha":"8b2c7a804e8ebef29eb70a952b7c6a53c26f53c2","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"modified","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -605,4 +605,64 @@ public boolean isSubscriptionChannelSharingEnabled() {\n         assertEquals(SubscriptionEvent.TOPIC_MOVED, eventQueue.take());\n     }\n \n+    @Test\n+    public void testCloseSubscribeDuringResubscribe() throws Exception {\n+        client.close();\n+\n+        final long reconnectWaitTime = 2000L;\n+        client = new HedwigClient(new ClientConfiguration() {\n+            @Override\n+            public HedwigSocketAddress getDefaultServerHedwigSocketAddress() {\n+                return getDefaultHedwigAddress();\n+            }\n+\n+            @Override\n+            public boolean isSubscriptionChannelSharingEnabled() {\n+                return TestPubSubClient.this.isSubscriptionChannelSharingEnabled;\n+            }\n+\n+            @Override\n+            public long getSubscribeReconnectRetryWaitTime() {\n+                return reconnectWaitTime;\n+            }\n+        });\n+\n+        publisher = client.getPublisher();\n+        subscriber = client.getSubscriber();\n+\n+        ByteString topic = ByteString.copyFromUtf8(\"testCloseSubscribeDuringResubscribe\");\n+        ByteString subscriberId = ByteString.copyFromUtf8(\"mysub\");\n+        subscriber.addSubscriptionListener(new TestSubscriptionListener());\n+        SubscriptionOptions options =\n+            SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH)\n+            .setForceAttach(false).setEnableResubscribe(true).build();\n+        subscriber.subscribe(topic, subscriberId, options);\n+        logger.info(\"Subscribed topic {}, subscriber {}.\", topic.toStringUtf8(),\n+                    subscriberId.toStringUtf8());\n+        subscriber.startDelivery(topic, subscriberId, new TestMessageHandler());\n+\n+        // tear down the hub server to let subscribe enter\n+        tearDownHubServer();\n+        logger.info(\"Tear down the hub server\");\n+\n+        // wait for client enter to resubscribe logic\n+        Thread.sleep(reconnectWaitTime / 2);\n+\n+        // close sub\n+        subscriber.closeSubscription(topic, subscriberId);\n+\n+        // start the hub server again\n+        startHubServer(conf);\n+\n+        // publish a new message\n+        publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #1\")).build(),\n+                               new TestCallback(), null);\n+        assertTrue(queue.take());\n+\n+        // wait for another reconnect time period\n+        assertNull(\"Should not receive any messages since the subscription has already been closed.\",\n+                   consumeQueue.poll(reconnectWaitTime + reconnectWaitTime / 2, TimeUnit.MILLISECONDS));\n+    }\n+\n }"},{"sha":"7e57be2fe06808ee72e49706bc2d6f11cb829edb","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","status":"modified","additions":3,"deletions":8,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java?ref=a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","patch":"@@ -64,13 +64,15 @@ public ServerConfiguration getStandAloneServerConfiguration() {\n     }\n \n     protected PubSubServer server;\n+    protected ServerConfiguration conf;\n     protected HedwigSocketAddress defaultAddress;\n \n     @Override\n     @Before\n     public void setUp() throws Exception {\n         logger.info(\"STARTING \" + getName());\n-        startHubServer();\n+        conf = getStandAloneServerConfiguration();\n+        startHubServer(conf);\n         logger.info(\"Standalone PubSubServer test setup finished\");\n     }\n \n@@ -83,13 +85,6 @@ public void tearDown() throws Exception {\n         logger.info(\"FINISHED \" + getName());\n     }\n \n-    protected void startHubServer() throws Exception {\n-        ServerConfiguration conf = getStandAloneServerConfiguration();\n-        defaultAddress = new HedwigSocketAddress(\"localhost\", conf.getServerPort(),\n-                                                 conf.getSSLServerPort());\n-        startHubServer(conf);\n-    }\n-\n     protected HedwigSocketAddress getDefaultHedwigAddress() {\n         return defaultAddress;\n     }"}]}

