{"sha":"a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","node_id":"MDY6Q29tbWl0MTU3NTk1NjphM2M5Yzk1M2RiNDliYzFlYzNkNzJmMDEyMTJlNmNiY2Q1OGNjNWQz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:49:10Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:49:10Z"},"message":"BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241858 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0f35da1b4e5785c402908d9172cd9baaf3246559","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0f35da1b4e5785c402908d9172cd9baaf3246559"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","html_url":"https://github.com/apache/bookkeeper/commit/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"bd2efa12f1f63afa90723ce405caebafb4afd6be","url":"https://api.github.com/repos/apache/bookkeeper/commits/bd2efa12f1f63afa90723ce405caebafb4afd6be","html_url":"https://github.com/apache/bookkeeper/commit/bd2efa12f1f63afa90723ce405caebafb4afd6be"}],"stats":{"total":2313,"additions":2312,"deletions":1},"files":[{"sha":"339ca415314bd9e596e4aae4be9d2e14c9ced214","filename":"CHANGES.txt","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -37,7 +37,6 @@ Trunk (unreleased changes)\n         BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)\n \n         BOOKKEEPER-133: Hub server should update subscription state to zookeeper when losing topic or shutting down (Sijie Gou via ivank)\n-\n     IMPROVEMENTS:\n \n       bookkeeper-server/\n@@ -48,6 +47,9 @@ Trunk (unreleased changes)\n \n \tBOOKKEEPER-157:\tFor small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n \n+      hedwig-server/\n+\n+        BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n \n Release 4.0.0 - 2011-11-30\n "},{"sha":"b269485678c670691f930429af98050e7013bbb6","filename":"hedwig-server/bin/hedwig","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/bin/hedwig","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/bin/hedwig","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/bin/hedwig?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -34,6 +34,8 @@ HW_HOME=`cd $BINDIR/..;pwd`\n \n DEFAULT_CONF=$HW_HOME/conf/hw_server.conf\n \n+. $HW_HOME/conf/hwenv.sh\n+\n RELEASE_JAR=`ls $HW_HOME/hedwig-server-*.jar 2> /dev/null | tail -1`\n if [ $? == 0 ]; then\n     HEDWIG_JAR=$RELEASE_JAR\n@@ -78,6 +80,7 @@ hedwig_help() {\n Usage: hedwig <command>\n where command is one of:\n     server           Run the hedwig server\n+    console          Run the hedwig admin console\n     help             This help message\n \n or command is the full name of a class with a defined main() method.\n@@ -118,6 +121,8 @@ OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n \n if [ $COMMAND == \"server\" ]; then\n     exec java $OPTS org.apache.hedwig.server.netty.PubSubServer $HEDWIG_SERVER_CONF $@\n+elif [ $COMMAND == \"console\" ]; then\n+    exec java $OPTS org.apache.hedwig.admin.console.HedwigConsole -server-cfg $HEDWIG_SERVER_CONF $@\n elif [ $COMMAND == \"help\" ]; then\n     hedwig_help;\n else"},{"sha":"12c8ebaf28c994bca2d0466ba58353e8ccf88b5e","filename":"hedwig-server/pom.xml","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/pom.xml?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -110,6 +110,11 @@\n \t</exclusion>\n       </exclusions>\n     </dependency>\n+    <dependency>\n+      <groupId>jline</groupId>\n+      <artifactId>jline</artifactId>\n+      <version>0.9.94</version>\n+    </dependency>\n   </dependencies>\n   <build>\n     <plugins>"},{"sha":"284589072de3a0bcd9da2850859bb9d6eb674ebe","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","status":"added","additions":397,"deletions":0,"changes":397,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -0,0 +1,397 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+/**\n+ * Hedwig Admin\n+ */\n+public class HedwigAdmin {\n+    static final Logger LOG = LoggerFactory.getLogger(HedwigAdmin.class);\n+\n+    // NOTE: now it is fixed passwd used in hedwig\n+    static byte[] passwd = \"sillysecret\".getBytes();\n+\n+    protected ZooKeeper zk;\n+    protected BookKeeper bk;\n+    // hub configurations\n+    protected ServerConfiguration serverConf;\n+    // bookkeeper configurations\n+    protected ClientConfiguration bkClientConf;\n+\n+    // Empty watcher\n+    private class MyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+        }\n+    }\n+\n+    /**\n+     * Hedwig Admin Constructor\n+     *\n+     * @param bkConf\n+     *          BookKeeper Client Configuration.\n+     * @param hubConf\n+     *          Hub Server Configuration.\n+     * @throws Exception\n+     */\n+    public HedwigAdmin(ClientConfiguration bkConf, ServerConfiguration hubConf) throws Exception {\n+        this.serverConf = hubConf;\n+        this.bkClientConf = bkConf;\n+\n+        // connect to zookeeper\n+        zk = new ZooKeeper(bkClientConf.getZkServers(), bkClientConf.getZkTimeout(), new MyWatcher());\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Connecting to zookeeper \" + bkClientConf.getZkServers() + \", timeout = \"\n+                    + bkClientConf.getZkTimeout());\n+        }\n+\n+        // connect to bookkeeper\n+        bk = new BookKeeper(bkClientConf, zk);\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Connecting to bookkeeper\");\n+        }\n+    }\n+\n+    /**\n+     * Close the hedwig admin.\n+     *\n+     * @throws Exception\n+     */\n+    public void close() throws Exception {\n+        bk.close();\n+        zk.close();\n+    }\n+\n+    /**\n+     * Return zookeeper handle used in hedwig admin.\n+     *\n+     * @return zookeeper handle\n+     */\n+    public ZooKeeper getZkHandle() {\n+        return zk;\n+    }\n+\n+    /**\n+     * Return bookkeeper handle used in hedwig admin.\n+     *\n+     * @return bookkeeper handle\n+     */\n+    public BookKeeper getBkHandle() {\n+        return bk;\n+    }\n+\n+    /**\n+     * Return hub server configuration used in hedwig admin\n+     *\n+     * @return hub server configuration\n+     */\n+    public ServerConfiguration getHubServerConf() {\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Return bookeeper passwd used in hedwig admin\n+     *\n+     * @return bookeeper passwd\n+     */\n+    public byte[] getBkPasswd() {\n+        return passwd;\n+    }\n+\n+    /**\n+     * Return digest type used in hedwig admin\n+     *\n+     * @return bookeeper digest type\n+     */\n+    public DigestType getBkDigestType() {\n+        return DigestType.CRC32;\n+    }\n+\n+    /**\n+     * Dose topic exist?\n+     *\n+     * @param topic\n+     *            Topic name\n+     * @return whether topic exists or not?\n+     * @throws Exception\n+     */\n+    public boolean hasTopic(ByteString topic) throws Exception {\n+        String topicPath = serverConf.getZkTopicPath(new StringBuilder(), topic).toString();\n+        Stat stat = zk.exists(topicPath, false);\n+        return null != stat;\n+    }\n+\n+    /**\n+     * Get available hubs.\n+     *\n+     * @return available hubs and their loads\n+     * @throws Exception\n+     */\n+    public Map<HedwigSocketAddress, Integer> getAvailableHubs() throws Exception {\n+        String zkHubsPath = serverConf.getZkHostsPrefix(new StringBuilder()).toString();\n+        Map<HedwigSocketAddress, Integer> hubs =\n+            new HashMap<HedwigSocketAddress, Integer>();\n+        List<String> hosts = zk.getChildren(zkHubsPath, false);\n+        for (String host : hosts) {\n+            String zkHubPath = serverConf.getZkHostsPrefix(new StringBuilder())\n+                                         .append(\"/\").append(host).toString();\n+            int load = 0;\n+            try {\n+                Stat stat = new Stat();\n+                byte[] data = zk.getData(zkHubPath, false, stat);\n+                if (data != null) {\n+                    load = Integer.parseInt(new String(data));\n+                }\n+            } catch (Exception e) {\n+                // igore\n+            }\n+            hubs.put(new HedwigSocketAddress(host), load);\n+        }\n+        return hubs;\n+    }\n+\n+    /**\n+     * Get list of topics\n+     *\n+     * @return list of topics\n+     * @throws Exception\n+     */\n+    public List<String> getTopics() throws Exception {\n+        return zk.getChildren(serverConf.getZkTopicsPrefix(new StringBuilder()).toString(), false);\n+    }\n+\n+    /**\n+     * Return the znode path of owner of a topic\n+     *\n+     * @param topic\n+     *            Topic name\n+     * @return znode path of owner of a topic\n+     */\n+    String hubPath(ByteString topic) {\n+        return serverConf.getZkTopicPath(new StringBuilder(), topic).append(\"/hub\").toString();\n+    }\n+\n+    /**\n+     * Return the topic owner of a topic\n+     *\n+     * @param topic\n+     *            Topic name\n+     * @return the address of the owner of a topic\n+     * @throws Exception\n+     */\n+    public HedwigSocketAddress getTopicOwner(ByteString topic) throws Exception {\n+        Stat stat = new Stat();\n+        byte[] owner = null;\n+        try {\n+            owner = zk.getData(hubPath(topic), false, stat);\n+        } catch (KeeperException.NoNodeException nne) {\n+        }\n+        if (null == owner) {\n+            return null;\n+        }\n+        return new HedwigSocketAddress(new String(owner));\n+    }\n+\n+    /**\n+     * Return the znode path to store ledgers info of a topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @return znode path to store ledgers info of a topic\n+     */\n+    String ledgersPath(ByteString topic) {\n+        return serverConf.getZkTopicPath(new StringBuilder(), topic).append(\"/ledgers\").toString();\n+    }\n+\n+    /**\n+     * Return the ledger range forming the topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @return ledger ranges forming the topic\n+     * @throws Exception\n+     */\n+    public List<LedgerRange> getTopicLedgers(ByteString topic) throws Exception {\n+        LedgerRanges ranges = null;\n+        try {\n+            Stat stat = new Stat();\n+            byte[] ledgersData = zk.getData(ledgersPath(topic), false, stat);\n+            if (null != ledgersData) {\n+                ranges = LedgerRanges.parseFrom(ledgersData);\n+            }\n+        } catch (KeeperException.NoNodeException nne) {\n+        }\n+        if (null == ranges) {\n+            return null;\n+        }\n+        List<LedgerRange> lrs = ranges.getRangesList();\n+        if (lrs.isEmpty()) {\n+            return lrs;\n+        }\n+        // try to check last ledger (it may still open)\n+        LedgerRange lastRange = lrs.get(lrs.size() - 1);\n+        if (lastRange.hasEndSeqIdIncluded()) {\n+            return lrs;\n+        }\n+        // read last confirmed of the opened ledger\n+        try {\n+            List<LedgerRange> newLrs = new ArrayList<LedgerRange>();\n+            newLrs.addAll(lrs);\n+            lrs = newLrs;\n+            MessageSeqId lastSeqId;\n+            if (lrs.size() == 1) {\n+                lastSeqId = MessageSeqId.newBuilder().setLocalComponent(1).build();\n+            } else {\n+                lastSeqId = lrs.get(lrs.size() - 2).getEndSeqIdIncluded();\n+            }\n+            LedgerRange newLastRange = refreshLastLedgerRange(lastSeqId, lastRange);\n+            lrs.set(lrs.size() - 1, newLastRange);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        return lrs;\n+    }\n+\n+    /**\n+     * Refresh last ledger range to get lastConfirmed entry, which make it available to read\n+     *\n+     * @param lastSeqId\n+     *            Last sequence id of previous ledger\n+     * @param oldRange\n+     *            Ledger range to set lastConfirmed entry\n+     */\n+    LedgerRange refreshLastLedgerRange(MessageSeqId lastSeqId, LedgerRange oldRange)\n+        throws BKException, KeeperException, InterruptedException {\n+        LedgerHandle lh = bk.openLedgerNoRecovery(oldRange.getLedgerId(), DigestType.CRC32, passwd);\n+        long lastConfirmed = lh.readLastConfirmed();\n+        MessageSeqId newSeqId = MessageSeqId.newBuilder().mergeFrom(lastSeqId)\n+                                .setLocalComponent(lastSeqId.getLocalComponent() + lastConfirmed).build();\n+        return LedgerRange.newBuilder().mergeFrom(oldRange).setEndSeqIdIncluded(newSeqId).build();\n+    }\n+\n+    /**\n+     * Return the znode path store all the subscribers of a topic.\n+     *\n+     * @param sb\n+     *          String builder to hold the znode path\n+     * @param topic\n+     *          Topic name\n+     */\n+    private StringBuilder topicSubscribersPath(StringBuilder sb, ByteString topic) {\n+        return serverConf.getZkTopicPath(sb, topic).append(\"/subscribers\");\n+    }\n+\n+    /**\n+     * Return the znode path of a subscriber of a topic.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriber\n+     *          Subscriber name\n+     */\n+\n+    private String topicSubscriberPath(ByteString topic, ByteString subscriber) {\n+        return topicSubscribersPath(new StringBuilder(), topic).append(\"/\")\n+               .append(subscriber.toStringUtf8()).toString();\n+    }\n+\n+    /**\n+     * Return subscriptions of a topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @return subscriptions of a topic\n+     * @throws Exception\n+     */\n+    public Map<ByteString, SubscriptionState> getTopicSubscriptions(ByteString topic)\n+        throws Exception {\n+        Map<ByteString, SubscriptionState> states =\n+            new HashMap<ByteString, SubscriptionState>();\n+        try {\n+            String subsPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n+            List<String> children = zk.getChildren(subsPath, false);\n+            for (String child : children) {\n+                ByteString subscriberId = ByteString.copyFromUtf8(child);\n+                String subPath = topicSubscriberPath(topic, subscriberId);\n+                Stat stat = new Stat();\n+                byte[] subData = zk.getData(subPath, false, stat);\n+                if (null == subData) {\n+                    continue;\n+                }\n+                SubscriptionState state = SubscriptionState.parseFrom(subData);\n+                states.put(subscriberId, state);\n+            }\n+        } catch (KeeperException.NoNodeException nne) {\n+        }\n+        return states;\n+    }\n+\n+    /**\n+     * Return subscription state of a subscriber of topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriber\n+     *          Subscriber name\n+     * @return subscription state\n+     * @throws Exception\n+     */\n+    public SubscriptionState getSubscription(ByteString topic, ByteString subscriber) throws Exception {\n+        String subPath = topicSubscriberPath(topic, subscriber);\n+        Stat stat = new Stat();\n+        byte[] subData = null;\n+        try {\n+            subData = zk.getData(subPath, false, stat);\n+        } catch (KeeperException.NoNodeException nne) {\n+        }\n+        if (null == subData) {\n+            return null;\n+        }\n+        return SubscriptionState.parseFrom(subData);\n+    }\n+}"},{"sha":"a17f56bec7bd3268494f2e763bf670783efb061b","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","status":"added","additions":424,"deletions":0,"changes":424,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -0,0 +1,424 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.util.Map;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * List all the available commands\n+ */\n+public final class HedwigCommands {\n+\n+    static final String[] EMPTY_ARRAY = new String[0];\n+\n+    //\n+    // List all commands used to play with hedwig\n+    //\n+\n+    /* PUB : publish a message to hedwig */\n+    static final String PUB = \"pub\";\n+    static final String PUB_DESC = \"Publish a message to a topic in Hedwig\";\n+    static final String[] PUB_USAGE = new String[] {\n+        \"usage: pub {topic} {message}\",\n+        \"\",\n+        \"  {topic}   : topic name.\",\n+        \"              any printable string without spaces.\",\n+        \"  {message} : message body.\",\n+        \"              remaining arguments are used as message body to publish.\",\n+    };\n+\n+    /* SUB : subscriber a topic in hedwig for a specified subscriber */\n+    static final String SUB = \"sub\";\n+    static final String SUB_DESC = \"Subscribe a topic for a specified subscriber\";\n+    static final String[] SUB_USAGE = new String[] {\n+        \"usage: sub {topic} {subscriber} [mode]\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"  [mode]       : mode to create subscription.\",\n+        \"  [receive]    : bool. whether to start delivery to receive messages.\",\n+        \"\",\n+        \"  available modes: (default value is 1)\",\n+        \"    0 = CREATE: create subscription.\",\n+        \"                if the subscription is exsited, it will fail.\",\n+        \"    1 = ATTACH: attach to exsited subscription.\",\n+        \"                if the subscription is not existed, it will faile.\",\n+        \"    2 = CREATE_OR_ATTACH:\",\n+        \"                attach to subscription, if not existed create one.\"\n+    };\n+\n+    /* CLOSESUB : close the subscription of a subscriber for a topic */\n+    static final String CLOSESUB = \"closesub\";\n+    static final String CLOSESUB_DESC = \"Close subscription of a subscriber to a specified topic\";\n+    static final String[] CLOSESUB_USAGE = new String[] {\n+        \"usage: closesub {topic} {subscriber}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"\",\n+        \" NOTE: this command just cleanup subscription states on client side.\",\n+        \"       You can try UNSUB to clean subscription states on server side.\",\n+    };\n+\n+    /* UNSUB: unsubscribe of a subscriber to a topic */\n+    static final String UNSUB = \"unsub\";\n+    static final String UNSUB_DESC = \"Unsubscribe a topic for a subscriber\";\n+    static final String[] UNSUB_USAGE = new String[] {\n+        \"usage: unsub {topic} {subscriber}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"\",\n+        \" NOTE: this command will cleanup subscription states on server side.\",\n+        \"       You can try CLOSESUB to just clean subscription states on client side.\",\n+    };\n+\n+    static final String RMSUB = \"rmsub\";\n+    static final String RMSUB_DESC = \"Remove subscriptions for topics\";\n+    static final String[] RMSUB_USAGE = new String[] {\n+        \"usage: rmsub {topic_prefix} {start_topic} {end_topic} {subscriber_prefix} {start_sub} {end_sub}\",\n+        \"\",\n+        \"  {topic_prefix}       : topic prefix.\",\n+        \"  {start_topic}        : start topic id.\",\n+        \"  {end_topic}          : end topic id.\",\n+        \"  {subscriber_prefix}  : subscriber prefix.\",\n+        \"  {start_sub}          : start subscriber id.\",\n+        \"  {end_sub}            : end subscriber id.\",\n+    };\n+\n+    /* CONSUME: move consume ptr of a subscription with specified steps */\n+    static final String CONSUME = \"consume\";\n+    static final String CONSUME_DESC = \"Move consume ptr of a subscription with sepcified steps\";\n+    static final String[] CONSUME_USAGE = new String[] {\n+        \"usage: consume {topic} {subscriber} {nmsgs}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {nmsgs}      : how many messages to move consume ptr.\",\n+        \"\",\n+        \"  Example:\",\n+        \"  suppose, from zk we know subscriber B consumed topic T to message 10\",\n+        \"  [hedwig: (standalone) 1] consume T B 2\",\n+        \"  after executed above command, a consume(10+2) request will be sent to hedwig.\",\n+        \"\",\n+        \"  NOTE:\",\n+        \"  since Hedwig updates subscription consume ptr lazily, so you need to know that\",\n+        \"    1) the consumption ptr read from zookeeper may be stable; \",\n+        \"    2) after sent the consume request, hedwig may just move ptr in its memory and lazily update it to zookeeper. you may not see the ptr changed when DESCRIBE the topic.\",\n+    };\n+\n+    /* CONSUMETO: move consume ptr of a subscription to a specified pos */\n+    static final String CONSUMETO = \"consumeto\";\n+    static final String CONSUMETO_DESC = \"Move consume ptr of a subscription to a specified message id\";\n+    static final String[] CONSUMETO_USAGE = new String[] {\n+        \"usage: consumeto {topic} {subscriber} {msg_id}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {msg_id}     : message id that consume ptr will be moved to.\",\n+        \"                 if the message id is less than current consume ptr,\",\n+        \"                 hedwig will do nothing.\",\n+        \"\",\n+        \"  Example:\",\n+        \"  suppose, from zk we know subscriber B consumed topic T to message 10\",\n+        \"  [hedwig: (standalone) 1] consumeto T B 12\",\n+        \"  after executed above command, a consume(12) request will be sent to hedwig.\",\n+        \"\",\n+        \"  NOTE:\",\n+        \"  since Hedwig updates subscription consume ptr lazily, so you need to know that\",\n+        \"    1) the consumption ptr read from zookeeper may be stable; \",\n+        \"    2) after sent the consume request, hedwig may just move ptr in its memory and lazily update it to zookeeper. you may not see the ptr changed when DESCRIBE the topic.\",\n+    };\n+\n+    /* PUBSUB: a healthy checking command to ensure cluster is running */\n+    static final String PUBSUB = \"pubsub\";\n+    static final String PUBSUB_DESC = \"A healthy checking command to ensure hedwig is in running state\";\n+    static final String[] PUBSUB_USAGE = new String[] {\n+        \"usage: pubsub {topic} {subscriber} {timeout_secs} {message}\",\n+        \"\",\n+        \"  {topic}        : topic name.\",\n+        \"                   any printable string without spaces.\",\n+        \"  {subscriber}   : subscriber id.\",\n+        \"                   any printable string without spaces.\",\n+        \"  {timeout_secs} : how long will the subscriber wait for published message.\",\n+        \"  {message}      : message body.\",\n+        \"                   remaining arguments are used as message body to publish.\",\n+        \"\",\n+        \"  Example:\",\n+        \"  [hedwig: (standalone) 1] pubsub TOPIC SUBID 10 TEST_MESSAGS\",\n+        \"\",\n+        \"  1) hw will subscribe topic TOPIC as subscriber SUBID;\",\n+        \"  2) subscriber SUBID will wait a message until 10 seconds;\",\n+        \"  3) hw publishes TEST_MESSAGES to topic TOPIC;\",\n+        \"  4) if subscriber recevied message in 10 secs, it checked that whether the message is published message.\",\n+        \"     if true, it will return SUCCESS, otherwise return FAILED.\",\n+    };\n+\n+    //\n+    // List all commands used to admin hedwig\n+    //\n+\n+    /* SHOW: list all available hub servers or topics */\n+    static final String SHOW = \"show\";\n+    static final String SHOW_DESC = \"list all available hub servers or topics\";\n+    static final String[] SHOW_USAGE = new String[] {\n+        \"usage: show [topics | hubs]\",\n+        \"\",\n+        \"  show topics :\",\n+        \"    listing all available topics in hedwig.\",\n+        \"\",\n+        \"  show hubs :\",\n+        \"    listing all available hubs in hedwig.\",\n+        \"\",\n+        \"  NOTES:\",\n+        \"  'show topics' will not works when there are millions of topics in hedwig, since we have packetLen limitation fetching data from zookeeper.\",\n+    };\n+\n+    static final String SHOW_TOPICS = \"topics\";\n+    static final String SHOW_HUBS   = \"hubs\";\n+\n+    /* DESCRIBE: show the metadata of a topic */\n+    static final String DESCRIBE = \"describe\";\n+    static final String DESCRIBE_DESC = \"show metadata of a topic, including topic owner, persistence info, subscriptions info\";\n+    static final String[] DESCRIBE_USAGE = new String[] {\n+        \"usage: describe topic {topic}\",\n+        \"\",\n+        \"  {topic} : topic name.\",\n+        \"            any printable string without spaces.\",\n+        \"\",\n+        \"  Example: describe topic ttttt\",\n+        \"\",\n+        \"  Output:\",\n+        \"  ===== Topic Information : ttttt =====\",\n+        \"\",\n+        \"  Owner : 98.137.99.27:9875:9876\",\n+        \"\",\n+        \"  >>> Persistence Info <<<\",\n+        \"  Ledger 54729 [ 1 ~ 59 ]\",\n+        \"  Ledger 54731 [ 60 ~ 60 ]\",\n+        \"  Ledger 54733 [ 61 ~ 61 ]\",\n+        \"\",\n+        \"  >>> Subscription Info <<<\",\n+        \"  Subscriber mysub : consumeSeqId: local:50\",\n+    };\n+\n+    static final String DESCRIBE_TOPIC = \"topic\";\n+\n+    /* READTOPIC: read messages of a specified topic */\n+    static final String READTOPIC = \"readtopic\";\n+    static final String READTOPIC_DESC = \"read messages of a specified topic\";\n+    static final String[] READTOPIC_USAGE = new String[] {\n+        \"usage: readtopic {topic} [start_msg_id]\",\n+        \"\",\n+        \"  {topic}        : topic name.\",\n+        \"                   any printable string without spaces.\",\n+        \"  [start_msg_id] : message id that start to read from.\",\n+        \"\",\n+        \"  no start_msg_id provided:\",\n+        \"    it will start from least_consumed_message_id + 1.\",\n+        \"    least_consume_message_id is computed from all its subscribers.\",\n+        \"\",\n+        \"  start_msg_id provided:\",\n+        \"    it will start from MAX(start_msg_id, least_consumed_message_id).\",\n+        \"\",\n+        \"  MESSAGE FORMAT:\",\n+        \"\",\n+        \"  ---------- MSGID=LOCAL(51) ----------\",\n+        \"  MsgId:     LOCAL(51)\",\n+        \"  SrcRegion: standalone\",\n+        \"  Message:\",\n+        \"\",\n+        \"  hello\",\n+    };\n+\n+    //\n+    // List other useful commands\n+    //\n+\n+    /* SET: set whether printing zk watches or not */\n+    static final String SET = \"set\";\n+    static final String SET_DESC = \"set whether printing zk watches or not\";\n+    static final String[] SET_USAGE = EMPTY_ARRAY;\n+\n+    /* HISTORY: list history commands */\n+    static final String HISTORY = \"history\";\n+    static final String HISTORY_DESC = \"list history commands\";\n+    static final String[] HISTORY_USAGE = EMPTY_ARRAY;\n+\n+    /* REDO: redo previous command */\n+    static final String REDO = \"redo\";\n+    static final String REDO_DESC = \"redo history command\";\n+    static final String[] REDO_USAGE = new String[] {\n+        \"usage: redo [{cmdno} | !]\",\n+        \"\",\n+        \"  {cmdno} : history command no.\",\n+        \"  !       : last command.\",\n+    };\n+\n+    /* HELP: print usage information of a specified command */\n+    static final String HELP = \"help\";\n+    static final String HELP_DESC = \"print usage information of a specified command\";\n+    static final String[] HELP_USAGE = new String[] {\n+        \"usage: help {command}\",\n+        \"\",\n+        \"  {command} : command name\",\n+    };\n+\n+    static final String QUIT = \"quit\";\n+    static final String QUIT_DESC = \"exit console\";\n+    static final String[] QUIT_USAGE = EMPTY_ARRAY;\n+\n+    static final String EXIT = \"exit\";\n+    static final String EXIT_DESC = QUIT_DESC;\n+    static final String[] EXIT_USAGE = EMPTY_ARRAY;\n+\n+    public static enum COMMAND {\n+\n+        CMD_PUB (PUB, PUB_DESC, PUB_USAGE),\n+        CMD_SUB (SUB, SUB_DESC, SUB_USAGE),\n+        CMD_CLOSESUB (CLOSESUB, CLOSESUB_DESC, CLOSESUB_USAGE),\n+        CMD_UNSUB (UNSUB, UNSUB_DESC, UNSUB_USAGE),\n+        CMD_RMSUB (RMSUB, RMSUB_DESC, RMSUB_USAGE),\n+        CMD_CONSUME (CONSUME, CONSUME_DESC, CONSUME_USAGE),\n+        CMD_CONSUMETO (CONSUMETO, CONSUMETO_DESC, CONSUMETO_USAGE),\n+        CMD_PUBSUB (PUBSUB, PUBSUB_DESC, PUBSUB_USAGE),\n+        CMD_SHOW (SHOW, SHOW_DESC, SHOW_USAGE),\n+        CMD_DESCRIBE (DESCRIBE, DESCRIBE_DESC, DESCRIBE_USAGE),\n+        CMD_READTOPIC (READTOPIC, READTOPIC_DESC, READTOPIC_USAGE),\n+        CMD_SET (SET, SET_DESC, SET_USAGE),\n+        CMD_HISTORY (HISTORY, HISTORY_DESC, HISTORY_USAGE),\n+        CMD_REDO (REDO, REDO_DESC, REDO_USAGE),\n+        CMD_HELP (HELP, HELP_DESC, HELP_USAGE),\n+        CMD_QUIT (QUIT, QUIT_DESC, QUIT_USAGE),\n+        CMD_EXIT (EXIT, EXIT_DESC, EXIT_USAGE),\n+        // sub commands\n+        CMD_SHOW_TOPICS (SHOW_TOPICS, \"\", EMPTY_ARRAY),\n+        CMD_SHOW_HUBS (SHOW_HUBS, \"\", EMPTY_ARRAY),\n+        CMD_DESCRIBE_TOPIC (DESCRIBE_TOPIC, \"\", EMPTY_ARRAY);\n+\n+        COMMAND(String name, String desc, String[] usage) {\n+            this.name = name;\n+            this.desc = desc;\n+            this.usage = usage;\n+            this.subCmds = new LinkedHashMap<String, COMMAND>();\n+        }\n+\n+        public String getName() { return name; }\n+\n+        public String getDescription() { return desc; }\n+\n+        public String[] getUsage() { return usage; }\n+\n+        public Map<String, COMMAND> getSubCommands() { return subCmds; }\n+\n+        public void addSubCommand(COMMAND c) {\n+            this.subCmds.put(c.name, c);\n+        };\n+\n+        public void printUsage() {\n+            System.err.println(name + \": \" + desc);\n+            for(String line : usage) {\n+                System.err.println(line);\n+            }\n+            System.err.println();\n+        }\n+\n+        protected String name;\n+        protected String desc;\n+        protected String[] usage;\n+        protected Map<String, COMMAND> subCmds;\n+    }\n+\n+    static Map<String, COMMAND> commands = null;\n+\n+    private static void addCommand(COMMAND c) {\n+        commands.put(c.getName(), c);\n+    }\n+\n+    static {\n+        commands = new LinkedHashMap<String, COMMAND>();\n+\n+        addCommand(COMMAND.CMD_PUB);\n+        addCommand(COMMAND.CMD_SUB);\n+        addCommand(COMMAND.CMD_CLOSESUB);\n+        addCommand(COMMAND.CMD_UNSUB);\n+        addCommand(COMMAND.CMD_RMSUB);\n+        addCommand(COMMAND.CMD_CONSUME);\n+        addCommand(COMMAND.CMD_CONSUMETO);\n+        addCommand(COMMAND.CMD_PUBSUB);\n+\n+        // show\n+        COMMAND.CMD_SHOW.addSubCommand(COMMAND.CMD_SHOW_TOPICS);\n+        COMMAND.CMD_SHOW.addSubCommand(COMMAND.CMD_SHOW_HUBS);\n+        addCommand(COMMAND.CMD_SHOW);\n+\n+        // describe\n+        COMMAND.CMD_DESCRIBE.addSubCommand(COMMAND.CMD_DESCRIBE_TOPIC);\n+        addCommand(COMMAND.CMD_DESCRIBE);\n+\n+        addCommand(COMMAND.CMD_READTOPIC);\n+        addCommand(COMMAND.CMD_SET);\n+        addCommand(COMMAND.CMD_HISTORY);\n+        addCommand(COMMAND.CMD_REDO);\n+        addCommand(COMMAND.CMD_HELP);\n+        addCommand(COMMAND.CMD_QUIT);\n+        addCommand(COMMAND.CMD_EXIT);\n+    }\n+\n+    public static Map<String, COMMAND> getHedwigCommands() {\n+        return commands;\n+    }\n+\n+    /**\n+     * Find candidate commands by the specified token list\n+     *\n+     * @param token token list\n+     *\n+     * @return list of candidate commands\n+     */\n+    public static List<String> findCandidateCommands(String[] tokens) {\n+        List<String> cmds = new LinkedList<String>();\n+\n+        Map<String, COMMAND> cmdMap = commands;\n+        for (int i=0; i<(tokens.length - 1); i++) {\n+            COMMAND c = cmdMap.get(tokens[i]);\n+            // no commands\n+            if (c == null || c.getSubCommands().size() <= 0) {\n+                return cmds;\n+            } else {\n+                cmdMap = c.getSubCommands();\n+            }\n+        }\n+        cmds.addAll(cmdMap.keySet());\n+        return cmds;\n+    }\n+}"},{"sha":"5da8e163e6a57a6c36dfa363002c0743a9b51e07","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","status":"added","additions":1029,"deletions":0,"changes":1029,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -0,0 +1,1029 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.hedwig.admin.HedwigAdmin;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.HedwigClient;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+import static org.apache.hedwig.admin.console.HedwigCommands.*;\n+import static org.apache.hedwig.admin.console.HedwigCommands.COMMAND.*;\n+\n+/**\n+ * Console Client to Hedwig\n+ */\n+public class HedwigConsole {\n+    private static final Logger LOG = LoggerFactory.getLogger(HedwigConsole.class);\n+    // NOTE: now it is fixed passwd in bookkeeper\n+    static byte[] passwd = \"sillysecret\".getBytes();\n+\n+    // history file name\n+    static final String HW_HISTORY_FILE = \".hw_history\";\n+\n+    protected MyCommandOptions cl = new MyCommandOptions();\n+    protected HashMap<Integer, String> history = new LinkedHashMap<Integer, String>();\n+    protected int commandCount = 0;\n+    protected boolean printWatches = true;\n+    protected Map<String, MyCommand> myCommands;\n+\n+    protected boolean inConsole = true;\n+\n+    protected HedwigAdmin admin;\n+    protected HedwigClient hubClient;\n+    protected Publisher publisher;\n+    protected Subscriber subscriber;\n+    protected ConsoleMessageHandler consoleHandler =\n+            new ConsoleMessageHandler();\n+\n+    protected String myRegion;\n+\n+    interface MyCommand {\n+        boolean runCmd(String[] args) throws Exception;\n+    }\n+\n+    class HelpCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            boolean printUsage = true;\n+            if (args.length >= 2) {\n+                String command = args[1];\n+                COMMAND c = getHedwigCommands().get(command);\n+                if (c != null) {\n+                    c.printUsage();\n+                    printUsage = false;\n+                }\n+            }\n+            if (printUsage) {\n+                usage();\n+            }\n+            return true;\n+        }\n+    }\n+\n+    class ExitCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            printMessage(\"Quitting ...\");\n+            hubClient.close();\n+            admin.close();\n+            System.exit(0);\n+            return true;\n+        }\n+    }\n+\n+    class RedoCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 2) {\n+                return false;\n+            }\n+\n+            int index;\n+            if (\"!\".equals(args[1])) {\n+                index = commandCount - 1;\n+            } else {\n+                index = Integer.decode(args[1]);\n+                if (commandCount <= index) {\n+                    System.err.println(\"Command index out of range\");\n+                    return false;\n+                }\n+            }\n+            cl.parseCommand(history.get(index));\n+            if (cl.getCommand().equals(\"redo\")) {\n+                System.err.println(\"No redoing redos\");\n+                return false;\n+            }\n+            history.put(commandCount, history.get(index));\n+            processCmd(cl);\n+            return true;\n+        }\n+        \n+    }\n+\n+    class HistoryCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            for (int i=commandCount - 10; i<=commandCount; ++i) {\n+                if (i < 0) {\n+                    continue;\n+                }\n+                System.out.println(i + \" - \" + history.get(i));\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class SetCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3 || !\"printwatches\".equals(args[1])) {\n+                return false;\n+            } else if (args.length == 2) {\n+                System.out.println(\"printwatches is \" + (printWatches ? \"on\" : \"off\"));\n+            } else {\n+                printWatches = args[2].equals(\"on\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class PubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (int i=2; i<args.length; i++) {\n+                sb.append(args[i]);\n+                if (i != args.length - 1) {\n+                    sb.append(' ');\n+                }\n+            }\n+            ByteString msgBody = ByteString.copyFromUtf8(sb.toString());\n+            Message msg = Message.newBuilder().setBody(msgBody).build();\n+            try {\n+                publisher.publish(topic, msg);\n+                System.out.println(\"PUB DONE\");\n+            } catch (Exception e) {\n+                System.err.println(\"PUB FAILED\");\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class ConsoleMessageHandler implements MessageHandler {\n+\n+        @Override\n+        public void deliver(ByteString topic, ByteString subscriberId,\n+                Message msg, Callback<Void> callback, Object context) {\n+            System.out.println(\"Received message from topic \" + topic.toStringUtf8() + \n+                    \" for subscriber \" + subscriberId.toStringUtf8() + \" : \"\n+                    + msg.getBody().toStringUtf8());\n+            callback.operationFinished(context, null);\n+        }\n+        \n+    }\n+\n+    class SubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            CreateOrAttach mode;\n+            boolean receive = true;\n+            if (args.length < 3) {\n+                return false;\n+            } else if (args.length == 3) {\n+                mode = CreateOrAttach.ATTACH;\n+                receive = true;\n+            } else {\n+                try {\n+                    mode = CreateOrAttach.valueOf(Integer.parseInt(args[3]));\n+                } catch (Exception e) {\n+                    System.err.println(\"Unknow mode : \" + args[3]);\n+                    return false;\n+                }\n+                if (args.length >= 5) {\n+                    try {\n+                        receive = Boolean.parseBoolean(args[4]);\n+                    } catch (Exception e) {\n+                        receive = false;\n+                    }\n+                }\n+            }\n+            if (mode == null) {\n+                System.err.println(\"Unknow mode : \" + args[3]);\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            try {\n+                subscriber.subscribe(topic, subId, mode);\n+                if (receive) {\n+                    subscriber.startDelivery(topic, subId, consoleHandler);\n+                    System.out.println(\"SUB DONE AND RECEIVE\");\n+                } else {\n+                    System.out.println(\"SUB DONE BUT NOT RECEIVE\");\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"SUB FAILED\");\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+    }\n+\n+    class UnsubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            try {\n+                subscriber.stopDelivery(topic, subId);\n+                subscriber.unsubscribe(topic, subId);\n+                System.out.println(\"UNSUB DONE\");\n+            } catch (Exception e) {\n+                System.err.println(\"UNSUB FAILED\");\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class RmsubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 7) {\n+                return false;\n+            }\n+            String topicPrefix = args[1];\n+            int startTopic = Integer.parseInt(args[2]);\n+            int endTopic = Integer.parseInt(args[3]);\n+            String subPrefix = args[4];\n+            int startSub = Integer.parseInt(args[5]);\n+            int endSub = Integer.parseInt(args[6]);\n+            if (startTopic > endTopic || endSub < startSub) {\n+                return false;\n+            }\n+            for (int i=startTopic; i<=endTopic; i++) {\n+                ByteString topic = ByteString.copyFromUtf8(topicPrefix + i);\n+                try {\n+                    for (int j=startSub; j<=endSub; j++) {\n+                        ByteString sub = ByteString.copyFromUtf8(subPrefix + j);\n+                        subscriber.subscribe(topic, sub, CreateOrAttach.CREATE_OR_ATTACH);\n+                        subscriber.unsubscribe(topic, sub);\n+                    }\n+                    System.out.println(\"RMSUB \" + topic.toStringUtf8() + \" DONE\");\n+                } catch (Exception e) {\n+                    System.err.println(\"RMSUB \" + topic.toStringUtf8() + \" FAILED\");\n+                    e.printStackTrace();\n+                }\n+            }\n+            return true;\n+        }\n+\n+    }\n+    \n+    class CloseSubscriptionCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString sudId = ByteString.copyFromUtf8(args[2]);\n+            \n+            try {\n+                subscriber.stopDelivery(topic, sudId);\n+                subscriber.closeSubscription(topic, sudId);\n+            } catch (Exception e) {\n+                System.err.println(\"CLOSESUB FAILED\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+    \n+    class ConsumeToCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 4) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            long msgId = Long.parseLong(args[3]);\n+            MessageSeqId consumeId = MessageSeqId.newBuilder().setLocalComponent(msgId).build();\n+            try {\n+                subscriber.consume(topic, subId, consumeId);\n+            } catch (Exception e) {\n+                System.err.println(\"CONSUMETO FAILED\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+    \n+    class ConsumeCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 4) {\n+                return false;\n+            }\n+            long lastConsumedId = 0;\n+            SubscriptionState state = admin.getSubscription(ByteString.copyFromUtf8(args[1]), ByteString.copyFromUtf8(args[2]));\n+            if (null == state) {\n+                System.err.println(\"Failed to read subscription for topic: \" + args[1]\n+                                 + \" subscriber: \" + args[2]);\n+                return true;\n+            }\n+            long numMessagesToConsume = Long.parseLong(args[3]);\n+            long idToConsumed = lastConsumedId + numMessagesToConsume;\n+            System.out.println(\"Try to move subscriber(\" + args[2] + \") consume ptr of topic(\" + args[1]\n+                             + \") from \" + lastConsumedId + \" to \" + idToConsumed);\n+            MessageSeqId consumeId = MessageSeqId.newBuilder().setLocalComponent(idToConsumed).build();\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            try {\n+                subscriber.consume(topic, subId, consumeId);\n+            } catch (Exception e) {\n+                System.err.println(\"CONSUME FAILED\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class PubSubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 5) {\n+                return false;\n+            }\n+            final long startTime = System.currentTimeMillis();\n+\n+            final ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            final ByteString subId = ByteString.copyFromUtf8(args[2] + \"-\" + startTime);\n+            int timeoutSecs = 60;\n+            try {\n+                timeoutSecs = Integer.parseInt(args[3]);\n+            } catch (NumberFormatException nfe) {\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (int i=4; i<args.length; i++) {\n+                sb.append(args[i]);\n+                if (i != args.length - 1) {\n+                    sb.append(' ');\n+                }\n+            }\n+            // append a timestamp tag\n+            ByteString msgBody = ByteString.copyFromUtf8(sb.toString() + \"-\" + startTime);\n+            final Message msg = Message.newBuilder().setBody(msgBody).build();\n+\n+            boolean subscribed = false;\n+            boolean success = false;\n+            final AtomicBoolean isDone = new AtomicBoolean(false);\n+            long elapsedTime = 0L;\n+\n+            System.out.println(\"Starting PUBSUB test ...\");\n+            try {\n+                // sub the topic\n+                subscriber.subscribe(topic, subId, CreateOrAttach.CREATE_OR_ATTACH);\n+                subscribed = true;\n+\n+                System.out.println(\"Sub topic \" + topic.toStringUtf8() + \", subscriber id \" + subId.toStringUtf8());\n+\n+                \n+\n+                // pub topic\n+                publisher.publish(topic, msg);\n+                System.out.println(\"Pub topic \" + topic.toStringUtf8() + \" : \" + msg.getBody().toStringUtf8());\n+\n+                // ensure subscriber first, publish next, then we start delivery to receive message\n+                // if start delivery first before publish, isDone may notify before wait\n+                subscriber.startDelivery(topic, subId, new MessageHandler() {\n+\n+                    @Override\n+                    public void deliver(ByteString thisTopic, ByteString subscriberId,\n+                            Message message, Callback<Void> callback, Object context) {\n+                        if (thisTopic.equals(topic) && subscriberId.equals(subId) &&\n+                            msg.getBody().equals(message.getBody())) {\n+                            System.out.println(\"Received message : \" + message.getBody().toStringUtf8());\n+                            synchronized(isDone) {\n+                                isDone.set(true);\n+                                isDone.notify();\n+                            }\n+                        }\n+                        callback.operationFinished(context, null);\n+                    }\n+\n+                });\n+\n+                // wait for the message\n+                synchronized (isDone) {\n+                    isDone.wait(timeoutSecs * 1000L);\n+                }\n+                success = isDone.get();\n+                elapsedTime = System.currentTimeMillis() - startTime;\n+            } finally {\n+                try {\n+                    if (subscribed) {\n+                        subscriber.stopDelivery(topic, subId);\n+                        subscriber.unsubscribe(topic, subId);\n+                    }\n+                } finally {\n+                    if (success) {\n+                        System.out.println(\"PUBSUB SUCCESS. TIME: \" + elapsedTime + \" MS\");\n+                    } else {\n+                        System.out.println(\"PUBSUB FAILED. \");\n+                    }\n+                    return success;\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    class ReadTopicCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 2) {\n+                return false;\n+            }\n+            ReadTopic rt;\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            if (args.length == 2) {\n+                rt = new ReadTopic(admin, topic, inConsole);\n+            } else {\n+                rt = new ReadTopic(admin, topic, Long.parseLong(args[2]), inConsole);\n+            }\n+            rt.readTopic();\n+            return true;\n+        }\n+        \n+    }\n+\n+    class ShowCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 2) {\n+                return false;\n+            }\n+            String errorMsg = null;\n+            try {\n+                if (HedwigCommands.SHOW_HUBS.equals(args[1])) {\n+                    errorMsg = \"Unable to fetch the list of hub servers\";\n+                    showHubs();\n+                } else if (HedwigCommands.SHOW_TOPICS.equals(args[1])) {\n+                    errorMsg = \"Unable to fetch the list of topics\";\n+                    showTopics();\n+                } else {\n+                    System.err.println(\"ERROR: Unknown show command '\" + args[1] + \"'\");\n+                    return false;\n+                }\n+            } catch (Exception e) {\n+                if (null != errorMsg) {\n+                    System.err.println(errorMsg);\n+                }\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+\n+        protected void showHubs() throws Exception {\n+            Map<HedwigSocketAddress, Integer> hubs = admin.getAvailableHubs();\n+            System.out.println(\"Available Hub Servers:\");\n+            for (Map.Entry<HedwigSocketAddress, Integer> entry : hubs.entrySet()) {\n+                System.out.println(\"\\t\" + entry.getKey() + \" :\\t\" + entry.getValue());\n+            }\n+        }\n+\n+        protected void showTopics() throws Exception {\n+            List<String> topics = admin.getTopics();\n+            System.out.println(\"Topic List:\");\n+            System.out.println(topics);\n+        }\n+        \n+    }\n+\n+    class DescribeCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            if (HedwigCommands.DESCRIBE_TOPIC.equals(args[1])) {\n+                return describeTopic(args[2]);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        protected boolean describeTopic(String topic) throws Exception {\n+            ByteString btopic = ByteString.copyFromUtf8(topic);\n+            HedwigSocketAddress owner = admin.getTopicOwner(btopic);\n+            List<LedgerRange> ranges = admin.getTopicLedgers(btopic);\n+            Map<ByteString, SubscriptionState> states = admin.getTopicSubscriptions(btopic);\n+\n+            System.out.println(\"===== Topic Information : \" + topic + \" =====\");\n+            System.out.println();\n+            System.out.println(\"Owner : \" + (owner == null ? \"NULL\" : owner));\n+            System.out.println();\n+\n+            // print ledgers\n+            printTopicLedgers(ranges);\n+            // print subscriptions\n+            printTopicSubscriptions(states);\n+\n+            return true;\n+        }\n+\n+        private void printTopicLedgers(List<LedgerRange> lrs) {\n+            System.out.println(\">>> Persistence Info <<<\");\n+            if (null == lrs) {\n+                System.out.println(\"N/A\");\n+                return;\n+            }\n+            if (lrs.isEmpty()) {\n+                System.out.println(\"No Ledger used.\");\n+                return;\n+            }\n+            Iterator<LedgerRange> lrIterator = lrs.iterator();\n+            long startOfLedger = 1;\n+            while (lrIterator.hasNext()) {\n+                LedgerRange range = lrIterator.next();\n+                long endOfLedger = Long.MAX_VALUE;\n+                if (range.hasEndSeqIdIncluded()) {\n+                    endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                }\n+                System.out.println(\"Ledger \" + range.getLedgerId() + \" [ \" + startOfLedger + \" ~ \" + (endOfLedger == Long.MAX_VALUE ? \"\" : endOfLedger) + \" ]\");\n+\n+                startOfLedger = endOfLedger + 1;\n+            }\n+            System.out.println();\n+        }\n+\n+        private void printTopicSubscriptions(Map<ByteString, SubscriptionState> states) {\n+            System.out.println(\">>> Subscription Info <<<\");\n+            if (0 == states.size()) {\n+                System.out.println(\"No subscriber.\");\n+                return;\n+            }\n+            for (Map.Entry<ByteString, SubscriptionState> entry : states.entrySet()) {\n+                System.out.println(\"Subscriber \" + entry.getKey().toStringUtf8() + \" : \"\n+                                 + SubscriptionStateUtils.toString(entry.getValue()));\n+            }\n+            System.out.println();\n+        }\n+\n+    }\n+\n+    protected Map<String, MyCommand> buildMyCommands() {\n+        Map<String, MyCommand> cmds =\n+                new HashMap<String, MyCommand>();\n+\n+        ExitCmd exitCmd = new ExitCmd();\n+        cmds.put(EXIT, exitCmd);\n+        cmds.put(QUIT, exitCmd);\n+        cmds.put(HELP, new HelpCmd());\n+        cmds.put(HISTORY, new HistoryCmd());\n+        cmds.put(REDO, new RedoCmd());\n+        cmds.put(SET, new SetCmd());\n+        cmds.put(PUB, new PubCmd());\n+        cmds.put(SUB, new SubCmd());\n+        cmds.put(PUBSUB, new PubSubCmd());\n+        cmds.put(CLOSESUB, new CloseSubscriptionCmd());\n+        cmds.put(UNSUB, new UnsubCmd());\n+        cmds.put(RMSUB, new RmsubCmd());\n+        cmds.put(CONSUME, new ConsumeCmd());\n+        cmds.put(CONSUMETO, new ConsumeToCmd());\n+        cmds.put(SHOW, new ShowCmd());\n+        cmds.put(DESCRIBE, new DescribeCmd());\n+        cmds.put(READTOPIC, new ReadTopicCmd());\n+\n+        return cmds;\n+    }\n+\n+    static void usage() {\n+        System.err.println(\"HedwigConsole [options] [command] [args]\");\n+        System.err.println();\n+        System.err.println(\"Avaiable commands:\");\n+        for (String cmd : getHedwigCommands().keySet()) {\n+            System.err.println(\"\\t\" + cmd);\n+        }\n+        System.err.println();\n+    }\n+\n+    /**\n+     * A storage class for both command line options and shell commands.\n+     */\n+    static private class MyCommandOptions {\n+\n+        private Map<String,String> options = new HashMap<String,String>();\n+        private List<String> cmdArgs = null;\n+        private String command = null;\n+\n+        public MyCommandOptions() {\n+        }\n+\n+        public String getOption(String opt) {\n+            return options.get(opt);\n+        }\n+\n+        public String getCommand( ) {\n+            return command;\n+        }\n+\n+        public String getCmdArgument( int index ) {\n+            return cmdArgs.get(index);\n+        }\n+\n+        public int getNumArguments( ) {\n+            return cmdArgs.size();\n+        }\n+\n+        public String[] getArgArray() {\n+            return cmdArgs.toArray(new String[0]);\n+        }\n+\n+        /**\n+         * Parses a command line that may contain one or more flags\n+         * before an optional command string\n+         * @param args command line arguments\n+         * @return true if parsing succeeded, false otherwise.\n+         */\n+        public boolean parseOptions(String[] args) {\n+            List<String> argList = Arrays.asList(args);\n+            Iterator<String> it = argList.iterator();\n+\n+            while (it.hasNext()) {\n+                String opt = it.next();\n+                if (!opt.startsWith(\"-\")) {\n+                    command = opt;\n+                    cmdArgs = new ArrayList<String>( );\n+                    cmdArgs.add( command );\n+                    while (it.hasNext()) {\n+                        cmdArgs.add(it.next());\n+                    }\n+                    return true;\n+                } else {\n+                    try {\n+                        options.put(opt.substring(1), it.next());\n+                    } catch (NoSuchElementException e) {\n+                        System.err.println(\"Error: no argument found for option \"\n+                                + opt);\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+\n+        /**\n+         * Breaks a string into command + arguments.\n+         * @param cmdstring string of form \"cmd arg1 arg2..etc\"\n+         * @return true if parsing succeeded.\n+         */\n+        public boolean parseCommand( String cmdstring ) {\n+            String[] args = cmdstring.split(\" \");\n+            if (args.length == 0){\n+                return false;\n+            }\n+            command = args[0];\n+            cmdArgs = Arrays.asList(args);\n+            return true;\n+        }\n+    }\n+\n+    private class MyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+            if (getPrintWatches()) {\n+                printMessage(\"WATCHER::\");\n+                printMessage(event.toString());\n+            }\n+        }\n+    }\n+\n+    public void printMessage(String msg) {\n+        if (inConsole) {\n+            System.out.println(\"\\n\"+msg);\n+        }\n+    }\n+\n+    /**\n+     * Hedwig Console\n+     *\n+     * @param args arguments\n+     * @throws IOException\n+     * @throws InterruptedException \n+     */\n+    public HedwigConsole(String[] args) throws IOException, InterruptedException {\n+        cl.parseOptions(args);\n+\n+        if (cl.getCommand() == null) {\n+            inConsole = true;\n+        } else {\n+            inConsole = false;\n+        }\n+\n+        org.apache.bookkeeper.conf.ClientConfiguration bkClientConf =\n+            new org.apache.bookkeeper.conf.ClientConfiguration();\n+        ServerConfiguration hubServerConf = new ServerConfiguration();\n+        String serverCfgFile = cl.getOption(\"server-cfg\");\n+        if (serverCfgFile != null) {\n+            try {\n+                hubServerConf.loadConf(new File(serverCfgFile).toURI().toURL());\n+            } catch (ConfigurationException e) {\n+                throw new IOException(e);\n+            }\n+            try {\n+                bkClientConf.loadConf(new File(serverCfgFile).toURI().toURL());\n+            } catch (ConfigurationException e) {\n+                throw new IOException(e);\n+            }\n+        }\n+\n+        ClientConfiguration hubClientCfg = new ClientConfiguration();\n+        String clientCfgFile = cl.getOption(\"client-cfg\");\n+        if (clientCfgFile != null) {\n+            try {\n+                hubClientCfg.loadConf(new File(clientCfgFile).toURI().toURL());\n+            } catch (ConfigurationException e) {\n+                throw new IOException(e);\n+            }\n+        }\n+\n+\n+\n+        printMessage(\"Connecting to zookeeper/bookkeeper using HedwigAdmin\");\n+        try {\n+            admin = new HedwigAdmin(bkClientConf, hubServerConf);\n+            admin.getZkHandle().register(new MyWatcher());\n+        } catch (Exception e) {\n+            throw new IOException(e);\n+        }\n+        \n+        printMessage(\"Connecting to default hub server \" + hubClientCfg.getDefaultServerHost());\n+        hubClient = new HedwigClient(hubClientCfg);\n+        publisher = hubClient.getPublisher();\n+        subscriber = hubClient.getSubscriber();\n+        \n+        // other parameters\n+        myRegion = hubServerConf.getMyRegion();\n+    }\n+\n+    public boolean getPrintWatches() {\n+        return printWatches;\n+    }\n+\n+    protected String getPrompt() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[hedwig: (\").append(myRegion).append(\") \").append(commandCount).append(\"] \");\n+        return sb.toString();\n+    }\n+\n+    protected void addToHistory(int i, String cmd) {\n+        history.put(i, cmd);\n+    }\n+\n+    public void executeLine(String line) {\n+        if (!line.equals(\"\")) {\n+            cl.parseCommand(line);\n+            addToHistory(commandCount, line);\n+            processCmd(cl);\n+            commandCount++;\n+        }\n+    }\n+\n+    protected boolean processCmd(MyCommandOptions co) {\n+        String[] args = co.getArgArray();\n+        String cmd = co.getCommand();\n+        if (args.length < 1) {\n+            usage();\n+            return false;\n+        }\n+        if (!getHedwigCommands().containsKey(cmd)) {\n+            usage();\n+            return false;\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Processing \" + cmd);\n+        }\n+\n+        MyCommand myCommand = myCommands.get(cmd);\n+        if (myCommand == null) {\n+            System.err.println(\"No Command Processor found for command \" + cmd);\n+            usage();\n+            return false;\n+        }\n+\n+        long startTime = System.currentTimeMillis();\n+        boolean success = false;\n+        try {\n+            success = myCommand.runCmd(args);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            success = false;\n+        }\n+        long elapsedTime = System.currentTimeMillis() - startTime;\n+        if (inConsole) {\n+            if (success) {\n+                System.out.println(\"Finished \" + ((double)elapsedTime / 1000) + \" s.\");\n+            } else {\n+                COMMAND c = getHedwigCommands().get(cmd);\n+                if (c != null) {\n+                    c.printUsage();\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    void run() throws IOException {\n+        inConsole = true;\n+        myCommands = buildMyCommands();\n+        if (cl.getCommand() == null) {\n+            System.out.println(\"Welcome to Hedwig!\");\n+\n+            boolean jlinemissing = false;\n+            // only use jline if it's in the classpath\n+            try {\n+                Class consoleC = Class.forName(\"jline.ConsoleReader\");\n+                Class completorC =\n+                    Class.forName(\"org.apache.hedwig.admin.console.JLineHedwigCompletor\");\n+\n+                System.out.println(\"JLine support is enabled\");\n+\n+                Object console =\n+                    consoleC.getConstructor().newInstance();\n+\n+                Object completor =\n+                    completorC.getConstructor(HedwigAdmin.class).newInstance(admin);\n+                Method addCompletor = consoleC.getMethod(\"addCompletor\",\n+                        Class.forName(\"jline.Completor\"));\n+                addCompletor.invoke(console, completor);\n+\n+                // load history file\n+                boolean historyEnabled = false;\n+                Object history = null;\n+                Method addHistory = null;\n+                // Method flushHistory = null;\n+                try {\n+                    Class historyC = Class.forName(\"jline.History\");\n+                    history = historyC.getConstructor().newInstance();\n+\n+                    File file = new File(System.getProperty(\"hw.history\",\n+                                         new File(System.getProperty(\"user.home\"), HW_HISTORY_FILE).toString()));\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"History file is \" + file.toString());\n+                    }\n+                    Method setHistoryFile = historyC.getMethod(\"setHistoryFile\", File.class);\n+                    setHistoryFile.invoke(history, file);\n+\n+                    // set history to console reader\n+                    Method setHistory = consoleC.getMethod(\"setHistory\", historyC);\n+                    setHistory.invoke(console, history);\n+\n+                    // load history from history file\n+                    Method moveToFirstEntry = historyC.getMethod(\"moveToFirstEntry\");\n+                    moveToFirstEntry.invoke(history);\n+\n+                    addHistory = historyC.getMethod(\"addToHistory\", String.class);\n+                    // flushHistory = historyC.getMethod(\"flushBuffer\");\n+\n+                    Method nextEntry = historyC.getMethod(\"next\");\n+                    Method current = historyC.getMethod(\"current\");\n+                    while ((Boolean)(nextEntry.invoke(history))) {\n+                        String entry = (String)current.invoke(history);\n+                        if (!entry.equals(\"\")) {\n+                            addToHistory(commandCount, entry);\n+                        }\n+                        commandCount++;\n+                    }\n+\n+                    historyEnabled = true;\n+                    System.out.println(\"JLine history support is enabled\");\n+                } catch (Exception e) {\n+                    historyEnabled = false;\n+                    e.printStackTrace();\n+                    System.out.println(\"JLine history support is disabled\");\n+                }\n+\n+                String line;\n+                Method readLine = consoleC.getMethod(\"readLine\", String.class);\n+                while ((line = (String)readLine.invoke(console, getPrompt())) != null) {\n+                    executeLine(line);\n+                    if (historyEnabled) {\n+                        addHistory.invoke(history, line);\n+                        // flushHistory.invoke(history);\n+                    }\n+                }\n+            } catch (ClassNotFoundException e) {\n+                LOG.debug(\"Unable to start jline\", e);\n+                jlinemissing = true;\n+            } catch (NoSuchMethodException e) {\n+                LOG.debug(\"Unable to start jline\", e);\n+                jlinemissing = true;\n+            } catch (InvocationTargetException e) {\n+                LOG.debug(\"Unable to start jline\", e);\n+                jlinemissing = true;\n+            } catch (IllegalAccessException e) {\n+                LOG.debug(\"Unable to start jline\", e);\n+                jlinemissing = true;\n+            } catch (InstantiationException e) {\n+                LOG.debug(\"Unable to start jline\", e);\n+                jlinemissing = true;\n+            }\n+\n+            if (jlinemissing) {\n+                System.out.println(\"JLine support is disabled\");\n+                BufferedReader br =\n+                    new BufferedReader(new InputStreamReader(System.in));\n+\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    executeLine(line);\n+                }\n+            }\n+        }\n+\n+        inConsole = false;\n+        processCmd(cl);\n+        try {\n+            myCommands.get(EXIT).runCmd(new String[0]);\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        HedwigConsole console = new HedwigConsole(args);\n+        console.run();\n+    }\n+}"},{"sha":"c600a292549b51d9ae682d2dae0225ad27cf4f4a","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -0,0 +1,92 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.util.List;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.hedwig.admin.HedwigAdmin;\n+\n+import jline.Completor;\n+\n+import static org.apache.hedwig.admin.console.HedwigCommands.*;\n+\n+/**\n+ * A jline completor for hedwig console\n+ */\n+public class JLineHedwigCompletor implements Completor {\n+    private HedwigAdmin admin;\n+\n+    public JLineHedwigCompletor(HedwigAdmin admin) {\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    public int complete(String buffer, int cursor, List candidates) {\n+        // Guarantee that the final token is the one we're expanding\n+        buffer = buffer.substring(0,cursor);\n+        String[] tokens = buffer.split(\" \");\n+        if (buffer.endsWith(\" \")) {\n+            String[] newTokens = new String[tokens.length + 1];\n+            System.arraycopy(tokens, 0, newTokens, 0, tokens.length);\n+            newTokens[newTokens.length - 1] = \"\";\n+            tokens = newTokens;\n+        }\n+        \n+        if (tokens.length > 2 &&\n+            DESCRIBE.equalsIgnoreCase(tokens[0]) &&\n+            DESCRIBE_TOPIC.equalsIgnoreCase(tokens[1])) {\n+            return completeTopic(buffer, tokens[2], candidates);\n+        } else if (tokens.length > 1 &&\n+                   (SUB.equalsIgnoreCase(tokens[0]) ||\n+                    PUB.equalsIgnoreCase(tokens[0]) ||\n+                    CLOSESUB.equalsIgnoreCase(tokens[0]) ||\n+                    CONSUME.equalsIgnoreCase(tokens[0]) ||\n+                    CONSUMETO.equalsIgnoreCase(tokens[0]) ||\n+                    READTOPIC.equalsIgnoreCase(tokens[0]))) {\n+            return completeTopic(buffer, tokens[1], candidates);\n+        }\n+        List<String> cmds = HedwigCommands.findCandidateCommands(tokens);\n+        return completeCommand(buffer, tokens[tokens.length - 1], cmds, candidates);\n+    }\n+\n+    private int completeCommand(String buffer, String token,\n+            List<String> commands, List<String> candidates) {\n+        for (String cmd : commands) {\n+            if (cmd.startsWith(token)) {\n+                candidates.add(cmd);\n+            }\n+        }\n+        return buffer.lastIndexOf(\" \") + 1;\n+    }\n+\n+    private int completeTopic(String buffer, String token, List<String> candidates) {\n+        try {\n+            List<String> children = admin.getTopics();\n+            for (String child : children) {\n+                if (child.startsWith(token)) {\n+                    candidates.add(child);\n+                }\n+            }\n+        } catch (Exception e) {\n+            return buffer.length();\n+        }\n+        return candidates.size() == 0 ? buffer.length() : buffer.lastIndexOf(\" \") + 1;\n+    }\n+}"},{"sha":"cfea7f4cbd645520c2b5de4d8a2b67b0cfaa23b2","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","status":"added","additions":357,"deletions":0,"changes":357,"blob_url":"https://github.com/apache/bookkeeper/blob/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","raw_url":"https://github.com/apache/bookkeeper/raw/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java?ref=a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","patch":"@@ -0,0 +1,357 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.hedwig.admin.HedwigAdmin;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.RegionSpecificSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+/**\n+ * A tool to read topic messages.\n+ *\n+ * This tool :\n+ * 1) read persistence info from zookeeper: ledger ranges\n+ * 2) read subscription infor from zookeeper: we can know the least message id (ledger id) \n+ * 3) use bk client to read message starting from least message id\n+ */\n+public class ReadTopic {\n+    \n+    final HedwigAdmin admin;\n+    final ByteString topic;\n+    long startSeqId;\n+    long leastConsumedSeqId = Long.MAX_VALUE;\n+    final boolean inConsole;\n+\n+    static final int RC_OK = 0;\n+    static final int RC_ERROR = -1;\n+    static final int RC_NOTOPIC = -2;\n+    static final int RC_NOLEDGERS = -3;\n+    static final int RC_NOSUBSCRIBERS = -4;\n+    \n+    static final int NUM_MESSAGES_TO_PRINT = 15;\n+\n+    SortedMap<Long, InMemoryLedgerRange> ledgers = new TreeMap<Long, InMemoryLedgerRange>();\n+    SubscriptionState leastSubscriber = null;\n+    \n+    static class InMemoryLedgerRange {\n+        LedgerRange range;\n+        long startSeqIdIncluded;\n+        \n+        public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n+            this.range = range;\n+            this.startSeqIdIncluded = startSeqId;\n+        }\n+    }\n+    \n+    /**\n+     * Constructor\n+     */\n+    public ReadTopic(HedwigAdmin admin, ByteString topic, boolean inConsole) {\n+        this(admin, topic, 1, inConsole);\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public ReadTopic(HedwigAdmin admin, ByteString topic, long msgSeqId, boolean inConsole) {\n+        this.admin = admin;\n+        this.topic = topic;\n+        this.startSeqId = msgSeqId;\n+        this.inConsole = inConsole;\n+    }\n+    \n+    /**\n+     * Check whether the topic existed or not\n+     *\n+     * @return RC_OK if topic is existed; RC_NOTOPIC if not.\n+     * @throws Exception\n+     */\n+    protected int checkTopic() throws Exception {\n+        return admin.hasTopic(topic) ? RC_OK : RC_NOTOPIC;\n+    }\n+    \n+    /**\n+     * Get the ledgers used by this topic to store messages\n+     *\n+     * @return RC_OK if topic has messages; RC_NOLEDGERS if not.\n+     * @throws Exception\n+     */\n+    protected int getTopicLedgers() throws Exception {\n+        List<LedgerRange> ranges = admin.getTopicLedgers(topic); \n+        if (null == ranges || ranges.isEmpty()) {\n+            return RC_NOLEDGERS;\n+        }\n+        Iterator<LedgerRange> lrIterator = ranges.iterator();\n+        long startOfLedger = 1;\n+        while (lrIterator.hasNext()) {\n+            LedgerRange range = lrIterator.next();\n+            if (range.hasEndSeqIdIncluded()) {\n+                long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                ledgers.put(endOfLedger, new InMemoryLedgerRange(range, startOfLedger));\n+                startOfLedger = endOfLedger + 1;\n+                continue;\n+            }\n+            if (lrIterator.hasNext()) {\n+                throw new IOException(\"Ledger-id: \" + range.getLedgerId() + \" for topic: \" + topic\n+                        + \" is not the last one but still does not have an end seq-id\");\n+            }\n+            // admin has read last confirmed entry of last ledger\n+            // so we don't need to handle here\n+        }\n+        return RC_OK;\n+    }\n+    \n+    protected int getLeastSubscription() throws Exception {\n+        Map<ByteString, SubscriptionState> states = admin.getTopicSubscriptions(topic); \n+        if (states.isEmpty()) {\n+            return RC_NOSUBSCRIBERS;\n+        }\n+        for (Map.Entry<ByteString, SubscriptionState> entry : states.entrySet()) {\n+            SubscriptionState state = entry.getValue();\n+            long localMsgId = state.getMsgId().getLocalComponent();\n+            if (localMsgId < leastConsumedSeqId) {\n+                leastConsumedSeqId = localMsgId;\n+                this.leastSubscriber = state;\n+            }\n+        }\n+        if (leastConsumedSeqId == Long.MAX_VALUE) {\n+            leastConsumedSeqId = 0;\n+        }\n+        return RC_OK;\n+    }\n+    \n+    public void readTopic() {\n+        try {\n+            int rc = _readTopic();\n+            switch (rc) {\n+            case RC_NOTOPIC:\n+                System.err.println(\"No topic \" + topic + \" found.\");\n+                break;\n+            case RC_NOLEDGERS:\n+                System.err.println(\"No message is published to topic \" + topic);\n+                break;\n+            default:\n+                break;\n+            }\n+        } catch (Exception e) {\n+            System.err.println(\"ERROR: read messages of topic \" + topic + \" failed.\");\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    protected int _readTopic() throws Exception {\n+        int rc;\n+        // check topic\n+        rc = checkTopic();\n+        if (RC_OK != rc) {\n+            return rc;\n+        }\n+        // get topic ledgers\n+        rc = getTopicLedgers();\n+        if (RC_OK != rc) {\n+            return rc;\n+        }\n+        // get topic subscription to find the least one\n+        rc = getLeastSubscription();\n+        if (RC_NOSUBSCRIBERS == rc) {\n+            startSeqId = 1;\n+        } else if (RC_OK == rc) {\n+            if (leastConsumedSeqId > startSeqId) {\n+                startSeqId = leastConsumedSeqId + 1;\n+            }\n+        } else {\n+            return rc;\n+        }\n+        \n+        for (Map.Entry<Long, InMemoryLedgerRange> entry : ledgers.entrySet()) {\n+            long endSeqId = entry.getKey();\n+            if (endSeqId < startSeqId) {\n+                continue;\n+            }\n+            boolean toContinue = readLedger(entry.getValue(), endSeqId);\n+            startSeqId = endSeqId + 1;\n+            if (!toContinue) {\n+                break;\n+            }\n+        }\n+        \n+        return RC_OK;\n+    }\n+    \n+    /**\n+     * Read a specific ledger\n+     *\n+     * @param ledger in memory ledger range\n+     * @param endSeqId end seq id\n+     * @return true if continue, otherwise false\n+     * @throws BKException\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    protected boolean readLedger(InMemoryLedgerRange ledger, long endSeqId) throws BKException, IOException, InterruptedException {\n+        long tEndSeqId = endSeqId;\n+        \n+        if (tEndSeqId < this.startSeqId) {\n+            return true;\n+        }\n+        // Open Ledger Handle\n+        long ledgerId = ledger.range.getLedgerId();\n+        System.out.println(\"\\n>>>>> Ledger \" + ledgerId + \" [ \" + ledger.startSeqIdIncluded + \" ~ \" + (endSeqId == Long.MAX_VALUE ? \"\" : endSeqId) + \"] <<<<<\\n\");\n+        LedgerHandle lh = null;\n+        try {\n+            lh = admin.getBkHandle().openLedgerNoRecovery(ledgerId, admin.getBkDigestType(), admin.getBkPasswd());\n+        } catch (BKException e) {\n+            System.err.println(\"ERROR: No ledger \" + ledgerId + \" found. maybe garbage collected due to the messages are consumed.\");\n+        }\n+        if (null == lh) {\n+            return true;\n+        }\n+        long expectedEntryId = startSeqId - ledger.startSeqIdIncluded;\n+        \n+        long correctedEndSeqId = tEndSeqId;\n+        try {\n+            while (startSeqId <= tEndSeqId) {\n+                correctedEndSeqId = Math.min(startSeqId + NUM_MESSAGES_TO_PRINT - 1, tEndSeqId);\n+                \n+                try {\n+                    Enumeration<LedgerEntry> seq = lh.readEntries(startSeqId - ledger.startSeqIdIncluded, correctedEndSeqId - ledger.startSeqIdIncluded);\n+                    LedgerEntry entry = null;\n+                    while (seq.hasMoreElements()) {\n+                        entry = seq.nextElement();\n+                        Message message;\n+                        try {\n+                            message = Message.parseFrom(entry.getEntryInputStream());\n+                        } catch (IOException e) {\n+                            System.out.println(\"WARN: Unreadable message found\\n\");\n+                            expectedEntryId++;\n+                            continue;\n+                        }\n+                        if (expectedEntryId != entry.getEntryId()\n+                            || (message.getMsgId().getLocalComponent() - ledger.startSeqIdIncluded) != expectedEntryId) {\n+                            throw new IOException(\"ERROR: Message ids are out of order : expected entry id \" + expectedEntryId\n+                                                + \", current entry id \" + entry.getEntryId() + \", msg seq id \" + message.getMsgId().getLocalComponent());\n+                        }\n+                        expectedEntryId++;\n+                        formatMessage(message);\n+\n+                    }\n+                    startSeqId = correctedEndSeqId + 1;\n+                    if (inConsole) {\n+                        if (!pressKeyToContinue()) {\n+                            return false;\n+                        }\n+                    }\n+                } catch (BKException.BKReadException be) {\n+                    throw be;\n+                }\n+            }\n+        } catch (BKException bke) {\n+            if (tEndSeqId != Long.MAX_VALUE) {\n+                System.err.println(\"ERROR: ledger \" + ledgerId + \" may be corrupted, since read messages [\"\n+                                 + startSeqId + \" ~ \" + correctedEndSeqId + \" ] failed :\");\n+                throw bke;\n+            }\n+        }\n+        System.out.println(\"\\n\");\n+        return true;\n+    }\n+    \n+    protected void formatMessage(Message message) {\n+        // print msg id\n+        String msgId;\n+        if (!message.hasMsgId()) {\n+            msgId = \"N/A\";\n+        } else {\n+            MessageSeqId seqId = message.getMsgId();\n+            StringBuilder idBuilder = new StringBuilder();\n+            if (seqId.hasLocalComponent()) {\n+                idBuilder.append(\"LOCAL(\").append(seqId.getLocalComponent()).append(\")\");\n+            } else {\n+                List<RegionSpecificSeqId> remoteIds = seqId.getRemoteComponentsList();\n+                int i = 0, numRegions = remoteIds.size();\n+                idBuilder.append(\"REMOTE(\");\n+                for (RegionSpecificSeqId rssid : remoteIds) {\n+                    idBuilder.append(rssid.getRegion().toStringUtf8());\n+                    idBuilder.append(\"[\");\n+                    idBuilder.append(rssid.getSeqId());\n+                    idBuilder.append(\"]\");\n+                    ++i;\n+                    if (i < numRegions) {\n+                        idBuilder.append(\",\");\n+                    }\n+                }\n+                idBuilder.append(\")\");\n+            }\n+            msgId = idBuilder.toString();\n+        }\n+        System.out.println(\"---------- MSGID=\" + msgId + \" ----------\");\n+        System.out.println(\"MsgId:     \" + msgId);\n+        // print source region\n+        if (message.hasSrcRegion()) {\n+            System.out.println(\"SrcRegion: \" + message.getSrcRegion().toStringUtf8());\n+        } else {\n+            System.out.println(\"SrcRegion: N/A\");\n+        }\n+        // print message body\n+        System.out.println(\"Message:\");\n+        System.out.println();\n+        if (message.hasBody()) {\n+            System.out.println(message.getBody().toStringUtf8());\n+        } else {\n+            System.out.println(\"N/A\");\n+        }\n+        System.out.println();\n+    }\n+    \n+    boolean pressKeyToContinue() throws IOException {\n+        System.out.println(\"Press Y to continue...\");\n+        BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));\n+        int ch = stdin.read();\n+        if (ch == 'y' ||\n+            ch == 'Y') {\n+            return true;\n+        }\n+        return false;\n+    }\n+}"}]}

