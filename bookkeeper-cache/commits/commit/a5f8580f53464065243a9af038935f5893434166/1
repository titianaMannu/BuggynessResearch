{"sha":"a5f8580f53464065243a9af038935f5893434166","node_id":"MDY6Q29tbWl0MTU3NTk1NjphNWY4NTgwZjUzNDY0MDY1MjQzYTlhZjAzODkzNWY1ODkzNDM0MTY2","commit":{"author":{"name":"Samuel Just","email":"sjust@salesforce.com","date":"2017-08-01T06:34:07Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-08-01T06:34:07Z"},"message":"BOOKKEEPER-1102: Clarify BookieInfoReader and fix associated test flappers\n\nBookieInfoReader:\n\nThe previous syncronization logic wasn't really correct, and the logic\nat the top of the method was far more complicated than it needed to be.\nRestrict bookies to be non-null.  Restructure the code to simply use\nthe BookieInfoReader instance as a single lock.\n\nOne significant behavioral change is that we scan every bookie not in\nthe map, and we clear from the map bookies which returned an error.\n\nAlso, explicitely cache the most recent bookie set reported by the\nBookieWatcher.  This eliminates the need to call into BookieWatcher\nfrom getReadWriteBookieInfo and the corresponding error path.  The\nperiodic scan continues to explicitely check.\n\nAnother departure is the addition of an explicit retry-on-error param to\ntrigger retry if any of the requests failed\n(getBookieInfoRetryIntervalSeconds).  We'll only retry the ones that\nactually failed (along with any new additions since the last run).  This\nis useful because bookie startup triggers the addition of the bookie\nnode to zk before the bookie actually becomes available for the bookie\ninfo request, so there can be rare races in the unit tests between\nBookieInfoReader requesting the info and the bookie actually being up.\n\nAlso, add a method to allow tests to wait for updates to be reflected.\n\nPerChannelBookieClient: fix error handling for BookieInfo keys\n\nPassing a key corresponding to a GET_BOOKIE_INFO operation to\nerrorOutReadKey results in a casting exception, clean up the invalid\ncalls.\n\nBookKeeperClusterTestCase: add killBookieAndWaitForZK\n\nShould reduce the need for tests to wait for an arbitrary period to let\nthe cluster \"settle\".\n\nBookKeeperDiskSpaceWeightedLedgerPlacementTest:\n\nThis test was heavily time dependent, and the Thread.sleep values did\nnot work universally.  Instead, eliminate the arbitrary Thread.sleep\nvalues and instead verify the free space changes on each change.\n\nAlso, switch the delay on\ntestDiskSpaceWeightedBookieSelectionWithPeriodicBookieInfoUpdate\nto simply use an atomic boolean to signal the value switch.\n\nSigned-off-by: Samuel Just <sjustsalesforce.com>\n\nAuthor: Samuel Just <sjust@salesforce.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>\n\nThis patch had conflicts when merged, resolved by\nCommitter: Sijie Guo <sijie@apache.org>\n\nThis closes #275 from athanatos/forupstream/BOOKKEEPER-1102","tree":{"sha":"4dba2e3de7a6f79798c80b1d2d606fad0ec621a4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4dba2e3de7a6f79798c80b1d2d606fad0ec621a4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a5f8580f53464065243a9af038935f5893434166","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a5f8580f53464065243a9af038935f5893434166","html_url":"https://github.com/apache/bookkeeper/commit/a5f8580f53464065243a9af038935f5893434166","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a5f8580f53464065243a9af038935f5893434166/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"f581e030c79abbde81bf165603fccdb5e6a1d38a","url":"https://api.github.com/repos/apache/bookkeeper/commits/f581e030c79abbde81bf165603fccdb5e6a1d38a","html_url":"https://github.com/apache/bookkeeper/commit/f581e030c79abbde81bf165603fccdb5e6a1d38a"}],"stats":{"total":647,"additions":440,"deletions":207},"files":[{"sha":"c015efa1f49630fe26fd9138df9d5a7e83851180","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java","status":"modified","additions":260,"deletions":108,"changes":368,"blob_url":"https://github.com/apache/bookkeeper/blob/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java","raw_url":"https://github.com/apache/bookkeeper/raw/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java?ref=a5f8580f53464065243a9af038935f5893434166","patch":"@@ -17,15 +17,17 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.common.annotation.InterfaceAudience;\n@@ -53,13 +55,6 @@\n     private final ScheduledExecutorService scheduler;\n     private final BookKeeper bk;\n     private final ClientConfiguration conf;\n-    private ConcurrentMap<BookieSocketAddress, BookieInfo> bookieInfoMap = new ConcurrentHashMap<BookieSocketAddress, BookieInfo>();\n-    private Collection<BookieSocketAddress> bookies;\n-    private final AtomicInteger totalSent = new AtomicInteger();\n-    private final AtomicInteger completedCnt = new AtomicInteger();\n-    private final AtomicBoolean instanceRunning = new AtomicBoolean();\n-    private final AtomicBoolean isQueued = new AtomicBoolean();\n-    private final AtomicBoolean refreshBookieList = new AtomicBoolean();\n \n     /**\n      * A class represents the information (e.g. disk usage, load) of a bookie.\n@@ -91,121 +86,276 @@ public String toString() {\n         }\n     }\n \n+\n+    /**\n+     * Tracks the most recently reported set of bookies from BookieWatcher as well\n+     * as current BookieInfo for bookies we've successfully queried.\n+     */\n+    private static class BookieInfoMap {\n+        /**\n+         * Contains the most recently obtained information on the contained bookies.\n+         * When an error happens querying a bookie, the entry is removed.\n+         */\n+        private final Map<BookieSocketAddress, BookieInfo> infoMap = new HashMap<>();\n+\n+        /**\n+         * Contains the most recently reported set of bookies from BookieWatcher\n+         * A partial query consists of every member of mostRecentlyReportedBookies\n+         * minus the entries in bookieInfoMap.\n+         */\n+        private Collection<BookieSocketAddress> mostRecentlyReportedBookies = new ArrayList<>();\n+\n+        public void updateBookies(Collection<BookieSocketAddress> updatedBookieSet) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\n+                        \"updateBookies: current: {}, new: {}\",\n+                        mostRecentlyReportedBookies, updatedBookieSet);\n+            }\n+            infoMap.keySet().retainAll(updatedBookieSet);\n+            mostRecentlyReportedBookies = updatedBookieSet;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public Collection<BookieSocketAddress> getPartialScanTargets() {\n+            return CollectionUtils.subtract(mostRecentlyReportedBookies, infoMap.keySet());\n+        }\n+\n+        public Collection<BookieSocketAddress> getFullScanTargets() {\n+            return mostRecentlyReportedBookies;\n+        }\n+\n+        /**\n+         * Returns info for bookie, null if not known\n+         *\n+         * @param bookie bookie for which to get info\n+         * @return Info for bookie, null otherwise\n+         */\n+        public BookieInfo getInfo(BookieSocketAddress bookie) {\n+            return infoMap.get(bookie);\n+        }\n+\n+        /**\n+         * Removes bookie from bookieInfoMap\n+         *\n+         * @param bookie bookie on which we observed an error\n+         */\n+        public void clearInfo(BookieSocketAddress bookie) {\n+            infoMap.remove(bookie);\n+        }\n+\n+        /**\n+         * Report new info on bookie\n+         *\n+         * @param bookie bookie for which we obtained new info\n+         * @param info the new info\n+         */\n+        public void gotInfo(BookieSocketAddress bookie, BookieInfo info) {\n+            infoMap.put(bookie, info);\n+        }\n+\n+        /**\n+         * Get bookie info map\n+         */\n+        public Map<BookieSocketAddress, BookieInfo> getBookieMap() {\n+            return infoMap;\n+        }\n+    }\n+    private final BookieInfoMap bookieInfoMap = new BookieInfoMap();\n+\n+    /**\n+     * Tracks whether there is an execution in progress as well as whether\n+     * another is pending.\n+     */\n+    public enum State { UNQUEUED, PARTIAL, FULL }\n+    private static class InstanceState {\n+        private boolean running = false;\n+        private State queuedType = State.UNQUEUED;\n+\n+        private boolean shouldStart() {\n+            if (running) {\n+                return false;\n+            } else {\n+                running = true;\n+                return true;\n+            }\n+        }\n+\n+        /**\n+         * Mark pending operation FULL and return true if there is no in-progress operation\n+         *\n+         * @return True if we should execute a scan, False if there is already one running\n+         */\n+        public boolean tryStartFull() {\n+            queuedType = State.FULL;\n+            return shouldStart();\n+        }\n+\n+        /**\n+         * Mark pending operation PARTIAL if not full and return true if there is no in-progress operation\n+         *\n+         * @return True if we should execute a scan, False if there is already one running\n+         */\n+        public boolean tryStartPartial() {\n+            if (queuedType == State.UNQUEUED) {\n+                queuedType = State.PARTIAL;\n+            }\n+            return shouldStart();\n+        }\n+\n+        /**\n+         * Gets and clears queuedType\n+         */\n+        public State getAndClearQueuedType() {\n+            State ret = queuedType;\n+            queuedType = State.UNQUEUED;\n+            return ret;\n+        }\n+\n+        /**\n+         * If queuedType != UNQUEUED, returns true, leaves running equal to true\n+         * Otherwise, returns false and sets running to false\n+         */\n+        public boolean completeUnlessQueued() {\n+            if (queuedType == State.UNQUEUED) {\n+                running = false;\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+    private final InstanceState instanceState = new InstanceState();\n+\n     BookieInfoReader(BookKeeper bk,\n-                          ClientConfiguration conf,\n-                          ScheduledExecutorService scheduler) {\n+                     ClientConfiguration conf,\n+                     ScheduledExecutorService scheduler) {\n         this.bk = bk;\n         this.conf = conf;\n         this.scheduler = scheduler;\n     }\n-    void start() {\n+\n+    public void start() {\n         scheduler.scheduleAtFixedRate(new Runnable() {\n             @Override\n             public void run() {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Running periodic BookieInfo scan\");\n+                synchronized (BookieInfoReader.this) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Running periodic BookieInfo scan\");\n+                    }\n+                    try {\n+                        Collection<BookieSocketAddress> updatedBookies = bk.bookieWatcher.getBookies();\n+                        bookieInfoMap.updateBookies(updatedBookies);\n+                    } catch (BKException e) {\n+                        LOG.info(\"Got exception while querying bookies from watcher, rerunning after {}s\",\n+                                 conf.getGetBookieInfoRetryIntervalSeconds(), e);\n+                        scheduler.schedule(this, conf.getGetBookieInfoRetryIntervalSeconds(), TimeUnit.SECONDS);\n+                        return;\n+                    }\n+                    if (instanceState.tryStartFull()) {\n+                        getReadWriteBookieInfo();\n+                    }\n                 }\n-                getReadWriteBookieInfo(null);\n             }\n         }, 0, conf.getGetBookieInfoIntervalSeconds(), TimeUnit.SECONDS);\n     }\n-    void submitTask(final Collection<BookieSocketAddress> newBookies) {\n-        scheduler.submit(new Runnable() {\n-            @Override\n-            public void run() {\n-                getReadWriteBookieInfo(newBookies);\n-            }\n-        });\n+\n+    private void submitTask() {\n+        scheduler.submit(() -> getReadWriteBookieInfo());\n     }\n-    void availableBookiesChanged(Set<BookieSocketAddress> newBookies) {\n-        LOG.info(\"Scheduling bookie info read due to changes in available bookies.\");\n-        submitTask(newBookies);\n+\n+    private void submitTaskWithDelay(int delaySeconds) {\n+        scheduler.schedule(() -> getReadWriteBookieInfo(), delaySeconds, TimeUnit.SECONDS);\n     }\n \n-    /*\n-     * This routine is responsible for issuing bookieInfoGet messages to all the read write bookies.\n-     * instanceRunning will be true until we have sent the bookieInfoGet requests to\n-     * all the readwrite bookies and have processed all the callbacks. Only then is it reset to\n-     * false. At that time, if any pending tasks are queued, they are scheduled by the\n-     * last callback processing task. isQueued variable is used to indicate the pending\n-     * tasks. refreshBookieList is used to indicate that we need to read we need to explicitly\n-     * retireve the bookies list from zk because we don't remember the bookie list for\n-     * queued ops.\n+    synchronized void availableBookiesChanged(Set<BookieSocketAddress> updatedBookiesList) {\n+        if (LOG.isInfoEnabled()) {\n+            LOG.info(\"Scheduling bookie info read due to changes in available bookies.\");\n+        }\n+        bookieInfoMap.updateBookies(updatedBookiesList);\n+        if (instanceState.tryStartPartial()) {\n+            submitTask();\n+        }\n+    }\n+\n+    /**\n+     * Method to allow tests to block until bookie info is available\n+     *\n+     * @param bookie to lookup\n+     * @return None if absent, free disk space if present\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    void getReadWriteBookieInfo(Collection<BookieSocketAddress> newBookiesList) {\n-        if (!instanceRunning.get()) {\n-            instanceRunning.compareAndSet(false, true);\n+    synchronized Optional<Long> getFreeDiskSpace(BookieSocketAddress bookie) {\n+        BookieInfo bookieInfo = bookieInfoMap.getInfo(bookie);\n+        if (bookieInfo != null) {\n+            return Optional.of(bookieInfo.getFreeDiskSpace());\n         } else {\n-            isQueued.set(true);\n-            if (newBookiesList != null) {\n-                refreshBookieList.set(true);\n-            }\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /* State to track scan execution progress as callbacks come in */\n+    private int totalSent = 0;\n+    private int completedCnt = 0;\n+    private int errorCnt = 0;\n+\n+    /**\n+     * Performs scan described by instanceState using the cached bookie information\n+     * in bookieInfoMap.\n+     */\n+    synchronized void getReadWriteBookieInfo() {\n+        State queuedType = instanceState.getAndClearQueuedType();\n+        Collection<BookieSocketAddress> toScan;\n+        if (queuedType == State.FULL) {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Exiting due to running instance\");\n+                LOG.debug(\"Doing full scan\");\n             }\n-            return;\n-        }\n-        Collection<BookieSocketAddress> deadBookies = null, joinedBookies=null;\n-        if (newBookiesList == null) {\n-            try {\n-                if (this.bookies == null) {\n-                    joinedBookies = this.bookies = bk.bookieWatcher.getBookies();\n-                } else if (refreshBookieList.get()) {\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"Refreshing bookie list\");\n-                    }\n-                    newBookiesList = bk.bookieWatcher.getBookies();\n-                    refreshBookieList.set(false);\n-                } else {\n-                    // the bookie list is already up to date, just retrieve their info\n-                    joinedBookies = this.bookies;\n-                }\n-            } catch (BKException e) {\n-                LOG.error(\"Unable to get the available bookies \", e);\n-                onExit();\n-                return;\n+            toScan = bookieInfoMap.getFullScanTargets();\n+        } else if (queuedType == State.PARTIAL) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Doing partial scan\");\n             }\n-        }\n-        if (newBookiesList != null) {\n-            if (this.bookies != null) {\n-                joinedBookies = CollectionUtils.subtract(newBookiesList, this.bookies);\n-                deadBookies = CollectionUtils.subtract(this.bookies, newBookiesList);\n-                for (BookieSocketAddress b : deadBookies) {\n-                    bookieInfoMap.remove(b);\n-                    this.bookies.remove(b);\n-                }\n-                this.bookies.addAll(joinedBookies);\n-            } else {\n-                joinedBookies = this.bookies = newBookiesList;\n+            toScan = bookieInfoMap.getPartialScanTargets();\n+        } else {\n+            if (LOG.isErrorEnabled()) {\n+                LOG.error(\"Invalid state, queuedType cannot be UNQUEUED in getReadWriteBookieInfo\");\n             }\n+            assert(queuedType != State.UNQUEUED);\n+            return;\n         }\n \n         BookieClient bkc = bk.getBookieClient();\n-        totalSent.set(0);\n-        completedCnt.set(0);\n+        final long requested = BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE |\n+                               BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE;\n+        totalSent = 0;\n+        completedCnt = 0;\n+        errorCnt = 0;\n+\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Getting bookie info for: {}\", joinedBookies);\n+            LOG.debug(\"Getting bookie info for: {}\", toScan);\n         }\n-        for (BookieSocketAddress b : joinedBookies) {\n-            bkc.getBookieInfo(b, GET_BOOKIE_INFO_REQUEST_FLAGS,\n+        for (BookieSocketAddress b : toScan) {\n+            bkc.getBookieInfo(b, requested,\n                     new GetBookieInfoCallback() {\n                         void processReadInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n-                            BookieSocketAddress b = (BookieSocketAddress) ctx;\n-                            if (rc != BKException.Code.OK) {\n-                                LOG.error(\"Reading bookie info from bookie {} failed due to error: {}.\", b, rc);\n-                                // if there was data earlier, don't overwrite it\n-                                // create a new one only if the key was missing\n-                                bookieInfoMap.putIfAbsent(b, new BookieInfo());\n-                            } else {\n-                                if (LOG.isDebugEnabled()) {\n-                                    LOG.debug(\"Bookie Info for bookie {} is {}\", b, bInfo);\n+                            synchronized (BookieInfoReader.this) {\n+                                BookieSocketAddress b = (BookieSocketAddress) ctx;\n+                                if (rc != BKException.Code.OK) {\n+                                    if (LOG.isErrorEnabled()) {\n+                                        LOG.error(\"Reading bookie info from bookie {} failed due to error: {}.\", b, rc);\n+                                    }\n+                                    // We reread bookies missing from the map each time, so remove to ensure\n+                                    // we get to it on the next scan\n+                                    bookieInfoMap.clearInfo(b);\n+                                    errorCnt++;\n+                                } else {\n+                                    if (LOG.isDebugEnabled()) {\n+                                        LOG.debug(\"Bookie Info for bookie {} is {}\", b, bInfo);\n+                                    }\n+                                    bookieInfoMap.gotInfo(b, bInfo);\n+                                }\n+                                completedCnt++;\n+                                if (totalSent == completedCnt) {\n+                                    onExit();\n                                 }\n-                                bookieInfoMap.put(b, bInfo);\n-                            }\n-                            if (completedCnt.incrementAndGet() == totalSent.get()) {\n-                                bk.placementPolicy.updateBookieInfo(bookieInfoMap);\n-                                onExit();\n                             }\n                         }\n                         @Override\n@@ -219,27 +369,27 @@ public void run() {\n                                 });\n                         }\n                     }, b);\n-            totalSent.incrementAndGet();\n+            totalSent++;\n         }\n-        if (totalSent.get() == 0) {\n-            if (deadBookies != null) {\n-                // if no new bookies joined but some existing bookies went away\n-                // we need to inform the placementPloicy\n-                bk.placementPolicy.updateBookieInfo(bookieInfoMap);\n-            }\n+        if (totalSent == 0) {\n             onExit();\n         }\n     }\n \n     void onExit() {\n-        if (isQueued.get()) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Scheduling a queued task\");\n+        bk.placementPolicy.updateBookieInfo(bookieInfoMap.getBookieMap());\n+        if (errorCnt > 0) {\n+            if (LOG.isInfoEnabled()) {\n+                LOG.info(\"Rescheduling in {}s due to errors\", conf.getGetBookieInfoIntervalSeconds());\n             }\n-            submitTask(null);\n+            instanceState.tryStartPartial();\n+            submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());\n+        } else if (instanceState.completeUnlessQueued()) {\n+            if (LOG.isInfoEnabled()) {\n+                LOG.info(\"Rescheduling, another scan is pending\");\n+            }\n+            submitTask();\n         }\n-        isQueued.set(false);\n-        instanceRunning.set(false);\n     }\n \n     Map<BookieSocketAddress, BookieInfo> getBookieInfo() throws BKException, InterruptedException {\n@@ -262,7 +412,9 @@ void onExit() {\n                         public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n                             BookieSocketAddress b = (BookieSocketAddress) ctx;\n                             if (rc != BKException.Code.OK) {\n-                                LOG.error(\"Reading bookie info from bookie {} failed due to error: {}.\", b, rc);\n+                                if (LOG.isErrorEnabled()) {\n+                                    LOG.error(\"Reading bookie info from bookie {} failed due to error: {}.\", b, rc);\n+                                }\n                             } else {\n                                 if (LOG.isDebugEnabled()) {\n                                     LOG.debug(\"Free disk space on bookie {} is {}.\", b, bInfo.getFreeDiskSpace());"},{"sha":"8c2b260fea5a4adc974861a5db7bc26809c3ac1d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=a5f8580f53464065243a9af038935f5893434166","patch":"@@ -100,6 +100,7 @@\n     // Bookie info poll interval\n     protected final static String DISK_WEIGHT_BASED_PLACEMENT_ENABLED = \"diskWeightBasedPlacementEnabled\";\n     protected final static String GET_BOOKIE_INFO_INTERVAL_SECONDS = \"getBookieInfoIntervalSeconds\";\n+    protected final static String GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS = \"getBookieInfoRetryIntervalSeconds\";\n     protected final static String BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT = \"bookieMaxMultipleForWeightBasedPlacement\";\n     protected final static String GET_BOOKIE_INFO_TIMEOUT_SECS = \"getBookieInfoTimeoutSecs\";\n \n@@ -1239,6 +1240,16 @@ public int getGetBookieInfoIntervalSeconds() {\n         return getInt(GET_BOOKIE_INFO_INTERVAL_SECONDS, 24*60*60);\n     }\n \n+    /**\n+     * Get the time interval between retries on unsuccessful bookie info request.  Default is\n+     * 60s.\n+     *\n+     * @return\n+     */\n+    public int getGetBookieInfoRetryIntervalSeconds() {\n+        return getInt(GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS, 60);\n+    }\n+\n     /**\n      * Return whether disk weight based placement policy is enabled\n      * @return\n@@ -1286,6 +1297,19 @@ public ClientConfiguration setGetBookieInfoIntervalSeconds(int pollInterval, Tim\n         return this;\n     }\n \n+    /**\n+     * Set the time interval between retries on unsuccessful GetInfo requests\n+     *\n+     *\n+     * @param interval\n+     * @param unit\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setGetBookieInfoRetryIntervalSeconds(int interval, TimeUnit unit) {\n+        setProperty(GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS, unit.toSeconds(interval));\n+        return this;\n+    }\n+\n     /**\n      * Set the max multiple to use for nodes with very high weight\n      * @param multiple"},{"sha":"d2f4dc5f4dd31226c98f34bae8d7579b389e052e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=a5f8580f53464065243a9af038935f5893434166","patch":"@@ -869,7 +869,7 @@ public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object\n \n         final Channel c = channel;\n         if (c == null) {\n-            errorOutReadKey(completionKey);\n+            errorOutGetBookieInfoKey(completionKey);\n             return;\n         }\n \n@@ -888,13 +888,13 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                             LOG.warn(\"Writing GetBookieInfoRequest(flags={}) to channel {} failed : \",\n                                     new Object[] { requested, c, future.cause() });\n                         }\n-                        errorOutReadKey(completionKey);\n+                        errorOutGetBookieInfoKey(completionKey);\n                     }\n                 }\n             });\n         } catch(Throwable e) {\n             LOG.warn(\"Get metadata operation {} failed\", getBookieInfoRequest, e);\n-            errorOutReadKey(completionKey);\n+            errorOutGetBookieInfoKey(completionKey);\n         }\n     }\n \n@@ -1136,6 +1136,9 @@ void errorOutOutstandingEntries(int rc) {\n                 case READ_ENTRY:\n                     errorOutReadKey(key, rc);\n                     break;\n+                case GET_BOOKIE_INFO:\n+                    errorOutGetBookieInfoKey(key, rc);\n+                    break;\n                 default:\n                     break;\n             }"},{"sha":"3bc612ea713468143bdc64ee38b99ddbbd929fd2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperDiskSpaceWeightedLedgerPlacementTest.java","status":"modified","additions":130,"deletions":96,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperDiskSpaceWeightedLedgerPlacementTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperDiskSpaceWeightedLedgerPlacementTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperDiskSpaceWeightedLedgerPlacementTest.java?ref=a5f8580f53464065243a9af038935f5893434166","patch":"@@ -20,9 +20,12 @@\n *\n */\n \n+import java.io.IOException;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n@@ -32,6 +35,7 @@\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.zookeeper.KeeperException;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -43,58 +47,90 @@\n  */\n public class BookKeeperDiskSpaceWeightedLedgerPlacementTest extends BookKeeperClusterTestCase {\n     private final static Logger LOG = LoggerFactory.getLogger(BookKeeperDiskSpaceWeightedLedgerPlacementTest.class);\n+    private final static long MS_WEIGHT_UPDATE_TIMEOUT = 30000;\n \n     public BookKeeperDiskSpaceWeightedLedgerPlacementTest() {\n         super(10);\n     }\n-    \n-    private BookieServer restartBookie(ServerConfiguration conf, final long initialFreeDiskSpace,\n-            final long finallFreeDiskSpace, final int delaySecs) throws Exception {\n+\n+    class BookKeeperCheckInfoReader extends BookKeeper {\n+        BookKeeperCheckInfoReader(ClientConfiguration conf) throws KeeperException, IOException, InterruptedException {\n+            super(conf);\n+        }\n+\n+        void blockUntilBookieWeightIs(BookieSocketAddress bookie, Optional<Long> target) throws InterruptedException {\n+            long startMsecs = System.currentTimeMillis();\n+            Optional<Long> freeDiskSpace = Optional.empty();\n+            while (System.currentTimeMillis() < (startMsecs + MS_WEIGHT_UPDATE_TIMEOUT)) {\n+                freeDiskSpace = bookieInfoReader.getFreeDiskSpace(bookie);\n+                if (freeDiskSpace.equals(target)) {\n+                    return;\n+                }\n+                Thread.sleep(1000);\n+            }\n+            fail(String.format(\n+                    \"Server %s still has weight %s rather than %s\",\n+                    bookie.toString(), freeDiskSpace.toString(), target.toString()));\n+        }\n+    }\n+\n+    private BookieServer restartBookie(\n+            BookKeeperCheckInfoReader client, ServerConfiguration conf, final long initialFreeDiskSpace,\n+            final long finalFreeDiskSpace, final AtomicBoolean useFinal) throws Exception {\n+        final AtomicBoolean ready = useFinal == null ? new AtomicBoolean(false) : useFinal;\n         Bookie bookieWithCustomFreeDiskSpace = new Bookie(conf) {\n             long startTime = System.currentTimeMillis();\n             @Override\n             public long getTotalFreeSpace() {\n                 if (startTime == 0) {\n                     startTime = System.currentTimeMillis();\n                 }\n-                if (delaySecs == 0 || ((System.currentTimeMillis()) - startTime < delaySecs*1000)) {\n+                if (!ready.get()) {\n                     return initialFreeDiskSpace;\n                 } else {\n-                    // after delaySecs, advertise finallFreeDiskSpace; before that advertise initialFreeDiskSpace\n-                    return finallFreeDiskSpace;\n+                    // after delaySecs, advertise finalFreeDiskSpace; before that advertise initialFreeDiskSpace\n+                    return finalFreeDiskSpace;\n                 }\n             }\n         };\n         bsConfs.add(conf);\n         BookieServer server = startBookie(conf, bookieWithCustomFreeDiskSpace);\n         bs.add(server);\n+        client.blockUntilBookieWeightIs(server.getLocalAddress(), Optional.of(initialFreeDiskSpace));\n+        if (useFinal == null) {\n+            ready.set(true);\n+        }\n         return server;\n     }\n \n-    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(int bookieIdx, final long freeDiskSpace)\n+    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(\n+            BookKeeperCheckInfoReader client,\n+            int bookieIdx, final long freeDiskSpace)\n             throws Exception {\n-        LOG.info(\"Killing bookie \" + bs.get(bookieIdx).getLocalAddress());\n-        bs.get(bookieIdx).getLocalAddress();\n-        ServerConfiguration conf = killBookie(bookieIdx);\n-        return restartBookie(conf, freeDiskSpace, freeDiskSpace, 0);\n+        return replaceBookieWithCustomFreeDiskSpaceBookie(client, bookieIdx, freeDiskSpace, freeDiskSpace, null);\n     }\n \n-    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(BookieServer bookie, final long freeDiskSpace)\n+    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(\n+            BookKeeperCheckInfoReader client,\n+            BookieServer bookie, final long freeDiskSpace)\n             throws Exception {\n         for (int i=0; i < bs.size(); i++) {\n             if (bs.get(i).getLocalAddress().equals(bookie.getLocalAddress())) {\n-                return replaceBookieWithCustomFreeDiskSpaceBookie(i, freeDiskSpace);\n+                return replaceBookieWithCustomFreeDiskSpaceBookie(client, i, freeDiskSpace);\n             }\n         }\n         return null;\n     }\n \n-    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(int bookieIdx, long initialFreeDiskSpace,\n-             long finalFreeDiskSpace, int delay) throws Exception {\n-        LOG.info(\"Killing bookie \" + bs.get(bookieIdx).getLocalAddress());\n-        bs.get(bookieIdx).getLocalAddress();\n-        ServerConfiguration conf = killBookie(bookieIdx);\n-        return restartBookie(conf, initialFreeDiskSpace, finalFreeDiskSpace, delay);\n+    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(\n+            BookKeeperCheckInfoReader client,\n+            int bookieIdx, long initialFreeDiskSpace,\n+             long finalFreeDiskSpace, AtomicBoolean useFinal) throws Exception {\n+        BookieSocketAddress addr = bs.get(bookieIdx).getLocalAddress();\n+        LOG.info(\"Killing bookie {}\", addr);\n+        ServerConfiguration conf = killBookieAndWaitForZK(bookieIdx);\n+        client.blockUntilBookieWeightIs(addr, Optional.empty());\n+        return restartBookie(client, conf, initialFreeDiskSpace, finalFreeDiskSpace, useFinal);\n     }\n \n     /**\n@@ -104,26 +140,27 @@ private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(int bookieIdx, l\n     public void testDiskSpaceWeightedBookieSelection() throws Exception {\n         long freeDiskSpace=1000000L;\n         int multiple=3;\n+\n+        ClientConfiguration conf = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString())\n+                .setDiskWeightBasedPlacementEnabled(true)\n+                .setGetBookieInfoRetryIntervalSeconds(1, TimeUnit.SECONDS)\n+                .setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        final BookKeeperCheckInfoReader client = new BookKeeperCheckInfoReader(conf);\n+\n         for (int i=0; i < numBookies; i++) {\n             // the first 8 bookies have freeDiskSpace of 1MB; While the remaining 2 have 3MB\n             if (i < numBookies-2) {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client, 0, freeDiskSpace);\n             } else {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, multiple*freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client, 0, multiple*freeDiskSpace);\n             }\n         }\n         Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n \n-        // wait a 100 msecs each for the bookies to come up and the bookieInfo to be retrieved by the client\n-        ClientConfiguration conf = new ClientConfiguration()\n-            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n-            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n-        Thread.sleep(200);\n-        final BookKeeper client = new BookKeeper(conf);\n-        Thread.sleep(200);\n         for (int i = 0; i < 2000; i++) {\n             LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n             for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n@@ -149,26 +186,27 @@ public void testDiskSpaceWeightedBookieSelection() throws Exception {\n     public void testDiskSpaceWeightedBookieSelectionWithChangingWeights() throws Exception {\n         long freeDiskSpace=1000000L;\n         int multiple=3;\n+\n+        ClientConfiguration conf = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString())\n+                .setDiskWeightBasedPlacementEnabled(true)\n+                .setGetBookieInfoRetryIntervalSeconds(1, TimeUnit.SECONDS)\n+                .setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        final BookKeeperCheckInfoReader client = new BookKeeperCheckInfoReader(conf);\n+\n         for (int i=0; i < numBookies; i++) {\n             // the first 8 bookies have freeDiskSpace of 1MB; While the remaining 2 have 3MB\n             if (i < numBookies-2) {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client,0, freeDiskSpace);\n             } else {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, multiple*freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client,0, multiple*freeDiskSpace);\n             }\n         }\n         Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n \n-        // wait a 100 msecs each for the bookies to come up and the bookieInfo to be retrieved by the client\n-        ClientConfiguration conf = new ClientConfiguration()\n-            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n-            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n-        Thread.sleep(100);\n-        final BookKeeper client = new BookKeeper(conf);\n-        Thread.sleep(100);\n         for (int i = 0; i < 2000; i++) {\n             LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n             for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n@@ -192,12 +230,11 @@ public void testDiskSpaceWeightedBookieSelectionWithChangingWeights() throws Exc\n         BookieServer server3 = bs.get(numBookies-2);\n         BookieServer server4 = bs.get(numBookies-1);\n \n-        server1 = replaceBookieWithCustomFreeDiskSpaceBookie(server1, multiple*freeDiskSpace);\n-        server2 = replaceBookieWithCustomFreeDiskSpaceBookie(server2, multiple*freeDiskSpace);\n-        server3 = replaceBookieWithCustomFreeDiskSpaceBookie(server3, freeDiskSpace);\n-        server4 = replaceBookieWithCustomFreeDiskSpaceBookie(server4, freeDiskSpace);\n+        server1 = replaceBookieWithCustomFreeDiskSpaceBookie(client, server1, multiple*freeDiskSpace);\n+        server2 = replaceBookieWithCustomFreeDiskSpaceBookie(client, server2, multiple*freeDiskSpace);\n+        server3 = replaceBookieWithCustomFreeDiskSpaceBookie(client, server3, freeDiskSpace);\n+        server4 = replaceBookieWithCustomFreeDiskSpaceBookie(client, server4, freeDiskSpace);\n \n-        Thread.sleep(100);\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n@@ -231,26 +268,27 @@ public void testDiskSpaceWeightedBookieSelectionWithChangingWeights() throws Exc\n     public void testDiskSpaceWeightedBookieSelectionWithBookiesDying() throws Exception {\n         long freeDiskSpace=1000000L;\n         int multiple=3;\n+\n+        ClientConfiguration conf = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString())\n+                .setDiskWeightBasedPlacementEnabled(true)\n+                .setGetBookieInfoRetryIntervalSeconds(1, TimeUnit.SECONDS)\n+                .setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        final BookKeeperCheckInfoReader client = new BookKeeperCheckInfoReader(conf);\n+\n         for (int i=0; i < numBookies; i++) {\n             // the first 8 bookies have freeDiskSpace of 1MB; While the remaining 2 have 1GB\n             if (i < numBookies-2) {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client, 0, freeDiskSpace);\n             } else {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, multiple*freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client, 0, multiple*freeDiskSpace);\n             }\n         }\n         Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n \n-        // wait a couple of 100 msecs each for the bookies to come up and the bookieInfo to be retrieved by the client\n-        ClientConfiguration conf = new ClientConfiguration()\n-            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n-            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n-        Thread.sleep(100);\n-        final BookKeeper client = new BookKeeper(conf);\n-        Thread.sleep(100);\n         for (int i = 0; i < 2000; i++) {\n             LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n             for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n@@ -272,11 +310,9 @@ public void testDiskSpaceWeightedBookieSelectionWithBookiesDying() throws Except\n         }\n         BookieServer server1 = bs.get(numBookies-2);\n         BookieServer server2 = bs.get(numBookies-1);\n-        killBookie(numBookies-1);\n-        killBookie(numBookies-2);\n+        killBookieAndWaitForZK(numBookies-1);\n+        killBookieAndWaitForZK(numBookies-2);\n \n-        // give some time for the cluster to become stable\n-        Thread.sleep(100);\n         for (int i = 0; i < 2000; i++) {\n             LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n             for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n@@ -307,25 +343,26 @@ public void testDiskSpaceWeightedBookieSelectionWithBookiesDying() throws Except\n     public void testDiskSpaceWeightedBookieSelectionWithBookiesBeingAdded() throws Exception {\n         long freeDiskSpace=1000000L;\n         int multiple=3;\n+\n+        ClientConfiguration conf = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString())\n+                .setDiskWeightBasedPlacementEnabled(true)\n+                .setGetBookieInfoRetryIntervalSeconds(1, TimeUnit.SECONDS)\n+                .setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        final BookKeeperCheckInfoReader client = new BookKeeperCheckInfoReader(conf);\n+\n         for (int i=0; i < numBookies; i++) {\n             // all the bookies have freeDiskSpace of 1MB\n-            replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+            replaceBookieWithCustomFreeDiskSpaceBookie(client, 0, freeDiskSpace);\n         }\n         // let the last two bookies be down initially\n-        ServerConfiguration conf1 = killBookie(numBookies-1);\n-        ServerConfiguration conf2 = killBookie(numBookies-2);\n+        ServerConfiguration conf1 = killBookieAndWaitForZK(numBookies-1);\n+        ServerConfiguration conf2 = killBookieAndWaitForZK(numBookies-2);\n         Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n \n-        // wait a bit for the bookies to come up and the bookieInfo to be retrieved by the client\n-        ClientConfiguration conf = new ClientConfiguration()\n-            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n-            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n-        Thread.sleep(100);\n-        final BookKeeper client = new BookKeeper(conf);\n-        Thread.sleep(100);\n         for (int i = 0; i < 2000; i++) {\n             LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n             for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n@@ -342,11 +379,9 @@ public void testDiskSpaceWeightedBookieSelectionWithBookiesBeingAdded() throws E\n         }\n \n         // bring up the two dead bookies; they'll also have 3X more free space than the rest of the bookies\n-        restartBookie(conf1, multiple*freeDiskSpace, multiple*freeDiskSpace, 0);\n-        restartBookie(conf2, multiple*freeDiskSpace, multiple*freeDiskSpace, 0);\n+        restartBookie(client, conf1, multiple*freeDiskSpace, multiple*freeDiskSpace, null);\n+        restartBookie(client, conf2, multiple*freeDiskSpace, multiple*freeDiskSpace, null);\n \n-        // give some time for the cluster to become stable\n-        Thread.sleep(100);\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n@@ -376,56 +411,55 @@ public void testDiskSpaceWeightedBookieSelectionWithBookiesBeingAdded() throws E\n     public void testDiskSpaceWeightedBookieSelectionWithPeriodicBookieInfoUpdate() throws Exception {\n         long freeDiskSpace=1000000L;\n         int multiple=3;\n+\n+        int updateIntervalSecs = 6;\n+         ClientConfiguration conf = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString())\n+                .setDiskWeightBasedPlacementEnabled(true)\n+                .setGetBookieInfoRetryIntervalSeconds(1, TimeUnit.SECONDS)\n+                .setBookieMaxWeightMultipleForWeightBasedPlacement(multiple)\n+                .setGetBookieInfoIntervalSeconds(updateIntervalSecs, TimeUnit.SECONDS);\n+        final BookKeeperCheckInfoReader client = new BookKeeperCheckInfoReader(conf);\n+\n+        AtomicBoolean useHigherValue = new AtomicBoolean(false);\n         for (int i=0; i < numBookies; i++) {\n             // the first 8 bookies have freeDiskSpace of 1MB; the remaining 2 will advertise 1MB for\n-            // the first 3 seconds but then they'll advertise 3MB after the first 3 seconds\n+            // the start of the test, and 3MB once useHigherValue is set\n             if (i < numBookies-2) {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(client, 0, freeDiskSpace);\n             } else {\n-                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace, multiple*freeDiskSpace, 2);\n+                replaceBookieWithCustomFreeDiskSpaceBookie(\n+                        client, 0, freeDiskSpace, multiple*freeDiskSpace, useHigherValue);\n             }\n         }\n         Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n         for (BookieServer b : bs) {\n             m.put(b.getLocalAddress(), 0);\n         }\n \n-        // the periodic bookieInfo is read once every 7 seconds\n-        int updateIntervalSecs = 6;\n-        ClientConfiguration conf = new ClientConfiguration()\n-            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n-            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple).\n-            setGetBookieInfoIntervalSeconds(updateIntervalSecs, TimeUnit.SECONDS);\n-        // wait a bit for the bookies to come up and the bookieInfo to be retrieved by the client\n-        Thread.sleep(100);\n-        final BookKeeper client = new BookKeeper(conf);\n-        Thread.sleep(100);\n-        long startMsecs = MathUtils.now();\n         for (int i = 0; i < 2000; i++) {\n             LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n             for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n                 m.put(b, m.get(b)+1);\n             }\n         }\n-        long elapsedMsecs = MathUtils.now() - startMsecs;\n \n-        // make sure that all the bookies are chosen pretty much uniformly\n-        int bookiesToCheck = numBookies-1;\n-        if (elapsedMsecs > updateIntervalSecs*1000) {\n-            // if this task longer than updateIntervalSecs, the weight for the last 2 bookies will be\n-            // higher, so skip checking them\n-            bookiesToCheck = numBookies-3;\n-        }\n-        for (int i=0; i < bookiesToCheck; i++) {\n+        for (int i=0; i < numBookies - 1; i++) {\n             double delta = Math.abs((double)m.get(bs.get(i).getLocalAddress())-(double)m.get(bs.get(i+1).getLocalAddress()));\n             delta = (delta*100)/(double)m.get(bs.get(i+1).getLocalAddress());\n             assertTrue(\"Weigheted placement is not honored: \" + delta, delta <= 30); // the deviation should be <30%\n         }\n \n-        if (elapsedMsecs < updateIntervalSecs*1000) {\n-            // sleep until periodic bookie info retrieval kicks in and it gets the updated\n-            // freeDiskSpace for the last 2 bookies\n-            Thread.sleep(updateIntervalSecs*1000 - elapsedMsecs);\n+\n+        // Sleep for double the time required to update the bookie infos, and then check each one\n+        useHigherValue.set(true);\n+        Thread.sleep(updateIntervalSecs * 1000);\n+        for (int i=0; i < numBookies; i++) {\n+            if (i < numBookies-2) {\n+                client.blockUntilBookieWeightIs(bs.get(i).getLocalAddress(), Optional.of(freeDiskSpace));\n+            } else {\n+                client.blockUntilBookieWeightIs(bs.get(i).getLocalAddress(), Optional.of(freeDiskSpace * multiple));\n+            }\n         }\n \n         for (BookieServer b : bs) {"},{"sha":"3b8d2a4cb393d0f0a2261655aa9425e02e0da06f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/a5f8580f53464065243a9af038935f5893434166/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=a5f8580f53464065243a9af038935f5893434166","patch":"@@ -321,6 +321,26 @@ public ServerConfiguration killBookie(int index) throws Exception {\n         return bsConfs.remove(index);\n     }\n \n+    /**\n+     * Kill bookie by index and verify that it's stopped\n+     *\n+     * @param index index of bookie to kill\n+     *\n+     * @return configuration of killed bookie\n+     */\n+    public ServerConfiguration killBookieAndWaitForZK(int index) throws Exception {\n+        if (index >= bs.size()) {\n+            throw new IOException(\"Bookie does not exist\");\n+        }\n+        BookieServer server = bs.get(index);\n+        ServerConfiguration ret = killBookie(index);\n+        while (zkc.exists(baseConf.getZkAvailableBookiesPath() + \"/\"\n+                + server.getLocalAddress().toString(), false) != null) {\n+            Thread.sleep(500);\n+        }\n+        return ret;\n+    }\n+\n     /**\n      * Sleep a bookie\n      *"}]}

