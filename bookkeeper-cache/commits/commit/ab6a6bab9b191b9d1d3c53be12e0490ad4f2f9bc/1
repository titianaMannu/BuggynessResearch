{"sha":"ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc","node_id":"MDY6Q29tbWl0MTU3NTk1NjphYjZhNmJhYjliMTkxYjlkMWQzYzUzYmUxMmUwNDkwYWQ0ZjJmOWJj","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-07-13T15:52:29Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-07-13T15:52:29Z"},"message":"BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1502806 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"627763e1c94d17e774c012a7e931461e10fb7295","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/627763e1c94d17e774c012a7e931461e10fb7295"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc","html_url":"https://github.com/apache/bookkeeper/commit/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"69af0463e916456c5610415b9a60b710d14d1132","url":"https://api.github.com/repos/apache/bookkeeper/commits/69af0463e916456c5610415b9a60b710d14d1132","html_url":"https://github.com/apache/bookkeeper/commit/69af0463e916456c5610415b9a60b710d14d1132"}],"stats":{"total":56,"additions":37,"deletions":19},"files":[{"sha":"17854b83be60baa8849930bb7bac0aa6d3b2e79f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc","patch":"@@ -44,6 +44,8 @@ Release 4.2.2 - Unreleased\n \n         BOOKKEEPER-579: TestSubAfterCloseSub was put in a wrong package (sijie via ivank)\n \n+\tBOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)\n+\n       hedwig-client:\n \n         BOOKKEEPER-598: Fails to compile - RESUBSCRIBE_EXCEPTION conflict (Matthew Farrellee via ivank)"},{"sha":"ba57aa06e3283c33a2c31c53b0241a1cbac03483","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"modified","additions":35,"deletions":19,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=ab6a6bab9b191b9d1d3c53be12e0490ad4f2f9bc","patch":"@@ -17,11 +17,9 @@\n  */\n package org.apache.hedwig.server.persistence;\n \n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.LinkedList;\n-import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n import java.util.SortedMap;\n@@ -30,33 +28,28 @@\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.hedwig.protocol.PubSubProtocol;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.protobuf.ByteString;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.exceptions.PubSubException.ServerNotResponsibleForTopicException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protoextensions.MessageIdUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n-import org.apache.hedwig.server.common.UnexpectedError;\n import org.apache.hedwig.server.jmx.HedwigJMXService;\n import org.apache.hedwig.server.jmx.HedwigMBeanInfo;\n import org.apache.hedwig.server.jmx.HedwigMBeanRegistry;\n-import org.apache.hedwig.server.persistence.ReadAheadCacheBean;\n import org.apache.hedwig.util.Callback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n \n public class ReadAheadCache implements PersistenceManager, HedwigJMXService {\n \n@@ -186,10 +179,12 @@ public ReadAheadCache start() {\n      * the real persistence manager.\n      */\n \n+    @Override\n     public long getSeqIdAfterSkipping(ByteString topic, long seqId, int skipAmount) {\n         return realPersistenceManager.getSeqIdAfterSkipping(topic, seqId, skipAmount);\n     }\n \n+    @Override\n     public MessageSeqId getCurrentSeqIdForTopic(ByteString topic) throws ServerNotResponsibleForTopicException {\n         return realPersistenceManager.getCurrentSeqIdForTopic(topic);\n     }\n@@ -203,6 +198,7 @@ public MessageSeqId getCurrentSeqIdForTopic(ByteString topic) throws ServerNotRe\n      * our callback on the return path\n      *\n      */\n+    @Override\n     public void persistMessage(PersistRequest request) {\n         // make a new PersistRequest object so that we can insert our own\n         // callback in the middle. Assign the original request as the context\n@@ -225,6 +221,7 @@ public void persistMessage(PersistRequest request) {\n          * In case there is a failure in persisting, just pass it to the\n          * original callback\n          */\n+        @Override\n         public void operationFailed(Object ctx, PubSubException exception) {\n             PersistRequest originalRequest = (PersistRequest) ctx;\n             Callback<PubSubProtocol.MessageSeqId> originalCallback = originalRequest.getCallback();\n@@ -237,6 +234,7 @@ public void operationFailed(Object ctx, PubSubException exception) {\n          * success, and then opportunistically treat the message as if it just\n          * came in through a scan\n          */\n+        @Override\n         public void operationFinished(Object ctx, PubSubProtocol.MessageSeqId resultOfOperation) {\n             PersistRequest originalRequest = (PersistRequest) ctx;\n \n@@ -283,6 +281,7 @@ public void safeRun() {\n      * 2. Scan - Since the scan needs to touch the cache, we will just enqueue\n      * the scan request and let the cache maintainer thread handle it.\n      */\n+    @Override\n     public void scanSingleMessage(ScanRequest request) {\n         // Let the scan requests be serialized through the queue\n         enqueueWithoutFailureByTopic(request.getTopic(),\n@@ -295,6 +294,7 @@ public void scanSingleMessage(ScanRequest request) {\n      * 3. Enqueue the request so that the cache maintainer thread can delete all\n      * message-ids older than the one specified\n      */\n+    @Override\n     public void deliveredUntil(ByteString topic, Long seqId) {\n         enqueueWithoutFailureByTopic(topic, new DeliveredUntil(topic, seqId));\n     }\n@@ -308,25 +308,30 @@ public void deliveredUntil(ByteString topic, Long seqId) {\n      * get aged out of the cache eventually. For now, there is no need to\n      * proactively remove those entries from the cache.\n      */\n+    @Override\n     public void consumedUntil(ByteString topic, Long seqId) {\n         realPersistenceManager.consumedUntil(topic, seqId);\n     }\n \n+    @Override\n     public void setMessageBound(ByteString topic, Integer bound) {\n         realPersistenceManager.setMessageBound(topic, bound);\n     }\n \n+    @Override\n     public void clearMessageBound(ByteString topic) {\n         realPersistenceManager.clearMessageBound(topic);\n     }\n \n+    @Override\n     public void consumeToBound(ByteString topic) {\n         realPersistenceManager.consumeToBound(topic);\n     }\n \n     /**\n      * Stop the readahead cache.\n      */\n+    @Override\n     public void stop() {\n         try {\n             keepRunning = false;\n@@ -439,6 +444,7 @@ public ReadAheadScanCallback(Queue<CacheKey> installedStubs, ByteString topic) {\n             this.topic = topic;\n         }\n \n+        @Override\n         public void messageScanned(Object ctx, Message message) {\n \n             // Any message we read is potentially useful for us, so lets first\n@@ -473,10 +479,12 @@ public void messageScanned(Object ctx, Message message) {\n \n         }\n \n+        @Override\n         public void scanFailed(Object ctx, Exception exception) {\n             enqueueDeleteOfRemainingStubs(exception);\n         }\n \n+        @Override\n         public void scanFinished(Object ctx, ReasonForFinish reason) {\n             // If the scan finished because no more messages are present, its ok\n             // to leave the stubs in place because they will get filled in as\n@@ -501,6 +509,7 @@ private void enqueueDeleteOfRemainingStubs(Exception reason) {\n     protected static class HashSetCacheKeyFactory implements Factory<Set<CacheKey>> {\n         protected final static HashSetCacheKeyFactory instance = new HashSetCacheKeyFactory();\n \n+        @Override\n         public Set<CacheKey> newInstance() {\n             return new HashSet<CacheKey>();\n         }\n@@ -509,6 +518,7 @@ private void enqueueDeleteOfRemainingStubs(Exception reason) {\n     protected static class TreeSetLongFactory implements Factory<SortedSet<Long>> {\n         protected final static TreeSetLongFactory instance = new TreeSetLongFactory();\n \n+        @Override\n         public SortedSet<Long> newInstance() {\n             return new TreeSet<Long>();\n         }\n@@ -527,7 +537,6 @@ protected void addMessageToCache(final CacheKey cacheKey,\n         logger.debug(\"Adding msg {} to readahead cache\", cacheKey);\n \n         CacheValue cacheValue;\n-\n         if ((cacheValue = cache.get(cacheKey)) == null) {\n             cacheValue = new CacheValue();\n             CacheValue oldValue = cache.putIfAbsent(cacheKey, cacheValue);\n@@ -539,11 +548,13 @@ protected void addMessageToCache(final CacheKey cacheKey,\n         }\n \n         CacheSegment segment = cacheSegment.get();\n-        int size = message.getBody().size();\n+        if (cacheValue.isStub()) { // update cache size only when cache value is a stub\n+            int size = message.getBody().size();\n \n-        // update the cache size\n-        segment.presentSegmentSize.addAndGet(size);\n-        presentCacheSize.addAndGet(size);\n+            // update the cache size\n+            segment.presentSegmentSize.addAndGet(size);\n+            presentCacheSize.addAndGet(size);\n+        }\n \n         synchronized (cacheValue) {\n             // finally add the message to the cache\n@@ -663,6 +674,7 @@ public ExceptionOnCacheKey(CacheKey cacheKey, Exception exception) {\n          * on the callbacks registered for that stub, and delete the entry from\n          * the cache\n          */\n+        @Override\n         public void performRequest() {\n             removeMessageFromCache(cacheKey, exception,\n                                    // maintainTimeIndex=\n@@ -696,6 +708,7 @@ public CancelScanRequestOp(CancelScanRequest request) {\n             this.request = request;\n         }\n \n+        @Override\n         public void performRequest() {\n             // cancel scan request\n             cancelScanRequest(request.getScanRequest());\n@@ -732,6 +745,7 @@ public ScanResponse(CacheKey cacheKey, Message message) {\n             this.message = message;\n         }\n \n+        @Override\n         public void performRequest() {\n             addMessageToCache(cacheKey, message, MathUtils.now());\n         }\n@@ -747,6 +761,7 @@ public DeliveredUntil(ByteString topic, Long seqId) {\n             this.seqId = seqId;\n         }\n \n+        @Override\n         public void performRequest() {\n             SortedSet<Long> orderedSeqIds = orderedIndexOnSeqId.get(topic);\n             if (orderedSeqIds == null) {\n@@ -795,6 +810,7 @@ public ScanRequestWrapper(ScanRequest request) {\n          * underlying persistence manager.\n          */\n \n+        @Override\n         public void performRequest() {\n \n             RangeScanRequest readAheadRequest = doReadAhead(request);\n@@ -805,7 +821,7 @@ public void performRequest() {\n             CacheValue cacheValue = cache.get(cacheKey);\n             if (null == cacheValue) {\n                 logger.error(\"Cache key {} is removed after installing stub when scanning.\", cacheKey);\n-                // reissue the request \n+                // reissue the request\n                 scanSingleMessage(request);\n                 return;\n             }"}]}

