{"sha":"b1c12c0f41b7c27b2452fef311f12077d771f431","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiMWMxMmMwZjQxYjdjMjdiMjQ1MmZlZjMxMWYxMjA3N2Q3NzFmNDMx","commit":{"author":{"name":"Ivan Kelly","email":"ivank@yahoo-inc.com","date":"2016-04-05T06:45:51Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-04-05T06:45:51Z"},"message":"BOOKKEEPER-901: Authentication framework\n\nAuthor: Ivan Kelly <ivank@yahoo-inc.com>\n\nReviewers: Sijie Guo<sijie@apache.org>\n\nCloses #23 from merlimat/authentication-framework and squashes the following commits:\n\naa01548 [Ivan Kelly] BOOKKEEPER-901: Add an authentication framework\nf930fbd [Ivan Kelly] BOOKKEEPER-794 BookkeeperProtocol.Response.status is completely ignored","tree":{"sha":"96d35a1c3ed84c969a61298a281fb785116c430b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/96d35a1c3ed84c969a61298a281fb785116c430b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b1c12c0f41b7c27b2452fef311f12077d771f431","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b1c12c0f41b7c27b2452fef311f12077d771f431","html_url":"https://github.com/apache/bookkeeper/commit/b1c12c0f41b7c27b2452fef311f12077d771f431","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b1c12c0f41b7c27b2452fef311f12077d771f431/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"e32c38890ffbd0291e24e2b3f2625374b27f1f67","url":"https://api.github.com/repos/apache/bookkeeper/commits/e32c38890ffbd0291e24e2b3f2625374b27f1f67","html_url":"https://github.com/apache/bookkeeper/commit/e32c38890ffbd0291e24e2b3f2625374b27f1f67"}],"stats":{"total":2903,"additions":2803,"deletions":100},"files":[{"sha":"eb67fd85d51034ea50755895239d73e1a9c1eac4","filename":"bookkeeper-server/pom.xml","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/pom.xml?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -262,6 +262,7 @@\n             <!-- exclude generated file //-->\n             <exclude>**/DataFormats.java</exclude>\n             <exclude>**/BookkeeperProtocol.java</exclude>\n+            <exclude>**/TestDataFormats.java</exclude>\n           </excludes>\n         </configuration>\n       </plugin>\n@@ -324,6 +325,14 @@\n                       <arg value=\"--java_out=src/main/java\" />\n                       <arg value=\"src/main/proto/DataFormats.proto\" />\n                     </exec>\n+                    <exec executable=\"protoc\" failonerror=\"true\">\n+                      <arg value=\"--java_out=src/main/java\" />\n+                      <arg value=\"src/main/proto/BookkeeperProtocol.proto\" />\n+                    </exec>\n+                    <exec executable=\"protoc\" failonerror=\"true\">\n+                      <arg value=\"--java_out=src/test/java\" />\n+                      <arg value=\"src/test/proto/TestDataFormats.proto\" />\n+                    </exec>\n                   </target>\n                 </configuration>\n                 <goals>"},{"sha":"d05c475f1226eb3824f240076ef28cc78917d086","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthProviderFactoryFactory.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthProviderFactoryFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthProviderFactoryFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthProviderFactoryFactory.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,111 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.auth;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ExtensionRegistry;\n+\n+\n+\n+public class AuthProviderFactoryFactory {\n+    static Logger LOG = LoggerFactory.getLogger(AuthProviderFactoryFactory.class);\n+\n+    public static BookieAuthProvider.Factory newBookieAuthProviderFactory(ServerConfiguration conf,\n+                                                                          ExtensionRegistry registry) throws IOException {\n+        String factoryClassName = conf.getBookieAuthProviderFactoryClass();\n+\n+        if (factoryClassName == null || factoryClassName.length() == 0) {\n+            return new NullBookieAuthProviderFactory();\n+        }\n+\n+        BookieAuthProvider.Factory factory = ReflectionUtils.newInstance(factoryClassName,\n+                                                                         BookieAuthProvider.Factory.class);\n+        factory.init(conf, registry);\n+        return factory;\n+    }\n+\n+    public static ClientAuthProvider.Factory newClientAuthProviderFactory(ClientConfiguration conf,\n+                                                                          ExtensionRegistry registry) throws IOException {\n+        String factoryClassName = conf.getClientAuthProviderFactoryClass();\n+\n+        if (factoryClassName == null || factoryClassName.length() == 0) {\n+            return new NullClientAuthProviderFactory();\n+        }\n+\n+        ClientAuthProvider.Factory factory = ReflectionUtils.newInstance(factoryClassName,\n+                                                                         ClientAuthProvider.Factory.class);\n+        factory.init(conf, registry);\n+        return factory;\n+    }\n+\n+    private final static String nullPluginName = \"NULLPlugin\";\n+\n+    private static class NullBookieAuthProviderFactory implements BookieAuthProvider.Factory {\n+        @Override\n+        public String getPluginName() {\n+            return nullPluginName;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {}\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              GenericCallback<Void> completeCb) {\n+            completeCb.operationComplete(BKException.Code.OK, null);\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {}\n+            };\n+        }\n+    }\n+\n+    private static class NullClientAuthProviderFactory implements ClientAuthProvider.Factory {\n+        @Override\n+        public String getPluginName() {\n+            return nullPluginName;\n+        }\n+\n+        @Override\n+        public void init(ClientConfiguration conf, ExtensionRegistry registry) {}\n+\n+        @Override\n+        public ClientAuthProvider newProvider(InetSocketAddress addr,\n+                                              GenericCallback<Void> completeCb) {\n+            completeCb.operationComplete(BKException.Code.OK, null);\n+            return new ClientAuthProvider() {\n+                public void init(GenericCallback<AuthMessage> cb) {}\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {}\n+            };\n+        }\n+    }\n+\n+}"},{"sha":"4fb7d07306f321197348161327169cc20222b48d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookieAuthProvider.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookieAuthProvider.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookieAuthProvider.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookieAuthProvider.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,83 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.auth;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+\n+import com.google.protobuf.ExtensionRegistry;\n+\n+/**\n+ * Bookie authentication provider interface.\n+ * This must be implemented by any party wishing to implement\n+ * an authentication mechanism for bookkeeper connections.\n+ */\n+public interface BookieAuthProvider {\n+    interface Factory {\n+        /**\n+         * Initialize the factory with the server configuration\n+         * and protobuf message registry. Implementors must\n+         * add any extention messages which contain the auth\n+         * payload, so that the server can decode auth messages\n+         * it receives from the client.\n+         */\n+        void init(ServerConfiguration conf,\n+                  ExtensionRegistry registry) throws IOException;\n+\n+        /**\n+         * Create a new instance of a bookie auth provider.\n+         * Each connection should get its own instance, as they\n+         * can hold connection specific state.\n+         * The completeCb is used to notify the server that\n+         * the authentication handshake is complete.\n+         * CompleteCb should be called only once.\n+         * If the authentication was successful, BKException.Code.OK\n+         * should be passed as the return code. Otherwise, another\n+         * error code should be passed.\n+         * If authentication fails, the server will close the\n+         * connection.\n+         * @param addr the address of the client being authenticated\n+         * @param completeCb callback to be notified when authentication\n+         *                   is complete.\n+         */\n+        BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                       GenericCallback<Void> completeCb);\n+\n+        /**\n+         * Get Auth provider plugin name.\n+         * Used as a sanity check to ensure that the bookie and the client.\n+         * are using the same auth provider.\n+         */\n+        String getPluginName();\n+    }\n+\n+    /**\n+     * Process a request from the client. cb will receive the next\n+     * message to be sent to the client. If there are no more messages\n+     * to send to the client, cb should not be called, and completeCb\n+     * must be called instead.\n+     */\n+    void process(AuthMessage m, GenericCallback<AuthMessage> cb);\n+}"},{"sha":"fba2264a7a53a6882595fcc27d89840a7a276dbb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/ClientAuthProvider.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/ClientAuthProvider.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/ClientAuthProvider.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/ClientAuthProvider.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,89 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.auth;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+\n+import com.google.protobuf.ExtensionRegistry;\n+\n+/**\n+ * Client authentication provider interface.\n+ * This must be implemented by any party wishing to implement\n+ * an authentication mechanism for bookkeeper connections.\n+ */\n+public interface ClientAuthProvider {\n+    interface Factory {\n+        /**\n+         * Initialize the factory with the client configuration\n+         * and protobuf message registry. Implementors must\n+         * add any extention messages which contain the auth\n+         * payload, so that the client can decode auth messages\n+         * it receives from the server.\n+         */\n+        void init(ClientConfiguration conf,\n+                  ExtensionRegistry registry) throws IOException;\n+\n+        /**\n+         * Create a new instance of a client auth provider.\n+         * Each connection should get its own instance, as they\n+         * can hold connection specific state.\n+         * The completeCb is used to notify the client that\n+         * the authentication handshake is complete.\n+         * CompleteCb should be called only once.\n+         * If the authentication was successful, BKException.Code.OK\n+         * should be passed as the return code. Otherwise, another\n+         * error code should be passed.\n+         * @param addr the address of the socket being authenticated\n+         * @param completeCb callback to be notified when authentication\n+         *                   is complete.\n+         */\n+        ClientAuthProvider newProvider(InetSocketAddress addr,\n+                                       GenericCallback<Void> completeCb);\n+\n+        /**\n+         * Get Auth provider plugin name.\n+         * Used as a sanity check to ensure that the bookie and the client.\n+         * are using the same auth provider.\n+         */\n+        String getPluginName();\n+    }\n+\n+    /**\n+     * Initiate the authentication. cb will receive the initial\n+     * authentication message which should be sent to the server.\n+     * cb may not be called if authentication is not requires. In\n+     * this case, completeCb should be called.\n+     */\n+    void init(GenericCallback<AuthMessage> cb);\n+\n+    /**\n+     * Process a response from the server. cb will receive the next\n+     * message to be sent to the server. If there are no more messages\n+     * to send to the server, cb should not be called, and completeCb\n+     * must be called instead.\n+     */\n+    void process(AuthMessage m, GenericCallback<AuthMessage> cb);\n+}"},{"sha":"194606917dcf252f9ada0ece2470bf841a9033e6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -208,8 +208,8 @@ public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddre\n             lh.handleUnrecoverableErrorDuringAdd(rc);\n             return;\n         default:\n-            LOG.warn(\"Write did not succeed: L{} E{} on {}\",\n-                     new Object[] { ledgerId, entryId, addr });\n+            LOG.warn(\"Write did not succeed: L{} E{} on {}, rc = {}\",\n+                     new Object[] { ledgerId, entryId, addr, rc });\n             lh.handleBookieFailure(addr, bookieIndex);\n             return;\n         }"},{"sha":"b8d738b04ba1d9c4a52f347aaec5e2b15728b57a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":40,"deletions":13,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -81,6 +81,9 @@\n     protected final static String ENABLE_TASK_EXECUTION_STATS = \"enableTaskExecutionStats\";\n     protected final static String TASK_EXECUTION_WARN_TIME_MICROS = \"taskExecutionWarnTimeMicros\";\n \n+    // Client auth provider factory class name\n+    protected final static String CLIENT_AUTH_PROVIDER_FACTORY_CLASS = \"clientAuthProviderFactoryClass\";\n+\n     /**\n      * Construct a default client-side configuration\n      */\n@@ -700,7 +703,7 @@ public ClientConfiguration setTaskExecutionWarnTimeMicros(long warnTime) {\n \n     /**\n      * Check if bookie health check is enabled.\n-     * \n+     *\n      * @return\n      */\n     public boolean isBookieHealthCheckEnabled() {\n@@ -709,15 +712,15 @@ public boolean isBookieHealthCheckEnabled() {\n \n     /**\n      * Enables the bookie health check.\n-     * \n+     *\n      * <p>\n      * If the number of read/write errors for a bookie exceeds {@link #getBookieErrorThresholdPerInterval()} per\n      * interval, that bookie is quarantined for {@link #getBookieQuarantineTimeSeconds()} seconds. During this\n      * quarantined period, the client will try not to use this bookie when creating new ensembles.\n      * </p>\n-     * \n+     *\n      * By default, the bookie health check is <b>disabled</b>.\n-     * \n+     *\n      * @return client configuration\n      */\n     public ClientConfiguration enableBookieHealthCheck() {\n@@ -727,7 +730,7 @@ public ClientConfiguration enableBookieHealthCheck() {\n \n     /**\n      * Get the bookie health check interval in seconds.\n-     * \n+     *\n      * @return\n      */\n     public int getBookieHealthCheckIntervalSeconds() {\n@@ -736,11 +739,11 @@ public int getBookieHealthCheckIntervalSeconds() {\n \n     /**\n      * Set the bookie health check interval. Default is 60 seconds.\n-     * \n+     *\n      * <p>\n      * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.\n      * </p>\n-     * \n+     *\n      * @param interval\n      * @param unit\n      * @return client configuration\n@@ -752,7 +755,7 @@ public ClientConfiguration setBookieHealthCheckInterval(int interval, TimeUnit u\n \n     /**\n      * Get the error threshold for a bookie to be quarantined.\n-     * \n+     *\n      * @return\n      */\n     public long getBookieErrorThresholdPerInterval() {\n@@ -762,11 +765,11 @@ public long getBookieErrorThresholdPerInterval() {\n     /**\n      * Set the error threshold per interval ({@link #getBookieHealthCheckIntervalSeconds()}) for a bookie before it is\n      * quarantined. Default is 100 errors per minute.\n-     * \n+     *\n      * <p>\n      * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.\n      * </p>\n-     * \n+     *\n      * @param threshold\n      * @param unit\n      * @return client configuration\n@@ -778,7 +781,7 @@ public ClientConfiguration setBookieErrorThresholdPerInterval(long thresholdPerI\n \n     /**\n      * Get the time for which a bookie will be quarantined.\n-     * \n+     *\n      * @return\n      */\n     public int getBookieQuarantineTimeSeconds() {\n@@ -787,11 +790,11 @@ public int getBookieQuarantineTimeSeconds() {\n \n     /**\n      * Set the time for which a bookie will be quarantined. Default is 30 minutes.\n-     * \n+     *\n      * <p>\n      * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.\n      * </p>\n-     * \n+     *\n      * @param quarantineTime\n      * @param unit\n      * @return client configuration\n@@ -800,4 +803,28 @@ public ClientConfiguration setBookieQuarantineTime(int quarantineTime, TimeUnit\n         setProperty(BOOKIE_QUARANTINE_TIME_SECONDS, unit.toSeconds(quarantineTime));\n         return this;\n     }\n+\n+    /**\n+     * Set the client authentication provider factory class name.\n+     * If this is not set, no authentication will be used\n+     *\n+     * @param factoryClass\n+     *          the client authentication provider factory class name\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setClientAuthProviderFactoryClass(\n+            String factoryClass) {\n+        setProperty(CLIENT_AUTH_PROVIDER_FACTORY_CLASS, factoryClass);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the client authentication provider factory class name. If this returns null, no authentication will take\n+     * place.\n+     *\n+     * @return the client authentication provider factory class name or null.\n+     */\n+    public String getClientAuthProviderFactoryClass() {\n+        return getString(CLIENT_AUTH_PROVIDER_FACTORY_CLASS, null);\n+    }\n }"},{"sha":"d77065031b988e64575d7f3bf8b6fe40f9090b06","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -122,6 +122,9 @@\n \n     protected final static String LEDGER_STORAGE_CLASS = \"ledgerStorageClass\";\n \n+    // Bookie auth provider factory class name\n+    protected final static String BOOKIE_AUTH_PROVIDER_FACTORY_CLASS = \"bookieAuthProviderFactoryClass\";\n+\n     /**\n      * Construct a default configuration object\n      */\n@@ -1566,4 +1569,25 @@ public void validate() throws ConfigurationException {\n         }\n     }\n \n+    /*\n+     * Set the bookie authentication provider factory class name.\n+     * If this is not set, no authentication will be used\n+     *\n+     * @param factoryClass\n+     *          the bookie authentication provider factory class name\n+     * @return void\n+     */\n+    public void setBookieAuthProviderFactoryClass(String factoryClass) {\n+        setProperty(BOOKIE_AUTH_PROVIDER_FACTORY_CLASS, factoryClass);\n+    }\n+\n+    /**\n+     * Get the bookie authentication provider factory class name.\n+     * If this returns null, no authentication will take place.\n+     *\n+     * @return the bookie authentication provider factory class name or null.\n+     */\n+    public String getBookieAuthProviderFactoryClass() {\n+        return getString(BOOKIE_AUTH_PROVIDER_FACTORY_CLASS, null);\n+    }\n }"},{"sha":"522bc0b285fd8e937df897c949d3d312e9269920","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","status":"added","additions":356,"deletions":0,"changes":356,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,356 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.DefaultExceptionEvent;\n+import org.jboss.netty.channel.ExceptionEvent;\n+\n+import org.apache.bookkeeper.auth.BookieAuthProvider;\n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class AuthHandler {\n+    static final Logger LOG = LoggerFactory.getLogger(AuthHandler.class);\n+\n+    static class ServerSideHandler extends SimpleChannelHandler {\n+        volatile boolean authenticated = false;\n+        final BookieAuthProvider.Factory authProviderFactory;\n+        BookieAuthProvider authProvider;\n+\n+        ServerSideHandler(BookieAuthProvider.Factory authProviderFactory) {\n+            this.authProviderFactory = authProviderFactory;\n+            authProvider = null;\n+        }\n+\n+        @Override\n+        public void channelOpen(ChannelHandlerContext ctx,\n+                                ChannelStateEvent e) throws Exception {\n+            LOG.info(\"Channel open {}\", ctx.getChannel());\n+            SocketAddress remote  = ctx.getChannel().getRemoteAddress();\n+            if (remote instanceof InetSocketAddress) {\n+                authProvider = authProviderFactory.newProvider((InetSocketAddress)remote,\n+                        new AuthHandshakeCompleteCallback());\n+            } else {\n+                LOG.error(\"Unknown socket type {} for {}\", remote.getClass(), remote);\n+            }\n+            super.channelOpen(ctx, e);\n+        }\n+\n+        @Override\n+        public void messageReceived(ChannelHandlerContext ctx,\n+                                    MessageEvent e)\n+                throws Exception {\n+            if (authProvider == null) {\n+                // close the channel, authProvider should only be\n+                // null if the other end of line is an InetSocketAddress\n+                // anything else is strange, and we don't want to deal\n+                // with it\n+                ctx.getChannel().close();\n+                return;\n+            }\n+\n+            Object event = e.getMessage();\n+            if (authenticated) {\n+                super.messageReceived(ctx, e);\n+            } else if (event instanceof BookieProtocol.AuthRequest) { // pre-PB-client\n+                BookieProtocol.AuthRequest req = (BookieProtocol.AuthRequest)event;\n+                assert (req.getOpCode() == BookieProtocol.AUTH);\n+                if (checkAuthPlugin(req.getAuthMessage(), ctx.getChannel())) {\n+                    authProvider.process(req.getAuthMessage(),\n+                                new AuthResponseCallbackLegacy(req, ctx.getChannel()));\n+                } else {\n+                    ctx.getChannel().close();\n+                }\n+            } else if (event instanceof BookieProtocol.Request) {\n+                BookieProtocol.Request req = (BookieProtocol.Request)event;\n+                if (req.getOpCode() == BookieProtocol.ADDENTRY) {\n+                    ctx.getChannel().write(\n+                            new BookieProtocol.AddResponse(\n+                                    req.getProtocolVersion(), BookieProtocol.EUA,\n+                                    req.getLedgerId(), req.getEntryId()));\n+                } else if (req.getOpCode() == BookieProtocol.READENTRY) {\n+                    ctx.getChannel().write(\n+                            new BookieProtocol.ReadResponse(\n+                                    req.getProtocolVersion(), BookieProtocol.EUA,\n+                                    req.getLedgerId(), req.getEntryId()));\n+                } else {\n+                    ctx.getChannel().close();\n+                }\n+            } else if (event instanceof BookkeeperProtocol.Request) { // post-PB-client\n+                BookkeeperProtocol.Request req = (BookkeeperProtocol.Request)event;\n+                if (req.getHeader().getOperation() == BookkeeperProtocol.OperationType.AUTH\n+                        && req.hasAuthRequest()\n+                        && checkAuthPlugin(req.getAuthRequest(), ctx.getChannel())) {\n+                    authProvider.process(req.getAuthRequest(),\n+                                         new AuthResponseCallback(req, ctx.getChannel()));\n+                } else {\n+                    BookkeeperProtocol.Response.Builder builder\n+                        = BookkeeperProtocol.Response.newBuilder()\n+                        .setHeader(req.getHeader())\n+                        .setStatus(BookkeeperProtocol.StatusCode.EUA);\n+\n+                    ctx.getChannel().write(builder.build());\n+                }\n+            } else {\n+                // close the channel, junk coming over it\n+                ctx.getChannel().close();\n+            }\n+        }\n+\n+        private boolean checkAuthPlugin(AuthMessage am, final Channel src) {\n+            if (!am.hasAuthPluginName()\n+                || !am.getAuthPluginName().equals(authProviderFactory.getPluginName())) {\n+                LOG.error(\"Received message from incompatible auth plugin. Local = {},\"\n+                          + \" Remote = {}, Channel = {}\",\n+                          authProviderFactory.getPluginName(), am.getAuthPluginName());\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        static class AuthResponseCallbackLegacy implements GenericCallback<AuthMessage> {\n+            final BookieProtocol.AuthRequest req;\n+            final Channel channel;\n+\n+            AuthResponseCallbackLegacy(BookieProtocol.AuthRequest req, Channel channel) {\n+                this.req = req;\n+                this.channel = channel;\n+            }\n+\n+            public void operationComplete(int rc, AuthMessage newam) {\n+                if (rc != BKException.Code.OK) {\n+                    LOG.error(\"Error processing auth message, closing connection\");\n+                    channel.close();\n+                    return;\n+                }\n+                channel.write(new BookieProtocol.AuthResponse(req.getProtocolVersion(),\n+                                                              newam));\n+            }\n+        }\n+\n+        static class AuthResponseCallback implements GenericCallback<AuthMessage> {\n+            final BookkeeperProtocol.Request req;\n+            final Channel channel;\n+\n+            AuthResponseCallback(BookkeeperProtocol.Request req, Channel channel) {\n+                this.req = req;\n+                this.channel = channel;\n+            }\n+\n+            public void operationComplete(int rc, AuthMessage newam) {\n+                BookkeeperProtocol.Response.Builder builder\n+                    = BookkeeperProtocol.Response.newBuilder()\n+                    .setHeader(req.getHeader());\n+\n+                if (rc != BKException.Code.OK) {\n+                    LOG.error(\"Error processing auth message, closing connection\");\n+\n+                    builder.setStatus(BookkeeperProtocol.StatusCode.EUA);\n+                    channel.write(builder.build());\n+                    channel.close();\n+                    return;\n+                } else {\n+                    builder.setStatus(BookkeeperProtocol.StatusCode.EOK)\n+                        .setAuthResponse(newam);\n+                    channel.write(builder.build());\n+                }\n+            }\n+        }\n+\n+        class AuthHandshakeCompleteCallback implements GenericCallback<Void> {\n+            @Override\n+            public void operationComplete(int rc, Void v) {\n+                if (rc == BKException.Code.OK) {\n+                    authenticated = true;\n+                } else {\n+                    LOG.debug(\"Authentication failed on server side\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static class ClientSideHandler extends SimpleChannelHandler {\n+        volatile boolean authenticated = false;\n+        final ClientAuthProvider.Factory authProviderFactory;\n+        ClientAuthProvider authProvider;\n+        AtomicLong transactionIdGenerator;\n+        Queue<MessageEvent> waitingForAuth = new ConcurrentLinkedQueue<MessageEvent>();\n+\n+        ClientSideHandler(ClientAuthProvider.Factory authProviderFactory,\n+                          AtomicLong transactionIdGenerator) {\n+            this.authProviderFactory = authProviderFactory;\n+            this.transactionIdGenerator = transactionIdGenerator;\n+            authProvider = null;\n+        }\n+\n+        @Override\n+        public void channelConnected(ChannelHandlerContext ctx,\n+                                     ChannelStateEvent e)\n+                throws Exception {\n+            SocketAddress remote  = ctx.getChannel().getRemoteAddress();\n+            if (remote instanceof InetSocketAddress) {\n+                authProvider = authProviderFactory.newProvider((InetSocketAddress)remote,\n+                        new AuthHandshakeCompleteCallback(ctx));\n+                authProvider.init(new AuthRequestCallback(ctx));\n+            } else {\n+                LOG.error(\"Unknown socket type {} for {}\", remote.getClass(), remote);\n+            }\n+            super.channelConnected(ctx, e);\n+        }\n+\n+        @Override\n+        public void messageReceived(ChannelHandlerContext ctx,\n+                                    MessageEvent e)\n+                throws Exception {\n+            assert (authProvider != null);\n+\n+            Object event = e.getMessage();\n+\n+            if (authenticated) {\n+                super.messageReceived(ctx, e);\n+            } else if (event instanceof BookkeeperProtocol.Response) {\n+                BookkeeperProtocol.Response resp = (BookkeeperProtocol.Response)event;\n+                if (resp.getHeader().getOperation() == BookkeeperProtocol.OperationType.AUTH) {\n+                    if (resp.getStatus() != BookkeeperProtocol.StatusCode.EOK) {\n+                        authenticationError(ctx, resp.getStatus().getNumber());\n+                    } else {\n+                        assert (resp.hasAuthResponse());\n+                        BookkeeperProtocol.AuthMessage am = resp.getAuthResponse();\n+                        authProvider.process(am, new AuthRequestCallback(ctx));\n+                    }\n+                } else {\n+                    // else just drop the message,\n+                    // we're not authenticated so nothing should be coming through\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void writeRequested(ChannelHandlerContext ctx,\n+                                   MessageEvent e)\n+                throws Exception {\n+            synchronized (waitingForAuth) {\n+                if (authenticated) {\n+                    super.writeRequested(ctx, e);\n+                } else if (e.getMessage() instanceof BookkeeperProtocol.Request) {\n+                    // let auth messages through, queue the rest\n+                    BookkeeperProtocol.Request req = (BookkeeperProtocol.Request)e.getMessage();\n+                    if (req.getHeader().getOperation()\n+                            == BookkeeperProtocol.OperationType.AUTH) {\n+                        super.writeRequested(ctx, e);\n+                    } else {\n+                        waitingForAuth.add(e);\n+                    }\n+                } // else just drop\n+            }\n+        }\n+\n+        long newTxnId() {\n+            return transactionIdGenerator.incrementAndGet();\n+        }\n+\n+        void authenticationError(ChannelHandlerContext ctx, int errorCode) {\n+            LOG.error(\"Error processing auth message, erroring connection {}\", errorCode);\n+            ctx.sendUpstream(new DefaultExceptionEvent(ctx.getChannel(),\n+                                     new AuthenticationException(\n+                                             \"Auth failed with error \" + errorCode)));\n+        }\n+\n+        class AuthRequestCallback implements GenericCallback<AuthMessage> {\n+            Channel channel;\n+            ChannelHandlerContext ctx;\n+\n+            AuthRequestCallback(ChannelHandlerContext ctx) {\n+                this.channel = ctx.getChannel();\n+                this.ctx = ctx;\n+            }\n+\n+            public void operationComplete(int rc, AuthMessage newam) {\n+                if (rc != BKException.Code.OK) {\n+                    authenticationError(ctx, rc);\n+                    return;\n+                }\n+\n+                BookkeeperProtocol.BKPacketHeader header\n+                    = BookkeeperProtocol.BKPacketHeader.newBuilder()\n+                    .setVersion(BookkeeperProtocol.ProtocolVersion.VERSION_THREE)\n+                    .setOperation(BookkeeperProtocol.OperationType.AUTH)\n+                    .setTxnId(newTxnId()).build();\n+                BookkeeperProtocol.Request.Builder builder\n+                    = BookkeeperProtocol.Request.newBuilder()\n+                    .setHeader(header)\n+                    .setAuthRequest(newam);\n+\n+                channel.write(builder.build());\n+            }\n+        }\n+\n+        class AuthHandshakeCompleteCallback implements GenericCallback<Void> {\n+            ChannelHandlerContext ctx;\n+            AuthHandshakeCompleteCallback(ChannelHandlerContext ctx) {\n+                this.ctx = ctx;\n+            }\n+\n+            @Override\n+            public void operationComplete(int rc, Void v) {\n+                if (rc == BKException.Code.OK) {\n+                    synchronized (waitingForAuth) {\n+                        authenticated = true;\n+                        MessageEvent e = waitingForAuth.poll();\n+                        while (e != null) {\n+                            ctx.sendDownstream(e);\n+                            e = waitingForAuth.poll();\n+                        }\n+                    }\n+                } else {\n+                    authenticationError(ctx, rc);\n+                    LOG.debug(\"Authentication failed on server side\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static class AuthenticationException extends IOException {\n+        AuthenticationException(String reason) {\n+            super(reason);\n+        }\n+    }\n+}"},{"sha":"d0052d63d7abf5218f5f11492dd9b701b9102a61","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":24,"deletions":8,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -28,8 +28,11 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -52,6 +55,7 @@\n \n import com.google.common.collect.Lists;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ExtensionRegistry;\n \n /**\n  * Implements the client-side part of the BookKeeper protocol.\n@@ -60,11 +64,18 @@\n public class BookieClient implements PerChannelBookieClientFactory {\n     static final Logger LOG = LoggerFactory.getLogger(BookieClient.class);\n \n-    final OrderedSafeExecutor executor;\n-    final ClientSocketChannelFactory channelFactory;\n+    // This is global state that should be across all BookieClients\n+    AtomicLong totalBytesOutstanding = new AtomicLong();\n+\n+    OrderedSafeExecutor executor;\n+    ClientSocketChannelFactory channelFactory;\n     final ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClientPool> channels =\n             new ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClientPool>();\n     final HashedWheelTimer requestTimer;\n+\n+    final private ClientAuthProvider.Factory authProviderFactory;\n+    final private ExtensionRegistry registry;\n+\n     private final ClientConfiguration conf;\n     private volatile boolean closed;\n     private final ReentrantReadWriteLock closeLock;\n@@ -73,17 +84,22 @@\n \n     private final long bookieErrorThresholdPerInterval;\n \n-    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n+    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory,\n+            OrderedSafeExecutor executor) throws IOException {\n         this(conf, channelFactory, executor, NullStatsLogger.INSTANCE);\n     }\n \n-    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor,\n-                        StatsLogger statsLogger) {\n+    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory,\n+                        OrderedSafeExecutor executor, StatsLogger statsLogger) throws IOException {\n         this.conf = conf;\n         this.channelFactory = channelFactory;\n         this.executor = executor;\n         this.closed = false;\n         this.closeLock = new ReentrantReadWriteLock();\n+\n+        this.registry = ExtensionRegistry.newInstance();\n+        this.authProviderFactory = AuthProviderFactoryFactory.newClientAuthProviderFactory(conf, registry);\n+\n         this.statsLogger = statsLogger;\n         this.numConnectionsPerBookie = conf.getNumChannelsPerBookie();\n         this.requestTimer = new HashedWheelTimer(\n@@ -120,8 +136,8 @@ private int getRc(int rc) {\n \n     @Override\n     public PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool) {\n-        return new PerChannelBookieClient(conf, executor, channelFactory, address,\n-                                          requestTimer, statsLogger, pcbcPool);\n+        return new PerChannelBookieClient(conf, executor, channelFactory, address, requestTimer, statsLogger,\n+                authProviderFactory, registry, pcbcPool);\n     }\n \n     private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object key) {\n@@ -133,7 +149,7 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n                     return null;\n                 }\n                 PerChannelBookieClientPool newClientPool =\n-                        new DefaultPerChannelBookieClientPool(this, addr, numConnectionsPerBookie);\n+                    new DefaultPerChannelBookieClientPool(this, addr, numConnectionsPerBookie);\n                 PerChannelBookieClientPool oldClientPool = channels.putIfAbsent(addr, newClientPool);\n                 if (null == oldClientPool) {\n                     clientPool = newClientPool;"},{"sha":"bb1b20727593f5949630a1d6e36dc0322bc05926","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":19,"deletions":2,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -28,6 +28,8 @@\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.auth.BookieAuthProvider;\n+import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.processor.RequestProcessor;\n import org.apache.zookeeper.KeeperException;\n import org.jboss.netty.bootstrap.ServerBootstrap;\n@@ -48,6 +50,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.protobuf.ExtensionRegistry;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n \n@@ -66,11 +69,21 @@\n     Object suspensionLock = new Object();\n     boolean suspended = false;\n \n+    final BookieAuthProvider.Factory authProviderFactory;\n+    final BookieProtoEncoding.ResponseEncoder responseEncoder;\n+    final BookieProtoEncoding.RequestDecoder requestDecoder;\n+\n     BookieNettyServer(ServerConfiguration conf, RequestProcessor processor)\n             throws IOException, KeeperException, InterruptedException, BookieException  {\n         this.conf = conf;\n         this.requestProcessor = processor;\n \n+        ExtensionRegistry registry = ExtensionRegistry.newInstance();\n+        authProviderFactory = AuthProviderFactoryFactory.newBookieAuthProviderFactory(conf, registry);\n+\n+        responseEncoder = new BookieProtoEncoding.ResponseEncoder(registry);\n+        requestDecoder = new BookieProtoEncoding.RequestDecoder(registry);\n+\n         ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n         String base = \"bookie-\" + conf.getBookiePort() + \"-netty\";\n         serverChannelFactory = new NioServerSocketChannelFactory(\n@@ -140,11 +153,15 @@ public ChannelPipeline getPipeline() throws Exception {\n                              new LengthFieldBasedFrameDecoder(maxMessageSize, 0, 4, 0, 4));\n             pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n \n-            pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.RequestDecoder());\n-            pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.ResponseEncoder());\n+            pipeline.addLast(\"bookieProtoDecoder\", requestDecoder);\n+            pipeline.addLast(\"bookieProtoEncoder\", responseEncoder);\n+            pipeline.addLast(\"bookieAuthHandler\",\n+                             new AuthHandler.ServerSideHandler(authProviderFactory));\n+\n             SimpleChannelHandler requestHandler = isRunning.get() ?\n                     new BookieRequestHandler(conf, requestProcessor, allChannels)\n                     : new RejectRequestHandler();\n+\n             pipeline.addLast(\"bookieRequestHandler\", requestHandler);\n             return pipeline;\n         }"},{"sha":"683a6fb95f6a04f4db0b82865de05a4e3f8f6e02","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"modified","additions":106,"deletions":19,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -20,29 +20,26 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.ExtensionRegistry;\n import com.google.protobuf.InvalidProtocolBufferException;\n+\n import org.jboss.netty.buffer.ChannelBufferFactory;\n import org.jboss.netty.buffer.ChannelBufferInputStream;\n+import org.jboss.netty.buffer.ChannelBufferOutputStream;\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelHandlerContext;\n-\n import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n import org.jboss.netty.handler.codec.oneone.OneToOneEncoder;\n import org.jboss.netty.handler.codec.oneone.OneToOneDecoder;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class BookieProtoEncoding {\n     private final static Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n \n-    static final EnDecoder REQ_PREV3 = new RequestEnDeCoderPreV3();\n-    static final EnDecoder REP_PREV3 = new ResponseEnDeCoderPreV3();\n-    static final EnDecoder REQ_V3 = new RequestEnDecoderV3();\n-    static final EnDecoder REP_V3 = new ResponseEnDecoderV3();\n-\n     static interface EnDecoder {\n \n         /**\n@@ -68,6 +65,12 @@\n     }\n \n     static class RequestEnDeCoderPreV3 implements EnDecoder {\n+        final ExtensionRegistry extensionRegistry;\n+\n+        RequestEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {\n+            this.extensionRegistry = extensionRegistry;\n+        }\n+\n         @Override\n         public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 throws Exception {\n@@ -83,8 +86,7 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n                 buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);\n                 return ChannelBuffers.wrappedBuffer(buf, ar.getData());\n-            } else {\n-                assert(r instanceof BookieProtocol.ReadRequest);\n+            } else if (r instanceof BookieProtocol.ReadRequest) {\n                 int totalHeaderSize = 4 // for request type\n                     + 8 // for ledgerId\n                     + 8; // for entryId\n@@ -101,6 +103,19 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 }\n \n                 return buf;\n+            } else if (r instanceof BookieProtocol.AuthRequest) {\n+                BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthRequest)r).getAuthMessage();\n+                int totalHeaderSize = 4; // for request type\n+                int totalSize = totalHeaderSize + am.getSerializedSize();\n+                ChannelBuffer buf = bufferFactory.getBuffer(totalSize);\n+                buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n+                                              r.getOpCode(),\n+                                              r.getFlags()).toInt());\n+                ChannelBufferOutputStream bufStream = new ChannelBufferOutputStream(buf);\n+                am.writeTo(bufStream);\n+                return buf;\n+            } else {\n+                return msg;\n             }\n         }\n \n@@ -141,12 +156,23 @@ public Object decode(ChannelBuffer packet)\n                 } else {\n                     return new BookieProtocol.ReadRequest(h.getVersion(), ledgerId, entryId, flags);\n                 }\n+            case BookieProtocol.AUTH:\n+                BookkeeperProtocol.AuthMessage.Builder builder\n+                    = BookkeeperProtocol.AuthMessage.newBuilder();\n+                builder.mergeFrom(new ChannelBufferInputStream(packet), extensionRegistry);\n+                return new BookieProtocol.AuthRequest(h.getVersion(), builder.build());\n             }\n             return packet;\n         }\n     }\n \n     static class ResponseEnDeCoderPreV3 implements EnDecoder {\n+        final ExtensionRegistry extensionRegistry;\n+\n+        ResponseEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {\n+            this.extensionRegistry = extensionRegistry;\n+        }\n+\n         @Override\n         public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 throws Exception {\n@@ -157,12 +183,13 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n             ChannelBuffer buf = bufferFactory.getBuffer(24);\n             buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n                                           r.getOpCode(), (short)0).toInt());\n-            buf.writeInt(r.getErrorCode());\n-            buf.writeLong(r.getLedgerId());\n-            buf.writeLong(r.getEntryId());\n \n             ServerStats.getInstance().incrementPacketsSent();\n             if (msg instanceof BookieProtocol.ReadResponse) {\n+                buf.writeInt(r.getErrorCode());\n+                buf.writeLong(r.getLedgerId());\n+                buf.writeLong(r.getEntryId());\n+\n                 BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse)r;\n                 if (rr.hasData()) {\n                     return ChannelBuffers.wrappedBuffer(buf,\n@@ -171,7 +198,15 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                     return buf;\n                 }\n             } else if (msg instanceof BookieProtocol.AddResponse) {\n+                buf.writeInt(r.getErrorCode());\n+                buf.writeLong(r.getLedgerId());\n+                buf.writeLong(r.getEntryId());\n+\n                 return buf;\n+            } else if (msg instanceof BookieProtocol.AuthResponse) {\n+                BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthResponse)r).getAuthMessage();\n+                return ChannelBuffers.wrappedBuffer(buf,\n+                        ChannelBuffers.wrappedBuffer(am.toByteArray()));\n             } else {\n                 LOG.error(\"Cannot encode unknown response type {}\", msg.getClass().getName());\n                 return msg;\n@@ -180,37 +215,54 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n         @Override\n         public Object decode(ChannelBuffer buffer)\n                 throws Exception {\n-            final int rc;\n-            final long ledgerId, entryId;\n+            int rc;\n+            long ledgerId, entryId;\n             final PacketHeader header;\n \n             header = PacketHeader.fromInt(buffer.readInt());\n-            rc = buffer.readInt();\n-            ledgerId = buffer.readLong();\n-            entryId = buffer.readLong();\n \n             switch (header.getOpCode()) {\n             case BookieProtocol.ADDENTRY:\n+                rc = buffer.readInt();\n+                ledgerId = buffer.readLong();\n+                entryId = buffer.readLong();\n                 return new BookieProtocol.AddResponse(header.getVersion(), rc, ledgerId, entryId);\n             case BookieProtocol.READENTRY:\n+                rc = buffer.readInt();\n+                ledgerId = buffer.readLong();\n+                entryId = buffer.readLong();\n+\n                 if (rc == BookieProtocol.EOK) {\n                     return new BookieProtocol.ReadResponse(header.getVersion(), rc,\n                                                            ledgerId, entryId, buffer.slice());\n                 } else {\n                     return new BookieProtocol.ReadResponse(header.getVersion(), rc,\n                                                            ledgerId, entryId);\n                 }\n+            case BookieProtocol.AUTH:\n+                ChannelBufferInputStream bufStream = new ChannelBufferInputStream(buffer);\n+                BookkeeperProtocol.AuthMessage.Builder builder\n+                    = BookkeeperProtocol.AuthMessage.newBuilder();\n+                builder.mergeFrom(bufStream, extensionRegistry);\n+                BookkeeperProtocol.AuthMessage am = builder.build();\n+                return new BookieProtocol.AuthResponse(header.getVersion(), am);\n             default:\n                 return buffer;\n             }\n         }\n     }\n \n     static class RequestEnDecoderV3 implements EnDecoder {\n+        final ExtensionRegistry extensionRegistry;\n+\n+        RequestEnDecoderV3(ExtensionRegistry extensionRegistry) {\n+            this.extensionRegistry = extensionRegistry;\n+        }\n \n         @Override\n         public Object decode(ChannelBuffer packet) throws Exception {\n-            return BookkeeperProtocol.Request.parseFrom(new ChannelBufferInputStream(packet));\n+            return BookkeeperProtocol.Request.parseFrom(new ChannelBufferInputStream(packet),\n+                                                        extensionRegistry);\n         }\n \n         @Override\n@@ -222,10 +274,16 @@ public Object encode(Object msg, ChannelBufferFactory factory) throws Exception\n     }\n \n     static class ResponseEnDecoderV3 implements EnDecoder {\n+        final ExtensionRegistry extensionRegistry;\n+\n+        ResponseEnDecoderV3(ExtensionRegistry extensionRegistry) {\n+            this.extensionRegistry = extensionRegistry;\n+        }\n \n         @Override\n         public Object decode(ChannelBuffer packet) throws Exception {\n-            return BookkeeperProtocol.Response.parseFrom(new ChannelBufferInputStream(packet));\n+            return BookkeeperProtocol.Response.parseFrom(new ChannelBufferInputStream(packet),\n+                                                         extensionRegistry);\n         }\n \n         @Override\n@@ -238,6 +296,14 @@ public Object encode(Object msg, ChannelBufferFactory factory) throws Exception\n \n     public static class RequestEncoder extends OneToOneEncoder {\n \n+        final EnDecoder REQ_PREV3;\n+        final EnDecoder REQ_V3;\n+\n+        RequestEncoder(ExtensionRegistry extensionRegistry) {\n+            REQ_PREV3 = new RequestEnDeCoderPreV3(extensionRegistry);\n+            REQ_V3 = new RequestEnDecoderV3(extensionRegistry);\n+        }\n+\n         @Override\n         protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 throws Exception {\n@@ -256,6 +322,13 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n     }\n \n     public static class RequestDecoder extends OneToOneDecoder {\n+        final EnDecoder REQ_PREV3;\n+        final EnDecoder REQ_V3;\n+\n+        RequestDecoder(ExtensionRegistry extensionRegistry) {\n+            REQ_PREV3 = new RequestEnDeCoderPreV3(extensionRegistry);\n+            REQ_V3 = new RequestEnDecoderV3(extensionRegistry);\n+        }\n \n         @Override\n         protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n@@ -283,6 +356,13 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n     }\n \n     public static class ResponseEncoder extends OneToOneEncoder {\n+        final EnDecoder REP_PREV3;\n+        final EnDecoder REP_V3;\n+\n+        ResponseEncoder(ExtensionRegistry extensionRegistry) {\n+            REP_PREV3 = new ResponseEnDeCoderPreV3(extensionRegistry);\n+            REP_V3 = new ResponseEnDecoderV3(extensionRegistry);\n+        }\n \n         @Override\n         protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n@@ -302,6 +382,13 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n     }\n \n     public static class ResponseDecoder extends OneToOneDecoder {\n+        final EnDecoder REP_PREV3;\n+        final EnDecoder REP_V3;\n+\n+        ResponseDecoder(ExtensionRegistry extensionRegistry) {\n+            REP_PREV3 = new ResponseEnDeCoderPreV3(extensionRegistry);\n+            REP_V3 = new ResponseEnDecoderV3(extensionRegistry);\n+        }\n \n         @Override\n         protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)"},{"sha":"2ce5ed891a21a17f0fae808ee73b13fda86a0cd5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -24,6 +24,8 @@\n import org.jboss.netty.buffer.ChannelBuffer;\n import java.nio.ByteBuffer;\n \n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+\n /**\n  * The packets of the Bookie protocol all have a 4-byte integer indicating the\n  * type of request or response at the very beginning of the packet followed by a\n@@ -132,6 +134,13 @@ short getFlags() {\n      */\n     public static final byte READENTRY = 2;\n \n+    /**\n+     * Auth message. This code is for passing auth messages between the auth\n+     * providers on the client and bookie. The message payload is determined\n+     * by the auth providers themselves.\n+     */\n+    public static final byte AUTH = 3;\n+\n     /**\n      * The error code that indicates success\n      */\n@@ -273,6 +282,19 @@ boolean isFencingRequest() {\n         }\n     }\n \n+    static class AuthRequest extends Request {\n+        final AuthMessage authMessage;\n+\n+        AuthRequest(byte protocolVersion, AuthMessage authMessage) {\n+            super(protocolVersion, AUTH, -1, -1, FLAG_NONE, null);\n+            this.authMessage = authMessage;\n+        }\n+\n+        AuthMessage getAuthMessage() {\n+            return authMessage;\n+        }\n+    }\n+\n     static class Response {\n         final byte protocolVersion;\n         final byte opCode;\n@@ -343,4 +365,18 @@ ChannelBuffer getData() {\n             super(protocolVersion, ADDENTRY, errorCode, ledgerId, entryId);\n         }\n     }\n+\n+    static class AuthResponse extends Response {\n+        final AuthMessage authMessage;\n+\n+        AuthResponse(byte protocolVersion, AuthMessage authMessage) {\n+            super(protocolVersion, AUTH, EOK, -1, -1);\n+            this.authMessage = authMessage;\n+        }\n+\n+        AuthMessage getAuthMessage() {\n+            return authMessage;\n+        }\n+    }\n+\n }"},{"sha":"1608328ccc68fe9c234ec37dd5f115fb83e07bdb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -124,6 +124,7 @@ public void processRequest(Object msg, Channel c) {\n                     processReadRequestV3(r, c);\n                     break;\n                 default:\n+                    LOG.info(\"Unknown operation type {}\", header.getOperation());\n                     BookkeeperProtocol.Response.Builder response =\n                             BookkeeperProtocol.Response.newBuilder().setHeader(r.getHeader())\n                             .setStatus(BookkeeperProtocol.StatusCode.EBADREQ);"},{"sha":"7fbb2cddfc0244136440d20a148b236a2eea669e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","status":"modified","additions":757,"deletions":30,"changes":787,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -176,12 +176,14 @@ private StatusCode(int index, int value) {\n     ADD_ENTRY(1, 2),\n     RANGE_READ_ENTRY(2, 3),\n     RANGE_ADD_ENTRY(3, 4),\n+    AUTH(4, 5),\n     ;\n     \n     public static final int READ_ENTRY_VALUE = 1;\n     public static final int ADD_ENTRY_VALUE = 2;\n     public static final int RANGE_READ_ENTRY_VALUE = 3;\n     public static final int RANGE_ADD_ENTRY_VALUE = 4;\n+    public static final int AUTH_VALUE = 5;\n     \n     \n     public final int getNumber() { return value; }\n@@ -192,6 +194,7 @@ public static OperationType valueOf(int value) {\n         case 2: return ADD_ENTRY;\n         case 3: return RANGE_READ_ENTRY;\n         case 4: return RANGE_ADD_ENTRY;\n+        case 5: return AUTH;\n         default: return null;\n       }\n     }\n@@ -222,7 +225,7 @@ public OperationType findValueByNumber(int number) {\n     }\n     \n     private static final OperationType[] VALUES = {\n-      READ_ENTRY, ADD_ENTRY, RANGE_READ_ENTRY, RANGE_ADD_ENTRY, \n+      READ_ENTRY, ADD_ENTRY, RANGE_READ_ENTRY, RANGE_ADD_ENTRY, AUTH, \n     };\n     \n     public static OperationType valueOf(\n@@ -756,6 +759,11 @@ public Builder clearTxnId() {\n     boolean hasAddRequest();\n     org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest getAddRequest();\n     org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequestOrBuilder getAddRequestOrBuilder();\n+    \n+    // optional .AuthMessage authRequest = 102;\n+    boolean hasAuthRequest();\n+    org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getAuthRequest();\n+    org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder getAuthRequestOrBuilder();\n   }\n   public static final class Request extends\n       com.google.protobuf.GeneratedMessage\n@@ -825,10 +833,24 @@ public boolean hasAddRequest() {\n       return addRequest_;\n     }\n     \n+    // optional .AuthMessage authRequest = 102;\n+    public static final int AUTHREQUEST_FIELD_NUMBER = 102;\n+    private org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage authRequest_;\n+    public boolean hasAuthRequest() {\n+      return ((bitField0_ & 0x00000008) == 0x00000008);\n+    }\n+    public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getAuthRequest() {\n+      return authRequest_;\n+    }\n+    public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder getAuthRequestOrBuilder() {\n+      return authRequest_;\n+    }\n+    \n     private void initFields() {\n       header_ = org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader.getDefaultInstance();\n       readRequest_ = org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest.getDefaultInstance();\n       addRequest_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest.getDefaultInstance();\n+      authRequest_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -855,6 +877,12 @@ public final boolean isInitialized() {\n           return false;\n         }\n       }\n+      if (hasAuthRequest()) {\n+        if (!getAuthRequest().isInitialized()) {\n+          memoizedIsInitialized = 0;\n+          return false;\n+        }\n+      }\n       memoizedIsInitialized = 1;\n       return true;\n     }\n@@ -871,6 +899,9 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       if (((bitField0_ & 0x00000004) == 0x00000004)) {\n         output.writeMessage(101, addRequest_);\n       }\n+      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        output.writeMessage(102, authRequest_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -892,6 +923,10 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeMessageSize(101, addRequest_);\n       }\n+      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(102, authRequest_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -1011,6 +1046,7 @@ private void maybeForceBuilderInitialization() {\n           getHeaderFieldBuilder();\n           getReadRequestFieldBuilder();\n           getAddRequestFieldBuilder();\n+          getAuthRequestFieldBuilder();\n         }\n       }\n       private static Builder create() {\n@@ -1037,6 +1073,12 @@ public Builder clear() {\n           addRequestBuilder_.clear();\n         }\n         bitField0_ = (bitField0_ & ~0x00000004);\n+        if (authRequestBuilder_ == null) {\n+          authRequest_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+        } else {\n+          authRequestBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000008);\n         return this;\n       }\n       \n@@ -1099,6 +1141,14 @@ public Builder clone() {\n         } else {\n           result.addRequest_ = addRequestBuilder_.build();\n         }\n+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        if (authRequestBuilder_ == null) {\n+          result.authRequest_ = authRequest_;\n+        } else {\n+          result.authRequest_ = authRequestBuilder_.build();\n+        }\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -1124,6 +1174,9 @@ public Builder mergeFrom(org.apache.bookkeeper.proto.BookkeeperProtocol.Request\n         if (other.hasAddRequest()) {\n           mergeAddRequest(other.getAddRequest());\n         }\n+        if (other.hasAuthRequest()) {\n+          mergeAuthRequest(other.getAuthRequest());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -1149,6 +1202,12 @@ public final boolean isInitialized() {\n             return false;\n           }\n         }\n+        if (hasAuthRequest()) {\n+          if (!getAuthRequest().isInitialized()) {\n+            \n+            return false;\n+          }\n+        }\n         return true;\n       }\n       \n@@ -1202,6 +1261,15 @@ public Builder mergeFrom(\n               setAddRequest(subBuilder.buildPartial());\n               break;\n             }\n+            case 818: {\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder subBuilder = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.newBuilder();\n+              if (hasAuthRequest()) {\n+                subBuilder.mergeFrom(getAuthRequest());\n+              }\n+              input.readMessage(subBuilder, extensionRegistry);\n+              setAuthRequest(subBuilder.buildPartial());\n+              break;\n+            }\n           }\n         }\n       }\n@@ -1478,6 +1546,96 @@ public Builder clearAddRequest() {\n         return addRequestBuilder_;\n       }\n       \n+      // optional .AuthMessage authRequest = 102;\n+      private org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage authRequest_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+      private com.google.protobuf.SingleFieldBuilder<\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder> authRequestBuilder_;\n+      public boolean hasAuthRequest() {\n+        return ((bitField0_ & 0x00000008) == 0x00000008);\n+      }\n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getAuthRequest() {\n+        if (authRequestBuilder_ == null) {\n+          return authRequest_;\n+        } else {\n+          return authRequestBuilder_.getMessage();\n+        }\n+      }\n+      public Builder setAuthRequest(org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage value) {\n+        if (authRequestBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          authRequest_ = value;\n+          onChanged();\n+        } else {\n+          authRequestBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000008;\n+        return this;\n+      }\n+      public Builder setAuthRequest(\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder builderForValue) {\n+        if (authRequestBuilder_ == null) {\n+          authRequest_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          authRequestBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000008;\n+        return this;\n+      }\n+      public Builder mergeAuthRequest(org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage value) {\n+        if (authRequestBuilder_ == null) {\n+          if (((bitField0_ & 0x00000008) == 0x00000008) &&\n+              authRequest_ != org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance()) {\n+            authRequest_ =\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.newBuilder(authRequest_).mergeFrom(value).buildPartial();\n+          } else {\n+            authRequest_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          authRequestBuilder_.mergeFrom(value);\n+        }\n+        bitField0_ |= 0x00000008;\n+        return this;\n+      }\n+      public Builder clearAuthRequest() {\n+        if (authRequestBuilder_ == null) {\n+          authRequest_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+          onChanged();\n+        } else {\n+          authRequestBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        return this;\n+      }\n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder getAuthRequestBuilder() {\n+        bitField0_ |= 0x00000008;\n+        onChanged();\n+        return getAuthRequestFieldBuilder().getBuilder();\n+      }\n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder getAuthRequestOrBuilder() {\n+        if (authRequestBuilder_ != null) {\n+          return authRequestBuilder_.getMessageOrBuilder();\n+        } else {\n+          return authRequest_;\n+        }\n+      }\n+      private com.google.protobuf.SingleFieldBuilder<\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder> \n+          getAuthRequestFieldBuilder() {\n+        if (authRequestBuilder_ == null) {\n+          authRequestBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder>(\n+                  authRequest_,\n+                  getParentForChildren(),\n+                  isClean());\n+          authRequest_ = null;\n+        }\n+        return authRequestBuilder_;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:Request)\n     }\n     \n@@ -2792,6 +2950,11 @@ public Builder clearBody() {\n     boolean hasAddResponse();\n     org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse getAddResponse();\n     org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponseOrBuilder getAddResponseOrBuilder();\n+    \n+    // optional .AuthMessage authResponse = 102;\n+    boolean hasAuthResponse();\n+    org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getAuthResponse();\n+    org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder getAuthResponseOrBuilder();\n   }\n   public static final class Response extends\n       com.google.protobuf.GeneratedMessage\n@@ -2871,11 +3034,25 @@ public boolean hasAddResponse() {\n       return addResponse_;\n     }\n     \n+    // optional .AuthMessage authResponse = 102;\n+    public static final int AUTHRESPONSE_FIELD_NUMBER = 102;\n+    private org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage authResponse_;\n+    public boolean hasAuthResponse() {\n+      return ((bitField0_ & 0x00000010) == 0x00000010);\n+    }\n+    public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getAuthResponse() {\n+      return authResponse_;\n+    }\n+    public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder getAuthResponseOrBuilder() {\n+      return authResponse_;\n+    }\n+    \n     private void initFields() {\n       header_ = org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader.getDefaultInstance();\n       status_ = org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode.EOK;\n       readResponse_ = org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse.getDefaultInstance();\n       addResponse_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse.getDefaultInstance();\n+      authResponse_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -2906,6 +3083,12 @@ public final boolean isInitialized() {\n           return false;\n         }\n       }\n+      if (hasAuthResponse()) {\n+        if (!getAuthResponse().isInitialized()) {\n+          memoizedIsInitialized = 0;\n+          return false;\n+        }\n+      }\n       memoizedIsInitialized = 1;\n       return true;\n     }\n@@ -2925,6 +3108,9 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       if (((bitField0_ & 0x00000008) == 0x00000008)) {\n         output.writeMessage(101, addResponse_);\n       }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n+        output.writeMessage(102, authResponse_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -2950,6 +3136,10 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeMessageSize(101, addResponse_);\n       }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(102, authResponse_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -3069,6 +3259,7 @@ private void maybeForceBuilderInitialization() {\n           getHeaderFieldBuilder();\n           getReadResponseFieldBuilder();\n           getAddResponseFieldBuilder();\n+          getAuthResponseFieldBuilder();\n         }\n       }\n       private static Builder create() {\n@@ -3097,6 +3288,12 @@ public Builder clear() {\n           addResponseBuilder_.clear();\n         }\n         bitField0_ = (bitField0_ & ~0x00000008);\n+        if (authResponseBuilder_ == null) {\n+          authResponse_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+        } else {\n+          authResponseBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000010);\n         return this;\n       }\n       \n@@ -3163,6 +3360,14 @@ public Builder clone() {\n         } else {\n           result.addResponse_ = addResponseBuilder_.build();\n         }\n+        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        if (authResponseBuilder_ == null) {\n+          result.authResponse_ = authResponse_;\n+        } else {\n+          result.authResponse_ = authResponseBuilder_.build();\n+        }\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -3191,6 +3396,9 @@ public Builder mergeFrom(org.apache.bookkeeper.proto.BookkeeperProtocol.Response\n         if (other.hasAddResponse()) {\n           mergeAddResponse(other.getAddResponse());\n         }\n+        if (other.hasAuthResponse()) {\n+          mergeAuthResponse(other.getAuthResponse());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -3220,6 +3428,12 @@ public final boolean isInitialized() {\n             return false;\n           }\n         }\n+        if (hasAuthResponse()) {\n+          if (!getAuthResponse().isInitialized()) {\n+            \n+            return false;\n+          }\n+        }\n         return true;\n       }\n       \n@@ -3284,6 +3498,15 @@ public Builder mergeFrom(\n               setAddResponse(subBuilder.buildPartial());\n               break;\n             }\n+            case 818: {\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder subBuilder = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.newBuilder();\n+              if (hasAuthResponse()) {\n+                subBuilder.mergeFrom(getAuthResponse());\n+              }\n+              input.readMessage(subBuilder, extensionRegistry);\n+              setAuthResponse(subBuilder.buildPartial());\n+              break;\n+            }\n           }\n         }\n       }\n@@ -3584,6 +3807,96 @@ public Builder clearAddResponse() {\n         return addResponseBuilder_;\n       }\n       \n+      // optional .AuthMessage authResponse = 102;\n+      private org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage authResponse_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+      private com.google.protobuf.SingleFieldBuilder<\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder> authResponseBuilder_;\n+      public boolean hasAuthResponse() {\n+        return ((bitField0_ & 0x00000010) == 0x00000010);\n+      }\n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getAuthResponse() {\n+        if (authResponseBuilder_ == null) {\n+          return authResponse_;\n+        } else {\n+          return authResponseBuilder_.getMessage();\n+        }\n+      }\n+      public Builder setAuthResponse(org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage value) {\n+        if (authResponseBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          authResponse_ = value;\n+          onChanged();\n+        } else {\n+          authResponseBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000010;\n+        return this;\n+      }\n+      public Builder setAuthResponse(\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder builderForValue) {\n+        if (authResponseBuilder_ == null) {\n+          authResponse_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          authResponseBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000010;\n+        return this;\n+      }\n+      public Builder mergeAuthResponse(org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage value) {\n+        if (authResponseBuilder_ == null) {\n+          if (((bitField0_ & 0x00000010) == 0x00000010) &&\n+              authResponse_ != org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance()) {\n+            authResponse_ =\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.newBuilder(authResponse_).mergeFrom(value).buildPartial();\n+          } else {\n+            authResponse_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          authResponseBuilder_.mergeFrom(value);\n+        }\n+        bitField0_ |= 0x00000010;\n+        return this;\n+      }\n+      public Builder clearAuthResponse() {\n+        if (authResponseBuilder_ == null) {\n+          authResponse_ = org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+          onChanged();\n+        } else {\n+          authResponseBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        return this;\n+      }\n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder getAuthResponseBuilder() {\n+        bitField0_ |= 0x00000010;\n+        onChanged();\n+        return getAuthResponseFieldBuilder().getBuilder();\n+      }\n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder getAuthResponseOrBuilder() {\n+        if (authResponseBuilder_ != null) {\n+          return authResponseBuilder_.getMessageOrBuilder();\n+        } else {\n+          return authResponse_;\n+        }\n+      }\n+      private com.google.protobuf.SingleFieldBuilder<\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder> \n+          getAuthResponseFieldBuilder() {\n+        if (authResponseBuilder_ == null) {\n+          authResponseBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder, org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder>(\n+                  authResponse_,\n+                  getParentForChildren(),\n+                  isClean());\n+          authResponse_ = null;\n+        }\n+        return authResponseBuilder_;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:Response)\n     }\n     \n@@ -4625,6 +4938,404 @@ public Builder clearEntryId() {\n     // @@protoc_insertion_point(class_scope:AddResponse)\n   }\n   \n+  public interface AuthMessageOrBuilder extends\n+      com.google.protobuf.GeneratedMessage.\n+          ExtendableMessageOrBuilder<AuthMessage> {\n+    \n+    // required string authPluginName = 1;\n+    boolean hasAuthPluginName();\n+    String getAuthPluginName();\n+  }\n+  public static final class AuthMessage extends\n+      com.google.protobuf.GeneratedMessage.ExtendableMessage<\n+        AuthMessage> implements AuthMessageOrBuilder {\n+    // Use AuthMessage.newBuilder() to construct.\n+    private AuthMessage(Builder builder) {\n+      super(builder);\n+    }\n+    private AuthMessage(boolean noInit) {}\n+    \n+    private static final AuthMessage defaultInstance;\n+    public static AuthMessage getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public AuthMessage getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.bookkeeper.proto.BookkeeperProtocol.internal_static_AuthMessage_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.bookkeeper.proto.BookkeeperProtocol.internal_static_AuthMessage_fieldAccessorTable;\n+    }\n+    \n+    private int bitField0_;\n+    // required string authPluginName = 1;\n+    public static final int AUTHPLUGINNAME_FIELD_NUMBER = 1;\n+    private java.lang.Object authPluginName_;\n+    public boolean hasAuthPluginName() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public String getAuthPluginName() {\n+      java.lang.Object ref = authPluginName_;\n+      if (ref instanceof String) {\n+        return (String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs = \n+            (com.google.protobuf.ByteString) ref;\n+        String s = bs.toStringUtf8();\n+        if (com.google.protobuf.Internal.isValidUtf8(bs)) {\n+          authPluginName_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    private com.google.protobuf.ByteString getAuthPluginNameBytes() {\n+      java.lang.Object ref = authPluginName_;\n+      if (ref instanceof String) {\n+        com.google.protobuf.ByteString b = \n+            com.google.protobuf.ByteString.copyFromUtf8((String) ref);\n+        authPluginName_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+    \n+    private void initFields() {\n+      authPluginName_ = \"\";\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasAuthPluginName()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!extensionsAreInitialized()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      com.google.protobuf.GeneratedMessage\n+        .ExtendableMessage<org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage>.ExtensionWriter extensionWriter =\n+          newExtensionWriter();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeBytes(1, getAuthPluginNameBytes());\n+      }\n+      extensionWriter.writeUntil(536870912, output);\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(1, getAuthPluginNameBytes());\n+      }\n+      size += extensionsSerializedSize();\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.ExtendableBuilder<\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage, Builder> implements org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessageOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.BookkeeperProtocol.internal_static_AuthMessage_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.bookkeeper.proto.BookkeeperProtocol.internal_static_AuthMessage_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        authPluginName_ = \"\";\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDescriptor();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage getDefaultInstanceForType() {\n+        return org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance();\n+      }\n+      \n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage build() {\n+        org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage buildPartial() {\n+        org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage result = new org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.authPluginName_ = authPluginName_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage) {\n+          return mergeFrom((org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage other) {\n+        if (other == org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.getDefaultInstance()) return this;\n+        if (other.hasAuthPluginName()) {\n+          setAuthPluginName(other.getAuthPluginName());\n+        }\n+        this.mergeExtensionFields(other);\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasAuthPluginName()) {\n+          \n+          return false;\n+        }\n+        if (!extensionsAreInitialized()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 10: {\n+              bitField0_ |= 0x00000001;\n+              authPluginName_ = input.readBytes();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required string authPluginName = 1;\n+      private java.lang.Object authPluginName_ = \"\";\n+      public boolean hasAuthPluginName() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public String getAuthPluginName() {\n+        java.lang.Object ref = authPluginName_;\n+        if (!(ref instanceof String)) {\n+          String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();\n+          authPluginName_ = s;\n+          return s;\n+        } else {\n+          return (String) ref;\n+        }\n+      }\n+      public Builder setAuthPluginName(String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000001;\n+        authPluginName_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearAuthPluginName() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        authPluginName_ = getDefaultInstance().getAuthPluginName();\n+        onChanged();\n+        return this;\n+      }\n+      void setAuthPluginName(com.google.protobuf.ByteString value) {\n+        bitField0_ |= 0x00000001;\n+        authPluginName_ = value;\n+        onChanged();\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:AuthMessage)\n+    }\n+    \n+    static {\n+      defaultInstance = new AuthMessage(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:AuthMessage)\n+  }\n+  \n   private static com.google.protobuf.Descriptors.Descriptor\n     internal_static_BKPacketHeader_descriptor;\n   private static\n@@ -4660,6 +5371,11 @@ public Builder clearEntryId() {\n   private static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_AddResponse_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_AuthMessage_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_AuthMessage_fieldAccessorTable;\n   \n   public static com.google.protobuf.Descriptors.FileDescriptor\n       getDescriptor() {\n@@ -4672,33 +5388,36 @@ public Builder clearEntryId() {\n       \"\\n\\'src/main/proto/BookkeeperProtocol.prot\" +\n       \"o\\\"e\\n\\016BKPacketHeader\\022!\\n\\007version\\030\\001 \\002(\\0162\\020.P\" +\n       \"rotocolVersion\\022!\\n\\toperation\\030\\002 \\002(\\0162\\016.Oper\" +\n-      \"ationType\\022\\r\\n\\005txnId\\030\\003 \\002(\\004\\\"n\\n\\007Request\\022\\037\\n\\006h\" +\n-      \"eader\\030\\001 \\002(\\0132\\017.BKPacketHeader\\022!\\n\\013readRequ\" +\n-      \"est\\030d \\001(\\0132\\014.ReadRequest\\022\\037\\n\\naddRequest\\030e \" +\n-      \"\\001(\\0132\\013.AddRequest\\\"~\\n\\013ReadRequest\\022\\037\\n\\004flag\\030\" +\n-      \"d \\001(\\0162\\021.ReadRequest.Flag\\022\\020\\n\\010ledgerId\\030\\001 \\002\" +\n-      \"(\\003\\022\\017\\n\\007entryId\\030\\002 \\002(\\003\\022\\021\\n\\tmasterKey\\030\\003 \\001(\\014\\\"\\030\" +\n-      \"\\n\\004Flag\\022\\020\\n\\014FENCE_LEDGER\\020\\001\\\"\\212\\001\\n\\nAddRequest\\022\",\n-      \"\\036\\n\\004flag\\030d \\001(\\0162\\020.AddRequest.Flag\\022\\020\\n\\010ledge\" +\n-      \"rId\\030\\001 \\002(\\003\\022\\017\\n\\007entryId\\030\\002 \\002(\\003\\022\\021\\n\\tmasterKey\\030\" +\n-      \"\\003 \\002(\\014\\022\\014\\n\\004body\\030\\004 \\002(\\014\\\"\\030\\n\\004Flag\\022\\020\\n\\014RECOVERY_\" +\n-      \"ADD\\020\\001\\\"\\220\\001\\n\\010Response\\022\\037\\n\\006header\\030\\001 \\002(\\0132\\017.BKP\" +\n-      \"acketHeader\\022\\033\\n\\006status\\030\\002 \\002(\\0162\\013.StatusCode\" +\n-      \"\\022#\\n\\014readResponse\\030d \\001(\\0132\\r.ReadResponse\\022!\\n\" +\n-      \"\\013addResponse\\030e \\001(\\0132\\014.AddResponse\\\"\\\\\\n\\014Read\" +\n-      \"Response\\022\\033\\n\\006status\\030\\001 \\002(\\0162\\013.StatusCode\\022\\020\\n\" +\n-      \"\\010ledgerId\\030\\002 \\002(\\003\\022\\017\\n\\007entryId\\030\\003 \\002(\\003\\022\\014\\n\\004body\" +\n-      \"\\030\\004 \\001(\\014\\\"M\\n\\013AddResponse\\022\\033\\n\\006status\\030\\001 \\002(\\0162\\013.\",\n-      \"StatusCode\\022\\020\\n\\010ledgerId\\030\\002 \\002(\\003\\022\\017\\n\\007entryId\\030\" +\n-      \"\\003 \\002(\\003*F\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_ONE\\020\" +\n-      \"\\001\\022\\017\\n\\013VERSION_TWO\\020\\002\\022\\021\\n\\rVERSION_THREE\\020\\003*\\206\\001\" +\n-      \"\\n\\nStatusCode\\022\\007\\n\\003EOK\\020\\000\\022\\016\\n\\tENOLEDGER\\020\\222\\003\\022\\r\\n\" +\n-      \"\\010ENOENTRY\\020\\223\\003\\022\\014\\n\\007EBADREQ\\020\\224\\003\\022\\010\\n\\003EIO\\020\\365\\003\\022\\010\\n\\003\" +\n-      \"EUA\\020\\366\\003\\022\\020\\n\\013EBADVERSION\\020\\367\\003\\022\\014\\n\\007EFENCED\\020\\370\\003\\022\\016\" +\n-      \"\\n\\tEREADONLY\\020\\371\\003*Y\\n\\rOperationType\\022\\016\\n\\nREAD_\" +\n-      \"ENTRY\\020\\001\\022\\r\\n\\tADD_ENTRY\\020\\002\\022\\024\\n\\020RANGE_READ_ENT\" +\n-      \"RY\\020\\003\\022\\023\\n\\017RANGE_ADD_ENTRY\\020\\004B\\037\\n\\033org.apache.\" +\n-      \"bookkeeper.protoH\\001\"\n+      \"ationType\\022\\r\\n\\005txnId\\030\\003 \\002(\\004\\\"\\221\\001\\n\\007Request\\022\\037\\n\\006\" +\n+      \"header\\030\\001 \\002(\\0132\\017.BKPacketHeader\\022!\\n\\013readReq\" +\n+      \"uest\\030d \\001(\\0132\\014.ReadRequest\\022\\037\\n\\naddRequest\\030e\" +\n+      \" \\001(\\0132\\013.AddRequest\\022!\\n\\013authRequest\\030f \\001(\\0132\\014\" +\n+      \".AuthMessage\\\"~\\n\\013ReadRequest\\022\\037\\n\\004flag\\030d \\001(\" +\n+      \"\\0162\\021.ReadRequest.Flag\\022\\020\\n\\010ledgerId\\030\\001 \\002(\\003\\022\\017\" +\n+      \"\\n\\007entryId\\030\\002 \\002(\\003\\022\\021\\n\\tmasterKey\\030\\003 \\001(\\014\\\"\\030\\n\\004Fl\",\n+      \"ag\\022\\020\\n\\014FENCE_LEDGER\\020\\001\\\"\\212\\001\\n\\nAddRequest\\022\\036\\n\\004f\" +\n+      \"lag\\030d \\001(\\0162\\020.AddRequest.Flag\\022\\020\\n\\010ledgerId\\030\" +\n+      \"\\001 \\002(\\003\\022\\017\\n\\007entryId\\030\\002 \\002(\\003\\022\\021\\n\\tmasterKey\\030\\003 \\002(\" +\n+      \"\\014\\022\\014\\n\\004body\\030\\004 \\002(\\014\\\"\\030\\n\\004Flag\\022\\020\\n\\014RECOVERY_ADD\\020\" +\n+      \"\\001\\\"\\264\\001\\n\\010Response\\022\\037\\n\\006header\\030\\001 \\002(\\0132\\017.BKPacke\" +\n+      \"tHeader\\022\\033\\n\\006status\\030\\002 \\002(\\0162\\013.StatusCode\\022#\\n\\014\" +\n+      \"readResponse\\030d \\001(\\0132\\r.ReadResponse\\022!\\n\\013add\" +\n+      \"Response\\030e \\001(\\0132\\014.AddResponse\\022\\\"\\n\\014authResp\" +\n+      \"onse\\030f \\001(\\0132\\014.AuthMessage\\\"\\\\\\n\\014ReadResponse\" +\n+      \"\\022\\033\\n\\006status\\030\\001 \\002(\\0162\\013.StatusCode\\022\\020\\n\\010ledgerI\",\n+      \"d\\030\\002 \\002(\\003\\022\\017\\n\\007entryId\\030\\003 \\002(\\003\\022\\014\\n\\004body\\030\\004 \\001(\\014\\\"M\" +\n+      \"\\n\\013AddResponse\\022\\033\\n\\006status\\030\\001 \\002(\\0162\\013.StatusCo\" +\n+      \"de\\022\\020\\n\\010ledgerId\\030\\002 \\002(\\003\\022\\017\\n\\007entryId\\030\\003 \\002(\\003\\\"0\\n\" +\n+      \"\\013AuthMessage\\022\\026\\n\\016authPluginName\\030\\001 \\002(\\t*\\t\\010\\350\" +\n+      \"\\007\\020\\200\\200\\200\\200\\002*F\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_ON\" +\n+      \"E\\020\\001\\022\\017\\n\\013VERSION_TWO\\020\\002\\022\\021\\n\\rVERSION_THREE\\020\\003*\" +\n+      \"\\206\\001\\n\\nStatusCode\\022\\007\\n\\003EOK\\020\\000\\022\\016\\n\\tENOLEDGER\\020\\222\\003\\022\" +\n+      \"\\r\\n\\010ENOENTRY\\020\\223\\003\\022\\014\\n\\007EBADREQ\\020\\224\\003\\022\\010\\n\\003EIO\\020\\365\\003\\022\\010\" +\n+      \"\\n\\003EUA\\020\\366\\003\\022\\020\\n\\013EBADVERSION\\020\\367\\003\\022\\014\\n\\007EFENCED\\020\\370\\003\" +\n+      \"\\022\\016\\n\\tEREADONLY\\020\\371\\003*c\\n\\rOperationType\\022\\016\\n\\nREA\",\n+      \"D_ENTRY\\020\\001\\022\\r\\n\\tADD_ENTRY\\020\\002\\022\\024\\n\\020RANGE_READ_E\" +\n+      \"NTRY\\020\\003\\022\\023\\n\\017RANGE_ADD_ENTRY\\020\\004\\022\\010\\n\\004AUTH\\020\\005B\\037\\n\" +\n+      \"\\033org.apache.bookkeeper.protoH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -4718,7 +5437,7 @@ public Builder clearEntryId() {\n           internal_static_Request_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Request_descriptor,\n-              new java.lang.String[] { \"Header\", \"ReadRequest\", \"AddRequest\", },\n+              new java.lang.String[] { \"Header\", \"ReadRequest\", \"AddRequest\", \"AuthRequest\", },\n               org.apache.bookkeeper.proto.BookkeeperProtocol.Request.class,\n               org.apache.bookkeeper.proto.BookkeeperProtocol.Request.Builder.class);\n           internal_static_ReadRequest_descriptor =\n@@ -4742,7 +5461,7 @@ public Builder clearEntryId() {\n           internal_static_Response_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Response_descriptor,\n-              new java.lang.String[] { \"Header\", \"Status\", \"ReadResponse\", \"AddResponse\", },\n+              new java.lang.String[] { \"Header\", \"Status\", \"ReadResponse\", \"AddResponse\", \"AuthResponse\", },\n               org.apache.bookkeeper.proto.BookkeeperProtocol.Response.class,\n               org.apache.bookkeeper.proto.BookkeeperProtocol.Response.Builder.class);\n           internal_static_ReadResponse_descriptor =\n@@ -4761,6 +5480,14 @@ public Builder clearEntryId() {\n               new java.lang.String[] { \"Status\", \"LedgerId\", \"EntryId\", },\n               org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse.class,\n               org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse.Builder.class);\n+          internal_static_AuthMessage_descriptor =\n+            getDescriptor().getMessageTypes().get(7);\n+          internal_static_AuthMessage_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_AuthMessage_descriptor,\n+              new java.lang.String[] { \"AuthPluginName\", },\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.class,\n+              org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage.Builder.class);\n           return null;\n         }\n       };"},{"sha":"0f9feeab2954118358fd91b456b6f60488ce3a5f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":50,"deletions":20,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -28,6 +28,7 @@\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n@@ -79,6 +80,7 @@\n \n import com.google.common.collect.Sets;\n import com.google.protobuf.ByteString;\n+import com.google.protobuf.ExtensionRegistry;\n \n /**\n  * This class manages all details of connection to a particular bookie. It also\n@@ -134,15 +136,27 @@\n     private final ClientConfiguration conf;\n \n     private final PerChannelBookieClientPool pcbcPool;\n+    private final ClientAuthProvider.Factory authProviderFactory;\n+    private final ExtensionRegistry extRegistry;\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n                                   BookieSocketAddress addr) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE, null);\n+        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE, null, null, null);\n+    }\n+\n+    public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+                                  BookieSocketAddress addr,\n+                                  ClientAuthProvider.Factory authProviderFactory,\n+                                  ExtensionRegistry extRegistry) {\n+        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE,\n+                authProviderFactory, extRegistry, null);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n                                   ClientSocketChannelFactory channelFactory, BookieSocketAddress addr,\n                                   HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,\n+                                  ClientAuthProvider.Factory authProviderFactory,\n+                                  ExtensionRegistry extRegistry,\n                                   PerChannelBookieClientPool pcbcPool) {\n         this.conf = conf;\n         this.addr = addr;\n@@ -153,6 +167,9 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.addEntryTimeout = conf.getAddEntryTimeout();\n         this.readEntryTimeout = conf.getReadEntryTimeout();\n \n+        this.authProviderFactory = authProviderFactory;\n+        this.extRegistry = extRegistry;\n+\n         StringBuilder nameBuilder = new StringBuilder();\n         nameBuilder.append(addr.getHostname().replace('.', '_').replace('-', '_'))\n             .append(\"_\").append(addr.getPort());\n@@ -563,8 +580,8 @@ public void safeRun() {\n                     bAddress = c.getRemoteAddress().toString();\n                 }\n \n-                LOG.debug(\"Could not write request for reading entry: {} ledger-id: {} bookie: {}\",\n-                          new Object[]{ readCompletion.entryId, readCompletion.ledgerId, bAddress });\n+                LOG.debug(\"Could not write request for reading entry: {} ledger-id: {} bookie: {} rc: {}\",\n+                        new Object[]{ readCompletion.entryId, readCompletion.ledgerId, bAddress, rc });\n \n                 readCompletion.cb.readEntryComplete(rc, readCompletion.ledgerId, readCompletion.entryId,\n                                                     null, readCompletion.ctx);\n@@ -594,8 +611,8 @@ public void safeRun() {\n                 if(c != null) {\n                     bAddress = c.getRemoteAddress().toString();\n                 }\n-                LOG.debug(\"Could not write request for adding entry: {} ledger-id: {} bookie: {}\",\n-                          new Object[] { addCompletion.entryId, addCompletion.ledgerId, bAddress });\n+                LOG.debug(\"Could not write request for adding entry: {} ledger-id: {} bookie: {} rc: {}\",\n+                          new Object[] { addCompletion.entryId, addCompletion.ledgerId, bAddress, rc });\n \n                 addCompletion.cb.writeComplete(rc, addCompletion.ledgerId, addCompletion.entryId,\n                                                addr, addCompletion.ctx);\n@@ -656,8 +673,9 @@ public ChannelPipeline getPipeline() throws Exception {\n \n         pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));\n         pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n-        pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder());\n-        pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.ResponseDecoder());\n+        pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder(extRegistry));\n+        pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.ResponseDecoder(extRegistry));\n+        pipeline.addLast(\"authHandler\", new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator));\n         pipeline.addLast(\"mainhandler\", this);\n         return pipeline;\n     }\n@@ -699,6 +717,16 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n             return;\n         }\n \n+        if (t instanceof AuthHandler.AuthenticationException) {\n+            LOG.error(\"Error authenticating connection\", t);\n+            errorOutOutstandingEntries(BKException.Code.UnauthorizedAccessException);\n+            Channel c = ctx.getChannel();\n+            if (c != null) {\n+                closeChannel(c);\n+            }\n+            return;\n+        }\n+\n         if (t instanceof IOException) {\n             // these are thrown when a bookie fails, logging them just pollutes\n             // the logs (the failure is logged from the listeners on the write\n@@ -739,7 +767,6 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n                 LOG.debug(\"Unexpected response received from bookie : \" + addr + \" for type : \" + header.             getOperation() +\n                         \" and txnId : \" + header.getTxnId());\n             }\n-\n         } else {\n             long orderingKey = completionValue.ledgerId;\n             executor.submitOrdered(orderingKey, new SafeRunnable() {\n@@ -748,10 +775,10 @@ public void safeRun() {\n                     OperationType type = header.getOperation();\n                     switch (type) {\n                         case ADD_ENTRY:\n-                            handleAddResponse(response.getAddResponse(), completionValue);\n+                            handleAddResponse(response, completionValue);\n                             break;\n                         case READ_ENTRY:\n-                            handleReadResponse(response.getReadResponse(), completionValue);\n+                            handleReadResponse(response, completionValue);\n                             break;\n                         default:\n                             LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n@@ -770,13 +797,14 @@ public String toString() {\n         }\n     }\n \n-    void handleAddResponse(AddResponse response, CompletionValue completionValue) {\n+    void handleAddResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of an AddCompletion object when we reach here.\n         AddCompletion ac = (AddCompletion)completionValue;\n+        AddResponse addResponse = response.getAddResponse();\n \n-        long ledgerId = response.getLedgerId();\n-        long entryId = response.getEntryId();\n-        StatusCode status = response.getStatus();\n+        long ledgerId = addResponse.getLedgerId();\n+        long entryId = addResponse.getEntryId();\n+        StatusCode status = response.getStatus() == StatusCode.EOK ? addResponse.getStatus() : response.getStatus();\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n@@ -796,17 +824,19 @@ void handleAddResponse(AddResponse response, CompletionValue completionValue) {\n         ac.cb.writeComplete(rcToRet, ledgerId, entryId, addr, ac.ctx);\n     }\n \n-    void handleReadResponse(ReadResponse response, CompletionValue completionValue) {\n+    void handleReadResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n+        ReadResponse readResponse = response.getReadResponse();\n+\n+        long ledgerId = readResponse.getLedgerId();\n+        long entryId = readResponse.getEntryId();\n+        StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();\n \n-        long ledgerId = response.getLedgerId();\n-        long entryId = response.getEntryId();\n-        StatusCode status = response.getStatus();\n         ChannelBuffer buffer = ChannelBuffers.buffer(0);\n \n-        if (response.hasBody()) {\n-            buffer = ChannelBuffers.copiedBuffer(response.getBody().asReadOnlyByteBuffer());\n+        if (readResponse.hasBody()) {\n+            buffer = ChannelBuffers.copiedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n         }\n \n         if (LOG.isDebugEnabled()) {"},{"sha":"7aeadfc1c810bfe8babd7f429e5f5f55d29e4b0e","filename":"bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -55,6 +55,8 @@ enum OperationType {\n     // Not supported yet.\n     RANGE_READ_ENTRY = 3;\n     RANGE_ADD_ENTRY = 4;\n+\n+    AUTH = 5;\n }\n \n /**\n@@ -71,6 +73,7 @@ message Request {\n     // Requests\n     optional ReadRequest readRequest = 100;\n     optional AddRequest addRequest = 101;\n+    optional AuthMessage authRequest = 102;\n }\n \n message ReadRequest {\n@@ -105,7 +108,7 @@ message Response {\n     // Response\n     optional ReadResponse readResponse = 100;\n     optional AddResponse addResponse = 101;\n-\n+    optional AuthMessage authResponse = 102;\n }\n \n message ReadResponse {\n@@ -120,3 +123,12 @@ message AddResponse {\n     required int64 ledgerId = 2;\n     required int64 entryId = 3;\n }\n+\n+/**\n+ * Extendible message which auth mechanisms\n+ * can use to carry their payload.\n+ */\n+message AuthMessage {\n+    required string authPluginName = 1;\n+    extensions 1000 to max;\n+}\n\\ No newline at end of file"},{"sha":"a57bfe9de1aef77f7327dc8d6f7688aa699eb71e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/auth/TestAuth.java","status":"added","additions":654,"deletions":0,"changes":654,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/auth/TestAuth.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/auth/TestAuth.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/auth/TestAuth.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,654 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.auth;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+import org.apache.bookkeeper.proto.TestDataFormats;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+import com.google.protobuf.ExtensionRegistry;\n+\n+public class TestAuth extends BookKeeperClusterTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(TestAuth.class);\n+    public static final String TEST_AUTH_PROVIDER_PLUGIN_NAME = \"TestAuthProviderPlugin\";\n+    private static final byte[] PASSWD = \"testPasswd\".getBytes();\n+    private static final byte[] ENTRY = \"TestEntry\".getBytes();\n+\n+    public TestAuth() {\n+        super(0); // start them later when auth providers are configured\n+    }\n+\n+    // we pass in ledgerId because the method may throw exceptions\n+    private void connectAndWriteToBookie(ClientConfiguration conf, AtomicLong ledgerWritten)\n+            throws Exception {\n+        LOG.info(\"Connecting to bookie\");\n+        BookKeeper bkc = new BookKeeper(conf, zkc);\n+        LedgerHandle l = bkc.createLedger(1, 1, DigestType.CRC32,\n+                PASSWD);\n+        ledgerWritten.set(l.getId());\n+        l.addEntry(ENTRY);\n+        l.close();\n+        bkc.close();\n+    }\n+\n+    /**\n+     * check if the entry exists. Restart the bookie to allow\n+     * access\n+     */\n+    private int entryCount(long ledgerId, ServerConfiguration bookieConf,\n+                           ClientConfiguration clientConf) throws Exception {\n+        LOG.info(\"Counting entries in {}\", ledgerId);\n+        for (ServerConfiguration conf : bsConfs) {\n+            conf.setBookieAuthProviderFactoryClass(\n+                    AlwaysSucceedBookieAuthProviderFactory.class.getName());\n+        }\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        \n+        restartBookies();\n+\n+        BookKeeper bkc = new BookKeeper(clientConf, zkc);\n+        LedgerHandle lh = bkc.openLedger(ledgerId, DigestType.CRC32,\n+                                         PASSWD);\n+        if (lh.getLastAddConfirmed() < 0) {\n+            return 0;\n+        }\n+        Enumeration<LedgerEntry> e = lh.readEntries(0, lh.getLastAddConfirmed());\n+        int count = 0;\n+        while (e.hasMoreElements()) {\n+            count++;\n+            assertTrue(\"Should match what we wrote\",\n+                       Arrays.equals(e.nextElement().getEntry(), ENTRY));\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Test an connection will authorize with a single message\n+     * to the server and a single response.\n+     */\n+    @Test(timeout=30000)\n+    public void testSingleMessageAuth() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                AlwaysSucceedBookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        \n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        connectAndWriteToBookie(clientConf, ledgerId); // should succeed\n+\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Should have entry\", 1, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+    \n+    /**\n+     * Test that when the bookie provider sends a failure message\n+     * the client will not be able to write\n+     */\n+    @Test(timeout=30000)\n+    public void testSingleMessageAuthFailure() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                AlwaysFailBookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        \n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        try {\n+            connectAndWriteToBookie(clientConf, ledgerId); // should fail\n+            fail(\"Shouldn't get this far\");\n+        } catch (BKException.BKUnauthorizedAccessException bke) {\n+            // client shouldnt be able to find enough bookies to\n+            // write\n+        }\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Shouldn't have entry\", 0, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    /**\n+     * Test that authentication works when the providers\n+     * exchange multiple messages\n+     */\n+    @Test(timeout=30000)\n+    public void testMultiMessageAuth() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                SucceedAfter3BookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        \n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        startAndStoreBookie(bookieConf);\n+        connectAndWriteToBookie(clientConf, ledgerId); // should succeed\n+\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Should have entry\", 1, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+    \n+    /**\n+     * Test that when the bookie provider sends a failure message\n+     * the client will not be able to write\n+     */\n+    @Test(timeout=30000)\n+    public void testMultiMessageAuthFailure() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                FailAfter3BookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        \n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        try {\n+            connectAndWriteToBookie(clientConf, ledgerId); // should fail\n+            fail(\"Shouldn't get this far\");\n+        } catch (BKException.BKUnauthorizedAccessException bke) {\n+            // bookie should have sent a negative response before\n+            // breaking the conneciton\n+        }\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Shouldn't have entry\", 0, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    /**\n+     * Test that when the bookie and the client have a different\n+     * plugin configured, no messages will get through.\n+     */\n+    @Test(timeout=30000)\n+    public void testDifferentPluginFailure() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                DifferentPluginBookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        \n+        startAndStoreBookie(bookieConf);\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        try {\n+            connectAndWriteToBookie(clientConf, ledgerId); // should fail\n+            fail(\"Shouldn't get this far\");\n+        } catch (BKException.BKUnauthorizedAccessException bke) {\n+            // bookie should have sent a negative response before\n+            // breaking the conneciton\n+        }\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Shouldn't have entry\", 0, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    /**\n+     * Test that when the plugin class does exist, but\n+     * doesn't implement the interface, we fail predictably\n+     */\n+    @Test(timeout=30000)\n+    public void testExistantButNotValidPlugin() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                \"java.lang.String\");\n+\n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                \"java.lang.String\");\n+        try {\n+            startAndStoreBookie(bookieConf);\n+            fail(\"Shouldn't get this far\");\n+        } catch (RuntimeException e) {\n+            // received correct exception\n+            assertTrue(\"Wrong exception thrown\",\n+                    e.getMessage().contains(\"not \"\n+                            + BookieAuthProvider.Factory.class.getName()));\n+        }\n+\n+        try {\n+            BookKeeper bkc = new BookKeeper(clientConf, zkc);\n+            fail(\"Shouldn't get this far\");\n+        } catch (RuntimeException e) {\n+            // received correct exception\n+            assertTrue(\"Wrong exception thrown\",\n+                    e.getMessage().contains(\"not \"\n+                            + ClientAuthProvider.Factory.class.getName()));\n+        }\n+    }\n+\n+    /**\n+     * Test that when the plugin class does not exist,\n+     * the bookie will not start and the client will\n+     * break.\n+     */\n+    @Test(timeout=30000)\n+    public void testNonExistantPlugin() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                \"NonExistantClassNameForTestingAuthPlugins\");\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                \"NonExistantClassNameForTestingAuthPlugins\");\n+        try {\n+            startAndStoreBookie(bookieConf);\n+            fail(\"Shouldn't get this far\");\n+        } catch (RuntimeException e) {\n+            // received correct exception\n+            assertEquals(\"Wrong exception thrown\",\n+                    e.getCause().getClass(), ClassNotFoundException.class);\n+        }\n+\n+        try {\n+            BookKeeper bkc = new BookKeeper(clientConf, zkc);\n+            fail(\"Shouldn't get this far\");\n+        } catch (RuntimeException e) {\n+            // received correct exception\n+            assertEquals(\"Wrong exception thrown\",\n+                    e.getCause().getClass(), ClassNotFoundException.class);\n+        }\n+    }\n+\n+    /**\n+     * Test that when the plugin on the bookie crashes, the client doesn't\n+     * hang also, but it cannot write in any case.\n+     */\n+    @Test(timeout=30000)\n+    public void testCrashDuringAuth() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                CrashAfter3BookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+\n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        try {\n+            connectAndWriteToBookie(clientConf, ledgerId);\n+            fail(\"Shouldn't get this far\");\n+        } catch (BKException.BKNotEnoughBookiesException bke) {\n+            // bookie won't respond, request will timeout, and then\n+            // we wont be able to find a replacement\n+        }\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Shouldn't have entry\", 0, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    /**\n+     * Test that when a bookie simply stops replying during auth, the client doesn't\n+     * hang also, but it cannot write in any case.\n+     */\n+    @Test(timeout=30000)\n+    public void testCrashType2DuringAuth() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                CrashType2After3BookieAuthProviderFactory.class.getName());\n+        \n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+                SendUntilCompleteClientAuthProviderFactory.class.getName());\n+        crashType2bookieInstance = startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        try {\n+            connectAndWriteToBookie(clientConf, ledgerId);\n+            fail(\"Shouldn't get this far\");\n+        } catch (BKException.BKNotEnoughBookiesException bke) {\n+            // bookie won't respond, request will timeout, and then\n+            // we wont be able to find a replacement\n+        }\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Shouldn't have entry\", 0, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    BookieServer startAndStoreBookie(ServerConfiguration conf) throws Exception {\n+        bsConfs.add(conf);\n+        BookieServer s = startBookie(conf);\n+        bs.add(s);\n+        return s;\n+    }\n+\n+    public static class AlwaysSucceedBookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    builder.setExtension(TestDataFormats.messageType, \n+                            TestDataFormats.AuthMessageType.SUCCESS_RESPONSE);\n+\n+                    cb.operationComplete(BKException.Code.OK, builder.build());\n+                    completeCb.operationComplete(BKException.Code.OK, null);\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class AlwaysFailBookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    builder.setExtension(TestDataFormats.messageType, \n+                            TestDataFormats.AuthMessageType.FAILURE_RESPONSE);\n+\n+                    cb.operationComplete(BKException.Code.OK, builder.build());\n+                    completeCb.operationComplete(\n+                            BKException.Code.UnauthorizedAccessException, null);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class SendUntilCompleteClientAuthProviderFactory\n+        implements ClientAuthProvider.Factory {\n+        \n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ClientConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public ClientAuthProvider newProvider(InetSocketAddress addr,\n+                final GenericCallback<Void> completeCb) {\n+            AuthMessage.Builder builder\n+                = AuthMessage.newBuilder()\n+                .setAuthPluginName(getPluginName());\n+            builder.setExtension(TestDataFormats.messageType, \n+                                 TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+            final AuthMessage message = builder.build();\n+\n+            return new ClientAuthProvider() {\n+                public void init(GenericCallback<AuthMessage> cb) {\n+                    cb.operationComplete(BKException.Code.OK, message);\n+                }\n+\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+                    if (m.hasExtension(TestDataFormats.messageType)) {\n+                        TestDataFormats.AuthMessageType type\n+                            = m.getExtension(TestDataFormats.messageType);\n+                        if (type == TestDataFormats.AuthMessageType.SUCCESS_RESPONSE) {\n+                            completeCb.operationComplete(BKException.Code.OK, null);\n+                        } else if (type == TestDataFormats.AuthMessageType.FAILURE_RESPONSE) {\n+                            completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+                        } else {\n+                            cb.operationComplete(BKException.Code.OK, message);\n+                        }\n+                    } else {\n+                        completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class SucceedAfter3BookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        AtomicInteger numMessages = new AtomicInteger(0);\n+\n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    if (numMessages.incrementAndGet() == 3) {\n+                        builder.setExtension(TestDataFormats.messageType, \n+                                TestDataFormats.AuthMessageType.SUCCESS_RESPONSE);\n+\n+                        cb.operationComplete(BKException.Code.OK, builder.build());\n+                        completeCb.operationComplete(BKException.Code.OK, null);\n+                    } else {\n+                        builder.setExtension(TestDataFormats.messageType, \n+                                TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+\n+                        cb.operationComplete(BKException.Code.OK, builder.build());\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class FailAfter3BookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        AtomicInteger numMessages = new AtomicInteger(0);\n+\n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    if (numMessages.incrementAndGet() == 3) {\n+                        builder.setExtension(TestDataFormats.messageType, \n+                                TestDataFormats.AuthMessageType.FAILURE_RESPONSE);\n+\n+                        cb.operationComplete(BKException.Code.OK, builder.build());\n+                        completeCb.operationComplete(BKException.Code.UnauthorizedAccessException,\n+                                                     null);\n+                    } else {\n+                        builder.setExtension(TestDataFormats.messageType, \n+                                TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+\n+                        cb.operationComplete(BKException.Code.OK, builder.build());\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class CrashAfter3BookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        AtomicInteger numMessages = new AtomicInteger(0);\n+\n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    if (numMessages.incrementAndGet() == 3) {\n+                        throw new RuntimeException(\"Do bad things to the bookie\");\n+                    } else {\n+                        builder.setExtension(TestDataFormats.messageType, \n+                                TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+\n+                        cb.operationComplete(BKException.Code.OK, builder.build());\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    private static BookieServer crashType2bookieInstance = null;\n+    public static class CrashType2After3BookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        AtomicInteger numMessages = new AtomicInteger(0);\n+\n+        @Override\n+        public String getPluginName() {\n+            return TEST_AUTH_PROVIDER_PLUGIN_NAME;\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    if (numMessages.incrementAndGet() != 3) {\n+                        builder.setExtension(TestDataFormats.messageType,\n+                                TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+                        cb.operationComplete(BKException.Code.OK, builder.build());\n+                        return;\n+                    }\n+\n+                    crashType2bookieInstance.suspendProcessing();\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class DifferentPluginBookieAuthProviderFactory\n+        implements BookieAuthProvider.Factory {\n+        @Override\n+        public String getPluginName() {\n+            return \"DifferentAuthProviderPlugin\";\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf, ExtensionRegistry registry) {\n+            TestDataFormats.registerAllExtensions(registry);\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(InetSocketAddress addr,\n+                                              final GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+                public void process(AuthMessage m, GenericCallback<AuthMessage> cb) {\n+\n+                    AuthMessage.Builder builder\n+                        = AuthMessage.newBuilder()\n+                        .setAuthPluginName(getPluginName());\n+                    builder.setExtension(TestDataFormats.messageType, \n+                            TestDataFormats.AuthMessageType.FAILURE_RESPONSE);\n+\n+                    cb.operationComplete(BKException.Code.OK, builder.build());\n+                    completeCb.operationComplete(BKException.Code.OK, null);\n+                }\n+            };\n+        }\n+    }\n+\n+}"},{"sha":"fe87ac9ce39d24f76eb3ccacbbfbedb26296bf16","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBackwardCompatCMS42.java","status":"added","additions":239,"deletions":0,"changes":239,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBackwardCompatCMS42.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBackwardCompatCMS42.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBackwardCompatCMS42.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,239 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ExtensionRegistry;\n+\n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.PerChannelBookieClient;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.bookkeeper.auth.TestAuth;\n+import org.jboss.netty.bootstrap.ClientBootstrap;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.bookkeeper.proto.BookieProtocol.*;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+\n+import static org.junit.Assert.*;\n+\n+public class TestBackwardCompatCMS42 extends BookKeeperClusterTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(TestBackwardCompatCMS42.class);\n+\n+    ExtensionRegistry extRegistry = ExtensionRegistry.newInstance();\n+    ClientAuthProvider.Factory authProvider;\n+    ClientSocketChannelFactory channelFactory\n+        = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+                                            Executors.newCachedThreadPool());\n+    OrderedSafeExecutor executor = OrderedSafeExecutor.newBuilder().numThreads(1).name(\"TestBackwardCompatClient\")\n+            .build();\n+\n+    public TestBackwardCompatCMS42() throws Exception {\n+        super(0);\n+\n+        TestDataFormats.registerAllExtensions(extRegistry);\n+        authProvider = AuthProviderFactoryFactory.newClientAuthProviderFactory(\n+                new ClientConfiguration(), extRegistry);\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testAuthSingleMessage() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                TestAuth.AlwaysSucceedBookieAuthProviderFactory.class.getName());\n+        BookieServer bookie1 = startAndStoreBookie(bookieConf);\n+\n+        AuthMessage.Builder builder = AuthMessage.newBuilder()\n+            .setAuthPluginName(TestAuth.TEST_AUTH_PROVIDER_PLUGIN_NAME);\n+        builder.setExtension(TestDataFormats.messageType,\n+                             TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+        final AuthMessage authMessage = builder.build();\n+\n+        CompatClient42 client = newCompatClient(bookie1.getLocalAddress());\n+\n+        Request request = new AuthRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, authMessage);\n+        client.sendRequest(request);\n+\n+        Response response = client.takeResponse();\n+        assertTrue(\"Should be auth response\", response instanceof AuthResponse);\n+        assertEquals(\"Should have succeeded\", response.getErrorCode(), BookieProtocol.EOK);\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testAuthMultiMessage() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                TestAuth.SucceedAfter3BookieAuthProviderFactory.class.getName());\n+        BookieServer bookie1 = startAndStoreBookie(bookieConf);\n+\n+        AuthMessage.Builder builder = AuthMessage.newBuilder()\n+            .setAuthPluginName(TestAuth.TEST_AUTH_PROVIDER_PLUGIN_NAME);\n+        builder.setExtension(TestDataFormats.messageType,\n+                             TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+        final AuthMessage authMessage = builder.build();\n+        CompatClient42 client = newCompatClient(bookie1.getLocalAddress());\n+\n+        Request request = new AuthRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, authMessage);\n+        for (int i = 0; i < 3 ; i++) {\n+            client.sendRequest(request);\n+            Response response = client.takeResponse();\n+            assertTrue(\"Should be auth response\", response instanceof AuthResponse);\n+            AuthResponse authResponse = (AuthResponse)response;\n+            assertEquals(\"Should have succeeded\",\n+                         response.getErrorCode(), BookieProtocol.EOK);\n+            TestDataFormats.AuthMessageType type = authResponse.getAuthMessage()\n+                .getExtension(TestDataFormats.messageType);\n+            if (i == 2) {\n+                assertEquals(\"Should succeed after 3\",\n+                             type, TestDataFormats.AuthMessageType.SUCCESS_RESPONSE);\n+            } else {\n+                assertEquals(\"Should be payload\", type,\n+                             TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+            }\n+        }\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testAuthFail() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+                TestAuth.FailAfter3BookieAuthProviderFactory.class.getName());\n+        BookieServer bookie1 = startAndStoreBookie(bookieConf);\n+\n+        AuthMessage.Builder builder = AuthMessage.newBuilder()\n+            .setAuthPluginName(TestAuth.TEST_AUTH_PROVIDER_PLUGIN_NAME);\n+        builder.setExtension(TestDataFormats.messageType,\n+                             TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+        final AuthMessage authMessage = builder.build();\n+        CompatClient42 client = newCompatClient(bookie1.getLocalAddress());\n+\n+        Request request = new AuthRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, authMessage);\n+        for (int i = 0; i < 3 ; i++) {\n+            client.sendRequest(request);\n+            Response response = client.takeResponse();\n+            assertTrue(\"Should be auth response\", response instanceof AuthResponse);\n+            AuthResponse authResponse = (AuthResponse)response;\n+            assertEquals(\"Should have succeeded\",\n+                         response.getErrorCode(), BookieProtocol.EOK);\n+            TestDataFormats.AuthMessageType type = authResponse.getAuthMessage()\n+                .getExtension(TestDataFormats.messageType);\n+            if (i == 2) {\n+                assertEquals(\"Should fail after 3\",\n+                             type, TestDataFormats.AuthMessageType.FAILURE_RESPONSE);\n+            } else {\n+                assertEquals(\"Should be payload\", type,\n+                             TestDataFormats.AuthMessageType.PAYLOAD_MESSAGE);\n+            }\n+\n+        }\n+\n+        client.sendRequest(new ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                                           1L, 1L, (short)0));\n+        Response response = client.takeResponse();\n+        assertEquals(\"Should have failed\",\n+                     response.getErrorCode(), BookieProtocol.EUA);\n+    }\n+\n+    // copy from TestAuth\n+    BookieServer startAndStoreBookie(ServerConfiguration conf) throws Exception {\n+        bsConfs.add(conf);\n+        BookieServer s = startBookie(conf);\n+        bs.add(s);\n+        return s;\n+    }\n+\n+    CompatClient42 newCompatClient(BookieSocketAddress addr) throws Exception {\n+        return new CompatClient42(executor, channelFactory, addr, authProvider, extRegistry);\n+    }\n+\n+    // extending PerChannelBookieClient to get the pipeline factory\n+    class CompatClient42 extends PerChannelBookieClient {\n+        final ArrayBlockingQueue<Response> responses = new ArrayBlockingQueue<Response>(10);\n+        final Channel channel;\n+        final CountDownLatch connected = new CountDownLatch(1);\n+\n+        CompatClient42(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+                       BookieSocketAddress addr,\n+                       ClientAuthProvider.Factory authProviderFactory,\n+                       ExtensionRegistry extRegistry) throws Exception {\n+            super(executor, channelFactory, addr, authProviderFactory, extRegistry);\n+\n+            ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);\n+            bootstrap.setPipelineFactory(this);\n+            bootstrap.setOption(\"tcpNoDelay\", false);\n+            bootstrap.setOption(\"keepAlive\", true);\n+            ChannelFuture f = bootstrap.connect(addr.getSocketAddress()).await();\n+            channel = f.getChannel();\n+        }\n+\n+        @Override\n+        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+            if (!(e.getMessage() instanceof Response)) {\n+                LOG.error(\"Unknown message {}, passing upstream\", e.getMessage());\n+                ctx.sendUpstream(e);\n+                return;\n+            }\n+            responses.add((Response)e.getMessage());\n+        }\n+\n+        @Override\n+        public void channelConnected(ChannelHandlerContext ctx,\n+                                     ChannelStateEvent e)\n+                throws Exception {\n+            connected.countDown();\n+        }\n+\n+        Response takeResponse() throws Exception {\n+            return responses.take();\n+        }\n+\n+        Response pollResponse() throws Exception {\n+            return responses.poll();\n+        }\n+\n+        void sendRequest(Request request) throws Exception {\n+            connected.await();\n+            channel.write(request);\n+        }\n+    }\n+}\n+"},{"sha":"c3f675f9ada699b06b9a0ec488af57ab4bc0b49c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDataFormats.java","status":"added","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDataFormats.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDataFormats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestDataFormats.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,126 @@\n+// Generated by the protocol buffer compiler.  DO NOT EDIT!\n+// source: src/test/proto/TestDataFormats.proto\n+\n+package org.apache.bookkeeper.proto;\n+\n+public final class TestDataFormats {\n+  private TestDataFormats() {}\n+  public static void registerAllExtensions(\n+      com.google.protobuf.ExtensionRegistry registry) {\n+    registry.add(org.apache.bookkeeper.proto.TestDataFormats.messageType);\n+  }\n+  public enum AuthMessageType\n+      implements com.google.protobuf.ProtocolMessageEnum {\n+    SUCCESS_RESPONSE(0, 1),\n+    FAILURE_RESPONSE(1, 2),\n+    PAYLOAD_MESSAGE(2, 3),\n+    ;\n+    \n+    public static final int SUCCESS_RESPONSE_VALUE = 1;\n+    public static final int FAILURE_RESPONSE_VALUE = 2;\n+    public static final int PAYLOAD_MESSAGE_VALUE = 3;\n+    \n+    \n+    public final int getNumber() { return value; }\n+    \n+    public static AuthMessageType valueOf(int value) {\n+      switch (value) {\n+        case 1: return SUCCESS_RESPONSE;\n+        case 2: return FAILURE_RESPONSE;\n+        case 3: return PAYLOAD_MESSAGE;\n+        default: return null;\n+      }\n+    }\n+    \n+    public static com.google.protobuf.Internal.EnumLiteMap<AuthMessageType>\n+        internalGetValueMap() {\n+      return internalValueMap;\n+    }\n+    private static com.google.protobuf.Internal.EnumLiteMap<AuthMessageType>\n+        internalValueMap =\n+          new com.google.protobuf.Internal.EnumLiteMap<AuthMessageType>() {\n+            public AuthMessageType findValueByNumber(int number) {\n+              return AuthMessageType.valueOf(number);\n+            }\n+          };\n+    \n+    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+        getValueDescriptor() {\n+      return getDescriptor().getValues().get(index);\n+    }\n+    public final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptorForType() {\n+      return getDescriptor();\n+    }\n+    public static final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptor() {\n+      return org.apache.bookkeeper.proto.TestDataFormats.getDescriptor().getEnumTypes().get(0);\n+    }\n+    \n+    private static final AuthMessageType[] VALUES = {\n+      SUCCESS_RESPONSE, FAILURE_RESPONSE, PAYLOAD_MESSAGE, \n+    };\n+    \n+    public static AuthMessageType valueOf(\n+        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+      if (desc.getType() != getDescriptor()) {\n+        throw new java.lang.IllegalArgumentException(\n+          \"EnumValueDescriptor is not for this type.\");\n+      }\n+      return VALUES[desc.getIndex()];\n+    }\n+    \n+    private final int index;\n+    private final int value;\n+    \n+    private AuthMessageType(int index, int value) {\n+      this.index = index;\n+      this.value = value;\n+    }\n+    \n+    // @@protoc_insertion_point(enum_scope:AuthMessageType)\n+  }\n+  \n+  public static final int MESSAGETYPE_FIELD_NUMBER = 1000;\n+  public static final\n+    com.google.protobuf.GeneratedMessage.GeneratedExtension<\n+      org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage,\n+      org.apache.bookkeeper.proto.TestDataFormats.AuthMessageType> messageType = com.google.protobuf.GeneratedMessage\n+          .newFileScopedGeneratedExtension(\n+        org.apache.bookkeeper.proto.TestDataFormats.AuthMessageType.class,\n+        null);\n+  \n+  public static com.google.protobuf.Descriptors.FileDescriptor\n+      getDescriptor() {\n+    return descriptor;\n+  }\n+  private static com.google.protobuf.Descriptors.FileDescriptor\n+      descriptor;\n+  static {\n+    java.lang.String[] descriptorData = {\n+      \"\\n$src/test/proto/TestDataFormats.proto\\032\\'\" +\n+      \"src/main/proto/BookkeeperProtocol.proto*\" +\n+      \"R\\n\\017AuthMessageType\\022\\024\\n\\020SUCCESS_RESPONSE\\020\\001\" +\n+      \"\\022\\024\\n\\020FAILURE_RESPONSE\\020\\002\\022\\023\\n\\017PAYLOAD_MESSAG\" +\n+      \"E\\020\\003:4\\n\\013messageType\\022\\014.AuthMessage\\030\\350\\007 \\002(\\0162\" +\n+      \"\\020.AuthMessageTypeB\\037\\n\\033org.apache.bookkeep\" +\n+      \"er.protoH\\001\"\n+    };\n+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n+      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n+        public com.google.protobuf.ExtensionRegistry assignDescriptors(\n+            com.google.protobuf.Descriptors.FileDescriptor root) {\n+          descriptor = root;\n+          messageType.internalInit(descriptor.getExtensions().get(0));\n+          return null;\n+        }\n+      };\n+    com.google.protobuf.Descriptors.FileDescriptor\n+      .internalBuildGeneratedFileFrom(descriptorData,\n+        new com.google.protobuf.Descriptors.FileDescriptor[] {\n+          org.apache.bookkeeper.proto.BookkeeperProtocol.getDescriptor(),\n+        }, assigner);\n+  }\n+  \n+  // @@protoc_insertion_point(outer_class_scope)\n+}"},{"sha":"b43f5cdf3931b5f6078d75205c899bea6adf5626","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":20,"deletions":5,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -20,9 +20,12 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n@@ -38,6 +41,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.protobuf.ExtensionRegistry;\n+\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.concurrent.CountDownLatch;\n@@ -54,10 +59,16 @@\n public class TestPerChannelBookieClient extends BookKeeperClusterTestCase {\n     private final static Logger LOG = LoggerFactory.getLogger(TestPerChannelBookieClient.class);\n \n-    public TestPerChannelBookieClient() {\n+    ExtensionRegistry extRegistry = ExtensionRegistry.newInstance();\n+    ClientAuthProvider.Factory authProvider;\n+\n+    public TestPerChannelBookieClient() throws Exception {\n         super(1);\n+        authProvider = AuthProviderFactoryFactory.newClientAuthProviderFactory(\n+                new ClientConfiguration(), extRegistry);\n     }\n \n+\n     /**\n      * Test that a race does not exist between connection completion\n      * and client closure. If a race does exist, this test will simply\n@@ -74,7 +85,8 @@ public void testConnectCloseRace() throws Exception {\n \n         BookieSocketAddress addr = getBookie(0);\n         for (int i = 0; i < 1000; i++) {\n-            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n+            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr,\n+                    authProvider, extRegistry);\n             client.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>() {\n                     @Override\n                     public void operationComplete(int rc, PerChannelBookieClient client) {\n@@ -118,7 +130,8 @@ public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n \n         BookieSocketAddress addr = getBookie(0);\n         for (int i = 0; i < 100; i++) {\n-            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n+            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr,\n+                                                                       authProvider, extRegistry);\n             for (int j = i; j < 10; j++) {\n                 client.connectIfNeededAndDoOp(nullop);\n             }\n@@ -150,7 +163,8 @@ public void operationComplete(int rc, PerChannelBookieClient client) {\n         OrderedSafeExecutor executor = getOrderedSafeExecutor();\n         BookieSocketAddress addr = getBookie(0);\n \n-        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n+                addr, authProvider, extRegistry);\n         final AtomicBoolean shouldFail = new AtomicBoolean(false);\n         final AtomicBoolean inconsistent = new AtomicBoolean(false);\n         final AtomicBoolean running = new AtomicBoolean(true);\n@@ -247,7 +261,8 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n         final OrderedSafeExecutor executor = getOrderedSafeExecutor();\n         BookieSocketAddress addr = getBookie(0);\n \n-        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n+                addr, authProvider, extRegistry);\n         final CountDownLatch completion = new CountDownLatch(1);\n         final ReadEntryCallback cb = new ReadEntryCallback() {\n                 @Override"},{"sha":"28de0b22609af020c12f0a26cf77670e6db05c2f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -195,6 +195,10 @@ protected ServerConfiguration newServerConfiguration() throws Exception {\n                                       f, new File[] { f });\n     }\n \n+    protected ClientConfiguration newClientConfiguration() {\n+        return new ClientConfiguration(baseConf);\n+    }\n+\n     protected ServerConfiguration newServerConfiguration(int port, String zkServers, File journalDir, File[] ledgerDirs) {\n         ServerConfiguration conf = new ServerConfiguration(baseConf);\n         conf.setBookiePort(port);\n@@ -289,9 +293,11 @@ public CountDownLatch sleepBookie(BookieSocketAddress addr, final int seconds)\n                         public void run() {\n                             try {\n                                 bookie.suspendProcessing();\n+                                LOG.info(\"bookie {} is asleep\", bookie.getLocalAddress());\n                                 l.countDown();\n                                 Thread.sleep(seconds*1000);\n                                 bookie.resumeProcessing();\n+                                LOG.info(\"bookie {} is awake\", bookie.getLocalAddress());\n                             } catch (Exception e) {\n                                 LOG.error(\"Error suspending bookie\", e);\n                             }\n@@ -441,6 +447,10 @@ protected BookieServer startBookie(ServerConfiguration conf)\n         BookieServer server = new BookieServer(conf);\n         server.start();\n \n+        if (bkc == null) {\n+            bkc = new BookKeeperTestClient(baseClientConf);\n+        }\n+\n         int port = conf.getBookiePort();\n         String host = InetAddress.getLocalHost().getHostAddress();\n         if (conf.getUseHostNameAsBookieID()) {"},{"sha":"0c616d7eac6cdbff08925d0ddde074f01d17c6a5","filename":"bookkeeper-server/src/test/proto/TestDataFormats.proto","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/proto/TestDataFormats.proto","raw_url":"https://github.com/apache/bookkeeper/raw/b1c12c0f41b7c27b2452fef311f12077d771f431/bookkeeper-server/src/test/proto/TestDataFormats.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/proto/TestDataFormats.proto?ref=b1c12c0f41b7c27b2452fef311f12077d771f431","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+option java_package = \"org.apache.bookkeeper.proto\";\n+option optimize_for = SPEED;\n+\n+import \"src/main/proto/BookkeeperProtocol.proto\";\n+\n+enum AuthMessageType {\n+    SUCCESS_RESPONSE = 1;\n+    FAILURE_RESPONSE = 2;\n+    PAYLOAD_MESSAGE = 3;\n+}\n+\n+/**\n+ *\n+ */\n+extend AuthMessage {\n+    required AuthMessageType messageType = 1000;\n+}"}]}

