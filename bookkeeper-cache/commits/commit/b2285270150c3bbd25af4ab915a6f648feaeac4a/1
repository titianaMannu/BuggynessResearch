{"sha":"b2285270150c3bbd25af4ab915a6f648feaeac4a","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiMjI4NTI3MDE1MGMzYmJkMjVhZjRhYjkxNWE2ZjY0OGZlYWVhYzRh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-07-22T17:18:01Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-07-22T17:18:01Z"},"message":"BOOKKEEPER-607: Filtered Messages Require ACK from Client Causes User Being Throttled Incorrectly Forever (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1505735 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"197ba5e8e59d3d88b4c77665201536341c0ff73c","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/197ba5e8e59d3d88b4c77665201536341c0ff73c"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b2285270150c3bbd25af4ab915a6f648feaeac4a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b2285270150c3bbd25af4ab915a6f648feaeac4a","html_url":"https://github.com/apache/bookkeeper/commit/b2285270150c3bbd25af4ab915a6f648feaeac4a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b2285270150c3bbd25af4ab915a6f648feaeac4a/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"0139c8c8917e76e2d9b5e5e37450bae80b4c6884","url":"https://api.github.com/repos/apache/bookkeeper/commits/0139c8c8917e76e2d9b5e5e37450bae80b4c6884","html_url":"https://github.com/apache/bookkeeper/commit/0139c8c8917e76e2d9b5e5e37450bae80b4c6884"}],"stats":{"total":184,"additions":173,"deletions":11},"files":[{"sha":"3c2b1cc2c3e3e77155f1e10e5b8a47c06394f4eb","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/b2285270150c3bbd25af4ab915a6f648feaeac4a/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/b2285270150c3bbd25af4ab915a6f648feaeac4a/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=b2285270150c3bbd25af4ab915a6f648feaeac4a","patch":"@@ -54,6 +54,8 @@ Release 4.2.2 - Unreleased\n \n \tBOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)\n \n+        BOOKKEEPER-607: Filtered Messages Require ACK from Client Causes User Being Throttled Incorrectly Forever (sijie via ivank)\n+\n       hedwig-client:\n \n         BOOKKEEPER-598: Fails to compile - RESUBSCRIBE_EXCEPTION conflict (Matthew Farrellee via ivank)"},{"sha":"28b044d4b12a1744a7c7a49f020cab3aeb045ffe","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":26,"deletions":4,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/b2285270150c3bbd25af4ab915a6f648feaeac4a/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/b2285270150c3bbd25af4ab915a6f648feaeac4a/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=b2285270150c3bbd25af4ab915a6f648feaeac4a","patch":"@@ -139,6 +139,7 @@ public FIFODeliveryManager(PersistenceManager persistenceMgr, ServerConfiguratio\n         this.cfg = cfg;\n     }\n \n+    @Override\n     public void start() {\n         workerThread.start();\n     }\n@@ -205,7 +206,7 @@ public void startServingSubscription(ByteString topic, ByteString subscriberId,\n                                          MessageSeqId seqIdToStartFrom,\n                                          DeliveryEndPoint endPoint, ServerMessageFilter filter,\n                                          Callback<Void> callback, Object ctx) {\n-        ActiveSubscriberState subscriber = \n+        ActiveSubscriberState subscriber =\n             new ActiveSubscriberState(topic, subscriberId,\n                                       preferences,\n                                       seqIdToStartFrom.getLocalComponent() - 1,\n@@ -262,7 +263,7 @@ public void messageConsumed(ByteString topic, ByteString subscriberId,\n         if (null == subState) {\n             return;\n         }\n-        subState.messageConsumed(consumedSeqId.getLocalComponent()); \n+        subState.messageConsumed(consumedSeqId.getLocalComponent());\n     }\n \n     /**\n@@ -313,6 +314,7 @@ public void run() {\n     /**\n      * Stop method which will enqueue a ShutdownDeliveryManagerRequest.\n      */\n+    @Override\n     public void stop() {\n         enqueueWithoutFailure(new ShutdownDeliveryManagerRequest());\n     }\n@@ -528,8 +530,8 @@ protected synchronized void messageConsumed(long newSeqIdConsumed) {\n                 enqueueWithoutFailure(new DeliveryManagerRequest() {\n                     @Override\n                     public void performRequest() {\n-                        // enqueue \n-                        clearRetryDelayForSubscriber(ActiveSubscriberState.this);            \n+                        // enqueue\n+                        clearRetryDelayForSubscriber(ActiveSubscriberState.this);\n                     }\n                 });\n             }\n@@ -621,6 +623,19 @@ public void messageScanned(Object ctx, Message message) {\n             }\n \n             if (!filter.testMessage(message)) {\n+                // for filtered out messages, we don't deliver the message to client, so we would not\n+                // receive its consume request which moves the <i>lastSeqIdConsumedUtil</i> pointer.\n+                // we move the <i>lastSeqIdConsumedUtil</i> here for filtered out messages, which would\n+                // avoid a subscriber being throttled due to the message gap introduced by filtering.\n+                //\n+                // it is OK to move <i>lastSeqIdConsumedUtil</i> here, since this pointer is subscriber's\n+                // delivery state which to trottling deliver. changing <i>lastSeqIdConsumedUtil</i> would\n+                // not affect the subscriber's consume pointer in zookeeper which is managed in subscription\n+                // manager.\n+                //\n+                // And marking message consumed before calling sending finished, would avoid the subscriber\n+                // being throttled first and released from throttled state laster.\n+                messageConsumed(message.getMsgId().getLocalComponent());\n                 sendingFinished();\n                 return;\n             }\n@@ -641,6 +656,7 @@ public void messageScanned(Object ctx, Message message) {\n \n         }\n \n+        @Override\n         public void scanFailed(Object ctx, Exception exception) {\n             if (!checkConnected()) {\n                 return;\n@@ -650,6 +666,7 @@ public void scanFailed(Object ctx, Exception exception) {\n             retryErroredSubscriberAfterDelay(this);\n         }\n \n+        @Override\n         public void scanFinished(Object ctx, ReasonForFinish reason) {\n             checkConnected();\n         }\n@@ -658,6 +675,7 @@ public void scanFinished(Object ctx, ReasonForFinish reason) {\n          * ===============================================================\n          * {@link DeliveryCallback} methods\n          */\n+        @Override\n         public void sendingFinished() {\n             if (!isConnected()) {\n                 return;\n@@ -687,6 +705,7 @@ public synchronized long getLastSeqIdCommunicatedExternally() {\n         }\n \n \n+        @Override\n         public void permanentErrorOnSend() {\n             // the underlying channel is broken, the channel will\n             // be closed in UmbrellaHandler when exception happened.\n@@ -695,6 +714,7 @@ public void permanentErrorOnSend() {\n                                   NOP_CALLBACK, null);\n         }\n \n+        @Override\n         public void transientErrorOnSend() {\n             retryErroredSubscriberAfterDelay(this);\n         }\n@@ -703,6 +723,7 @@ public void transientErrorOnSend() {\n          * ===============================================================\n          * {@link DeliveryManagerRequest} methods\n          */\n+        @Override\n         public void performRequest() {\n             // Put this subscriber in the channel to subscriber mapping\n             ActiveSubscriberState prevSubscriber =\n@@ -847,6 +868,7 @@ public void performRequest() {\n         // This is a simple type of Request we will enqueue when the\n         // PubSubServer is shut down and we want to stop the DeliveryManager\n         // thread.\n+        @Override\n         public void performRequest() {\n             keepRunning = false;\n         }"},{"sha":"e284ace554c987eb9ff1e23490f316bf8793f95a","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","status":"modified","additions":145,"deletions":7,"changes":152,"blob_url":"https://github.com/apache/bookkeeper/blob/b2285270150c3bbd25af4ab915a6f648feaeac4a/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","raw_url":"https://github.com/apache/bookkeeper/raw/b2285270150c3bbd25af4ab915a6f648feaeac4a/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java?ref=b2285270150c3bbd25af4ab915a6f648feaeac4a","patch":"@@ -17,14 +17,18 @@\n  */\n package org.apache.hedwig.server.delivery;\n \n+import java.io.IOException;\n+\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.configuration.ConfigurationException;\n+ \n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -40,11 +44,19 @@\n import org.apache.hedwig.client.api.MessageHandler;\n import org.apache.hedwig.client.api.Publisher;\n import org.apache.hedwig.client.api.Subscriber;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.filter.MessageFilterBase;\n+import org.apache.hedwig.filter.ServerMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageHeader;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+\n import org.apache.hedwig.server.HedwigHubTestBase;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.util.Callback;\n@@ -53,6 +65,43 @@\n public class TestThrottlingDelivery extends HedwigHubTestBase {\n \n     private static final int DEFAULT_MESSAGE_WINDOW_SIZE = 10;\n+    private static final String OPT_MOD = \"MOD\";\n+\n+    static class ModMessageFilter implements ServerMessageFilter, ClientMessageFilter {\n+\n+        int mod;\n+\n+        @Override\n+        public MessageFilterBase setSubscriptionPreferences(ByteString topic, ByteString subscriberId,\n+                SubscriptionPreferences preferences) {\n+            Map<String, ByteString> userOptions = SubscriptionStateUtils.buildUserOptions(preferences);\n+            ByteString modValue = userOptions.get(OPT_MOD);\n+            if (null == modValue) {\n+                mod = 0;\n+            } else {\n+                mod = Integer.valueOf(modValue.toStringUtf8());\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean testMessage(Message message) {\n+            int value = Integer.valueOf(message.getBody().toStringUtf8());\n+            return 0 == value % mod;\n+        }\n+\n+        @Override\n+        public ServerMessageFilter initialize(Configuration conf) throws ConfigurationException, IOException {\n+            // do nothing\n+            return this;\n+        }\n+\n+        @Override\n+        public void uninitialize() {\n+            // do nothing\n+        }\n+\n+    }\n \n     protected class ThrottleDeliveryServerConfiguration extends HubServerConfiguration {\n \n@@ -62,7 +111,7 @@\n \n         @Override\n         public int getDefaultMessageWindowSize() {\n-            return TestThrottlingDelivery.this.DEFAULT_MESSAGE_WINDOW_SIZE;\n+            return TestThrottlingDelivery.DEFAULT_MESSAGE_WINDOW_SIZE;\n         }\n     }\n \n@@ -71,7 +120,7 @@ public int getDefaultMessageWindowSize() {\n         int messageWindowSize;\n \n         ThrottleDeliveryClientConfiguration() {\n-            this(TestThrottlingDelivery.this.DEFAULT_MESSAGE_WINDOW_SIZE);\n+            this(TestThrottlingDelivery.DEFAULT_MESSAGE_WINDOW_SIZE);\n         }\n \n         ThrottleDeliveryClientConfiguration(int messageWindowSize) {\n@@ -98,6 +147,73 @@ public boolean isSubscriptionChannelSharingEnabled() {\n         }\n     }\n \n+    private void publishNums(Publisher pub, ByteString topic, int start, int num, int M) throws Exception {\n+        for (int i = 1; i <= num; i++) {\n+            PubSubProtocol.Map.Builder propsBuilder = PubSubProtocol.Map.newBuilder().addEntries(\n+                    PubSubProtocol.Map.Entry.newBuilder().setKey(OPT_MOD)\n+                            .setValue(ByteString.copyFromUtf8(String.valueOf((start + i) % M))));\n+            MessageHeader.Builder headerBuilder = MessageHeader.newBuilder().setProperties(propsBuilder);\n+            Message msg = Message.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(start + i)))\n+                    .setHeader(headerBuilder).build();\n+            pub.publish(topic, msg);\n+        }\n+    }\n+\n+    private void throttleWithFilter(Publisher pub, final Subscriber sub,\n+                           ByteString topic, ByteString subid,\n+                           final int X) throws Exception {\n+        // publish numbers with header (so only 3 messages would be delivered)\n+        publishNums(pub, topic, 0, 3 * X, X);\n+\n+        // subscribe the topic with filter\n+        PubSubProtocol.Map userOptions = PubSubProtocol.Map\n+                .newBuilder()\n+                .addEntries(\n+                        PubSubProtocol.Map.Entry.newBuilder().setKey(OPT_MOD)\n+                                .setValue(ByteString.copyFromUtf8(String.valueOf(X)))).build();\n+        SubscriptionOptions opts = SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH)\n+                .setOptions(userOptions).setMessageFilter(ModMessageFilter.class.getName()).build();\n+        sub.subscribe(topic, subid, opts);\n+\n+        final AtomicInteger expected = new AtomicInteger(X);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        sub.startDelivery(topic, subid, new MessageHandler() {\n+            @Override\n+            public synchronized void deliver(ByteString topic, ByteString subscriberId,\n+                                             Message msg,\n+                                             Callback<Void> callback, Object context) {\n+                try {\n+                    int value = Integer.valueOf(msg.getBody().toStringUtf8());\n+                    logger.debug(\"Received message {},\", value);\n+\n+                    if (value == expected.get()) {\n+                        expected.addAndGet(X);\n+                    } else {\n+                        // error condition\n+                        logger.error(\"Did not receive expected value, expected {}, got {}\",\n+                                     expected.get(), value);\n+                        expected.set(0);\n+                        latch.countDown();\n+                    }\n+                    if (value == 3 * X) {\n+                        latch.countDown();\n+                    }\n+                    callback.operationFinished(context, null);\n+                    sub.consume(topic, subscriberId, msg.getMsgId());\n+                } catch (Exception e) {\n+                    logger.error(\"Received bad message\", e);\n+                    latch.countDown();\n+                }\n+            }\n+        });\n+\n+        assertTrue(\"Timed out waiting for messages \" + 3 * X, latch.await(10, TimeUnit.SECONDS));\n+        assertEquals(\"Should be expected message with \" + 4 * X, 4 * X, expected.get());\n+\n+        sub.stopDelivery(topic, subid);\n+        sub.closeSubscription(topic, subid);\n+    }\n+\n     private void throttleX(Publisher pub, final Subscriber sub,\n                            ByteString topic, ByteString subid,\n                            final int X) throws Exception {\n@@ -138,7 +254,7 @@ public synchronized void deliver(ByteString topic, ByteString subscriberId,\n                     callback.operationFinished(context, null);\n                     if (expected.get() > X + 1) {\n                         sub.consume(topic, subscriberId, msg.getMsgId());\n-                    }      \n+                    }\n                 } catch (Exception e) {\n                     logger.error(\"Received bad message\", e);\n                     throttleLatch.countDown();\n@@ -197,7 +313,7 @@ public void testServerSideThrottle() throws Exception {\n         Publisher pub = client.getPublisher();\n         Subscriber sub = client.getSubscriber();\n \n-        ByteString topic = ByteString.copyFromUtf8(\"testServerSideThrottle\"); \n+        ByteString topic = ByteString.copyFromUtf8(\"testServerSideThrottle\");\n         ByteString subid = ByteString.copyFromUtf8(\"serverThrottleSub\");\n         sub.subscribe(topic, subid, CreateOrAttach.CREATE);\n         sub.closeSubscription(topic, subid);\n@@ -228,4 +344,26 @@ public void testServerSideThrottle() throws Exception {\n         client.close();\n     }\n \n+    @Test(timeout = 60000)\n+    public void testThrottleWithServerSideFilter() throws Exception {\n+        int messageWindowSize = DEFAULT_MESSAGE_WINDOW_SIZE;\n+        ThrottleDeliveryClientConfiguration conf = new ThrottleDeliveryClientConfiguration();\n+        HedwigClient client = new HedwigClient(conf);\n+        Publisher pub = client.getPublisher();\n+        Subscriber sub = client.getSubscriber();\n+\n+        ByteString topic = ByteString.copyFromUtf8(\"testThrottleWithServerSideFilter\");\n+        ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n+        SubscriptionOptions opts = SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE).build();\n+        sub.subscribe(topic, subid, opts);\n+        sub.closeSubscription(topic, subid);\n+\n+        // message gap: half of the throttle threshold\n+        throttleWithFilter(pub, sub, topic, subid, messageWindowSize / 2);\n+        // message gap: equals to the throttle threshold\n+        throttleWithFilter(pub, sub, topic, subid, messageWindowSize);\n+        // message gap: larger than the throttle threshold\n+        throttleWithFilter(pub, sub, topic, subid, messageWindowSize + messageWindowSize / 2);\n+    }\n+\n }"}]}

