{"sha":"b4bac04a8141fa116223de8028471facbe343555","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiNGJhYzA0YTgxNDFmYTExNjIyM2RlODAyODQ3MWZhY2JlMzQzNTU1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-02-06T15:28:24Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-02-06T15:28:24Z"},"message":"BOOKKEEPER-526: multiple threads for delivery manager (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1443017 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9815e4056235eb0a7894d60902a8822ea66f6d6b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9815e4056235eb0a7894d60902a8822ea66f6d6b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b4bac04a8141fa116223de8028471facbe343555","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b4bac04a8141fa116223de8028471facbe343555","html_url":"https://github.com/apache/bookkeeper/commit/b4bac04a8141fa116223de8028471facbe343555","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b4bac04a8141fa116223de8028471facbe343555/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"e95b9392d4ba38c68617dff16de53e523d8ea51b","url":"https://api.github.com/repos/apache/bookkeeper/commits/e95b9392d4ba38c68617dff16de53e523d8ea51b","html_url":"https://github.com/apache/bookkeeper/commit/e95b9392d4ba38c68617dff16de53e523d8ea51b"}],"stats":{"total":347,"additions":211,"deletions":136},"files":[{"sha":"68f1ebabfe521d65b6f3ba87d363cedbc9af1159","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/b4bac04a8141fa116223de8028471facbe343555/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/b4bac04a8141fa116223de8028471facbe343555/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=b4bac04a8141fa116223de8028471facbe343555","patch":"@@ -12,6 +12,8 @@ Trunk (unreleased changes)\n \n     IMPROVEMENTS:\n \n+      BOOKKEEPER-526: multiple threads for delivery manager (sijie via ivank)\n+\n       BOOKKEEPER-544: Modify hedwig server tests to allow client testcases to start/stop them as part of their tests (mridul via ivank)\n \n       BOOKKEEPER-312: Implementation of JMS provider (mridul via ivank)"},{"sha":"d8b87b270e8c417d55c646f9c059fbb832b81825","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/b4bac04a8141fa116223de8028471facbe343555/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/b4bac04a8141fa116223de8028471facbe343555/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=b4bac04a8141fa116223de8028471facbe343555","patch":"@@ -69,6 +69,7 @@\n     protected final static String DEFAULT_MESSAGE_WINDOW_SIZE =\n         \"default_message_window_size\";\n     protected final static String NUM_READAHEAD_CACHE_THREADS = \"num_readahead_cache_threads\";\n+    protected final static String NUM_DELIVERY_THREADS = \"num_delivery_threads\";\n \n     protected final static String MAX_ENTRIES_PER_LEDGER = \"max_entries_per_ledger\";\n \n@@ -531,6 +532,15 @@ public int getNumReadAheadCacheThreads() {\n         return conf.getInt(NUM_READAHEAD_CACHE_THREADS, Runtime.getRuntime().availableProcessors());\n     }\n \n+    /**\n+     * Get number of delivery threads\n+     *\n+     * @return number of delivery threads.\n+     */\n+    public int getNumDeliveryThreads() {\n+        return conf.getInt(NUM_DELIVERY_THREADS, Runtime.getRuntime().availableProcessors());\n+    }\n+\n     /**\n      * Whether enable metadata manager based topic manager.\n      *"},{"sha":"06c21912cb8ac1b352071d48d2fc811bc05e7e18","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":199,"deletions":136,"changes":335,"blob_url":"https://github.com/apache/bookkeeper/blob/b4bac04a8141fa116223de8028471facbe343555/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/b4bac04a8141fa116223de8028471facbe343555/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=b4bac04a8141fa116223de8028471facbe343555","patch":"@@ -18,14 +18,15 @@\n package org.apache.hedwig.server.delivery;\n \n import java.util.Comparator;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.TreeMap;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n@@ -63,7 +64,7 @@\n import org.apache.hedwig.util.Callback;\n import static org.apache.hedwig.util.VarArgs.va;\n \n-public class FIFODeliveryManager implements Runnable, DeliveryManager, SubChannelDisconnectedListener {\n+public class FIFODeliveryManager implements DeliveryManager, SubChannelDisconnectedListener {\n \n     protected static final Logger logger = LoggerFactory.getLogger(FIFODeliveryManager.class);\n \n@@ -80,50 +81,181 @@ public void operationFailed(Object ctx, PubSubException exception) {\n         public void performRequest();\n     }\n \n-    /**\n-     * the main queue that the single-threaded delivery manager works off of\n-     */\n-    BlockingQueue<DeliveryManagerRequest> requestQueue = new LinkedBlockingQueue<DeliveryManagerRequest>();\n-\n-    /**\n-     * The queue of all subscriptions that are facing a transient error either\n-     * in scanning from the persistence manager, or in sending to the consumer\n-     */\n-    Queue<ActiveSubscriberState> retryQueue =\n-        new PriorityBlockingQueue<ActiveSubscriberState>(32, new Comparator<ActiveSubscriberState>() {\n-            @Override\n-            public int compare(ActiveSubscriberState as1, ActiveSubscriberState as2) {\n-                long s = as1.lastScanErrorTime - as2.lastScanErrorTime;\n-                return s > 0 ? 1 : (s < 0 ? -1 : 0);\n-            }\n-        });\n-\n     /**\n      * Stores a mapping from topic to the delivery pointers on the topic. The\n      * delivery pointers are stored in a sorted map from seq-id to the set of\n      * subscribers at that seq-id\n      */\n-    Map<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>> perTopicDeliveryPtrs;\n+    ConcurrentMap<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>> perTopicDeliveryPtrs;\n \n     /**\n      * Mapping from delivery end point to the subscriber state that we are\n      * serving at that end point. This prevents us e.g., from serving two\n      * subscriptions to the same endpoint\n      */\n-    Map<TopicSubscriber, ActiveSubscriberState> subscriberStates;\n+    ConcurrentMap<TopicSubscriber, ActiveSubscriberState> subscriberStates;\n \n     private final ReadAheadCache cache;\n     private final PersistenceManager persistenceMgr;\n \n     private ServerConfiguration cfg;\n \n-    // Boolean indicating if this thread should continue running. This is used\n-    // when we want to stop the thread during a PubSubServer shutdown.\n-    protected boolean keepRunning = true;\n-    private final Thread workerThread;\n+    private final int numDeliveryWorkers;\n+    private final DeliveryWorker[] deliveryWorkers;\n+\n+    private class DeliveryWorker implements Runnable {\n+\n+        BlockingQueue<DeliveryManagerRequest> requestQueue =\n+            new LinkedBlockingQueue<DeliveryManagerRequest>();;\n+\n+        /**\n+         * The queue of all subscriptions that are facing a transient error either\n+         * in scanning from the persistence manager, or in sending to the consumer\n+         */\n+        Queue<ActiveSubscriberState> retryQueue =\n+            new PriorityBlockingQueue<ActiveSubscriberState>(32, new Comparator<ActiveSubscriberState>() {\n+                @Override\n+                public int compare(ActiveSubscriberState as1, ActiveSubscriberState as2) {\n+                    long s = as1.lastScanErrorTime - as2.lastScanErrorTime;\n+                    return s > 0 ? 1 : (s < 0 ? -1 : 0);\n+                }\n+            });\n+\n+        // Boolean indicating if this thread should continue running. This is used\n+        // when we want to stop the thread during a PubSubServer shutdown.\n+        protected volatile boolean keepRunning = true;\n+        private final Thread workerThread;\n+        private final int idx;\n+\n+        private Object suspensionLock = new Object();\n+        private boolean suspended = false;\n+\n+        DeliveryWorker(int index) {\n+            this.idx = index;\n+            workerThread = new Thread(this, \"DeliveryManagerThread-\" + index);\n+        }\n+\n+        void start() {\n+            workerThread.start();\n+        }\n+\n+        /**\n+         * Stop method which will enqueue a ShutdownDeliveryManagerRequest.\n+         */\n+        void stop() {\n+            enqueueWithoutFailure(new ShutdownDeliveryManagerRequest());\n+        }\n+\n+        /**\n+         * Stop FIFO delivery worker from processing requests. (for testing)\n+         */\n+        void suspendProcessing() {\n+            synchronized(suspensionLock) {\n+                suspended = true;\n+            }\n+        }\n+\n+        /**\n+         * Resume FIFO delivery worker. (for testing)\n+         */\n+        void resumeProcessing() {\n+            synchronized(suspensionLock) {\n+                suspended = false;\n+                suspensionLock.notify();\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (keepRunning) {\n+                DeliveryManagerRequest request = null;\n+\n+                try {\n+                    // We use a timeout of 1 second, so that we can wake up once in\n+                    // a while to check if there is something in the retry queue.\n+                    request = requestQueue.poll(1, TimeUnit.SECONDS);\n+                    synchronized(suspensionLock) {\n+                        while (suspended) {\n+                            suspensionLock.wait();\n+                        }\n+                    }\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+\n+                // First retry any subscriptions that had failed and need a retry\n+                retryErroredSubscribers();\n+\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                request.performRequest();\n+\n+            }\n+        }\n+\n+        protected void enqueueWithoutFailure(DeliveryManagerRequest request) {\n+            if (!requestQueue.offer(request)) {\n+                throw new UnexpectedError(\"Could not enqueue object: \" + request\n+                    + \" to request queue for delivery worker .\" + idx);\n+            }\n+        }\n+\n+        public void retryErroredSubscriberAfterDelay(ActiveSubscriberState subscriber) {\n+            subscriber.setLastScanErrorTime(MathUtils.now());\n+\n+            if (!retryQueue.offer(subscriber)) {\n+                throw new UnexpectedError(\"Could not enqueue to retry queue for delivery worker \" + idx);\n+            }\n+            getDeliveryWorker(subscriber.getTopic()).retryErroredSubscriberAfterDelay(subscriber);\n+        }\n+\n+        public void clearRetryDelayForSubscriber(ActiveSubscriberState subscriber) {\n+            subscriber.clearLastScanErrorTime();\n+            if (!retryQueue.offer(subscriber)) {\n+                throw new UnexpectedError(\"Could not enqueue to delivery manager retry queue\");\n+            }\n+            // no request in request queue now\n+            // issue a empty delivery request to not waiting for polling requests queue\n+            if (requestQueue.isEmpty()) {\n+                enqueueWithoutFailure(new DeliveryManagerRequest() {\n+                        @Override\n+                        public void performRequest() {\n+                        // do nothing\n+                        }\n+                        });\n+            }\n+        }\n+\n+        protected void retryErroredSubscribers() {\n+            long lastInterestingFailureTime = MathUtils.now() - cfg.getScanBackoffPeriodMs();\n+            ActiveSubscriberState subscriber;\n+\n+            while ((subscriber = retryQueue.peek()) != null) {\n+                if (subscriber.getLastScanErrorTime() > lastInterestingFailureTime) {\n+                    // Not enough time has elapsed yet, will retry later\n+                    // Since the queue is fifo, no need to check later items\n+                    return;\n+                }\n+\n+                // retry now\n+                subscriber.deliverNextMessage();\n+                retryQueue.poll();\n+            }\n+        }\n+\n+        protected class ShutdownDeliveryManagerRequest implements DeliveryManagerRequest {\n+            // This is a simple type of Request we will enqueue when the\n+            // PubSubServer is shut down and we want to stop the DeliveryManager\n+            // thread.\n+            public void performRequest() {\n+                keepRunning = false;\n+            }\n+        }\n+\n+    }\n \n-    private Object suspensionLock = new Object();\n-    private boolean suspended = false;\n \n \n     public FIFODeliveryManager(PersistenceManager persistenceMgr, ServerConfiguration cfg) {\n@@ -133,23 +265,32 @@ public FIFODeliveryManager(PersistenceManager persistenceMgr, ServerConfiguratio\n         } else {\n             this.cache = null;\n         }\n-        perTopicDeliveryPtrs = new HashMap<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>>();\n-        subscriberStates = new HashMap<TopicSubscriber, ActiveSubscriberState>();\n-        workerThread = new Thread(this, \"DeliveryManagerThread\");\n+        perTopicDeliveryPtrs =\n+            new ConcurrentHashMap<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>>();\n+        subscriberStates =\n+            new ConcurrentHashMap<TopicSubscriber, ActiveSubscriberState>();\n         this.cfg = cfg;\n+        // initialize the delivery workers\n+        this.numDeliveryWorkers = cfg.getNumDeliveryThreads();\n+        this.deliveryWorkers = new DeliveryWorker[numDeliveryWorkers];\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i] = new DeliveryWorker(i);\n+        }\n     }\n \n     public void start() {\n-        workerThread.start();\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].start();\n+        }\n     }\n \n     /**\n      * Stop FIFO delivery manager from processing requests. (for testing)\n      */\n     @VisibleForTesting\n     public void suspendProcessing() {\n-        synchronized(suspensionLock) {\n-            suspended = true;\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].suspendProcessing();\n         }\n     }\n \n@@ -158,28 +299,33 @@ public void suspendProcessing() {\n      */\n     @VisibleForTesting\n     public void resumeProcessing() {\n-        synchronized(suspensionLock) {\n-            suspended = false;\n-            suspensionLock.notify();\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].resumeProcessing();\n         }\n     }\n \n     /**\n-     * ===================================================================== Our\n-     * usual enqueue function, stop if error because of unbounded queue, should\n-     * never happen\n-     *\n+     * Stop the FIFO delivery manager.\n      */\n-    protected void enqueueWithoutFailure(DeliveryManagerRequest request) {\n-        if (!requestQueue.offer(request)) {\n-            throw new UnexpectedError(\"Could not enqueue object: \" + request + \" to delivery manager request queue.\");\n+    public void stop() {\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].stop();\n         }\n     }\n \n+    private DeliveryWorker getDeliveryWorker(ByteString topic) {\n+        return deliveryWorkers[MathUtils.signSafeMod(topic.hashCode(), numDeliveryWorkers)];\n+    }\n+\n     /**\n-     * ====================================================================\n-     * Public interface of the delivery manager\n+     * ===================================================================== Our\n+     * usual enqueue function, stop if error because of unbounded queue, should\n+     * never happen\n+     *\n      */\n+    protected void enqueueWithoutFailure(ByteString topic, DeliveryManagerRequest request) {\n+        getDeliveryWorker(topic).enqueueWithoutFailure(request);\n+    }\n \n     /**\n      * Tells the delivery manager to start sending out messages for a particular\n@@ -211,13 +357,13 @@ public void startServingSubscription(ByteString topic, ByteString subscriberId,\n                                       seqIdToStartFrom.getLocalComponent() - 1,\n                                       endPoint, filter, callback, ctx);\n \n-        enqueueWithoutFailure(subscriber);\n+        enqueueWithoutFailure(topic, subscriber);\n     }\n \n     public void stopServingSubscriber(ByteString topic, ByteString subscriberId,\n                                       SubscriptionEvent event,\n                                       Callback<Void> cb, Object ctx) {\n-        enqueueWithoutFailure(new StopServingSubscriber(topic, subscriberId, event, cb, ctx));\n+        enqueueWithoutFailure(topic, new StopServingSubscriber(topic, subscriberId, event, cb, ctx));\n     }\n \n     /**\n@@ -227,29 +373,11 @@ public void stopServingSubscriber(ByteString topic, ByteString subscriberId,\n      * @param subscriber\n      */\n     public void retryErroredSubscriberAfterDelay(ActiveSubscriberState subscriber) {\n-\n-        subscriber.setLastScanErrorTime(MathUtils.now());\n-\n-        if (!retryQueue.offer(subscriber)) {\n-            throw new UnexpectedError(\"Could not enqueue to delivery manager retry queue\");\n-        }\n+        getDeliveryWorker(subscriber.getTopic()).retryErroredSubscriberAfterDelay(subscriber);\n     }\n \n     public void clearRetryDelayForSubscriber(ActiveSubscriberState subscriber) {\n-        subscriber.clearLastScanErrorTime();\n-        if (!retryQueue.offer(subscriber)) {\n-            throw new UnexpectedError(\"Could not enqueue to delivery manager retry queue\");\n-        }\n-        // no request in request queue now\n-        // issue a empty delivery request to not waiting for polling requests queue\n-        if (requestQueue.isEmpty()) {\n-            enqueueWithoutFailure(new DeliveryManagerRequest() {\n-                    @Override\n-                    public void performRequest() {\n-                    // do nothing\n-                    }\n-                    });\n-        }\n+        getDeliveryWorker(subscriber.getTopic()).clearRetryDelayForSubscriber(subscriber);\n     }\n \n     // TODO: for now, I don't move messageConsumed request to delivery manager thread,\n@@ -274,64 +402,8 @@ public void messageConsumed(ByteString topic, ByteString subscriberId,\n      * @param newSeqId\n      */\n     public void moveDeliveryPtrForward(ActiveSubscriberState subscriber, long prevSeqId, long newSeqId) {\n-        enqueueWithoutFailure(new DeliveryPtrMove(subscriber, prevSeqId, newSeqId));\n-    }\n-\n-    /*\n-     * ==========================================================================\n-     * == End of public interface, internal machinery begins.\n-     */\n-    public void run() {\n-        while (keepRunning) {\n-            DeliveryManagerRequest request = null;\n-\n-            try {\n-                // We use a timeout of 1 second, so that we can wake up once in\n-                // a while to check if there is something in the retry queue.\n-                request = requestQueue.poll(1, TimeUnit.SECONDS);\n-                synchronized(suspensionLock) {\n-                    while (suspended) {\n-                        suspensionLock.wait();\n-                    }\n-                }\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-            }\n-\n-            // First retry any subscriptions that had failed and need a retry\n-            retryErroredSubscribers();\n-\n-            if (request == null) {\n-                continue;\n-            }\n-\n-            request.performRequest();\n-\n-        }\n-    }\n-\n-    /**\n-     * Stop method which will enqueue a ShutdownDeliveryManagerRequest.\n-     */\n-    public void stop() {\n-        enqueueWithoutFailure(new ShutdownDeliveryManagerRequest());\n-    }\n-\n-    protected void retryErroredSubscribers() {\n-        long lastInterestingFailureTime = MathUtils.now() - cfg.getScanBackoffPeriodMs();\n-        ActiveSubscriberState subscriber;\n-\n-        while ((subscriber = retryQueue.peek()) != null) {\n-            if (subscriber.getLastScanErrorTime() > lastInterestingFailureTime) {\n-                // Not enough time has elapsed yet, will retry later\n-                // Since the queue is fifo, no need to check later items\n-                return;\n-            }\n-\n-            // retry now\n-            subscriber.deliverNextMessage();\n-            retryQueue.poll();\n-        }\n+        enqueueWithoutFailure(subscriber.getTopic(),\n+            new DeliveryPtrMove(subscriber, prevSeqId, newSeqId));\n     }\n \n     protected void removeDeliveryPtr(ActiveSubscriberState subscriber, Long seqId, boolean isAbsenceOk,\n@@ -525,7 +597,7 @@ protected synchronized void messageConsumed(long newSeqIdConsumed) {\n                 logger.info(\"Try to wake up subscriber ({}) to deliver messages again : last delivered {}, last consumed {}.\",\n                             va(this, lastLocalSeqIdDelivered, lastSeqIdConsumedUtil));\n \n-                enqueueWithoutFailure(new DeliveryManagerRequest() {\n+                enqueueWithoutFailure(topic, new DeliveryManagerRequest() {\n                     @Override\n                     public void performRequest() {\n                         // enqueue \n@@ -843,15 +915,6 @@ public void performRequest() {\n         }\n     }\n \n-    protected class ShutdownDeliveryManagerRequest implements DeliveryManagerRequest {\n-        // This is a simple type of Request we will enqueue when the\n-        // PubSubServer is shut down and we want to stop the DeliveryManager\n-        // thread.\n-        public void performRequest() {\n-            keepRunning = false;\n-        }\n-    }\n-\n     /**\n      * ====================================================================\n      *"}]}

