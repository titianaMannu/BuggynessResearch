{"sha":"b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiNGU5ODViMzJjYmI1YWE3YzZiMTA5ODk4ZjlkOGJmNTFiMmZkMzMw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-03T10:06:24Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-03T10:06:24Z"},"message":"BOOKKEEPER-409: Integration Test - Perform bookie rereplication cycle by Auditor-RW processes (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1428258 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2414eef4fd9a97a9c2508a4c5ec9c572b609f2b4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/2414eef4fd9a97a9c2508a4c5ec9c572b609f2b4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","html_url":"https://github.com/apache/bookkeeper/commit/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","url":"https://api.github.com/repos/apache/bookkeeper/commits/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0","html_url":"https://github.com/apache/bookkeeper/commit/a27b64e340a6ad12f1e9588d1d55fa51f0b2d1f0"}],"stats":{"total":609,"additions":579,"deletions":30},"files":[{"sha":"0bb4c4553be6d85e0b01f15a554fc3d0e7a23b1b","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","patch":"@@ -281,6 +281,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-463: Refactor garbage collection code for ease to plugin different GC algorithm. (Fangmin, ivank, fpj via sijie)\n \n+        BOOKKEEPER-409: Integration Test - Perform bookie rereplication cycle by Auditor-RW processes (rakeshr via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"4a0bd229161749843a70bf54772f6649e31192a2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","patch":"@@ -289,13 +289,15 @@ public void shutdown() {\n             }\n             workerRunning = false;\n         }\n+        this.pendingReplicationTimer.cancel();\n         try {\n-            underreplicationManager.close();\n-        } catch (UnavailableException e) {\n-            LOG.warn(\"Exception while closing the \"\n-                    + \"ZkLedgerUnderrepliationManager\", e);\n+            this.workerThread.interrupt();\n+            this.workerThread.join();\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Interrupted during shutting down replication worker : \",\n+                    e);\n+            Thread.currentThread().interrupt();\n         }\n-        this.pendingReplicationTimer.cancel();\n         try {\n             bkc.close();\n         } catch (InterruptedException e) {\n@@ -305,12 +307,10 @@ public void shutdown() {\n             LOG.warn(\"Exception while closing the Bookie client\", e);\n         }\n         try {\n-            this.workerThread.interrupt();\n-            this.workerThread.join();\n-        } catch (InterruptedException e) {\n-            LOG.error(\"Interrupted during shutting down replication worker : \",\n-                    e);\n-            Thread.currentThread().interrupt();\n+            underreplicationManager.close();\n+        } catch (UnavailableException e) {\n+            LOG.warn(\"Exception while closing the \"\n+                    + \"ZkLedgerUnderrepliationManager\", e);\n         }\n     }\n "},{"sha":"c902b35b30c2de9050a47b978849875b9bff5123","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"added","additions":418,"deletions":0,"changes":418,"blob_url":"https://github.com/apache/bookkeeper/blob/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","patch":"@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerHandleAdapter;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.data.Stat;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Integration tests verifies the complete functionality of the\n+ * Auditor-rereplication process: Auditor will publish the bookie failures,\n+ * consequently ReplicationWorker will get the notifications and act on it.\n+ */\n+public class BookieAutoRecoveryTest extends\n+        MultiLedgerManagerTestCase {\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(BookieAutoRecoveryTest.class);\n+    private static final byte[] PASSWD = \"admin\".getBytes();\n+    private static final byte[] data = \"TESTDATA\".getBytes();\n+    private static final String openLedgerRereplicationGracePeriod = \"3000\"; // milliseconds\n+\n+    private DigestType digestType;\n+    private LedgerManagerFactory mFactory;\n+    private LedgerUnderreplicationManager underReplicationManager;\n+    private LedgerManager ledgerManager;\n+\n+    private final String UNDERREPLICATED_PATH = baseClientConf\n+            .getZkLedgersRootPath() + \"/underreplication/ledgers\";\n+\n+    public BookieAutoRecoveryTest(String ledgerManagerFactory) throws IOException, KeeperException,\n+            InterruptedException, UnavailableException, CompatibilityException {\n+        super(3);\n+        LOG.info(\"Running test case using ledger manager : \"\n+                + ledgerManagerFactory);\n+        // set ledger manager name\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseConf.setOpenLedgerRereplicationGracePeriod(openLedgerRereplicationGracePeriod);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        this.digestType = DigestType.MAC;\n+        setAutoRecoveryEnabled(true);\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        baseConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        // initialize urReplicationManager\n+        mFactory = LedgerManagerFactory.newLedgerManagerFactory(baseClientConf,\n+                zkc);\n+        underReplicationManager = mFactory.newLedgerUnderreplicationManager();\n+        LedgerManagerFactory newLedgerManagerFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseClientConf, zkc);\n+        ledgerManager = newLedgerManagerFactory.newLedgerManager();\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        if (null != mFactory) {\n+            mFactory.uninitialize();\n+            mFactory = null;\n+        }\n+        if (null != underReplicationManager) {\n+            underReplicationManager.close();\n+            underReplicationManager = null;\n+        }\n+        if (null != ledgerManager) {\n+            ledgerManager.close();\n+            ledgerManager = null;\n+        }\n+    }\n+\n+    /**\n+     * Test verifies publish urLedger by Auditor and replication worker is\n+     * picking up the entries and finishing the rereplication of open ledger\n+     */\n+    @Test(timeout = 90000)\n+    public void testOpenLedgers() throws Exception {\n+        List<LedgerHandle> listOfLedgerHandle = createLedgersAndAddEntries(1, 5);\n+        LedgerHandle lh = listOfLedgerHandle.get(0);\n+        int ledgerReplicaIndex = 0;\n+        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles().get(0L).get(0);\n+\n+        final String urLedgerZNode = getUrLedgerZNode(lh);\n+        ledgerReplicaIndex = getReplicaIndexInLedger(lh, replicaToKillAddr);\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+        assertNull(\"UrLedger already exists!\",\n+                watchUrLedgerNode(urLedgerZNode, latch));\n+\n+        LOG.info(\"Killing Bookie :\" + replicaToKillAddr);\n+        killBookie(replicaToKillAddr);\n+\n+        // waiting to publish urLedger znode by Auditor\n+        latch.await();\n+        latch = new CountDownLatch(1);\n+        LOG.info(\"Watching on urLedgerPath:\" + urLedgerZNode\n+                + \" to know the status of rereplication process\");\n+        assertNotNull(\"UrLedger doesn't exists!\",\n+                watchUrLedgerNode(urLedgerZNode, latch));\n+\n+        // starting the replication service, so that he will be able to act as\n+        // target bookie\n+        startNewBookie();\n+        int newBookieIndex = bs.size() - 1;\n+        BookieServer newBookieServer = bs.get(newBookieIndex);\n+\n+        LOG.debug(\"Waiting to finish the replication of failed bookie : \"\n+                + replicaToKillAddr);\n+        latch.await();\n+\n+        // grace period to update the urledger metadata in zookeeper\n+        LOG.info(\"Waiting to update the urledger metadata in zookeeper\");\n+\n+        verifyLedgerEnsembleMetadataAfterReplication(newBookieServer,\n+                listOfLedgerHandle.get(0), ledgerReplicaIndex);\n+    }\n+\n+    /**\n+     * Test verifies publish urLedger by Auditor and replication worker is\n+     * picking up the entries and finishing the rereplication of closed ledgers\n+     */\n+    @Test(timeout = 90000)\n+    public void testClosedLedgers() throws Exception {\n+        List<Integer> listOfReplicaIndex = new ArrayList<Integer>();\n+        List<LedgerHandle> listOfLedgerHandle = createLedgersAndAddEntries(1, 5);\n+        closeLedgers(listOfLedgerHandle);\n+        LedgerHandle lhandle = listOfLedgerHandle.get(0);\n+        int ledgerReplicaIndex = 0;\n+        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+                .getLedgerMetadata(lhandle).getEnsembles().get(0L).get(0);\n+\n+        CountDownLatch latch = new CountDownLatch(listOfLedgerHandle.size());\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            ledgerReplicaIndex = getReplicaIndexInLedger(lh, replicaToKillAddr);\n+            listOfReplicaIndex.add(ledgerReplicaIndex);\n+            assertNull(\"UrLedger already exists!\",\n+                    watchUrLedgerNode(getUrLedgerZNode(lh), latch));\n+        }\n+\n+        LOG.info(\"Killing Bookie :\" + replicaToKillAddr);\n+        killBookie(replicaToKillAddr);\n+\n+        // waiting to publish urLedger znode by Auditor\n+        latch.await();\n+\n+        // Again watching the urLedger znode to know the replication status\n+        latch = new CountDownLatch(listOfLedgerHandle.size());\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            String urLedgerZNode = getUrLedgerZNode(lh);\n+            LOG.info(\"Watching on urLedgerPath:\" + urLedgerZNode\n+                    + \" to know the status of rereplication process\");\n+            assertNotNull(\"UrLedger doesn't exists!\",\n+                    watchUrLedgerNode(urLedgerZNode, latch));\n+        }\n+\n+        // starting the replication service, so that he will be able to act as\n+        // target bookie\n+        startNewBookie();\n+        int newBookieIndex = bs.size() - 1;\n+        BookieServer newBookieServer = bs.get(newBookieIndex);\n+\n+        LOG.debug(\"Waiting to finish the replication of failed bookie : \"\n+                + replicaToKillAddr);\n+\n+        // waiting to finish replication\n+        latch.await();\n+\n+        // grace period to update the urledger metadata in zookeeper\n+        LOG.info(\"Waiting to update the urledger metadata in zookeeper\");\n+\n+        for (int index = 0; index < listOfLedgerHandle.size(); index++) {\n+            verifyLedgerEnsembleMetadataAfterReplication(newBookieServer,\n+                    listOfLedgerHandle.get(index),\n+                    listOfReplicaIndex.get(index));\n+        }\n+    }\n+\n+    /**\n+     * Test stopping replica service while replication in progress. Considering\n+     * when there is an exception will shutdown Auditor and RW processes. After\n+     * restarting should be able to finish the re-replication activities\n+     */\n+    @Test(timeout = 90000)\n+    public void testStopWhileReplicationInProgress() throws Exception {\n+        int numberOfLedgers = 2;\n+        List<Integer> listOfReplicaIndex = new ArrayList<Integer>();\n+        List<LedgerHandle> listOfLedgerHandle = createLedgersAndAddEntries(\n+                numberOfLedgers, 5);\n+        closeLedgers(listOfLedgerHandle);\n+        LedgerHandle handle = listOfLedgerHandle.get(0);\n+        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+                .getLedgerMetadata(handle).getEnsembles().get(0L).get(0);\n+        LOG.info(\"Killing Bookie:\" + replicaToKillAddr);\n+\n+        // Each ledger, there will be two events : create urLedger and after\n+        // rereplication delete urLedger\n+        CountDownLatch latch = new CountDownLatch(listOfLedgerHandle.size());\n+        for (int i = 0; i < listOfLedgerHandle.size(); i++) {\n+            final String urLedgerZNode = getUrLedgerZNode(listOfLedgerHandle\n+                    .get(i));\n+            assertNull(\"UrLedger already exists!\",\n+                    watchUrLedgerNode(urLedgerZNode, latch));\n+            int replicaIndexInLedger = getReplicaIndexInLedger(\n+                    listOfLedgerHandle.get(i), replicaToKillAddr);\n+            listOfReplicaIndex.add(replicaIndexInLedger);\n+        }\n+\n+        LOG.info(\"Killing Bookie :\" + replicaToKillAddr);\n+        killBookie(replicaToKillAddr);\n+\n+        // waiting to publish urLedger znode by Auditor\n+        latch.await();\n+\n+        // Again watching the urLedger znode to know the replication status\n+        latch = new CountDownLatch(listOfLedgerHandle.size());\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            String urLedgerZNode = getUrLedgerZNode(lh);\n+            LOG.info(\"Watching on urLedgerPath:\" + urLedgerZNode\n+                    + \" to know the status of rereplication process\");\n+            assertNotNull(\"UrLedger doesn't exists!\",\n+                    watchUrLedgerNode(urLedgerZNode, latch));\n+        }\n+\n+        // starting the replication service, so that he will be able to act as\n+        // target bookie\n+        startNewBookie();\n+        int newBookieIndex = bs.size() - 1;\n+        BookieServer newBookieServer = bs.get(newBookieIndex);\n+\n+        LOG.debug(\"Waiting to finish the replication of failed bookie : \"\n+                + replicaToKillAddr);\n+        while (true) {\n+            if (latch.getCount() < numberOfLedgers || latch.getCount() <= 0) {\n+                stopReplicationService();\n+                LOG.info(\"Latch Count is:\" + latch.getCount());\n+                break;\n+            }\n+            // grace period to take breath\n+            Thread.sleep(1000);\n+        }\n+\n+        startReplicationService();\n+\n+        LOG.info(\"Waiting to finish rereplication processes\");\n+        latch.await();\n+\n+        // grace period to update the urledger metadata in zookeeper\n+        LOG.info(\"Waiting to update the urledger metadata in zookeeper\");\n+\n+        for (int index = 0; index < listOfLedgerHandle.size(); index++) {\n+            verifyLedgerEnsembleMetadataAfterReplication(newBookieServer,\n+                    listOfLedgerHandle.get(index),\n+                    listOfReplicaIndex.get(index));\n+        }\n+    }\n+\n+    /**\n+     * Verify the published urledgers of deleted ledgers(those ledgers where\n+     * deleted after publishing as urledgers by Auditor) should be cleared off\n+     * by the newly selected replica bookie\n+     */\n+    @Test(timeout = 30000)\n+    public void testNoSuchLedgerExists() throws Exception {\n+        List<LedgerHandle> listOfLedgerHandle = createLedgersAndAddEntries(2, 5);\n+        CountDownLatch latch = new CountDownLatch(listOfLedgerHandle.size());\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            assertNull(\"UrLedger already exists!\",\n+                    watchUrLedgerNode(getUrLedgerZNode(lh), latch));\n+        }\n+        InetSocketAddress replicaToKillAddr = LedgerHandleAdapter\n+                .getLedgerMetadata(listOfLedgerHandle.get(0)).getEnsembles()\n+                .get(0L).get(0);\n+        killBookie(replicaToKillAddr);\n+        replicaToKillAddr = LedgerHandleAdapter\n+                .getLedgerMetadata(listOfLedgerHandle.get(0)).getEnsembles()\n+                .get(0L).get(0);\n+        killBookie(replicaToKillAddr);\n+        // waiting to publish urLedger znode by Auditor\n+        latch.await();\n+\n+        latch = new CountDownLatch(listOfLedgerHandle.size());\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            assertNotNull(\"UrLedger doesn't exists!\",\n+                    watchUrLedgerNode(getUrLedgerZNode(lh), latch));\n+        }\n+\n+        // delete ledgers\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            bkc.deleteLedger(lh.getId());\n+        }\n+        startNewBookie();\n+\n+        // waiting to delete published urledgers, since it doesn't exists\n+        latch.await();\n+\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            assertNull(\"UrLedger still exists after rereplication\",\n+                    watchUrLedgerNode(getUrLedgerZNode(lh), latch));\n+        }\n+    }\n+\n+    private int getReplicaIndexInLedger(LedgerHandle lh,\n+            InetSocketAddress replicaToKill) {\n+        SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = LedgerHandleAdapter\n+                .getLedgerMetadata(lh).getEnsembles();\n+        int ledgerReplicaIndex = -1;\n+        for (InetSocketAddress addr : ensembles.get(0L)) {\n+            ++ledgerReplicaIndex;\n+            if (addr.equals(replicaToKill)) {\n+                break;\n+            }\n+        }\n+        return ledgerReplicaIndex;\n+    }\n+\n+    private void verifyLedgerEnsembleMetadataAfterReplication(\n+            BookieServer newBookieServer, LedgerHandle lh,\n+            int ledgerReplicaIndex) throws BKException, InterruptedException {\n+        LedgerHandle openLedger = bkc\n+                .openLedger(lh.getId(), digestType, PASSWD);\n+\n+        InetSocketAddress inetSocketAddress = LedgerHandleAdapter\n+                .getLedgerMetadata(openLedger).getEnsembles().get(0L)\n+                .get(ledgerReplicaIndex);\n+        assertEquals(\"Rereplication has been failed and ledgerReplicaIndex :\"\n+                + ledgerReplicaIndex, newBookieServer.getLocalAddress(),\n+                inetSocketAddress);\n+    }\n+\n+    private void closeLedgers(List<LedgerHandle> listOfLedgerHandle)\n+            throws InterruptedException, BKException {\n+        for (LedgerHandle lh : listOfLedgerHandle) {\n+            lh.close();\n+        }\n+    }\n+\n+    private List<LedgerHandle> createLedgersAndAddEntries(int numberOfLedgers,\n+            int numberOfEntries) throws InterruptedException, BKException {\n+        List<LedgerHandle> listOfLedgerHandle = new ArrayList<LedgerHandle>(\n+                numberOfLedgers);\n+        for (int index = 0; index < numberOfLedgers; index++) {\n+            LedgerHandle lh = bkc.createLedger(3, 3, digestType, PASSWD);\n+            listOfLedgerHandle.add(lh);\n+            for (int i = 0; i < numberOfEntries; i++) {\n+                lh.addEntry(data);\n+            }\n+        }\n+        return listOfLedgerHandle;\n+    }\n+\n+    private String getUrLedgerZNode(LedgerHandle lh) {\n+        return ZkLedgerUnderreplicationManager.getUrLedgerZnode(\n+                UNDERREPLICATED_PATH, lh.getId());\n+    }\n+\n+    private Stat watchUrLedgerNode(final String znode,\n+            final CountDownLatch latch) throws KeeperException,\n+            InterruptedException {\n+        return zkc.exists(znode, new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                if (event.getType() == EventType.NodeDeleted) {\n+                    LOG.info(\"Recieved Ledger rereplication completion event :\"\n+                            + event.getType());\n+                    latch.countDown();\n+                }\n+                if (event.getType() == EventType.NodeCreated) {\n+                    LOG.info(\"Recieved urLedger publishing event :\"\n+                            + event.getType());\n+                    latch.countDown();\n+                }\n+            }\n+        });\n+    }\n+}"},{"sha":"e87a8b7b314690e51aca9f36563ac4964db8bf47","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":148,"deletions":19,"changes":167,"blob_url":"https://github.com/apache/bookkeeper/blob/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=b4e985b32cbb5aa7c6b109898f9d8bf51b2fd330","patch":"@@ -21,33 +21,38 @@\n \n package org.apache.bookkeeper.test;\n \n-import java.io.IOException;\n import java.io.File;\n+import java.io.IOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CountDownLatch;\n \n-import org.apache.bookkeeper.bookie.BookieException;\n+import junit.framework.TestCase;\n+\n import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.client.BookKeeperTestClient;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.metastore.InMemoryMetaStore;\n import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.replication.AutoRecoveryMain;\n+import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.commons.io.FileUtils;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.junit.After;\n import org.junit.Before;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import junit.framework.TestCase;\n-\n /**\n  * A class runs several bookie servers for testing.\n  */\n@@ -69,6 +74,10 @@\n     protected ServerConfiguration baseConf = new ServerConfiguration();\n     protected ClientConfiguration baseClientConf = new ClientConfiguration();\n \n+    private Map<BookieServer, AutoRecoveryMain> autoRecoveryProcesses = new HashMap<BookieServer, AutoRecoveryMain>();\n+\n+    private boolean isAutoRecoveryEnabled;\n+\n     public BookKeeperClusterTestCase(int numBookies) {\n         this.numBookies = numBookies;\n     }\n@@ -123,7 +132,8 @@ protected void stopZKCluster() throws Exception {\n     }\n \n     /**\n-     * Start cluster\n+     * Start cluster. Also, starts the auto recovery process for each bookie, if\n+     * isAutoRecoveryEnabled is true.\n      *\n      * @throws Exception\n      */\n@@ -140,7 +150,8 @@ protected void startBKCluster() throws Exception {\n     }\n \n     /**\n-     * Stop cluster\n+     * Stop cluster. Also, stops all the auto recovery processes for the bookie\n+     * cluster, if isAutoRecoveryEnabled is true.\n      *\n      * @throws Exception\n      */\n@@ -151,6 +162,12 @@ protected void stopBKCluster() throws Exception {\n \n         for (BookieServer server : bs) {\n             server.shutdown();\n+            AutoRecoveryMain autoRecovery = autoRecoveryProcesses.get(server);\n+            if (autoRecovery != null && isAutoRecoveryEnabled()) {\n+                autoRecovery.shutdown();\n+                LOG.debug(\"Shutdown auto recovery for bookieserver:\"\n+                        + server.getLocalAddress());\n+            }\n         }\n         bs.clear();\n         for (File f : tmpDirs) {\n@@ -183,10 +200,11 @@ public InetSocketAddress getBookie(int index) throws IllegalArgumentException {\n     }\n \n     /**\n-     * Kill a bookie by its socket address\n+     * Kill a bookie by its socket address. Also, stops the autorecovery process\n+     * for the corresponding bookie server, if isAutoRecoveryEnabled is true.\n      *\n      * @param addr\n-     *          Socket Address\n+     *            Socket Address\n      * @return the configuration of killed bookie\n      * @throws InterruptedException\n      */\n@@ -202,17 +220,19 @@ public ServerConfiguration killBookie(InetSocketAddress addr) throws Interrupted\n             ++toRemoveIndex;\n         }\n         if (toRemove != null) {\n+            stopAutoRecoveryService(toRemove);\n             bs.remove(toRemove);\n             return bsConfs.remove(toRemoveIndex);\n         }\n         return null;\n     }\n \n     /**\n-     * Kill a bookie by index\n+     * Kill a bookie by index. Also, stops the respective auto recovery process\n+     * for this bookie, if isAutoRecoveryEnabled is true.\n      *\n      * @param index\n-     *          Bookie Index\n+     *            Bookie Index\n      * @return the configuration of killed bookie\n      * @throws InterruptedException\n      * @throws IOException\n@@ -223,6 +243,7 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n         }\n         BookieServer server = bs.get(index);\n         server.shutdown();\n+        stopAutoRecoveryService(server);\n         bs.remove(server);\n         return bsConfs.remove(index);\n     }\n@@ -302,7 +323,8 @@ public void run() {\n     }\n \n     /**\n-     * Restart bookie servers\n+     * Restart bookie servers. Also restarts all the respective auto recovery\n+     * process, if isAutoRecoveryEnabled is true.\n      *\n      * @throws InterruptedException\n      * @throws IOException\n@@ -315,10 +337,11 @@ public void restartBookies()\n     }\n \n     /**\n-     * Restart bookie servers using new configuration settings\n+     * Restart bookie servers using new configuration settings. Also restart the\n+     * respective auto recovery process, if isAutoRecoveryEnabled is true.\n      *\n      * @param newConf\n-     *          New Configuration Settings\n+     *            New Configuration Settings\n      * @throws InterruptedException\n      * @throws IOException\n      * @throws KeeperException\n@@ -329,6 +352,7 @@ public void restartBookies(ServerConfiguration newConf)\n         // shut down bookie server\n         for (BookieServer server : bs) {\n             server.shutdown();\n+            stopAutoRecoveryService(server);\n         }\n         bs.clear();\n         Thread.sleep(1000);\n@@ -345,7 +369,8 @@ public void restartBookies(ServerConfiguration newConf)\n \n     /**\n      * Helper method to startup a new bookie server with the indicated port\n-     * number\n+     * number. Also, starts the auto recovery process, if the\n+     * isAutoRecoveryEnabled is set true.\n      *\n      * @param port\n      *            Port to start the new bookie server on\n@@ -368,14 +393,16 @@ public int startNewBookie()\n     }\n \n     /**\n-     * Helper method to startup a bookie server using a configuration object\n+     * Helper method to startup a bookie server using a configuration object.\n+     * Also, starts the auto recovery process if isAutoRecoveryEnabled is true.\n      *\n      * @param conf\n      *            Server Configuration Object\n      *\n      */\n     protected BookieServer startBookie(ServerConfiguration conf)\n-            throws IOException, InterruptedException, KeeperException, BookieException {\n+            throws IOException, InterruptedException, KeeperException,\n+            BookieException {\n         BookieServer server = new BookieServer(conf);\n         server.start();\n \n@@ -387,11 +414,19 @@ protected BookieServer startBookie(ServerConfiguration conf)\n         bkc.readBookiesBlocking();\n         LOG.info(\"New bookie on port \" + port + \" has been created.\");\n \n+        try {\n+            startAutoRecovery(server, conf);\n+        } catch (CompatibilityException ce) {\n+            LOG.error(\"Exception while starting AutoRecovery!\", ce);\n+        } catch (UnavailableException ue) {\n+            LOG.error(\"Exception while starting AutoRecovery!\", ue);\n+        }\n         return server;\n     }\n \n     /**\n-     * Start a bookie with the given bookie instance.\n+     * Start a bookie with the given bookie instance. Also, starts the auto\n+     * recovery for this bookie, if isAutoRecoveryEnabled is true.\n      */\n     protected BookieServer startBookie(ServerConfiguration conf, final Bookie b)\n             throws IOException, InterruptedException, KeeperException, BookieException {\n@@ -410,11 +445,105 @@ protected Bookie newBookie(ServerConfiguration conf) {\n \n         bkc.readBookiesBlocking();\n         LOG.info(\"New bookie on port \" + port + \" has been created.\");\n-\n+        try {\n+            startAutoRecovery(server, conf);\n+        } catch (CompatibilityException ce) {\n+            LOG.error(\"Exception while starting AutoRecovery!\", ce);\n+        } catch (UnavailableException ue) {\n+            LOG.error(\"Exception while starting AutoRecovery!\", ue);\n+        }\n         return server;\n     }\n \n     public void setMetastoreImplClass(AbstractConfiguration conf) {\n         conf.setMetastoreImplClass(InMemoryMetaStore.class.getName());\n     }\n+\n+    /**\n+     * Flags used to enable/disable the auto recovery process. If it is enabled,\n+     * starting the bookie server will starts the auto recovery process for that\n+     * bookie. Also, stopping bookie will stops the respective auto recovery\n+     * process.\n+     *\n+     * @param isAutoRecoveryEnabled\n+     *            Value true will enable the auto recovery process. Value false\n+     *            will disable the auto recovery process\n+     */\n+    public void setAutoRecoveryEnabled(boolean isAutoRecoveryEnabled) {\n+        this.isAutoRecoveryEnabled = isAutoRecoveryEnabled;\n+    }\n+\n+    /**\n+     * Flag used to check whether auto recovery process is enabled/disabled. By\n+     * default the flag is false.\n+     *\n+     * @return true, if the auto recovery is enabled. Otherwise return false.\n+     */\n+    public boolean isAutoRecoveryEnabled() {\n+        return isAutoRecoveryEnabled;\n+    }\n+\n+    private void startAutoRecovery(BookieServer bserver,\n+            ServerConfiguration conf) throws CompatibilityException,\n+            KeeperException, InterruptedException, IOException,\n+            UnavailableException {\n+        if (isAutoRecoveryEnabled()) {\n+            AutoRecoveryMain autoRecoveryProcess = new AutoRecoveryMain(conf);\n+            autoRecoveryProcess.start();\n+            autoRecoveryProcesses.put(bserver, autoRecoveryProcess);\n+            LOG.debug(\"Starting Auditor Recovery for the bookie:\"\n+                    + bserver.getLocalAddress());\n+        }\n+    }\n+\n+    private void stopAutoRecoveryService(BookieServer toRemove) {\n+        AutoRecoveryMain autoRecoveryMain = autoRecoveryProcesses\n+                .remove(toRemove);\n+        if (null != autoRecoveryMain && isAutoRecoveryEnabled()) {\n+            autoRecoveryMain.shutdown();\n+            LOG.debug(\"Shutdown auto recovery for bookieserver:\"\n+                    + toRemove.getLocalAddress());\n+        }\n+    }\n+\n+    /**\n+     * Will starts the auto recovery process for the bookie servers. One auto\n+     * recovery process per each bookie server, if isAutoRecoveryEnabled is\n+     * enabled.\n+     *\n+     * @throws CompatibilityException\n+     *             - Compatibility error\n+     * @throws KeeperException\n+     *             - ZK exception\n+     * @throws InterruptedException\n+     *             - interrupted exception\n+     * @throws IOException\n+     *             - IOException\n+     * @throws UnavailableException\n+     *             - replication service has become unavailable\n+     */\n+    public void startReplicationService() throws CompatibilityException,\n+            KeeperException, InterruptedException, IOException,\n+            UnavailableException {\n+        int index = -1;\n+        for (BookieServer bserver : bs) {\n+            startAutoRecovery(bserver, bsConfs.get(++index));\n+        }\n+    }\n+\n+    /**\n+     * Will stops all the auto recovery processes for the bookie cluster, if\n+     * isAutoRecoveryEnabled is true.\n+     */\n+    public void stopReplicationService() {\n+        if(false == isAutoRecoveryEnabled()){\n+            return;\n+        }\n+        for (Entry<BookieServer, AutoRecoveryMain> autoRecoveryProcess : autoRecoveryProcesses\n+                .entrySet()) {\n+            autoRecoveryProcess.getValue().shutdown();\n+            LOG.debug(\"Shutdown Auditor Recovery for the bookie:\"\n+                    + autoRecoveryProcess.getKey().getLocalAddress());\n+        }\n+    }\n }"}]}

