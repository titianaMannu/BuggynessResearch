{"sha":"b625fdc27a429341143e204338cf5deab3188e9e","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiNjI1ZmRjMjdhNDI5MzQxMTQzZTIwNDMzOGNmNWRlYWIzMTg4ZTll","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-07T11:25:06Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-07T11:25:06Z"},"message":"BOOKKEEPER-355: Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during recovery add (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1429756 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0ebce665e8dee4441d9e07046b31b9662eeb3243","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0ebce665e8dee4441d9e07046b31b9662eeb3243"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b625fdc27a429341143e204338cf5deab3188e9e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b625fdc27a429341143e204338cf5deab3188e9e","html_url":"https://github.com/apache/bookkeeper/commit/b625fdc27a429341143e204338cf5deab3188e9e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b625fdc27a429341143e204338cf5deab3188e9e/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f80dcedaeea5f701822f02484c098cf4df2f04da","url":"https://api.github.com/repos/apache/bookkeeper/commits/f80dcedaeea5f701822f02484c098cf4df2f04da","html_url":"https://github.com/apache/bookkeeper/commit/f80dcedaeea5f701822f02484c098cf4df2f04da"}],"stats":{"total":277,"additions":230,"deletions":47},"files":[{"sha":"7a30867b3320c3ee6c3cdbcf59bd67f538414180","filename":"CHANGES.txt","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/b625fdc27a429341143e204338cf5deab3188e9e/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/b625fdc27a429341143e204338cf5deab3188e9e/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=b625fdc27a429341143e204338cf5deab3188e9e","patch":"@@ -153,12 +153,15 @@ Trunk (unreleased changes)\n         BOOKKEEPER-520: BookieFailureTest hangs on precommit build (ivank via sijie)\n \n         BOOKKEEPER-447: Bookie can fail to recover if index pages flushed before ledger flush acknowledged (ivank via sijie)\n+\n \tBOOKKEEPER-520: BookieFailureTest hangs on precommit build (sijie via fpj, jira reopened)\n \n \tBOOKKEEPER-514: TestDeadLock hanging sometimes (ivank, sijie via fpj)\n \n         BOOKKEEPER-524: Bookie journal filesystem gets full after SyncThread is terminated with exception (Matteo, fpj via sijie)\n \n+        BOOKKEEPER-355: Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during recovery add (ivank)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"033cb8aa08b7c5c88f8e5bbf2d38b07432577488","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":31,"deletions":24,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=b625fdc27a429341143e204338cf5deab3188e9e","patch":"@@ -645,15 +645,34 @@ void sendAddSuccessCallbacks() {\n \n     }\n \n-    void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n+    ArrayList<InetSocketAddress> replaceBookieInMetadata(final InetSocketAddress addr, final int bookieIndex)\n+            throws BKException.BKNotEnoughBookiesException {\n         InetSocketAddress newBookie;\n-\n-        LOG.debug(\"Handling failure of bookie: {} index: {}\", addr, bookieIndex);\n+        LOG.info(\"Handling failure of bookie: {} index: {}\", addr, bookieIndex);\n         final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>();\n-        blockAddCompletions.incrementAndGet();\n         final long newEnsembleStartEntry = lastAddConfirmed + 1;\n \n         // avoid parallel ensemble changes to same ensemble.\n+        synchronized (metadata) {\n+            newBookie = bk.bookieWatcher.getAdditionalBookie(metadata.currentEnsemble);\n+\n+            newEnsemble.addAll(metadata.currentEnsemble);\n+            newEnsemble.set(bookieIndex, newBookie);\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble\n+                        + \" to: \" + newEnsemble + \" for ledger: \" + ledgerId\n+                        + \" starting at entry: \" + (lastAddConfirmed + 1));\n+            }\n+\n+            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n+        }\n+        return newEnsemble;\n+    }\n+\n+    void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n+        blockAddCompletions.incrementAndGet();\n+\n         synchronized (metadata) {\n             if (!metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n                 // ensemble has already changed, failure of this addr is immaterial\n@@ -664,30 +683,18 @@ void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n             }\n \n             try {\n-                newBookie = bk.bookieWatcher\n-                        .getAdditionalBookie(metadata.currentEnsemble);\n-            } catch (BKNotEnoughBookiesException e) {\n+                ArrayList<InetSocketAddress> newEnsemble = replaceBookieInMetadata(addr, bookieIndex);\n+\n+                EnsembleInfo ensembleInfo = new EnsembleInfo(newEnsemble, bookieIndex,\n+                                                             addr);\n+                writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo));\n+            } catch (BKException.BKNotEnoughBookiesException e) {\n                 LOG.error(\"Could not get additional bookie to \"\n-                        + \"remake ensemble, closing ledger: \" + ledgerId);\n+                          + \"remake ensemble, closing ledger: \" + ledgerId);\n                 handleUnrecoverableErrorDuringAdd(e.getCode());\n                 return;\n             }\n-\n-            newEnsemble.addAll(metadata.currentEnsemble);\n-            newEnsemble.set(bookieIndex, newBookie);\n-\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble\n-                        + \" to: \" + newEnsemble + \" for ledger: \" + ledgerId\n-                        + \" starting at entry: \" + (lastAddConfirmed + 1));\n-            }\n-\n-            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n         }\n-\n-        EnsembleInfo ensembleInfo = new EnsembleInfo(newEnsemble, bookieIndex,\n-                addr);\n-        writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo));\n     }\n \n     // Contains newly reformed ensemble, bookieIndex, failedBookieAddress\n@@ -819,7 +826,7 @@ private boolean resolveConflict(LedgerMetadata newMeta) {\n \n     };\n \n-    private void unsetSuccessAndSendWriteRequest(final int bookieIndex) {\n+    void unsetSuccessAndSendWriteRequest(final int bookieIndex) {\n         for (PendingAddOp pendingAddOp : pendingAddOps) {\n             pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n         }"},{"sha":"d038e3bb82e1e41826b57c7efb4d99129a1c6d1e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":16,"deletions":13,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=b625fdc27a429341143e204338cf5deab3188e9e","patch":"@@ -437,21 +437,24 @@ boolean resolveConflict(LedgerMetadata newMeta) {\n             Version.Occurred.AFTER == version.compare(newMeta.version)) {\n             return false;\n         }\n-        // ensemble size should be same\n-        if (ensembles.size() != newMeta.ensembles.size()) {\n-            return false;\n-        }\n-        // ensemble distribution should be same\n-        // we don't check the detail ensemble, since new bookie will be set\n-        // using recovery tool.\n-        Iterator<Long> keyIter = ensembles.keySet().iterator();\n-        Iterator<Long> newMetaKeyIter = newMeta.ensembles.keySet().iterator();\n-        for (int i=0; i<ensembles.size(); i++) {\n-            Long curKey = keyIter.next();\n-            Long newMetaKey = newMetaKeyIter.next();\n-            if (!curKey.equals(newMetaKey)) {\n+        // if ledger is closed, we can just take the new ensembles\n+        if (newMeta.state != LedgerMetadataFormat.State.CLOSED) {\n+            // ensemble size should be same\n+            if (ensembles.size() != newMeta.ensembles.size()) {\n                 return false;\n             }\n+            // ensemble distribution should be same\n+            // we don't check the detail ensemble, since new bookie will be set\n+            // using recovery tool.\n+            Iterator<Long> keyIter = ensembles.keySet().iterator();\n+            Iterator<Long> newMetaKeyIter = newMeta.ensembles.keySet().iterator();\n+            for (int i=0; i<ensembles.size(); i++) {\n+                Long curKey = keyIter.next();\n+                Long newMetaKey = newMetaKeyIter.next();\n+                if (!curKey.equals(newMetaKey)) {\n+                    return false;\n+                }\n+            }\n         }\n         /*\n          *  if the conflict has been resolved, then update"},{"sha":"f6c1ea996769e2e068bea2d067dda1cc3d81d7d2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"modified","additions":28,"deletions":1,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java?ref=b625fdc27a429341143e204338cf5deab3188e9e","patch":"@@ -25,7 +25,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import java.security.GeneralSecurityException;\n-\n+import java.net.InetSocketAddress;\n \n /**\n  * Read only ledger handle. This ledger handle allows you to \n@@ -76,4 +76,31 @@ public void asyncAddEntry(final byte[] data, final int offset, final int length,\n         cb.addComplete(BKException.Code.IllegalOpException, this,\n                        LedgerHandle.INVALID_ENTRY_ID, ctx);\n     }\n+\n+    @Override\n+    void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n+        blockAddCompletions.incrementAndGet();\n+        synchronized (metadata) {\n+            try {\n+                if (!metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n+                    // ensemble has already changed, failure of this addr is immaterial\n+                    LOG.warn(\"Write did not succeed to {}, bookieIndex {}, but we have already fixed it.\",\n+                             addr, bookieIndex);\n+                    blockAddCompletions.decrementAndGet();\n+                    return;\n+                }\n+\n+                replaceBookieInMetadata(addr, bookieIndex);\n+\n+                blockAddCompletions.decrementAndGet();\n+                // the failed bookie has been replaced\n+                unsetSuccessAndSendWriteRequest(bookieIndex);\n+            } catch (BKException.BKNotEnoughBookiesException e) {\n+                LOG.error(\"Could not get additional bookie to \"\n+                          + \"remake ensemble, closing ledger: \" + ledgerId);\n+                handleUnrecoverableErrorDuringAdd(e.getCode());\n+                return;\n+            }\n+        }\n+    }\n }"},{"sha":"de0d319ad846d9b710ee6faa5987c15e0d513326","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","status":"modified","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java?ref=b625fdc27a429341143e204338cf5deab3188e9e","patch":"@@ -26,6 +26,8 @@\n import java.nio.ByteBuffer;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.*;\n import org.apache.bookkeeper.bookie.Bookie;\n@@ -217,4 +219,141 @@ public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] mast\n         assertEquals(numEntries - 1, afterlh.getLastAddConfirmed());\n     }\n \n+    /**\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-355}\n+     * A recovery during a rolling restart shouldn't affect the ability\n+     * to recovery the ledger later.\n+     * We have a ledger on ensemble B1,B2,B3.\n+     * The sequence of events is\n+     * 1. B1 brought down for maintenance\n+     * 2. Ledger recovery started\n+     * 3. B2 answers read last confirmed.\n+     * 4. B1 replaced in ensemble by B4\n+     * 5. Write to B4 fails for some reason\n+     * 6. B1 comes back up.\n+     * 7. B2 goes down for maintenance.\n+     * 8. Ledger recovery starts (ledger is now unavailable)\n+     */\n+    @Test(timeout=60000)\n+    public void testLedgerRecoveryWithRollingRestart() throws Exception {\n+        LedgerHandle lhbefore = bkc.createLedger(numBookies, 2, digestType, \"\".getBytes());\n+        for (int i = 0; i < (numBookies*3)+1; i++) {\n+            lhbefore.addEntry(\"data\".getBytes());\n+        }\n+\n+        // Add a dead bookie to the cluster\n+        ServerConfiguration conf = newServerConfiguration();\n+        Bookie deadBookie1 = new Bookie(conf) {\n+            @Override\n+            public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n+                    throws IOException, BookieException {\n+                // drop request to simulate a slow and failed bookie\n+                throw new IOException(\"Couldn't write for some reason\");\n+            }\n+        };\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf, deadBookie1));\n+\n+        // kill first bookie server\n+        InetSocketAddress bookie1 = lhbefore.getLedgerMetadata().currentEnsemble.get(0);\n+        ServerConfiguration conf1 = killBookie(bookie1);\n+\n+        // Try to recover and fence the ledger after killing one bookie in the\n+        // ensemble in the ensemble, and another bookie is available in zk, but not writtable\n+        try {\n+            bkc.openLedger(lhbefore.getId(), digestType, \"\".getBytes());\n+            fail(\"Shouldn't be able to open ledger, there should be entries missing\");\n+        } catch (BKException.BKLedgerRecoveryException e) {\n+            // expected\n+        }\n+\n+        // restart the first server, kill the second\n+        bsConfs.add(conf1);\n+        bs.add(startBookie(conf1));\n+        InetSocketAddress bookie2 = lhbefore.getLedgerMetadata().currentEnsemble.get(1);\n+        ServerConfiguration conf2 = killBookie(bookie2);\n+\n+        // using async, because this could trigger an assertion\n+        final AtomicInteger returnCode = new AtomicInteger(0);\n+        final CountDownLatch openLatch = new CountDownLatch(1);\n+        bkc.asyncOpenLedger(lhbefore.getId(), digestType, \"\".getBytes(),\n+                            new AsyncCallback.OpenCallback() {\n+                                public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+                                    returnCode.set(rc);\n+                                    openLatch.countDown();\n+                                    if (rc != BKException.Code.OK) {\n+                                        try {\n+                                            lh.close();\n+                                        } catch (Exception e) {\n+                                            LOG.error(\"Exception closing ledger handle\", e);\n+                                        }\n+                                    }\n+                                }\n+                            }, null);\n+        assertTrue(\"Open call should have completed\", openLatch.await(5, TimeUnit.SECONDS));\n+        assertFalse(\"Open should not have succeeded\", returnCode.get() == BKException.Code.OK);\n+\n+        bsConfs.add(conf2);\n+        bs.add(startBookie(conf2));\n+\n+        LedgerHandle lhafter = bkc.openLedger(lhbefore.getId(), digestType,\n+                \"\".getBytes());\n+        assertEquals(\"Fenced ledger should have correct lastAddConfirmed\",\n+                     lhbefore.getLastAddConfirmed(), lhafter.getLastAddConfirmed());\n+    }\n+\n+    /**\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-355}\n+     * Verify that if a recovery happens with 1 replica missing, and it's replaced\n+     * with a faulty bookie, it doesn't break future recovery from happening.\n+     * 1. Ledger is created with quorum size as 2, and entries are written\n+     * 2. Now first bookie is in the ensemble is brought down.\n+     * 3. Another client fence and trying to recover the same ledger\n+     * 4. During this time ensemble change will happen\n+     *    and new bookie will be added. But this bookie is not able to write.\n+     * 5. This recovery will fail.\n+     * 7. A new non-faulty bookie comes up\n+     * 8. Another client trying to recover the same ledger.\n+     */\n+    @Test(timeout=60000)\n+    public void testBookieFailureDuringRecovery() throws Exception {\n+        LedgerHandle lhbefore = bkc.createLedger(numBookies, 2, digestType, \"\".getBytes());\n+        for (int i = 0; i < (numBookies*3)+1; i++) {\n+            lhbefore.addEntry(\"data\".getBytes());\n+        }\n+\n+        // Add a dead bookie to the cluster\n+        ServerConfiguration conf = newServerConfiguration();\n+        Bookie deadBookie1 = new Bookie(conf) {\n+            @Override\n+            public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n+                    throws IOException, BookieException {\n+                // drop request to simulate a slow and failed bookie\n+                throw new IOException(\"Couldn't write for some reason\");\n+            }\n+        };\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf, deadBookie1));\n+\n+        // kill first bookie server\n+        InetSocketAddress bookie1 = lhbefore.getLedgerMetadata().currentEnsemble.get(0);\n+        ServerConfiguration conf1 = killBookie(bookie1);\n+\n+        // Try to recover and fence the ledger after killing one bookie in the\n+        // ensemble in the ensemble, and another bookie is available in zk but not writtable\n+        try {\n+            bkc.openLedger(lhbefore.getId(), digestType, \"\".getBytes());\n+            fail(\"Shouldn't be able to open ledger, there should be entries missing\");\n+        } catch (BKException.BKLedgerRecoveryException e) {\n+            // expected\n+        }\n+\n+        // start a new good server\n+        startNewBookie();\n+\n+        LedgerHandle lhafter = bkc.openLedger(lhbefore.getId(), digestType,\n+                \"\".getBytes());\n+        assertEquals(\"Fenced ledger should have correct lastAddConfirmed\",\n+                     lhbefore.getLastAddConfirmed(), lhafter.getLastAddConfirmed());\n+    }\n }"},{"sha":"f3b114da27865ab08d534a8569bdb1a580d78664","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/b625fdc27a429341143e204338cf5deab3188e9e/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=b625fdc27a429341143e204338cf5deab3188e9e","patch":"@@ -175,6 +175,17 @@ protected void stopBKCluster() throws Exception {\n         }\n     }\n \n+    protected ServerConfiguration newServerConfiguration() throws IOException {\n+        File f = File.createTempFile(\"bookie\", \"test\");\n+        tmpDirs.add(f);\n+        f.delete();\n+        f.mkdir();\n+\n+        int port = PortManager.nextFreePort();\n+        return newServerConfiguration(port, zkUtil.getZooKeeperConnectString(),\n+                                      f, new File[] { f });\n+    }\n+\n     protected ServerConfiguration newServerConfiguration(int port, String zkServers, File journalDir, File[] ledgerDirs) {\n         ServerConfiguration conf = new ServerConfiguration(baseConf);\n         conf.setBookiePort(port);\n@@ -378,18 +389,11 @@ public void restartBookies(ServerConfiguration newConf)\n      */\n     public int startNewBookie()\n             throws IOException, InterruptedException, KeeperException, BookieException {\n-        File f = File.createTempFile(\"bookie\", \"test\");\n-        tmpDirs.add(f);\n-        f.delete();\n-        f.mkdir();\n-\n-        int port = PortManager.nextFreePort();\n-        ServerConfiguration conf = newServerConfiguration(port, zkUtil.getZooKeeperConnectString(),\n-                                                          f, new File[] { f });\n+        ServerConfiguration conf = newServerConfiguration();\n         bsConfs.add(conf);\n         bs.add(startBookie(conf));\n \n-        return port;\n+        return conf.getBookiePort();\n     }\n \n     /**"}]}

