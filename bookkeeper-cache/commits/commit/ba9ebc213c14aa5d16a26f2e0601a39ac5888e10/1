{"sha":"ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiYTllYmMyMTNjMTRhYTVkMTZhMjZmMmUwNjAxYTM5YWM1ODg4ZTEw","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2011-09-05T17:38:57Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2011-09-05T17:38:57Z"},"message":"BOOKKEEPER-26: Indentation is all messed up in the BookKeeper code (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1165369 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"424cf47eae8512a2db6e85aaeee915abac29d744","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/424cf47eae8512a2db6e85aaeee915abac29d744"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","html_url":"https://github.com/apache/bookkeeper/commit/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"79ea05a3cbcc953bd86f024eb4143e4b85fcd8f1","url":"https://api.github.com/repos/apache/bookkeeper/commits/79ea05a3cbcc953bd86f024eb4143e4b85fcd8f1","html_url":"https://github.com/apache/bookkeeper/commit/79ea05a3cbcc953bd86f024eb4143e4b85fcd8f1"}],"stats":{"total":19115,"additions":9698,"deletions":9417},"files":[{"sha":"8e7c0bbf25e4375fea4c6d3307e8836594b81dc7","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -54,6 +54,8 @@ IMPROVEMENTS:\n \n  BOOKKEEPER-28: Create useful startup scripts for bookkeeper and hedwig (ivank)\n \n+ BOOKKEEPER-26: Indentation is all messed up in the BookKeeper code (ivank via fpj)\n+\n  hedwig-client/\n \n   BOOKKEEPER-44: Reuse publish channel to default server to avoid too many connect requests to default server when lots of producers came in same time (Sijie Guo via breed)"},{"sha":"ad5f4458f48a243e4ccb78e4f78b80423c3335eb","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","status":"modified","additions":101,"deletions":101,"changes":202,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -33,104 +33,104 @@\n import org.apache.zookeeper.KeeperException;\n \n public class MySqlClient {\n-\tstatic Logger LOG = Logger.getLogger(MySqlClient.class);\n-\n-\tBookKeeper x;\n-\tLedgerHandle lh;\n-\tInteger entryId;\n-\tHashMap<Integer, Integer> map;\n-\n-\tFileOutputStream fStream;\n-\tFileOutputStream fStreamLocal;\n-\tlong start, lastId;\n-\tConnection con;\n-\tStatement stmt;\n-\t\n-\t\n-\tpublic MySqlClient(String hostport, String user, String pass) \n-\t\t\tthrows ClassNotFoundException {\n-\t\tentryId = 0;\n-\t\tmap = new HashMap<Integer, Integer>();\n-\t\tClass.forName(\"com.mysql.jdbc.Driver\");\n-\t\t// database is named \"bookkeeper\"\n-\t\tString url = \"jdbc:mysql://\" + hostport + \"/bookkeeper\";\n-\t\ttry {\n-\t\t\tcon = DriverManager.getConnection(url, user, pass);\n-\t\t\tstmt = con.createStatement();\n-\t\t\t// drop table and recreate it\n-\t\t\tstmt.execute(\"DROP TABLE IF EXISTS data;\");\n-\t\t\tstmt.execute(\"create table data(transaction_id bigint PRIMARY KEY AUTO_INCREMENT, content TEXT);\");\n-\t\t\tLOG.info(\"Database initialization terminated\");\n-\t\t} catch (SQLException e) {\n-\t\t\t\n-\t\t\t// TODO Auto-generated catch block\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\tpublic void closeHandle() throws KeeperException, InterruptedException, SQLException{\n-\t\tcon.close();\n-\t}\n-\t/**\n-\t * First parameter is an integer defining the length of the message \n-\t * Second parameter is the number of writes\n-\t * Third parameter is host:port \n-\t * Fourth parameter is username\n-\t * Fifth parameter is password\n-\t * @param args\n-\t * @throws ClassNotFoundException \n-\t * @throws SQLException \n-\t */\n-\tpublic static void main(String[] args) throws ClassNotFoundException, SQLException {\t\t\n-\t\tint lenght = Integer.parseInt(args[1]);\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\twhile(lenght-- > 0){\n-\t\t\tsb.append('a');\n-\t\t}\n-\t\ttry {\n-\t\t\tMySqlClient c = new MySqlClient(args[2], args[3], args[4]);\n-\t\t\tc.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[0]));\n-\t\t\tc.writeSameEntry(sb.toString().getBytes(), Integer.parseInt(args[0]));\n-\t\t\tc.closeHandle();\n-\t\t} catch (NumberFormatException e) {\n-\t\t\te.printStackTrace();\n-\t\t} catch (InterruptedException e) {\n-\t\t\te.printStackTrace();\n-\t\t} catch (KeeperException e) {\n-\t\t\te.printStackTrace();\n-\t\t} \n-\n-\t}\n-\n-\t/**\t\n-\t * \tAdds  data entry to the DB \n-\t * \t@param data \tthe entry to be written, given as a byte array \n-\t * \t@param times\tthe number of times the entry should be written on the DB\t*/\n-\tvoid writeSameEntryBatch(byte[] data, int times) throws InterruptedException, SQLException{\n-\t\tstart = System.currentTimeMillis();\n-\t\tint count = times;\n-\t\tString content = new String(data);\n-\t\tSystem.out.println(\"Data: \" + content + \", \" + data.length);\n-\t\twhile(count-- > 0){\n-\t\t\tstmt.addBatch(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n-\t\t}\n-\t\tLOG.info(\"Finished writing batch SQL command in ms: \" + (System.currentTimeMillis() - start));\n-\t\tstart = System.currentTimeMillis();\n-\t\tstmt.executeBatch();\n-\t\tSystem.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));       \n-\t\tLOG.info(\"Ended computation\");\n-\t}\n-\n-\tvoid writeSameEntry(byte[] data, int times) throws InterruptedException, SQLException{\n-\t\tstart = System.currentTimeMillis();\n-\t\tint count = times;\n-\t\tString content = new String(data);\n-\t\tSystem.out.println(\"Data: \" + content + \", \" + data.length);\n-\t\twhile(count-- > 0){\n-\t\t\tstmt.executeUpdate(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n-\t\t}\n-\t\tSystem.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));       \n-\t\tLOG.info(\"Ended computation\");\n-\t}\n-\n-}\n\\ No newline at end of file\n+    static Logger LOG = Logger.getLogger(MySqlClient.class);\n+\n+    BookKeeper x;\n+    LedgerHandle lh;\n+    Integer entryId;\n+    HashMap<Integer, Integer> map;\n+\n+    FileOutputStream fStream;\n+    FileOutputStream fStreamLocal;\n+    long start, lastId;\n+    Connection con;\n+    Statement stmt;\n+\n+\n+    public MySqlClient(String hostport, String user, String pass)\n+            throws ClassNotFoundException {\n+        entryId = 0;\n+        map = new HashMap<Integer, Integer>();\n+        Class.forName(\"com.mysql.jdbc.Driver\");\n+        // database is named \"bookkeeper\"\n+        String url = \"jdbc:mysql://\" + hostport + \"/bookkeeper\";\n+        try {\n+            con = DriverManager.getConnection(url, user, pass);\n+            stmt = con.createStatement();\n+            // drop table and recreate it\n+            stmt.execute(\"DROP TABLE IF EXISTS data;\");\n+            stmt.execute(\"create table data(transaction_id bigint PRIMARY KEY AUTO_INCREMENT, content TEXT);\");\n+            LOG.info(\"Database initialization terminated\");\n+        } catch (SQLException e) {\n+\n+            // TODO Auto-generated catch block\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void closeHandle() throws KeeperException, InterruptedException, SQLException {\n+        con.close();\n+    }\n+    /**\n+     * First parameter is an integer defining the length of the message\n+     * Second parameter is the number of writes\n+     * Third parameter is host:port\n+     * Fourth parameter is username\n+     * Fifth parameter is password\n+     * @param args\n+     * @throws ClassNotFoundException\n+     * @throws SQLException\n+     */\n+    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n+        int lenght = Integer.parseInt(args[1]);\n+        StringBuilder sb = new StringBuilder();\n+        while(lenght-- > 0) {\n+            sb.append('a');\n+        }\n+        try {\n+            MySqlClient c = new MySqlClient(args[2], args[3], args[4]);\n+            c.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[0]));\n+            c.writeSameEntry(sb.toString().getBytes(), Integer.parseInt(args[0]));\n+            c.closeHandle();\n+        } catch (NumberFormatException e) {\n+            e.printStackTrace();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        } catch (KeeperException e) {\n+            e.printStackTrace();\n+        }\n+\n+    }\n+\n+    /**\n+     * \tAdds  data entry to the DB\n+     * \t@param data \tthe entry to be written, given as a byte array\n+     * \t@param times\tthe number of times the entry should be written on the DB\t*/\n+    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException, SQLException {\n+        start = System.currentTimeMillis();\n+        int count = times;\n+        String content = new String(data);\n+        System.out.println(\"Data: \" + content + \", \" + data.length);\n+        while(count-- > 0) {\n+            stmt.addBatch(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n+        }\n+        LOG.info(\"Finished writing batch SQL command in ms: \" + (System.currentTimeMillis() - start));\n+        start = System.currentTimeMillis();\n+        stmt.executeBatch();\n+        System.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));\n+        LOG.info(\"Ended computation\");\n+    }\n+\n+    void writeSameEntry(byte[] data, int times) throws InterruptedException, SQLException {\n+        start = System.currentTimeMillis();\n+        int count = times;\n+        String content = new String(data);\n+        System.out.println(\"Data: \" + content + \", \" + data.length);\n+        while(count-- > 0) {\n+            stmt.executeUpdate(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n+        }\n+        System.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));\n+        LOG.info(\"Ended computation\");\n+    }\n+\n+}"},{"sha":"e521e5cf2a402aefd3ea549227057a84db8724e3","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,23 +1,23 @@\n package org.apache.bookkeeper.benchmark;\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n \n@@ -41,104 +41,104 @@\n /**\n  * This is a simple test program to compare the performance of writing to\n  * BookKeeper and to the local file system.\n- * \n+ *\n  */\n \n-public class TestClient \n-    implements AddCallback, ReadCallback{\n+public class TestClient\n+    implements AddCallback, ReadCallback {\n     private static final Logger LOG = Logger.getLogger(TestClient.class);\n-    \n+\n     BookKeeper x;\n     LedgerHandle lh;\n     Integer entryId;\n     HashMap<Integer, Integer> map;\n-    \n+\n     FileOutputStream fStream;\n     FileOutputStream fStreamLocal;\n     long start, lastId;\n-    \n+\n     public TestClient() {\n         entryId = 0;\n         map = new HashMap<Integer, Integer>();\n     }\n-    \n-    public TestClient(String servers) throws KeeperException, IOException, InterruptedException{\n+\n+    public TestClient(String servers) throws KeeperException, IOException, InterruptedException {\n         this();\n         x = new BookKeeper(servers);\n-        try{\n-\t    lh = x.createLedger(DigestType.MAC, new byte[] {'a', 'b'});\n+        try {\n+            lh = x.createLedger(DigestType.MAC, new byte[] {'a', 'b'});\n         } catch (BKException e) {\n             LOG.error(e.toString());\n         }\n     }\n-    \n+\n     public TestClient(String servers, int ensSize, int qSize)\n-    throws KeeperException, IOException, InterruptedException{\n+            throws KeeperException, IOException, InterruptedException {\n         this();\n         x = new BookKeeper(servers);\n-        try{\n-        lh = x.createLedger(ensSize, qSize, DigestType.MAC, new byte[] {'a', 'b'});\n+        try {\n+            lh = x.createLedger(ensSize, qSize, DigestType.MAC, new byte[] {'a', 'b'});\n         } catch (BKException e) {\n             LOG.error(e.toString());\n         }\n     }\n-    \n+\n     public TestClient(FileOutputStream fStream)\n-    throws FileNotFoundException {\n+            throws FileNotFoundException {\n         this.fStream = fStream;\n         this.fStreamLocal = new FileOutputStream(\"./local.log\");\n     }\n-    \n-    \n-    public Integer getFreshEntryId(int val){\n+\n+\n+    public Integer getFreshEntryId(int val) {\n         ++this.entryId;\n         synchronized (map) {\n             map.put(this.entryId, val);\n         }\n         return this.entryId;\n     }\n-    \n-    public boolean removeEntryId(Integer id){\n+\n+    public boolean removeEntryId(Integer id) {\n         boolean retVal = false;\n         synchronized (map) {\n-                map.remove(id);\n-                retVal = true;\n-     \n+            map.remove(id);\n+            retVal = true;\n+\n             if(map.size() == 0) map.notifyAll();\n-            else{\n+            else {\n                 if(map.size() < 4)\n                     LOG.error(map.toString());\n             }\n         }\n         return retVal;\n     }\n \n-    public void closeHandle() throws KeeperException, InterruptedException{\n+    public void closeHandle() throws KeeperException, InterruptedException {\n         lh.close();\n     }\n     /**\n      * First says if entries should be written to BookKeeper (0) or to the local\n-     * disk (1). Second parameter is an integer defining the length of a ledger entry. \n+     * disk (1). Second parameter is an integer defining the length of a ledger entry.\n      * Third parameter is the number of writes.\n-     * \n+     *\n      * @param args\n      */\n     public static void main(String[] args) {\n-        \n+\n         int lenght = Integer.parseInt(args[1]);\n         StringBuilder sb = new StringBuilder();\n-        while(lenght-- > 0){\n+        while(lenght-- > 0) {\n             sb.append('a');\n         }\n-        \n+\n         Integer selection = Integer.parseInt(args[0]);\n-        switch(selection){\n-        case 0:           \n+        switch(selection) {\n+        case 0:\n             StringBuilder servers_sb = new StringBuilder();\n-            for (int i = 4; i < args.length; i++){\n+            for (int i = 4; i < args.length; i++) {\n                 servers_sb.append(args[i] + \" \");\n             }\n-        \n+\n             String servers = servers_sb.toString().trim().replace(' ', ',');\n             try {\n                 TestClient c = new TestClient(servers, Integer.parseInt(args[3]), Integer.parseInt(args[4]));\n@@ -156,11 +156,11 @@ public static void main(String[] args) {\n             }\n             break;\n         case 1:\n-            \n-            try{\n+\n+            try {\n                 TestClient c = new TestClient(new FileOutputStream(args[2]));\n                 c.writeSameEntryBatchFS(sb.toString().getBytes(), Integer.parseInt(args[3]));\n-            } catch(FileNotFoundException e){\n+            } catch(FileNotFoundException e) {\n                 LOG.error(e);\n             }\n             break;\n@@ -169,80 +169,80 @@ public static void main(String[] args) {\n         }\n     }\n \n-    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException{\n+    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException {\n         start = System.currentTimeMillis();\n         int count = times;\n         LOG.debug(\"Data: \" + new String(data) + \", \" + data.length);\n-        while(count-- > 0){\n+        while(count-- > 0) {\n             lh.asyncAddEntry(data, this, this.getFreshEntryId(2));\n         }\n-        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));       \n+        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));\n         synchronized (map) {\n             if(map.size() != 0)\n                 map.wait();\n         }\n         LOG.debug(\"Finished processing in ms: \" + (System.currentTimeMillis() - start));\n-        \n+\n         LOG.debug(\"Ended computation\");\n     }\n-    \n-    void writeConsecutiveEntriesBatch(int times) throws InterruptedException{\n+\n+    void writeConsecutiveEntriesBatch(int times) throws InterruptedException {\n         start = System.currentTimeMillis();\n         int count = times;\n-        while(count-- > 0){\n+        while(count-- > 0) {\n             byte[] write = new byte[2];\n             int j = count%100;\n             int k = (count+1)%100;\n             write[0] = (byte) j;\n             write[1] = (byte) k;\n             lh.asyncAddEntry(write, this, this.getFreshEntryId(2));\n         }\n-        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));       \n+        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));\n         synchronized (map) {\n             if(map.size() != 0)\n                 map.wait();\n         }\n         LOG.debug(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n-        \n+\n         Integer mon = Integer.valueOf(0);\n-        synchronized(mon){\n-\t    lh.asyncReadEntries(1, times - 1, this, mon);\n-\t    mon.wait();\n-         }\n+        synchronized(mon) {\n+            lh.asyncReadEntries(1, times - 1, this, mon);\n+            mon.wait();\n+        }\n         LOG.error(\"Ended computation\");\n     }\n \n     void writeSameEntryBatchFS(byte[] data, int times) {\n         int count = times;\n         LOG.debug(\"Data: \" + data.length + \", \" + times);\n-        try{\n+        try {\n             start = System.currentTimeMillis();\n-            while(count-- > 0){\n+            while(count-- > 0) {\n                 fStream.write(data);\n                 fStreamLocal.write(data);\n                 fStream.flush();\n             }\n             fStream.close();\n             System.out.println(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n-        } catch(IOException e){\n+        } catch(IOException e) {\n             LOG.error(e);\n         }\n     }\n-        \n-   \n+\n+\n     @Override\n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         this.removeEntryId((Integer) ctx);\n     }\n-   \n+\n     @Override\n-    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx){\n+    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n         System.out.println(\"Read callback: \" + rc);\n-        while(seq.hasMoreElements()){\n+        while(seq.hasMoreElements()) {\n             LedgerEntry le = seq.nextElement();\n             LOG.debug(new String(le.getEntry()));\n         }\n-        synchronized(ctx){\n+        synchronized(ctx) {\n             ctx.notify();\n         }\n     }"},{"sha":"affffb6250f562adbea9d57511ebe3a2234f86ac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n package org.apache.bookkeeper.bookie;\n@@ -57,7 +57,7 @@\n public class Bookie extends Thread {\n     HashMap<Long, LedgerDescriptor> ledgers = new HashMap<Long, LedgerDescriptor>();\n     static Logger LOG = Logger.getLogger(Bookie.class);\n-    \n+\n     final File journalDirectory;\n \n     final File ledgerDirectories[];\n@@ -209,7 +209,7 @@ public Bookie(int port, String zkServers, File journalDirectory, File ledgerDire\n         LOG.debug(\"I'm starting a bookie with journal directory \" + journalDirectory.getName());\n         start();\n         syncThread.start();\n-        // set running here. \n+        // set running here.\n         // since bookie server use running as a flag to tell bookie server whether it is alive\n         // if setting it in bookie thread, the watcher might run before bookie thread.\n         running = true;\n@@ -231,7 +231,7 @@ private void instantiateZookeeperClient(int port, String zkServers) throws IOExc\n         // Create the ZK ephemeral node for this Bookie.\n         try {\n             zk.create(BOOKIE_REGISTRATION_PATH + InetAddress.getLocalHost().getHostAddress() + \":\" + port, new byte[0],\n-                    Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+                      Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n         } catch (Exception e) {\n             LOG.fatal(\"ZK exception registering ephemeral Znode for Bookie!\", e);\n             // Throw an IOException back up. This will cause the Bookie\n@@ -240,10 +240,10 @@ private void instantiateZookeeperClient(int port, String zkServers) throws IOExc\n             throw new IOException(e);\n         }\n     }\n-    \n-    /** \n+\n+    /**\n      * Create a new zookeeper client to zk cluster.\n-     * \n+     *\n      * <p>\n      * Bookie Server just used zk client when syncing ledgers for garbage collection.\n      * So when zk client is expired, it means this bookie server is not available in\n@@ -262,35 +262,35 @@ private void instantiateZookeeperClient(int port, String zkServers) throws IOExc\n      * @return zk client instance\n      */\n     private ZooKeeper newZookeeper(final String zkServers,\n-            final int sessionTimeout) throws IOException {\n+                                   final int sessionTimeout) throws IOException {\n         ZooKeeper newZk = new ZooKeeper(zkServers, sessionTimeout,\n-                new Watcher() {\n-                    @Override\n-                    public void process(WatchedEvent event) {\n-                        // handle session disconnects and expires\n-                        if (event.getType()\n-                                .equals(Watcher.Event.EventType.None)) {\n-                            if (event.getState().equals(\n-                                    Watcher.Event.KeeperState.Disconnected)) {\n-                                LOG.warn(\"ZK client has been disconnected to the ZK server!\");\n-                            } else if (event.getState().equals(\n-                                    Watcher.Event.KeeperState.SyncConnected)) {\n-                                LOG.info(\"ZK client has been reconnected to the ZK server!\");\n-                            }\n-                        }\n-                        // Check for expired connection.\n-                        if (event.getState().equals(\n-                                Watcher.Event.KeeperState.Expired)) {\n-                            LOG.error(\"ZK client connection to the ZK server has expired!\");\n-                            isZkExpired = true;\n-                            try {\n-                                shutdown();\n-                            } catch (InterruptedException ie) {\n-                                System.exit(-1);\n-                            }\n-                        }\n+        new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                // handle session disconnects and expires\n+                if (event.getType()\n+                .equals(Watcher.Event.EventType.None)) {\n+                    if (event.getState().equals(\n+                    Watcher.Event.KeeperState.Disconnected)) {\n+                        LOG.warn(\"ZK client has been disconnected to the ZK server!\");\n+                    } else if (event.getState().equals(\n+                    Watcher.Event.KeeperState.SyncConnected)) {\n+                        LOG.info(\"ZK client has been reconnected to the ZK server!\");\n                     }\n-                });\n+                }\n+                // Check for expired connection.\n+                if (event.getState().equals(\n+                Watcher.Event.KeeperState.Expired)) {\n+                    LOG.error(\"ZK client connection to the ZK server has expired!\");\n+                    isZkExpired = true;\n+                    try {\n+                        shutdown();\n+                    } catch (InterruptedException ie) {\n+                        System.exit(-1);\n+                    }\n+                }\n+            }\n+        });\n         isZkExpired = false;\n         return newZk;\n     }\n@@ -323,12 +323,12 @@ private LedgerDescriptor getHandle(long ledgerId, boolean readonly, byte[] maste\n                 handle = createHandle(ledgerId, readonly);\n                 ledgers.put(ledgerId, handle);\n                 handle.setMasterKey(ByteBuffer.wrap(masterKey));\n-            } \n+            }\n             handle.incRef();\n         }\n         return handle;\n     }\n-    \n+\n     private LedgerDescriptor getHandle(long ledgerId, boolean readonly) throws IOException {\n         LedgerDescriptor handle = null;\n         synchronized (ledgers) {\n@@ -339,20 +339,20 @@ private LedgerDescriptor getHandle(long ledgerId, boolean readonly) throws IOExc\n                 }\n                 handle = createHandle(ledgerId, readonly);\n                 ledgers.put(ledgerId, handle);\n-            } \n+            }\n             handle.incRef();\n         }\n         return handle;\n     }\n-    \n+\n \n     private LedgerDescriptor createHandle(long ledgerId, boolean readOnly) throws IOException {\n         return new LedgerDescriptor(ledgerId, entryLogger, ledgerCache);\n     }\n-    \n+\n     static class QueueEntry {\n-        QueueEntry(ByteBuffer entry, long ledgerId, long entryId, \n-                WriteCallback cb, Object ctx) {\n+        QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n+                   WriteCallback cb, Object ctx) {\n             this.entry = entry.duplicate();\n             this.cb = cb;\n             this.ctx = ctx;\n@@ -361,9 +361,9 @@ private LedgerDescriptor createHandle(long ledgerId, boolean readOnly) throws IO\n         }\n \n         ByteBuffer entry;\n-        \n+\n         long ledgerId;\n-        \n+\n         long entryId;\n \n         WriteCallback cb;\n@@ -374,9 +374,9 @@ private LedgerDescriptor createHandle(long ledgerId, boolean readOnly) throws IO\n     LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n \n     public final static long preAllocSize = 4*1024*1024;\n-    \n+\n     public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n-    \n+\n     class LastLogMark {\n         long txnLogId;\n         long txnLogPosition;\n@@ -433,13 +433,13 @@ synchronized void readLog() {\n             }\n         }\n     }\n-    \n+\n     private LastLogMark lastLogMark = new LastLogMark(0, 0);\n-    \n-    public boolean isRunning(){\n+\n+    public boolean isRunning() {\n         return running;\n     }\n-    \n+\n     @Override\n     public void run() {\n         LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n@@ -510,7 +510,7 @@ private FileChannel openChannel(long logId) throws FileNotFoundException {\n \n     public synchronized void shutdown() throws InterruptedException {\n         if (!running) { // avoid shutdown twice\n-          return;\n+            return;\n         }\n         // Shutdown the ZK client\n         if(zk != null) zk.close();\n@@ -526,13 +526,13 @@ public synchronized void shutdown() throws InterruptedException {\n         // setting running to false here, so watch thread in bookie server know it only after bookie shut down\n         running = false;\n     }\n-    \n+\n     public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n             throws IOException, BookieException {\n         long ledgerId = entry.getLong();\n         LedgerDescriptor handle = getHandle(ledgerId, false, masterKey);\n-        \n-        if(!handle.cmpMasterKey(ByteBuffer.wrap(masterKey))){\n+\n+        if(!handle.cmpMasterKey(ByteBuffer.wrap(masterKey))) {\n             throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n         }\n         try {\n@@ -588,7 +588,7 @@ synchronized public void waitZero() throws InterruptedException {\n      * @throws InterruptedException\n      */\n     public static void main(String[] args) throws IOException,\n-            InterruptedException, BookieException {\n+        InterruptedException, BookieException {\n         Bookie b = new Bookie(5000, null, new File(\"/tmp\"), new File[] { new File(\"/tmp\") });\n         CounterCallback cb = new CounterCallback();\n         long start = System.currentTimeMillis();"},{"sha":"292617e1b72c7e49ac1e5ede59150d654f23ec71","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","status":"modified","additions":29,"deletions":29,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,63 +1,63 @@\n package org.apache.bookkeeper.bookie;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n- \n- \n- import java.lang.Exception;\n- \n- @SuppressWarnings(\"serial\")\n+\n+\n+import java.lang.Exception;\n+\n+@SuppressWarnings(\"serial\")\n public abstract class BookieException extends Exception {\n \n     private int code;\n-    public BookieException(int code){\n+    public BookieException(int code) {\n         this.code = code;\n     }\n-    \n-    public static BookieException create(int code){\n-        switch(code){\n+\n+    public static BookieException create(int code) {\n+        switch(code) {\n         case Code.UnauthorizedAccessException:\n             return new BookieUnauthorizedAccessException();\n         default:\n             return new BookieIllegalOpException();\n         }\n     }\n-    \n+\n     public interface Code {\n         int OK = 0;\n         int UnauthorizedAccessException = -1;\n-        \n+\n         int IllegalOpException = -100;\n     }\n-    \n-    public void setCode(int code){\n+\n+    public void setCode(int code) {\n         this.code = code;\n     }\n-    \n-    public int getCode(){\n+\n+    public int getCode() {\n         return this.code;\n     }\n-    \n-    public String getMessage(int code){\n-        switch(code){\n+\n+    public String getMessage(int code) {\n+        switch(code) {\n         case Code.OK:\n             return \"No problem\";\n         case Code.UnauthorizedAccessException:\n@@ -66,16 +66,16 @@ public String getMessage(int code){\n             return \"Invalid operation\";\n         }\n     }\n-    \n+\n     public static class BookieUnauthorizedAccessException extends BookieException {\n-        public BookieUnauthorizedAccessException(){\n+        public BookieUnauthorizedAccessException() {\n             super(Code.UnauthorizedAccessException);\n-        }   \n+        }\n     }\n-    \n+\n     public static class BookieIllegalOpException extends BookieException {\n-        public BookieIllegalOpException(){\n+        public BookieIllegalOpException() {\n             super(Code.UnauthorizedAccessException);\n-        }   \n+        }\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"9bee1f3516341cd1b3f0086b5384d964ce3856a1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,7 +28,7 @@\n /**\n  * Provides a buffering layer in front of a FileChannel.\n  */\n-public class BufferedChannel \n+public class BufferedChannel\n {\n     ByteBuffer writeBuffer;\n     ByteBuffer readBuffer;\n@@ -43,10 +43,10 @@\n         position = bc.position();\n         writeBufferStartPosition = position;\n     }\n-/*    public void close() throws IOException {\n-        bc.close();\n-    }\n-*/\n+    /*    public void close() throws IOException {\n+            bc.close();\n+        }\n+    */\n //    public boolean isOpen() {\n //        return bc.isOpen();\n //    }\n@@ -75,22 +75,22 @@ synchronized public int write(ByteBuffer src) throws IOException {\n         position += copied;\n         return copied;\n     }\n-    \n+\n     public long position() {\n         return position;\n     }\n-    \n+\n     /**\n      * Retrieve the current size of the underlying FileChannel\n-     * \n+     *\n      * @return FileChannel size measured in bytes\n-     * \n+     *\n      * @throws IOException if some I/O error occurs reading the FileChannel\n      */\n     public long size() throws IOException {\n         return bc.size();\n     }\n-    \n+\n     public void flush(boolean sync) throws IOException {\n         synchronized(this) {\n             if (writeBuffer == null) {\n@@ -116,7 +116,7 @@ synchronized public int read(ByteBuffer buff, long pos) throws IOException {\n         }\n         int rc = buff.remaining();\n         while(buff.remaining() > 0) {\n-            // check if it is in the write buffer    \n+            // check if it is in the write buffer\n             if (writeBuffer != null && writeBufferStartPosition <= pos) {\n                 long positionInBuffer = pos - writeBufferStartPosition;\n                 long bytesToCopy = writeBuffer.position()-positionInBuffer;\n@@ -143,7 +143,7 @@ synchronized public int read(ByteBuffer buff, long pos) throws IOException {\n                 src.limit((int) (positionInBuffer+bytesToCopy));\n                 buff.put(src);\n                 pos += bytesToCopy;\n-            // let's read it\n+                // let's read it\n             } else {\n                 readBufferStartPosition = pos;\n                 readBuffer.clear();"},{"sha":"1410bc48c92be63dc97b40ab38c57abdb784d589","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":19,"deletions":19,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -85,7 +85,7 @@\n     // This is the thread that garbage collects the entry logs that do not\n     // contain any active ledgers in them.\n     GarbageCollectorThread gcThread = new GarbageCollectorThread();\n-    // This is how often we want to run the Garbage Collector Thread (in milliseconds). \n+    // This is how often we want to run the Garbage Collector Thread (in milliseconds).\n     // This should be passed as a System property. Default it to 1000 ms (1sec).\n     final static int gcWaitTime = Integer.getInteger(\"gcWaitTime\", 1000);\n \n@@ -113,7 +113,7 @@ public EntryLogger(File dirs[], Bookie bookie) throws IOException {\n         // Start the Garbage Collector thread to prune unneeded entry logs.\n         gcThread.start();\n     }\n-    \n+\n     /**\n      * Maps entry log files to open channels.\n      */\n@@ -152,10 +152,10 @@ public void run() {\n                     public void processResult(int rc, String path, Object ctx) {\n                         if (rc != Code.OK.intValue()) {\n                             LOG.error(\"ZK error syncing the ledgers node when getting children: \", KeeperException\n-                                    .create(KeeperException.Code.get(rc), path));\n+                                      .create(KeeperException.Code.get(rc), path));\n                             return;\n                         }\n-                        // Sync has completed successfully so now we can poll ZK \n+                        // Sync has completed successfully so now we can poll ZK\n                         // and read in the latest set of active ledger nodes.\n                         List<String> ledgerNodes;\n                         try {\n@@ -194,7 +194,7 @@ public void processResult(int rc, String path, Object ctx) {\n                         // Remove any active ledgers that don't exist in ZK.\n                         for (Long ledger : curActiveLedgers.keySet()) {\n                             if (!allActiveLedgers.contains(ledger)) {\n-                                // Remove it from the current active ledgers set and also from all \n+                                // Remove it from the current active ledgers set and also from all\n                                 // LedgerCache data references to the ledger, i.e. the physical ledger index file.\n                                 LOG.info(\"Removing a non-active/deleted ledger: \" + ledger);\n                                 curActiveLedgers.remove(ledger);\n@@ -223,7 +223,7 @@ public void processResult(int rc, String path, Object ctx) {\n                                     entryLogFile = findFile(entryLogId);\n                                 } catch (FileNotFoundException e) {\n                                     LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n-                                            + entryLogId + \".log\");\n+                                              + entryLogId + \".log\");\n                                     continue;\n                                 }\n                                 entryLogFile.delete();\n@@ -236,7 +236,7 @@ public void processResult(int rc, String path, Object ctx) {\n             }\n         }\n     }\n-    \n+\n     /**\n      * Creates a new log file with the given id.\n      */\n@@ -275,7 +275,7 @@ private void setLastLogId(File dir, long logId) throws IOException {\n             }\n         }\n     }\n-    \n+\n     /**\n      * reads id from the \"lastId\" file in the given directory.\n      */\n@@ -301,11 +301,11 @@ private long getLastLogId(File f) {\n             }\n         }\n     }\n-    \n+\n     private void openNewChannel() throws IOException {\n         createLogId(++logId);\n     }\n-    \n+\n     synchronized void flush() throws IOException {\n         if (logChannel != null) {\n             logChannel.flush(true);\n@@ -325,7 +325,7 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         somethingWritten = true;\n         return (logId << 32L) | pos;\n     }\n-    \n+\n     byte[] readEntry(long ledgerId, long entryId, long location) throws IOException {\n         long entryLogId = location >> 32L;\n         long pos = location & 0xffffffffL;\n@@ -348,7 +348,7 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         // entrySize does not include the ledgerId\n         if (entrySize > 1024*1024) {\n             LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \" + entryLogId);\n-            \n+\n         }\n         byte data[] = new byte[entrySize];\n         ByteBuffer buff = ByteBuffer.wrap(data);\n@@ -365,10 +365,10 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         if (thisEntryId != entryId) {\n             throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry is \" + thisEntryId + \" not \" + entryId);\n         }\n-        \n+\n         return data;\n     }\n-    \n+\n     private BufferedChannel getChannelForLogId(long entryLogId) throws IOException {\n         BufferedChannel fc = channels.get(entryLogId);\n         if (fc != null) {\n@@ -381,7 +381,7 @@ private BufferedChannel getChannelForLogId(long entryLogId) throws IOException {\n         newFc.position(newFc.size());\n         synchronized (channels) {\n             fc = channels.get(entryLogId);\n-            if (fc != null){\n+            if (fc != null) {\n                 newFc.close();\n                 return fc;\n             }\n@@ -400,7 +400,7 @@ private File findFile(long logId) throws FileNotFoundException {\n         }\n         throw new FileNotFoundException(\"No file for log \" + Long.toHexString(logId));\n     }\n-    \n+\n     synchronized public boolean testAndClearSomethingWritten() {\n         try {\n             return somethingWritten;\n@@ -452,14 +452,14 @@ private void extractLedgersFromEntryLogs() throws IOException {\n                 int entrySize = sizeBuff.getInt();\n                 if (entrySize > 1024 * 1024) {\n                     LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \"\n-                            + entryLogId);\n+                              + entryLogId);\n                 }\n                 byte data[] = new byte[entrySize];\n                 ByteBuffer buff = ByteBuffer.wrap(data);\n                 int rc = bc.read(buff, pos);\n                 if (rc != data.length) {\n                     throw new IOException(\"Short read for entryLog \" + entryLogId + \"@\" + pos + \"(\" + rc + \"!=\"\n-                            + data.length + \")\");\n+                                          + data.length + \")\");\n                 }\n                 buff.flip();\n                 long ledgerId = buff.getLong();\n@@ -475,7 +475,7 @@ private void extractLedgersFromEntryLogs() throws IOException {\n \n     /**\n      * Shutdown method to gracefully stop all threads spawned in this class and exit.\n-     * \n+     *\n      * @throws InterruptedException if there is an exception stopping threads.\n      */\n     public void shutdown() throws InterruptedException {"},{"sha":"53e336c43f8fe4f2336539b967ea4553474060ef","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -105,7 +105,7 @@ synchronized public long write(ByteBuffer[] buffs, long position) throws IOExcep\n     synchronized public void use() {\n         useCount++;\n     }\n-    \n+\n     synchronized public void release() {\n         useCount--;\n         if (isClosed && useCount == 0) {\n@@ -116,7 +116,7 @@ synchronized public void release() {\n             }\n         }\n     }\n-    \n+\n     /**\n      * Getter to a handle on the actual ledger index file.\n      * This is used when we are deleting a ledger and want to physically remove the index file."},{"sha":"1aa359447a9dd5e8155555b67857a6d1a3b02bb1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":27,"deletions":26,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -45,7 +45,7 @@\n  */\n public class LedgerCache {\n     private final static Logger LOG = Logger.getLogger(LedgerDescriptor.class);\n-    \n+\n     final File ledgerDirectories[];\n \n     public LedgerCache(File ledgerDirectories[]) {\n@@ -57,16 +57,16 @@ public LedgerCache(File ledgerDirectories[]) {\n      * the list of potentially clean ledgers\n      */\n     LinkedList<Long> cleanLedgers = new LinkedList<Long>();\n-    \n+\n     /**\n      * the list of potentially dirty ledgers\n      */\n     LinkedList<Long> dirtyLedgers = new LinkedList<Long>();\n-    \n+\n     HashMap<Long, FileInfo> fileInfoCache = new HashMap<Long, FileInfo>();\n-    \n+\n     LinkedList<Long> openLedgers = new LinkedList<Long>();\n-    \n+\n     // Stores the set of active (non-deleted) ledgers.\n     ConcurrentMap<Long, Boolean> activeLedgers = new ConcurrentHashMap<Long, Boolean>();\n \n@@ -77,7 +77,7 @@ public LedgerCache(File ledgerDirectories[]) {\n         }\n         LOG.info(\"openFileLimit is \" + OPEN_FILE_LIMIT);\n     }\n-    \n+\n     // allocate half of the memory to the page cache\n     private static int pageLimit = (int)((Runtime.getRuntime().maxMemory() / 3) / LedgerEntryPage.PAGE_SIZE);\n     static {\n@@ -90,7 +90,7 @@ public LedgerCache(File ledgerDirectories[]) {\n     // The number of pages that have actually been used\n     private int pageCount = 0;\n     HashMap<Long, HashMap<Long,LedgerEntryPage>> pages = new HashMap<Long, HashMap<Long,LedgerEntryPage>>();\n-    \n+\n     private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, LedgerEntryPage lep) {\n         HashMap<Long, LedgerEntryPage> map = table.get(lep.getLedger());\n         if (map == null) {\n@@ -99,16 +99,16 @@ private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, Le\n         }\n         map.put(lep.getFirstEntry(), lep);\n     }\n-    \n+\n     private static LedgerEntryPage getFromTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, Long ledger, Long firstEntry) {\n         HashMap<Long, LedgerEntryPage> map = table.get(ledger);\n         if (map != null) {\n             return map.get(firstEntry);\n         }\n         return null;\n     }\n-    \n-   synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n+\n+    synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n         LedgerEntryPage lep = getFromTable(pages, ledger, firstEntry);\n         try {\n             if (onlyDirty && lep.isClean()) {\n@@ -122,7 +122,7 @@ synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstE\n         }\n     }\n \n-   public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n+    public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n         int offsetInPage = (int) (entry%LedgerEntryPage.ENTRIES_PER_PAGES);\n         // find the id of the first entry of the page that has the entry\n         // we are looking for\n@@ -142,7 +142,7 @@ public void putEntryOffset(long ledger, long entry, long offset) throws IOExcept\n             return;\n         }\n     }\n-    \n+\n     public long getEntryOffset(long ledger, long entry) throws IOException {\n         int offsetInPage = (int) (entry%LedgerEntryPage.ENTRIES_PER_PAGES);\n         // find the id of the first entry of the page that has the entry\n@@ -156,7 +156,7 @@ public long getEntryOffset(long ledger, long entry) throws IOException {\n                     putIntoTable(pages, lep);\n                 }\n                 updatePage(lep);\n-                \n+\n             }\n             return lep.getOffset(offsetInPage*8);\n         } finally {\n@@ -165,7 +165,7 @@ public long getEntryOffset(long ledger, long entry) throws IOException {\n             }\n         }\n     }\n-    \n+\n     static final private String getLedgerName(long ledgerId) {\n         int parent = (int) (ledgerId & 0xff);\n         int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n@@ -178,7 +178,7 @@ static final private String getLedgerName(long ledgerId) {\n         sb.append(\".idx\");\n         return sb.toString();\n     }\n-    \n+\n     static final private void checkParents(File f) throws IOException {\n         File parent = f.getParentFile();\n         if (parent.exists()) {\n@@ -188,7 +188,7 @@ static final private void checkParents(File f) throws IOException {\n             throw new IOException(\"Counldn't mkdirs for \" + parent);\n         }\n     }\n-    \n+\n     static final private Random rand = new Random();\n \n     static final private File pickDirs(File dirs[]) {\n@@ -304,7 +304,8 @@ void flushLedger(boolean doAll) throws IOException {\n                         @Override\n                         public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n                             return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n-                        }});\n+                        }\n+                    });\n                     ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n                     fi = getFileInfo(l, true);\n                     int start = 0;\n@@ -354,10 +355,10 @@ public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n             }\n         }\n     }\n-    \n+\n     private void writeBuffers(Long ledger,\n-            List<LedgerEntryPage> entries, FileInfo fi,\n-            int start, int count) throws IOException {\n+                              List<LedgerEntryPage> entries, FileInfo fi,\n+                              int start, int count) throws IOException {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Writing \" + count + \" buffers of \" + Long.toHexString(ledger));\n         }\n@@ -401,7 +402,7 @@ private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOExceptio\n                 return lep;\n             }\n         }\n-        \n+\n         outerLoop:\n         while(true) {\n             synchronized(cleanLedgers) {\n@@ -461,7 +462,7 @@ public long getLastEntry(long ledgerId) {\n                 }\n             }\n         }\n-        \n+\n         return lastEntry;\n     }\n \n@@ -484,7 +485,7 @@ private void getActiveLedgers() {\n                                 if (!index.isFile() || !index.getName().endsWith(\".idx\")) {\n                                     continue;\n                                 }\n-                                // We've found a ledger index file. The file name is the \n+                                // We've found a ledger index file. The file name is the\n                                 // HexString representation of the ledgerId.\n                                 String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n                                 activeLedgers.put(Long.parseLong(ledgerIdInHex, 16), true);\n@@ -498,7 +499,7 @@ private void getActiveLedgers() {\n             LOG.debug(\"Active ledgers found: \" + activeLedgers);\n         }\n     }\n-    \n+\n     /**\n      * This method is called whenever a ledger is deleted by the BookKeeper Client\n      * and we want to remove all relevant data for it stored in the LedgerCache.\n@@ -514,8 +515,8 @@ void deleteLedger(long ledgerId) throws IOException {\n         // Remove it from the activeLedgers set\n         activeLedgers.remove(ledgerId);\n \n-        // Now remove it from all the other lists and maps. \n-        // These data structures need to be synchronized first before removing entries. \n+        // Now remove it from all the other lists and maps.\n+        // These data structures need to be synchronized first before removing entries.\n         synchronized(this) {\n             pages.remove(ledgerId);\n         }"},{"sha":"024cac391969b314a8f5305099866ad1dc74d962","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":14,"deletions":14,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n package org.apache.bookkeeper.bookie;\n@@ -41,17 +41,17 @@\n         this.entryLogger = entryLogger;\n         this.ledgerCache = ledgerCache;\n     }\n-    \n+\n     private ByteBuffer masterKey = null;\n-    \n-    void setMasterKey(ByteBuffer masterKey){\n+\n+    void setMasterKey(ByteBuffer masterKey) {\n         this.masterKey = masterKey;\n     }\n-    \n-    boolean cmpMasterKey(ByteBuffer masterKey){\n+\n+    boolean cmpMasterKey(ByteBuffer masterKey) {\n         return this.masterKey.equals(masterKey);\n     }\n-    \n+\n     private long ledgerId;\n     EntryLogger entryLogger;\n     private int refCnt;\n@@ -71,13 +71,13 @@ long addEntry(ByteBuffer entry) throws IOException {\n         }\n         long entryId = entry.getLong();\n         entry.rewind();\n-        \n+\n         /*\n          * Log the entry\n          */\n         long pos = entryLogger.addEntry(ledgerId, entry);\n-        \n-        \n+\n+\n         /*\n          * Set offset of entry id to be the current ledger position\n          */\n@@ -121,7 +121,7 @@ ByteBuffer readEntry(long entryId) throws IOException {\n             }\n             entryId = lastEntry;\n         }\n-        \n+\n         offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n         if (offset == 0) {\n             throw new Bookie.NoEntryException(ledgerId, entryId);"},{"sha":"e5d01209483047025f78281af750f4d272cb7115","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -38,7 +38,7 @@\n     private boolean pinned = false;\n     private int useCount;\n     private int version;\n-    \n+\n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();"},{"sha":"6421460c230ee8b476a42fe92184468f71082c46","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"modified","additions":113,"deletions":113,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -9,9 +9,9 @@\n  * licenses this file to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n@@ -20,120 +20,120 @@\n  */\n \n public interface AsyncCallback {\n-  public interface AddCallback {\n-    /**\n-     * Callback declaration\n-     * \n-     * @param rc\n-     *          return code\n-     * @param ledgerId\n-     *          ledger identifier\n-     * @param entryId\n-     *          entry identifier\n-     * @param ctx\n-     *          control object\n-     */\n-    void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n-  }\n-\n-  public interface CloseCallback {\n-    /**\n-     * Callback definition\n-     * \n-     * @param rc\n-     *          return code\n-     * @param ledgerId\n-     *          ledger identifier\n-     * @param ctx\n-     *          control object\n-     */\n-    void closeComplete(int rc, LedgerHandle lh, Object ctx);\n-  }\n-\n-  public interface CreateCallback {\n-    /**\n-     * Declaration of callback method\n-     * \n-     * @param rc\n-     *          return status\n-     * @param lh\n-     *          ledger handle\n-     * @param ctx\n-     *          control object\n-     */\n-\n-    void createComplete(int rc, LedgerHandle lh, Object ctx);\n-  }\n-\n-  public interface OpenCallback {\n-    /**\n-     * Callback for asynchronous call to open ledger\n-     * \n-     * @param rc\n-     *          Return code\n-     * @param lh\n-     *          ledger handle\n-     * @param ctx\n-     *          control object\n-     */\n-\n-    public void openComplete(int rc, LedgerHandle lh, Object ctx);\n-\n-  }\n-\n-  public interface ReadCallback {\n-    /**\n-     * Callback declaration\n-     * \n-     * @param rc\n-     *          return code\n-     * @param ledgerId\n-     *          ledger identifier\n-     * @param seq\n-     *          sequence of entries\n-     * @param ctx\n-     *          control object\n-     */\n-\n-    void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n-        Object ctx);\n-  }\n-  \n-  public interface DeleteCallback {\n-      /**\n-       * Callback definition for delete operations\n-       * \n-       * @param rc\n-       *          return code\n-       * @param ctx\n-       *          control object\n-       */\n-      void deleteComplete(int rc, Object ctx);\n+    public interface AddCallback {\n+        /**\n+         * Callback declaration\n+         *\n+         * @param rc\n+         *          return code\n+         * @param ledgerId\n+         *          ledger identifier\n+         * @param entryId\n+         *          entry identifier\n+         * @param ctx\n+         *          control object\n+         */\n+        void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n     }\n \n-  public interface RecoverCallback {\n-      /**\n-       * Callback definition for bookie recover operations\n-       * \n-       * @param rc\n-       *          return code\n-       * @param ctx\n-       *          control object\n-       */\n-      void recoverComplete(int rc, Object ctx);\n+    public interface CloseCallback {\n+        /**\n+         * Callback definition\n+         *\n+         * @param rc\n+         *          return code\n+         * @param ledgerId\n+         *          ledger identifier\n+         * @param ctx\n+         *          control object\n+         */\n+        void closeComplete(int rc, LedgerHandle lh, Object ctx);\n     }\n-  \n-  public interface ReadLastConfirmedCallback {\n-      /**\n-       * Callback definition for bookie recover operations\n-       * \n-       * @param rc\n-       *          return code\n-       * @param ctx\n-       *          control object\n-       */\n-      void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n+\n+    public interface CreateCallback {\n+        /**\n+         * Declaration of callback method\n+         *\n+         * @param rc\n+         *          return status\n+         * @param lh\n+         *          ledger handle\n+         * @param ctx\n+         *          control object\n+         */\n+\n+        void createComplete(int rc, LedgerHandle lh, Object ctx);\n+    }\n+\n+    public interface OpenCallback {\n+        /**\n+         * Callback for asynchronous call to open ledger\n+         *\n+         * @param rc\n+         *          Return code\n+         * @param lh\n+         *          ledger handle\n+         * @param ctx\n+         *          control object\n+         */\n+\n+        public void openComplete(int rc, LedgerHandle lh, Object ctx);\n+\n+    }\n+\n+    public interface ReadCallback {\n+        /**\n+         * Callback declaration\n+         *\n+         * @param rc\n+         *          return code\n+         * @param ledgerId\n+         *          ledger identifier\n+         * @param seq\n+         *          sequence of entries\n+         * @param ctx\n+         *          control object\n+         */\n+\n+        void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n+                          Object ctx);\n+    }\n+\n+    public interface DeleteCallback {\n+        /**\n+         * Callback definition for delete operations\n+         *\n+         * @param rc\n+         *          return code\n+         * @param ctx\n+         *          control object\n+         */\n+        void deleteComplete(int rc, Object ctx);\n+    }\n+\n+    public interface RecoverCallback {\n+        /**\n+         * Callback definition for bookie recover operations\n+         *\n+         * @param rc\n+         *          return code\n+         * @param ctx\n+         *          control object\n+         */\n+        void recoverComplete(int rc, Object ctx);\n+    }\n+\n+    public interface ReadLastConfirmedCallback {\n+        /**\n+         * Callback definition for bookie recover operations\n+         *\n+         * @param rc\n+         *          return code\n+         * @param ctx\n+         *          control object\n+         */\n+        void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n     }\n-  \n+\n \n }"},{"sha":"eb76a1d0ffbda7a2f2d5c762e3b9b90ef7929981","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,31 +1,31 @@\n package org.apache.bookkeeper.client;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.lang.Exception;\n \n /**\n  * Class the enumerates all the possible error conditions\n- * \n+ *\n  */\n \n @SuppressWarnings(\"serial\")\n@@ -100,7 +100,7 @@ public static BKException create(int code) {\n         int NoSuchEntryException = -13;\n         int IncorrectParameterException = -14;\n         int InterruptedException = -15;\n-        \n+\n         int IllegalOpException = -100;\n     }\n \n@@ -234,13 +234,13 @@ public BKLedgerClosedException() {\n             super(Code.LedgerClosedException);\n         }\n     }\n-    \n+\n     public static class BKIncorrectParameterException extends BKException {\n         public BKIncorrectParameterException() {\n             super(Code.IncorrectParameterException);\n         }\n     }\n-    \n+\n     public static class BKInterruptedException extends BKException {\n         public BKInterruptedException() {\n             super(Code.InterruptedException);"},{"sha":"6af43ae27f102609c8f8fb80d1b8ef7d26f3aed5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":407,"deletions":407,"changes":814,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.client;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.IOException;\n@@ -41,429 +41,429 @@\n /**\n  * BookKeeper client. We assume there is one single writer to a ledger at any\n  * time.\n- * \n+ *\n  * There are four possible operations: start a new ledger, write to a ledger,\n  * read from a ledger and delete a ledger.\n- * \n+ *\n  * The exceptions resulting from synchronous calls and error code resulting from\n  * asynchronous calls can be found in the class {@link BKException}.\n- * \n- * \n+ *\n+ *\n  */\n \n public class BookKeeper implements OpenCallback, CreateCallback, DeleteCallback {\n \n-  static final Logger LOG = Logger.getLogger(BookKeeper.class);\n-\n-  ZooKeeper zk = null;\n-  // whether the zk handle is one we created, or is owned by whoever\n-  // instantiated us\n-  boolean ownZKHandle = false;\n-\n-  ClientSocketChannelFactory channelFactory;\n-  // whether the socket factory is one we created, or is owned by whoever\n-  // instantiated us\n-  boolean ownChannelFactory = false;\n-\n-  BookieClient bookieClient;\n-  BookieWatcher bookieWatcher;\n-\n-  OrderedSafeExecutor callbackWorker = new OrderedSafeExecutor(Runtime\n-      .getRuntime().availableProcessors());\n-  OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime\n-      .getRuntime().availableProcessors());\n-\n-  /**\n-   * Create a bookkeeper client. A zookeeper client and a client socket factory\n-   * will be instantiated as part of this constructor.\n-   * \n-   * @param servers\n-   *          A list of one of more servers on which zookeeper is running. The\n-   *          client assumes that the running bookies have been registered with\n-   *          zookeeper under the path\n-   *          {@link BookieWatcher#BOOKIE_REGISTRATION_PATH}\n-   * @throws IOException\n-   * @throws InterruptedException\n-   * @throws KeeperException\n-   */\n-  public BookKeeper(String servers) throws IOException, InterruptedException,\n-      KeeperException {\n-    this(new ZooKeeper(servers, 10000, new Watcher() {\n-      @Override\n-      public void process(WatchedEvent event) {\n-        // TODO: handle session disconnects and expires\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n+    static final Logger LOG = Logger.getLogger(BookKeeper.class);\n+\n+    ZooKeeper zk = null;\n+    // whether the zk handle is one we created, or is owned by whoever\n+    // instantiated us\n+    boolean ownZKHandle = false;\n+\n+    ClientSocketChannelFactory channelFactory;\n+    // whether the socket factory is one we created, or is owned by whoever\n+    // instantiated us\n+    boolean ownChannelFactory = false;\n+\n+    BookieClient bookieClient;\n+    BookieWatcher bookieWatcher;\n+\n+    OrderedSafeExecutor callbackWorker = new OrderedSafeExecutor(Runtime\n+            .getRuntime().availableProcessors());\n+    OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime\n+            .getRuntime().availableProcessors());\n+\n+    /**\n+     * Create a bookkeeper client. A zookeeper client and a client socket factory\n+     * will be instantiated as part of this constructor.\n+     *\n+     * @param servers\n+     *          A list of one of more servers on which zookeeper is running. The\n+     *          client assumes that the running bookies have been registered with\n+     *          zookeeper under the path\n+     *          {@link BookieWatcher#BOOKIE_REGISTRATION_PATH}\n+     * @throws IOException\n+     * @throws InterruptedException\n+     * @throws KeeperException\n+     */\n+    public BookKeeper(String servers) throws IOException, InterruptedException,\n+        KeeperException {\n+        this(new ZooKeeper(servers, 10000, new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                // TODO: handle session disconnects and expires\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n+                }\n+            }\n+        }), new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+                                              Executors.newCachedThreadPool()));\n+\n+        ownZKHandle = true;\n+        ownChannelFactory = true;\n+    }\n+\n+    /**\n+     * Create a bookkeeper client but use the passed in zookeeper client instead\n+     * of instantiating one.\n+     *\n+     * @param zk\n+     *          Zookeeper client instance connected to the zookeeper with which\n+     *          the bookies have registered\n+     * @throws InterruptedException\n+     * @throws KeeperException\n+     */\n+    public BookKeeper(ZooKeeper zk) throws InterruptedException, KeeperException {\n+        this(zk, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+                Executors.newCachedThreadPool()));\n+        ownChannelFactory = true;\n+    }\n+\n+    /**\n+     * Create a bookkeeper client but use the passed in zookeeper client and\n+     * client socket channel factory instead of instantiating those.\n+     *\n+     * @param zk\n+     *          Zookeeper client instance connected to the zookeeper with which\n+     *          the bookies have registered\n+     * @param channelFactory\n+     *          A factory that will be used to create connections to the bookies\n+     * @throws InterruptedException\n+     * @throws KeeperException\n+     */\n+    public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n+            throws InterruptedException, KeeperException {\n+        if (zk == null || channelFactory == null) {\n+            throw new NullPointerException();\n         }\n-      }\n-    }), new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-        Executors.newCachedThreadPool()));\n-\n-    ownZKHandle = true;\n-    ownChannelFactory = true;\n-  }\n-\n-  /**\n-   * Create a bookkeeper client but use the passed in zookeeper client instead\n-   * of instantiating one.\n-   * \n-   * @param zk\n-   *          Zookeeper client instance connected to the zookeeper with which\n-   *          the bookies have registered\n-   * @throws InterruptedException\n-   * @throws KeeperException\n-   */\n-  public BookKeeper(ZooKeeper zk) throws InterruptedException, KeeperException {\n-    this(zk, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-        Executors.newCachedThreadPool()));\n-    ownChannelFactory = true;\n-  }\n-\n-  /**\n-   * Create a bookkeeper client but use the passed in zookeeper client and\n-   * client socket channel factory instead of instantiating those.\n-   * \n-   * @param zk\n-   *          Zookeeper client instance connected to the zookeeper with which\n-   *          the bookies have registered\n-   * @param channelFactory\n-   *          A factory that will be used to create connections to the bookies\n-   * @throws InterruptedException\n-   * @throws KeeperException\n-   */\n-  public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n-      throws InterruptedException, KeeperException {\n-    if (zk == null || channelFactory == null) {\n-      throw new NullPointerException();\n+        this.zk = zk;\n+        this.channelFactory = channelFactory;\n+        bookieWatcher = new BookieWatcher(this);\n+        bookieWatcher.readBookiesBlocking();\n+        bookieClient = new BookieClient(channelFactory, mainWorkerPool);\n+    }\n+\n+    /**\n+     * There are 2 digest types that can be used for verification. The CRC32 is\n+     * cheap to compute but does not protect against byzantine bookies (i.e., a\n+     * bookie might report fake bytes and a matching CRC32). The MAC code is more\n+     * expensive to compute, but is protected by a password, i.e., a bookie can't\n+     * report fake bytes with a mathching MAC unless it knows the password\n+     */\n+    public enum DigestType {\n+        MAC, CRC32\n+    };\n+\n+    public ZooKeeper getZkHandle() {\n+        return zk;\n+    }\n+\n+    /**\n+     * Get the BookieClient, currently used for doing bookie recovery.\n+     *\n+     * @return BookieClient for the BookKeeper instance.\n+     */\n+    public BookieClient getBookieClient() {\n+        return bookieClient;\n     }\n-    this.zk = zk;\n-    this.channelFactory = channelFactory;\n-    bookieWatcher = new BookieWatcher(this);\n-    bookieWatcher.readBookiesBlocking();\n-    bookieClient = new BookieClient(channelFactory, mainWorkerPool);\n-  }\n-\n-  /**\n-   * There are 2 digest types that can be used for verification. The CRC32 is\n-   * cheap to compute but does not protect against byzantine bookies (i.e., a\n-   * bookie might report fake bytes and a matching CRC32). The MAC code is more\n-   * expensive to compute, but is protected by a password, i.e., a bookie can't\n-   * report fake bytes with a mathching MAC unless it knows the password\n-   */\n-  public enum DigestType {\n-    MAC, CRC32\n-  };\n-\n-  public ZooKeeper getZkHandle() {\n-    return zk;\n-  }\n-\n-  /**\n-   * Get the BookieClient, currently used for doing bookie recovery.\n-   * \n-   * @return BookieClient for the BookKeeper instance.\n-   */\n-  public BookieClient getBookieClient() {\n-      return bookieClient;\n-  }\n-  \n-  /**\n-   * Creates a new ledger asynchronously. To create a ledger, we need to specify\n-   * the ensemble size, the quorum size, the digest type, a password, a callback\n-   * implementation, and an optional control object. The ensemble size is how\n-   * many bookies the entries should be striped among and the quorum size is the\n-   * degree of replication of each entry. The digest type is either a MAC or a\n-   * CRC. Note that the CRC option is not able to protect a client against a\n-   * bookie that replaces an entry. The password is used not only to\n-   * authenticate access to a ledger, but also to verify entries in ledgers.\n-   * \n-   * @param ensSize\n-   *          ensemble size\n-   * @param qSize\n-   *          quorum size\n-   * @param digestType\n-   *          digest type, either MAC or CRC32\n-   * @param passwd\n-   *          password\n-   * @param cb\n-   *          createCallback implementation\n-   * @param ctx\n-   *          optional control object\n-   */\n-  public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,\n-      byte[] passwd, CreateCallback cb, Object ctx) {\n-\n-    new LedgerCreateOp(this, ensSize, qSize, digestType, passwd, cb, ctx)\n+\n+    /**\n+     * Creates a new ledger asynchronously. To create a ledger, we need to specify\n+     * the ensemble size, the quorum size, the digest type, a password, a callback\n+     * implementation, and an optional control object. The ensemble size is how\n+     * many bookies the entries should be striped among and the quorum size is the\n+     * degree of replication of each entry. The digest type is either a MAC or a\n+     * CRC. Note that the CRC option is not able to protect a client against a\n+     * bookie that replaces an entry. The password is used not only to\n+     * authenticate access to a ledger, but also to verify entries in ledgers.\n+     *\n+     * @param ensSize\n+     *          ensemble size\n+     * @param qSize\n+     *          quorum size\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @param cb\n+     *          createCallback implementation\n+     * @param ctx\n+     *          optional control object\n+     */\n+    public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,\n+                                  byte[] passwd, CreateCallback cb, Object ctx) {\n+\n+        new LedgerCreateOp(this, ensSize, qSize, digestType, passwd, cb, ctx)\n         .initiate();\n \n-  }\n-\n-  /**\n-   * Create callback implementation for synchronous create call.\n-   * \n-   * @param rc\n-   *          return code\n-   * @param lh\n-   *          ledger handle object\n-   * @param ctx\n-   *          optional control object\n-   */\n-  public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n-    SyncCounter counter = (SyncCounter) ctx;\n-    counter.setLh(lh);\n-    counter.setrc(rc);\n-    counter.dec();\n-  }\n-\n-  /**\n-   * Creates a new ledger. Default of 3 servers, and quorum of 2 servers.\n-   * \n-   * @param digestType\n-   *          digest type, either MAC or CRC32\n-   * @param passwd\n-   *          password\n-   * @return\n-   * @throws KeeperException\n-   * @throws InterruptedException\n-   * @throws BKException\n-   */\n-  public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n-      throws KeeperException, BKException, InterruptedException, IOException {\n-    return createLedger(3, 2, digestType, passwd);\n-  }\n-\n-  /**\n-   * Synchronous call to create ledger. Parameters match those of\n-   * {@link #asyncCreateLedger(int, int, DigestType, byte[], CreateCallback, Object)}\n-   * \n-   * @param ensSize\n-   * @param qSize\n-   * @param digestType\n-   * @param passwd\n-   * @return\n-   * @throws KeeperException\n-   * @throws InterruptedException\n-   * @throws IOException\n-   * @throws BKException\n-   */\n-  public LedgerHandle createLedger(int ensSize, int qSize,\n-      DigestType digestType, byte passwd[]) throws KeeperException,\n-      InterruptedException, IOException, BKException {\n-    SyncCounter counter = new SyncCounter();\n-    counter.inc();\n-    /*\n-     * Calls asynchronous version\n+    }\n+\n+    /**\n+     * Create callback implementation for synchronous create call.\n+     *\n+     * @param rc\n+     *          return code\n+     * @param lh\n+     *          ledger handle object\n+     * @param ctx\n+     *          optional control object\n+     */\n+    public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n+        SyncCounter counter = (SyncCounter) ctx;\n+        counter.setLh(lh);\n+        counter.setrc(rc);\n+        counter.dec();\n+    }\n+\n+    /**\n+     * Creates a new ledger. Default of 3 servers, and quorum of 2 servers.\n+     *\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @return\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n+            throws KeeperException, BKException, InterruptedException, IOException {\n+        return createLedger(3, 2, digestType, passwd);\n+    }\n+\n+    /**\n+     * Synchronous call to create ledger. Parameters match those of\n+     * {@link #asyncCreateLedger(int, int, DigestType, byte[], CreateCallback, Object)}\n+     *\n+     * @param ensSize\n+     * @param qSize\n+     * @param digestType\n+     * @param passwd\n+     * @return\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     * @throws IOException\n+     * @throws BKException\n+     */\n+    public LedgerHandle createLedger(int ensSize, int qSize,\n+                                     DigestType digestType, byte passwd[]) throws KeeperException,\n+        InterruptedException, IOException, BKException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+        /*\n+         * Calls asynchronous version\n+         */\n+        asyncCreateLedger(ensSize, qSize, digestType, passwd, this, counter);\n+\n+        /*\n+         * Wait\n+         */\n+        counter.block(0);\n+        if (counter.getLh() == null) {\n+            LOG.error(\"ZooKeeper error: \" + counter.getrc());\n+            throw BKException.create(Code.ZKException);\n+        }\n+\n+        return counter.getLh();\n+    }\n+\n+    /**\n+     * Open existing ledger asynchronously for reading.\n+     *\n+     * @param lId\n+     *          ledger identifier\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @param ctx\n+     *          optional control object\n+     */\n+    public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n+                                OpenCallback cb, Object ctx) {\n+\n+        new LedgerOpenOp(this, lId, digestType, passwd, false, cb, ctx).initiate();\n+\n+    }\n+\n+    /**\n+     * Open existing ledger asynchronously for reading, but it does not try to\n+     * recover the ledger if it is not yet closed. The application needs to use\n+     * it carefully, since the writer might have crash and ledger will remain\n+     * unsealed forever if there is no external mechanism to detect the failure\n+     * of the writer and the ledger is not open in a safe manner, invoking the\n+     * recovery procedure.\n+     *\n+     * @param lId\n+     *          ledger identifier\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @param ctx\n+     *          optional control object\n+     */\n+\n+    public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte passwd[],\n+                                          OpenCallback cb, Object ctx) {\n+\n+        new LedgerOpenOp(this, lId, digestType, passwd, true, cb, ctx).initiate();\n+\n+    }\n+\n+    /**\n+     * Callback method for synchronous open operation\n+     *\n+     * @param rc\n+     *          return code\n+     * @param lh\n+     *          ledger handle\n+     * @param ctx\n+     *          optional control object\n+     */\n+    public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+        SyncCounter counter = (SyncCounter) ctx;\n+        counter.setLh(lh);\n+\n+        LOG.debug(\"Open complete: \" + rc);\n+\n+        counter.setrc(rc);\n+        counter.dec();\n+    }\n+\n+    /**\n+     * Synchronous open ledger call\n+     *\n+     * @param lId\n+     *          ledger identifier\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @return\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+\n+    public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n+            throws BKException, InterruptedException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+\n+        /*\n+         * Calls async open ledger\n+         */\n+        asyncOpenLedger(lId, digestType, passwd, this, counter);\n+\n+        /*\n+         * Wait\n+         */\n+        counter.block(0);\n+        if (counter.getrc() != BKException.Code.OK)\n+            throw BKException.create(counter.getrc());\n+\n+        return counter.getLh();\n+    }\n+\n+    /**\n+     * Synchronous, unsafe open ledger call\n+     *\n+     * @param lId\n+     *          ledger identifier\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @return\n+     * @throws InterruptedException\n+     * @throws BKException\n      */\n-    asyncCreateLedger(ensSize, qSize, digestType, passwd, this, counter);\n \n-    /*\n-     * Wait\n+    public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte passwd[])\n+            throws BKException, InterruptedException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+\n+        /*\n+         * Calls async open ledger\n+         */\n+        asyncOpenLedgerNoRecovery(lId, digestType, passwd, this, counter);\n+\n+        /*\n+         * Wait\n+         */\n+        counter.block(0);\n+        if (counter.getrc() != BKException.Code.OK)\n+            throw BKException.create(counter.getrc());\n+\n+        return counter.getLh();\n+    }\n+\n+    /**\n+     * Deletes a ledger asynchronously.\n+     *\n+     * @param lId\n+     *            ledger Id\n+     * @param cb\n+     *            deleteCallback implementation\n+     * @param ctx\n+     *            optional control object\n      */\n-    counter.block(0);\n-    if (counter.getLh() == null) {\n-      LOG.error(\"ZooKeeper error: \" + counter.getrc());\n-      throw BKException.create(Code.ZKException);\n+    public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) {\n+        new LedgerDeleteOp(this, lId, cb, ctx).initiate();\n     }\n \n-    return counter.getLh();\n-  }\n-\n-  /**\n-   * Open existing ledger asynchronously for reading.\n-   * \n-   * @param lId\n-   *          ledger identifier\n-   * @param digestType\n-   *          digest type, either MAC or CRC32\n-   * @param passwd\n-   *          password\n-   * @param ctx\n-   *          optional control object\n-   */\n-  public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n-      OpenCallback cb, Object ctx) {\n-\n-      new LedgerOpenOp(this, lId, digestType, passwd, false, cb, ctx).initiate();\n-\n-  }\n-\n-  /**\n-   * Open existing ledger asynchronously for reading, but it does not try to\n-   * recover the ledger if it is not yet closed. The application needs to use\n-   * it carefully, since the writer might have crash and ledger will remain \n-   * unsealed forever if there is no external mechanism to detect the failure \n-   * of the writer and the ledger is not open in a safe manner, invoking the\n-   * recovery procedure.\n-   * \n-   * @param lId\n-   *          ledger identifier\n-   * @param digestType\n-   *          digest type, either MAC or CRC32\n-   * @param passwd\n-   *          password\n-   * @param ctx\n-   *          optional control object\n-   */\n-  \n-  public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte passwd[],\n-          OpenCallback cb, Object ctx) {\n-\n-      new LedgerOpenOp(this, lId, digestType, passwd, true, cb, ctx).initiate();\n-\n-  }\n-  \n-  /**\n-   * Callback method for synchronous open operation\n-   * \n-   * @param rc\n-   *          return code\n-   * @param lh\n-   *          ledger handle\n-   * @param ctx\n-   *          optional control object\n-   */\n-  public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n-    SyncCounter counter = (SyncCounter) ctx;\n-    counter.setLh(lh);\n-\n-    LOG.debug(\"Open complete: \" + rc);\n-\n-    counter.setrc(rc);\n-    counter.dec();\n-  }\n-\n-  /**\n-   * Synchronous open ledger call\n-   * \n-   * @param lId\n-   *          ledger identifier\n-   * @param digestType\n-   *          digest type, either MAC or CRC32\n-   * @param passwd\n-   *          password\n-   * @return\n-   * @throws InterruptedException\n-   * @throws BKException\n-   */\n-\n-  public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n-      throws BKException, InterruptedException {\n-    SyncCounter counter = new SyncCounter();\n-    counter.inc();\n-\n-    /*\n-     * Calls async open ledger\n+    /**\n+     * Delete callback implementation for synchronous delete call.\n+     *\n+     * @param rc\n+     *            return code\n+     * @param ctx\n+     *            optional control object\n      */\n-    asyncOpenLedger(lId, digestType, passwd, this, counter);\n+    public void deleteComplete(int rc, Object ctx) {\n+        SyncCounter counter = (SyncCounter) ctx;\n+        counter.setrc(rc);\n+        counter.dec();\n+    }\n \n-    /*\n-     * Wait\n+    /**\n+     * Synchronous call to delete a ledger. Parameters match those of\n+     * {@link #asyncDeleteLedger(long, DeleteCallback, Object)}\n+     *\n+     * @param lId\n+     *            ledgerId\n+     * @throws InterruptedException\n+     * @throws BKException\n      */\n-    counter.block(0);\n-    if (counter.getrc() != BKException.Code.OK)\n-      throw BKException.create(counter.getrc());\n-\n-    return counter.getLh();\n-  }\n-\n-  /**\n-   * Synchronous, unsafe open ledger call\n-   * \n-   * @param lId\n-   *          ledger identifier\n-   * @param digestType\n-   *          digest type, either MAC or CRC32\n-   * @param passwd\n-   *          password\n-   * @return\n-   * @throws InterruptedException\n-   * @throws BKException\n-   */\n-\n-  public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte passwd[])\n-  throws BKException, InterruptedException {\n-      SyncCounter counter = new SyncCounter();\n-      counter.inc();\n-\n-      /*\n-       * Calls async open ledger\n-       */\n-      asyncOpenLedgerNoRecovery(lId, digestType, passwd, this, counter);\n-\n-      /*\n-       * Wait\n-       */\n-      counter.block(0);\n-      if (counter.getrc() != BKException.Code.OK)\n-          throw BKException.create(counter.getrc());\n-\n-      return counter.getLh();\n-  }\n-  \n-  /**\n-   * Deletes a ledger asynchronously.\n-   * \n-   * @param lId\n-   *            ledger Id\n-   * @param cb\n-   *            deleteCallback implementation\n-   * @param ctx\n-   *            optional control object\n-   */\n-  public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) {\n-      new LedgerDeleteOp(this, lId, cb, ctx).initiate();\n-  }\n-  \n-  /**\n-   * Delete callback implementation for synchronous delete call.\n-   * \n-   * @param rc\n-   *            return code\n-   * @param ctx\n-   *            optional control object\n-   */\n-  public void deleteComplete(int rc, Object ctx) {\n-      SyncCounter counter = (SyncCounter) ctx;\n-      counter.setrc(rc);\n-      counter.dec();\n-  }\n-\n-  /**\n-   * Synchronous call to delete a ledger. Parameters match those of\n-   * {@link #asyncDeleteLedger(long, DeleteCallback, Object)}\n-   * \n-   * @param lId\n-   *            ledgerId\n-   * @throws InterruptedException\n-   * @throws BKException\n-   */\n-  public void deleteLedger(long lId) throws InterruptedException, BKException {\n-      SyncCounter counter = new SyncCounter();\n-      counter.inc();\n-      // Call asynchronous version\n-      asyncDeleteLedger(lId, this, counter);\n-      // Wait\n-      counter.block(0);\n-      if (counter.getrc() != KeeperException.Code.OK.intValue()) { \n-          LOG.error(\"ZooKeeper error deleting ledger node: \" + counter.getrc());\n-          throw BKException.create(Code.ZKException);\n-      }\n-  }\n-  \n-  /**\n-   * Shuts down client.\n-   * \n-   */\n-  public void halt() throws InterruptedException {\n-    bookieClient.close();\n-    bookieWatcher.halt();\n-    if (ownChannelFactory) {\n-      channelFactory.releaseExternalResources();\n+    public void deleteLedger(long lId) throws InterruptedException, BKException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+        // Call asynchronous version\n+        asyncDeleteLedger(lId, this, counter);\n+        // Wait\n+        counter.block(0);\n+        if (counter.getrc() != KeeperException.Code.OK.intValue()) {\n+            LOG.error(\"ZooKeeper error deleting ledger node: \" + counter.getrc());\n+            throw BKException.create(Code.ZKException);\n+        }\n     }\n-    if (ownZKHandle) {\n-      zk.close();\n+\n+    /**\n+     * Shuts down client.\n+     *\n+     */\n+    public void halt() throws InterruptedException {\n+        bookieClient.close();\n+        bookieWatcher.halt();\n+        if (ownChannelFactory) {\n+            channelFactory.releaseExternalResources();\n+        }\n+        if (ownZKHandle) {\n+            zk.close();\n+        }\n+        callbackWorker.shutdown();\n+        mainWorkerPool.shutdown();\n     }\n-    callbackWorker.shutdown();\n-    mainWorkerPool.shutdown();\n-  }\n }"},{"sha":"b2fbc6b5325b77e74387873977a426cf06d8b48e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -44,11 +44,11 @@\n  * are available by reading Zookeeper (and setting watches on the bookie nodes).\n  * When a bookie fails, the other parts of the code turn to this class to find a\n  * replacement\n- * \n+ *\n  */\n class BookieWatcher implements Watcher, ChildrenCallback {\n     static final Logger logger = Logger.getLogger(BookieWatcher.class);\n-    \n+\n     public static final String BOOKIE_REGISTRATION_PATH = \"/ledgers/available\";\n     static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n     public static int ZK_CONNECT_BACKOFF_SEC = 1;\n@@ -69,8 +69,8 @@ public BookieWatcher(BookKeeper bk) {\n         this.bk = bk;\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n     }\n-    \n-    public void halt(){\n+\n+    public void halt() {\n         scheduler.shutdown();\n     }\n "},{"sha":"fb7c8bc78e16c4de22e5c691512bda97ad368afb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,7 +24,7 @@\n \n class CRC32DigestManager extends DigestManager {\n     CRC32 crc = new CRC32();\n-    \n+\n     public CRC32DigestManager(long ledgerId) {\n         super(ledgerId);\n     }\n@@ -33,7 +33,7 @@ public CRC32DigestManager(long ledgerId) {\n     int getMacCodeLength() {\n         return 8;\n     }\n-    \n+\n     @Override\n     byte[] getValueAndReset() {\n         byte[] value = new byte[8];\n@@ -42,7 +42,7 @@ int getMacCodeLength() {\n         crc.reset();\n         return value;\n     }\n-    \n+\n     @Override\n     void update(byte[] data, int offset, int length) {\n         crc.update(data, offset, length);"},{"sha":"d4af3facf6a394f5eff3fbdcb3098e91543c3d24","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -37,29 +37,29 @@\n \n public abstract class DigestManager {\n     static final Logger logger = Logger.getLogger(DigestManager.class);\n-    \n+\n     static final int METADATA_LENGTH = 32;\n-    \n+\n     long ledgerId;\n-    \n+\n     abstract int getMacCodeLength();\n-    \n-    void update(byte[] data){\n+\n+    void update(byte[] data) {\n         update(data, 0, data.length);\n     }\n-    \n+\n     abstract void update(byte[] data, int offset, int length);\n     abstract byte[] getValueAndReset();\n-    \n+\n     final int macCodeLength;\n \n     public DigestManager(long ledgerId) {\n         this.ledgerId = ledgerId;\n         macCodeLength = getMacCodeLength();\n     }\n-    \n-    static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digestType) throws GeneralSecurityException{\n-        switch(digestType){\n+\n+    static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digestType) throws GeneralSecurityException {\n+        switch(digestType) {\n         case MAC:\n             return new MacDigestManager(ledgerId, passwd);\n         case CRC32:\n@@ -71,14 +71,14 @@ static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digest\n \n     /**\n      * Computes the digest for an entry and put bytes together for sending.\n-     *  \n+     *\n      * @param entryId\n      * @param lastAddConfirmed\n      * @param length\n      * @param data\n      * @return\n      */\n-    \n+\n     public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data, int doffset, int dlength) {\n \n         byte[] bufferArray = new byte[METADATA_LENGTH + macCodeLength];\n@@ -133,21 +133,21 @@ private void verifyDigest(long entryId, ChannelBuffer dataReceived, boolean skip\n \n         if (actualLedgerId != ledgerId) {\n             logger.error(\"Ledger-id mismatch in authenticated message, expected: \" + ledgerId + \" , actual: \"\n-                    + actualLedgerId);\n+                         + actualLedgerId);\n             throw new BKDigestMatchException();\n         }\n \n         if (!skipEntryIdCheck && actualEntryId != entryId) {\n             logger.error(\"Entry-id mismatch in authenticated message, expected: \" + entryId + \" , actual: \"\n-                    + actualEntryId);\n+                         + actualEntryId);\n             throw new BKDigestMatchException();\n         }\n \n     }\n-    \n+\n     /**\n      * Verify that the digest matches and returns the data in the entry.\n-     * \n+     *\n      * @param entryId\n      * @param dataReceived\n      * @return"},{"sha":"78aaa1511cb23330edc387d9cdd339aea83f65c7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -20,7 +20,7 @@\n \n /**\n  * This interface determins how entries are distributed among bookies.\n- * \n+ *\n  * Every entry gets replicated to some number of replicas. The first replica for\n  * an entry is given a replicaIndex of 0, and so on. To distribute write load,\n  * not all entries go to all bookies. Given an entry-id and replica index, an\n@@ -31,15 +31,15 @@\n public interface DistributionSchedule {\n \n     /**\n-     * \n+     *\n      * @param entryId\n      * @param replicaIndex\n      * @return index of bookie that should get this replica\n      */\n     public int getBookieIndex(long entryId, int replicaIndex);\n \n     /**\n-     * \n+     *\n      * @param entryId\n      * @param bookieIndex\n      * @return -1 if the given bookie index is not a replica for the given\n@@ -53,7 +53,7 @@\n      * sequence and an implementation of this interface should accumulate\n      * history about which bookie indexes we have heard from. Once this method\n      * has returned true, it wont be called again on the same instance\n-     * \n+     *\n      * @param bookieIndexHeardFrom\n      * @return true if its ok to proceed with recovery\n      */"},{"sha":"06feb308e9a857545545d10aed03eed74cca0370","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":26,"deletions":26,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n package org.apache.bookkeeper.client;\n@@ -39,7 +39,7 @@\n \n /**\n  * Encapsulates asynchronous ledger create operation\n- * \n+ *\n  */\n class LedgerCreateOp implements StringCallback, StatCallback {\n \n@@ -53,24 +53,24 @@\n     BookKeeper bk;\n     DigestType digestType;\n \n-   /**\n-    * Constructor\n-    * \n-    * @param bk\n-    *       BookKeeper object\n-    * @param ensembleSize\n-    *       ensemble size\n-    * @param quorumSize\n-    *       quorum size\n-    * @param digestType\n-    *       digest type, either MAC or CRC32\n-    * @param passwd\n-    *       passowrd\n-    * @param cb\n-    *       callback implementation\n-    * @param ctx\n-    *       optional control object\n-    */\n+    /**\n+     * Constructor\n+     *\n+     * @param bk\n+     *       BookKeeper object\n+     * @param ensembleSize\n+     *       ensemble size\n+     * @param quorumSize\n+     *       quorum size\n+     * @param digestType\n+     *       digest type, either MAC or CRC32\n+     * @param passwd\n+     *       passowrd\n+     * @param cb\n+     *       callback implementation\n+     * @param ctx\n+     *       optional control object\n+     */\n \n     LedgerCreateOp(BookKeeper bk, int ensembleSize, int quorumSize, DigestType digestType, byte[] passwd, CreateCallback cb, Object ctx) {\n         this.bk = bk;\n@@ -91,15 +91,15 @@ public void initiate() {\n          */\n \n         bk.getZkHandle().create(StringUtils.prefix, new byte[0], Ids.OPEN_ACL_UNSAFE,\n-                CreateMode.PERSISTENT_SEQUENTIAL, this, null);\n+                                CreateMode.PERSISTENT_SEQUENTIAL, this, null);\n \n         // calls the children callback method below\n     }\n \n \n     /**\n      * Implements ZooKeeper string callback.\n-     * \n+     *\n      * @see org.apache.zookeeper.AsyncCallback.StringCallback#processResult(int, java.lang.String, java.lang.Object, java.lang.String)\n      */\n     public void processResult(int rc, String path, Object ctx, String name) {\n@@ -157,7 +157,7 @@ public void processResult(int rc, String path, Object ctx, String name) {\n \n     /**\n      * Implements ZooKeeper stat callback.\n-     * \n+     *\n      * @see org.apache.zookeeper.AsyncCallback.StatCallback#processResult(int, String, Object, Stat)\n      */\n     public void processResult(int rc, String path, Object ctx, Stat stat) {"},{"sha":"97b06fb7f9fce9485f484f20c5e925b893dbadbc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n package org.apache.bookkeeper.client;\n@@ -28,7 +28,7 @@\n \n /**\n  * Encapsulates asynchronous ledger delete operation\n- * \n+ *\n  */\n class LedgerDeleteOp implements VoidCallback {\n \n@@ -41,7 +41,7 @@\n \n     /**\n      * Constructor\n-     * \n+     *\n      * @param bk\n      *            BookKeeper object\n      * @param ledgerId\n@@ -69,7 +69,7 @@ public void initiate() {\n \n     /**\n      * Implements ZooKeeper Void Callback.\n-     * \n+     *\n      * @see org.apache.zookeeper.AsyncCallback.VoidCallback#processResult(int,\n      *      java.lang.String, java.lang.Object)\n      */"},{"sha":"8f65e1b8509af4bad55114b16ab93055b6914fa8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.client;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.IOException;\n@@ -30,54 +30,54 @@\n /**\n  * Ledger entry. Its a simple tuple containing the ledger id, the entry-id, and\n  * the entry content.\n- * \n+ *\n  */\n \n public class LedgerEntry {\n-  Logger LOG = Logger.getLogger(LedgerEntry.class);\n+    Logger LOG = Logger.getLogger(LedgerEntry.class);\n \n-  long ledgerId;\n-  long entryId;\n-  long length;\n-  ChannelBufferInputStream entryDataStream;\n+    long ledgerId;\n+    long entryId;\n+    long length;\n+    ChannelBufferInputStream entryDataStream;\n \n-  int nextReplicaIndexToReadFrom = 0;\n+    int nextReplicaIndexToReadFrom = 0;\n \n-  LedgerEntry(long lId, long eId) {\n-    this.ledgerId = lId;\n-    this.entryId = eId;\n-  }\n+    LedgerEntry(long lId, long eId) {\n+        this.ledgerId = lId;\n+        this.entryId = eId;\n+    }\n+\n+    public long getLedgerId() {\n+        return ledgerId;\n+    }\n \n-  public long getLedgerId() {\n-    return ledgerId;\n-  }\n+    public long getEntryId() {\n+        return entryId;\n+    }\n \n-  public long getEntryId() {\n-    return entryId;\n-  }\n-  \n-  public long getLength() {\n-      return length;\n-  }\n+    public long getLength() {\n+        return length;\n+    }\n \n-  public byte[] getEntry() {\n-    try {\n-      // In general, you can't rely on the available() method of an input\n-      // stream, but ChannelBufferInputStream is backed by a byte[] so it\n-      // accurately knows the # bytes available\n-      byte[] ret = new byte[entryDataStream.available()];\n-      entryDataStream.readFully(ret);\n-      return ret;\n-    } catch (IOException e) {\n-      // The channelbufferinput stream doesnt really throw the\n-      // ioexceptions, it just has to be in the signature because\n-      // InputStream says so. Hence this code, should never be reached.\n-      LOG.fatal(\"Unexpected IOException while reading from channel buffer\", e);\n-      return new byte[0];\n+    public byte[] getEntry() {\n+        try {\n+            // In general, you can't rely on the available() method of an input\n+            // stream, but ChannelBufferInputStream is backed by a byte[] so it\n+            // accurately knows the # bytes available\n+            byte[] ret = new byte[entryDataStream.available()];\n+            entryDataStream.readFully(ret);\n+            return ret;\n+        } catch (IOException e) {\n+            // The channelbufferinput stream doesnt really throw the\n+            // ioexceptions, it just has to be in the signature because\n+            // InputStream says so. Hence this code, should never be reached.\n+            LOG.fatal(\"Unexpected IOException while reading from channel buffer\", e);\n+            return new byte[0];\n+        }\n     }\n-  }\n \n-  public InputStream getEntryInputStream() {\n-    return entryDataStream;\n-  }\n+    public InputStream getEntryInputStream() {\n+        return entryDataStream;\n+    }\n }"},{"sha":"2645e94db64ed3de38257be8bde3f1ce00f9b1dc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":531,"deletions":531,"changes":1062,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.client;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.net.InetSocketAddress;\n@@ -53,275 +53,275 @@\n  * write operations to a ledger.\n  */\n public class LedgerHandle implements ReadCallback, AddCallback, CloseCallback, ReadLastConfirmedCallback {\n-  final static Logger LOG = Logger.getLogger(LedgerHandle.class);\n-  final static long LAST_ADD_CONFIRMED = -1;\n-  \n-  final byte[] ledgerKey;\n-  final LedgerMetadata metadata;\n-  final BookKeeper bk;\n-  final long ledgerId;\n-  long lastAddPushed;\n-  long lastAddConfirmed;\n-  long length;\n-  final DigestManager macManager;\n-  final DistributionSchedule distributionSchedule;\n-\n-  final Semaphore opCounterSem;\n-  private Integer throttling = 5000;\n-  \n-  final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();\n-  \n-  LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n-      DigestType digestType, byte[] password)\n-      throws GeneralSecurityException, NumberFormatException {\n-    this.bk = bk;\n-    this.metadata = metadata;\n-    if (metadata.isClosed()) {\n-      lastAddConfirmed = lastAddPushed = metadata.close;\n-      length = metadata.length;\n-    } else {\n-      lastAddConfirmed = lastAddPushed = -1;\n-      length = 0;\n-    }\n-    \n-    this.ledgerId = ledgerId;\n-    \n-    String throttleValue = System.getProperty(\"throttle\");\n-    if(throttleValue != null){\n-        this.throttling = new Integer(throttleValue); \n-    }\n-    this.opCounterSem = new Semaphore(throttling);\n-    \n-    macManager = DigestManager.instantiate(ledgerId, password, digestType);\n-    this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n-    distributionSchedule = new RoundRobinDistributionSchedule(\n-        metadata.quorumSize, metadata.ensembleSize);\n-  }\n-  \n-  /**\n-   * Get the id of the current ledger\n-   * \n-   * @return\n-   */\n-  public long getId() {\n-    return ledgerId;\n-  }\n-\n-  /**\n-   * Get the last confirmed entry id on this ledger\n-   * \n-   * @return\n-   */\n-  public long getLastAddConfirmed() {\n-    return lastAddConfirmed;\n-  }\n-\n-  /**\n-   * Get the entry id of the last entry that has been enqueued for addition (but\n-   * may not have possibly been persited to the ledger)\n-   * \n-   * @return\n-   */\n-  public long getLastAddPushed() {\n-    return lastAddPushed;\n-  }\n-\n-  /**\n-   * Get the Ledger's key/password.\n-   * \n-   * @return byte array for the ledger's key/password.\n-   */\n-  public byte[] getLedgerKey() {\n-      return ledgerKey;\n-  }\n-  \n-  /**\n-   * Get the LedgerMetadata\n-   * \n-   * @return LedgerMetadata for the LedgerHandle\n-   */\n-  public LedgerMetadata getLedgerMetadata() {\n-      return metadata;\n-  }\n-  \n-  /**\n-   * Get the DigestManager\n-   * \n-   * @return DigestManager for the LedgerHandle\n-   */\n-  public DigestManager getDigestManager() {\n-      return macManager;\n-  }\n-  \n-  /**\n-   * Return total number of available slots.\n-   * \n-   * @return int    available slots\n-   */\n-  Semaphore getAvailablePermits(){\n-      return this.opCounterSem;\n-  }\n-  \n-  /**\n-   *  Add to the length of the ledger in bytes.\n-   *  \n-   * @param delta\n-   * @return\n-   */\n-  long addToLength(long delta){\n-      this.length += delta;\n-      return this.length;\n-  }\n-  \n-  /**\n-   * Returns the length of the ledger in bytes. \n-   * \n-   * @return\n-   */\n-  public long getLength(){\n-      return this.length;\n-  }\n-  \n-  /**\n-   * Get the Distribution Schedule\n-   * \n-   * @return DistributionSchedule for the LedgerHandle\n-   */\n-  public DistributionSchedule getDistributionSchedule() {\n-      return distributionSchedule;\n-  }\n-  \n-  public void writeLedgerConfig(StatCallback callback, Object ctx) {\n-    bk.getZkHandle().setData(StringUtils.getLedgerNodePath(ledgerId),\n-        metadata.serialize(), -1, callback, ctx);\n-  }\n-\n-  /**\n-   * Close this ledger synchronously.\n-   * \n-   */\n-  public void close() throws InterruptedException {\n-    SyncCounter counter = new SyncCounter();\n-    counter.inc();\n-\n-    asyncClose(this, counter);\n-\n-    counter.block(0);\n-  }\n-\n-  /**\n-   * Asynchronous close, any adds in flight will return errors\n-   * \n-   * @param cb\n-   *          callback implementation\n-   * @param ctx\n-   *          control object\n-   * @throws InterruptedException\n-   */\n-  public void asyncClose(CloseCallback cb, Object ctx) {\n-    asyncClose(cb, ctx, BKException.Code.LedgerClosedException);\n-  }\n-\n-  /**\n-   * Same as public version of asynClose except that this one takes an\n-   * additional parameter which is the return code to hand to all the pending\n-   * add ops\n-   * \n-   * @param cb\n-   * @param ctx\n-   * @param rc\n-   */\n-  private void asyncClose(final CloseCallback cb, final Object ctx, final int rc) {\n-\n-    bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-\n-      @Override\n-      public void safeRun() {\n-        metadata.length = length;\n-        // Close operation is idempotent, so no need to check if we are\n-        // already closed\n-        metadata.close(lastAddConfirmed);\n-        errorOutPendingAdds(rc);\n-        lastAddPushed = lastAddConfirmed;\n+    final static Logger LOG = Logger.getLogger(LedgerHandle.class);\n+    final static long LAST_ADD_CONFIRMED = -1;\n+\n+    final byte[] ledgerKey;\n+    final LedgerMetadata metadata;\n+    final BookKeeper bk;\n+    final long ledgerId;\n+    long lastAddPushed;\n+    long lastAddConfirmed;\n+    long length;\n+    final DigestManager macManager;\n+    final DistributionSchedule distributionSchedule;\n+\n+    final Semaphore opCounterSem;\n+    private Integer throttling = 5000;\n+\n+    final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();\n+\n+    LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n+                 DigestType digestType, byte[] password)\n+            throws GeneralSecurityException, NumberFormatException {\n+        this.bk = bk;\n+        this.metadata = metadata;\n+        if (metadata.isClosed()) {\n+            lastAddConfirmed = lastAddPushed = metadata.close;\n+            length = metadata.length;\n+        } else {\n+            lastAddConfirmed = lastAddPushed = -1;\n+            length = 0;\n+        }\n \n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n-              + metadata.close + \" with this many bytes: \" + metadata.length);\n+        this.ledgerId = ledgerId;\n+\n+        String throttleValue = System.getProperty(\"throttle\");\n+        if(throttleValue != null) {\n+            this.throttling = new Integer(throttleValue);\n         }\n+        this.opCounterSem = new Semaphore(throttling);\n+\n+        macManager = DigestManager.instantiate(ledgerId, password, digestType);\n+        this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n+        distributionSchedule = new RoundRobinDistributionSchedule(\n+            metadata.quorumSize, metadata.ensembleSize);\n+    }\n+\n+    /**\n+     * Get the id of the current ledger\n+     *\n+     * @return\n+     */\n+    public long getId() {\n+        return ledgerId;\n+    }\n+\n+    /**\n+     * Get the last confirmed entry id on this ledger\n+     *\n+     * @return\n+     */\n+    public long getLastAddConfirmed() {\n+        return lastAddConfirmed;\n+    }\n+\n+    /**\n+     * Get the entry id of the last entry that has been enqueued for addition (but\n+     * may not have possibly been persited to the ledger)\n+     *\n+     * @return\n+     */\n+    public long getLastAddPushed() {\n+        return lastAddPushed;\n+    }\n+\n+    /**\n+     * Get the Ledger's key/password.\n+     *\n+     * @return byte array for the ledger's key/password.\n+     */\n+    public byte[] getLedgerKey() {\n+        return ledgerKey;\n+    }\n+\n+    /**\n+     * Get the LedgerMetadata\n+     *\n+     * @return LedgerMetadata for the LedgerHandle\n+     */\n+    public LedgerMetadata getLedgerMetadata() {\n+        return metadata;\n+    }\n+\n+    /**\n+     * Get the DigestManager\n+     *\n+     * @return DigestManager for the LedgerHandle\n+     */\n+    public DigestManager getDigestManager() {\n+        return macManager;\n+    }\n+\n+    /**\n+     * Return total number of available slots.\n+     *\n+     * @return int    available slots\n+     */\n+    Semaphore getAvailablePermits() {\n+        return this.opCounterSem;\n+    }\n+\n+    /**\n+     *  Add to the length of the ledger in bytes.\n+     *\n+     * @param delta\n+     * @return\n+     */\n+    long addToLength(long delta) {\n+        this.length += delta;\n+        return this.length;\n+    }\n+\n+    /**\n+     * Returns the length of the ledger in bytes.\n+     *\n+     * @return\n+     */\n+    public long getLength() {\n+        return this.length;\n+    }\n+\n+    /**\n+     * Get the Distribution Schedule\n+     *\n+     * @return DistributionSchedule for the LedgerHandle\n+     */\n+    public DistributionSchedule getDistributionSchedule() {\n+        return distributionSchedule;\n+    }\n+\n+    public void writeLedgerConfig(StatCallback callback, Object ctx) {\n+        bk.getZkHandle().setData(StringUtils.getLedgerNodePath(ledgerId),\n+                                 metadata.serialize(), -1, callback, ctx);\n+    }\n+\n+    /**\n+     * Close this ledger synchronously.\n+     *\n+     */\n+    public void close() throws InterruptedException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+\n+        asyncClose(this, counter);\n+\n+        counter.block(0);\n+    }\n+\n+    /**\n+     * Asynchronous close, any adds in flight will return errors\n+     *\n+     * @param cb\n+     *          callback implementation\n+     * @param ctx\n+     *          control object\n+     * @throws InterruptedException\n+     */\n+    public void asyncClose(CloseCallback cb, Object ctx) {\n+        asyncClose(cb, ctx, BKException.Code.LedgerClosedException);\n+    }\n+\n+    /**\n+     * Same as public version of asynClose except that this one takes an\n+     * additional parameter which is the return code to hand to all the pending\n+     * add ops\n+     *\n+     * @param cb\n+     * @param ctx\n+     * @param rc\n+     */\n+    private void asyncClose(final CloseCallback cb, final Object ctx, final int rc) {\n+\n+        bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+\n+            @Override\n+            public void safeRun() {\n+                metadata.length = length;\n+                // Close operation is idempotent, so no need to check if we are\n+                // already closed\n+                metadata.close(lastAddConfirmed);\n+                errorOutPendingAdds(rc);\n+                lastAddPushed = lastAddConfirmed;\n+\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n+                              + metadata.close + \" with this many bytes: \" + metadata.length);\n+                }\n+\n+                writeLedgerConfig(new StatCallback() {\n+                    @Override\n+                    public void processResult(int rc, String path, Object subctx,\n+                    Stat stat) {\n+                        if (rc != KeeperException.Code.OK.intValue()) {\n+                            cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n+                                             ctx);\n+                        } else {\n+                            cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n+                        }\n+                    }\n+                }, null);\n \n-        writeLedgerConfig(new StatCallback() {\n-          @Override\n-          public void processResult(int rc, String path, Object subctx,\n-              Stat stat) {\n-            if (rc != KeeperException.Code.OK.intValue()) {\n-              cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n-                  ctx);\n-            } else {\n-              cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n             }\n-          }\n-        }, null);\n+        });\n+    }\n+\n+    /**\n+     * Read a sequence of entries synchronously.\n+     *\n+     * @param firstEntry\n+     *          id of first entry of sequence (included)\n+     * @param lastEntry\n+     *          id of last entry of sequence (included)\n+     *\n+     */\n+    public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n+            throws InterruptedException, BKException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+\n+        asyncReadEntries(firstEntry, lastEntry, this, counter);\n+\n+        counter.block(0);\n+        if (counter.getrc() != BKException.Code.OK) {\n+            throw BKException.create(counter.getrc());\n+        }\n+\n+        return counter.getSequence();\n+    }\n+\n+    /**\n+     * Read a sequence of entries asynchronously.\n+     *\n+     * @param firstEntry\n+     *          id of first entry of sequence\n+     * @param lastEntry\n+     *          id of last entry of sequence\n+     * @param cb\n+     *          object implementing read callback interface\n+     * @param ctx\n+     *          control object\n+     */\n+    public void asyncReadEntries(long firstEntry, long lastEntry,\n+                                 ReadCallback cb, Object ctx) {\n+        // Little sanity check\n+        if (firstEntry < 0 || lastEntry > lastAddConfirmed\n+                || firstEntry > lastEntry) {\n+            cb.readComplete(BKException.Code.ReadException, this, null, ctx);\n+            return;\n+        }\n \n-      }\n-    });\n-  }\n-\n-  /**\n-   * Read a sequence of entries synchronously.\n-   * \n-   * @param firstEntry\n-   *          id of first entry of sequence (included)\n-   * @param lastEntry\n-   *          id of last entry of sequence (included)\n-   * \n-   */\n-  public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n-      throws InterruptedException, BKException {\n-    SyncCounter counter = new SyncCounter();\n-    counter.inc();\n-\n-    asyncReadEntries(firstEntry, lastEntry, this, counter);\n-\n-    counter.block(0);\n-    if (counter.getrc() != BKException.Code.OK) {\n-      throw BKException.create(counter.getrc());\n-    }\n-\n-    return counter.getSequence();\n-  }\n-\n-  /**\n-   * Read a sequence of entries asynchronously.\n-   * \n-   * @param firstEntry\n-   *          id of first entry of sequence\n-   * @param lastEntry\n-   *          id of last entry of sequence\n-   * @param cb\n-   *          object implementing read callback interface\n-   * @param ctx\n-   *          control object\n-   */\n-  public void asyncReadEntries(long firstEntry, long lastEntry,\n-      ReadCallback cb, Object ctx) {\n-    // Little sanity check\n-    if (firstEntry < 0 || lastEntry > lastAddConfirmed\n-        || firstEntry > lastEntry) {\n-      cb.readComplete(BKException.Code.ReadException, this, null, ctx);\n-      return;\n-    }\n-\n-    try{\n-        new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();\n-  \n-    } catch (InterruptedException e) {\n-        cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);\n-    }\n-  }\n+        try {\n+            new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();\n+\n+        } catch (InterruptedException e) {\n+            cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);\n+        }\n+    }\n \n     /**\n      * Add entry synchronously to an open ledger.\n-     * \n+     *\n      * @param data\n      *         array of bytes to be written to the ledger\n      */\n@@ -331,44 +331,44 @@ public long addEntry(byte[] data) throws InterruptedException, BKException {\n \n     /**\n      * Add entry synchronously to an open ledger.\n-     * \n+     *\n      * @param data\n      *         array of bytes to be written to the ledger\n      * @param offset\n      *          offset from which to take bytes from data\n      * @param length\n      *          number of bytes to take from data\n      */\n-    public long addEntry(byte[] data, int offset, int length) \n+    public long addEntry(byte[] data, int offset, int length)\n             throws InterruptedException, BKException {\n         LOG.debug(\"Adding entry \" + data);\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n-        \n+\n         asyncAddEntry(data, offset, length, this, counter);\n         counter.block(0);\n \n         return counter.getrc();\n     }\n \n-  /**\n-   * Add entry asynchronously to an open ledger.\n-   * \n-   * @param data\n-   *          array of bytes to be written\n-   * @param cb\n-   *          object implementing callbackinterface\n-   * @param ctx\n-   *          some control object\n-   */\n-    public void asyncAddEntry(final byte[] data, final AddCallback cb, \n+    /**\n+     * Add entry asynchronously to an open ledger.\n+     *\n+     * @param data\n+     *          array of bytes to be written\n+     * @param cb\n+     *          object implementing callbackinterface\n+     * @param ctx\n+     *          some control object\n+     */\n+    public void asyncAddEntry(final byte[] data, final AddCallback cb,\n                               final Object ctx) {\n         asyncAddEntry(data, 0, data.length, cb, ctx);\n     }\n \n     /**\n      * Add entry asynchronously to an open ledger, using an offset and range.\n-     * \n+     *\n      * @param data\n      *          array of bytes to be written\n      * @param offset\n@@ -379,285 +379,285 @@ public void asyncAddEntry(final byte[] data, final AddCallback cb,\n      *          object implementing callbackinterface\n      * @param ctx\n      *          some control object\n-     * @throws ArrayIndexOutOfBoundsException if offset or length is negative or \n+     * @throws ArrayIndexOutOfBoundsException if offset or length is negative or\n      *          offset and length sum to a value higher than the length of data.\n      */\n-    public void asyncAddEntry(final byte[] data, final int offset, final int length, \n+    public void asyncAddEntry(final byte[] data, final int offset, final int length,\n                               final AddCallback cb, final Object ctx) {\n         if (offset < 0 || length < 0\n-            || (offset + length) > data.length) {\n+                || (offset + length) > data.length) {\n             throw new ArrayIndexOutOfBoundsException(\n-                    \"Invalid values for offset(\"+offset\n-                    +\") or length(\"+length+\")\");\n+                \"Invalid values for offset(\"+offset\n+                +\") or length(\"+length+\")\");\n         }\n-        try{\n+        try {\n             opCounterSem.acquire();\n         } catch (InterruptedException e) {\n             cb.addComplete(BKException.Code.InterruptedException,\n-                    LedgerHandle.this, -1, ctx);\n+                           LedgerHandle.this, -1, ctx);\n         }\n-        \n-        try{\n+\n+        try {\n             bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-                    @Override\n-                    public void safeRun() {\n-                        if (metadata.isClosed()) {\n-                            LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                            LedgerHandle.this.opCounterSem.release();\n-                            cb.addComplete(BKException.Code.LedgerClosedException,\n-                                           LedgerHandle.this, -1, ctx);\n-                            return;\n-                        }\n-                        \n-                        long entryId = ++lastAddPushed;\n-                        long currentLength = addToLength(length);\n-                        PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);\n-                        pendingAddOps.add(op);\n-                        ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n-                                entryId, lastAddConfirmed, currentLength, data, offset, length);\n-                        op.initiate(toSend);\n+                @Override\n+                public void safeRun() {\n+                    if (metadata.isClosed()) {\n+                        LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n+                        LedgerHandle.this.opCounterSem.release();\n+                        cb.addComplete(BKException.Code.LedgerClosedException,\n+                                       LedgerHandle.this, -1, ctx);\n+                        return;\n                     }\n-                });\n+\n+                    long entryId = ++lastAddPushed;\n+                    long currentLength = addToLength(length);\n+                    PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);\n+                    pendingAddOps.add(op);\n+                    ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n+                                               entryId, lastAddConfirmed, currentLength, data, offset, length);\n+                    op.initiate(toSend);\n+                }\n+            });\n         } catch (RuntimeException e) {\n             opCounterSem.release();\n             throw e;\n         }\n     }\n \n-  /**\n-   * Obtains last confirmed write from a quorum of bookies.\n-   * \n-   * @param cb\n-   * @param ctx\n-   */\n-  \n-  public void asyncReadLastConfirmed(ReadLastConfirmedCallback cb, Object ctx){\n-      new ReadLastConfirmedOp(this, cb, ctx).initiate();\n-  }\n-  \n-  \n-  /**\n-   * Context objects for synchronous call to read last confirmed. \n-   */\n-  class LastConfirmedCtx {\n-      long response;\n-      int rc;\n-      \n-      LastConfirmedCtx(){\n-          this.response = -1;\n-      }\n-      \n-      void setLastConfirmed(long lastConfirmed){\n-          this.response = lastConfirmed;\n-      }\n-      \n-      long getlastConfirmed(){\n-          return this.response;\n-      }\n-      \n-      void setRC(int rc){\n-          this.rc = rc;\n-      }\n-      \n-      int getRC(){\n-          return this.rc;\n-      }\n-      \n-      boolean ready(){\n-          return (this.response != -1);\n-      }\n-  }\n-  \n-  public long readLastConfirmed()\n-  throws InterruptedException, BKException {   \n-      LastConfirmedCtx ctx = new LastConfirmedCtx();\n-      asyncReadLastConfirmed(this, ctx);\n-      synchronized(ctx){\n-          while(!ctx.ready()){\n-              ctx.wait();\n-          }\n-      }\n-      \n-      if(ctx.getRC() != BKException.Code.OK) throw BKException.create(ctx.getRC());\n-      return ctx.getlastConfirmed();\n-  }\n-  \n-  // close the ledger and send fails to all the adds in the pipeline\n-  void handleUnrecoverableErrorDuringAdd(int rc) {\n-    asyncClose(NoopCloseCallback.instance, null, rc);\n-  }\n-\n-  void errorOutPendingAdds(int rc) {\n-    PendingAddOp pendingAddOp;\n-    while ((pendingAddOp = pendingAddOps.poll()) != null) {\n-      pendingAddOp.submitCallback(rc);\n-    }\n-  }\n-\n-  void sendAddSuccessCallbacks() {\n-    // Start from the head of the queue and proceed while there are\n-    // entries that have had all their responses come back\n-    PendingAddOp pendingAddOp;\n-    while ((pendingAddOp = pendingAddOps.peek()) != null) {\n-      if (pendingAddOp.numResponsesPending != 0) {\n-        return;\n-      }\n-      pendingAddOps.remove();\n-      lastAddConfirmed = pendingAddOp.entryId;\n-      pendingAddOp.submitCallback(BKException.Code.OK);\n-    }\n-\n-  }\n-\n-  void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n-    InetSocketAddress newBookie;\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Handling failure of bookie: \" + addr + \" index: \"\n-          + bookieIndex);\n-    }\n-\n-    try {\n-      newBookie = bk.bookieWatcher\n-          .getAdditionalBookie(metadata.currentEnsemble);\n-    } catch (BKNotEnoughBookiesException e) {\n-      LOG\n-          .error(\"Could not get additional bookie to remake ensemble, closing ledger: \"\n-              + ledgerId);\n-      handleUnrecoverableErrorDuringAdd(e.getCode());\n-      return;\n-    }\n-\n-    final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>(\n-        metadata.currentEnsemble);\n-    newEnsemble.set(bookieIndex, newBookie);\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble + \" to: \"\n-          + newEnsemble + \" for ledger: \" + ledgerId + \" starting at entry: \"\n-          + (lastAddConfirmed + 1));\n-    }\n-\n-    metadata.addEnsemble(lastAddConfirmed + 1, newEnsemble);\n-\n-    writeLedgerConfig(new StatCallback() {\n-      @Override\n-      public void processResult(final int rc, String path, Object ctx, Stat stat) {\n+    /**\n+     * Obtains last confirmed write from a quorum of bookies.\n+     *\n+     * @param cb\n+     * @param ctx\n+     */\n+\n+    public void asyncReadLastConfirmed(ReadLastConfirmedCallback cb, Object ctx) {\n+        new ReadLastConfirmedOp(this, cb, ctx).initiate();\n+    }\n+\n \n-        bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-          @Override\n-          public void safeRun() {\n-            if (rc != KeeperException.Code.OK.intValue()) {\n-              LOG\n-                  .error(\"Could not persist ledger metadata while changing ensemble to: \"\n-                      + newEnsemble + \" , closing ledger\");\n-              handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n-              return;\n+    /**\n+     * Context objects for synchronous call to read last confirmed.\n+     */\n+    class LastConfirmedCtx {\n+        long response;\n+        int rc;\n+\n+        LastConfirmedCtx() {\n+            this.response = -1;\n+        }\n+\n+        void setLastConfirmed(long lastConfirmed) {\n+            this.response = lastConfirmed;\n+        }\n+\n+        long getlastConfirmed() {\n+            return this.response;\n+        }\n+\n+        void setRC(int rc) {\n+            this.rc = rc;\n+        }\n+\n+        int getRC() {\n+            return this.rc;\n+        }\n+\n+        boolean ready() {\n+            return (this.response != -1);\n+        }\n+    }\n+\n+    public long readLastConfirmed()\n+            throws InterruptedException, BKException {\n+        LastConfirmedCtx ctx = new LastConfirmedCtx();\n+        asyncReadLastConfirmed(this, ctx);\n+        synchronized(ctx) {\n+            while(!ctx.ready()) {\n+                ctx.wait();\n             }\n+        }\n+\n+        if(ctx.getRC() != BKException.Code.OK) throw BKException.create(ctx.getRC());\n+        return ctx.getlastConfirmed();\n+    }\n \n-            for (PendingAddOp pendingAddOp : pendingAddOps) {\n-              pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n+    // close the ledger and send fails to all the adds in the pipeline\n+    void handleUnrecoverableErrorDuringAdd(int rc) {\n+        asyncClose(NoopCloseCallback.instance, null, rc);\n+    }\n+\n+    void errorOutPendingAdds(int rc) {\n+        PendingAddOp pendingAddOp;\n+        while ((pendingAddOp = pendingAddOps.poll()) != null) {\n+            pendingAddOp.submitCallback(rc);\n+        }\n+    }\n+\n+    void sendAddSuccessCallbacks() {\n+        // Start from the head of the queue and proceed while there are\n+        // entries that have had all their responses come back\n+        PendingAddOp pendingAddOp;\n+        while ((pendingAddOp = pendingAddOps.peek()) != null) {\n+            if (pendingAddOp.numResponsesPending != 0) {\n+                return;\n             }\n-          }\n-        });\n+            pendingAddOps.remove();\n+            lastAddConfirmed = pendingAddOp.entryId;\n+            pendingAddOp.submitCallback(BKException.Code.OK);\n+        }\n+\n+    }\n+\n+    void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n+        InetSocketAddress newBookie;\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Handling failure of bookie: \" + addr + \" index: \"\n+                      + bookieIndex);\n+        }\n \n-      }\n-    }, null);\n+        try {\n+            newBookie = bk.bookieWatcher\n+                        .getAdditionalBookie(metadata.currentEnsemble);\n+        } catch (BKNotEnoughBookiesException e) {\n+            LOG\n+            .error(\"Could not get additional bookie to remake ensemble, closing ledger: \"\n+                   + ledgerId);\n+            handleUnrecoverableErrorDuringAdd(e.getCode());\n+            return;\n+        }\n+\n+        final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>(\n+            metadata.currentEnsemble);\n+        newEnsemble.set(bookieIndex, newBookie);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble + \" to: \"\n+                      + newEnsemble + \" for ledger: \" + ledgerId + \" starting at entry: \"\n+                      + (lastAddConfirmed + 1));\n+        }\n+\n+        metadata.addEnsemble(lastAddConfirmed + 1, newEnsemble);\n+\n+        writeLedgerConfig(new StatCallback() {\n+            @Override\n+            public void processResult(final int rc, String path, Object ctx, Stat stat) {\n+\n+                bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        if (rc != KeeperException.Code.OK.intValue()) {\n+                            LOG\n+                            .error(\"Could not persist ledger metadata while changing ensemble to: \"\n+                                   + newEnsemble + \" , closing ledger\");\n+                            handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                            return;\n+                        }\n+\n+                        for (PendingAddOp pendingAddOp : pendingAddOps) {\n+                            pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n+                        }\n+                    }\n+                });\n+\n+            }\n+        }, null);\n+\n+    }\n+\n+    void recover(GenericCallback<Void> cb) {\n+        if (metadata.isClosed()) {\n+            // We are already closed, nothing to do\n+            cb.operationComplete(BKException.Code.OK, null);\n+            return;\n+        }\n+\n+        new LedgerRecoveryOp(this, cb).initiate();\n+    }\n \n-  }\n+    static class NoopCloseCallback implements CloseCallback {\n+        static NoopCloseCallback instance = new NoopCloseCallback();\n \n-  void recover(GenericCallback<Void> cb) {\n-    if (metadata.isClosed()) {\n-      // We are already closed, nothing to do\n-      cb.operationComplete(BKException.Code.OK, null);\n-      return;\n+        @Override\n+        public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n+            // noop\n+        }\n+    }\n+\n+    /**\n+     * Implementation of callback interface for synchronous read method.\n+     *\n+     * @param rc\n+     *          return code\n+     * @param leder\n+     *          ledger identifier\n+     * @param seq\n+     *          sequence of entries\n+     * @param ctx\n+     *          control object\n+     */\n+    public void readComplete(int rc, LedgerHandle lh,\n+                             Enumeration<LedgerEntry> seq, Object ctx) {\n+\n+        SyncCounter counter = (SyncCounter) ctx;\n+        synchronized (counter) {\n+            counter.setSequence(seq);\n+            counter.setrc(rc);\n+            counter.dec();\n+            counter.notify();\n+        }\n+    }\n+\n+    /**\n+     * Implementation of callback interface for synchronous read method.\n+     *\n+     * @param rc\n+     *          return code\n+     * @param leder\n+     *          ledger identifier\n+     * @param entry\n+     *          entry identifier\n+     * @param ctx\n+     *          control object\n+     */\n+    public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n+        SyncCounter counter = (SyncCounter) ctx;\n+\n+        counter.setrc(rc);\n+        counter.dec();\n     }\n \n-    new LedgerRecoveryOp(this, cb).initiate();\n-  }\n \n-  static class NoopCloseCallback implements CloseCallback {\n-    static NoopCloseCallback instance = new NoopCloseCallback();\n \n-    @Override\n+    /**\n+     * Implementation of  callback interface for synchronous read last confirmed method.\n+     */\n+    public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n+        LastConfirmedCtx lcCtx = (LastConfirmedCtx) ctx;\n+\n+        synchronized(lcCtx) {\n+            lcCtx.setRC(rc);\n+            lcCtx.setLastConfirmed(lastConfirmed);\n+            lcCtx.notify();\n+        }\n+    }\n+\n+    /**\n+     * Close callback method\n+     *\n+     * @param rc\n+     * @param lh\n+     * @param ctx\n+     */\n     public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n-      // noop\n-    }\n-  }\n-\n-  /**\n-   * Implementation of callback interface for synchronous read method.\n-   * \n-   * @param rc\n-   *          return code\n-   * @param leder\n-   *          ledger identifier\n-   * @param seq\n-   *          sequence of entries\n-   * @param ctx\n-   *          control object\n-   */\n-  public void readComplete(int rc, LedgerHandle lh,\n-      Enumeration<LedgerEntry> seq, Object ctx) {\n-\n-    SyncCounter counter = (SyncCounter) ctx;\n-    synchronized (counter) {\n-      counter.setSequence(seq);\n-      counter.setrc(rc);\n-      counter.dec();\n-      counter.notify();\n-    }\n-  }\n-\n-  /**\n-   * Implementation of callback interface for synchronous read method.\n-   * \n-   * @param rc\n-   *          return code\n-   * @param leder\n-   *          ledger identifier\n-   * @param entry\n-   *          entry identifier\n-   * @param ctx\n-   *          control object\n-   */\n-  public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n-    SyncCounter counter = (SyncCounter) ctx;\n-\n-    counter.setrc(rc);\n-    counter.dec();\n-  }\n-\n-  \n-\n-  /**\n-   * Implementation of  callback interface for synchronous read last confirmed method.\n-   */\n-  public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n-      LastConfirmedCtx lcCtx = (LastConfirmedCtx) ctx;\n-      \n-      synchronized(lcCtx){\n-          lcCtx.setRC(rc);\n-          lcCtx.setLastConfirmed(lastConfirmed);\n-          lcCtx.notify();\n-      }\n-  }\n-  \n-  /**\n-   * Close callback method\n-   * \n-   * @param rc\n-   * @param lh\n-   * @param ctx\n-   */\n-  public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n-\n-    SyncCounter counter = (SyncCounter) ctx;\n-    counter.setrc(rc);\n-    synchronized (counter) {\n-      counter.dec();\n-      counter.notify();\n-    }\n-\n-  }\n+\n+        SyncCounter counter = (SyncCounter) ctx;\n+        counter.setrc(rc);\n+        synchronized (counter) {\n+            counter.dec();\n+            counter.notify();\n+        }\n+\n+    }\n }"},{"sha":"445264305f6a8e51a6cd6f18dd4377a789e5aaf3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":14,"deletions":14,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -31,7 +31,7 @@\n /**\n  * This class encapsulates all the ledger metadata that is persistently stored\n  * in zookeeper. It provides parsing and serialization methods of such metadata.\n- * \n+ *\n  */\n public class LedgerMetadata {\n     static final Logger LOG = Logger.getLogger(LedgerMetadata.class);\n@@ -53,9 +53,9 @@\n     public LedgerMetadata(int ensembleSize, int quorumSize) {\n         this.ensembleSize = ensembleSize;\n         this.quorumSize = quorumSize;\n-        \n+\n         /*\n-         * It is set in PendingReadOp.readEntryComplete, and \n+         * It is set in PendingReadOp.readEntryComplete, and\n          * we read it in LedgerRecoveryOp.readComplete.\n          */\n         this.length = 0;\n@@ -67,24 +67,24 @@ private LedgerMetadata() {\n     }\n \n     /**\n-     * Get the Map of bookie ensembles for the various ledger fragments \n+     * Get the Map of bookie ensembles for the various ledger fragments\n      * that make up the ledger.\n-     * \n-     * @return SortedMap of Ledger Fragments and the corresponding \n+     *\n+     * @return SortedMap of Ledger Fragments and the corresponding\n      * bookie ensembles that store the entries.\n      */\n     public SortedMap<Long, ArrayList<InetSocketAddress>> getEnsembles() {\n         return ensembles;\n     }\n-    \n+\n     boolean isClosed() {\n         return close != NOTCLOSED;\n     }\n \n     void close(long entryId) {\n         close = entryId;\n     }\n-    \n+\n     void addEnsemble(long startEntryId, ArrayList<InetSocketAddress> ensemble) {\n         assert ensembles.isEmpty() || startEntryId >= ensembles.lastKey();\n \n@@ -101,7 +101,7 @@ void addEnsemble(long startEntryId, ArrayList<InetSocketAddress> ensemble) {\n     /**\n      * the entry id > the given entry-id at which the next ensemble change takes\n      * place ( -1 if no further ensemble changes)\n-     * \n+     *\n      * @param entryId\n      * @return\n      */\n@@ -117,7 +117,7 @@ long getNextEnsembleChange(long entryId) {\n \n     /**\n      * Generates a byte array based on a LedgerConfig object received.\n-     * \n+     *\n      * @param config\n      *            LedgerConfig object\n      * @return byte[]\n@@ -133,7 +133,7 @@ long getNextEnsembleChange(long entryId) {\n                 StringUtils.addrToString(s, addr);\n             }\n         }\n-        \n+\n         if (close != NOTCLOSED) {\n             s.append(lSplitter).append(close).append(tSplitter).append(closed);\n         }\n@@ -147,7 +147,7 @@ long getNextEnsembleChange(long entryId) {\n \n     /**\n      * Parses a given byte array and transforms into a LedgerConfig object\n-     * \n+     *\n      * @param array\n      *            byte array to parse\n      * @return LedgerConfig\n@@ -173,8 +173,8 @@ static LedgerMetadata parseConfig(byte[] bytes) throws IOException {\n         try {\n             lc.quorumSize = new Integer(lines[0]);\n             lc.ensembleSize = new Integer(lines[1]);\n-            lc.length = new Long(lines[2]); \n-            \n+            lc.length = new Long(lines[2]);\n+\n             for (int i = 3; i < lines.length; i++) {\n                 String parts[] = lines[i].split(tSplitter);\n "},{"sha":"b59d40892c7ce82d1a7014a1d2834a0141f4e588","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":17,"deletions":17,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n package org.apache.bookkeeper.client;\n@@ -34,11 +34,11 @@\n \n /**\n  * Encapsulates the ledger open operation\n- * \n+ *\n  */\n class LedgerOpenOp implements DataCallback {\n     static final Logger LOG = Logger.getLogger(LedgerOpenOp.class);\n-    \n+\n     final BookKeeper bk;\n     final long ledgerId;\n     final OpenCallback cb;\n@@ -47,18 +47,18 @@\n     final byte[] passwd;\n     final DigestType digestType;\n     final boolean unsafe;\n-    \n+\n     /**\n      * Constructor.\n-     * \n+     *\n      * @param bk\n      * @param ledgerId\n      * @param digestType\n      * @param passwd\n      * @param cb\n      * @param ctx\n      */\n-    \n+\n     public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, boolean unsafe, OpenCallback cb, Object ctx) {\n         this.bk = bk;\n         this.ledgerId = ledgerId;\n@@ -96,7 +96,7 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n         }\n         if (rc != KeeperException.Code.OK.intValue()) {\n             LOG.error(\"Could not read metadata for ledger: \" + ledgerId, KeeperException.create(KeeperException.Code\n-                    .get(rc), path));\n+                      .get(rc), path));\n             cb.openComplete(BKException.Code.ZKException, null, this.ctx);\n             return;\n         }\n@@ -130,14 +130,14 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n \n         if(!unsafe)\n             lh.recover(new GenericCallback<Void>() {\n-                @Override\n-                public void operationComplete(int rc, Void result) {\n-                    if (rc != BKException.Code.OK) {\n-                        cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n-                    } else {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (rc != BKException.Code.OK) {\n+                    cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n+                } else {\n                     cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n-                    }\n                 }\n-            });\n+            }\n+        });\n     }\n }"},{"sha":"1dc2adffd46e61db4bca292cfd82d5943e6e2b75","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -32,11 +32,11 @@\n \n /**\n  * This class encapsulated the ledger recovery operation. It first does a read\n- * with entry-id of -1 (LedgerHandle.LAST_ADD_CONFIRMED) to all bookies. Then \n- * starting from the last confirmed entry (from hints in the ledger entries), \n+ * with entry-id of -1 (LedgerHandle.LAST_ADD_CONFIRMED) to all bookies. Then\n+ * starting from the last confirmed entry (from hints in the ledger entries),\n  * it reads forward until it is not able to find a particular entry. It closes\n  * the ledger at that entry.\n- * \n+ *\n  */\n class LedgerRecoveryOp implements ReadEntryCallback, ReadCallback, AddCallback {\n     static final Logger LOG = Logger.getLogger(LedgerRecoveryOp.class);\n@@ -85,7 +85,7 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n                 // Too bad, this bookie didnt give us a valid answer, we\n                 // still might be able to recover though so continue\n                 LOG.error(\"Mac mismatch while reading last entry from bookie: \"\n-                        + lh.metadata.currentEnsemble.get(bookieIndex));\n+                          + lh.metadata.currentEnsemble.get(bookieIndex));\n             }\n         }\n \n@@ -128,17 +128,17 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         // get back to prev value\n         lh.lastAddConfirmed--;\n         if (rc == BKException.Code.OK) {\n-            LedgerEntry entry = seq.nextElement(); \n+            LedgerEntry entry = seq.nextElement();\n             byte[] data = entry.getEntry();\n-            \n+\n             /*\n              * We will add this entry again to make sure it is written to enough\n              * replicas. We subtract the length of the data itself, since it will\n              * be added again when processing the call to add it.\n              */\n             lh.length = entry.getLength() - (long) data.length;\n             lh.asyncAddEntry(data, this, null);\n-            \n+\n             return;\n         }\n \n@@ -156,7 +156,7 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n \n         // otherwise, some other error, we can't handle\n         LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + lh.lastAddConfirmed + 1\n-                + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n+                  + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n         cb.operationComplete(rc, null);\n         return;\n     }\n@@ -167,7 +167,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n             // Give up, we can't recover from this error\n \n             LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + lh.lastAddConfirmed + 1\n-                    + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n+                      + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n             cb.operationComplete(rc, null);\n             return;\n         }"},{"sha":"1131652a243e4d71a07b4b630d6adcd5273bd1df","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -36,32 +36,32 @@ public MacDigestManager(long ledgerId, byte[] passwd) throws GeneralSecurityExce\n         SecretKeySpec keySpec = new SecretKeySpec(macKey, KEY_ALGORITHM);\n         mac = Mac.getInstance(KEY_ALGORITHM);\n         mac.init(keySpec);\n-        \n-        \n+\n+\n     }\n \n     static byte[] genDigest(String pad, byte[] passwd) throws NoSuchAlgorithmException {\n         MessageDigest digest = MessageDigest.getInstance(DIGEST_ALGORITHM);\n         digest.update(pad.getBytes());\n         digest.update(passwd);\n-                return digest.digest();\n+        return digest.digest();\n     }\n \n     @Override\n     int getMacCodeLength() {\n         return 20;\n     }\n \n-    \n+\n     @Override\n     byte[] getValueAndReset() {\n         return mac.doFinal();\n     }\n-    \n+\n     @Override\n     void update(byte[] data, int offset, int length) {\n         mac.update(data, offset, length);\n     }\n-    \n-    \n+\n+\n }"},{"sha":"eddd76027c08e0106bb67654e979643f6badedbc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -30,8 +30,8 @@\n  * sends ack back to the application. If a bookie fails, a replacement is made\n  * and placed at the same position in the ensemble. The pending adds are then\n  * rereplicated.\n- * \n- * \n+ *\n+ *\n  */\n class PendingAddOp implements WriteCallback {\n     final static Logger LOG = Logger.getLogger(PendingAddOp.class);\n@@ -55,7 +55,7 @@\n \n     void sendWriteRequest(int bookieIndex, int arrayIndex) {\n         lh.bk.bookieClient.addEntry(lh.metadata.currentEnsemble.get(bookieIndex), lh.ledgerId, lh.ledgerKey, entryId, toSend,\n-                this, arrayIndex);\n+                                    this, arrayIndex);\n     }\n \n     void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n@@ -70,14 +70,14 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n         if (replicaIndex < 0) {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Leaving unchanged, ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n-                        + bookieIndex);\n+                          + bookieIndex);\n             }\n             return;\n         }\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Unsetting success for ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n-                    + bookieIndex);\n+                      + bookieIndex);\n         }\n \n         // if we had already heard a success from this array index, need to\n@@ -87,8 +87,8 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n             successesSoFar[replicaIndex] = false;\n             numResponsesPending++;\n         }\n-        \n-         sendWriteRequest(bookieIndex, replicaIndex);\n+\n+        sendWriteRequest(bookieIndex, replicaIndex);\n     }\n \n     void initiate(ChannelBuffer toSend) {\n@@ -110,7 +110,7 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             LOG.warn(\"Write did not succeed: \" + ledgerId + \", \" + entryId + \". But we have already fixed it.\");\n             return;\n         }\n-        \n+\n         if (rc != BKException.Code.OK) {\n             LOG.warn(\"Write did not succeed: \" + ledgerId + \", \" + entryId);\n             lh.handleBookieFailure(addr, bookieIndex);\n@@ -121,18 +121,18 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n         if (!successesSoFar[replicaIndex]) {\n             successesSoFar[replicaIndex] = true;\n             numResponsesPending--;\n-            \n+\n             // do some quick checks to see if some adds may have finished. All\n             // this will be checked under locks again\n             if (numResponsesPending == 0 && lh.pendingAddOps.peek() == this) {\n                 lh.sendAddSuccessCallbacks();\n             }\n-        } \n+        }\n     }\n \n     void submitCallback(final int rc) {\n         cb.addComplete(rc, lh, entryId, ctx);\n         lh.opCounterSem.release();\n     }\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"385b16ce52f65ecd0713134d1248bad5b4b71428","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":17,"deletions":17,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.client;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.net.InetSocketAddress;\n@@ -42,7 +42,7 @@\n  * When all the data read has come back, the application callback is called.\n  * This class could be improved because we could start pushing data to the\n  * application as soon as it arrives rather than waiting for the whole thing.\n- * \n+ *\n  */\n \n class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n@@ -73,12 +73,12 @@ public void initiate() throws InterruptedException {\n         ArrayList<InetSocketAddress> ensemble = null;\n         do {\n \n-            if(LOG.isDebugEnabled()){\n+            if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Acquiring lock: \" + i);\n             }\n-           \n+\n             lh.opCounterSem.acquire();\n-            \n+\n             if (i == nextEnsembleChange) {\n                 ensemble = lh.metadata.getEnsemble(i);\n                 nextEnsembleChange = lh.metadata.getNextEnsembleChange(i);\n@@ -108,7 +108,7 @@ void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n         ArrayList<InetSocketAddress> ensemble = lh.metadata.getEnsemble(entry.entryId);\n         int bookeIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom - 1);\n         LOG.error(errMsg + \" while reading entry: \" + entry.entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n-                + ensemble.get(bookeIndex));\n+                  + ensemble.get(bookeIndex));\n         sendRead(ensemble, entry, rc);\n         return;\n     }\n@@ -121,17 +121,17 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n             logErrorAndReattemptRead(entry, \"Error: \" + BKException.getMessage(rc), rc);\n             return;\n         }\n-        \n+\n         ChannelBufferInputStream is;\n         try {\n             is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n         } catch (BKDigestMatchException e) {\n             logErrorAndReattemptRead(entry, \"Mac mismatch\", BKException.Code.DigestMatchException);\n             return;\n         }\n-        \n+\n         entry.entryDataStream = is;\n-        \n+\n         /*\n          * The length is a long and it is the last field of the metadata of an entry.\n          * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n@@ -142,18 +142,18 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n         if (numPendingReads == 0) {\n             submitCallback(BKException.Code.OK);\n         }\n-        \n-        if(LOG.isDebugEnabled()){\n+\n+        if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Releasing lock: \" + entryId);\n         }\n-        \n+\n         lh.opCounterSem.release();\n-        \n+\n         if(numPendingReads < 0)\n             LOG.error(\"Read too many values\");\n     }\n \n-    private void submitCallback(int code){\n+    private void submitCallback(int code) {\n         cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);\n     }\n     public boolean hasMoreElements() {"},{"sha":"d9a21fe42442f1cc34ef74f82270f88276289be0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -30,16 +30,16 @@\n import org.jboss.netty.buffer.ChannelBuffer;\n \n /**\n- * This class encapsulated the read last confirmed operation. \n- * \n+ * This class encapsulated the read last confirmed operation.\n+ *\n  */\n class ReadLastConfirmedOp implements ReadEntryCallback {\n     static final Logger LOG = Logger.getLogger(LedgerRecoveryOp.class);\n     LedgerHandle lh;\n-    Object ctx; \n+    Object ctx;\n     int numResponsesPending;\n     int validResponses;\n-    long maxAddConfirmed; \n+    long maxAddConfirmed;\n     long maxLength = 0;\n     volatile boolean notComplete = true;\n \n@@ -62,9 +62,9 @@ public void initiate() {\n     public synchronized void readEntryComplete(final int rc, final long ledgerId, final long entryId,\n             final ChannelBuffer buffer, final Object ctx) {\n         int bookieIndex = (Integer) ctx;\n-        \n+\n         numResponsesPending--;\n-        \n+\n         if (rc == BKException.Code.OK) {\n             try {\n                 RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n@@ -74,10 +74,10 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n                 // Too bad, this bookie didn't give us a valid answer, we\n                 // still might be able to recover though so continue\n                 LOG.error(\"Mac mismatch while reading last entry from bookie: \"\n-                        + lh.metadata.currentEnsemble.get(bookieIndex));\n+                          + lh.metadata.currentEnsemble.get(bookieIndex));\n             }\n         }\n-        \n+\n         if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n             // this still counts as a valid response, e.g., if the client crashed without writing any entry\n             validResponses++;\n@@ -96,6 +96,6 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n             LOG.error(\"While recovering ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n             cb.readLastConfirmedComplete(BKException.Code.LedgerRecoveryException, maxAddConfirmed, ctx);\n         }\n-        \n+\n     }\n }"},{"sha":"4a88747b88e3b250d4e848257da32ec54d467b3e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -25,7 +25,7 @@\n  * fashion. For ensemble size 3, and quorum size 2, Entry 0 goes to bookie 0 and\n  * 1, entry 1 goes to bookie 1 and 2, and entry 2 goes to bookie 2 and 0, and so\n  * on.\n- * \n+ *\n  */\n class RoundRobinDistributionSchedule implements DistributionSchedule {\n     int quorumSize;"},{"sha":"888e46d00a8505de08aa8b7cf6ef6352f403d3f6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SyncCounter.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -25,7 +25,7 @@\n \n /**\n  * Implements objects to help with the synchronization of asynchronous calls\n- * \n+ *\n  */\n \n class SyncCounter {"},{"sha":"69ed6782459462c88087212557700e9757997668","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.proto;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.IOException;\n@@ -39,7 +39,7 @@\n \n /**\n  * Implements the client-side part of the BookKeeper protocol.\n- * \n+ *\n  */\n public class BookieClient {\n     static final Logger LOG = Logger.getLogger(BookieClient.class);\n@@ -73,7 +73,7 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n     }\n \n     public void addEntry(final InetSocketAddress addr, final long ledgerId, final byte[] masterKey, final long entryId,\n-            final ChannelBuffer toSend, final WriteCallback cb, final Object ctx) {\n+                         final ChannelBuffer toSend, final WriteCallback cb, final Object ctx) {\n \n         final PerChannelBookieClient client = lookupClient(addr);\n \n@@ -90,7 +90,7 @@ public void operationComplete(int rc, Void result) {\n     }\n \n     public void readEntry(final InetSocketAddress addr, final long ledgerId, final long entryId,\n-            final ReadEntryCallback cb, final Object ctx) {\n+                          final ReadEntryCallback cb, final Object ctx) {\n \n         final PerChannelBookieClient client = lookupClient(addr);\n \n@@ -107,8 +107,8 @@ public void operationComplete(int rc, Void result) {\n         });\n     }\n \n-    public void close(){\n-        for (PerChannelBookieClient channel: channels.values()){\n+    public void close() {\n+        for (PerChannelBookieClient channel: channels.values()) {\n             channel.close();\n         }\n     }"},{"sha":"63084a89f93857f008934cdc776ea350dae1bbcb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,31 +1,31 @@\n package org.apache.bookkeeper.proto;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n /**\n  * The packets of the Bookie protocol all have a 4-byte integer indicating the\n  * type of request or response at the very beginning of the packet followed by a\n  * payload.\n- * \n+ *\n  */\n public interface BookieProtocol {\n     /**"},{"sha":"1ff135b4ff2de9118ce3ea7620f5d3cbce0c0d30","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.proto;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.File;\n@@ -33,7 +33,7 @@\n \n /**\n  * Implements the server-side part of the BookKeeper protocol.\n- * \n+ *\n  */\n public class BookieServer implements NIOServerFactory.PacketProcessor, BookkeeperInternalCallbacks.WriteCallback {\n     int port;\n@@ -64,7 +64,7 @@ public synchronized void shutdown() throws InterruptedException {\n         running = false;\n     }\n \n-    public boolean isRunning(){\n+    public boolean isRunning() {\n         return bookie.isRunning() && nioServerFactory.isRunning() && running;\n     }\n \n@@ -138,8 +138,8 @@ public static void main(String[] args) throws IOException, InterruptedException\n             sb.append(ledgerDirectory[i]);\n         }\n         String hello = String.format(\n-                \"Hello, I'm your bookie, listening on port %1$s. ZKServers are on %2$s. Journals are in %3$s. Ledgers are stored in %4$s.\",\n-                port, zkServers, journalDirectory, sb);\n+                           \"Hello, I'm your bookie, listening on port %1$s. ZKServers are on %2$s. Journals are in %3$s. Ledgers are stored in %4$s.\",\n+                           port, zkServers, journalDirectory, sb);\n         LOG.info(hello);\n         BookieServer bs = new BookieServer(port, zkServers, journalDirectory, ledgerDirectory);\n         bs.start();\n@@ -254,5 +254,5 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n         }\n         src.sendResponse(new ByteBuffer[] { bb });\n     }\n-    \n+\n }"},{"sha":"29714e1ea6667ecdcfdc92ad38c7325d1a24f3b3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n package org.apache.bookkeeper.proto;\n@@ -33,7 +33,7 @@\n     /**\n      * Callback for calls from BookieClient objects. Such calls are for replies\n      * of write operations (operations to add an entry to a ledger).\n-     * \n+     *\n      */\n \n     public interface WriteCallback {\n@@ -43,12 +43,12 @@\n     public interface GenericCallback<T> {\n         void operationComplete(int rc, T result);\n     }\n-    \n+\n     /**\n      * Declaration of a callback implementation for calls from BookieClient objects.\n      * Such calls are for replies of read operations (operations to read an entry\n      * from a ledger).\n-     * \n+     *\n      */\n \n     public interface ReadEntryCallback {"},{"sha":"1a20945a3913ef9bc98e9eac12eefef0aae3645a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -45,7 +45,7 @@\n     public interface PacketProcessor {\n         public void processPacket(ByteBuffer packet, Cnxn src);\n     }\n-    \n+\n     ServerStats stats = new ServerStats();\n \n     Logger LOG = Logger.getLogger(NIOServerFactory.class);\n@@ -93,7 +93,7 @@ private void addCnxn(Cnxn cnxn) {\n     public boolean isRunning() {\n         return !ss.socket().isClosed();\n     }\n-    \n+\n     @Override\n     public void run() {\n         while (!ss.socket().isClosed()) {\n@@ -129,7 +129,7 @@ public void run() {\n \n     /**\n      * clear all the connections in the selector\n-     * \n+     *\n      */\n     synchronized public void clear() {\n         selector.wakeup();\n@@ -339,7 +339,7 @@ private void readLength(SelectionKey k) throws IOException {\n \n         /*\n          * (non-Javadoc)\n-         * \n+         *\n          * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n          */\n         public int getSessionTimeout() {\n@@ -371,7 +371,7 @@ public String toString() {\n \n         /*\n          * (non-Javadoc)\n-         * \n+         *\n          * @see org.apache.zookeeper.server.ServerCnxnIface#close()\n          */\n         public void close() {\n@@ -503,9 +503,9 @@ public String toString() {\n                 Channel channel = sk.channel();\n                 if (channel instanceof SocketChannel) {\n                     sb.append(\" \").append(((SocketChannel) channel).socket().getRemoteSocketAddress()).append(\"[\")\n-                            .append(Integer.toHexString(sk.interestOps())).append(\"](queued=\").append(\n-                                    getOutstandingRequests()).append(\",recved=\").append(getPacketsReceived()).append(\n-                                    \",sent=\").append(getPacketsSent()).append(\")\\n\");\n+                    .append(Integer.toHexString(sk.interestOps())).append(\"](queued=\").append(\n+                        getOutstandingRequests()).append(\",recved=\").append(getPacketsReceived()).append(\n+                            \",sent=\").append(getPacketsSent()).append(\")\\n\");\n                 }\n                 return sb.toString();\n             }"},{"sha":"f1ae4d9f6e33ee1a35c4725da5ff20058e966af3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":24,"deletions":24,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -57,7 +57,7 @@\n /**\n  * This class manages all details of connection to a particular bookie. It also\n  * has reconnect logic if a connection to a bookie fails.\n- * \n+ *\n  */\n \n @ChannelPipelineCoverage(\"one\")\n@@ -87,7 +87,7 @@\n     Channel channel = null;\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n-            InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n+                                  InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n         this.addr = addr;\n         this.executor = executor;\n         this.totalBytesOutstanding = totalBytesOutstanding;\n@@ -192,7 +192,7 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n     /**\n      * This method should be called only after connection has been checked for\n      * {@link #connectIfNeededAndDoOp(GenericCallback)}\n-     * \n+     *\n      * @param ledgerId\n      * @param masterKey\n      * @param entryId\n@@ -203,10 +203,10 @@ void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n      * @param ctx\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n-            Object ctx) {\n+                  Object ctx) {\n \n         final int entrySize = toSend.readableBytes();\n-        \n+\n         // if (totalBytesOutstanding.get() > maxMemory) {\n         // // TODO: how to throttle, throw an exception, or call the callback?\n         // // Maybe this should be done at the layer above?\n@@ -217,8 +217,8 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n         addCompletions.put(completionKey, new AddCompletion(cb, entrySize, ctx));\n \n         int totalHeaderSize = 4 // for the length of the packet\n-        + 4 // for the type of request\n-        + masterKey.length; // for the master key\n+                              + 4 // for the type of request\n+                              + masterKey.length; // for the master key\n \n         ChannelBuffer header = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n         header.writeInt(totalHeaderSize - 4 + entrySize);\n@@ -234,7 +234,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 if (future.isSuccess()) {\n                     if (LOG.isDebugEnabled()) {\n                         LOG.debug(\"Successfully wrote request for adding entry: \" + entryId + \" ledger-id: \" + ledgerId\n-                                + \" bookie: \" + channel.getRemoteAddress() + \" entry length: \" + entrySize);\n+                                  + \" bookie: \" + channel.getRemoteAddress() + \" entry length: \" + entrySize);\n                     }\n                     // totalBytesOutstanding.addAndGet(entrySize);\n                 } else {\n@@ -251,9 +251,9 @@ public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback\n         readCompletions.put(key, new ReadCompletion(cb, ctx));\n \n         int totalHeaderSize = 4 // for the length of the packet\n-        + 4 // for request type\n-        + 8 // for ledgerId\n-        + 8; // for entryId\n+                              + 4 // for request type\n+                              + 8 // for ledgerId\n+                              + 8; // for entryId\n \n         ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n         tmpEntry.writeInt(totalHeaderSize - 4);\n@@ -268,7 +268,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 if (future.isSuccess()) {\n                     if (LOG.isDebugEnabled()) {\n                         LOG.debug(\"Successfully wrote request for reading entry: \" + entryId + \" ledger-id: \"\n-                                + ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+                                  + ledgerId + \" bookie: \" + channel.getRemoteAddress());\n                     }\n                 } else {\n                     errorOutReadKey(key);\n@@ -293,10 +293,10 @@ public void safeRun() {\n \n                 if (readCompletion != null) {\n                     LOG.error(\"Could not write  request for reading entry: \" + key.entryId + \" ledger-id: \"\n-                            + key.ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+                              + key.ledgerId + \" bookie: \" + channel.getRemoteAddress());\n \n                     readCompletion.cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n-                            key.ledgerId, key.entryId, null, readCompletion.ctx);\n+                                                        key.ledgerId, key.entryId, null, readCompletion.ctx);\n                 }\n             }\n \n@@ -315,10 +315,10 @@ public void safeRun() {\n                     if(channel != null)\n                         bAddress = channel.getRemoteAddress().toString();\n                     LOG.error(\"Could not write request for adding entry: \" + key.entryId + \" ledger-id: \"\n-                            + key.ledgerId + \" bookie: \" + bAddress);\n+                              + key.ledgerId + \" bookie: \" + bAddress);\n \n                     addCompletion.cb.writeComplete(BKException.Code.BookieHandleNotAvailableException, key.ledgerId,\n-                            key.entryId, addr, addCompletion.ctx);\n+                                                   key.entryId, addr, addCompletion.ctx);\n                     LOG.error(\"Invoked callback method: \" + key.entryId);\n                 }\n             }\n@@ -372,7 +372,7 @@ public ChannelPipeline getPipeline() throws Exception {\n     @Override\n     public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n         LOG.info(\"Disconnected from bookie: \" + addr);\n-    \terrorOutOutstandingEntries();\n+        errorOutOutstandingEntries();\n         channel.close();\n \n         connected = false;\n@@ -448,15 +448,15 @@ public void safeRun() {\n     void handleAddResponse(long ledgerId, long entryId, int rc) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n-                    + entryId + \" rc: \" + rc);\n+                      + entryId + \" rc: \" + rc);\n         }\n \n         // convert to BKException code because thats what the uppper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n         if (rc != BookieProtocol.EOK) {\n             LOG.error(\"Add for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n-                    + \" with code: \" + rc);\n+                      + \" with code: \" + rc);\n             rc = BKException.Code.WriteException;\n         } else {\n             rc = BKException.Code.OK;\n@@ -466,7 +466,7 @@ void handleAddResponse(long ledgerId, long entryId, int rc) {\n         ac = addCompletions.remove(new CompletionKey(ledgerId, entryId));\n         if (ac == null) {\n             LOG.error(\"Unexpected add response received from bookie: \" + addr + \" for ledger: \" + ledgerId\n-                    + \", entry: \" + entryId + \" , ignoring\");\n+                      + \", entry: \" + entryId + \" , ignoring\");\n             return;\n         }\n \n@@ -479,7 +479,7 @@ void handleAddResponse(long ledgerId, long entryId, int rc) {\n     void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffer) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n-                    + entryId + \" rc: \" + rc + \"entry length: \" + buffer.readableBytes());\n+                      + entryId + \" rc: \" + rc + \"entry length: \" + buffer.readableBytes());\n         }\n \n         // convert to BKException code because thats what the uppper\n@@ -491,7 +491,7 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n             rc = BKException.Code.NoSuchEntryException;\n         } else {\n             LOG.error(\"Read for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n-                    + \" with code: \" + rc);\n+                      + \" with code: \" + rc);\n             rc = BKException.Code.ReadException;\n         }\n \n@@ -509,7 +509,7 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n \n         if (readCompletion == null) {\n             LOG.error(\"Unexpected read response recieved from bookie: \" + addr + \" for ledger: \" + ledgerId\n-                    + \", entry: \" + entryId + \" , ignoring\");\n+                      + \", entry: \" + entryId + \" , ignoring\");\n             return;\n         }\n \n@@ -518,7 +518,7 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n \n     /**\n      * Boiler-plate wrapper classes follow\n-     * \n+     *\n      */\n \n     private static class ReadCompletion {"},{"sha":"911b539291e375a4795b0d5a484d35ea5f13f7fc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n package org.apache.bookkeeper.streaming;\n \n@@ -42,7 +42,7 @@\n \n     /**\n      * construct a outputstream from a ledger handle\n-     * \n+     *\n      * @param lh\n      *            ledger handle\n      * @throws {@link BKException}, {@link InterruptedException}\n@@ -58,7 +58,7 @@ public LedgerInputStream(LedgerHandle lh) throws BKException, InterruptedExcepti\n \n     /**\n      * construct a outputstream from a ledger handle\n-     * \n+     *\n      * @param lh\n      *            the ledger handle\n      * @param size\n@@ -76,7 +76,7 @@ public LedgerInputStream(LedgerHandle lh, int size) throws BKException, Interrup\n \n     /**\n      * Method close currently doesn't do anything. The application\n-     * is supposed to open and close the ledger handle backing up \n+     * is supposed to open and close the ledger handle backing up\n      * a stream ({@link LedgerHandle}).\n      */\n     @Override\n@@ -88,7 +88,7 @@ public void close() {\n \n     /**\n      * refill the buffer, we need to read more bytes\n-     * \n+     *\n      * @return if we can refill or not\n      */\n     private synchronized boolean refill() throws IOException {"},{"sha":"bbde2fb2eca96e09e80bdd541dcd57b358506cbe","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,22 +1,22 @@\n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n package org.apache.bookkeeper.streaming;\n \n@@ -43,7 +43,7 @@\n \n     /**\n      * construct a outputstream from a ledger handle\n-     * \n+     *\n      * @param lh\n      *            ledger handle\n      */\n@@ -55,7 +55,7 @@ public LedgerOutputStream(LedgerHandle lh) {\n \n     /**\n      * construct a outputstream from a ledger handle\n-     * \n+     *\n      * @param lh\n      *            the ledger handle\n      * @param size\n@@ -97,7 +97,7 @@ public synchronized void flush() {\n \n     /**\n      * make space for len bytes to be written to the buffer.\n-     * \n+     *\n      * @param len\n      * @return if true then we can make space for len if false we cannot\n      */\n@@ -144,4 +144,4 @@ public synchronized void write(int b) throws IOException {\n         byte oneB = (byte) (b & 0xFF);\n         bytebuff.put(oneB);\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"9e5a67edb04f28b88283fe9d04941d5350347e44","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.tools;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.IOException;\n@@ -54,7 +54,7 @@\n \n /**\n  * Provides Admin Tools to manage the BookKeeper cluster.\n- * \n+ *\n  */\n public class BookKeeperTools {\n \n@@ -93,7 +93,7 @@\n      * how to connect to ZooKeeper to retrieve information about the BookKeeper\n      * cluster. We need this before we can do any type of admin operations on\n      * the BookKeeper cluster.\n-     * \n+     *\n      * @param zkServers\n      *            Comma separated list of hostname:port pairs for the ZooKeeper\n      *            servers cluster.\n@@ -123,7 +123,7 @@ public void process(WatchedEvent event) {\n \n     /**\n      * Shutdown method to gracefully release resources that this class uses.\n-     * \n+     *\n      * @throws InterruptedException\n      *             if there is an error shutting down the clients that this\n      *             class uses.\n@@ -184,7 +184,7 @@ public void processResult(int rc, String path, Object ctx) {\n      * placeholder function since there is no way we can get this information\n      * easily. In the future, BookKeeper should store this ledger metadata\n      * somewhere such that an admin tool can access it.\n-     * \n+     *\n      * @param ledgerId\n      *            LedgerId we are retrieving the digestType for.\n      * @return DigestType for the input ledger\n@@ -198,7 +198,7 @@ private DigestType getLedgerDigestType(long ledgerId) {\n      * placeholder function since there is no way we can get this information\n      * easily. In the future, BookKeeper should store this ledger metadata\n      * somewhere such that an admin tool can access it.\n-     * \n+     *\n      * @param ledgerId\n      *            LedgerId we are retrieving the password for.\n      * @return Password for the input ledger\n@@ -226,7 +226,7 @@ public SyncObject() {\n      * active set of bookies, perhaps based on load. All ZooKeeper ledger\n      * metadata will be updated to point to the new bookie(s) that contain the\n      * replicated ledger fragments.\n-     * \n+     *\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n@@ -268,7 +268,7 @@ public void recoverComplete(int rc, Object ctx) {\n      * active set of bookies, perhaps based on load. All ZooKeeper ledger\n      * metadata will be updated to point to the new bookie(s) that contain the\n      * replicated ledger fragments.\n-     * \n+     *\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n@@ -282,7 +282,7 @@ public void recoverComplete(int rc, Object ctx) {\n      *            Context for the RecoverCallback to call.\n      */\n     public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-            final RecoverCallback cb, final Object context) {\n+                                       final RecoverCallback cb, final Object context) {\n         // Sync ZK to make sure we're reading the latest bookie/ledger data.\n         zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n             @Override\n@@ -303,7 +303,7 @@ public void processResult(int rc, String path, Object ctx) {\n      * a specific destination bookie, then just use that one. Otherwise, we'll\n      * randomly pick one of the other available bookies to use for each ledger\n      * fragment we are replicating.\n-     * \n+     *\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n@@ -317,7 +317,7 @@ public void processResult(int rc, String path, Object ctx) {\n      *            Context for the RecoverCallback to call.\n      */\n     private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-            final RecoverCallback cb, final Object context) {\n+                                     final RecoverCallback cb, final Object context) {\n         final List<InetSocketAddress> availableBookies = new LinkedList<InetSocketAddress>();\n         if (bookieDest != null) {\n             availableBookies.add(bookieDest);\n@@ -329,7 +329,7 @@ private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSo\n                 public void processResult(int rc, String path, Object ctx, List<String> children) {\n                     if (rc != Code.OK.intValue()) {\n                         LOG.error(\"ZK error getting bookie nodes: \", KeeperException.create(KeeperException.Code\n-                                .get(rc), path));\n+                                  .get(rc), path));\n                         cb.recoverComplete(BKException.Code.ZKException, context);\n                         return;\n                     }\n@@ -354,7 +354,7 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      * ledgers. From this, we can open each ledger and look at the metadata to\n      * determine if any of the ledger fragments for it were stored at the dead\n      * input bookie.\n-     * \n+     *\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n@@ -373,13 +373,13 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      *            server to replicate data to.\n      */\n     private void getActiveLedgers(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n-            final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n+                                  final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n         zk.getChildren(LEDGERS_PATH, null, new AsyncCallback.ChildrenCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx, List<String> children) {\n                 if (rc != Code.OK.intValue()) {\n                     LOG.error(\"ZK error getting ledger nodes: \", KeeperException.create(KeeperException.Code.get(rc),\n-                            path));\n+                              path));\n                     cb.recoverComplete(BKException.Code.ZKException, context);\n                     return;\n                 }\n@@ -409,7 +409,7 @@ public void processResult(int rc, String path, Object ctx) {\n     /**\n      * This method asynchronously recovers a given ledger if any of the ledger\n      * entries were stored on the failed bookie.\n-     * \n+     *\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n@@ -426,7 +426,7 @@ public void processResult(int rc, String path, Object ctx) {\n      *            server to replicate data to.\n      */\n     private void recoverLedger(final InetSocketAddress bookieSrc, final String ledgerNode,\n-            final MultiCallback ledgerMcb, final List<InetSocketAddress> availableBookies) {\n+                               final MultiCallback ledgerMcb, final List<InetSocketAddress> availableBookies) {\n         /*\n          * The available node is also stored in this path so ignore that. That\n          * node is the path for the set of available Bookie Servers.\n@@ -483,7 +483,7 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                 Map<Long, Long> ledgerFragmentsRange = new HashMap<Long, Long>();\n                 Long curEntryId = null;\n                 for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n-                        .entrySet()) {\n+                .entrySet()) {\n                     if (curEntryId != null)\n                         ledgerFragmentsRange.put(curEntryId, entry.getKey() - 1);\n                     curEntryId = entry.getKey();\n@@ -529,7 +529,7 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                     public void processResult(int rc, String path, Object ctx) {\n                         if (rc != Code.OK.intValue()) {\n                             LOG.error(\"BK error replicating ledger fragments for ledger: \" + lId, BKException\n-                                    .create(rc));\n+                                      .create(rc));\n                             ledgerMcb.processResult(rc, null, null);\n                             return;\n                         }\n@@ -549,11 +549,11 @@ public void processResult(int rc, String path, Object ctx) {\n                             public void processResult(int rc, String path, Object ctx, Stat stat) {\n                                 if (rc != Code.OK.intValue()) {\n                                     LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n-                                            KeeperException.create(KeeperException.Code.get(rc), path));\n+                                              KeeperException.create(KeeperException.Code.get(rc), path));\n                                 } else {\n                                     LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId()\n-                                            + \") to point ledger fragments from old dead bookie: (\" + bookieSrc\n-                                            + \") to new bookie: (\" + newBookie + \")\");\n+                                             + \") to point ledger fragments from old dead bookie: (\" + bookieSrc\n+                                             + \") to new bookie: (\" + newBookie + \")\");\n                                 }\n                                 /*\n                                  * Pass the return code result up the chain with\n@@ -588,7 +588,7 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n      * This method asynchronously recovers a ledger fragment which is a\n      * contiguous portion of a ledger that was stored in an ensemble that\n      * included the failed bookie.\n-     * \n+     *\n      * @param bookieSrc\n      *            Source bookie that had a failure. We want to replicate the\n      *            ledger fragments that were stored there.\n@@ -606,15 +606,15 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n      *            entries that were stored on the failed bookie.\n      */\n     private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final LedgerHandle lh,\n-            final Long startEntryId, final Long endEntryId, final MultiCallback ledgerFragmentMcb,\n-            final InetSocketAddress newBookie) throws InterruptedException {\n+                                       final Long startEntryId, final Long endEntryId, final MultiCallback ledgerFragmentMcb,\n+                                       final InetSocketAddress newBookie) throws InterruptedException {\n         if (endEntryId == null) {\n             /*\n              * Ideally this should never happen if bookie failure is taken care\n              * of properly. Nothing we can do though in this case.\n              */\n             LOG.warn(\"Dead bookie (\" + bookieSrc + \") is still part of the current active ensemble for ledgerId: \"\n-                    + lh.getId());\n+                     + lh.getId());\n             ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n             return;\n         }\n@@ -655,7 +655,7 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n      * This method asynchronously recovers a specific ledger entry by reading\n      * the values via the BookKeeper Client (which would read it from the other\n      * replicas) and then writing it to the chosen new bookie.\n-     * \n+     *\n      * @param entryId\n      *            Ledger Entry ID to recover.\n      * @param lh\n@@ -668,7 +668,7 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n      *            entries that were stored on the failed bookie.\n      */\n     private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n-            final MultiCallback ledgerFragmentEntryMcb, final InetSocketAddress newBookie) throws InterruptedException {\n+                                            final MultiCallback ledgerFragmentEntryMcb, final InetSocketAddress newBookie) throws InterruptedException {\n         /*\n          * Read the ledger entry using the LedgerHandle. This will allow us to\n          * read the entry from one of the other replicated bookies other than\n@@ -689,32 +689,32 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n                 LedgerEntry entry = seq.nextElement();\n                 byte[] data = entry.getEntry();\n                 ChannelBuffer toSend = lh.getDigestManager().computeDigestAndPackageForSending(entryId,\n-                        lh.getLastAddConfirmed(), entry.getLength(), data, 0, data.length);\n+                                       lh.getLastAddConfirmed(), entry.getLength(), data, 0, data.length);\n                 bkc.getBookieClient().addEntry(newBookie, lh.getId(), lh.getLedgerKey(), entryId, toSend,\n-                        new WriteCallback() {\n-                            @Override\n-                            public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr,\n-                                    Object ctx) {\n-                                if (rc != Code.OK.intValue()) {\n-                                    LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n-                                            + entryId + \", bookie: \" + addr, BKException.create(rc));\n-                                } else {\n-                                    LOG.debug(\"Success writing ledger entry to a new bookie!\");\n-                                }\n-                                /*\n-                                 * Pass the return code result up the chain with\n-                                 * the parent callback.\n-                                 */\n-                                ledgerFragmentEntryMcb.processResult(rc, null, null);\n-                            }\n-                        }, null);\n+                new WriteCallback() {\n+                    @Override\n+                    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr,\n+                    Object ctx) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n+                                      + entryId + \", bookie: \" + addr, BKException.create(rc));\n+                        } else {\n+                            LOG.debug(\"Success writing ledger entry to a new bookie!\");\n+                        }\n+                        /*\n+                         * Pass the return code result up the chain with\n+                         * the parent callback.\n+                         */\n+                        ledgerFragmentEntryMcb.processResult(rc, null, null);\n+                    }\n+                }, null);\n             }\n         }, null);\n     }\n \n     /**\n      * Main method so we can invoke the bookie recovery via command line.\n-     * \n+     *\n      * @param args\n      *            Arguments to BookKeeperTools. 2 are required and the third is\n      *            optional. The first is a comma separated list of ZK server\n@@ -746,7 +746,7 @@ public static void main(String[] args) throws InterruptedException, IOException,\n             String bookieDestString[] = args[2].split(COLON);\n             if (bookieDestString.length < 2) {\n                 System.err.println(\"BookieDest inputted has invalid name format (host:port expected): \"\n-                        + bookieDestString);\n+                                   + bookieDestString);\n                 return;\n             }\n             bookieDest = new InetSocketAddress(bookieDestString[0], Integer.parseInt(bookieDestString[1]));"},{"sha":"4e5b1347cb7c35f3792cd01c7fae2f59d95a234b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"modified","additions":84,"deletions":84,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -44,123 +44,123 @@\n public class LocalBookKeeper {\n     protected static final Logger LOG = Logger.getLogger(LocalBookKeeper.class);\n     public static final int CONNECTION_TIMEOUT = 30000;\n-    \n+\n     ConsoleAppender ca;\n     int numberOfBookies;\n-    \n+\n     public LocalBookKeeper() {\n-\tca = new ConsoleAppender(new PatternLayout());\n-\tLOG.addAppender(ca);\n-\tLOG.setLevel(Level.INFO);\n-\tnumberOfBookies = 3;\n+        ca = new ConsoleAppender(new PatternLayout());\n+        LOG.addAppender(ca);\n+        LOG.setLevel(Level.INFO);\n+        numberOfBookies = 3;\n     }\n-    \n-    public LocalBookKeeper(int numberOfBookies){\n-\tthis();\n-\tthis.numberOfBookies = numberOfBookies;\n-\tLOG.info(\"Running \" + this.numberOfBookies + \" bookie(s).\");\n+\n+    public LocalBookKeeper(int numberOfBookies) {\n+        this();\n+        this.numberOfBookies = numberOfBookies;\n+        LOG.info(\"Running \" + this.numberOfBookies + \" bookie(s).\");\n     }\n-    \n+\n     private final String HOSTPORT = \"127.0.0.1:2181\";\n     NIOServerCnxnFactory serverFactory;\n     ZooKeeperServer zks;\n     ZooKeeper zkc;\n     int ZooKeeperDefaultPort = 2181;\n     File ZkTmpDir;\n-    \n+\n     //BookKeeper variables\n     File tmpDirs[];\n     BookieServer bs[];\n     Integer initialPort = 5000;\n-    \n+\n     /**\n      * @param args\n      */\n-\t\n-    private void runZookeeper(int maxCC) throws IOException{\n-\t// create a ZooKeeper server(dataDir, dataLogDir, port)\n-\tLOG.info(\"Starting ZK server\");\n-\t//ServerStats.registerAsConcrete();\n-\t//ClientBase.setupTestEnv();\n-\tZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n+\n+    private void runZookeeper(int maxCC) throws IOException {\n+        // create a ZooKeeper server(dataDir, dataLogDir, port)\n+        LOG.info(\"Starting ZK server\");\n+        //ServerStats.registerAsConcrete();\n+        //ClientBase.setupTestEnv();\n+        ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n         ZkTmpDir.delete();\n         ZkTmpDir.mkdir();\n-\t\t    \n-\ttry {\n-\t    zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n-\t    serverFactory =  new NIOServerCnxnFactory();\n-\t    serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), maxCC);\n-\t    serverFactory.startup(zks);\n-\t} catch (Exception e) {\n-\t    // TODO Auto-generated catch block\n-\t    LOG.fatal(\"Exception while instantiating ZooKeeper\", e);\n-\t} \n+\n+        try {\n+            zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n+            serverFactory =  new NIOServerCnxnFactory();\n+            serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), maxCC);\n+            serverFactory.startup(zks);\n+        } catch (Exception e) {\n+            // TODO Auto-generated catch block\n+            LOG.fatal(\"Exception while instantiating ZooKeeper\", e);\n+        }\n \n         boolean b = waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT);\n         LOG.debug(\"ZooKeeper server up: \" + b);\n     }\n-\t\n-    private void initializeZookeper(){\n-\tLOG.info(\"Instantiate ZK Client\");\n-\t//initialize the zk client with values\n-\ttry {\n-\t    zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n-\t    zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-\t    zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-            // No need to create an entry for each requested bookie anymore as the \n+\n+    private void initializeZookeper() {\n+        LOG.info(\"Instantiate ZK Client\");\n+        //initialize the zk client with values\n+        try {\n+            zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n+            zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            // No need to create an entry for each requested bookie anymore as the\n             // BookieServers will register themselves with ZooKeeper on startup.\n-\t} catch (KeeperException e) {\n-\t    // TODO Auto-generated catch block\n-\t    LOG.fatal(\"Exception while creating znodes\", e);\n-\t} catch (InterruptedException e) {\n-\t    // TODO Auto-generated catch block\n-\t    LOG.fatal(\"Interrupted while creating znodes\", e);\n-\t} catch (IOException e) {\n-\t    // TODO Auto-generated catch block\n-\t    LOG.fatal(\"Exception while creating znodes\", e);\n-\t}\t\t\n+        } catch (KeeperException e) {\n+            // TODO Auto-generated catch block\n+            LOG.fatal(\"Exception while creating znodes\", e);\n+        } catch (InterruptedException e) {\n+            // TODO Auto-generated catch block\n+            LOG.fatal(\"Interrupted while creating znodes\", e);\n+        } catch (IOException e) {\n+            // TODO Auto-generated catch block\n+            LOG.fatal(\"Exception while creating znodes\", e);\n+        }\n     }\n-    private void runBookies() throws IOException{\n-\tLOG.info(\"Starting Bookie(s)\");\n-\t// Create Bookie Servers (B1, B2, B3)\n-\t\t\n-\ttmpDirs = new File[numberOfBookies];\t\t\n-\tbs = new BookieServer[numberOfBookies];\n-\t\t\n-\tfor(int i = 0; i < numberOfBookies; i++){\n-\t    tmpDirs[i] = File.createTempFile(\"bookie\" + Integer.toString(i), \"test\");\n-\t    tmpDirs[i].delete();\n-\t    tmpDirs[i].mkdir();\n-\t\t\t\n-\t    bs[i] = new BookieServer(initialPort + i, InetAddress.getLocalHost().getHostAddress() + \":\"\n-\t\t\t\t     + ZooKeeperDefaultPort, tmpDirs[i], new File[]{tmpDirs[i]});\n-\t    bs[i].start();\n-\t}\t\t\n+    private void runBookies() throws IOException {\n+        LOG.info(\"Starting Bookie(s)\");\n+        // Create Bookie Servers (B1, B2, B3)\n+\n+        tmpDirs = new File[numberOfBookies];\n+        bs = new BookieServer[numberOfBookies];\n+\n+        for(int i = 0; i < numberOfBookies; i++) {\n+            tmpDirs[i] = File.createTempFile(\"bookie\" + Integer.toString(i), \"test\");\n+            tmpDirs[i].delete();\n+            tmpDirs[i].mkdir();\n+\n+            bs[i] = new BookieServer(initialPort + i, InetAddress.getLocalHost().getHostAddress() + \":\"\n+                                     + ZooKeeperDefaultPort, tmpDirs[i], new File[] {tmpDirs[i]});\n+            bs[i].start();\n+        }\n     }\n-\t\n+\n     public static void main(String[] args) throws IOException, InterruptedException {\n-\tif(args.length < 1){\n-\t    usage();\n-\t    System.exit(-1);\n-\t}\n-\tLocalBookKeeper lb = new LocalBookKeeper(Integer.parseInt(args[0]));\n-\tlb.runZookeeper(1000);\n-\tlb.initializeZookeper();\n-\tlb.runBookies();\n-\twhile (true){\n-\t    Thread.sleep(5000);\n-\t}\n+        if(args.length < 1) {\n+            usage();\n+            System.exit(-1);\n+        }\n+        LocalBookKeeper lb = new LocalBookKeeper(Integer.parseInt(args[0]));\n+        lb.runZookeeper(1000);\n+        lb.initializeZookeper();\n+        lb.runBookies();\n+        while (true) {\n+            Thread.sleep(5000);\n+        }\n     }\n \n     private static void usage() {\n-\tSystem.err.println(\"Usage: LocalBookKeeper number-of-bookies\");\t\n+        System.err.println(\"Usage: LocalBookKeeper number-of-bookies\");\n     }\n \n     /*\tUser for testing purposes, void */\n-    class emptyWatcher implements Watcher{\n-\tpublic void process(WatchedEvent event) {}\n+    class emptyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {}\n     }\n-\t\n+\n     public static boolean waitForServerUp(String hp, long timeout) {\n         long start = System.currentTimeMillis();\n         String split[] = hp.split(\":\");\n@@ -177,7 +177,7 @@ public static boolean waitForServerUp(String hp, long timeout) {\n \n                     reader =\n                         new BufferedReader(\n-\t\t\t\t\t   new InputStreamReader(sock.getInputStream()));\n+                        new InputStreamReader(sock.getInputStream()));\n                     String line = reader.readLine();\n                     if (line != null && line.startsWith(\"Zookeeper version:\")) {\n                         LOG.info(\"Server UP\");\n@@ -205,5 +205,5 @@ public static boolean waitForServerUp(String hp, long timeout) {\n         }\n         return false;\n     }\n-\t\n+\n }"},{"sha":"928c5f0d3724c8bb743eeb0d28e751d889c5b7a5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Main.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.util;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.IOException;"},{"sha":"dfd7c28483340f28c7fd7984d052f6bdc506ee3d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,15 +24,15 @@\n  */\n public class MathUtils {\n \n-    public static int signSafeMod(long dividend, int divisor){\n+    public static int signSafeMod(long dividend, int divisor) {\n         int mod = (int) (dividend % divisor);\n-        \n-        if (mod < 0){\n+\n+        if (mod < 0) {\n             mod += divisor;\n         }\n-        \n+\n         return mod;\n-        \n+\n     }\n \n }"},{"sha":"1acafaf2248bcbe5f11db0d254d5db13bd7d2b6d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -25,18 +25,18 @@\n \n /**\n  * This class provides 2 things over the java {@link ScheduledExecutorService}.\n- * \n+ *\n  * 1. It takes {@link SafeRunnable objects} instead of plain Runnable objects.\n  * This means that exceptions in scheduled tasks wont go unnoticed and will be\n  * logged.\n- * \n+ *\n  * 2. It supports submitting tasks with an ordering key, so that tasks submitted\n  * with the same key will always be executed in order, but tasks across\n  * different keys can be unordered. This retains parallelism while retaining the\n  * basic amount of ordering we want (e.g. , per ledger handle). Ordering is\n  * achieved by hashing the key objects to threads by their {@link #hashCode()}\n  * method.\n- * \n+ *\n  */\n public class OrderedSafeExecutor {\n     ExecutorService threads[];\n@@ -74,7 +74,7 @@ ExecutorService chooseThread(Object orderingKey) {\n     }\n \n     /**\n-     * schedules a one time action to execute \n+     * schedules a one time action to execute\n      */\n     public void submit(SafeRunnable r) {\n         chooseThread().submit(r);"},{"sha":"b8284b84d6580ddb6254713e6c3c4def07b18d4a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -20,19 +20,19 @@\n \n import org.apache.log4j.Logger;\n \n-public abstract class SafeRunnable implements Runnable{\n+public abstract class SafeRunnable implements Runnable {\n \n     static final Logger logger = Logger.getLogger(SafeRunnable.class);\n-    \n-@Override\n+\n+    @Override\n     public void run() {\n-        try{\n+        try {\n             safeRun();\n-        }catch(Throwable t){\n+        } catch(Throwable t) {\n             logger.fatal(\"Unexpected throwable caught \", t);\n         }\n     }\n-    \n+\n     public abstract void safeRun();\n-    \n+\n }"},{"sha":"bd0ce7b7840eabcf19444189f86a7512e71b7ff7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,7 +24,7 @@\n /**\n  * Provided utilites for parsing network addresses, ledger-id from node paths\n  * etc.\n- * \n+ *\n  */\n public class StringUtils {\n \n@@ -35,7 +35,7 @@\n \n     /**\n      * Parses address into IP and port.\n-     * \n+     *\n      * @param addr\n      *            String\n      */\n@@ -63,7 +63,7 @@ public static StringBuilder addrToString(StringBuilder sb, InetSocketAddress add\n \n     /**\n      * Formats ledger ID according to ZooKeeper rules\n-     * \n+     *\n      * @param id\n      *            znode id\n      */\n@@ -73,7 +73,7 @@ public static String getZKStringId(long id) {\n \n     /**\n      * Get the path for the ledger metadata node\n-     * \n+     *\n      * @return\n      */\n     public static String getLedgerNodePath(long ledgerId) {"},{"sha":"073f2413fc28a47fe552a1ebb58b6cc479abe8de","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.IOException;\n@@ -47,25 +47,25 @@\n  * This test tests read and write, synchronous and asynchronous, strings and\n  * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n  * and three BookKeepers.\n- * \n+ *\n  */\n public class AsyncLedgerOpsTest extends BaseTestCase implements AddCallback, ReadCallback, CreateCallback,\n-        CloseCallback, OpenCallback {\n+    CloseCallback, OpenCallback {\n     static Logger LOG = Logger.getLogger(BookieClientTest.class);\n \n     DigestType digestType;\n-    \n+\n     public AsyncLedgerOpsTest(DigestType digestType) {\n         super(3);\n         this.digestType = digestType;\n     }\n-    \n+\n     @Parameters\n-    public static Collection<Object[]> configs(){\n-        return Arrays.asList(new Object[][]{ {DigestType.MAC }, {DigestType.CRC32}});\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] { {DigestType.MAC }, {DigestType.CRC32}});\n     }\n-    \n- \n+\n+\n     byte[] ledgerPassword = \"aaa\".getBytes();\n     LedgerHandle lh, lh2;\n     long ledgerId;\n@@ -107,7 +107,7 @@ LedgerHandle getLh() {\n     @Test\n     public void testAsyncCreateClose() throws IOException {\n         try {\n-            \n+\n             ControlObj ctx = new ControlObj();\n \n             synchronized (ctx) {\n@@ -243,14 +243,14 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n     public void setUp() throws Exception {\n         super.setUp();\n         rng = new Random(System.currentTimeMillis()); // Initialize the Random\n-                                                      // Number Generator\n+        // Number Generator\n         entries = new ArrayList<byte[]>(); // initialize the entries list\n         entriesSize = new ArrayList<Integer>();\n         sync = new SyncObj(); // initialize the synchronization data structure\n     }\n \n-    \n \n \n \n-}\n\\ No newline at end of file\n+\n+}"},{"sha":"224c7963e95c41ba750e3724cdc85d05aec438d5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -69,55 +69,55 @@\n     public BaseTestCase(int numBookies) {\n         this.numBookies = numBookies;\n     }\n-    \n+\n     @Parameters\n-    public static Collection<Object[]> configs(){\n-        return Arrays.asList(new Object[][]{ {DigestType.MAC }, {DigestType.CRC32}});\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] { {DigestType.MAC }, {DigestType.CRC32}});\n     }\n \n \n     @Before\n     @Override\n     public void setUp() throws Exception {\n         try {\n-        // create a ZooKeeper server(dataDir, dataLogDir, port)\n-        LOG.debug(\"Running ZK server\");\n-        // ServerStats.registerAsConcrete();\n-        ClientBase.setupTestEnv();\n-        ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n-        ZkTmpDir.delete();\n-        ZkTmpDir.mkdir();\n-\n-        zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n-        serverFactory = new NIOServerCnxnFactory();\n-        serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), 100);\n-        serverFactory.startup(zks);\n-\n-        boolean b = ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT);\n-\n-        LOG.debug(\"Server up: \" + b);\n-\n-        // create a zookeeper client\n-        LOG.debug(\"Instantiate ZK Client\");\n-        zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n-\n-        // initialize the zk client with values\n-        zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-\n-        // Create Bookie Servers (B1, B2, B3)\n-        for (int i = 0; i < numBookies; i++) {\n-            File f = File.createTempFile(\"bookie\", \"test\");\n-            tmpDirs.add(f);\n-            f.delete();\n-            f.mkdir();\n-\n-            BookieServer server = new BookieServer(initialPort + i, HOSTPORT, f, new File[] { f });\n-            server.start();\n-            bs.add(server);\n-        }\n-        zkc.close();\n-        bkc = new BookKeeperTestClient(\"127.0.0.1\");\n+            // create a ZooKeeper server(dataDir, dataLogDir, port)\n+            LOG.debug(\"Running ZK server\");\n+            // ServerStats.registerAsConcrete();\n+            ClientBase.setupTestEnv();\n+            ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n+            ZkTmpDir.delete();\n+            ZkTmpDir.mkdir();\n+\n+            zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n+            serverFactory = new NIOServerCnxnFactory();\n+            serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), 100);\n+            serverFactory.startup(zks);\n+\n+            boolean b = ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT);\n+\n+            LOG.debug(\"Server up: \" + b);\n+\n+            // create a zookeeper client\n+            LOG.debug(\"Instantiate ZK Client\");\n+            zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n+\n+            // initialize the zk client with values\n+            zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+            // Create Bookie Servers (B1, B2, B3)\n+            for (int i = 0; i < numBookies; i++) {\n+                File f = File.createTempFile(\"bookie\", \"test\");\n+                tmpDirs.add(f);\n+                f.delete();\n+                f.mkdir();\n+\n+                BookieServer server = new BookieServer(initialPort + i, HOSTPORT, f, new File[] { f });\n+                server.start();\n+                bs.add(server);\n+            }\n+            zkc.close();\n+            bkc = new BookKeeperTestClient(\"127.0.0.1\");\n         } catch(Exception e) {\n             LOG.error(\"Error setting up\", e);\n             throw e;\n@@ -132,7 +132,7 @@ public void tearDown() throws Exception {\n         if (bkc != null) {\n             bkc.halt();;\n         }\n-        \n+\n         for (BookieServer server : bs) {\n             server.shutdown();\n         }\n@@ -148,7 +148,7 @@ public void tearDown() throws Exception {\n         }\n         // ServerStats.unregister();\n         cleanUpDir(ZkTmpDir);\n-        \n+\n \n     }\n "},{"sha":"4cfaf30755a7599e7fe88a3dfa029deb9e479cd4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.File;"},{"sha":"82483f34aead863970ed5d3455fdd65c3c0566c7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"modified","additions":24,"deletions":24,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.File;\n@@ -48,7 +48,7 @@\n  * This test tests read and write, synchronous and asynchronous, strings and\n  * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n  * and three BookKeepers.\n- * \n+ *\n  */\n \n public class BookieFailureTest extends BaseTestCase implements AddCallback, ReadCallback {\n@@ -70,7 +70,7 @@\n     ArrayList<byte[]> entries; // generated entries\n     ArrayList<Integer> entriesSize;\n     DigestType digestType;\n-    \n+\n     // Synchronization\n     SyncObj sync;\n     Set<Object> syncObjs;\n@@ -87,20 +87,20 @@ public SyncObj() {\n \n     public BookieFailureTest(DigestType digestType) {\n         super(4);\n-        this.digestType = digestType;        \n+        this.digestType = digestType;\n     }\n-    \n+\n     /**\n      * Tests writes and reads when a bookie fails.\n-     * \n+     *\n      * @throws {@link IOException}\n      */\n     @Test\n     public void testAsyncBK1() throws IOException {\n         LOG.info(\"#### BK1 ####\");\n         auxTestReadWriteAsyncSingleClient(bs.get(0));\n     }\n-    \n+\n     @Test\n     public void testAsyncBK2() throws IOException {\n         LOG.info(\"#### BK2 ####\");\n@@ -118,39 +118,39 @@ public void testAsyncBK4() throws IOException {\n         LOG.info(\"#### BK4 ####\");\n         auxTestReadWriteAsyncSingleClient(bs.get(3));\n     }\n-    \n+\n     @Test\n-    public void testBookieRecovery() throws Exception{\n+    public void testBookieRecovery() throws Exception {\n         //Shutdown all but 1 bookie\n         bs.get(0).shutdown();\n         bs.get(1).shutdown();\n         bs.get(2).shutdown();\n-        \n+\n         byte[] passwd = \"blah\".getBytes();\n         LedgerHandle lh = bkc.createLedger(1, 1,digestType, passwd);\n-        \n+\n         int numEntries = 100;\n-        for (int i=0; i< numEntries; i++){\n+        for (int i=0; i< numEntries; i++) {\n             byte[] data = (\"\"+i).getBytes();\n             lh.addEntry(data);\n         }\n-        \n+\n         bs.get(3).shutdown();\n         BookieServer server = new BookieServer(initialPort + 3, HOSTPORT, tmpDirs.get(3), new File[] { tmpDirs.get(3)});\n         server.start();\n         bs.set(3, server);\n \n         assertEquals(numEntries - 1 , lh.getLastAddConfirmed());\n         Enumeration<LedgerEntry> entries = lh.readEntries(0, lh.getLastAddConfirmed());\n-        \n+\n         int numScanned = 0;\n-        while (entries.hasMoreElements()){\n+        while (entries.hasMoreElements()) {\n             assertEquals((\"\"+numScanned), new String(entries.nextElement().getEntry()));\n             numScanned++;\n         }\n         assertEquals(numEntries, numScanned);\n-        \n-        \n+\n+\n     }\n \n     void auxTestReadWriteAsyncSingleClient(BookieServer bs) throws IOException {\n@@ -168,9 +168,9 @@ void auxTestReadWriteAsyncSingleClient(BookieServer bs) throws IOException {\n                 entries.add(entry.array());\n                 entriesSize.add(entry.array().length);\n                 lh.asyncAddEntry(entry.array(), this, sync);\n-                \n+\n             }\n-            \n+\n             LOG.info(\"Wrote \" + numEntriesToWrite + \" and now going to fail bookie.\");\n             // Bookie fail\n             bs.shutdown();\n@@ -269,7 +269,7 @@ public void setUp() throws Exception {\n         super.setUp();\n \n         rng = new Random(System.currentTimeMillis()); // Initialize the Random\n-                                                      // Number Generator\n+        // Number Generator\n         entries = new ArrayList<byte[]>(); // initialize the entries list\n         entriesSize = new ArrayList<Integer>();\n         sync = new SyncObj(); // initialize the synchronization data structure\n@@ -300,4 +300,4 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"56331efe04313352e48dd3816d122d9f088c325e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":89,"deletions":89,"changes":178,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.File;\n@@ -57,11 +57,11 @@\n  * This test tests read and write, synchronous and asynchronous, strings and\n  * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n  * and three BookKeepers.\n- * \n+ *\n  */\n \n-public class BookieReadWriteTest extends BaseTestCase \n-implements AddCallback, ReadCallback, ReadLastConfirmedCallback {\n+public class BookieReadWriteTest extends BaseTestCase\n+    implements AddCallback, ReadCallback, ReadLastConfirmedCallback {\n \n     // Depending on the taste, select the amount of logging\n     // by decommenting one of the two lines below\n@@ -79,10 +79,10 @@\n     Random rng; // Random Number Generator\n     ArrayList<byte[]> entries; // generated entries\n     ArrayList<Integer> entriesSize;\n-    \n+\n     DigestType digestType;\n-    \n-    public BookieReadWriteTest(DigestType digestType){\n+\n+    public BookieReadWriteTest(DigestType digestType) {\n         super(3);\n         this.digestType = digestType;\n     }\n@@ -114,7 +114,7 @@ public void testOpenException() throws KeeperException, IOException, Interrupted\n \n     /**\n      * test the streaming api for reading and writing\n-     * \n+     *\n      * @throws {@link IOException}, {@link KeeperException}\n      */\n     @Test\n@@ -259,7 +259,7 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n             byte bytes[] = {'a','b','c','d','e','f','g','h','i'};\n-            \n+\n             lh.asyncAddEntry(bytes, 0, bytes.length, this, sync);\n             lh.asyncAddEntry(bytes, 0, 4, this, sync); // abcd\n             lh.asyncAddEntry(bytes, 3, 4, this, sync); // defg\n@@ -275,37 +275,37 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n             }\n \n             try {\n-                lh.asyncAddEntry(bytes, -1, bytes.length, this, sync); \n+                lh.asyncAddEntry(bytes, -1, bytes.length, this, sync);\n                 fail(\"Shouldn't be able to use negative offset\");\n             } catch (ArrayIndexOutOfBoundsException aiob) {\n                 // expected\n             }\n             try {\n-                lh.asyncAddEntry(bytes, 0, bytes.length+1, this, sync); \n+                lh.asyncAddEntry(bytes, 0, bytes.length+1, this, sync);\n                 fail(\"Shouldn't be able to use that much length\");\n             } catch (ArrayIndexOutOfBoundsException aiob) {\n                 // expected\n             }\n             try {\n-                lh.asyncAddEntry(bytes, -1, bytes.length+2, this, sync); \n+                lh.asyncAddEntry(bytes, -1, bytes.length+2, this, sync);\n                 fail(\"Shouldn't be able to use negative offset \"\n                      + \"with that much length\");\n             } catch (ArrayIndexOutOfBoundsException aiob) {\n                 // expected\n             }\n             try {\n-                lh.asyncAddEntry(bytes, 4, -3, this, sync); \n+                lh.asyncAddEntry(bytes, 4, -3, this, sync);\n                 fail(\"Shouldn't be able to use negative length\");\n             } catch (ArrayIndexOutOfBoundsException aiob) {\n                 // expected\n             }\n             try {\n-                lh.asyncAddEntry(bytes, -4, -3, this, sync); \n+                lh.asyncAddEntry(bytes, -4, -3, this, sync);\n                 fail(\"Shouldn't be able to use negative offset & length\");\n             } catch (ArrayIndexOutOfBoundsException aiob) {\n                 // expected\n             }\n-            \n+\n \n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n@@ -316,7 +316,7 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n             // open ledger\n             lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n             LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n-            assertTrue(\"Verifying number of entries written\", \n+            assertTrue(\"Verifying number of entries written\",\n                        lh.getLastAddConfirmed() == (numEntries - 1));\n \n             // read entries\n@@ -336,26 +336,26 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n             while (ls.hasMoreElements()) {\n                 byte[] expected = null;\n                 byte[] entry = ls.nextElement().getEntry();\n-                \n+\n                 switch (i) {\n-                case 0: \n+                case 0:\n                     expected = Arrays.copyOfRange(bytes, 0, bytes.length);\n                     break;\n-                case 1: \n+                case 1:\n                     expected = Arrays.copyOfRange(bytes, 0, 4);\n                     break;\n-                case 2: \n+                case 2:\n                     expected = Arrays.copyOfRange(bytes, 3, 3+4);\n                     break;\n-                case 3: \n+                case 3:\n                     expected = Arrays.copyOfRange(bytes, 3, 3+(bytes.length-3));\n                     break;\n                 }\n                 assertNotNull(\"There are more checks than writes\", expected);\n-                \n+\n                 String message = \"Checking entry \" + i + \" for equality [\"\n-                    + new String(entry, \"UTF-8\") + \",\" \n-                    + new String(expected, \"UTF-8\") + \"]\";\n+                                 + new String(entry, \"UTF-8\") + \",\"\n+                                 + new String(expected, \"UTF-8\") + \"]\";\n                 assertTrue(message, Arrays.equals(entry, expected));\n \n                 i++;\n@@ -377,47 +377,47 @@ public void testReadWriteRangeAsyncSingleClient() throws IOException {\n \n     class ThrottleTestCallback implements ReadCallback {\n         int throttle;\n-        \n-        ThrottleTestCallback(int threshold){\n+\n+        ThrottleTestCallback(int threshold) {\n             this.throttle = threshold;\n         }\n-        \n-        public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx){\n-            if(rc != BKException.Code.OK){\n+\n+        public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+            if(rc != BKException.Code.OK) {\n                 fail(\"Return code is not OK: \" + rc);\n             }\n-        \n+\n             ls = seq;\n-            synchronized(sync){\n+            synchronized(sync) {\n                 sync.counter += throttle;\n                 sync.notify();\n             }\n             LOG.info(\"Current counter: \" + sync.counter);\n         }\n     }\n-    \n+\n     /**\n      * Method for obtaining the available permits of a ledger handle\n      * using reflection to avoid adding a new public method to the\n      * class.\n-     *   \n+     *\n      * @param lh\n      * @return\n      */\n     @SuppressWarnings(\"unchecked\")\n     int getAvailablePermits(LedgerHandle lh) throws\n-    NoSuchFieldException, IllegalAccessException\n-    { \n-        Field field = LedgerHandle.class.getDeclaredField(\"opCounterSem\"); \n-        field.setAccessible(true); \n-        return ((Semaphore)field.get(lh)).availablePermits(); \n+        NoSuchFieldException, IllegalAccessException\n+    {\n+        Field field = LedgerHandle.class.getDeclaredField(\"opCounterSem\");\n+        field.setAccessible(true);\n+        return ((Semaphore)field.get(lh)).availablePermits();\n     }\n-    \n+\n     @Test\n-    public void testReadWriteAsyncSingleClientThrottle() throws \n-    IOException, NoSuchFieldException, IllegalAccessException {\n+    public void testReadWriteAsyncSingleClientThrottle() throws\n+        IOException, NoSuchFieldException, IllegalAccessException {\n         try {\n-                       \n+\n             Integer throttle = 100;\n             ThrottleTestCallback tcb = new ThrottleTestCallback(throttle);\n             // Create a ledger\n@@ -426,8 +426,8 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n             // bkc.initMessageDigest(\"SHA1\");\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n-            \n-            numEntriesToWrite = 8000; \n+\n+            numEntriesToWrite = 8000;\n             for (int i = 0; i < (numEntriesToWrite - 2000); i++) {\n                 ByteBuffer entry = ByteBuffer.allocate(4);\n                 entry.putInt(rng.nextInt(maxInt));\n@@ -442,7 +442,7 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n                 int testValue = getAvailablePermits(lh);\n                 assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n             }\n-            \n+\n \n             for (int i = 0; i < 2000; i++) {\n                 ByteBuffer entry = ByteBuffer.allocate(4);\n@@ -452,14 +452,14 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n                 entries.add(entry.array());\n                 entriesSize.add(entry.array().length);\n                 lh.asyncAddEntry(entry.array(), this, sync);\n-                \n+\n                 /*\n                  * Check that the difference is no larger than the throttling threshold\n                  */\n                 int testValue = getAvailablePermits(lh);\n                 assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n             }\n-            \n+\n             // wait for all entries to be acknowledged\n             synchronized (sync) {\n                 while (sync.counter < numEntriesToWrite) {\n@@ -473,7 +473,7 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n             lh.close();\n \n             // *** WRITING PART COMPLETE // READ PART BEGINS ***\n-            \n+\n             // open ledger\n             lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n             LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n@@ -486,7 +486,7 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n                 int testValue = getAvailablePermits(lh);\n                 assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n             }\n-            \n+\n             synchronized (sync) {\n                 while (sync.counter < numEntriesToWrite) {\n                     LOG.info(\"Entries counter = \" + sync.counter);\n@@ -508,7 +508,7 @@ public void testReadWriteAsyncSingleClientThrottle() throws\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n+\n     @Test\n     public void testSyncReadAsyncWriteStringsSingleClient() throws IOException {\n         LOG.info(\"TEST READ WRITE STRINGS MIXED SINGLE CLIENT\");\n@@ -703,9 +703,9 @@ public void testMultiLedger() throws IOException {\n \n             LOG.debug(\"Number of entries written: \" + lh.getLastAddConfirmed() + \", \" + lh2.getLastAddConfirmed());\n             assertTrue(\"Verifying number of entries written lh (\" + lh.getLastAddConfirmed() + \")\", lh\n-                    .getLastAddConfirmed() == (numEntriesToWrite - 1));\n+                       .getLastAddConfirmed() == (numEntriesToWrite - 1));\n             assertTrue(\"Verifying number of entries written lh2 (\" + lh2.getLastAddConfirmed() + \")\", lh2\n-                    .getLastAddConfirmed() == (numEntriesToWrite - 1));\n+                       .getLastAddConfirmed() == (numEntriesToWrite - 1));\n \n             ls = lh.readEntries(0, numEntriesToWrite - 1);\n             int i = 0;\n@@ -764,7 +764,7 @@ public void testReadWriteAsyncLength() throws IOException {\n             }\n             long length = numEntriesToWrite * 4;\n             assertTrue(\"Ledger length before closing: \" + lh.getLength(), lh.getLength() == length);\n-            \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n@@ -788,29 +788,29 @@ public void testReadWriteAsyncLength() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n+\n     @Test\n     public void testShutdown() throws IOException {\n         try {\n             int numLedgers = 10000;\n             Long throttle = (((Double) Math.max(1.0, ((double) 10000/numLedgers))).longValue());\n             System.setProperty(\"throttle\", throttle.toString());\n             LedgerHandle[] lhArray = new LedgerHandle[numLedgers];\n-            for(int i = 0; i < numLedgers; i++){\n+            for(int i = 0; i < numLedgers; i++) {\n                 lhArray[i] = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32, new byte[] {'a', 'b'});\n                 LOG.debug(\"Ledger handle: \" + lhArray[i].getId());\n             }\n             LOG.info(\"Done creating ledgers.\");\n             Random r = new Random();\n-            \n+\n             for (int i = 0; i < numEntriesToWrite; i++) {\n                 ByteBuffer entry = ByteBuffer.allocate(4);\n                 entry.putInt(rng.nextInt(maxInt));\n                 entry.position(0);\n \n                 entries.add(entry.array());\n                 entriesSize.add(entry.array().length);\n-                \n+\n                 int nextLh = r.nextInt(numLedgers);\n                 lhArray[nextLh].asyncAddEntry(entry.array(), this, sync);\n             }\n@@ -822,10 +822,10 @@ public void testShutdown() throws IOException {\n                     sync.wait();\n                 }\n             }\n-            \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n-            for(int i = 0; i < lhArray.length; i++){\n+            for(int i = 0; i < lhArray.length; i++) {\n                 lhArray[i].close();\n             }\n         } catch (KeeperException e) {\n@@ -839,7 +839,7 @@ public void testShutdown() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n+\n     public void testReadFromOpenLedger() throws IOException {\n         try {\n             // Create a ledger\n@@ -855,7 +855,7 @@ public void testReadFromOpenLedger() throws IOException {\n                 entries.add(entry.array());\n                 entriesSize.add(entry.array().length);\n                 lh.addEntry(entry.array());\n-                if(i == numEntriesToWrite/2){\n+                if(i == numEntriesToWrite/2) {\n                     LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n                     Enumeration<LedgerEntry> readEntry = lh.readEntries(i, i);\n                     assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n@@ -864,7 +864,7 @@ public void testReadFromOpenLedger() throws IOException {\n \n             long last = lh.readLastConfirmed();\n             assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n-            \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n@@ -885,24 +885,24 @@ public void testReadFromOpenLedger() throws IOException {\n                 lh.addEntry(entry.array());\n             }\n \n-            \n+\n             SyncObj sync = new SyncObj();\n             lh.asyncReadLastConfirmed(this, sync);\n-            \n+\n             // Wait for for last confirmed\n             synchronized (sync) {\n                 while (sync.lastConfirmed == -1) {\n                     LOG.debug(\"Counter = \" + sync.lastConfirmed);\n                     sync.wait();\n                 }\n             }\n-            \n+\n             assertTrue(\"Last confirmed add: \" + sync.lastConfirmed, sync.lastConfirmed == (numEntriesToWrite - 2));\n-            \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n-            \n+\n \n         } catch (KeeperException e) {\n             LOG.error(\"Test failed\", e);\n@@ -915,8 +915,8 @@ public void testReadFromOpenLedger() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n-    \n+\n+\n     @Test\n     public void testLastConfirmedAdd() throws IOException {\n         try {\n@@ -937,7 +937,7 @@ public void testLastConfirmedAdd() throws IOException {\n \n             long last = lh.readLastConfirmed();\n             assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n-            \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n@@ -958,24 +958,24 @@ public void testLastConfirmedAdd() throws IOException {\n                 lh.addEntry(entry.array());\n             }\n \n-            \n+\n             SyncObj sync = new SyncObj();\n             lh.asyncReadLastConfirmed(this, sync);\n-            \n+\n             // Wait for for last confirmed\n             synchronized (sync) {\n                 while (sync.lastConfirmed == -1) {\n                     LOG.debug(\"Counter = \" + sync.lastConfirmed);\n                     sync.wait();\n                 }\n             }\n-            \n+\n             assertTrue(\"Last confirmed add: \" + sync.lastConfirmed, sync.lastConfirmed == (numEntriesToWrite - 2));\n-            \n+\n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n             lh.close();\n-            \n+\n \n         } catch (KeeperException e) {\n             LOG.error(\"Test failed\", e);\n@@ -988,13 +988,13 @@ public void testLastConfirmedAdd() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n-    \n-    \n+\n+\n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n-        \n+\n         SyncObj x = (SyncObj) ctx;\n-        \n+\n         synchronized (x) {\n             x.counter++;\n             x.notify();\n@@ -1003,7 +1003,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n \n     public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n         if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n-        \n+\n         ls = seq;\n \n         synchronized (sync) {\n@@ -1014,22 +1014,22 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n \n     public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n         SyncObj sync = (SyncObj) ctx;\n-        \n-        synchronized(sync){\n+\n+        synchronized(sync) {\n             sync.lastConfirmed = lastConfirmed;\n             sync.notify();\n         }\n     }\n-    \n+\n     @Before\n-    public void setUp() throws Exception{\n+    public void setUp() throws Exception {\n         super.setUp();\n         rng = new Random(System.currentTimeMillis()); // Initialize the Random\n-                                                      // Number Generator\n+        // Number Generator\n         entries = new ArrayList<byte[]>(); // initialize the entries list\n         entriesSize = new ArrayList<Integer>();\n         sync = new SyncObj(); // initialize the synchronization data structure\n-        \n+\n     }\n \n     /* Clean up a directory recursively */"},{"sha":"f933ba1137b883351c07e6129a7aa66e2125f0df","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.File;\n@@ -109,7 +109,7 @@ public void tearDown() throws Exception {\n \n     /**\n      * Helper method to create a number of ledgers\n-     * \n+     *\n      * @param numLedgers\n      *            Number of ledgers to create\n      * @return List of LedgerHandles for each of the ledgers created\n@@ -119,7 +119,7 @@ public void tearDown() throws Exception {\n      * @throws InterruptedException\n      */\n     private List<LedgerHandle> createLedgers(int numLedgers) throws BKException, KeeperException, IOException,\n-            InterruptedException {\n+        InterruptedException {\n         List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n         for (int i = 0; i < numLedgers; i++) {\n             lhs.add(bkc.createLedger(digestType, System.getProperty(\"passwd\").getBytes()));\n@@ -129,7 +129,7 @@ public void tearDown() throws Exception {\n \n     /**\n      * Helper method to write dummy ledger entries to all of the ledgers passed.\n-     * \n+     *\n      * @param numEntries\n      *            Number of ledger entries to write for each ledger\n      * @param startEntryId\n@@ -140,7 +140,7 @@ public void tearDown() throws Exception {\n      * @throws InterruptedException\n      */\n     private void writeEntriestoLedgers(int numEntries, long startEntryId, List<LedgerHandle> lhs) throws BKException,\n-            InterruptedException {\n+        InterruptedException {\n         for (LedgerHandle lh : lhs) {\n             for (int i = 0; i < numEntries; i++) {\n                 lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (startEntryId + i)).getBytes());\n@@ -151,33 +151,33 @@ private void writeEntriestoLedgers(int numEntries, long startEntryId, List<Ledge\n     /**\n      * Helper method to startup a new bookie server with the indicated port\n      * number\n-     * \n+     *\n      * @param port\n      *            Port to start the new bookie server on\n      * @throws IOException\n      */\n     private void startNewBookie(int port)\n-    throws IOException, InterruptedException, KeeperException {\n+            throws IOException, InterruptedException, KeeperException {\n         File f = File.createTempFile(\"bookie\", \"test\");\n         tmpDirs.add(f);\n         f.delete();\n         f.mkdir();\n-        \n+\n         BookieServer server = new BookieServer(port, HOSTPORT, f, new File[] { f });\n         server.start();\n         bs.add(server);\n-        \n-        while(bkc.getZkHandle().exists(\"/ledgers/available/\" + InetAddress.getLocalHost().getHostAddress() + \":\" + port, false) == null){\n+\n+        while(bkc.getZkHandle().exists(\"/ledgers/available/\" + InetAddress.getLocalHost().getHostAddress() + \":\" + port, false) == null) {\n             Thread.sleep(500);\n         }\n-        \n+\n         bkc.readBookiesBlocking();\n         LOG.info(\"New bookie on port \" + port + \" has been created.\");\n     }\n-    \n+\n     /**\n      * Helper method to verify that we can read the recovered ledger entries.\n-     * \n+     *\n      * @param numLedgers\n      *            Number of ledgers to verify\n      * @param startEntryId\n@@ -188,7 +188,7 @@ private void startNewBookie(int port)\n      * @throws InterruptedException\n      */\n     private void verifyRecoveredLedgers(int numLedgers, long startEntryId, long endEntryId) throws BKException,\n-            InterruptedException {\n+        InterruptedException {\n         // Get a set of LedgerHandles for all of the ledgers to verify\n         List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n         for (int i = 0; i < numLedgers; i++) {\n@@ -201,7 +201,7 @@ private void verifyRecoveredLedgers(int numLedgers, long startEntryId, long endE\n             while (entries.hasMoreElements()) {\n                 LedgerEntry entry = entries.nextElement();\n                 assertTrue(new String(entry.getEntry()).equals(\"LedgerId: \" + entry.getLedgerId() + \", EntryId: \"\n-                        + entry.getEntryId()));\n+                           + entry.getEntryId()));\n             }\n         }\n \n@@ -213,7 +213,7 @@ private void verifyRecoveredLedgers(int numLedgers, long startEntryId, long endE\n      * replace it, and then recovering the ledger entries from the killed bookie\n      * onto the new one. We'll verify that the entries stored on the killed\n      * bookie are properly copied over and restored onto the new one.\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -243,7 +243,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n         InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n         InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n-                + bookieDest + \")\");\n+                 + bookieDest + \")\");\n         // Initiate the sync object\n         sync.value = false;\n         bkTools.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n@@ -266,7 +266,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n      * onto random available bookie servers. We'll verify that the entries\n      * stored on the killed bookie are properly copied over and restored onto\n      * the other bookies.\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -283,7 +283,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n         LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n         bs.get(0).shutdown();\n         bs.remove(0);\n-        \n+\n         // Startup three new bookie servers\n         for (int i = 0; i < 3; i++) {\n             int newBookiePort = initialPort + numBookies + i;\n@@ -298,7 +298,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n         InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n         InetSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n-                + \") and replicate it to a random available one\");\n+                 + \") and replicate it to a random available one\");\n         // Initiate the sync object\n         sync.value = false;\n         bkTools.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n@@ -320,7 +320,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n      * replace it, and then recovering the ledger entries from the killed bookie\n      * onto the new one. We'll verify that the entries stored on the killed\n      * bookie are properly copied over and restored onto the new one.\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -337,7 +337,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n         bs.get(0).shutdown();\n         bs.remove(0);\n-        \n+\n         // Startup a new bookie server\n         int newBookiePort = initialPort + numBookies;\n         startNewBookie(newBookiePort);\n@@ -350,7 +350,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n         InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n-                + bookieDest + \")\");\n+                 + bookieDest + \")\");\n         bkTools.recoverBookieData(bookieSrc, bookieDest);\n \n         // Verify the recovered ledger entries are okay.\n@@ -364,7 +364,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n      * onto random available bookie servers. We'll verify that the entries\n      * stored on the killed bookie are properly copied over and restored onto\n      * the other bookies.\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -396,7 +396,7 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n         InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n         InetSocketAddress bookieDest = null;\n         LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n-                + \") and replicate it to a random available one\");\n+                 + \") and replicate it to a random available one\");\n         bkTools.recoverBookieData(bookieSrc, bookieDest);\n \n         // Verify the recovered ledger entries are okay."},{"sha":"e8274f42217d723cf5ed941a5bd34e1ef87199e5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -46,7 +46,7 @@ public void runBookieServerZKExpireBehaviourTest() throws Exception {\n             File f = File.createTempFile(\"bookieserver\", \"test\");\n             f.delete();\n             f.mkdir();\n-            \n+\n             HashSet<Thread> threadset = new HashSet<Thread>();\n             int threadCount = Thread.activeCount();\n             Thread threads[] = new Thread[threadCount*2];\n@@ -56,28 +56,28 @@ public void runBookieServerZKExpireBehaviourTest() throws Exception {\n                     threadset.add(threads[i]);\n                 }\n             }\n-            \n+\n             server = new BookieServer(initialPort + 1, HOSTPORT, f, new File[] { f });\n             server.start();\n-            \n+\n             Thread.sleep(10);\n             Thread sendthread = null;\n             threadCount = Thread.activeCount();\n             threads = new Thread[threadCount*2];\n             threadCount = Thread.enumerate(threads);\n             for(int i = 0; i < threadCount; i++) {\n                 if (threads[i].getName().indexOf(\"SendThread\") != -1\n-                    && !threadset.contains(threads[i])) {\n+                        && !threadset.contains(threads[i])) {\n                     sendthread = threads[i];\n                     break;\n                 }\n             }\n             assertNotNull(\"Send thread not found\", sendthread);\n-            \n+\n             sendthread.suspend();\n             Thread.sleep(2*10000);\n             sendthread.resume();\n-            \n+\n             // allow watcher thread to run\n             Thread.sleep(3000);\n             assertFalse(\"Bookie should have shutdown on losing zk session\", server.isBookieRunning());"},{"sha":"b43db91099c3dc38e315517b56fc476db3441ce7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import org.junit.*;\n@@ -29,10 +29,10 @@\n /**\n  * This unit test tests closing ledgers sequentially. It creates 4 ledgers, then\n  * write 1000 entries to each ledger and close it.\n- * \n+ *\n  */\n \n-public class CloseTest extends BaseTestCase{\n+public class CloseTest extends BaseTestCase {\n     static Logger LOG = Logger.getLogger(CloseTest.class);\n     DigestType digestType;\n "},{"sha":"ebb17d23a7eee5f589025ed82db4fa58dd36d5d8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -48,7 +48,7 @@\n     File txnDir, ledgerDir;\n     int recvTimeout = 10000;\n     Semaphore throttle;\n-    \n+\n     @Override\n     @Before\n     public void setUp() throws IOException {\n@@ -67,10 +67,10 @@ public void setUp() throws IOException {\n         tmpFile = File.createTempFile(\"book\", \".ledger\", ledgerDir);\n         ledgerDir = new File(tmpFile.getParent(), tmpFile.getName()+\".dir\");\n         ledgerDir.mkdirs();\n-        \n+\n         bookie = new Bookie(5000, null, txnDir, new File[] {ledgerDir});\n     }\n-    \n+\n     static void recursiveDelete(File f) {\n         if (f.isFile()) {\n             f.delete();\n@@ -81,7 +81,7 @@ static void recursiveDelete(File f) {\n             f.delete();\n         }\n     }\n-    \n+\n     @Override\n     @After\n     public void tearDown() {\n@@ -153,7 +153,7 @@ private long doWrites(int ledgers, int size, int totalwrites)\n         WriteCallback cb = new WriteCallback() {\n             @Override\n             public void writeComplete(int rc, long ledgerId, long entryId,\n-                    InetSocketAddress addr, Object ctx) {\n+            InetSocketAddress addr, Object ctx) {\n                 AtomicInteger counter = (AtomicInteger)ctx;\n                 counter.getAndIncrement();\n                 throttle.release();"},{"sha":"3a78507a5d63e4c4060440f579e870aa972608c4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java","status":"modified","additions":19,"deletions":19,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCacheTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -47,17 +47,17 @@\n  */\n public class LedgerCacheTest extends TestCase {\n     static Logger LOG = Logger.getLogger(LedgerCacheTest.class);\n-    \n+\n     Bookie bookie;\n     File txnDir, ledgerDir;\n-    \n+\n     class TestWriteCallback implements WriteCallback {\n-        public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx){\n+        public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n             LOG.info(\"Added entry: \" + rc + \", \" + ledgerId + \", \" + entryId + \", \" + addr);\n         }\n     }\n-    \n-    \n+\n+\n     @Override\n     @Before\n     public void setUp() throws IOException {\n@@ -76,12 +76,12 @@ public void setUp() throws IOException {\n         tmpFile = File.createTempFile(\"book\", \".ledger\", ledgerDir);\n         ledgerDir = new File(tmpFile.getParent(), tmpFile.getName()+\".dir\");\n         ledgerDir.mkdirs();\n-        \n-        \n-        bookie = new Bookie(5000, null, txnDir, new File[] {ledgerDir});   \n+\n+\n+        bookie = new Bookie(5000, null, txnDir, new File[] {ledgerDir});\n     }\n-    \n-    \n+\n+\n     @Override\n     @After\n     public void tearDown() {\n@@ -93,10 +93,10 @@ public void tearDown() {\n             LOG.error(\"Error tearing down\", e);\n         }\n     }\n-    \n+\n     /**\n      * Recursively deletes a directory. This is a duplication of BookieClientTest.\n-     * \n+     *\n      * @param dir\n      */\n     private static void recursiveDelete(File dir) {\n@@ -108,16 +108,16 @@ private static void recursiveDelete(File dir) {\n         }\n         dir.delete();\n     }\n-    \n+\n     @Test\n-    public void testAddEntryException() \n-    throws GeneralSecurityException, BookieException {\n+    public void testAddEntryException()\n+            throws GeneralSecurityException, BookieException {\n         /*\n          * Populate ledger cache\n          */\n-        try{\n+        try {\n             byte[] masterKey = \"blah\".getBytes();\n-            for( int i = 0; i < 30000; i++){\n+            for( int i = 0; i < 30000; i++) {\n                 MacDigestManager dm = new MacDigestManager(i, masterKey);\n                 byte[] data = \"0123456789\".getBytes();\n                 ByteBuffer entry = dm.computeDigestAndPackageForSending(0, 0, 10, data, 0, data.length).toByteBuffer();\n@@ -128,5 +128,5 @@ public void testAddEntryException()\n             fail(\"Failed to add entry.\");\n         }\n     }\n-    \n-}\n\\ No newline at end of file\n+\n+}"},{"sha":"48d5e70a6354e9d9f24772be17532f2f3b397abd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.io.File;\n@@ -85,7 +85,7 @@ public void setUp() throws Exception {\n      * It will then delete all of the ledgers from the client and let the\n      * server's EntryLogger garbage collector thread delete the initial entry\n      * log file.\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -104,7 +104,7 @@ public void testLedgerDelete() throws Exception {\n         for (File ledgerDirectory : tmpDirs) {\n             for (File f : ledgerDirectory.listFiles()) {\n                 assertFalse(\"Found the entry log file (0.log) that should have been deleted in ledgerDirectory: \"\n-                        + ledgerDirectory, f.isFile() && f.getName().equals(\"0.log\"));\n+                            + ledgerDirectory, f.isFile() && f.getName().equals(\"0.log\"));\n             }\n         }\n     }\n@@ -114,7 +114,7 @@ public void testLedgerDelete() throws Exception {\n      * restart the Bookie Servers after it has written out the ledger entries.\n      * On restart, there will be existing entry logs and ledger index files for\n      * the EntryLogger and LedgerCache to read and store into memory.\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -155,7 +155,7 @@ public void testLedgerDeleteWithExistingEntryLogs() throws Exception {\n         for (File ledgerDirectory : tmpDirs) {\n             for (File f : ledgerDirectory.listFiles()) {\n                 assertFalse(\"Found the entry log file ([0,1].log) that should have been deleted in ledgerDirectory: \"\n-                        + ledgerDirectory, f.isFile() && (f.getName().equals(\"0.log\") || f.getName().equals(\"1.log\")));\n+                            + ledgerDirectory, f.isFile() && (f.getName().equals(\"0.log\") || f.getName().equals(\"1.log\")));\n             }\n         }\n     }"},{"sha":"8c0d3af70a34bdfecd23289ccb88aafed698b249","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import org.junit.*;\n@@ -28,7 +28,7 @@\n \n /**\n  * This unit test tests ledger recovery.\n- * \n+ *\n  */\n \n public class LedgerRecoveryTest extends BaseTestCase {\n@@ -54,7 +54,7 @@ private void testInternal(int numEntries) throws Exception {\n         }\n \n         long length = (long) (numEntries * tmp.length());\n-        \n+\n         /*\n          * Try to open ledger.\n          */\n@@ -64,24 +64,24 @@ private void testInternal(int numEntries) throws Exception {\n          * Check if has recovered properly.\n          */\n         assertTrue(\"Has not recovered correctly: \" + afterlh.getLastAddConfirmed(),\n-                afterlh.getLastAddConfirmed() == numEntries - 1);       \n-        assertTrue(\"Has not set the length correctly: \" + afterlh.getLength() + \", \" + length, \n-                afterlh.getLength() == length);\n+                   afterlh.getLastAddConfirmed() == numEntries - 1);\n+        assertTrue(\"Has not set the length correctly: \" + afterlh.getLength() + \", \" + length,\n+                   afterlh.getLength() == length);\n     }\n-    \n+\n     @Test\n     public void testLedgerRecovery() throws Exception {\n         testInternal(100);\n-     \n+\n     }\n \n     @Test\n-    public void testEmptyLedgerRecoveryOne() throws Exception{\n+    public void testEmptyLedgerRecoveryOne() throws Exception {\n         testInternal(1);\n     }\n \n     @Test\n-    public void testEmptyLedgerRecovery() throws Exception{\n+    public void testEmptyLedgerRecovery() throws Exception {\n         testInternal(0);\n     }\n "},{"sha":"85822bf421a4550e5e09b49817aee48eafe6fd6c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.net.InetSocketAddress;\n@@ -37,9 +37,9 @@\n \n /**\n  * This class tests BookieClient. It just sends the a new entry to itself.\n- * \n- * \n- * \n+ *\n+ *\n+ *\n  */\n \n class LoopbackClient implements WriteCallback {"},{"sha":"edc5a385128a080588a33f4d48e7e35d60129175","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -1,24 +1,24 @@\n package org.apache.bookkeeper.test;\n \n /*\n- * \n+ *\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n  * regarding copyright ownership.  The ASF licenses this file\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n- * \n+ *\n  */\n \n import java.net.Socket;"},{"sha":"ddf92b1762a821d8868bdb25bf747a9a321233f8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,13 +24,13 @@\n /**\n  * Interface to define the client handler logic to consume messages it is\n  * subscribed to.\n- * \n+ *\n  */\n public interface MessageHandler {\n \n     /**\n      * Consumes a message it is subscribed to and has been delivered to it.\n-     * \n+     *\n      * @param topic\n      *            The topic name where the message came from.\n      * @param subscriberId\n@@ -45,4 +45,4 @@\n      */\n     public void consume(ByteString topic, ByteString subscriberId, Message msg, Callback<Void> callback, Object context);\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"350b89c6ecef61a12adfa60ee4a424aee980d4dc","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -25,13 +25,13 @@\n \n /**\n  * Interface to define the client Publisher API.\n- * \n+ *\n  */\n public interface Publisher {\n \n     /**\n      * Publishes a message on the given topic.\n-     * \n+     *\n      * @param topic\n      *            Topic name to publish on\n      * @param msg\n@@ -45,7 +45,7 @@\n \n     /**\n      * Publishes a message asynchronously on the given topic.\n-     * \n+     *\n      * @param topic\n      *            Topic name to publish on\n      * @param msg\n@@ -60,4 +60,4 @@\n      */\n     public void asyncPublish(ByteString topic, Message msg, Callback<Void> callback, Object context);\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"6910e7d7fb28ad3d8b38a25084de656a838edc98","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","status":"modified","additions":20,"deletions":20,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -31,13 +31,13 @@\n \n /**\n  * Interface to define the client Subscriber API.\n- * \n+ *\n  */\n public interface Subscriber {\n \n     /**\n      * Subscribe to the given topic for the inputted subscriberId.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -58,12 +58,12 @@\n      */\n     public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n-            InvalidSubscriberIdException;\n+        InvalidSubscriberIdException;\n \n     /**\n      * Subscribe to the given topic asynchronously for the inputted subscriberId\n      * disregarding if the topic has been created yet or not.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -80,12 +80,12 @@ public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach\n      *            asynchronously.\n      */\n     public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n-            Object context);\n+                               Object context);\n \n     /**\n      * Unsubscribe from a topic that the subscriberId user has previously\n      * subscribed to.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -102,12 +102,12 @@ public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAt\n      *             e.g. local vs. hub subscriber\n      */\n     public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n-            ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException;\n+        ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException;\n \n     /**\n      * Unsubscribe from a topic asynchronously that the subscriberId user has\n      * previously subscribed to.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -124,15 +124,15 @@ public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldN\n \n     /**\n      * Manually send a consume message to the server for the given inputs.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n      *            ID of the subscriber\n      * @param messageSeqId\n      *            Message Sequence ID for the latest message that the client app\n      *            has successfully consumed. All messages up to that point will\n-     *            also be considered as consumed.            \n+     *            also be considered as consumed.\n      * @throws ClientNotSubscribedException\n      *             If the client is not currently subscribed to the topic based\n      *             on the client's local state.\n@@ -143,7 +143,7 @@ public void consume(ByteString topic, ByteString subscriberId, MessageSeqId mess\n     /**\n      * Checks if the subscriberId client is currently subscribed to the given\n      * topic.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription.\n      * @param subscriberId\n@@ -156,12 +156,12 @@ public void consume(ByteString topic, ByteString subscriberId, MessageSeqId mess\n      * @return Boolean indicating if the client has a subscription or not.\n      */\n     public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n-            ServiceDownException;\n+        ServiceDownException;\n \n     /**\n      * Fills the input List with the subscriptions this subscriberId client is\n      * subscribed to.\n-     * \n+     *\n      * @param subscriberId\n      *            ID of the subscriber\n      * @return List filled with subscription name (topic) strings.\n@@ -171,12 +171,12 @@ public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws\n      *             If there is an error retrieving the list of topics\n      */\n     public List<ByteString> getSubscriptionList(ByteString subscriberId) throws CouldNotConnectException,\n-            ServiceDownException;\n+        ServiceDownException;\n \n     /**\n      * Begin delivery of messages from the server to us for this topic and\n      * subscriberId.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -191,7 +191,7 @@ public void startDelivery(ByteString topic, ByteString subscriberId, MessageHand\n \n     /**\n      * Stop delivery of messages for this topic and subscriberId.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -205,7 +205,7 @@ public void startDelivery(ByteString topic, ByteString subscriberId, MessageHand\n      * Closes all of the client side cached data for this subscription without\n      * actually sending an unsubscribe request to the server. This will close\n      * the subscribe channel synchronously (if it exists) for the topic.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -220,7 +220,7 @@ public void startDelivery(ByteString topic, ByteString subscriberId, MessageHand\n      * Closes all of the client side cached data for this subscription without\n      * actually sending an unsubscribe request to the server. This will close\n      * the subscribe channel asynchronously (if it exists) for the topic.\n-     * \n+     *\n      * @param topic\n      *            Topic name of the subscription\n      * @param subscriberId\n@@ -232,6 +232,6 @@ public void startDelivery(ByteString topic, ByteString subscriberId, MessageHand\n      *            asynchronously.\n      */\n     public void asyncCloseSubscription(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n-            Object context);\n+                                       Object context);\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"687062bf29e1002b412be24dc4ba00049e6fad39","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -35,7 +35,7 @@\n     double rate;\n \n     public BenchmarkPublisher(int numTopics, int numMessages, int numRegions, int startTopicLabel, int partitionIndex,\n-            int numPartitions, Publisher publisher, Subscriber subscriber, int msgSize, int nParallel, int rate) {\n+                              int numPartitions, Publisher publisher, Subscriber subscriber, int msgSize, int nParallel, int rate) {\n         super(numTopics, numMessages, numRegions, startTopicLabel, partitionIndex, numPartitions);\n         this.publisher = publisher;\n         this.msgSize = msgSize;\n@@ -53,7 +53,7 @@ public void warmup(int nWarmup) throws Exception {\n         subscriber.startDelivery(topic, subId, new MessageHandler() {\n             @Override\n             public void consume(ByteString topic, ByteString subscriberId, Message msg, Callback<Void> callback,\n-                    Object context) {\n+            Object context) {\n                 // noop\n                 callback.operationFinished(context, null);\n             }\n@@ -88,7 +88,7 @@ public Void call() throws Exception {\n         // Single warmup for every topic\n         int myPublishCount = 0;\n         for (int i = 0; i < numTopics; i++) {\n-            if (!HedwigBenchmark.amIResponsibleForTopic(startTopicLabel + i, partitionIndex, numPartitions)){\n+            if (!HedwigBenchmark.amIResponsibleForTopic(startTopicLabel + i, partitionIndex, numPartitions)) {\n                 continue;\n             }\n             ByteString topic = ByteString.copyFromUtf8(HedwigBenchmark.TOPIC_PREFIX + (startTopicLabel + i));\n@@ -123,8 +123,8 @@ public Void call() throws Exception {\n         }\n \n         System.out.println(\"Finished unacked pubs: tput = \" + BenchmarkUtils.calcTp(myPublishLimit, startTime)\n-                + \" ops/s\");\n-        // Wait till the benchmark test has completed \n+                           + \" ops/s\");\n+        // Wait till the benchmark test has completed\n         agg.tpAgg.queue.take();\n         System.out.println(agg.summarize(startTime));\n         return null;"},{"sha":"0e87dd76866629460387957003e9bdd904d62f2d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -34,17 +34,17 @@\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.util.Callback;\n \n-public class BenchmarkSubscriber extends BenchmarkWorker implements Callable<Void>{\n+public class BenchmarkSubscriber extends BenchmarkWorker implements Callable<Void> {\n     static final Logger logger = Logger.getLogger(BenchmarkSubscriber.class);\n     Subscriber subscriber;\n     ByteString subId;\n-    \n+\n \n     public BenchmarkSubscriber(int numTopics, int numMessages, int numRegions,\n-            int startTopicLabel, int partitionIndex, int numPartitions, Subscriber subscriber, ByteString subId) {\n+                               int startTopicLabel, int partitionIndex, int numPartitions, Subscriber subscriber, ByteString subId) {\n         super(numTopics, numMessages, numRegions, startTopicLabel, partitionIndex, numPartitions);\n         this.subscriber = subscriber;\n-        this.subId = subId;        \n+        this.subId = subId;\n     }\n \n     public void warmup(int numWarmup) throws InterruptedException {\n@@ -73,10 +73,10 @@ public Void call() throws Exception {\n \n                 @Override\n                 public void consume(ByteString thisTopic, ByteString subscriberId, Message msg,\n-                        Callback<Void> callback, Object context) {\n+                Callback<Void> callback, Object context) {\n                     if (logger.isDebugEnabled())\n                         logger.debug(\"Got message from src-region: \" + msg.getSrcRegion() + \" with seq-id: \"\n-                                + msg.getMsgId());\n+                                     + msg.getMsgId());\n \n                     String mapKey = topic + msg.getSrcRegion().toStringUtf8();\n                     Long lastSeqIdSeen = lastSeqIdSeenMap.get(mapKey);\n@@ -86,7 +86,7 @@ public void consume(ByteString thisTopic, ByteString subscriberId, Message msg,\n \n                     if (getSrcSeqId(msg) <= lastSeqIdSeen) {\n                         logger.info(\"Redelivery of message, src-region: \" + msg.getSrcRegion() + \"seq-id: \"\n-                                + msg.getMsgId());\n+                                    + msg.getMsgId());\n                     } else {\n                         agg.ding(false);\n                     }\n@@ -97,7 +97,7 @@ public void consume(ByteString thisTopic, ByteString subscriberId, Message msg,\n         }\n         System.out.println(\"Finished subscribing to topics and now waiting for messages to come in...\");\n         // Wait till the benchmark test has completed\n-        agg.queue.take();            \n+        agg.queue.take();\n         System.out.println(agg.summarize(agg.earliest.get()));\n         return null;\n     }\n@@ -121,11 +121,11 @@ void multiSub(String label, String topicPrefix, int start, final int npar, final\n         ThroughputLatencyAggregator agg = new ThroughputLatencyAggregator(label, count / numPartitions, npar);\n         int end = start + count;\n         for (int i = start; i < end; ++i) {\n-            if (!HedwigBenchmark.amIResponsibleForTopic(i, partitionIndex, numPartitions)){\n+            if (!HedwigBenchmark.amIResponsibleForTopic(i, partitionIndex, numPartitions)) {\n                 continue;\n             }\n             subscriber.asyncSubscribe(ByteString.copyFromUtf8(topicPrefix + i), subId, CreateOrAttach.CREATE_OR_ATTACH,\n-                    new BenchmarkCallback(agg), null);\n+                                      new BenchmarkCallback(agg), null);\n         }\n         // Wait till the benchmark test has completed\n         agg.tpAgg.queue.take();"},{"sha":"79acc9665ef69f1dbf4ce40b62998b38c8457933","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -86,7 +86,7 @@ private String getPercentile(double percentile) {\n         public String summarize(long startTime) {\n             double percentile = Double.parseDouble(System.getProperty(\"percentile\", \"99.9\"));\n             return tpAgg.summarize(startTime) + \", avg latency = \" + sum.get() / tpAgg.count + \", \" + percentile\n-                    + \"%ile latency = \" + getPercentile(percentile);\n+                   + \"%ile latency = \" + getPercentile(percentile);\n         }\n     }\n \n@@ -140,7 +140,7 @@ public void ding(boolean failed) {\n \n         public String summarize(long startTime) {\n             return \"Finished \" + label + \": count = \" + done.get() + \", tput = \" + calcTp(count, startTime)\n-                    + \" ops/s, numFailed = \" + numFailed;\n+                   + \" ops/s, numFailed = \" + numFailed;\n         }\n     }\n "},{"sha":"e7b15f26a2ffef6e44573adf95a011e296007fd8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -26,7 +26,7 @@\n     int numPartitions;\n \n     public BenchmarkWorker(int numTopics, int numMessages, int numRegions,\n-            int startTopicLabel, int partitionIndex, int numPartitions) {\n+                           int startTopicLabel, int partitionIndex, int numPartitions) {\n         this.numTopics = numTopics;\n         this.numMessages = numMessages;\n         this.numRegions = numRegions;"},{"sha":"6465c9e5326e496777b5fedbabcbb6ca0720a1c5","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -98,7 +98,7 @@ public Void call() throws Exception {\n                     startTopicLabel, partitionIndex, numPartitions, publisher, subscriber, msgSize, nParallel, rate);\n             benchmarkPub.warmup(nWarmups);\n             benchmarkPub.call();\n-            \n+\n         } else {\n             throw new Exception(\"unknown mode: \" + mode);\n         }"},{"sha":"52e570495043dc2f9902b0b8ff85e1799677fa20","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -79,7 +79,7 @@ public int getMaximumServerRedirects() {\n     // automatically send the consume message to the server based on the\n     // configured amount of messages consumed by the client app. The client app\n     // could choose to override this behavior and instead, manually send the\n-    // consume message to the server via the client library using its own \n+    // consume message to the server via the client library using its own\n     // logic and policy.\n     public boolean isAutoSendConsumeMessageEnabled() {\n         return conf.getBoolean(AUTO_SEND_CONSUME_MESSAGE_ENABLED, true);"},{"sha":"ccb99031b9b1b4007b8d9560b969da1bf7f10b0c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -26,7 +26,7 @@\n  * server for a given TopicSubscriber. This will be used as the Context in the\n  * VoidCallback for the MessageHandlers once they've completed consuming the\n  * message.\n- * \n+ *\n  */\n public class MessageConsumeData {\n "},{"sha":"1b33c2fe1588eba970d78fecc1d999079cc40b5d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -32,7 +32,7 @@\n  * request in case of a server redirect. This will be used for all sync/async\n  * calls, and for all the known types of request messages to send to the server\n  * hubs: Publish, Subscribe, Unsubscribe, and Consume.\n- * \n+ *\n  */\n public class PubSubData {\n     // Static string constants\n@@ -84,8 +84,8 @@\n \n     // Constructor for all types of PubSub request data to send to the server\n     public PubSubData(final ByteString topic, final Message msg, final ByteString subscriberId,\n-            final OperationType operationType, final CreateOrAttach createOrAttach, final Callback<Void> callback,\n-            final Object context) {\n+                      final OperationType operationType, final CreateOrAttach createOrAttach, final Callback<Void> callback,\n+                      final Object context) {\n         this.topic = topic;\n         this.msg = msg;\n         this.subscriberId = subscriberId;"},{"sha":"064cec12d379684adec3a4f33a46f22625919783","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -25,7 +25,7 @@\n  * Wrapper class object for the Topic + SubscriberId combination. Since the\n  * Subscribe flows always use the Topic + SubscriberId as the logical entity,\n  * we'll create a simple class to encapsulate that.\n- * \n+ *\n  */\n public class TopicSubscriber {\n     private final ByteString topic;\n@@ -62,13 +62,13 @@ public String toString() {\n             sb.append(PubSubData.COMMA).append(\"SubscriberId: \" + subscriberId.toStringUtf8());\n         return sb.toString();\n     }\n-    \n+\n     public ByteString getTopic() {\n         return topic;\n     }\n-    \n+\n     public ByteString getSubscriberId() {\n         return subscriberId;\n     }\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"da6d4e7d39ee0a1359a9f2dcb364697e3ae25384","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -19,9 +19,9 @@\n \n /**\n  * This is a Hedwig client side exception when the PubSubRequest is being\n- * redirected to a server where the request has already been sent to previously. \n+ * redirected to a server where the request has already been sent to previously.\n  * To avoid having a cyclical redirect loop, this condition is checked for\n- * and this exception will be thrown to the client caller. \n+ * and this exception will be thrown to the client caller.\n  */\n public class ServerRedirectLoopException extends Exception {\n "},{"sha":"4a3c99f0f42beea2858fc203a824a1d93a2a3885","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -22,7 +22,7 @@\n  * redirects during a publish/subscribe call. We only allow a certain number of\n  * server redirects to find the topic master. If we have exceeded this\n  * configured amount, the publish/subscribe will fail with this exception.\n- * \n+ *\n  */\n public class TooManyServerRedirectsException extends Exception {\n "},{"sha":"2e11d63be49c51daee698e470570bc78f32d2079","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -35,7 +35,7 @@\n  * can use a singleton for the class. The object context used should be the\n  * MessageConsumeData type. That will contain all of the information needed to\n  * call the message consume logic in the client lib ResponseHandler.\n- * \n+ *\n  */\n public class MessageConsumeCallback implements Callback<Void> {\n \n@@ -61,7 +61,7 @@ public void run() {\n             // Try to consume the message again\n             Channel topicSubscriberChannel = client.getSubscriber().getChannelForTopic(topicSubscriber);\n             HedwigClient.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n-                    .asyncMessageConsume(messageConsumeData.msg);\n+            .asyncMessageConsume(messageConsumeData.msg);\n         }\n     }\n \n@@ -72,7 +72,7 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n         // to the ResponseHandler indicating that the message is consumed.\n         Channel topicSubscriberChannel = client.getSubscriber().getChannelForTopic(topicSubscriber);\n         HedwigClient.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n-                .messageConsumed(messageConsumeData.msg);\n+        .messageConsumed(messageConsumeData.msg);\n     }\n \n     public void operationFailed(Object ctx, PubSubException exception) {\n@@ -89,7 +89,7 @@ public void operationFailed(Object ctx, PubSubException exception) {\n         // perhaps what the last amount of time we slept was. We could stick\n         // some of this meta-data into the MessageConsumeData when we retry.\n         client.getClientTimer().schedule(new MessageConsumeRetryTask(messageConsumeData, topicSubscriber),\n-                client.getConfiguration().getMessageConsumeRetryWaitTime());\n+                                         client.getConfiguration().getMessageConsumeRetryWaitTime());\n     }\n \n }"},{"sha":"563ad658f7909349f83776de139c7dce20ba728f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -27,7 +27,7 @@\n  * This class is used when we are doing synchronous type of operations. All\n  * underlying client ops in Hedwig are async so this is just a way to make the\n  * async calls synchronous.\n- * \n+ *\n  */\n public class PubSubCallback implements Callback<Void> {\n "},{"sha":"90e62bab076d4a6ab6d037a79adf701198cbbff8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -40,7 +40,7 @@ public PublishResponseHandler(ResponseHandler responseHandler) {\n     public void handlePublishResponse(PubSubResponse response, PubSubData pubSubData, Channel channel) throws Exception {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Handling a Publish response: \" + response + \", pubSubData: \" + pubSubData + \", host: \"\n-                    + HedwigClient.getHostFromChannel(channel));\n+                         + HedwigClient.getHostFromChannel(channel));\n         switch (response.getStatusCode()) {\n         case SUCCESS:\n             // Response was success so invoke the callback's operationFinished\n@@ -51,7 +51,7 @@ public void handlePublishResponse(PubSubResponse response, PubSubData pubSubData\n             // Response was service down failure so just invoke the callback's\n             // operationFailed method.\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    \"Server responded with a SERVICE_DOWN status\"));\n+                                                    \"Server responded with a SERVICE_DOWN status\"));\n             break;\n         case NOT_RESPONSIBLE_FOR_TOPIC:\n             // Redirect response so we'll need to repost the original Publish\n@@ -63,7 +63,7 @@ public void handlePublishResponse(PubSubResponse response, PubSubData pubSubData\n             // cases.\n             logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    \"Server responded with a status code of: \" + response.getStatusCode()));\n+                                                    \"Server responded with a status code of: \" + response.getStatusCode()));\n             break;\n         }\n     }"},{"sha":"60388faf6708e6575d522a79a109bfc4c8348677","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -36,7 +36,7 @@\n  * the topic is completed, we need to restart delivery for that topic if that\n  * was the case before the original channel got disconnected. This async\n  * callback will be the hook for this.\n- * \n+ *\n  */\n public class SubscribeReconnectCallback implements Callback<Void> {\n \n@@ -83,8 +83,8 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                 // This exception should never be thrown here but just in case,\n                 // log an error and just keep retrying the subscribe request.\n                 logger.error(\"Subscribe was successful but error starting delivery for topic: \"\n-                        + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                        + origSubData.subscriberId.toStringUtf8(), e);\n+                             + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                             + origSubData.subscriberId.toStringUtf8(), e);\n                 retrySubscribeRequest();\n             }\n         }\n@@ -108,6 +108,6 @@ private void retrySubscribeRequest() {\n         // Retry the subscribe request but only after waiting for a\n         // preconfigured amount of time.\n         client.getClientTimer().schedule(new SubscribeReconnectRetryTask(),\n-                client.getConfiguration().getSubscribeReconnectRetryWaitTime());\n+                                         client.getConfiguration().getSubscribeReconnectRetryWaitTime());\n     }\n }"},{"sha":"2256a682e113b1d1ee5580bcb4c1ae67b226af1e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -93,7 +93,7 @@ public void handleSubscribeResponse(PubSubResponse response, PubSubData pubSubDa\n \n         if (logger.isDebugEnabled())\n             logger.debug(\"Handling a Subscribe response: \" + response + \", pubSubData: \" + pubSubData + \", host: \"\n-                    + HedwigClient.getHostFromChannel(channel));\n+                         + HedwigClient.getHostFromChannel(channel));\n         switch (response.getStatusCode()) {\n         case SUCCESS:\n             // For successful Subscribe requests, store this Channel locally\n@@ -122,7 +122,7 @@ public void handleSubscribeResponse(PubSubResponse response, PubSubData pubSubDa\n             // because when that happens, things are slow already and piling\n             // up on the client app side to consume messages.\n             outstandingMsgSet = new HashSet<Message>(\n-                    responseHandler.getConfiguration().getMaximumOutstandingMessages(), 1.0f);\n+                responseHandler.getConfiguration().getMaximumOutstandingMessages(), 1.0f);\n             // Response was success so invoke the callback's operationFinished\n             // method.\n             pubSubData.callback.operationFinished(pubSubData.context, null);\n@@ -131,14 +131,14 @@ public void handleSubscribeResponse(PubSubResponse response, PubSubData pubSubDa\n             // For Subscribe requests, the server says that the client is\n             // already subscribed to it.\n             pubSubData.callback.operationFailed(pubSubData.context, new ClientAlreadySubscribedException(\n-                    \"Client is already subscribed for topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                            + pubSubData.subscriberId.toStringUtf8()));\n+                                                    \"Client is already subscribed for topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                                    + pubSubData.subscriberId.toStringUtf8()));\n             break;\n         case SERVICE_DOWN:\n             // Response was service down failure so just invoke the callback's\n             // operationFailed method.\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    \"Server responded with a SERVICE_DOWN status\"));\n+                                                    \"Server responded with a SERVICE_DOWN status\"));\n             break;\n         case NOT_RESPONSIBLE_FOR_TOPIC:\n             // Redirect response so we'll need to repost the original Subscribe\n@@ -150,7 +150,7 @@ public void handleSubscribeResponse(PubSubResponse response, PubSubData pubSubDa\n             // cases.\n             logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    \"Server responded with a status code of: \" + response.getStatusCode()));\n+                                                    \"Server responded with a status code of: \" + response.getStatusCode()));\n             break;\n         }\n     }\n@@ -160,7 +160,7 @@ public void handleSubscribeResponse(PubSubResponse response, PubSubData pubSubDa\n     public void handleSubscribeMessage(PubSubResponse response) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Handling a Subscribe message in response: \" + response + \", topic: \"\n-                    + origSubData.topic.toStringUtf8() + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n+                         + origSubData.topic.toStringUtf8() + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n         Message message = response.getMessage();\n \n         synchronized (this) {\n@@ -182,8 +182,8 @@ public void handleSubscribeMessage(PubSubResponse response) {\n                     subscribeMsgQueue = new LinkedList<Message>();\n                 if (logger.isDebugEnabled())\n                     logger\n-                        .debug(\"Message has arrived but Subscribe channel does not have a registered MessageHandler yet so queueing up the message: \"\n-                                + message);\n+                    .debug(\"Message has arrived but Subscribe channel does not have a registered MessageHandler yet so queueing up the message: \"\n+                           + message);\n                 subscribeMsgQueue.add(message);\n             }\n         }\n@@ -193,15 +193,15 @@ public void handleSubscribeMessage(PubSubResponse response) {\n      * Method called when a message arrives for a subscribe Channel and we want\n      * to consume it asynchronously via the registered MessageHandler (should\n      * not be null when called here).\n-     * \n+     *\n      * @param message\n      *            Message from Subscribe Channel we want to consume.\n      */\n     protected void asyncMessageConsume(Message message) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Call the client app's MessageHandler asynchronously to consume the message: \" + message\n-                    + \", topic: \" + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                    + origSubData.subscriberId.toStringUtf8());\n+                         + \", topic: \" + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                         + origSubData.subscriberId.toStringUtf8());\n         // Add this \"pending to be consumed\" message to the outstandingMsgSet.\n         outstandingMsgSet.add(message);\n         // Check if we've exceeded the max size for the outstanding message set.\n@@ -211,13 +211,13 @@ protected void asyncMessageConsume(Message message) {\n             // Channel to not be readable.\n             if (logger.isDebugEnabled())\n                 logger.debug(\"Too many outstanding messages (\" + outstandingMsgSet.size()\n-                        + \") so throttling the subscribe netty Channel\");\n+                             + \") so throttling the subscribe netty Channel\");\n             subscribeChannel.setReadable(false);\n         }\n         MessageConsumeData messageConsumeData = new MessageConsumeData(origSubData.topic, origSubData.subscriberId,\n                 message);\n         messageHandler.consume(origSubData.topic, origSubData.subscriberId, message, responseHandler.getClient()\n-                .getConsumeCallback(), messageConsumeData);\n+                               .getConsumeCallback(), messageConsumeData);\n     }\n \n     /**\n@@ -230,16 +230,16 @@ protected void asyncMessageConsume(Message message) {\n      * same order. To make this thread safe, since multiple outstanding messages\n      * could be consumed by the client app and then called back to here, make\n      * this method synchronized.\n-     * \n+     *\n      * @param message\n      *            Message sent from server for topic subscription that has been\n      *            consumed by the client.\n      */\n     protected synchronized void messageConsumed(Message message) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Message has been successfully consumed by the client app for message: \" + message\n-                    + \", topic: \" + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                    + origSubData.subscriberId.toStringUtf8());\n+                         + \", topic: \" + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                         + origSubData.subscriberId.toStringUtf8());\n         // Update the consumed messages buffer variables\n         if (responseHandler.getConfiguration().isAutoSendConsumeMessageEnabled()) {\n             // Update these variables only if we are auto-sending consume\n@@ -265,8 +265,8 @@ protected synchronized void messageConsumed(Message message) {\n             // subscribe request for the TopicSubscriber.\n             if (logger.isDebugEnabled())\n                 logger\n-                        .debug(\"Consumed message buffer limit reached so send the Consume Request to the server with lastMessageSeqId: \"\n-                                + lastMessageSeqId);\n+                .debug(\"Consumed message buffer limit reached so send the Consume Request to the server with lastMessageSeqId: \"\n+                       + lastMessageSeqId);\n             responseHandler.getSubscriber().doConsume(origSubData, subscribeChannel, lastMessageSeqId);\n             numConsumedMessagesInBuffer = 0;\n             lastMessageSeqId = null;\n@@ -279,10 +279,10 @@ protected synchronized void messageConsumed(Message message) {\n         if (!subscribeChannel.isReadable() && outstandingMsgSet.size() == 0) {\n             if (logger.isDebugEnabled())\n                 logger\n-                        .debug(\"Message consumption has caught up so okay to turn off throttling of messages on the subscribe channel for topic: \"\n-                                + origSubData.topic.toStringUtf8()\n-                                + \", subscriberId: \"\n-                                + origSubData.subscriberId.toStringUtf8());\n+                .debug(\"Message consumption has caught up so okay to turn off throttling of messages on the subscribe channel for topic: \"\n+                       + origSubData.topic.toStringUtf8()\n+                       + \", subscriberId: \"\n+                       + origSubData.subscriberId.toStringUtf8());\n             subscribeChannel.setReadable(true);\n         }\n     }\n@@ -291,14 +291,14 @@ protected synchronized void messageConsumed(Message message) {\n      * Setter used for Subscribe flows when delivery for the subscription is\n      * started. This is used to register the MessageHandler needed to consumer\n      * the subscribed messages for the topic.\n-     * \n+     *\n      * @param messageHandler\n      *            MessageHandler to register for this ResponseHandler instance.\n      */\n     public void setMessageHandler(MessageHandler messageHandler) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Setting the messageHandler for topic: \" + origSubData.topic.toStringUtf8()\n-                    + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n+                         + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n         synchronized (this) {\n             this.messageHandler = messageHandler;\n             // Once the MessageHandler is registered, see if we have any queued up\n@@ -309,8 +309,8 @@ public void setMessageHandler(MessageHandler messageHandler) {\n             if (messageHandler != null && subscribeMsgQueue != null && subscribeMsgQueue.size() > 0) {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Consuming \" + subscribeMsgQueue.size() + \" queued up messages for topic: \"\n-                            + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                            + origSubData.subscriberId.toStringUtf8());\n+                                 + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                 + origSubData.subscriberId.toStringUtf8());\n                 for (Message message : subscribeMsgQueue) {\n                     asyncMessageConsume(message);\n                 }\n@@ -323,7 +323,7 @@ public void setMessageHandler(MessageHandler messageHandler) {\n \n     /**\n      * Getter for the MessageHandler that is set for this subscribe channel.\n-     * \n+     *\n      * @return The MessageHandler for consuming messages\n      */\n     public MessageHandler getMessageHandler() {"},{"sha":"f12e47644c84d0fc2765c4aab5965cc08101ee63","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -42,7 +42,7 @@ public void handleUnsubscribeResponse(PubSubResponse response, PubSubData pubSub\n             throws Exception {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Handling an Unsubscribe response: \" + response + \", pubSubData: \" + pubSubData + \", host: \"\n-                    + HedwigClient.getHostFromChannel(channel));\n+                         + HedwigClient.getHostFromChannel(channel));\n         switch (response.getStatusCode()) {\n         case SUCCESS:\n             // For successful Unsubscribe requests, we can now safely close the\n@@ -56,14 +56,14 @@ public void handleUnsubscribeResponse(PubSubResponse response, PubSubData pubSub\n             // For Unsubscribe requests, the server says that the client was\n             // never subscribed to the topic.\n             pubSubData.callback.operationFailed(pubSubData.context, new ClientNotSubscribedException(\n-                    \"Client was never subscribed to topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                            + pubSubData.subscriberId.toStringUtf8()));\n+                                                    \"Client was never subscribed to topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                                    + pubSubData.subscriberId.toStringUtf8()));\n             break;\n         case SERVICE_DOWN:\n             // Response was service down failure so just invoke the callback's\n             // operationFailed method.\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    \"Server responded with a SERVICE_DOWN status\"));\n+                                                    \"Server responded with a SERVICE_DOWN status\"));\n             break;\n         case NOT_RESPONSIBLE_FOR_TOPIC:\n             // Redirect response so we'll need to repost the original\n@@ -75,7 +75,7 @@ public void handleUnsubscribeResponse(PubSubResponse response, PubSubData pubSub\n             // cases.\n             logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    \"Server responded with a status code of: \" + response.getStatusCode()));\n+                                                    \"Server responded with a status code of: \" + response.getStatusCode()));\n             break;\n         }\n     }"},{"sha":"9c36e87156a9ad92a23b1169f16e08e964772eea","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -40,12 +40,12 @@ public ClientChannelPipelineFactory(HedwigClient client) {\n     public ChannelPipeline getPipeline() throws Exception {\n         // Create a new ChannelPipline using the factory method from the\n         // Channels helper class.\n-        ChannelPipeline pipeline = Channels.pipeline();        \n+        ChannelPipeline pipeline = Channels.pipeline();\n         if (client.getSslFactory() != null) {\n             pipeline.addLast(\"ssl\", new SslHandler(client.getSslFactory().getEngine()));\n-        }        \n+        }\n         pipeline.addLast(\"lengthbaseddecoder\", new LengthFieldBasedFrameDecoder(client.getConfiguration()\n-                .getMaximumMessageSize(), 0, 4, 0, 4));\n+                         .getMaximumMessageSize(), 0, 4, 0, 4));\n         pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n \n         pipeline.addLast(\"protobufdecoder\", new ProtobufDecoder(PubSubProtocol.PubSubResponse.getDefaultInstance()));"},{"sha":"3f137540601980d8a07bbd91d3ca5717cb762225","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -70,7 +70,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 // invoke the operationFailed callback.\n                 logger.error(\"Error connecting to host more than once so just invoke the operationFailed callback!\");\n                 pubSubData.callback.operationFailed(pubSubData.context, new CouldNotConnectException(\n-                        \"Could not connect to host: \" + host));\n+                                                        \"Could not connect to host: \" + host));\n             } else {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Try to connect to server: \" + host + \" again for pubSubData: \" + pubSubData);"},{"sha":"b270d343855b4be7b2cfa4d135cabcad3300c20e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -44,7 +44,7 @@\n /**\n  * This is a top level Hedwig Client class that encapsulates the common\n  * functionality needed for both Publish and Subscribe operations.\n- * \n+ *\n  */\n public class HedwigClient {\n \n@@ -182,15 +182,15 @@ public void run() {\n         }\n \n         private void checkPubSubDataToTimeOut(PubSubData pubSubData, ResponseHandler responseHandler, long curTime,\n-                long timeoutInterval) {\n+                                              long timeoutInterval) {\n             if (curTime > pubSubData.requestWriteTime + timeoutInterval) {\n                 // Current PubSubRequest has timed out so remove it from the\n                 // ResponseHandler's map and invoke the VoidCallback's\n                 // operationFailed method.\n                 logger.error(\"Current PubSubRequest has timed out for pubSubData: \" + pubSubData);\n                 responseHandler.txn2PubSubData.remove(pubSubData.txnId);\n                 pubSubData.callback.operationFailed(pubSubData.context, new UncertainStateException(\n-                        \"Server ack response never received so PubSubRequest has timed out!\"));\n+                                                        \"Server ack response never received so PubSubRequest has timed out!\"));\n             }\n         }\n     }\n@@ -236,7 +236,7 @@ public void stop() {\n      * to the one that is responsible for the topic. Once the connect to the\n      * server is done, we will perform the corresponding PubSub write on that\n      * channel.\n-     * \n+     *\n      * @param pubSubData\n      *            PubSub call's data wrapper object\n      * @param serverHost\n@@ -261,7 +261,7 @@ public void doConnect(PubSubData pubSubData, InetSocketAddress serverHost) {\n      * Helper method to store the topic2Host mapping in the HedwigClient cache\n      * map. This method is assumed to be called when we've done a successful\n      * connection to the correct server topic master.\n-     * \n+     *\n      * @param pubSubData\n      *            PubSub wrapper data\n      * @param channel\n@@ -282,7 +282,7 @@ protected void storeTopic2HostMapping(PubSubData pubSubData, Channel channel) {\n         // Store the relevant mappings for this topic and host combination.\n         if (logger.isDebugEnabled())\n             logger.debug(\"Storing info for topic: \" + pubSubData.topic.toStringUtf8() + \", old host: \"\n-                    + topic2Host.get(pubSubData.topic) + \", new host: \" + host);\n+                         + topic2Host.get(pubSubData.topic) + \", new host: \" + host);\n         topic2Host.put(pubSubData.topic, host);\n         if (host2Topics.containsKey(host)) {\n             host2Topics.get(host).add(pubSubData.topic);\n@@ -297,7 +297,7 @@ protected void storeTopic2HostMapping(PubSubData pubSubData, Channel channel) {\n      * Helper static method to get the String Hostname:Port from a netty\n      * Channel. Assumption is that the netty Channel was originally created with\n      * an InetSocketAddress. This is true with the Hedwig netty implementation.\n-     * \n+     *\n      * @param channel\n      *            Netty channel to extract the hostname and port from.\n      * @return String representation of the Hostname:Port from the Netty Channel\n@@ -310,7 +310,7 @@ public static InetSocketAddress getHostFromChannel(Channel channel) {\n      * Helper static method to get the ResponseHandler instance from a Channel\n      * via the ChannelPipeline it is associated with. The assumption is that the\n      * last ChannelHandler tied to the ChannelPipeline is the ResponseHandler.\n-     * \n+     *\n      * @param channel\n      *            Channel we are retrieving the ResponseHandler instance for\n      * @return ResponseHandler Instance tied to the Channel's Pipeline"},{"sha":"e38110749486f1a99207d8ee9a60cf5869f5ec01","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -42,7 +42,7 @@\n \n /**\n  * This is the Hedwig Netty specific implementation of the Publisher interface.\n- * \n+ *\n  */\n public class HedwigPublisher implements Publisher {\n \n@@ -143,7 +143,7 @@ public void asyncPublish(ByteString topic, Message msg, Callback<Void> callback,\n     /**\n      * This is a helper method to write the actual publish message once the\n      * client is connected to the server and a Channel is available.\n-     * \n+     *\n      * @param pubSubData\n      *            Publish call's data wrapper object\n      * @param channel\n@@ -183,7 +183,7 @@ protected void doPublish(PubSubData pubSubData, Channel channel) {\n         // Finally, write the Publish request through the Channel.\n         if (logger.isDebugEnabled())\n             logger.debug(\"Writing a Publish request to host: \" + HedwigClient.getHostFromChannel(channel)\n-                    + \" for pubSubData: \" + pubSubData);\n+                         + \" for pubSubData: \" + pubSubData);\n         ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n         future.addListener(new WriteCallback(pubSubData, client));\n     }"},{"sha":"7b21a4d28f2015200f0f9db8282e85bd356608d0","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -53,7 +53,7 @@\n \n /**\n  * This is the Hedwig Netty specific implementation of the Subscriber interface.\n- * \n+ *\n  */\n public class HedwigSubscriber implements Subscriber {\n \n@@ -79,12 +79,12 @@ public HedwigSubscriber(HedwigClient client) {\n     // two flows are very similar. The assumption is that the input\n     // OperationType is either SUBSCRIBE or UNSUBSCRIBE.\n     private void subUnsub(ByteString topic, ByteString subscriberId, OperationType operationType,\n-            CreateOrAttach createOrAttach) throws CouldNotConnectException, ClientAlreadySubscribedException,\n-            ClientNotSubscribedException, ServiceDownException {\n+                          CreateOrAttach createOrAttach) throws CouldNotConnectException, ClientAlreadySubscribedException,\n+        ClientNotSubscribedException, ServiceDownException {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Calling a sync subUnsub request for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8() + \", operationType: \" + operationType + \", createOrAttach: \"\n-                    + createOrAttach);\n+                         + subscriberId.toStringUtf8() + \", operationType: \" + operationType + \", createOrAttach: \"\n+                         + createOrAttach);\n         PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, createOrAttach, null, null);\n         synchronized (pubSubData) {\n             PubSubCallback pubSubCallback = new PubSubCallback(pubSubData);\n@@ -132,15 +132,15 @@ else if (failureException instanceof ServiceDownException)\n     // flows are very similar. The assumption is that the input OperationType is\n     // either SUBSCRIBE or UNSUBSCRIBE.\n     private void asyncSubUnsub(ByteString topic, ByteString subscriberId, Callback<Void> callback, Object context,\n-            OperationType operationType, CreateOrAttach createOrAttach) {\n+                               OperationType operationType, CreateOrAttach createOrAttach) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Calling an async subUnsub request for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8() + \", operationType: \" + operationType + \", createOrAttach: \"\n-                    + createOrAttach);\n+                         + subscriberId.toStringUtf8() + \", operationType: \" + operationType + \", createOrAttach: \"\n+                         + createOrAttach);\n         // Check if we know which server host is the master for the topic we are\n         // subscribing to.\n         PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, createOrAttach, callback,\n-                context);\n+                                               context);\n         if (client.topic2Host.containsKey(topic)) {\n             InetSocketAddress host = client.topic2Host.get(topic);\n             if (operationType.equals(OperationType.UNSUBSCRIBE) && client.getPublisher().host2Channel.containsKey(host)) {\n@@ -173,18 +173,18 @@ private void asyncSubUnsub(ByteString topic, ByteString subscriberId, Callback<V\n \n     public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n-            InvalidSubscriberIdException {\n+        InvalidSubscriberIdException {\n         subscribe(topic, subscriberId, mode, false);\n     }\n \n     protected void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, boolean isHub)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n-            InvalidSubscriberIdException {\n+        InvalidSubscriberIdException {\n         // Validate that the format of the subscriberId is valid either as a\n         // local or hub subscriber.\n         if (!isValidSubscriberId(subscriberId, isHub)) {\n             throw new InvalidSubscriberIdException(\"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8()\n-                    + \", isHub: \" + isHub);\n+                                                   + \", isHub: \" + isHub);\n         }\n         try {\n             subUnsub(topic, subscriberId, OperationType.SUBSCRIBE, mode);\n@@ -198,35 +198,35 @@ protected void subscribe(ByteString topic, ByteString subscriberId, CreateOrAtta\n     }\n \n     public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n-            Object context) {\n+                               Object context) {\n         asyncSubscribe(topic, subscriberId, mode, callback, context, false);\n     }\n \n     protected void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode,\n-            Callback<Void> callback, Object context, boolean isHub) {\n+                                  Callback<Void> callback, Object context, boolean isHub) {\n         // Validate that the format of the subscriberId is valid either as a\n         // local or hub subscriber.\n         if (!isValidSubscriberId(subscriberId, isHub)) {\n             callback.operationFailed(context, new ServiceDownException(new InvalidSubscriberIdException(\n-                    \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n+                                         \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n             return;\n         }\n         asyncSubUnsub(topic, subscriberId, callback, context, OperationType.SUBSCRIBE, mode);\n     }\n \n     public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n-            ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException {\n+        ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException {\n         unsubscribe(topic, subscriberId, false);\n     }\n \n     protected void unsubscribe(ByteString topic, ByteString subscriberId, boolean isHub)\n             throws CouldNotConnectException, ClientNotSubscribedException, ServiceDownException,\n-            InvalidSubscriberIdException {\n+        InvalidSubscriberIdException {\n         // Validate that the format of the subscriberId is valid either as a\n         // local or hub subscriber.\n         if (!isValidSubscriberId(subscriberId, isHub)) {\n             throw new InvalidSubscriberIdException(\"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8()\n-                    + \", isHub: \" + isHub);\n+                                                   + \", isHub: \" + isHub);\n         }\n         // Synchronously close the subscription on the client side. Even\n         // if the unsubscribe request to the server errors out, we won't be\n@@ -246,17 +246,17 @@ protected void unsubscribe(ByteString topic, ByteString subscriberId, boolean is\n     }\n \n     public void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId, final Callback<Void> callback,\n-            final Object context) {\n+                                 final Object context) {\n         asyncUnsubscribe(topic, subscriberId, callback, context, false);\n     }\n \n     protected void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n-            final Callback<Void> callback, final Object context, boolean isHub) {\n+                                    final Callback<Void> callback, final Object context, boolean isHub) {\n         // Validate that the format of the subscriberId is valid either as a\n         // local or hub subscriber.\n         if (!isValidSubscriberId(subscriberId, isHub)) {\n             callback.operationFailed(context, new ServiceDownException(new InvalidSubscriberIdException(\n-                    \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n+                                         \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n             return;\n         }\n         // Asynchronously close the subscription. On the callback to that\n@@ -288,13 +288,13 @@ public void consume(ByteString topic, ByteString subscriberId, MessageSeqId mess\n             throws ClientNotSubscribedException {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Calling consume for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8() + \", messageSeqId: \" + messageSeqId);\n+                         + subscriberId.toStringUtf8() + \", messageSeqId: \" + messageSeqId);\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n         // Check that this topic subscription on the client side exists.\n         if (!topicSubscriber2Channel.containsKey(topicSubscriber)) {\n             throw new ClientNotSubscribedException(\n-                    \"Cannot send consume message since client is not subscribed to topic: \" + topic.toStringUtf8()\n-                            + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                \"Cannot send consume message since client is not subscribed to topic: \" + topic.toStringUtf8()\n+                + \", subscriberId: \" + subscriberId.toStringUtf8());\n         }\n         PubSubData pubSubData = new PubSubData(topic, null, subscriberId, OperationType.CONSUME, null, null, null);\n         // Send the consume message to the server using the same subscribe\n@@ -305,7 +305,7 @@ public void consume(ByteString topic, ByteString subscriberId, MessageSeqId mess\n     /**\n      * This is a helper method to write the actual subscribe/unsubscribe message\n      * once the client is connected to the server and a Channel is available.\n-     * \n+     *\n      * @param pubSubData\n      *            Subscribe/Unsubscribe call's data wrapper object. We assume\n      *            that the operationType field is either SUBSCRIBE or\n@@ -360,7 +360,7 @@ protected void doSubUnsub(PubSubData pubSubData, Channel channel) {\n         // Finally, write the Subscribe request through the Channel.\n         if (logger.isDebugEnabled())\n             logger.debug(\"Writing a SubUnsub request to host: \" + HedwigClient.getHostFromChannel(channel)\n-                    + \" for pubSubData: \" + pubSubData);\n+                         + \" for pubSubData: \" + pubSubData);\n         ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n         future.addListener(new WriteCallback(pubSubData, client));\n     }\n@@ -369,7 +369,7 @@ protected void doSubUnsub(PubSubData pubSubData, Channel channel) {\n      * This is a helper method to write a consume message to the server after a\n      * subscribe Channel connection is made to the server and messages are being\n      * consumed by the client.\n-     * \n+     *\n      * @param pubSubData\n      *            Consume call's data wrapper object. We assume that the\n      *            operationType field is CONSUME.\n@@ -405,22 +405,22 @@ public void doConsume(final PubSubData pubSubData, final Channel channel, final\n         // message if there was a problem writing the consume request.\n         if (logger.isDebugEnabled())\n             logger.debug(\"Writing a Consume request to host: \" + HedwigClient.getHostFromChannel(channel)\n-                    + \" with messageSeqId: \" + messageSeqId + \" for pubSubData: \" + pubSubData);\n+                         + \" with messageSeqId: \" + messageSeqId + \" for pubSubData: \" + pubSubData);\n         ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n         future.addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) throws Exception {\n                 if (!future.isSuccess()) {\n                     logger.error(\"Error writing a Consume request to host: \" + HedwigClient.getHostFromChannel(channel)\n-                            + \" with messageSeqId: \" + messageSeqId + \" for pubSubData: \" + pubSubData);                    \n+                                 + \" with messageSeqId: \" + messageSeqId + \" for pubSubData: \" + pubSubData);\n                 }\n             }\n         });\n \n     }\n \n     public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n-            ServiceDownException {\n+        ServiceDownException {\n         // The subscription type of info should be stored on the server end, not\n         // the client side. Eventually, the server will have the Subscription\n         // Manager part that ties into Zookeeper to manage this info.\n@@ -433,7 +433,7 @@ public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws\n     }\n \n     public List<ByteString> getSubscriptionList(ByteString subscriberId) throws CouldNotConnectException,\n-            ServiceDownException {\n+        ServiceDownException {\n         // Same as the previous hasSubscription method, this data should reside\n         // on the server end, not the client side.\n         return null;\n@@ -443,24 +443,24 @@ public void startDelivery(final ByteString topic, final ByteString subscriberId,\n             throws ClientNotSubscribedException {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Starting delivery for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8());\n+                         + subscriberId.toStringUtf8());\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n         // Make sure we know about this topic subscription on the client side\n         // exists. The assumption is that the client should have in memory the\n         // Channel created for the TopicSubscriber once the server has sent\n         // an ack response to the initial subscribe request.\n         if (!topicSubscriber2Channel.containsKey(topicSubscriber)) {\n             logger.error(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8());\n+                         + subscriberId.toStringUtf8());\n             throw new ClientNotSubscribedException(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8()\n-                    + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                                                   + \", subscriberId: \" + subscriberId.toStringUtf8());\n         }\n \n         // Register the MessageHandler with the subscribe Channel's\n         // Response Handler.\n         Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n         HedwigClient.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n-                .setMessageHandler(messageHandler);\n+        .setMessageHandler(messageHandler);\n         // Now make the TopicSubscriber Channel readable (it is set to not be\n         // readable when the initial subscription is done). Note that this is an\n         // asynchronous call. If this fails (not likely), the futureListener\n@@ -471,7 +471,7 @@ public void startDelivery(final ByteString topic, final ByteString subscriberId,\n             public void operationComplete(ChannelFuture future) throws Exception {\n                 if (!future.isSuccess()) {\n                     logger.error(\"Unable to make subscriber Channel readable in startDelivery call for topic: \"\n-                            + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                                 + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n                 }\n             }\n         });\n@@ -480,24 +480,24 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     public void stopDelivery(final ByteString topic, final ByteString subscriberId) throws ClientNotSubscribedException {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Stopping delivery for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8());\n+                         + subscriberId.toStringUtf8());\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n         // Make sure we know that this topic subscription on the client side\n         // exists. The assumption is that the client should have in memory the\n         // Channel created for the TopicSubscriber once the server has sent\n         // an ack response to the initial subscribe request.\n         if (!topicSubscriber2Channel.containsKey(topicSubscriber)) {\n             logger.error(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8());\n+                         + subscriberId.toStringUtf8());\n             throw new ClientNotSubscribedException(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8()\n-                    + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                                                   + \", subscriberId: \" + subscriberId.toStringUtf8());\n         }\n \n         // Unregister the MessageHandler for the subscribe Channel's\n         // Response Handler.\n         Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n         HedwigClient.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n-                .setMessageHandler(null);\n+        .setMessageHandler(null);\n         // Now make the TopicSubscriber channel not-readable. This will buffer\n         // up messages if any are sent from the server. Note that this is an\n         // asynchronous call. If this fails (not likely), the futureListener\n@@ -508,7 +508,7 @@ public void stopDelivery(final ByteString topic, final ByteString subscriberId)\n             public void operationComplete(ChannelFuture future) throws Exception {\n                 if (!future.isSuccess()) {\n                     logger.error(\"Unable to make subscriber Channel not readable in stopDelivery call for topic: \"\n-                            + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                                 + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n                 }\n             }\n         });\n@@ -528,16 +528,16 @@ public void closeSubscription(ByteString topic, ByteString subscriberId) throws\n             // Check from the PubSubCallback if it was successful or not.\n             if (!pubSubCallback.getIsCallSuccessful()) {\n                 throw new ServiceDownException(\"Exception while trying to close the subscription for topic: \"\n-                        + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                                               + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n             }\n         }\n     }\n \n     public void asyncCloseSubscription(final ByteString topic, final ByteString subscriberId,\n-            final Callback<Void> callback, final Object context) {\n+                                       final Callback<Void> callback, final Object context) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Closing subscription asynchronously for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                    + subscriberId.toStringUtf8());\n+                         + subscriberId.toStringUtf8());\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n         if (topicSubscriber2Channel.containsKey(topicSubscriber)) {\n             // Remove all cached references for the TopicSubscriber\n@@ -551,18 +551,18 @@ public void asyncCloseSubscription(final ByteString topic, final ByteString subs\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (!future.isSuccess()) {\n                         logger.error(\"Failed to close the subscription channel for topic: \" + topic.toStringUtf8()\n-                                + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                                     + \", subscriberId: \" + subscriberId.toStringUtf8());\n                         callback.operationFailed(context, new ServiceDownException(\n-                                \"Failed to close the subscription channel for topic: \" + topic.toStringUtf8()\n-                                        + \", subscriberId: \" + subscriberId.toStringUtf8()));\n+                                                     \"Failed to close the subscription channel for topic: \" + topic.toStringUtf8()\n+                                                     + \", subscriberId: \" + subscriberId.toStringUtf8()));\n                     } else {\n                         callback.operationFinished(context, null);\n                     }\n                 }\n             });\n         } else {\n             logger.warn(\"Trying to close a subscription when we don't have a subscribe channel cached for topic: \"\n-                    + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                        + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n             callback.operationFinished(context, null);\n         }\n     }"},{"sha":"378bb19114dd8f20eac05891f784bcdff148da78","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","status":"modified","additions":14,"deletions":14,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -113,7 +113,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n         PubSubResponse response = (PubSubResponse) e.getMessage();\n         if (logger.isDebugEnabled())\n             logger.debug(\"Response received from host: \" + HedwigClient.getHostFromChannel(ctx.getChannel())\n-                    + \", response: \" + response);\n+                         + \", response: \" + response);\n \n         // Determine if this PubSubResponse is an ack response for a PubSub\n         // Request or if it is a message being pushed to the client subscriber.\n@@ -127,7 +127,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n         // Response is an ack to a prior PubSubRequest so first retrieve the\n         // PubSub data for this txn.\n         PubSubData pubSubData = txn2PubSubData.containsKey(response.getTxnId()) ? txn2PubSubData.get(response\n-                .getTxnId()) : null;\n+                                .getTxnId()) : null;\n         // Validate that the PubSub data for this txn is stored. If not, just\n         // log an error message and return since we don't know how to handle\n         // this.\n@@ -163,14 +163,14 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n             // The above are the only expected PubSubResponse messages received\n             // from the server for the various client side requests made.\n             logger.error(\"Response received from server is for an unhandled operation type, txnId: \"\n-                    + response.getTxnId() + \", operationType: \" + pubSubData.operationType);\n+                         + response.getTxnId() + \", operationType: \" + pubSubData.operationType);\n         }\n     }\n \n     /**\n      * Logic to repost a PubSubRequest when the server responds with a redirect\n      * indicating they are not the topic master.\n-     * \n+     *\n      * @param response\n      *            PubSubResponse from the server for the redirect\n      * @param pubSubData\n@@ -185,7 +185,7 @@ public void handleRedirectResponse(PubSubResponse response, PubSubData pubSubDat\n             throws Exception {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Handling a redirect from host: \" + HedwigClient.getHostFromChannel(channel) + \", response: \"\n-                    + response + \", pubSubData: \" + pubSubData);\n+                         + response + \", pubSubData: \" + pubSubData);\n         // In this case, the PubSub request was done to a server that is not\n         // responsible for the topic. First make sure that we haven't\n         // exceeded the maximum number of server redirects.\n@@ -197,16 +197,16 @@ public void handleRedirectResponse(PubSubResponse response, PubSubData pubSubDat\n             if (logger.isDebugEnabled())\n                 logger.debug(\"Exceeded the number of server redirects (\" + curNumServerRedirects + \") so error out.\");\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    new TooManyServerRedirectsException(\"Already reached max number of redirects: \"\n-                            + curNumServerRedirects)));\n+                                                    new TooManyServerRedirectsException(\"Already reached max number of redirects: \"\n+                                                            + curNumServerRedirects)));\n             return;\n         }\n \n         // We will redirect and try to connect to the correct server\n         // stored in the StatusMsg of the response. First store the\n         // server that we sent the PubSub request to for the topic.\n         ByteString triedServer = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(HedwigClient\n-                .getHostFromChannel(channel)));\n+                                 .getHostFromChannel(channel)));\n         if (pubSubData.triedServers == null)\n             pubSubData.triedServers = new LinkedList<ByteString>();\n         pubSubData.shouldClaim = true;\n@@ -232,10 +232,10 @@ public void handleRedirectResponse(PubSubResponse response, PubSubData pubSubDat\n         // already before in this PubSub request.\n         if (pubSubData.triedServers.contains(ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(redirectedHost)))) {\n             logger.error(\"We've already sent this PubSubRequest before to redirectedHost: \" + redirectedHost\n-                    + \", pubSubData: \" + pubSubData);\n+                         + \", pubSubData: \" + pubSubData);\n             pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                    new ServerRedirectLoopException(\"Already made the request before to redirected host: \"\n-                            + redirectedHost)));\n+                                                    new ServerRedirectLoopException(\"Already made the request before to redirected host: \"\n+                                                            + redirectedHost)));\n             return;\n         }\n \n@@ -297,7 +297,7 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n             if (pub.host2Channel.containsKey(host) && pub.host2Channel.get(host).equals(ctx.getChannel())) {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Disconnected channel for host: \" + host\n-                            + \" was for Publish/Unsubscribe requests so remove all references to it.\");\n+                                 + \" was for Publish/Unsubscribe requests so remove all references to it.\");\n                 pub.host2Channel.remove(host);\n                 client.clearAllTopicsForHost(host);\n             }\n@@ -333,9 +333,9 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n         for (PubSubData pubSubData : txn2PubSubData.values()) {\n             if (logger.isDebugEnabled())\n                 logger.debug(\"Channel disconnected so invoking the operationFailed callback for pubSubData: \"\n-                        + pubSubData);\n+                             + pubSubData);\n             pubSubData.callback.operationFailed(pubSubData.context, new UncertainStateException(\n-                    \"Server ack response never received before server connection disconnected!\"));\n+                                                    \"Server ack response never received before server connection disconnected!\"));\n         }\n         txn2PubSubData.clear();\n     }"},{"sha":"a8cac77abb02f60b69a9ef25f4e9c3de4c9218b8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -52,7 +52,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         // with any callback logic here.\n         if (client.hasStopped())\n             return;\n-        \n+\n         // When the write operation to the server is done, we just need to check\n         // if it was successful or not.\n         InetSocketAddress host = HedwigClient.getHostFromChannel(future.getChannel());\n@@ -73,11 +73,11 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 // failed, so invoke the operationFailed callback.\n                 logger.error(\"Error writing to host more than once so just invoke the operationFailed callback!\");\n                 pubSubData.callback.operationFailed(pubSubData.context, new ServiceDownException(\n-                        \"Error while writing message to server: \" + hostString));\n+                                                        \"Error while writing message to server: \" + hostString));\n             } else {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Try to send the PubSubRequest again to the default server host/VIP for pubSubData: \"\n-                            + pubSubData);\n+                                 + pubSubData);\n                 // Keep track of this current server that we failed to write to\n                 // but retry the request on the default server host/VIP.\n                 if (pubSubData.writeFailedServers == null)"},{"sha":"33c5a53bd3afa6888ecb13690dd0967d0bf5e0a8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","status":"modified","additions":14,"deletions":13,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -43,23 +43,24 @@ public SSLEngine getEngine() {\n \n     protected TrustManager[] getTrustManagers() {\n         return new TrustManager[] { new X509TrustManager() {\n-            // Always trust, even if invalid.\n+                // Always trust, even if invalid.\n \n-            @Override\n-            public X509Certificate[] getAcceptedIssuers() {\n-                return new X509Certificate[0];\n-            }\n+                @Override\n+                public X509Certificate[] getAcceptedIssuers() {\n+                    return new X509Certificate[0];\n+                }\n \n-            @Override\n-            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n-                // Always trust.\n-            }\n+                @Override\n+                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n+                    // Always trust.\n+                }\n \n-            @Override\n-            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n-                // Always trust.\n+                @Override\n+                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n+                    // Always trust.\n+                }\n             }\n-        } };\n+        };\n     }\n \n }"},{"sha":"c0baaf4858e407ba37f5c9830aa9382c6386fbf8","filename":"hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -34,7 +34,7 @@ protected AbstractConfiguration() {\n     /**\n      * You can load configurations in precedence order. The first one takes\n      * precedence over any loaded later.\n-     * \n+     *\n      * @param confURL\n      */\n     public void loadConf(URL confURL) throws ConfigurationException {"},{"sha":"78deef1de2f2ecb8853a5cf4b3ae7717d70b2b01","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -21,13 +21,13 @@\n \n /**\n  * This class is used for callbacks for asynchronous operations\n- * \n+ *\n  */\n public interface Callback<T> {\n \n     /**\n      * This method is called when the asynchronous operation finishes\n-     * \n+     *\n      * @param ctx\n      * @param resultOfOperation\n      */\n@@ -36,12 +36,12 @@\n     /**\n      * This method is called when the operation failed due to some reason. The\n      * reason for failure is passed in.\n-     * \n+     *\n      * @param ctx\n      *            The context for the callback\n      * @param exception\n      *            The reason for the failure of the scan\n      */\n     public abstract void operationFailed(Object ctx, PubSubException exception);\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"c90e0e62993f97d7e4601d17f3639d4da63714d6","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -31,10 +31,10 @@\n     /**\n      * A callback that waits for all of a number of events to fire. If any fail,\n      * then fail the final callback with a composite exception.\n-     * \n+     *\n      * TODO: change this to use any Exception and make CompositeException\n      * generic, not a PubSubException.\n-     * \n+     *\n      * @param expected\n      *            Number of expected callbacks.\n      * @param cb\n@@ -135,7 +135,7 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n      * Logs what happened before continuing the callback chain.\n      */\n     public static <T> Callback<T> logger(final Logger logger, final Level successLevel, final Level failureLevel, final Object successMsg,\n-            final Object failureMsg, final Callback<T> cont) {\n+                                         final Object failureMsg, final Callback<T> cont) {\n         return new Callback<T>() {\n \n             @Override"},{"sha":"08b8c6773a299e33a1bd573231445901f4f88f39","filename":"hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -27,7 +27,7 @@\n public class AppTest extends TestCase {\n     /**\n      * Create the test case\n-     * \n+     *\n      * @param testName\n      *            name of the test case\n      */"},{"sha":"c8858c89c1ffbe3be7e85606b873d681e78b1382","filename":"hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -31,7 +31,7 @@\n     private int sslPort = 9876;\n     private int invalidPort = -9999;\n     private String COLON = \":\";\n-    \n+\n     @Test\n     public void testCreateWithSSLPort() throws Exception {\n         HedwigSocketAddress addr = new HedwigSocketAddress(hostname, port, sslPort);\n@@ -51,15 +51,15 @@ public void testCreateFromStringWithSSLPort() throws Exception {\n         HedwigSocketAddress addr = new HedwigSocketAddress(hostname+COLON+port+COLON+sslPort);\n         assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname, port)));\n         assertTrue(addr.getSSLSocketAddress().equals(new InetSocketAddress(hostname, sslPort)));\n-    }    \n+    }\n \n     @Test\n     public void testCreateFromStringWithNoSSLPort() throws Exception {\n         HedwigSocketAddress addr = new HedwigSocketAddress(hostname+COLON+port);\n         assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname, port)));\n         assertTrue(addr.getSSLSocketAddress() == null);\n     }\n-    \n+\n     @Test\n     public void testCreateWithInvalidRegularPort() throws Exception {\n         boolean success = false;\n@@ -70,7 +70,7 @@ public void testCreateWithInvalidRegularPort() throws Exception {\n             success = true;\n         }\n         assertTrue(success);\n-    }    \n+    }\n \n     @Test\n     public void testCreateWithInvalidSSLPort() throws Exception {\n@@ -82,7 +82,7 @@ public void testCreateWithInvalidSSLPort() throws Exception {\n             success = true;\n         }\n         assertTrue(success);\n-    }    \n+    }\n \n     @Test\n     public void testToStringConversion() throws Exception {\n@@ -98,7 +98,7 @@ public void testIsSSLEnabledFlag() throws Exception {\n         HedwigSocketAddress sslAddr = new HedwigSocketAddress(hostname, port, sslPort);\n         assertTrue(sslAddr.isSSLEnabled());\n         HedwigSocketAddress addr = new HedwigSocketAddress(hostname, port);\n-        assertFalse(addr.isSSLEnabled());               \n+        assertFalse(addr.isSSLEnabled());\n     }\n-    \n+\n }"},{"sha":"5cbd31862e30a8355138c169ab80b6a921f93254","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -135,7 +135,7 @@ public UnexpectedConditionException(String msg) {\n             super(StatusCode.UNEXPECTED_CONDITION, msg);\n         }\n     }\n-    \n+\n     // The composite exception (for concurrent operations).\n     public static class CompositeException extends PubSubException {\n         private final Collection<PubSubException> exceptions;"},{"sha":"f46868babc285d9c600b1dfa24eed5d9b2b13f63","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":6267,"deletions":5995,"changes":12262,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10"},{"sha":"9ceec26e1cdda6b5c876d8f05e37ef52031f5a4f","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -93,7 +93,7 @@ public static Message mergeLocalSeqId(Message orginalMessage, long localSeqId) {\n \n     /**\n      * Compares two seq numbers represented as lists of longs.\n-     * \n+     *\n      * @param l1\n      * @param l2\n      * @return 1 if the l1 is greater, 0 if they are equal, -1 if l2 is greater\n@@ -103,7 +103,7 @@ public static Message mergeLocalSeqId(Message orginalMessage, long localSeqId) {\n     public static int compare(List<Long> l1, List<Long> l2) throws UnexpectedConditionException {\n         if (l1.size() != l2.size()) {\n             throw new UnexpectedConditionException(\"Seq-ids being compared have different sizes: \" + l1.size()\n-                    + \" and \" + l2.size());\n+                                                   + \" and \" + l2.size());\n         }\n \n         for (int i = 0; i < l1.size(); i++) {"},{"sha":"2afc169a31912fbb8e14dee5190455111cdc93e2","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -37,5 +37,5 @@ public static String toString(SubscriptionState state) {\n     public static boolean isHubSubscriber(ByteString subscriberId) {\n         return subscriberId.toStringUtf8().startsWith(HUB_SUBSCRIBER_PREFIX);\n     }\n-    \n+\n }"},{"sha":"cd2d65e67d3347caca41eb13b4aad413ddcd1554","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,77 +28,77 @@\n \n public abstract class AbstractBenchmark {\n \n-\tstatic final Logger logger = Logger.getLogger(AbstractBenchmark.class);\n-    \n-\tAtomicLong totalLatency = new AtomicLong();\n+    static final Logger logger = Logger.getLogger(AbstractBenchmark.class);\n+\n+    AtomicLong totalLatency = new AtomicLong();\n     LinkedBlockingQueue<Boolean> doneSignalQueue = new LinkedBlockingQueue<Boolean>();\n \n     abstract void doOps(int numOps) throws Exception;\n-\tabstract void tearDown() throws Exception;\n-    \n-\tprotected class AbstractCallback{\n-\t\tAtomicInteger numDone = new AtomicInteger(0);\n-\t\tSemaphore outstanding;\n-\t\tint numOps;\n-\t\tboolean logging;\n-\t\t\n-\t\tpublic AbstractCallback(Semaphore outstanding, int numOps) {\n-\t\t\tthis.outstanding = outstanding;\n-\t\t\tthis.numOps = numOps;\n-\t\t\tlogging = Boolean.getBoolean(\"progress\");\n-\t\t}\n-    \t\n-\t\tpublic void handle(boolean success, Object ctx){\n+    abstract void tearDown() throws Exception;\n+\n+    protected class AbstractCallback {\n+        AtomicInteger numDone = new AtomicInteger(0);\n+        Semaphore outstanding;\n+        int numOps;\n+        boolean logging;\n+\n+        public AbstractCallback(Semaphore outstanding, int numOps) {\n+            this.outstanding = outstanding;\n+            this.numOps = numOps;\n+            logging = Boolean.getBoolean(\"progress\");\n+        }\n+\n+        public void handle(boolean success, Object ctx) {\n             outstanding.release();\n-            \n-            if (!success){\n+\n+            if (!success) {\n                 ConcurrencyUtils.put(doneSignalQueue, false);\n                 return;\n             }\n-            \n+\n             totalLatency.addAndGet(System.currentTimeMillis() - (Long)ctx);\n             int numDoneInt = numDone.incrementAndGet();\n-            \n-            if (logging && numDoneInt % 10000 == 0){\n+\n+            if (logging && numDoneInt % 10000 == 0) {\n                 logger.info(\"Finished \" + numDoneInt + \" ops\");\n             }\n-            \n-            if (numOps == numDoneInt){\n+\n+            if (numOps == numDoneInt) {\n                 ConcurrencyUtils.put(doneSignalQueue, true);\n-            }   \n+            }\n         }\n-\t}\n-\t\n-\tpublic void runPhase(String phase, int numOps) throws Exception{\n+    }\n+\n+    public void runPhase(String phase, int numOps) throws Exception {\n         long startTime = System.currentTimeMillis();\n-        \n+\n         doOps(numOps);\n-        \n-        if (!doneSignalQueue.take()){\n-        \tlogger.error(\"One or more operations failed in phase: \" + phase);\n-        \tthrow new RuntimeException();\n-        }else{\n+\n+        if (!doneSignalQueue.take()) {\n+            logger.error(\"One or more operations failed in phase: \" + phase);\n+            throw new RuntimeException();\n+        } else {\n             logger.info(\"Phase: \" + phase + \" Avg latency : \" + totalLatency.get() / numOps + \", tput = \" + (numOps * 1000/ (System.currentTimeMillis() - startTime)));\n         }\n-\t}\n-\t\n-\t\n-\t\n-\t\n-\n-\tpublic void run() throws Exception{\n-        \n+    }\n+\n+\n+\n+\n+\n+    public void run() throws Exception {\n+\n         int numWarmup = Integer.getInteger(\"nWarmup\", 50000);\n-    \trunPhase(\"warmup\", numWarmup);\n-        \n-    \tlogger.info(\"Sleeping for 10 seconds\");\n-    \tThread.sleep(10000);\n+        runPhase(\"warmup\", numWarmup);\n+\n+        logger.info(\"Sleeping for 10 seconds\");\n+        Thread.sleep(10000);\n         //reset latency\n         totalLatency.set(0);\n-        \n+\n         int numOps = Integer.getInteger(\"nOps\", 400000);\n         runPhase(\"real\", numOps);\n \n         tearDown();\n-\t}\n+    }\n }"},{"sha":"18319d73dd7a4807e1111e68e48add61abc93b07","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -31,70 +31,70 @@\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n-public class BookieBenchmark extends AbstractBenchmark{\n-    \n+public class BookieBenchmark extends AbstractBenchmark {\n+\n     static final Logger logger = Logger.getLogger(BookkeeperBenchmark.class);\n-    \n+\n     BookieClient bkc;\n     InetSocketAddress addr;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor = new OrderedSafeExecutor(1);\n-    \n-    \n-    public BookieBenchmark(String bookieHostPort)  throws Exception{\n-    \tchannelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());\n-    \tbkc = new BookieClient(channelFactory, executor);\n-    \tString[] hostPort = bookieHostPort.split(\":\");\n+\n+\n+    public BookieBenchmark(String bookieHostPort)  throws Exception {\n+        channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());\n+        bkc = new BookieClient(channelFactory, executor);\n+        String[] hostPort = bookieHostPort.split(\":\");\n         addr = new InetSocketAddress(hostPort[0], Integer.parseInt(hostPort[1]));\n-        \n+\n     }\n-    \n-    \n+\n+\n     @Override\n-\tvoid doOps(final int numOps) throws Exception{\n-    \tint numOutstanding = Integer.getInteger(\"nPars\",1000);\n+    void doOps(final int numOps) throws Exception {\n+        int numOutstanding = Integer.getInteger(\"nPars\",1000);\n         final Semaphore outstanding = new Semaphore(numOutstanding);\n-        \n-        \n+\n+\n         WriteCallback callback = new WriteCallback() {\n-        \tAbstractCallback handler = new AbstractCallback(outstanding, numOps);\n-        \t\n-        \t@Override\n+            AbstractCallback handler = new AbstractCallback(outstanding, numOps);\n+\n+            @Override\n             public void writeComplete(int rc, long ledgerId, long entryId,\n-            \t\tInetSocketAddress addr, Object ctx) {\n-                handler.handle(rc == BKException.Code.OK, ctx);   \n+            InetSocketAddress addr, Object ctx) {\n+                handler.handle(rc == BKException.Code.OK, ctx);\n             }\n         };\n-        \n-    \tbyte[] passwd = new byte[20];\n-    \tint size = Integer.getInteger(\"size\", 1024);\n+\n+        byte[] passwd = new byte[20];\n+        int size = Integer.getInteger(\"size\", 1024);\n         byte[] data = new byte[size];\n-    \t\n-    \tfor (int i=0; i<numOps; i++){\n-        \toutstanding.acquire();\n-            \n-        \tByteBuffer buffer = ByteBuffer.allocate(44);\n-        \tlong ledgerId = 1000;\n-        \tbuffer.putLong(ledgerId);\n+\n+        for (int i=0; i<numOps; i++) {\n+            outstanding.acquire();\n+\n+            ByteBuffer buffer = ByteBuffer.allocate(44);\n+            long ledgerId = 1000;\n+            buffer.putLong(ledgerId);\n             buffer.putLong(i);\n-        \tbuffer.putLong(0);\n-        \tbuffer.put(passwd);\n+            buffer.putLong(0);\n+            buffer.put(passwd);\n             buffer.rewind();\n             ChannelBuffer toSend = ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer.slice()), ChannelBuffers.wrappedBuffer(data));\n-            bkc.addEntry(addr, ledgerId, passwd, i, toSend, callback, System.currentTimeMillis());            \n+            bkc.addEntry(addr, ledgerId, passwd, i, toSend, callback, System.currentTimeMillis());\n         }\n \n     }\n-    \n+\n     @Override\n-\tpublic void tearDown(){        \n+    public void tearDown() {\n         bkc.close();\n         channelFactory.releaseExternalResources();\n         executor.shutdown();\n     }\n-    \n-    \n-    public static void main(String[] args) throws Exception{\n+\n+\n+    public static void main(String[] args) throws Exception {\n         BookieBenchmark benchmark = new BookieBenchmark(args[0]);\n         benchmark.run();\n     }"},{"sha":"a934985aeeffc3cce5af3b165f826b4017dd3f59","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -26,65 +26,65 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.log4j.Logger;\n \n-public class BookkeeperBenchmark extends AbstractBenchmark{\n-    \n+public class BookkeeperBenchmark extends AbstractBenchmark {\n+\n     static final Logger logger = Logger.getLogger(BookkeeperBenchmark.class);\n-    \n+\n     BookKeeper bk;\n     LedgerHandle[] lh;\n-    \n-    public BookkeeperBenchmark(String zkHostPort) throws Exception{\n+\n+    public BookkeeperBenchmark(String zkHostPort) throws Exception {\n         bk = new BookKeeper(zkHostPort);\n         int numLedgers = Integer.getInteger(\"nLedgers\",5);\n         lh = new LedgerHandle[numLedgers];\n         int quorumSize = Integer.getInteger(\"quorum\", 2);\n         int ensembleSize = Integer.getInteger(\"ensemble\", 4);\n         DigestType digestType = DigestType.valueOf(System.getProperty(\"digestType\", \"CRC32\"));\n-        for (int i=0; i< numLedgers; i++){\n+        for (int i=0; i< numLedgers; i++) {\n             lh[i] = bk.createLedger(ensembleSize, quorumSize, digestType, \"blah\".getBytes());\n         }\n-        \n+\n     }\n-    \n-    \n+\n+\n     @Override\n     void doOps(final int numOps) throws Exception {\n-    \tint size = Integer.getInteger(\"size\", 1024);\n-    \tbyte[] msg = new byte[size];\n-        \n-    \tint numOutstanding = Integer.getInteger(\"nPars\",1000);\n+        int size = Integer.getInteger(\"size\", 1024);\n+        byte[] msg = new byte[size];\n+\n+        int numOutstanding = Integer.getInteger(\"nPars\",1000);\n         final Semaphore outstanding = new Semaphore(numOutstanding);\n \n         AddCallback callback = new AddCallback() {\n-            \tAbstractCallback handler = new AbstractCallback(outstanding, numOps);\n-            \t\n+            AbstractCallback handler = new AbstractCallback(outstanding, numOps);\n \n-        \t@Override\n+\n+            @Override\n             public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-                handler.handle(rc == BKException.Code.OK, ctx);   \n-        \t}\n-        \t\t\t\t\n-\t\t};\n+                handler.handle(rc == BKException.Code.OK, ctx);\n+            }\n+\n+        };\n+\n+\n \n-        \n-        \n         Random rand = new Random();\n-    \t\n-    \tfor (int i=0; i<numOps; i++){\n+\n+        for (int i=0; i<numOps; i++) {\n             outstanding.acquire();\n             lh[rand.nextInt(lh.length)].asyncAddEntry(msg, callback, System.currentTimeMillis());\n         }\n-        \n-    \t\n+\n+\n     }\n- \n+\n     @Override\n-\tpublic void tearDown() throws Exception{\n+    public void tearDown() throws Exception {\n         bk.halt();\n     }\n-    \n-    \n-    public static void main(String[] args) throws Exception{\n+\n+\n+    public static void main(String[] args) throws Exception {\n         BookkeeperBenchmark benchmark = new BookkeeperBenchmark(args[0]);\n         benchmark.run();\n     }"},{"sha":"a394d056961a82624f20dd38fbda1023fb300b94","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -39,62 +39,62 @@\n \n @ChannelPipelineCoverage(\"all\")\n public class FakeBookie extends SimpleChannelHandler implements\n-\t\tChannelPipelineFactory {\n-\tstatic final Logger logger = Logger.getLogger(FakeBookie.class);\n-\tServerSocketChannelFactory serverChannelFactory = new NioServerSocketChannelFactory(\n-\t\t\tExecutors.newCachedThreadPool(), Executors.newCachedThreadPool());\n+    ChannelPipelineFactory {\n+    static final Logger logger = Logger.getLogger(FakeBookie.class);\n+    ServerSocketChannelFactory serverChannelFactory = new NioServerSocketChannelFactory(\n+        Executors.newCachedThreadPool(), Executors.newCachedThreadPool());\n \n-\tpublic FakeBookie(int port) {\n-\t\tInternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n-\t\tServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n+    public FakeBookie(int port) {\n+        InternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n+        ServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n \n-\t\tbootstrap.setPipelineFactory(this);\n-\t\tbootstrap.setOption(\"child.tcpNoDelay\", true);\n-\t\tbootstrap.setOption(\"child.keepAlive\", true);\n-\t\tbootstrap.setOption(\"reuseAddress\", true);\n+        bootstrap.setPipelineFactory(this);\n+        bootstrap.setOption(\"child.tcpNoDelay\", true);\n+        bootstrap.setOption(\"child.keepAlive\", true);\n+        bootstrap.setOption(\"reuseAddress\", true);\n \n-\t\tlogger.info(\"Going into receive loop\");\n-\t\t// Bind and start to accept incoming connections.\n-\t\tbootstrap.bind(new InetSocketAddress(port));\n-\t}\n+        logger.info(\"Going into receive loop\");\n+        // Bind and start to accept incoming connections.\n+        bootstrap.bind(new InetSocketAddress(port));\n+    }\n \n-\t@Override\n-\tpublic ChannelPipeline getPipeline() throws Exception {\n-\t\tChannelPipeline pipeline = Channels.pipeline();\n-\t\tpipeline.addLast(\"lengthbaseddecoder\",\n-\t\t\t\tnew LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));\n-\t\tpipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n-\t\tpipeline.addLast(\"main\", this);\n-\t\treturn pipeline;\n-\t}\n+    @Override\n+    public ChannelPipeline getPipeline() throws Exception {\n+        ChannelPipeline pipeline = Channels.pipeline();\n+        pipeline.addLast(\"lengthbaseddecoder\",\n+                         new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));\n+        pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+        pipeline.addLast(\"main\", this);\n+        return pipeline;\n+    }\n \n-\t@Override\n-\tpublic void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n-\t\t\tthrows Exception {\n-\t\tif (!(e.getMessage() instanceof ChannelBuffer)) {\n-\t\t\tctx.sendUpstream(e);\n-\t\t\treturn;\n-\t\t}\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n+            throws Exception {\n+        if (!(e.getMessage() instanceof ChannelBuffer)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n \n-\t\tChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n+        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n \n-\t\tint type = buffer.readInt();\n-\t\tbuffer.readerIndex(24);\n-\t\tlong ledgerId = buffer.readLong();\n-\t\tlong entryId = buffer.readLong();\n+        int type = buffer.readInt();\n+        buffer.readerIndex(24);\n+        long ledgerId = buffer.readLong();\n+        long entryId = buffer.readLong();\n \n-\t\tChannelBuffer outBuf = ctx.getChannel().getConfig().getBufferFactory()\n-\t\t\t\t.getBuffer(24);\n-\t\toutBuf.writeInt(type);\n-\t\toutBuf.writeInt(0); // rc\n-\t\toutBuf.writeLong(ledgerId);\n-\t\toutBuf.writeLong(entryId);\n-\t\te.getChannel().write(outBuf);\n+        ChannelBuffer outBuf = ctx.getChannel().getConfig().getBufferFactory()\n+                               .getBuffer(24);\n+        outBuf.writeInt(type);\n+        outBuf.writeInt(0); // rc\n+        outBuf.writeLong(ledgerId);\n+        outBuf.writeLong(entryId);\n+        e.getChannel().write(outBuf);\n \n-\t}\n+    }\n \n-\t\n-\tpublic static void main(String args[]){\n-\t\tnew FakeBookie(Integer.parseInt(args[0]));\n-\t}\n+\n+    public static void main(String args[]) {\n+        new FakeBookie(Integer.parseInt(args[0]));\n+    }\n }"},{"sha":"3a8e8ca878b64cccd0f9ac127e06166cfd4de3b7","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -281,7 +281,7 @@ public void validate() throws ConfigurationException {\n         // Validate that the Bookkeeper ensemble size >= quorum size.\n         if (getBkEnsembleSize() < getBkQuorumSize()) {\n             throw new ConfigurationException(\"BK ensemble size (\" + getBkEnsembleSize()\n-                    + \") is less than the quorum size (\" + getBkQuorumSize() + \")\");\n+                                             + \") is less than the quorum size (\" + getBkQuorumSize() + \")\");\n         }\n \n         // add other checks here"},{"sha":"364ffdc766ed00abde16c049e35613ac7c48c1da","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -20,7 +20,7 @@\n public class UnexpectedError extends Error {\n \n     /**\n-     * \n+     *\n      */\n     private static final long serialVersionUID = 1L;\n "},{"sha":"f4db619133de60b1a8466d607e28e32e97d5a1d9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -23,7 +23,7 @@\n \n public interface DeliveryManager {\n     public void startServingSubscription(ByteString topic, ByteString subscriberId, MessageSeqId seqIdToStartFrom,\n-            DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber);\n+                                         DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber);\n \n     public void stopServingSubscriber(ByteString topic, ByteString subscriberId);\n }"},{"sha":"af3d12e22b7c5c2a18a2fe5f34fe4cdfd493a1ef","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":32,"deletions":32,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -100,7 +100,7 @@ public FIFODeliveryManager(PersistenceManager persistenceMgr, ServerConfiguratio\n      * ===================================================================== Our\n      * usual enqueue function, stop if error because of unbounded queue, should\n      * never happen\n-     * \n+     *\n      */\n     protected void enqueueWithoutFailure(DeliveryManagerRequest request) {\n         if (!requestQueue.offer(request)) {\n@@ -116,7 +116,7 @@ protected void enqueueWithoutFailure(DeliveryManagerRequest request) {\n     /**\n      * Tells the delivery manager to start sending out messages for a particular\n      * subscription\n-     * \n+     *\n      * @param topic\n      * @param subscriberId\n      * @param seqIdToStartFrom\n@@ -131,7 +131,7 @@ protected void enqueueWithoutFailure(DeliveryManagerRequest request) {\n      *            should send only a subset of the seq-id vector\n      */\n     public void startServingSubscription(ByteString topic, ByteString subscriberId, MessageSeqId seqIdToStartFrom,\n-            DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber) {\n+                                         DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber) {\n \n         ActiveSubscriberState subscriber = new ActiveSubscriberState(topic, subscriberId, seqIdToStartFrom\n                 .getLocalComponent() - 1, endPoint, filter, isHubSubscriber);\n@@ -150,7 +150,7 @@ public void stopServingSubscriber(ByteString topic, ByteString subscriberId) {\n     /**\n      * Due to some error or disconnection or unsusbcribe, someone asks us to\n      * stop serving a particular endpoint\n-     * \n+     *\n      * @param endPoint\n      */\n     protected void stopServingSubscriber(ActiveSubscriberState subscriber) {\n@@ -160,7 +160,7 @@ protected void stopServingSubscriber(ActiveSubscriberState subscriber) {\n     /**\n      * Instructs the delivery manager to backoff on the given subscriber and\n      * retry sending after some time\n-     * \n+     *\n      * @param subscriber\n      */\n \n@@ -176,7 +176,7 @@ public void retryErroredSubscriberAfterDelay(ActiveSubscriberState subscriber) {\n     /**\n      * Instructs the delivery manager to move the delivery pointer for a given\n      * subscriber\n-     * \n+     *\n      * @param subscriber\n      * @param prevSeqId\n      * @param newSeqId\n@@ -238,7 +238,7 @@ protected void retryErroredSubscribers() {\n     }\n \n     protected void removeDeliveryPtr(ActiveSubscriberState subscriber, Long seqId, boolean isAbsenceOk,\n-            boolean pruneTopic) {\n+                                     boolean pruneTopic) {\n \n         assert seqId != null;\n \n@@ -279,7 +279,7 @@ protected void addDeliveryPtr(ActiveSubscriberState subscriber, Long seqId) {\n         // If this topic doesn't exist in the per-topic delivery pointers table,\n         // create an entry for it\n         SortedMap<Long, Set<ActiveSubscriberState>> deliveryPtrs = MapMethods.getAfterInsertingIfAbsent(\n-                perTopicDeliveryPtrs, subscriber.getTopic(), TreeMapLongToSetSubscriberFactory.instance);\n+                    perTopicDeliveryPtrs, subscriber.getTopic(), TreeMapLongToSetSubscriberFactory.instance);\n \n         MapMethods.addToMultiMap(deliveryPtrs, seqId, subscriber, HashMapSubscriberFactory.instance);\n     }\n@@ -299,7 +299,7 @@ protected void addDeliveryPtr(ActiveSubscriberState subscriber, Long seqId) {\n         final static int SEQ_ID_SLACK = 10;\n \n         public ActiveSubscriberState(ByteString topic, ByteString subscriberId, long lastLocalSeqIdDelivered,\n-                DeliveryEndPoint deliveryEndPoint, MessageFilter filter, boolean isHubSubscriber) {\n+                                     DeliveryEndPoint deliveryEndPoint, MessageFilter filter, boolean isHubSubscriber) {\n             this.topic = topic;\n             this.subscriberId = subscriberId;\n             this.lastLocalSeqIdDelivered = lastLocalSeqIdDelivered;\n@@ -342,7 +342,7 @@ public void deliverNextMessage() {\n             localSeqIdDeliveringNow = persistenceMgr.getSeqIdAfterSkipping(topic, lastLocalSeqIdDelivered, 1);\n \n             ScanRequest scanRequest = new ScanRequest(topic, localSeqIdDeliveringNow,\n-            /* callback= */this, /* ctx= */null);\n+                    /* callback= */this, /* ctx= */null);\n \n             persistenceMgr.scanSingleMessage(scanRequest);\n         }\n@@ -373,11 +373,11 @@ public void messageScanned(Object ctx, Message message) {\n              * done\n              */\n             PubSubResponse response = PubSubResponse.newBuilder().setProtocolVersion(ProtocolVersion.VERSION_ONE)\n-                    .setStatusCode(StatusCode.SUCCESS).setTxnId(0).setMessage(message).build();\n+                                      .setStatusCode(StatusCode.SUCCESS).setTxnId(0).setMessage(message).build();\n \n             deliveryEndPoint.send(response, //\n-                    // callback =\n-                    this);\n+                                  // callback =\n+                                  this);\n \n         }\n \n@@ -404,8 +404,8 @@ public void sendingFinished() {\n             }\n \n             lastLocalSeqIdDelivered = localSeqIdDeliveringNow;\n-            \n-            if (lastLocalSeqIdDelivered > lastSeqIdCommunicatedExternally + SEQ_ID_SLACK){\n+\n+            if (lastLocalSeqIdDelivered > lastSeqIdCommunicatedExternally + SEQ_ID_SLACK) {\n                 // Note: The order of the next 2 statements is important. We should\n                 // submit a request to change our delivery pointer only *after* we\n                 // have actually changed it. Otherwise, there is a race condition\n@@ -417,11 +417,11 @@ public void sendingFinished() {\n             }\n             deliverNextMessage();\n         }\n-        \n+\n         public long getLastSeqIdCommunicatedExternally() {\n             return lastSeqIdCommunicatedExternally;\n         }\n-            \n+\n \n         public void permanentErrorOnSend() {\n             stopServingSubscriber(this);\n@@ -446,7 +446,7 @@ public void performRequest() {\n \n             lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n             addDeliveryPtr(this, lastLocalSeqIdDelivered);\n-            \n+\n             deliverNextMessage();\n         };\n \n@@ -480,10 +480,10 @@ public void performRequest() {\n             // subscriber first changes its delivery pointer and then submits a\n             // request to move so this works.\n             removeDeliveryPtr(subscriber, subscriber.getLastSeqIdCommunicatedExternally(), //\n-                    // isAbsenceOk=\n-                    true,\n-                    // pruneTopic=\n-                    true);\n+                              // isAbsenceOk=\n+                              true,\n+                              // pruneTopic=\n+                              true);\n         }\n \n     }\n@@ -507,18 +507,18 @@ public void performRequest() {\n \n             if (subscriber.isConnected()) {\n                 removeDeliveryPtr(subscriber, oldSeqId, //\n-                        // isAbsenceOk=\n-                        false,\n-                        // pruneTopic=\n-                        false);\n+                                  // isAbsenceOk=\n+                                  false,\n+                                  // pruneTopic=\n+                                  false);\n \n                 addDeliveryPtr(subscriber, newSeqId);\n             } else {\n                 removeDeliveryPtr(subscriber, oldSeqId, //\n-                        // isAbsenceOk=\n-                        true,\n-                        // pruneTopic=\n-                        true);\n+                                  // isAbsenceOk=\n+                                  true,\n+                                  // pruneTopic=\n+                                  true);\n             }\n \n             long nowMinSeqId = getMinimumSeqId(topic);\n@@ -540,11 +540,11 @@ public void performRequest() {\n \n     /**\n      * ====================================================================\n-     * \n+     *\n      * Dumb factories for our map methods\n      */\n     protected static class TreeMapLongToSetSubscriberFactory implements\n-            Factory<SortedMap<Long, Set<ActiveSubscriberState>>> {\n+        Factory<SortedMap<Long, Set<ActiveSubscriberState>>> {\n         static TreeMapLongToSetSubscriberFactory instance = new TreeMapLongToSetSubscriberFactory();\n \n         @Override"},{"sha":"2573df0470ef9fdb0164c9f57789c9d6df4db87b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,7 +28,7 @@\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.util.HedwigSocketAddress;\n \n-public abstract class BaseHandler implements Handler{\n+public abstract class BaseHandler implements Handler {\n \n     protected TopicManager topicMgr;\n     protected ServerConfiguration cfg;\n@@ -41,22 +41,22 @@ protected BaseHandler(TopicManager tm, ServerConfiguration cfg) {\n \n     public void handleRequest(final PubSubRequest request, final Channel channel) {\n         topicMgr.getOwner(request.getTopic(), request.getShouldClaim(),\n-                new Callback<HedwigSocketAddress>() {\n-                    @Override\n-                    public void operationFailed(Object ctx, PubSubException exception) {\n-                        channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n-                    }\n+        new Callback<HedwigSocketAddress>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+            }\n \n-                    @Override\n-                    public void operationFinished(Object ctx, HedwigSocketAddress owner) {\n-                        if (!owner.equals(cfg.getServerAddr())) {\n-                            channel.write(PubSubResponseUtils.getResponseForException(\n-                                    new ServerNotResponsibleForTopicException(owner.toString()), request.getTxnId()));\n-                            return;\n-                        }\n-                        handleRequestAtOwner(request, channel);\n-                    }\n-                }, null);\n+            @Override\n+            public void operationFinished(Object ctx, HedwigSocketAddress owner) {\n+                if (!owner.equals(cfg.getServerAddr())) {\n+                    channel.write(PubSubResponseUtils.getResponseForException(\n+                                      new ServerNotResponsibleForTopicException(owner.toString()), request.getTxnId()));\n+                    return;\n+                }\n+                handleRequestAtOwner(request, channel);\n+            }\n+        }, null);\n     }\n \n     public abstract void handleRequestAtOwner(PubSubRequest request, Channel channel);"},{"sha":"458d301fd2f4edce4cf6373979e1e4e149cc5184","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -20,7 +20,7 @@\n import org.jboss.netty.channel.Channel;\n \n public interface ChannelDisconnectListener {\n-    \n+\n     /**\n      * Act on a particular channel being disconnected\n      * @param channel"},{"sha":"17120272747d48fe76a39193733e38e6625136f8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -53,7 +53,7 @@ public void handleRequestAtOwner(PubSubRequest request, Channel channel) {\n         ConsumeRequest consumeRequest = request.getConsumeRequest();\n \n         sm.setConsumeSeqIdForSubscriber(request.getTopic(), consumeRequest.getSubscriberId(),\n-                consumeRequest.getMsgId(), noopCallback, null);\n+                                        consumeRequest.getMsgId(), noopCallback, null);\n \n     }\n "},{"sha":"c391f5c1c24f9115e96214a7cf4b13c342bd4ace","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -22,14 +22,14 @@\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n \n public interface Handler {\n-    \n+\n     /**\n      * Handle a request synchronously or asynchronously. After handling the\n      * request, the appropriate response should be written on the given channel\n-     * \n+     *\n      * @param request\n      *            The request to handle\n-     * \n+     *\n      * @param channel\n      *            The channel on which to write the response\n      */"},{"sha":"7a785c40c6f55212c3cb2073888f992204bb08c8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -47,20 +47,20 @@ public void handleRequestAtOwner(final PubSubRequest request, final Channel chan\n         }\n \n         Message msgToSerialize = Message.newBuilder(request.getPublishRequest().getMsg()).setSrcRegion(\n-                cfg.getMyRegionByteString()).build();\n+                                     cfg.getMyRegionByteString()).build();\n \n         PersistRequest persistRequest = new PersistRequest(request.getTopic(), msgToSerialize,\n-                new Callback<Long>() {\n-                    @Override\n-                    public void operationFailed(Object ctx, PubSubException exception) {\n-                        channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n-                    }\n+        new Callback<Long>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+            }\n \n-                    @Override\n-                    public void operationFinished(Object ctx, Long resultOfOperation) {\n-                        channel.write(PubSubResponseUtils.getSuccessResponse(request.getTxnId()));\n-                    }\n-                }, null);\n+            @Override\n+            public void operationFinished(Object ctx, Long resultOfOperation) {\n+                channel.write(PubSubResponseUtils.getSuccessResponse(request.getTxnId()));\n+            }\n+        }, null);\n \n         persistenceMgr.persistMessage(persistRequest);\n     }"},{"sha":"2f510c8cd2fd60e6a0dacca119454bf649d1261d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -42,7 +42,7 @@\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.util.Callback;\n \n-public class SubscribeHandler extends BaseHandler implements ChannelDisconnectListener{\n+public class SubscribeHandler extends BaseHandler implements ChannelDisconnectListener {\n     static Logger logger = Logger.getLogger(SubscribeHandler.class);\n \n     private DeliveryManager deliveryMgr;\n@@ -52,7 +52,7 @@\n     ConcurrentHashMap<Channel, TopicSubscriber> channel2sub;\n \n     public SubscribeHandler(TopicManager topicMgr, DeliveryManager deliveryManager, PersistenceManager persistenceMgr,\n-            SubscriptionManager subMgr, ServerConfiguration cfg) {\n+                            SubscriptionManager subMgr, ServerConfiguration cfg) {\n         super(topicMgr, cfg);\n         this.deliveryMgr = deliveryManager;\n         this.persistenceMgr = persistenceMgr;\n@@ -89,7 +89,7 @@ public void handleRequestAtOwner(final PubSubRequest request, final Channel chan\n             seqId = persistenceMgr.getCurrentSeqIdForTopic(topic);\n         } catch (ServerNotResponsibleForTopicException e) {\n             channel.write(PubSubResponseUtils.getResponseForException(e, request.getTxnId())).addListener(\n-                    ChannelFutureListener.CLOSE);\n+                ChannelFutureListener.CLOSE);\n             return;\n         }\n \n@@ -103,7 +103,7 @@ public void handleRequestAtOwner(final PubSubRequest request, final Channel chan\n             @Override\n             public void operationFailed(Object ctx, PubSubException exception) {\n                 channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId())).addListener(\n-                        ChannelFutureListener.CLOSE);\n+                    ChannelFutureListener.CLOSE);\n             }\n \n             @Override\n@@ -124,9 +124,9 @@ public void operationFinished(Object ctx, MessageSeqId resultOfOperation) {\n                     if (null != sub2Channel.putIfAbsent(topicSub, channel)) {\n                         // there was another channel mapped to this sub\n                         PubSubException pse = new PubSubException.TopicBusyException(\n-                                \"subscription for this topic, subscriberId is already being served on a different channel\");\n+                            \"subscription for this topic, subscriberId is already being served on a different channel\");\n                         channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n-                                .addListener(ChannelFutureListener.CLOSE);\n+                        .addListener(ChannelFutureListener.CLOSE);\n                         return;\n                     } else {\n                         // channel2sub is just a cache, so we can add to it\n@@ -141,10 +141,10 @@ public void operationFinished(Object ctx, MessageSeqId resultOfOperation) {\n \n                 // want to start 1 ahead of the consume ptr\n                 MessageSeqId seqIdToStartFrom = MessageSeqId.newBuilder(resultOfOperation).setLocalComponent(\n-                        resultOfOperation.getLocalComponent() + 1).build();\n+                                                    resultOfOperation.getLocalComponent() + 1).build();\n                 deliveryMgr.startServingSubscription(topic, subscriberId, seqIdToStartFrom,\n-                        new ChannelEndPoint(channel), TrueFilter.instance(), SubscriptionStateUtils\n-                                .isHubSubscriber(subRequest.getSubscriberId()));\n+                                                     new ChannelEndPoint(channel), TrueFilter.instance(), SubscriptionStateUtils\n+                                                     .isHubSubscriber(subRequest.getSubscriberId()));\n             }\n         }, null);\n "},{"sha":"09e8b926245437d19f79af6703e2d14ec836e2e3","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -35,7 +35,7 @@\n     DeliveryManager deliveryMgr;\n \n     public UnsubscribeHandler(TopicManager tm, ServerConfiguration cfg, SubscriptionManager subMgr,\n-            DeliveryManager deliveryMgr) {\n+                              DeliveryManager deliveryMgr) {\n         super(tm, cfg);\n         this.subMgr = subMgr;\n         this.deliveryMgr = deliveryMgr;"},{"sha":"726341d5d9d7927b4f3c7ff7e644bc5cd87e0baf","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -101,7 +101,7 @@\n     ScheduledExecutorService scheduler;\n \n     protected PersistenceManager instantiatePersistenceManager(TopicManager topicMgr) throws IOException,\n-            InterruptedException {\n+        InterruptedException {\n \n         PersistenceManagerWithRangeScan underlyingPM;\n \n@@ -157,9 +157,9 @@ public void process(WatchedEvent event) {\n             // wait until connection is effective\n             if (!signalZkReady.await(conf.getZkTimeout()*2, TimeUnit.MILLISECONDS)) {\n                 logger.fatal(\"Could not establish connection with ZooKeeper after zk_timeout*2 = \" +\n-                        conf.getZkTimeout()*2 + \" ms. (Default value for zk_timeout is 2000).\");\n+                             conf.getZkTimeout()*2 + \" ms. (Default value for zk_timeout is 2000).\");\n                 throw new Exception(\"Could not establish connection with ZooKeeper after zk_timeout*2 = \" +\n-                        conf.getZkTimeout()*2 + \" ms. (Default value for zk_timeout is 2000).\");\n+                                    conf.getZkTimeout()*2 + \" ms. (Default value for zk_timeout is 2000).\");\n             }\n         }\n     }\n@@ -206,7 +206,7 @@ protected void initializeNetty(SslServerContextFactory sslFactory, Map<Operation\n \n         // Bind and start to accept incoming connections.\n         allChannels.add(bootstrap.bind(isSSLEnabled ? new InetSocketAddress(conf.getSSLServerPort())\n-                : new InetSocketAddress(conf.getServerPort())));\n+                                       : new InetSocketAddress(conf.getServerPort())));\n         logger.info(\"Going into receive loop\");\n     }\n \n@@ -226,7 +226,7 @@ public void shutdown() {\n \n         // Stop the RegionManager.\n         rm.stop();\n-        \n+\n         // Stop the DeliveryManager and ReadAheadCache threads (if\n         // applicable).\n         // TODO: It'd be cleaner and more general to modify the interfaces to\n@@ -243,7 +243,7 @@ public void shutdown() {\n         if (sm instanceof AbstractSubscriptionManager) {\n             ((AbstractSubscriptionManager) sm).stop();\n         }\n-        \n+\n         // Close and release the Netty channels and resources\n         allChannels.close().awaitUninterruptibly();\n         serverChannelFactory.releaseExternalResources();\n@@ -253,7 +253,7 @@ public void shutdown() {\n \n     /**\n      * Starts the hedwig server on the given port\n-     * \n+     *\n      * @param port\n      * @throws ConfigurationException\n      *             if there is something wrong with the given configuration\n@@ -334,7 +334,7 @@ public PubSubServer(ServerConfiguration conf) throws Exception {\n     }\n \n     /**\n-     * \n+     *\n      * @param msg\n      * @param rc\n      *            : code to exit with"},{"sha":"c96f438e2d6d21182d671ecf558b578b8c333103","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -41,7 +41,7 @@\n     private int maxMessageSize;\n \n     /**\n-     * \n+     *\n      * @param uh\n      * @param sslFactory\n      *            may be null if ssl is disabled\n@@ -59,7 +59,7 @@ public ChannelPipeline getPipeline() throws Exception {\n             pipeline.addLast(\"ssl\", new SslHandler(sslFactory.getEngine()));\n         }\n         pipeline.addLast(\"lengthbaseddecoder\",\n-                new LengthFieldBasedFrameDecoder(maxMessageSize, 0, 4, 0, 4));\n+                         new LengthFieldBasedFrameDecoder(maxMessageSize, 0, 4, 0, 4));\n         pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n \n         pipeline.addLast(\"protobufdecoder\", new ProtobufDecoder(PubSubProtocol.PubSubRequest.getDefaultInstance()));"},{"sha":"5196a44ccff5101e5f891af9e195569ee53c42da","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -53,7 +53,7 @@\n     private boolean isSSLEnabled = false;\n \n     public UmbrellaHandler(ChannelGroup allChannels, Map<OperationType, Handler> handlers,\n-            boolean isSSLEnabled) {\n+                           boolean isSSLEnabled) {\n         this.allChannels = allChannels;\n         this.isSSLEnabled = isSSLEnabled;\n         this.handlers = handlers;\n@@ -148,7 +148,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n \n         if (handler == null) {\n             sendErrorResponseToMalformedRequest(channel, txnId, \"Request type \" + request.getType().getNumber()\n-                    + \" unknown\");\n+                                                + \" unknown\");\n             return;\n         }\n "},{"sha":"a6079dff6c4bd30d502730b1e9be18f186954c8f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -60,14 +60,14 @@\n \n /**\n  * This persistence manager uses zookeeper and bookkeeper to store messages.\n- * \n+ *\n  * Information about topics are stored in zookeeper with a znode named after the\n  * topic that contains an ASCII encoded list with records of the following form:\n- * \n+ *\n  * <pre>\n  * startSeqId(included)\\tledgerId\\n\n  * </pre>\n- * \n+ *\n  */\n \n public class BookkeeperPersistenceManager implements PersistenceManagerWithRangeScan, TopicOwnershipChangeListener {\n@@ -99,7 +99,7 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n         /**\n          * stores the last message-seq-id vector that has been pushed to BK for\n          * persistence (but not necessarily acked yet by BK)\n-         * \n+         *\n          */\n         MessageSeqId lastSeqIdPushed;\n \n@@ -132,7 +132,7 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n \n     /**\n      * Instantiates a BookKeeperPersistence manager.\n-     * \n+     *\n      * @param bk\n      *            a reference to bookkeeper to use.\n      * @param zk\n@@ -143,7 +143,7 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n      *            created.\n      */\n     public BookkeeperPersistenceManager(BookKeeper bk, ZooKeeper zk, TopicManager tm, ServerConfiguration cfg,\n-            ScheduledExecutorService executor) {\n+                                        ScheduledExecutorService executor) {\n         this.bk = bk;\n         this.zk = zk;\n         this.cfg = cfg;\n@@ -180,21 +180,21 @@ protected void read(final InMemoryLedgerRange imlr, final long startSeqId, final\n             if (imlr.handle == null) {\n \n                 bk.asyncOpenLedger(imlr.range.getLedgerId(), DigestType.CRC32, passwd,\n-                        new SafeAsynBKCallback.OpenCallback() {\n-                            @Override\n-                            public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n-                                if (rc == BKException.Code.OK) {\n-                                    imlr.handle = ledgerHandle;\n-                                    read(imlr, startSeqId, endSeqId);\n-                                    return;\n-                                }\n-                                BKException bke = BKException.create(rc);\n-                                logger.error(\"Could not open ledger: \" + imlr.range.getLedgerId() + \" for topic: \"\n-                                        + topic);\n-                                request.callback.scanFailed(ctx, new PubSubException.ServiceDownException(bke));\n-                                return;\n-                            }\n-                        }, request.ctx);\n+                new SafeAsynBKCallback.OpenCallback() {\n+                    @Override\n+                    public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n+                        if (rc == BKException.Code.OK) {\n+                            imlr.handle = ledgerHandle;\n+                            read(imlr, startSeqId, endSeqId);\n+                            return;\n+                        }\n+                        BKException bke = BKException.create(rc);\n+                        logger.error(\"Could not open ledger: \" + imlr.range.getLedgerId() + \" for topic: \"\n+                                     + topic);\n+                        request.callback.scanFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                        return;\n+                    }\n+                }, request.ctx);\n                 return;\n             }\n \n@@ -203,12 +203,12 @@ public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n \n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Issuing a bk read for ledger: \" + imlr.handle.getId() + \" from entry-id: \"\n-                        + (startSeqId - imlr.startSeqIdIncluded) + \" to entry-id: \"\n-                        + (correctedEndSeqId - imlr.startSeqIdIncluded));\n+                             + (startSeqId - imlr.startSeqIdIncluded) + \" to entry-id: \"\n+                             + (correctedEndSeqId - imlr.startSeqIdIncluded));\n             }\n \n             imlr.handle.asyncReadEntries(startSeqId - imlr.startSeqIdIncluded, correctedEndSeqId\n-                    - imlr.startSeqIdIncluded, new SafeAsynBKCallback.ReadCallback() {\n+            - imlr.startSeqIdIncluded, new SafeAsynBKCallback.ReadCallback() {\n \n                 long expectedEntryId = startSeqId - imlr.startSeqIdIncluded;\n \n@@ -217,7 +217,7 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                     if (rc != BKException.Code.OK || !seq.hasMoreElements()) {\n                         BKException bke = BKException.create(rc);\n                         logger.error(\"Error while reading from ledger: \" + imlr.range.getLedgerId() + \" for topic: \"\n-                                + topic.toStringUtf8(), bke);\n+                                     + topic.toStringUtf8(), bke);\n                         request.callback.scanFailed(request.ctx, new PubSubException.ServiceDownException(bke));\n                         return;\n                     }\n@@ -230,19 +230,19 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                             message = Message.parseFrom(entry.getEntryInputStream());\n                         } catch (IOException e) {\n                             String msg = \"Unreadable message found in ledger: \" + imlr.range.getLedgerId()\n-                                    + \" for topic: \" + topic.toStringUtf8();\n+                                         + \" for topic: \" + topic.toStringUtf8();\n                             logger.error(msg, e);\n                             request.callback.scanFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n                             return;\n                         }\n \n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Read response from ledger: \" + lh.getId() + \" entry-id: \"\n-                                    + entry.getEntryId());\n+                                         + entry.getEntryId());\n                         }\n \n                         assert expectedEntryId == entry.getEntryId() : \"expectedEntryId (\" + expectedEntryId\n-                                + \") != entry.getEntryId() (\" + entry.getEntryId() + \")\";\n+                        + \") != entry.getEntryId() (\" + entry.getEntryId() + \")\";\n                         assert (message.getMsgId().getLocalComponent() - imlr.startSeqIdIncluded) == expectedEntryId;\n \n                         expectedEntryId++;\n@@ -275,7 +275,7 @@ protected void startReadingFrom(long startSeqId) {\n                 // None of the old ledgers have this seq-id, we must use the\n                 // current ledger\n                 long endSeqId = topicInfo.currentLedgerRange.startSeqIdIncluded\n-                        + topicInfo.lastEntryIdAckedInCurrentLedger;\n+                                + topicInfo.lastEntryIdAckedInCurrentLedger;\n \n                 if (endSeqId < startSeqId) {\n                     request.callback.scanFinished(request.ctx, ReasonForFinish.NO_MORE_MESSAGES);\n@@ -354,7 +354,7 @@ public void runInternal() {\n \n             if (topicInfo == null) {\n                 request.callback.operationFailed(request.ctx,\n-                        new PubSubException.ServerNotResponsibleForTopicException(\"\"));\n+                                                 new PubSubException.ServerNotResponsibleForTopicException(\"\"));\n                 return;\n             }\n \n@@ -371,34 +371,34 @@ public void runInternal() {\n             Message msgToSerialize = Message.newBuilder(request.message).setMsgId(topicInfo.lastSeqIdPushed).build();\n \n             topicInfo.currentLedgerRange.handle.asyncAddEntry(msgToSerialize.toByteArray(),\n-                    new SafeAsynBKCallback.AddCallback() {\n-                        @Override\n-                        public void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-                            if (rc != BKException.Code.OK) {\n-                                BKException bke = BKException.create(rc);\n-                                logger.error(\"Error while persisting entry to ledger: \" + lh.getId() + \" for topic: \"\n-                                        + topic.toStringUtf8(), bke);\n+            new SafeAsynBKCallback.AddCallback() {\n+                @Override\n+                public void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    if (rc != BKException.Code.OK) {\n+                        BKException bke = BKException.create(rc);\n+                        logger.error(\"Error while persisting entry to ledger: \" + lh.getId() + \" for topic: \"\n+                                     + topic.toStringUtf8(), bke);\n \n-                                // To preserve ordering guarantees, we\n-                                // should give up the topic and not let\n-                                // other operations through\n-                                request.callback.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n-                                return;\n-                            }\n+                        // To preserve ordering guarantees, we\n+                        // should give up the topic and not let\n+                        // other operations through\n+                        request.callback.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                        return;\n+                    }\n \n-                            if (entryId + topicInfo.currentLedgerRange.startSeqIdIncluded != localSeqId) {\n-                                String msg = \"Expected BK to assign entry-id: \"\n-                                        + (localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded)\n-                                        + \" but it instead assigned entry-id: \" + entryId + \" topic: \"\n-                                        + topic.toStringUtf8() + \"ledger: \" + lh.getId();\n-                                logger.fatal(msg);\n-                                throw new UnexpectedError(msg);\n-                            }\n+                    if (entryId + topicInfo.currentLedgerRange.startSeqIdIncluded != localSeqId) {\n+                        String msg = \"Expected BK to assign entry-id: \"\n+                                     + (localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded)\n+                                     + \" but it instead assigned entry-id: \" + entryId + \" topic: \"\n+                                     + topic.toStringUtf8() + \"ledger: \" + lh.getId();\n+                        logger.fatal(msg);\n+                        throw new UnexpectedError(msg);\n+                    }\n \n-                            topicInfo.lastEntryIdAckedInCurrentLedger = entryId;\n-                            request.callback.operationFinished(ctx, localSeqId);\n-                        }\n-                    }, request.ctx);\n+                    topicInfo.lastEntryIdAckedInCurrentLedger = entryId;\n+                    request.callback.operationFinished(ctx, localSeqId);\n+                }\n+            }, request.ctx);\n \n         }\n     }\n@@ -448,27 +448,27 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                         // create it\n                         final byte[] initialData = LedgerRanges.getDefaultInstance().toByteArray();\n                         ZkUtils.createFullPathOptimistic(zk, zNodePath, initialData, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n-                                CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n-                                    @Override\n-                                    public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                                        if (rc != Code.OK.intValue()) {\n-                                            KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                                    \"Could not create ledgers node for topic: \" + topic.toStringUtf8(),\n-                                                    path, rc);\n-                                            cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                                            return;\n-                                        }\n-                                        // initial version is version 1\n-                                        // (guessing)\n-                                        processTopicLedgersNodeData(initialData, 0);\n-                                    }\n-                                }, ctx);\n+                        CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+                            @Override\n+                            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                                if (rc != Code.OK.intValue()) {\n+                                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                                             \"Could not create ledgers node for topic: \" + topic.toStringUtf8(),\n+                                                             path, rc);\n+                                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                                    return;\n+                                }\n+                                // initial version is version 1\n+                                // (guessing)\n+                                processTopicLedgersNodeData(initialData, 0);\n+                            }\n+                        }, ctx);\n                         return;\n                     }\n \n                     // otherwise some other error\n                     KeeperException ke = ZkUtils.logErrorAndCreateZKException(\"Could not read ledgers node for topic: \"\n-                            + topic.toStringUtf8(), path, rc);\n+                                         + topic.toStringUtf8(), path, rc);\n                     cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n \n                 }\n@@ -506,7 +506,7 @@ void processTopicLedgersNodeData(byte[] data, int version) {\n                 // If it doesn't have a valid end, it must be the last ledger\n                 if (lrIterator.hasNext()) {\n                     String msg = \"Ledger-id: \" + range.getLedgerId() + \" for topic: \" + topic.toStringUtf8()\n-                            + \" is not the last one but still does not have an end seq-id\";\n+                                 + \" is not the last one but still does not have an end seq-id\";\n                     logger.fatal(msg);\n                     cb.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n                     return;\n@@ -525,7 +525,7 @@ void processTopicLedgersNodeData(byte[] data, int version) {\n         /**\n          * Recovers the last ledger, opens a new one, and persists the new\n          * information to ZK\n-         * \n+         *\n          * @param ledgerId\n          *            Ledger to be recovered\n          */\n@@ -539,7 +539,7 @@ public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n                     if (rc != BKException.Code.OK) {\n                         BKException bke = BKException.create(rc);\n                         logger.error(\"While acquiring topic: \" + topic.toStringUtf8()\n-                                + \", could not open unrecovered ledger: \" + ledgerId, bke);\n+                                     + \", could not open unrecovered ledger: \" + ledgerId, bke);\n                         cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n                         return;\n                     }\n@@ -559,97 +559,97 @@ public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n                     // out the last seq-id\n \n                     ledgerHandle.asyncReadEntries(numEntriesInLastLedger - 1, numEntriesInLastLedger - 1,\n-                            new SafeAsynBKCallback.ReadCallback() {\n-                                @Override\n-                                public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n-                                        Object ctx) {\n-                                    if (rc != BKException.Code.OK || !seq.hasMoreElements()) {\n-                                        BKException bke = BKException.create(rc);\n-                                        logger.error(\"While recovering ledger: \" + ledgerId + \" for topic: \"\n-                                                + topic.toStringUtf8() + \", could not read last entry\", bke);\n-                                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n-                                        return;\n-                                    }\n-\n-                                    Message lastMessage;\n-                                    try {\n-                                        lastMessage = Message.parseFrom(seq.nextElement().getEntry());\n-                                    } catch (InvalidProtocolBufferException e) {\n-                                        String msg = \"While recovering ledger: \" + ledgerId + \" for topic: \"\n-                                                + topic.toStringUtf8() + \", could not deserialize last message\";\n-                                        logger.error(msg, e);\n-                                        cb.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n-                                        return;\n-                                    }\n-\n-                                    long prevLedgerEnd = topicInfo.ledgerRanges.isEmpty() ? 0 : topicInfo.ledgerRanges\n-                                            .lastKey();\n-                                    LedgerRange lr = LedgerRange.newBuilder().setLedgerId(ledgerId)\n-                                            .setEndSeqIdIncluded(lastMessage.getMsgId()).build();\n-                                    topicInfo.ledgerRanges.put(lr.getEndSeqIdIncluded().getLocalComponent(),\n-                                            new InMemoryLedgerRange(lr, prevLedgerEnd + 1, lh));\n-\n-                                    logger.info(\"Recovered unclosed ledger: \" + ledgerId + \" for topic: \"\n-                                            + topic.toStringUtf8() + \" with \" + numEntriesInLastLedger + \" entries\");\n-\n-                                    openNewTopicLedger(expectedVersionOfLedgerNode, topicInfo);\n-                                }\n-                            }, ctx);\n+                    new SafeAsynBKCallback.ReadCallback() {\n+                        @Override\n+                        public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n+                        Object ctx) {\n+                            if (rc != BKException.Code.OK || !seq.hasMoreElements()) {\n+                                BKException bke = BKException.create(rc);\n+                                logger.error(\"While recovering ledger: \" + ledgerId + \" for topic: \"\n+                                             + topic.toStringUtf8() + \", could not read last entry\", bke);\n+                                cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                                return;\n+                            }\n+\n+                            Message lastMessage;\n+                            try {\n+                                lastMessage = Message.parseFrom(seq.nextElement().getEntry());\n+                            } catch (InvalidProtocolBufferException e) {\n+                                String msg = \"While recovering ledger: \" + ledgerId + \" for topic: \"\n+                                             + topic.toStringUtf8() + \", could not deserialize last message\";\n+                                logger.error(msg, e);\n+                                cb.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                                return;\n+                            }\n+\n+                            long prevLedgerEnd = topicInfo.ledgerRanges.isEmpty() ? 0 : topicInfo.ledgerRanges\n+                                                 .lastKey();\n+                            LedgerRange lr = LedgerRange.newBuilder().setLedgerId(ledgerId)\n+                                             .setEndSeqIdIncluded(lastMessage.getMsgId()).build();\n+                            topicInfo.ledgerRanges.put(lr.getEndSeqIdIncluded().getLocalComponent(),\n+                                                       new InMemoryLedgerRange(lr, prevLedgerEnd + 1, lh));\n+\n+                            logger.info(\"Recovered unclosed ledger: \" + ledgerId + \" for topic: \"\n+                                        + topic.toStringUtf8() + \" with \" + numEntriesInLastLedger + \" entries\");\n+\n+                            openNewTopicLedger(expectedVersionOfLedgerNode, topicInfo);\n+                        }\n+                    }, ctx);\n \n                 }\n \n             }, ctx);\n         }\n \n         /**\n-         * \n+         *\n          * @param requiredVersionOfLedgersNode\n          *            The version of the ledgers node when we read it, should be\n          *            the same when we try to write\n          */\n         private void openNewTopicLedger(final int expectedVersionOfLedgersNode, final TopicInfo topicInfo) {\n             bk.asyncCreateLedger(cfg.getBkEnsembleSize(), cfg.getBkQuorumSize(), DigestType.CRC32, passwd,\n-                    new SafeAsynBKCallback.CreateCallback() {\n-                        boolean processed = false;\n+            new SafeAsynBKCallback.CreateCallback() {\n+                boolean processed = false;\n \n-                        @Override\n-                        public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n-                            if (processed) {\n-                                return;\n-                            } else {\n-                                processed = true;\n-                            }\n+                @Override\n+                public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n+                    if (processed) {\n+                        return;\n+                    } else {\n+                        processed = true;\n+                    }\n \n-                            if (rc != BKException.Code.OK) {\n-                                BKException bke = BKException.create(rc);\n-                                logger.error(\"Could not create new ledger while acquiring topic: \"\n-                                        + topic.toStringUtf8(), bke);\n-                                cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n-                                return;\n-                            }\n+                    if (rc != BKException.Code.OK) {\n+                        BKException bke = BKException.create(rc);\n+                        logger.error(\"Could not create new ledger while acquiring topic: \"\n+                                     + topic.toStringUtf8(), bke);\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                        return;\n+                    }\n \n-                            topicInfo.lastSeqIdPushed = topicInfo.ledgerRanges.isEmpty() ? MessageSeqId.newBuilder()\n-                                    .setLocalComponent(0).build() : topicInfo.ledgerRanges.lastEntry().getValue().range\n-                                    .getEndSeqIdIncluded();\n+                    topicInfo.lastSeqIdPushed = topicInfo.ledgerRanges.isEmpty() ? MessageSeqId.newBuilder()\n+                                                .setLocalComponent(0).build() : topicInfo.ledgerRanges.lastEntry().getValue().range\n+                                                .getEndSeqIdIncluded();\n \n-                            LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(lh.getId()).build();\n-                            topicInfo.currentLedgerRange = new InMemoryLedgerRange(lastRange, topicInfo.lastSeqIdPushed\n-                                    .getLocalComponent() + 1, lh);\n+                    LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(lh.getId()).build();\n+                    topicInfo.currentLedgerRange = new InMemoryLedgerRange(lastRange, topicInfo.lastSeqIdPushed\n+                            .getLocalComponent() + 1, lh);\n \n-                            // Persist the fact that we started this new\n-                            // ledger to ZK\n+                    // Persist the fact that we started this new\n+                    // ledger to ZK\n \n-                            LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n-                            for (InMemoryLedgerRange imlr : topicInfo.ledgerRanges.values()) {\n-                                builder.addRanges(imlr.range);\n-                            }\n-                            builder.addRanges(lastRange);\n+                    LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n+                    for (InMemoryLedgerRange imlr : topicInfo.ledgerRanges.values()) {\n+                        builder.addRanges(imlr.range);\n+                    }\n+                    builder.addRanges(lastRange);\n \n-                            writeTopicLedgersNode(topic, builder.build().toByteArray(), expectedVersionOfLedgersNode,\n-                                    topicInfo);\n-                            return;\n-                        }\n-                    }, ctx);\n+                    writeTopicLedgersNode(topic, builder.build().toByteArray(), expectedVersionOfLedgersNode,\n+                                          topicInfo);\n+                    return;\n+                }\n+            }, ctx);\n         }\n \n         void writeTopicLedgersNode(final ByteString topic, byte[] data, int expectedVersion, final TopicInfo topicInfo) {\n@@ -660,7 +660,7 @@ void writeTopicLedgersNode(final ByteString topic, byte[] data, int expectedVers\n                 public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n                     if (rc != KeeperException.Code.OK.intValue()) {\n                         KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n+                                                 \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n                         cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n                         return;\n                     }\n@@ -677,7 +677,7 @@ public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n     /**\n      * acquire ownership of a topic, doing whatever is needed to be able to\n      * perform reads and writes on that topic from here on\n-     * \n+     *\n      * @param topic\n      * @param callback\n      * @param ctx\n@@ -725,7 +725,7 @@ public void runInternal() {\n     /**\n      * Release any resources for the topic that might be currently held. There\n      * wont be any subsequent reads or writes on that topic coming\n-     * \n+     *\n      * @param topic\n      */\n     @Override"},{"sha":"26bdb942f8fe1982085f13ffa419290d5ac081e6","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -65,10 +65,10 @@ public boolean equals(Object obj) {\n             return false;\n         return true;\n     }\n-    \n+\n     @Override\n     public String toString() {\n-        return \"(\" + topic.toStringUtf8() + \",\" + seqId + \")\"; \n+        return \"(\" + topic.toStringUtf8() + \",\" + seqId + \")\";\n     }\n \n }"},{"sha":"ef4200957af77b8de0551c40ba5ede36103cbc3d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,7 +28,7 @@\n /**\n  * This class is NOT thread safe. It need not be thread-safe because our\n  * read-ahead cache will operate with only 1 thread\n- * \n+ *\n  */\n public class CacheValue {\n "},{"sha":"84ebd62577aff63856b64aacd8a62e5bbcf4af6c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -115,7 +115,7 @@ private LocalDBPersistenceManager() {\n      * Ensures that at least the default seq-id exists in the map for the given\n      * topic. Checks for race conditions (.e.g, another thread inserts the\n      * default id before us), and returns the latest seq-id value in the map\n-     * \n+     *\n      * @param topic\n      * @return\n      */\n@@ -140,13 +140,13 @@ private MessageSeqId ensureSeqIdExistsForTopic(ByteString topic) {\n      * Adjust the current seq id of the topic based on the message we are about\n      * to publish. The local component of the current seq-id is always\n      * incremented by 1. For the other components, there are two cases:\n-     * \n+     *\n      * 1. If the message to be published doesn't have a seq-id (locally\n      * published messages), the other components are left as is.\n-     * \n+     *\n      * 2. If the message to be published has a seq-id, we take the max of the\n      * current one we have, and that in the message to be published.\n-     * \n+     *\n      * @param topic\n      * @param messageToPublish\n      * @return The value of the local seq-id obtained after incrementing the\n@@ -250,7 +250,7 @@ private void createTable(Connection conn, ByteString topic) {\n             Statement stmt = conn.createStatement();\n             String tableName = getTableNameForTopic(topic);\n             stmt.execute(\"CREATE TABLE \" + tableName + \" (\" + ID_FIELD_NAME + \" BIGINT NOT NULL CONSTRAINT ID_PK_\"\n-                    + tableName + \" PRIMARY KEY,\" + MSG_FIELD_NAME + \" BLOB(2M) NOT NULL)\");\n+                         + tableName + \" PRIMARY KEY,\" + MSG_FIELD_NAME + \" BLOB(2M) NOT NULL)\");\n         } catch (SQLException e) {\n             logger.debug(\"Could not create table\", e);\n         }\n@@ -262,13 +262,13 @@ public MessageSeqId getCurrentSeqIdForTopic(ByteString topic) {\n \n     public void scanSingleMessage(ScanRequest request) {\n         scanMessagesInternal(request.getTopic(), request.getStartSeqId(), 1, Long.MAX_VALUE, request.getCallback(),\n-                request.getCtx(), 1);\n+                             request.getCtx(), 1);\n         return;\n     }\n \n     public void scanMessages(RangeScanRequest request) {\n         scanMessagesInternal(request.getTopic(), request.getStartSeqId(), request.getMessageLimit(), request\n-                .getSizeLimit(), request.getCallback(), request.getCtx(), SCAN_CHUNK);\n+                             .getSizeLimit(), request.getCallback(), request.getCtx(), SCAN_CHUNK);\n         return;\n     }\n \n@@ -277,7 +277,7 @@ private String getTableNameForTopic(ByteString topic) {\n     }\n \n     private void scanMessagesInternal(ByteString topic, long startSeqId, int messageLimit, long sizeLimit,\n-            ScanCallback callback, Object ctx, int scanChunk) {\n+                                      ScanCallback callback, Object ctx, int scanChunk) {\n \n         Connection conn = threadLocalConnection.get();\n \n@@ -293,7 +293,7 @@ private void scanMessagesInternal(ByteString topic, long startSeqId, int message\n         try {\n             try {\n                 stmt = conn.prepareStatement(\"SELECT * FROM \" + getTableNameForTopic(topic) + \" WHERE \" + ID_FIELD_NAME\n-                        + \" >= ?  AND \" + ID_FIELD_NAME + \" <= ?\");\n+                                             + \" >= ?  AND \" + ID_FIELD_NAME + \" <= ?\");\n \n             } catch (SQLException sqle) {\n                 String theError = (sqle).getSQLState();\n@@ -383,7 +383,7 @@ public void consumedUntil(ByteString topic, Long seqId) {\n         PreparedStatement stmt;\n         try {\n             stmt = conn.prepareStatement(\"DELETE FROM \" + getTableNameForTopic(topic) + \" WHERE \" + ID_FIELD_NAME\n-                    + \" <= ?\");\n+                                         + \" <= ?\");\n             stmt.setLong(1, seqId);\n             int rowCount = stmt.executeUpdate();\n             logger.debug(\"Deleted \" + rowCount + \" records for topic: \" + topic.toStringUtf8() + \", seqId: \" + seqId);"},{"sha":"486fcd2686f280699982e6ee206dcecc9d33701e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,7 +24,7 @@\n /**\n  * Encapsulates a request to persist a given message on a given topic. The\n  * request is completed asynchronously, callback and context are provided\n- * \n+ *\n  */\n public class PersistRequest {\n     ByteString topic;"},{"sha":"5c38ad9495cbf068ef58425e57eb48c90c5ea4f4","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,7 +28,7 @@\n  * the {@link PersistenceManager} needs to understand the format of the seqId\n  * and maintain it in such a way that there is a total order on the seqIds of a\n  * topic.\n- * \n+ *\n  */\n public interface PersistenceManager {\n \n@@ -44,14 +44,14 @@\n      * Get the seqId of the last message that has been persisted to the given\n      * topic. The returned seqId will be set as the consume position of any\n      * brand new subscription on this topic.\n-     * \n+     *\n      * Note that the return value may quickly become invalid because a\n      * {@link #persistMessage(String, PublishedMessage)} call from another\n      * thread succeeds. For us, the typical use case is choosing the consume\n      * position of a new subscriber. Since the subscriber need not receive all\n      * messages that are published while the subscribe call is in progress, such\n      * loose semantics from this method is acceptable.\n-     * \n+     *\n      * @param topic\n      * @return the seqId of the last persisted message.\n      * @throws ServerNotResponsibleForTopicException\n@@ -60,7 +60,7 @@\n \n     /**\n      * Executes the given scan request\n-     * \n+     *\n      */\n     public void scanSingleMessage(ScanRequest request);\n \n@@ -80,7 +80,7 @@\n      * subscribers to the topic and no longer need to be stored. The\n      * implementation classes can decide how and if they want to garbage collect\n      * and delete these older topic messages that are no longer needed.\n-     * \n+     *\n      * @param topic\n      *            Topic\n      * @param seqId"},{"sha":"f12174f098df09d97ccc36e0fdb4c04791df2bca","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -20,7 +20,7 @@\n public interface PersistenceManagerWithRangeScan extends PersistenceManager {\n     /**\n      * Executes the given range scan request\n-     * \n+     *\n      * @param request\n      */\n     public void scanMessages(RangeScanRequest request);"},{"sha":"3ac324df537fd37463b455c0823e5bd07f3fc815","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -30,7 +30,7 @@\n  * {@link ScanCallback} used should be prepared to deal with more or less\n  * messages scanned. If an error occurs during scanning, the\n  * {@link ScanCallback} is notified of the error.\n- * \n+ *\n  */\n public class RangeScanRequest {\n     ByteString topic;\n@@ -41,7 +41,7 @@\n     Object ctx;\n \n     public RangeScanRequest(ByteString topic, long startSeqId, int messageLimit, long sizeLimit, ScanCallback callback,\n-            Object ctx) {\n+                            Object ctx) {\n         this.topic = topic;\n         this.startSeqId = startSeqId;\n         this.messageLimit = messageLimit;"},{"sha":"31e9c063392116dcddac385e6b838495ac378d9c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"modified","additions":36,"deletions":36,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -107,7 +107,7 @@\n \n     /**\n      * Constructor. Starts the cache maintainer thread\n-     * \n+     *\n      * @param realPersistenceManager\n      */\n     public ReadAheadCache(PersistenceManagerWithRangeScan realPersistenceManager, ServerConfiguration cfg) {\n@@ -139,10 +139,10 @@ public MessageSeqId getCurrentSeqIdForTopic(ByteString topic) throws ServerNotRe\n      * ========================================================================\n      * Other methods of {@link PersistenceManager} that the cache needs to take\n      * some action on.\n-     * \n+     *\n      * 1. Persist: We pass it through to the real persistence manager but insert\n      * our callback on the return path\n-     * \n+     *\n      */\n     public void persistMessage(PersistRequest request) {\n         // make a new PersistRequest object so that we can insert our own\n@@ -158,7 +158,7 @@ public void persistMessage(PersistRequest request) {\n      * The callback that we insert on the persist request return path. The\n      * callback simply forms a {@link PersistResponse} object and inserts it in\n      * the request queue to be handled serially by the cache maintainer thread.\n-     * \n+     *\n      */\n     public class PersistCallback implements Callback<Long> {\n \n@@ -188,7 +188,7 @@ public void operationFinished(Object ctx, Long resultOfOperation) {\n             // Original message that was persisted didn't have the local seq-id.\n             // Lets add that in\n             Message messageWithLocalSeqId = MessageIdUtils.mergeLocalSeqId(originalRequest.getMessage(),\n-                    resultOfOperation);\n+                                            resultOfOperation);\n \n             // Now enqueue a request to add this newly persisted message to our\n             // cache\n@@ -204,20 +204,20 @@ public void operationFinished(Object ctx, Long resultOfOperation) {\n      * callbacks. Its just simpler to quit and restart afresh. Moreover, this\n      * should not happen as the request queue for the cache maintainer is\n      * unbounded.\n-     * \n+     *\n      * @param obj\n      */\n     protected void enqueueWithoutFailure(CacheRequest obj) {\n         if (!requestQueue.offer(obj)) {\n             throw new UnexpectedError(\"Could not enqueue object: \" + obj.toString()\n-                    + \" to cache request queue. Exiting.\");\n+                                      + \" to cache request queue. Exiting.\");\n \n         }\n     }\n \n     /**\n      * Another method from {@link PersistenceManager}.\n-     * \n+     *\n      * 2. Scan - Since the scan needs to touch the cache, we will just enqueue\n      * the scan request and let the cache maintainer thread handle it.\n      */\n@@ -228,7 +228,7 @@ public void scanSingleMessage(ScanRequest request) {\n \n     /**\n      * Another method from {@link PersistenceManager}.\n-     * \n+     *\n      * 3. Enqueue the request so that the cache maintainer thread can delete all\n      * message-ids older than the one specified\n      */\n@@ -238,7 +238,7 @@ public void deliveredUntil(ByteString topic, Long seqId) {\n \n     /**\n      * Another method from {@link PersistenceManager}.\n-     * \n+     *\n      * Since this is a cache layer on top of an underlying persistence manager,\n      * we can just call the consumedUntil method there. The messages older than\n      * the latest one passed here won't be accessed anymore so they should just\n@@ -252,7 +252,7 @@ public void consumedUntil(ByteString topic, Long seqId) {\n     /**\n      * ========================================================================\n      * BEGINNING OF CODE FOR THE CACHE MAINTAINER THREAD\n-     * \n+     *\n      * 1. The run method. It simply dequeues from the request queue, checks the\n      * type of object and acts accordingly\n      */\n@@ -284,7 +284,7 @@ public void stop() {\n      * outstanding. In that case, we look a little ahead (by readAheadCount/2)\n      * and issue a range read of readAheadCount/2 messages. The idea is to\n      * ensure that the next readAheadCount messages are always available.\n-     * \n+     *\n      * @return the range scan that should be issued for read ahead\n      */\n     protected RangeScanRequest doReadAhead(ScanRequest request) {\n@@ -313,7 +313,7 @@ protected RangeScanRequest doReadAhead(ScanRequest request) {\n     /**\n      * This method just checks if the provided seq-id already exists in the\n      * cache. If not, a range read of the specified amount is issued.\n-     * \n+     *\n      * @param topic\n      * @param seqId\n      * @param readAheadCount\n@@ -369,7 +369,7 @@ protected RangeScanRequest doReadAheadStartingFrom(ByteString topic, long seqId,\n \n         /**\n          * Constructor\n-         * \n+         *\n          * @param installedStubs\n          *            The list of stubs that were installed for this range scan\n          * @param topic\n@@ -407,8 +407,8 @@ public void messageScanned(Object ctx, Message message) {\n             // should remove them, so that whoever is waiting on them can retry.\n             // This shouldn't be happening usually\n             logger.warn(\"Unexpected message seq-id: \" + message.getMsgId().getLocalComponent() + \" on topic: \"\n-                    + topic.toStringUtf8() + \" from readahead scan, was expecting seq-id: \" + expectedKey.seqId\n-                    + \" topic: \" + expectedKey.topic.toStringUtf8() + \" installedStubs: \" + installedStubs);\n+                        + topic.toStringUtf8() + \" from readahead scan, was expecting seq-id: \" + expectedKey.seqId\n+                        + \" topic: \" + expectedKey.topic.toStringUtf8() + \" installedStubs: \" + installedStubs);\n             enqueueDeleteOfRemainingStubs(noSuchSeqIdExceptionInstance);\n \n         }\n@@ -457,14 +457,14 @@ private void enqueueDeleteOfRemainingStubs(Exception reason) {\n      * For adding the message to the cache, we do some bookeeping such as the\n      * total size of cache, order in which entries were added etc. If the size\n      * of the cache has exceeded our budget, old entries are collected.\n-     * \n+     *\n      * @param cacheKey\n      * @param message\n      */\n     protected void addMessageToCache(CacheKey cacheKey, Message message, long currTime) {\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Adding msg (topic: \" + cacheKey.getTopic().toStringUtf8() + \", seq-id: \"\n-                    + message.getMsgId().getLocalComponent() + \") to readahead cache\");\n+                         + message.getMsgId().getLocalComponent() + \") to readahead cache\");\n         }\n \n         CacheValue cacheValue;\n@@ -482,7 +482,7 @@ protected void addMessageToCache(CacheKey cacheKey, Message message, long currTi\n \n         // maintain the index of seq-id\n         MapMethods.addToMultiMap(orderedIndexOnSeqId, cacheKey.getTopic(), cacheKey.getSeqId(),\n-                TreeSetLongFactory.instance);\n+                                 TreeSetLongFactory.instance);\n \n         // finally add the message to the cache\n         cacheValue.setMessageAndInvokeCallbacks(message, currTime);\n@@ -492,7 +492,7 @@ protected void addMessageToCache(CacheKey cacheKey, Message message, long currTi\n     }\n \n     protected void removeMessageFromCache(CacheKey cacheKey, Exception exception, boolean maintainTimeIndex,\n-            boolean maintainSeqIdIndex) {\n+                                          boolean maintainSeqIdIndex) {\n         CacheValue cacheValue = cache.remove(cacheKey);\n \n         if (cacheValue == null) {\n@@ -537,13 +537,13 @@ protected void collectOldCacheEntries() {\n \n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Removing topic: \" + cacheKey.getTopic() + \"seq-id: \" + cacheKey.getSeqId()\n-                            + \" from cache because its the oldest\");\n+                                 + \" from cache because its the oldest\");\n                 }\n                 removeMessageFromCache(cacheKey, readAheadExceptionInstance, //\n-                        // maintainTimeIndex=\n-                        false,\n-                        // maintainSeqIdIndex=\n-                        true);\n+                                       // maintainTimeIndex=\n+                                       false,\n+                                       // maintainSeqIdIndex=\n+                                       true);\n             }\n \n             timeIndexOfAddition.remove(earliestTime);\n@@ -554,7 +554,7 @@ protected void collectOldCacheEntries() {\n     /**\n      * ========================================================================\n      * The rest is just simple wrapper classes.\n-     * \n+     *\n      */\n \n     protected class ExceptionOnCacheKey implements CacheRequest {\n@@ -575,10 +575,10 @@ public ExceptionOnCacheKey(CacheKey cacheKey, Exception exception) {\n          */\n         public void performRequest() {\n             removeMessageFromCache(cacheKey, exception,\n-            // maintainTimeIndex=\n-                    true,\n-                    // maintainSeqIdIndex=\n-                    true);\n+                                   // maintainTimeIndex=\n+                                   true,\n+                                   // maintainSeqIdIndex=\n+                                   true);\n         }\n \n     }\n@@ -638,15 +638,15 @@ public void performRequest() {\n \n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Removing seq-id: \" + cacheKey.getSeqId() + \" topic: \"\n-                            + cacheKey.getTopic().toStringUtf8()\n-                            + \" from cache because every subscriber has moved past\");\n+                                 + cacheKey.getTopic().toStringUtf8()\n+                                 + \" from cache because every subscriber has moved past\");\n                 }\n \n                 removeMessageFromCache(cacheKey, readAheadExceptionInstance, //\n-                        // maintainTimeIndex=\n-                        true,\n-                        // maintainSeqIdIndex=\n-                        false);\n+                                       // maintainTimeIndex=\n+                                       true,\n+                                       // maintainSeqIdIndex=\n+                                       false);\n                 iter.remove();\n             }\n "},{"sha":"42ebb93394b251258b23ea2eecd712b82279c44f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -30,7 +30,7 @@\n      * as part of a scan. The message just read is handed to this listener which\n      * can then take the desired action on it. The return value from the method\n      * indicates whether the scan should continue or not.\n-     * \n+     *\n      * @param ctx\n      *            The context for the callback\n      * @param message\n@@ -41,8 +41,8 @@\n \n     /**\n      * This method is called when the scan finishes\n-     * \n-     * \n+     *\n+     *\n      * @param ctx\n      * @param reason\n      */\n@@ -52,7 +52,7 @@\n     /**\n      * This method is called when the operation failed due to some reason. The\n      * reason for failure is passed in.\n-     * \n+     *\n      * @param ctx\n      *            The context for the callback\n      * @param exception"},{"sha":"c985840316db631aeeaa3b8bd0e1cfcbd64360da","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -30,7 +30,7 @@\n  * its redundant.\n  * {@link ScanCallback#scanFailed(Object, org.apache.hedwig.exceptions.PubSubException)}\n  * method is called in case of error.\n- * \n+ *\n  */\n public class ScanRequest {\n     ByteString topic;"},{"sha":"5bfd89841becf37409c05dc57c08499273f76f21","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -72,7 +72,7 @@ public synchronized void subscribeSucceeded(TopicSubscriber topicSubscriber, Cha\n \n         if (topicSub2Channel.containsKey(topicSubscriber)) {\n             TopicBusyException pse = new PubSubException.TopicBusyException(\n-                    \"subscription for this topic, subscriberId is already being served on a different channel\");\n+                \"subscription for this topic, subscriberId is already being served on a different channel\");\n             throw pse;\n         }\n \n@@ -107,12 +107,12 @@ public synchronized void checkChannelMatches(ByteString topic, ByteString subscr\n \n         if (subscribedChannel == null) {\n             throw new PubSubException.ClientNotSubscribedException(\n-                    \"Can't start delivery since client is not subscribed\");\n+                \"Can't start delivery since client is not subscribed\");\n         }\n \n         if (subscribedChannel != channel) {\n             throw new PubSubException.TopicBusyException(\n-                    \"Can't start delivery since client is subscribed on a different channel\");\n+                \"Can't start delivery since client is subscribed on a different channel\");\n         }\n \n     }"},{"sha":"f8b836a19d04e97eeafd745bfaa19413b4910f1c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -48,7 +48,7 @@\n \n     HedwigClient client;\n     ServerSocketChannelFactory serverSocketChannelFactory;\n-    ChannelGroup allChannels; \n+    ChannelGroup allChannels;\n     Map<OperationType, Handler> handlers;\n     ProxyConfiguration cfg;\n \n@@ -69,7 +69,7 @@ public void uncaughtException(Thread t, Throwable e) {\n             @Override\n             public void run() {\n                 client = new HedwigClient(cfg);\n-                \n+\n                 serverSocketChannelFactory = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),\n                         Executors.newCachedThreadPool());\n                 initializeHandlers();\n@@ -125,7 +125,7 @@ public void shutdown() {\n \n     // the following method only exists for unit-testing purposes, should go\n     // away once we make start delivery totally server-side\n-    public Handler getStartDeliveryHandler(){\n+    public Handler getStartDeliveryHandler() {\n         return handlers.get(OperationType.START_DELIVERY);\n     }\n "},{"sha":"fc811e97722b7703aafc823b6bf0cefac28e19ee","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -19,18 +19,18 @@\n \n import org.apache.hedwig.client.conf.ClientConfiguration;\n \n-public class ProxyConfiguration extends ClientConfiguration{\n+public class ProxyConfiguration extends ClientConfiguration {\n \n     protected static String PROXY_PORT = \"proxy_port\";\n     protected static String MAX_MESSAGE_SIZE = \"max_message_size\";\n-    \n-    public int getProxyPort(){\n+\n+    public int getProxyPort() {\n         return conf.getInt(PROXY_PORT, 9099);\n     }\n-    \n+\n     @Override\n     public int getMaximumMessageSize() {\n         return conf.getInt(MAX_MESSAGE_SIZE, 1258291); /* 1.2M */\n     }\n-    \n+\n }"},{"sha":"07706c1eaffdcea7ec3831210cd7d8a0f654d542","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -71,22 +71,22 @@ public void handleRequest(PubSubRequest request, Channel channel) {\n             // }\n \n             final Channel subscribedChannel = tracker.getChannel(topic, subscriberId);\n-            \n+\n             if (subscribedChannel == null) {\n                 channel.write(PubSubResponseUtils.getResponseForException(\n-                        new PubSubException.ClientNotSubscribedException(\"no subscription to start delivery on\"),\n-                        request.getTxnId()));\n+                                  new PubSubException.ClientNotSubscribedException(\"no subscription to start delivery on\"),\n+                                  request.getTxnId()));\n                 return;\n             }\n-            \n+\n             MessageHandler handler = new MessageHandler() {\n                 @Override\n                 public void consume(ByteString topic, ByteString subscriberId, Message msg,\n-                        final Callback<Void> callback, final Object context) {\n+                final Callback<Void> callback, final Object context) {\n \n                     PubSubResponse response = PubSubResponse.newBuilder().setProtocolVersion(\n-                            ProtocolVersion.VERSION_ONE).setStatusCode(StatusCode.SUCCESS).setTxnId(0).setMessage(msg)\n-                            .setTopic(topic).setSubscriberId(subscriberId).build();\n+                                                  ProtocolVersion.VERSION_ONE).setStatusCode(StatusCode.SUCCESS).setTxnId(0).setMessage(msg)\n+                                              .setTopic(topic).setSubscriberId(subscriberId).build();\n \n                     ChannelFuture future = subscribedChannel.write(response);\n \n@@ -119,7 +119,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 logger.fatal(\"Unexpected: No subscription when attempting to start delivery\", e);\n                 throw new RuntimeException(e);\n             }\n-            \n+\n \n \n         }"},{"sha":"8112a5c371ba2bbf10831d79be9bd565079a797e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -60,7 +60,7 @@ public void handleRequest(final PubSubRequest request, final Channel channel) {\n         final TopicSubscriber topicSubscriber = new TopicSubscriber(request.getTopic(), subRequest.getSubscriberId());\n \n         subscriber.asyncSubscribe(topicSubscriber.getTopic(), subRequest.getSubscriberId(), subRequest\n-                .getCreateOrAttach(), new Callback<Void>() {\n+        .getCreateOrAttach(), new Callback<Void>() {\n             @Override\n             public void operationFailed(Object ctx, PubSubException exception) {\n                 channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));"},{"sha":"fa240e29d6e25464766088a06508b602aef96eb4","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -38,7 +38,7 @@ public HedwigHubClientFactory(ServerConfiguration cfg, ClientSocketChannelFactor\n     /**\n      * Manufacture a hub client whose default server to connect to is the input\n      * HedwigSocketAddress hub.\n-     * \n+     *\n      * @param hub\n      *            The hub in another region to connect to.\n      */"},{"sha":"4e8a4059664ca7839431e1e57a1a555b9e9644f3","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -45,25 +45,25 @@ public HedwigHubSubscriber(HedwigClient client) {\n     @Override\n     public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n-            InvalidSubscriberIdException {\n+        InvalidSubscriberIdException {\n         subscribe(topic, subscriberId, mode, true);\n     }\n \n     @Override\n     public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n-            Object context) {\n+                               Object context) {\n         asyncSubscribe(topic, subscriberId, mode, callback, context, true);\n     }\n \n     @Override\n     public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n-            ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException {\n+        ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException {\n         unsubscribe(topic, subscriberId, true);\n     }\n \n     @Override\n     public void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId, final Callback<Void> callback,\n-            final Object context) {\n+                                 final Object context) {\n         asyncUnsubscribe(topic, subscriberId, callback, context, true);\n     }\n "},{"sha":"9533d8cc40fd197fd2b791e535e5307bc97af765","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -52,7 +52,7 @@\n     private final TopicOpQueuer queue;\n \n     public RegionManager(final PersistenceManager pm, final ServerConfiguration cfg, final ZooKeeper zk,\n-            ScheduledExecutorService scheduler, HedwigHubClientFactory hubClientFactory) {\n+                         ScheduledExecutorService scheduler, HedwigHubClientFactory hubClientFactory) {\n         this.pm = pm;\n         mySubId = ByteString.copyFromUtf8(SubscriptionStateUtils.HUB_SUBSCRIBER_PREFIX + cfg.getMyRegion());\n         queue = new TopicOpQueuer(scheduler);\n@@ -70,7 +70,7 @@ public void onFirstLocalSubscribe(final ByteString topic, final boolean synchron\n             @Override\n             public void run() {\n                 Callback<Void> postCb = synchronous ? cb : CallbackUtils.logger(LOGGER, Level.DEBUG, Level.ERROR,\n-                        \"all cross-region subscriptions succeeded\", \"at least one cross-region subscription failed\");\n+                                        \"all cross-region subscriptions succeeded\", \"at least one cross-region subscription failed\");\n                 final Callback<Void> mcb = CallbackUtils.multiCallback(clients.size(), postCb, ctx);\n                 for (final HedwigHubClient client : clients) {\n                     final HedwigSubscriber sub = client.getSubscriber();\n@@ -83,44 +83,44 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                                 sub.startDelivery(topic, mySubId, new MessageHandler() {\n                                     @Override\n                                     public void consume(final ByteString topic, ByteString subscriberId, Message msg,\n-                                            final Callback<Void> callback, final Object context) {\n+                                    final Callback<Void> callback, final Object context) {\n                                         // When messages are first published\n                                         // locally, the PublishHandler sets the\n                                         // source region in the Message.\n                                         if (msg.hasSrcRegion()) {\n                                             Message.newBuilder(msg).setMsgId(\n-                                                    MessageSeqId.newBuilder(msg.getMsgId()).addRemoteComponents(\n-                                                            RegionSpecificSeqId.newBuilder().setRegion(\n-                                                                    msg.getSrcRegion()).setSeqId(\n-                                                                    msg.getMsgId().getLocalComponent())));\n+                                                MessageSeqId.newBuilder(msg.getMsgId()).addRemoteComponents(\n+                                                    RegionSpecificSeqId.newBuilder().setRegion(\n+                                                        msg.getSrcRegion()).setSeqId(\n+                                                        msg.getMsgId().getLocalComponent())));\n                                         }\n                                         pm.persistMessage(new PersistRequest(topic, msg, new Callback<Long>() {\n                                             @Override\n                                             public void operationFinished(Object ctx, Long resultOfOperation) {\n                                                 if (LOGGER.isDebugEnabled())\n                                                     LOGGER.debug(\"cross-region recv-fwd succeeded for topic \"\n-                                                            + topic.toStringUtf8());\n+                                                                 + topic.toStringUtf8());\n                                                 callback.operationFinished(context, null);\n                                             }\n \n                                             @Override\n                                             public void operationFailed(Object ctx, PubSubException exception) {\n                                                 if (LOGGER.isDebugEnabled())\n                                                     LOGGER.error(\"cross-region recv-fwd failed for topic \"\n-                                                            + topic.toStringUtf8(), exception);\n+                                                                 + topic.toStringUtf8(), exception);\n                                                 callback.operationFailed(context, exception);\n                                             }\n                                         }, null));\n                                     }\n                                 });\n                                 if (LOGGER.isDebugEnabled())\n                                     LOGGER.debug(\"cross-region start-delivery succeeded for topic \"\n-                                            + topic.toStringUtf8());\n+                                                 + topic.toStringUtf8());\n                                 mcb.operationFinished(ctx, null);\n                             } catch (PubSubException ex) {\n                                 if (LOGGER.isDebugEnabled())\n                                     LOGGER.error(\n-                                            \"cross-region start-delivery failed for topic \" + topic.toStringUtf8(), ex);\n+                                        \"cross-region start-delivery failed for topic \" + topic.toStringUtf8(), ex);\n                                 mcb.operationFailed(ctx, ex);\n                             }\n                         }\n@@ -129,7 +129,7 @@ public void operationFailed(Object ctx, PubSubException exception) {\n                         public void operationFailed(Object ctx, PubSubException exception) {\n                             if (LOGGER.isDebugEnabled())\n                                 LOGGER.error(\"cross-region subscribe failed for topic \" + topic.toStringUtf8(),\n-                                        exception);\n+                                             exception);\n                             mcb.operationFailed(ctx, exception);\n                         }\n                     }, null);"},{"sha":"bf320dd4d02c2cdb4bc5f3fbbb201580488cb6e9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":17,"deletions":17,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -66,7 +66,7 @@\n     private final ConcurrentHashMap<ByteString, Long> topic2MinConsumedMessagesMap = new ConcurrentHashMap<ByteString, Long>();\n \n     public AbstractSubscriptionManager(ServerConfiguration cfg, TopicManager tm, PersistenceManager pm,\n-            ScheduledExecutorService scheduler) {\n+                                       ScheduledExecutorService scheduler) {\n         this.cfg = cfg;\n         queuer = new TopicOpQueuer(scheduler);\n         tm.addTopicOwnershipChangeListener(this);\n@@ -141,7 +141,7 @@ public void operationFailed(Object ctx, PubSubException exception) {\n \n                 @Override\n                 public void operationFinished(final Object ctx,\n-                        final Map<ByteString, InMemorySubscriptionState> resultOfOperation) {\n+                final Map<ByteString, InMemorySubscriptionState> resultOfOperation) {\n                     // We've just inherited a bunch of subscriber for this\n                     // topic, some of which may be local. If they are, then we\n                     // need to (1) notify listeners of this and (2) record the\n@@ -163,7 +163,7 @@ public void operationFinished(final Object ctx,\n                         @Override\n                         public void operationFailed(Object ctx, PubSubException exception) {\n                             logger.error(\"Subscription manager failed to acquired topic \" + topic.toStringUtf8(),\n-                                    exception);\n+                                         exception);\n                             cb.operationFailed(ctx, null);\n                         }\n \n@@ -201,7 +201,7 @@ private void notifySubscribe(ByteString topic, boolean synchronous, final Callba\n      * Figure out who is subscribed. Do nothing if already acquired. If there's\n      * an error reading the subscribers' sequence IDs, then the topic is not\n      * acquired.\n-     * \n+     *\n      * @param topic\n      * @param callback\n      * @param ctx\n@@ -236,7 +236,7 @@ protected abstract void readSubscriptions(final ByteString topic,\n         MessageSeqId consumeSeqId;\n \n         public SubscribeOp(ByteString topic, SubscribeRequest subRequest, MessageSeqId consumeSeqId,\n-                Callback<MessageSeqId> callback, Object ctx) {\n+                           Callback<MessageSeqId> callback, Object ctx) {\n             queuer.super(topic, callback, ctx);\n             this.subRequest = subRequest;\n             this.consumeSeqId = consumeSeqId;\n@@ -259,8 +259,8 @@ public void run() {\n \n                 if (createOrAttach.equals(CreateOrAttach.CREATE)) {\n                     String msg = \"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                            + \" requested creating a subscription but it is already subscribed with state: \"\n-                            + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState());\n+                                 + \" requested creating a subscription but it is already subscribed with state: \"\n+                                 + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState());\n                     logger.debug(msg);\n                     cb.operationFailed(ctx, new PubSubException.ClientAlreadySubscribedException(msg));\n                     return;\n@@ -269,8 +269,8 @@ public void run() {\n                 // otherwise just attach\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                            + \" attaching to subscription with state: \"\n-                            + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState()));\n+                                 + \" attaching to subscription with state: \"\n+                                 + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState()));\n                 }\n \n                 cb.operationFinished(ctx, subscriptionState.getLastConsumeSeqId());\n@@ -280,7 +280,7 @@ public void run() {\n             // we don't have a mapping for this subscriber\n             if (createOrAttach.equals(CreateOrAttach.ATTACH)) {\n                 String msg = \"Topic: \" + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                        + \" requested attaching to an existing subscription but it is not subscribed\";\n+                             + \" requested attaching to an existing subscription but it is not subscribed\";\n                 logger.debug(msg);\n                 cb.operationFailed(ctx, new PubSubException.ClientNotSubscribedException(msg));\n                 return;\n@@ -301,7 +301,7 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                         @Override\n                         public void operationFailed(Object ctx, PubSubException exception) {\n                             logger.error(\"subscription for subscriber \" + subscriberId.toStringUtf8() + \" to topic \"\n-                                    + topic.toStringUtf8() + \" failed due to failed listener callback\", exception);\n+                                         + topic.toStringUtf8() + \" failed due to failed listener callback\", exception);\n                             cb.operationFailed(ctx, exception);\n                         }\n \n@@ -325,7 +325,7 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n \n     @Override\n     public void serveSubscribeRequest(ByteString topic, SubscribeRequest subRequest, MessageSeqId consumeSeqId,\n-            Callback<MessageSeqId> callback, Object ctx) {\n+                                      Callback<MessageSeqId> callback, Object ctx) {\n         queuer.pushAndMaybeRun(topic, new SubscribeOp(topic, subRequest, consumeSeqId, callback, ctx));\n     }\n \n@@ -334,7 +334,7 @@ public void serveSubscribeRequest(ByteString topic, SubscribeRequest subRequest,\n         MessageSeqId consumeSeqId;\n \n         public ConsumeOp(ByteString topic, ByteString subscriberId, MessageSeqId consumeSeqId, Callback<Void> callback,\n-                Object ctx) {\n+                         Object ctx) {\n             queuer.super(topic, callback, ctx);\n             this.subscriberId = subscriberId;\n             this.consumeSeqId = consumeSeqId;\n@@ -359,10 +359,10 @@ public void run() {\n             } else {\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Only advanced consume pointer in memory, will persist later, topic: \"\n-                            + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                            + \" persistentState: \" + SubscriptionStateUtils.toString(subState.getSubscriptionState())\n-                            + \" in-memory consume-id: \"\n-                            + MessageIdUtils.msgIdToReadableString(subState.getLastConsumeSeqId()));\n+                                 + topic.toStringUtf8() + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                 + \" persistentState: \" + SubscriptionStateUtils.toString(subState.getSubscriptionState())\n+                                 + \" in-memory consume-id: \"\n+                                 + MessageIdUtils.msgIdToReadableString(subState.getLastConsumeSeqId()));\n                 }\n                 cb.operationFinished(ctx, null);\n             }"},{"sha":"0fdfad0241af657b247f285bf69e81eac2851da2","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -36,21 +36,21 @@ public InMemorySubscriptionManager(TopicManager tm, PersistenceManager pm, Serve\n \n     @Override\n     protected void createSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n-            Callback<Void> callback, Object ctx) {\n+                                           Callback<Void> callback, Object ctx) {\n         // nothing to do, in-memory info is already recorded by base class\n         callback.operationFinished(ctx, null);\n     }\n \n     @Override\n     protected void deleteSubscriptionState(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n-            Object ctx) {\n+                                           Object ctx) {\n         // nothing to do, in-memory info is already deleted by base class\n         callback.operationFinished(ctx, null);\n     }\n \n     @Override\n     protected void updateSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n-            Callback<Void> callback, Object ctx) {\n+                                           Callback<Void> callback, Object ctx) {\n         // nothing to do, in-memory info is already updated by base class\n         callback.operationFinished(ctx, null);\n     }\n@@ -62,7 +62,7 @@ public void lostTopic(ByteString topic) {\n \n     @Override\n     protected void readSubscriptions(ByteString topic,\n-            Callback<Map<ByteString, InMemorySubscriptionState>> cb, Object ctx) {\n+                                     Callback<Map<ByteString, InMemorySubscriptionState>> cb, Object ctx) {\n         // Since we don't lose in-memory information on lostTopic, we can just\n         // return that back\n         Map<ByteString, InMemorySubscriptionState> topicSubs = top2sub2seq.get(topic);"},{"sha":"8ee92e384b96c86e366840b129b9725331ca50e8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -42,7 +42,7 @@ public MessageSeqId getLastConsumeSeqId() {\n     }\n \n     /**\n-     * \n+     *\n      * @param lastConsumeSeqId\n      * @param consumeInterval\n      *            The amount of laziness we want in persisting the consume"},{"sha":"03503298c3892b827cf6f88d993cacf57828e957","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -23,7 +23,7 @@\n \n     /**\n      * Tests whether a particular message passes the filter or not\n-     * \n+     *\n      * @param message\n      * @return\n      */"},{"sha":"6c6e626dd22c8e92d2203bb0c4b34eb933972b52","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -22,15 +22,15 @@\n \n /**\n  * For listening to events that are issued by a SubscriptionManager.\n- * \n+ *\n  */\n public interface SubscriptionEventListener {\n \n     /**\n      * Called by the subscription manager when it previously had zero local\n      * subscribers for a topic and is currently accepting its first local\n      * subscriber.\n-     * \n+     *\n      * @param topic\n      *            The topic of interest.\n      * @param synchronous\n@@ -48,10 +48,10 @@\n      * Called by the SubscriptionManager when it previously had non-zero local\n      * subscribers for a topic and is currently dropping its last local\n      * subscriber. This is fully asynchronous so there is no callback.\n-     * \n+     *\n      * @param topic\n      *            The topic of interest.\n      */\n     public void onLastLocalUnsubscribe(ByteString topic);\n-    \n+\n }"},{"sha":"d40a029c532cd27d8b6b251fc6e2df5f2da31389","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,15 +28,15 @@\n public interface SubscriptionManager {\n \n     /**\n-     * \n+     *\n      * Register a new subscription for the given subscriber for the given topic.\n      * This method should reliably persist the existence of the subscription in\n      * a way that it can't be lost. If the subscription already exists,\n      * depending on the create or attach flag in the subscribe request, an\n      * exception may be returned.\n-     * \n+     *\n      * This is an asynchronous method.\n-     * \n+     *\n      * @param topic\n      * @param subRequest\n      * @param consumeSeqId\n@@ -48,14 +48,14 @@\n      * @param ctx\n      */\n     public void serveSubscribeRequest(ByteString topic, SubscribeRequest subRequest, MessageSeqId consumeSeqId,\n-            Callback<MessageSeqId> callback, Object ctx);\n+                                      Callback<MessageSeqId> callback, Object ctx);\n \n     /**\n      * Set the consume position of a given subscriber on a given topic. Note\n      * that this method need not persist the consume position immediately but\n      * can be lazy and persist it later asynchronously, if that is more\n      * efficient.\n-     * \n+     *\n      * @param topic\n      * @param subscriberId\n      * @param consumeSeqId\n@@ -65,7 +65,7 @@ public void setConsumeSeqIdForSubscriber(ByteString topic, ByteString subscriber\n \n     /**\n      * Delete a particular subscription\n-     * \n+     *\n      * @param topic\n      * @param subscriberId\n      */\n@@ -100,5 +100,5 @@ public void setConsumeSeqIdForSubscriber(ByteString topic, ByteString subscriber\n      * or removed.\n      */\n     public void addListener(SubscriptionEventListener listener);\n-    \n+\n }"},{"sha":"b480fa0c650d65ec4a236aff713dde0bedae70ec","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -50,7 +50,7 @@\n     protected final static Logger logger = Logger.getLogger(ZkSubscriptionManager.class);\n \n     public ZkSubscriptionManager(ZooKeeper zk, TopicManager topicMgr, PersistenceManager pm, ServerConfiguration cfg,\n-            ScheduledExecutorService scheduler) {\n+                                 ScheduledExecutorService scheduler) {\n         super(cfg, topicMgr, pm, scheduler);\n         this.zk = zk;\n     }\n@@ -61,12 +61,12 @@ private StringBuilder topicSubscribersPath(StringBuilder sb, ByteString topic) {\n \n     private String topicSubscriberPath(ByteString topic, ByteString subscriber) {\n         return topicSubscribersPath(new StringBuilder(), topic).append(\"/\").append(subscriber.toStringUtf8())\n-                .toString();\n+               .toString();\n     }\n \n     @Override\n     protected void readSubscriptions(final ByteString topic,\n-            final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n+                                     final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n \n         String topicSubscribersPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n         zk.getChildren(topicSubscribersPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n@@ -75,7 +75,7 @@ public void safeProcessResult(int rc, String path, final Object ctx, final List<\n \n                 if (rc != Code.OK.intValue() && rc != Code.NONODE.intValue()) {\n                     KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read subscribers for topic \"\n-                            + topic.toStringUtf8(), path, rc);\n+                                        + topic.toStringUtf8(), path, rc);\n                     cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                     return;\n                 }\n@@ -104,8 +104,8 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n \n                             if (rc != Code.OK.intValue()) {\n                                 KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                                        \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n-                                                + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                                                        \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                                        + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n                                 reportFailure(new PubSubException.ServiceDownException(e));\n                                 return;\n                             }\n@@ -120,16 +120,16 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                                 state = SubscriptionState.parseFrom(data);\n                             } catch (InvalidProtocolBufferException ex) {\n                                 String msg = \"Failed to deserialize state for topic: \" + topic.toStringUtf8()\n-                                        + \" subscriberId: \" + subscriberId.toStringUtf8();\n+                                             + \" subscriberId: \" + subscriberId.toStringUtf8();\n                                 logger.error(msg, ex);\n                                 reportFailure(new PubSubException.UnexpectedConditionException(msg));\n                                 return;\n                             }\n \n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n-                                        + \" subscriberId: \" + child + \"state: \"\n-                                        + SubscriptionStateUtils.toString(state));\n+                                             + \" subscriberId: \" + child + \"state: \"\n+                                             + SubscriptionStateUtils.toString(state));\n                             }\n \n                             topicSubs.put(subscriberId, new InMemorySubscriptionState(state));\n@@ -151,73 +151,73 @@ private void reportFailure(PubSubException e) {\n \n     @Override\n     protected void createSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-            final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n+                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n         ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), state.toByteArray(),\n-                Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+        Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n \n-                    @Override\n-                    public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                        if (rc == Code.OK.intValue()) {\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Successfully recorded subscription for topic: \" + topic.toStringUtf8()\n-                                        + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n-                                        + SubscriptionStateUtils.toString(state));\n-                            }\n-                            callback.operationFinished(ctx, null);\n-                        } else {\n-                            KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                    \"Could not record new subscription for topic: \" + topic.toStringUtf8()\n-                                            + \" subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n-                            callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                        }\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                if (rc == Code.OK.intValue()) {\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Successfully recorded subscription for topic: \" + topic.toStringUtf8()\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n+                                     + SubscriptionStateUtils.toString(state));\n                     }\n-                }, ctx);\n+                    callback.operationFinished(ctx, null);\n+                } else {\n+                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                             \"Could not record new subscription for topic: \" + topic.toStringUtf8()\n+                                             + \" subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                }\n+            }\n+        }, ctx);\n     }\n \n     @Override\n     protected void updateSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-            final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n+                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n         zk.setData(topicSubscriberPath(topic, subscriberId), state.toByteArray(), -1,\n-                new SafeAsyncZKCallback.StatCallback() {\n-                    @Override\n-                    public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n-                        if (rc != Code.OK.intValue()) {\n-                            KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n-                                    + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                                    + \" could not set subscription state: \" + SubscriptionStateUtils.toString(state),\n-                                    path, rc);\n-                            callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n-                        } else {\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Successfully updated subscription for topic: \" + topic.toStringUtf8()\n-                                        + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n-                                        + SubscriptionStateUtils.toString(state));\n-                            }\n-\n-                            callback.operationFinished(ctx, null);\n-                        }\n+        new SafeAsyncZKCallback.StatCallback() {\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                if (rc != Code.OK.intValue()) {\n+                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                        + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                        + \" could not set subscription state: \" + SubscriptionStateUtils.toString(state),\n+                                        path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                } else {\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Successfully updated subscription for topic: \" + topic.toStringUtf8()\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n+                                     + SubscriptionStateUtils.toString(state));\n                     }\n-                }, ctx);\n+\n+                    callback.operationFinished(ctx, null);\n+                }\n+            }\n+        }, ctx);\n     }\n \n     @Override\n     protected void deleteSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-            final Callback<Void> callback, final Object ctx) {\n+                                           final Callback<Void> callback, final Object ctx) {\n         zk.delete(topicSubscriberPath(topic, subscriberId), -1, new SafeAsyncZKCallback.VoidCallback() {\n             @Override\n             public void safeProcessResult(int rc, String path, Object ctx) {\n                 if (rc == Code.OK.intValue()) {\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Successfully deleted subscription for topic: \" + topic.toStringUtf8()\n-                                + \" subscriberId: \" + subscriberId.toStringUtf8());\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8());\n                     }\n \n                     callback.operationFinished(ctx, null);\n                     return;\n                 }\n \n                 KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n-                        + \" subscriberId: \" + subscriberId.toStringUtf8() + \" failed to delete subscription\", path, rc);\n+                                    + \" subscriberId: \" + subscriberId.toStringUtf8() + \" failed to delete subscription\", path, rc);\n                 callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n             }\n         }, ctx);"},{"sha":"05562c91509085fd758325cb4b7b44bd297e9556","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -60,8 +60,8 @@\n     private class GetOwnerOp extends TopicOpQueuer.AsynchronousOp<HedwigSocketAddress> {\n         public boolean shouldClaim;\n \n-        public GetOwnerOp(final ByteString topic, boolean shouldClaim, \n-                final Callback<HedwigSocketAddress> cb, Object ctx) {\n+        public GetOwnerOp(final ByteString topic, boolean shouldClaim,\n+                          final Callback<HedwigSocketAddress> cb, Object ctx) {\n             queuer.super(topic, cb, ctx);\n             this.shouldClaim = shouldClaim;\n         }\n@@ -119,7 +119,7 @@ public void run() {\n                                 @Override\n                                 public void operationFailed(Object ctx, PubSubException exception) {\n                                     logger.error(\"failure that should never happen when periodically releasing topic \"\n-                                            + topic, exception);\n+                                                 + topic, exception);\n                                 }\n \n                                 @Override\n@@ -157,7 +157,7 @@ private void realReleaseTopic(ByteString topic, Callback<Void> callback, Object\n \n     @Override\n     public final void getOwner(ByteString topic, boolean shouldClaim,\n-            Callback<HedwigSocketAddress> cb, Object ctx) {\n+                               Callback<HedwigSocketAddress> cb, Object ctx) {\n         queuer.pushAndMaybeRun(topic, new GetOwnerOp(topic, shouldClaim, cb, ctx));\n     }\n \n@@ -173,10 +173,10 @@ public final void releaseTopic(ByteString topic, Callback<Void> cb, Object ctx)\n      * choosing this hub as the owner, the {@code\n      * AbstractTopicManager#notifyListenersAndAddToOwnedTopics(ByteString,\n      * OperationCallback, Object)} method must be called.\n-     * \n+     *\n      */\n     protected abstract void realGetOwner(ByteString topic, boolean shouldClaim,\n-            Callback<HedwigSocketAddress> cb, Object ctx);\n+                                         Callback<HedwigSocketAddress> cb, Object ctx);\n \n     /**\n      * The method should do any cleanup necessary to indicate to other hubs that"},{"sha":"6e4b2c9bbe1b13c0b8777d19df4518dc7b95085c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -30,13 +30,13 @@\n  * claim responsibilities for the topics that were at the failed host. On\n  * claiming responsibility for a topic, a host should call its\n  * {@link TopicOwnershipChangeListener}.\n- * \n+ *\n  */\n \n public interface TopicManager {\n     /**\n      * Get the name of the host responsible for the given topic.\n-     * \n+     *\n      * @param topic\n      *            The topic whose owner to get.\n      * @param cb\n@@ -45,8 +45,8 @@\n      * @throws ServiceDownException\n      *             If there is an error looking up the information\n      */\n-    public void getOwner(ByteString topic, boolean shouldClaim, \n-            Callback<HedwigSocketAddress> cb, Object ctx);\n+    public void getOwner(ByteString topic, boolean shouldClaim,\n+                         Callback<HedwigSocketAddress> cb, Object ctx);\n \n     /**\n      * Whenever the topic manager finds out that the set of topics owned by this\n@@ -59,14 +59,14 @@ public void getOwner(ByteString topic, boolean shouldClaim,\n      * immediately to such notifications, and with no blocking (because multiple\n      * listeners might need to be informed and they are all informed by the same\n      * thread).\n-     * \n+     *\n      * @param listener\n      */\n     public void addTopicOwnershipChangeListener(TopicOwnershipChangeListener listener);\n \n     /**\n      * Give up ownership of a topic. If I don't own it, do nothing.\n-     * \n+     *\n      * @throws ServiceDownException\n      *             If there is an error in claiming responsibility for the topic\n      */"},{"sha":"1f6654f11106240af3abdbf8fa884c448a3e7b27","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -33,8 +33,8 @@ public TrivialOwnAllTopicManager(ServerConfiguration cfg, ScheduledExecutorServi\n     }\n \n     @Override\n-    protected void realGetOwner(ByteString topic, boolean shouldClaim, \n-            Callback<HedwigSocketAddress> cb, Object ctx) {\n+    protected void realGetOwner(ByteString topic, boolean shouldClaim,\n+                                Callback<HedwigSocketAddress> cb, Object ctx) {\n \n         if (topics.contains(topic)) {\n             cb.operationFinished(ctx, addr);"},{"sha":"e884d76dbf89af916b26e0726a2643df06e49375","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -47,13 +47,13 @@\n \n /**\n  * Topics are operated on in parallel as they are independent.\n- * \n+ *\n  */\n public class ZkTopicManager extends AbstractTopicManager implements TopicManager {\n \n     static Logger logger = Logger.getLogger(ZkTopicManager.class);\n     Random rand = new Random();\n-    \n+\n     /**\n      * Persistent storage for topic metadata.\n      */\n@@ -75,7 +75,7 @@ public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n \n     /**\n      * Create a new topic manager. Pass in an active ZooKeeper client object.\n-     * \n+     *\n      * @param zk\n      */\n     public ZkTopicManager(final ZooKeeper zk, final ServerConfiguration cfg, ScheduledExecutorService scheduler)\n@@ -93,18 +93,18 @@ public void process(WatchedEvent event) {\n                         logger.warn(\"ZK client has been disconnected to the ZK server!\");\n                         isSuspended = true;\n                     } else if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n-\t\t\tif (isSuspended) {\n-\t                    logger.info(\"ZK client has been reconnected to the ZK server!\");\n-\t\t\t}\n-\t\t\tisSuspended = false;\n+                        if (isSuspended) {\n+                            logger.info(\"ZK client has been reconnected to the ZK server!\");\n+                        }\n+                        isSuspended = false;\n                     }\n-\t\t}\n-\t\t// Check for expired connection.\n+                }\n+                // Check for expired connection.\n                 if (event.getState().equals(Watcher.Event.KeeperState.Expired)) {\n                     logger.error(\"ZK client connection to the ZK server has expired!\");\n                     System.exit(1);\n-                }             \n-\t    }\n+                }\n+            }\n         });\n         final SynchronousQueue<Either<Void, PubSubException>> queue = new SynchronousQueue<Either<Void, PubSubException>>();\n \n@@ -132,41 +132,41 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n     void registerWithZookeeper(final Callback<Void> callback, Object ctx) {\n \n         ZkUtils.createFullPathOptimistic(zk, ephemeralNodePath, getCurrentLoadData(), Ids.OPEN_ACL_UNSAFE,\n-                CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n+        CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n+\n+            @Override\n+            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                if (rc == Code.OK.intValue()) {\n+                    callback.operationFinished(ctx, null);\n+                    return;\n+                }\n+                if (rc != Code.NODEEXISTS.intValue()) {\n+                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                             \"Could not create ephemeral node to register hub\", ephemeralNodePath, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                    return;\n+                }\n \n+                logger.info(\"Found stale ephemeral node while registering hub with ZK, deleting it\");\n+\n+                // Node exists, lets try to delete it and retry\n+                zk.delete(ephemeralNodePath, -1, new SafeAsyncZKCallback.VoidCallback() {\n                     @Override\n-                    public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                        if (rc == Code.OK.intValue()) {\n-                            callback.operationFinished(ctx, null);\n-                            return;\n-                        }\n-                        if (rc != Code.NODEEXISTS.intValue()) {\n-                            KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                    \"Could not create ephemeral node to register hub\", ephemeralNodePath, rc);\n-                            callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                    public void safeProcessResult(int rc, String path, Object ctx) {\n+                        if (rc == Code.OK.intValue() || rc == Code.NONODE.intValue()) {\n+                            registerWithZookeeper(callback, ctx);\n                             return;\n                         }\n-\n-                        logger.info(\"Found stale ephemeral node while registering hub with ZK, deleting it\");\n-\n-                        // Node exists, lets try to delete it and retry\n-                        zk.delete(ephemeralNodePath, -1, new SafeAsyncZKCallback.VoidCallback() {\n-                            @Override\n-                            public void safeProcessResult(int rc, String path, Object ctx) {\n-                                if (rc == Code.OK.intValue() || rc == Code.NONODE.intValue()) {\n-                                    registerWithZookeeper(callback, ctx);\n-                                    return;\n-                                }\n-                                KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                        \"Could not delete stale ephemeral node to register hub\", ephemeralNodePath, rc);\n-                                callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                                return;\n-\n-                            }\n-                        }, ctx);\n+                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                                 \"Could not delete stale ephemeral node to register hub\", ephemeralNodePath, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                        return;\n \n                     }\n-                }, null);\n+                }, ctx);\n+\n+            }\n+        }, null);\n     }\n \n     String hubPath(ByteString topic) {\n@@ -175,12 +175,12 @@ String hubPath(ByteString topic) {\n \n     @Override\n     protected void realGetOwner(final ByteString topic, final boolean shouldClaim,\n-            final Callback<HedwigSocketAddress> cb, final Object ctx) {\n+                                final Callback<HedwigSocketAddress> cb, final Object ctx) {\n         // If operations are suspended due to a ZK client disconnect, just error\n         // out this call and return.\n         if (isSuspended) {\n             cb.operationFailed(ctx, new PubSubException.ServiceDownException(\n-                    \"ZKTopicManager service is temporarily suspended!\"));\n+                                   \"ZKTopicManager service is temporarily suspended!\"));\n             return;\n         }\n \n@@ -217,7 +217,7 @@ public void choose() {\n                 public void safeProcessResult(int rc, String path, Object ctx, List<String> children) {\n                     if (rc != Code.OK.intValue()) {\n                         KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                                \"Could not get list of available hubs\", path, rc);\n+                                                \"Could not get list of available hubs\", path, rc);\n                         cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                         return;\n                     }\n@@ -238,8 +238,8 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                         if (rc == KeeperException.Code.OK.intValue()) {\n                             try {\n                                 int load = Integer.parseInt(new String(data));\n-                                if (logger.isDebugEnabled()){\n-                                \tlogger.debug(\"Found server: \" + ctx + \" with load: \" + load);\n+                                if (logger.isDebugEnabled()) {\n+                                    logger.debug(\"Found server: \" + ctx + \" with load: \" + load);\n                                 }\n                                 if (load < minLoad  || (load == minLoad && rand.nextBoolean())) {\n                                     minLoad = load;\n@@ -256,7 +256,7 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                         if (numResponses == children.size()) {\n                             if (leastLoaded == null) {\n                                 cb.operationFailed(ZkGetOwnerOp.this.ctx, new PubSubException.ServiceDownException(\n-                                        \"No hub available\"));\n+                                                       \"No hub available\"));\n                                 return;\n                             }\n                             HedwigSocketAddress owner = new HedwigSocketAddress(leastLoaded);\n@@ -273,7 +273,7 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n \n             for (String child : children) {\n                 zk.getData(cfg.getZkHostsPrefix(new StringBuilder()).append(\"/\").append(child).toString(), false,\n-                        dataCallback, child);\n+                           dataCallback, child);\n             }\n         }\n \n@@ -296,7 +296,7 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n \n                     if (rc != Code.OK.intValue()) {\n                         KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read ownership for topic: \"\n-                                + topic.toStringUtf8(), path, rc);\n+                                            + topic.toStringUtf8(), path, rc);\n                         cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                         return;\n                     }\n@@ -324,7 +324,7 @@ public void processResult(int rc, String path, Object ctx) {\n                                 claimOrChoose();\n                             } else {\n                                 KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                                        \"Could not delete self node for topic: \" + topic.toStringUtf8(), path, rc);\n+                                                        \"Could not delete self node for topic: \" + topic.toStringUtf8(), path, rc);\n                                 cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                             }\n                         }\n@@ -339,26 +339,26 @@ public void claim() {\n             }\n \n             ZkUtils.createFullPathOptimistic(zk, hubPath, addr.toString().getBytes(), Ids.OPEN_ACL_UNSAFE,\n-                    CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n+            CreateMode.EPHEMERAL, new SafeAsyncZKCallback.StringCallback() {\n \n-                        @Override\n-                        public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                            if (rc == Code.OK.intValue()) {\n-                                if (logger.isDebugEnabled()) {\n-                                    logger.debug(\"claimed topic: \" + topic.toStringUtf8());\n-                                }\n-                                notifyListenersAndAddToOwnedTopics(topic, cb, ctx);\n-                                updateLoadInformation();\n-                            } else if (rc == Code.NODEEXISTS.intValue()) {\n-                                read();\n-                            } else {\n-                                KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                                        \"Failed to create ephemeral node to claim ownership of topic: \"\n-                                                + topic.toStringUtf8(), path, rc);\n-                                cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n-                            }\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                    if (rc == Code.OK.intValue()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"claimed topic: \" + topic.toStringUtf8());\n                         }\n-                    }, ctx);\n+                        notifyListenersAndAddToOwnedTopics(topic, cb, ctx);\n+                        updateLoadInformation();\n+                    } else if (rc == Code.NODEEXISTS.intValue()) {\n+                        read();\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Failed to create ephemeral node to claim ownership of topic: \"\n+                                                + topic.toStringUtf8(), path, rc);\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                    }\n+                }\n+            }, ctx);\n         }\n \n     }\n@@ -370,10 +370,10 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n     }\n \n     void updateLoadInformation() {\n-    \tbyte[] currentLoad = getCurrentLoadData();\n-    \tif (logger.isDebugEnabled()){\n-    \t\tlogger.debug(\"Reporting load of \" + new String(currentLoad));\n-    \t}\n+        byte[] currentLoad = getCurrentLoadData();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Reporting load of \" + new String(currentLoad));\n+        }\n         zk.setData(ephemeralNodePath, currentLoad, -1, loadReportingStatCallback, null);\n     }\n \n@@ -393,15 +393,15 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n \n                 if (rc != Code.OK.intValue()) {\n                     KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                            \"Failed to delete self-ownership node for topic: \" + topic.toStringUtf8(), path, rc);\n+                                            \"Failed to delete self-ownership node for topic: \" + topic.toStringUtf8(), path, rc);\n                     cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                     return;\n                 }\n \n                 HedwigSocketAddress owner = new HedwigSocketAddress(new String(data));\n                 if (!owner.equals(addr)) {\n                     logger.warn(\"Wanted to delete self-node for topic: \" + topic.toStringUtf8() + \" but node for \"\n-                            + owner + \" found, leaving untouched\");\n+                                + owner + \" found, leaving untouched\");\n                     // Not our node, someone else's, leave it alone\n                     cb.operationFinished(ctx, null);\n                     return;\n@@ -412,8 +412,8 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                     public void safeProcessResult(int rc, String path, Object ctx) {\n                         if (rc != Code.OK.intValue() && rc != Code.NONODE.intValue()) {\n                             KeeperException e = ZkUtils\n-                                    .logErrorAndCreateZKException(\"Failed to delete self-ownership node for topic: \"\n-                                            + topic.toStringUtf8(), path, rc);\n+                                                .logErrorAndCreateZKException(\"Failed to delete self-ownership node for topic: \"\n+                                                        + topic.toStringUtf8(), path, rc);\n                             cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                             return;\n                         }"},{"sha":"b708ab9f8dd1d617b437be7404a17b1eadbea11f","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,81 +24,81 @@\n import org.apache.bookkeeper.client.LedgerHandle;\n \n \n-public class SafeAsynBKCallback extends SafeAsyncCallback{\n+public class SafeAsynBKCallback extends SafeAsyncCallback {\n \n     public static abstract class OpenCallback implements AsyncCallback.OpenCallback {\n         @Override\n         public void openComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n-            try{\n+            try {\n                 safeOpenComplete(rc, ledgerHandle, ctx);\n-            }catch(Throwable t){\n+            } catch(Throwable t) {\n                 invokeUncaughtExceptionHandler(t);\n             }\n         }\n-        \n+\n         public abstract void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx);\n \n     }\n-    \n+\n     public static abstract class CloseCallback implements AsyncCallback.CloseCallback {\n         @Override\n-        public void closeComplete(int rc, LedgerHandle ledgerHandle, Object ctx){\n-            try{\n+        public void closeComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n+            try {\n                 safeCloseComplete(rc, ledgerHandle, ctx);\n-            }catch(Throwable t){\n+            } catch(Throwable t) {\n                 invokeUncaughtExceptionHandler(t);\n             }\n         }\n-        \n+\n         public abstract void safeCloseComplete(int rc, LedgerHandle ledgerHandle, Object ctx) ;\n     }\n-    \n+\n     public static abstract class ReadCallback implements AsyncCallback.ReadCallback {\n-        \n+\n         @Override\n         public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-            try{\n+            try {\n                 safeReadComplete(rc, lh, seq, ctx);\n-            }catch(Throwable t){\n+            } catch(Throwable t) {\n                 invokeUncaughtExceptionHandler(t);\n             }\n-            \n+\n         }\n-        \n+\n         public abstract void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx);\n     }\n-    \n+\n     public static abstract class CreateCallback implements AsyncCallback.CreateCallback {\n-        \n+\n         @Override\n         public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n-            try{\n+            try {\n                 safeCreateComplete(rc, lh, ctx);\n-            }catch(Throwable t){\n+            } catch(Throwable t) {\n                 invokeUncaughtExceptionHandler(t);\n             }\n-            \n+\n         }\n-        \n+\n         public abstract void safeCreateComplete(int rc, LedgerHandle lh, Object ctx);\n-        \n-        \n+\n+\n     }\n-    \n+\n     public static abstract class AddCallback implements AsyncCallback.AddCallback {\n-        \n+\n         @Override\n         public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-            try{\n+            try {\n                 safeAddComplete(rc, lh, entryId, ctx);\n-            }catch(Throwable t){\n+            } catch(Throwable t) {\n                 invokeUncaughtExceptionHandler(t);\n             }\n         }\n-        \n+\n         public abstract void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n-        \n+\n     }\n-    \n+\n }\n "},{"sha":"4e519f3b75db24c95967990a32c39227264bd876","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -23,7 +23,7 @@\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n \n-public class SafeAsyncZKCallback extends SafeAsyncCallback{\n+public class SafeAsyncZKCallback extends SafeAsyncCallback {\n     public static abstract class StatCallback implements AsyncCallback.StatCallback {\n         public void processResult(int rc, String path, Object ctx, Stat stat) {\n             try {"},{"sha":"8f0de639e5ec2fd82cd98f6275b112032be9b33e","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -50,20 +50,20 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n                 // create mode is persistent since ephemeral nodes can't be\n                 // parents\n                 ZkUtils.createFullPathOptimistic(zk, PathUtils.parent(originalPath), new byte[0], acl,\n-                        CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+                CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n \n-                            @Override\n-                            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                                if (rc == Code.OK.intValue() || rc == Code.NODEEXISTS.intValue()) {\n-                                    // succeeded in creating the parent, now\n-                                    // create the original path\n-                                    ZkUtils.createFullPathOptimistic(zk, originalPath, data, acl, createMode, callback,\n-                                            ctx);\n-                                } else {\n-                                    callback.processResult(rc, path, ctx, name);\n-                                }\n-                            }\n-                        }, ctx);\n+                    @Override\n+                    public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                        if (rc == Code.OK.intValue() || rc == Code.NODEEXISTS.intValue()) {\n+                            // succeeded in creating the parent, now\n+                            // create the original path\n+                            ZkUtils.createFullPathOptimistic(zk, originalPath, data, acl, createMode, callback,\n+                                                             ctx);\n+                        } else {\n+                            callback.processResult(rc, path, ctx, name);\n+                        }\n+                    }\n+                }, ctx);\n             }\n         }, ctx);\n "},{"sha":"972e145a8ec327a3b154bdca74ba96e059bc3c5e","filename":"hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -29,7 +29,8 @@\n \n     public static List<Message> getRandomPublishedMessages(int numMessages, int size) {\n         ByteString[] regions = { ByteString.copyFromUtf8(\"sp1\"), ByteString.copyFromUtf8(\"re1\"),\n-                ByteString.copyFromUtf8(\"sg\") };\n+                                 ByteString.copyFromUtf8(\"sg\")\n+                               };\n         return getRandomPublishedMessages(numMessages, size, regions);\n     }\n \n@@ -39,7 +40,7 @@\n             byte[] body = new byte[size];\n             rand.nextBytes(body);\n             msgs.add(Message.newBuilder().setBody(ByteString.copyFrom(body)).setSrcRegion(\n-                    regions[rand.nextInt(regions.length)]).build());\n+                         regions[rand.nextInt(regions.length)]).build());\n         }\n         return msgs;\n     }"},{"sha":"be64f93532b78375a9097f801e4ec178902ca008","filename":"hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java","status":"modified","additions":170,"deletions":166,"changes":336,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -37,197 +37,201 @@\n     static Logger LOG = Logger.getLogger(ServerControl.class);\n \n     public class TestException extends Exception {\n-\tpublic TestException(String str) {\n-\t    super(str);\n-\t}\n+        public TestException(String str) {\n+            super(str);\n+        }\n     };\n \n     public interface TestServer {\n-\tpublic String getAddress();\n-\tpublic void kill();\n+        public String getAddress();\n+        public void kill();\n     }\n \n     private class BookKeeperServer extends BookieServer implements TestServer {\n-\tprivate String address;\n-\n-\tpublic BookKeeperServer(int port, TestServer zkserver, String journal, String ledger) throws IOException {\n-\t    super(port, zkserver.getAddress(), new File(journal), new File[] { new File(ledger) });\n-\t    \n-\t    address = \"localhost:\"+port;\n-\t    start();\n-\t} \n-\n-\tpublic String getAddress() {\n-\t    return address;\n-\t}\n-\t\n-\tpublic void kill() {\n-\t    try {\n-\t\tshutdown();\n-\t    } catch (Exception e) {\n-\t    }\n-\t}\n+        private String address;\n+\n+        public BookKeeperServer(int port, TestServer zkserver, String journal, String ledger) throws IOException {\n+            super(port, zkserver.getAddress(), new File(journal), new File[] { new File(ledger) });\n+\n+            address = \"localhost:\"+port;\n+            start();\n+        }\n+\n+        public String getAddress() {\n+            return address;\n+        }\n+\n+        public void kill() {\n+            try {\n+                shutdown();\n+            } catch (Exception e) {\n+            }\n+        }\n     }\n \n     private class ZookeeperServer extends ZooKeeperServerMain implements TestServer {\n-\tpublic String address;\n-\tpublic Thread serverThread;\n-\tString path;\n-\tpublic ZookeeperServer(int port, String path) throws TestException {\n-\t    super(); \n-\n-\t    this.path = path;\n-\t    final String[] args = { Integer.toString(port), path};\n-\t    address = \"localhost:\" + port;\n-\t    serverThread = new Thread() {\n-\t\t    public void run() {\n-\t\t\ttry {\n-\t\t\t    initializeAndRun(args);\n-\t\t\t} catch (Exception e) {\n-\t\t\t}\n-\t\t    };\n-\t\t};\n-\t    serverThread.start();\n-\t}\n-\n-\tpublic String getAddress() {\n-\t    return address;\n-\t}\n-\n-\tpublic void kill() {\n-\t    shutdown();\n-\t    serverThread.interrupt();\n-\t}\n+        public String address;\n+        public Thread serverThread;\n+        String path;\n+        public ZookeeperServer(int port, String path) throws TestException {\n+            super();\n+\n+            this.path = path;\n+            final String[] args = { Integer.toString(port), path};\n+            address = \"localhost:\" + port;\n+            serverThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        initializeAndRun(args);\n+                    } catch (Exception e) {\n+                    }\n+                };\n+            };\n+            serverThread.start();\n+        }\n+\n+        public String getAddress() {\n+            return address;\n+        }\n+\n+        public void kill() {\n+            shutdown();\n+            serverThread.interrupt();\n+        }\n     }\n \n     private class HedwigServer implements TestServer {\n-\tprivate PubSubServer server;\n-\tprivate String address;\n-\n-\tpublic HedwigServer(int port, String region, TestServer zk) throws TestException {\n-\t    class MyServerConfiguration extends ServerConfiguration {\n-\t\tMyServerConfiguration(int port, TestServer zk, String region) {\n-\t\t    conf.setProperty(ServerConfiguration.SERVER_PORT, port);\n-\t\t    conf.setProperty(ServerConfiguration.ZK_HOST, zk.getAddress());\n-\t\t    conf.setProperty(ServerConfiguration.REGION, region);\n-\t\t}\n-\t    };\n-\t    \n-\t    address = \"localhost:\" + port;\n-\t    \n-\t    try {\n-\t\tserver = new PubSubServer(new MyServerConfiguration(port, zk, region));\n-\t    } catch (Exception e) {\n-\t\tthrow new TestException(\"Couldn't create pub sub server : \" + e);\n-\t    }\n-\t}\n-\n-\tpublic String getAddress() {\n-\t    return address;\n-\t}\n-\n-\tpublic void kill() {\n-\t    server.shutdown();\n-\t}\n+        private PubSubServer server;\n+        private String address;\n+\n+        public HedwigServer(int port, String region, TestServer zk) throws TestException {\n+            class MyServerConfiguration extends ServerConfiguration {\n+                MyServerConfiguration(int port, TestServer zk, String region) {\n+                    conf.setProperty(ServerConfiguration.SERVER_PORT, port);\n+                    conf.setProperty(ServerConfiguration.ZK_HOST, zk.getAddress());\n+                    conf.setProperty(ServerConfiguration.REGION, region);\n+                }\n+            };\n+\n+            address = \"localhost:\" + port;\n+\n+            try {\n+                server = new PubSubServer(new MyServerConfiguration(port, zk, region));\n+            } catch (Exception e) {\n+                throw new TestException(\"Couldn't create pub sub server : \" + e);\n+            }\n+        }\n+\n+        public String getAddress() {\n+            return address;\n+        }\n+\n+        public void kill() {\n+            server.shutdown();\n+        }\n     }\n \n     private String createTempDirectory(String suffix) throws IOException {\n-\tString dir = System.getProperty(\"java.io.tmpdir\") + File.separator + System.currentTimeMillis() + suffix;\n-\tfinal File dirf = new File(dir);\n-\tboolean good = dirf.mkdir();\n-\tif (!good) {\n-\t    throw new IOException(\"Unable to create directory \" + dir);\n-\t}\n-\t\n-\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\tpublic void delete(File f) {\n-\t\t    File[] subfiles = f.listFiles();\n-\t\t    if (subfiles != null) {\n-\t\t\tfor (File subf : subfiles) {\n-\t\t\t    delete(subf);\n-\t\t\t}\n-\t\t    }\n-\t\t    f.delete();\n-\t\t}\n-\n-\t\tpublic void run() {\n-\t\t    delete(dirf);\n-\t\t}\n-\t    });\n-\treturn dir;\n+        String dir = System.getProperty(\"java.io.tmpdir\") + File.separator + System.currentTimeMillis() + suffix;\n+        final File dirf = new File(dir);\n+        boolean good = dirf.mkdir();\n+        if (!good) {\n+            throw new IOException(\"Unable to create directory \" + dir);\n+        }\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            public void delete(File f) {\n+                File[] subfiles = f.listFiles();\n+                if (subfiles != null) {\n+                    for (File subf : subfiles) {\n+                        delete(subf);\n+                    }\n+                }\n+                f.delete();\n+            }\n+\n+            public void run() {\n+                delete(dirf);\n+            }\n+        });\n+        return dir;\n     }\n \n     public TestServer startZookeeperServer(int port) throws IOException, TestException {\n-\tString dir = createTempDirectory(\"-zookeeper-\" + port);\n-\tZookeeperServer server =  new ZookeeperServer(port, dir);\n-\t\n-\treturn server;\n+        String dir = createTempDirectory(\"-zookeeper-\" + port);\n+        ZookeeperServer server =  new ZookeeperServer(port, dir);\n+\n+        return server;\n     }\n-    \n+\n     public TestServer startBookieServer(int port, TestServer zookeeperServer) throws IOException, TestException {\n-\tint tries = 4;\n-\twhile (true) {\n-\t    try {\n-\t\ttries--;\n-\t\tZooKeeper zk = new ZooKeeper(zookeeperServer.getAddress(), 1000, new Watcher() { public void process(WatchedEvent event) { /* do nothing */ } });\n-\t\tif (zk.exists(\"/ledgers/available\", false) == null) {\n-\t\t    byte[] data = new byte[1];\n-\t\t    data[0] = 0;\n-\t\t    zk.create(\"/ledgers\", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-\t\t    zk.create(\"/ledgers/available\", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-\t\t}\n-\t\tzk.close();\n-\t\tbreak;\n-\t    } catch (KeeperException.ConnectionLossException ce) {\n-\t\tif (tries > 0) {\n-\t\t    try { \n-\t\t\tThread.sleep(3);\n-\t\t    } catch (Exception e) {\n-\t\t\tthrow new TestException(\"Can't even sleep. Fix your machine: \" + e);\n-\t\t    }\n-\t\t    continue;\n-\t\t} else {\n-\t\t    throw new TestException(\"Error connecting to zookeeper: \" + ce);\n-\t\t}\n-\t    } catch (Exception e) {\n-\t\tthrow new TestException(\"Error initialising bookkeeper ledgers: \" +  e);\n-\t    } \n-\t}\n-\tString journal = createTempDirectory(\"-bookie-\" + port + \"-journal\");\n-\tString ledger = createTempDirectory(\"-bookie-\" + port + \"-ledger\");\n-\tBookKeeperServer bookie = new BookKeeperServer(port, zookeeperServer, journal, ledger);\n-\treturn bookie;\n+        int tries = 4;\n+        while (true) {\n+            try {\n+                tries--;\n+                ZooKeeper zk = new ZooKeeper(zookeeperServer.getAddress(), 1000, new Watcher() {\n+                    public void process(WatchedEvent event) {\n+                        /* do nothing */\n+                    }\n+                });\n+                if (zk.exists(\"/ledgers/available\", false) == null) {\n+                    byte[] data = new byte[1];\n+                    data[0] = 0;\n+                    zk.create(\"/ledgers\", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+                    zk.create(\"/ledgers/available\", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+                }\n+                zk.close();\n+                break;\n+            } catch (KeeperException.ConnectionLossException ce) {\n+                if (tries > 0) {\n+                    try {\n+                        Thread.sleep(3);\n+                    } catch (Exception e) {\n+                        throw new TestException(\"Can't even sleep. Fix your machine: \" + e);\n+                    }\n+                    continue;\n+                } else {\n+                    throw new TestException(\"Error connecting to zookeeper: \" + ce);\n+                }\n+            } catch (Exception e) {\n+                throw new TestException(\"Error initialising bookkeeper ledgers: \" +  e);\n+            }\n+        }\n+        String journal = createTempDirectory(\"-bookie-\" + port + \"-journal\");\n+        String ledger = createTempDirectory(\"-bookie-\" + port + \"-ledger\");\n+        BookKeeperServer bookie = new BookKeeperServer(port, zookeeperServer, journal, ledger);\n+        return bookie;\n     }\n-    \n+\n     public TestServer startPubSubServer(int port, String region, TestServer zookeeperServer) throws IOException, TestException {\n-\treturn new HedwigServer(port, region, zookeeperServer);\n-    }    \n+        return new HedwigServer(port, region, zookeeperServer);\n+    }\n \n     public ServerControl() {\n     }\n \n     public static void main(String[] args) throws Exception {\n-\tServerControl control = new ServerControl();\n-\n-\tTestServer zk = control.startZookeeperServer(12345);\n-\tTestServer bk1 = control.startBookieServer(12346, zk);\n-\tTestServer bk2 = control.startBookieServer(12347, zk);\n-\tTestServer bk3 = control.startBookieServer(12348, zk);\n-\n-\tTestServer hw1 = control.startPubSubServer(12349, \"foobar\", zk);\n-\tTestServer hw2 = control.startPubSubServer(12350, \"foobar\", zk);\n-\tTestServer hw3 = control.startPubSubServer(12351, \"foobar\", zk);\n-\tTestServer hw4 = control.startPubSubServer(12352, \"barfoo\", zk);\n-\tLOG.info(\"Started \" + zk.getAddress());\n-\tLOG.info(\"Sleeping for 10 seconds\");\n-\tThread.sleep(10000);\n-\tbk3.kill();\n-\tbk2.kill();\n-\tbk1.kill();\n-\tzk.kill();\n-\thw1.kill();\n-\thw2.kill();\n-\thw3.kill();\n-\thw4.kill();\n+        ServerControl control = new ServerControl();\n+\n+        TestServer zk = control.startZookeeperServer(12345);\n+        TestServer bk1 = control.startBookieServer(12346, zk);\n+        TestServer bk2 = control.startBookieServer(12347, zk);\n+        TestServer bk3 = control.startBookieServer(12348, zk);\n+\n+        TestServer hw1 = control.startPubSubServer(12349, \"foobar\", zk);\n+        TestServer hw2 = control.startPubSubServer(12350, \"foobar\", zk);\n+        TestServer hw3 = control.startPubSubServer(12351, \"foobar\", zk);\n+        TestServer hw4 = control.startPubSubServer(12352, \"barfoo\", zk);\n+        LOG.info(\"Started \" + zk.getAddress());\n+        LOG.info(\"Sleeping for 10 seconds\");\n+        Thread.sleep(10000);\n+        bk3.kill();\n+        bk2.kill();\n+        bk1.kill();\n+        zk.kill();\n+        hw1.kill();\n+        hw2.kill();\n+        hw3.kill();\n+        hw4.kill();\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"14de7056484e0a70100a1c2b275f3601208cf5cd","filename":"hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java","status":"modified","additions":116,"deletions":116,"changes":232,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -28,7 +28,7 @@\n \n import org.apache.log4j.Logger;\n \n-import org.jboss.netty.channel.Channel;  \n+import org.jboss.netty.channel.Channel;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.channel.ChannelEvent;\n import org.jboss.netty.channel.ChannelHandlerContext;\n@@ -49,123 +49,123 @@\n         Logger.getLogger(ServerControlDaemon.class);\n \n     @ChannelPipelineCoverage(\"all\")\n-    public static class ServerControlDaemonHandler extends SimpleChannelUpstreamHandler{\n-\tprivate ServerControl control;\n-\tprivate HashMap<Channel, HashMap<String, ServerControl.TestServer>> serverMap;\n-\t\n-\tpublic ServerControlDaemonHandler() {\n-\t    serverMap = new HashMap<Channel, HashMap<String, ServerControl.TestServer>>();\n-\t    control = new ServerControl();\n-\t}\n-\n-\tprivate void addServerForChannel(Channel c, ServerControl.TestServer t) {\n-\t    LOG.info(\"Created server \" + t.getAddress());\n-\t    HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n-\t    if (map == null) {\n-\t\tmap = new HashMap<String, ServerControl.TestServer>();\n-\t\tserverMap.put(c, map);\n-\t    }\n-\t    map.put(t.getAddress(), t);\t    \n-\t}\n-\t\n-\tprivate void killServerForChannel(Channel c, String name) {\n-\t    LOG.info(\"Killing server \" + name);\n-\t    HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n-\t    ServerControl.TestServer t = map.get(name);\n-\t    map.remove(name);\n-\t    try {\n-\t\tt.kill();\n-\t    } catch (Exception e) {\n-\t\tLOG.error(\"Error killing server\", e);\n-\t\t// do nothing, should be killed, we won't use it again anyhow\n-\t    }\n-\t}\n-\n-\tprivate ServerControl.TestServer lookupServer(Channel c, String name) {\n-\t    HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n-\t    return map.get(name);\n-\t}\n-\t\n-\tprivate void clearServersForChannel(Channel c) {\n-\t    HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n-\t    serverMap.remove(map);\n-\t    \n-\t    if (map != null) {\n-\t\tfor (ServerControl.TestServer t : map.values()) {\n-\t\t    t.kill();\n-\t\t}\n-\t\tmap.clear();\n-\t    }\n-\t}\n-\n-\tpublic void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {\n-\t    try {\n-\t\tString command = (String)e.getMessage();\n-\t\tLOG.info(\"Command: \" + command);\n-\t\tString[] args = command.split(\"\\\\s+\");\n-\n-\t\tif (args[0].equals(\"START\")) {\n-\t\t    ServerControl.TestServer t = null;\n-\t\t    if (args[1].equals(\"ZOOKEEPER\")) {\n-\t\t\tt = control.startZookeeperServer(Integer.valueOf(args[2]));\n-\t\t\taddServerForChannel(ctx.getChannel(), t);\n-\t\t    } else if (args[1].equals(\"BOOKKEEPER\")) {\n-\t\t\tServerControl.TestServer zk = lookupServer(ctx.getChannel(), args[3]);\n-\t\t\tt = control.startBookieServer(Integer.valueOf(args[2]), zk);\n-\t\t\taddServerForChannel(ctx.getChannel(), t);\n-\t\t    } else if (args[1].equals(\"HEDWIG\")) {\n-\t\t\tServerControl.TestServer zk = lookupServer(ctx.getChannel(), args[4]);\n-\t\t\tt = control.startPubSubServer(Integer.valueOf(args[2]), args[3], zk);\n-\t\t\taddServerForChannel(ctx.getChannel(), t);\n-\t\t    }\n-\n-\t\t    ctx.getChannel().write(\"OK \" + t.getAddress() + \"\\n\");\n-\t\t} else if (args[0].equals(\"KILL\")) {\n-\t\t    killServerForChannel(ctx.getChannel(), args[1]);\n-\t\t    \n-\t\t    ctx.getChannel().write(\"OK Killed \" + args[1] + \"\\n\");\n-\t\t} else if (args[0].equals(\"TEST\")) {\n-\t\t    LOG.info(\"\\n******\\n\\n\" + args[1] + \"\\n\\n******\");\n-\t\t    ctx.getChannel().write(\"OK Test Noted\\n\");\n-\t\t} else {\n-\t\t    ctx.getChannel().write(\"ERR Bad Command\\n\");\n-\t\t}\n-\t    } catch (Exception ex) {\n-\t\tLOG.error(\"Error handling message\", ex);\n-\t\tctx.getChannel().write(\"ERR \" + ex.toString() + \"\\n\");\n-\t    }\n-\t}\n-\t\n-\tpublic void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-\t    clearServersForChannel(ctx.getChannel());\n-\t}\n+    public static class ServerControlDaemonHandler extends SimpleChannelUpstreamHandler {\n+        private ServerControl control;\n+        private HashMap<Channel, HashMap<String, ServerControl.TestServer>> serverMap;\n+\n+        public ServerControlDaemonHandler() {\n+            serverMap = new HashMap<Channel, HashMap<String, ServerControl.TestServer>>();\n+            control = new ServerControl();\n+        }\n+\n+        private void addServerForChannel(Channel c, ServerControl.TestServer t) {\n+            LOG.info(\"Created server \" + t.getAddress());\n+            HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n+            if (map == null) {\n+                map = new HashMap<String, ServerControl.TestServer>();\n+                serverMap.put(c, map);\n+            }\n+            map.put(t.getAddress(), t);\n+        }\n+\n+        private void killServerForChannel(Channel c, String name) {\n+            LOG.info(\"Killing server \" + name);\n+            HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n+            ServerControl.TestServer t = map.get(name);\n+            map.remove(name);\n+            try {\n+                t.kill();\n+            } catch (Exception e) {\n+                LOG.error(\"Error killing server\", e);\n+                // do nothing, should be killed, we won't use it again anyhow\n+            }\n+        }\n+\n+        private ServerControl.TestServer lookupServer(Channel c, String name) {\n+            HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n+            return map.get(name);\n+        }\n+\n+        private void clearServersForChannel(Channel c) {\n+            HashMap<String, ServerControl.TestServer> map = serverMap.get(c);\n+            serverMap.remove(map);\n+\n+            if (map != null) {\n+                for (ServerControl.TestServer t : map.values()) {\n+                    t.kill();\n+                }\n+                map.clear();\n+            }\n+        }\n+\n+        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {\n+            try {\n+                String command = (String)e.getMessage();\n+                LOG.info(\"Command: \" + command);\n+                String[] args = command.split(\"\\\\s+\");\n+\n+                if (args[0].equals(\"START\")) {\n+                    ServerControl.TestServer t = null;\n+                    if (args[1].equals(\"ZOOKEEPER\")) {\n+                        t = control.startZookeeperServer(Integer.valueOf(args[2]));\n+                        addServerForChannel(ctx.getChannel(), t);\n+                    } else if (args[1].equals(\"BOOKKEEPER\")) {\n+                        ServerControl.TestServer zk = lookupServer(ctx.getChannel(), args[3]);\n+                        t = control.startBookieServer(Integer.valueOf(args[2]), zk);\n+                        addServerForChannel(ctx.getChannel(), t);\n+                    } else if (args[1].equals(\"HEDWIG\")) {\n+                        ServerControl.TestServer zk = lookupServer(ctx.getChannel(), args[4]);\n+                        t = control.startPubSubServer(Integer.valueOf(args[2]), args[3], zk);\n+                        addServerForChannel(ctx.getChannel(), t);\n+                    }\n+\n+                    ctx.getChannel().write(\"OK \" + t.getAddress() + \"\\n\");\n+                } else if (args[0].equals(\"KILL\")) {\n+                    killServerForChannel(ctx.getChannel(), args[1]);\n+\n+                    ctx.getChannel().write(\"OK Killed \" + args[1] + \"\\n\");\n+                } else if (args[0].equals(\"TEST\")) {\n+                    LOG.info(\"\\n******\\n\\n\" + args[1] + \"\\n\\n******\");\n+                    ctx.getChannel().write(\"OK Test Noted\\n\");\n+                } else {\n+                    ctx.getChannel().write(\"ERR Bad Command\\n\");\n+                }\n+            } catch (Exception ex) {\n+                LOG.error(\"Error handling message\", ex);\n+                ctx.getChannel().write(\"ERR \" + ex.toString() + \"\\n\");\n+            }\n+        }\n+\n+        public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+            clearServersForChannel(ctx.getChannel());\n+        }\n     }\n \n     public static void main(String[] args) throws Exception {\n-\t// Configure the server.\n-\tint port = 5672;\n-\tif (args.length == 1) {\n-\t    port = Integer.valueOf(args[0]); \n-\t}\n-\tServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),\n-\t\t\t\t\t\t\t\t\t\t\t  Executors.newCachedThreadPool()));\n-\t// Set up the pipeline factory.\n-\tbootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n-\t\tpublic ChannelPipeline getPipeline() throws Exception {\n-\t\t    ChannelPipeline p = Channels.pipeline();\n-\t\t    p.addLast(\"frameDecoder\", new DelimiterBasedFrameDecoder(80, Delimiters.lineDelimiter()));\n-\t\t    p.addLast(\"stringDecoder\", new StringDecoder(\"UTF-8\"));\n-\t\t    \n-\t\t    // Encoder\n-\t\t    p.addLast(\"stringEncoder\", new StringEncoder(\"UTF-8\"));\n-\t\t    p.addLast(\"handler\", new ServerControlDaemonHandler());\n-\t\t    \n-\t\t    return p;\n-\t\t}\n-\t    });\n-\t\n-\tLOG.info(\"Listening on localhost:\"+port);\n-\t// Bind and start to accept incoming connections.\n-\tbootstrap.bind(new InetSocketAddress(port));\n+        // Configure the server.\n+        int port = 5672;\n+        if (args.length == 1) {\n+            port = Integer.valueOf(args[0]);\n+        }\n+        ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),\n+                Executors.newCachedThreadPool()));\n+        // Set up the pipeline factory.\n+        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n+            public ChannelPipeline getPipeline() throws Exception {\n+                ChannelPipeline p = Channels.pipeline();\n+                p.addLast(\"frameDecoder\", new DelimiterBasedFrameDecoder(80, Delimiters.lineDelimiter()));\n+                p.addLast(\"stringDecoder\", new StringDecoder(\"UTF-8\"));\n+\n+                // Encoder\n+                p.addLast(\"stringEncoder\", new StringEncoder(\"UTF-8\"));\n+                p.addLast(\"handler\", new ServerControlDaemonHandler());\n+\n+                return p;\n+            }\n+        });\n+\n+        LOG.info(\"Listening on localhost:\"+port);\n+        // Bind and start to accept incoming connections.\n+        bootstrap.bind(new InetSocketAddress(port));\n     }\n }"},{"sha":"64a851f5a4b8b0f13f4474dd6b72d1ac2d7785eb","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -78,7 +78,7 @@ public void run() {\n     // Test implementation of subscriber's message handler.\n     class TestMessageHandler implements MessageHandler {\n         public void consume(ByteString topic, ByteString subscriberId, Message msg, Callback<Void> callback,\n-                Object context) {\n+                            Object context) {\n             new Thread(new Runnable() {\n                 @Override\n                 public void run() {\n@@ -112,7 +112,7 @@ public void testSyncPublish() throws Exception {\n         boolean publishSuccess = true;\n         try {\n             publisher.publish(ByteString.copyFromUtf8(\"mySyncTopic\"), Message.newBuilder().setBody(\n-                    ByteString.copyFromUtf8(\"Hello Sync World!\")).build());\n+                                  ByteString.copyFromUtf8(\"Hello Sync World!\")).build());\n         } catch (Exception e) {\n             publishSuccess = false;\n         }\n@@ -122,7 +122,7 @@ public void testSyncPublish() throws Exception {\n     @Test\n     public void testAsyncPublish() throws Exception {\n         publisher.asyncPublish(ByteString.copyFromUtf8(\"myAsyncTopic\"), Message.newBuilder().setBody(\n-                ByteString.copyFromUtf8(\"Hello Async World!\")).build(), new TestCallback(), null);\n+                                   ByteString.copyFromUtf8(\"Hello Async World!\")).build(), new TestCallback(), null);\n         assertTrue(queue.take());\n     }\n \n@@ -132,13 +132,13 @@ public void testMultipleAsyncPublish() throws Exception {\n         ByteString topic2 = ByteString.copyFromUtf8(\"myNewTopic\");\n \n         publisher.asyncPublish(topic1, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Hello World!\")).build(),\n-                new TestCallback(), null);\n+                               new TestCallback(), null);\n         assertTrue(queue.take());\n         publisher.asyncPublish(topic2, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Hello on new topic!\"))\n-                .build(), new TestCallback(), null);\n+                               .build(), new TestCallback(), null);\n         assertTrue(queue.take());\n         publisher.asyncPublish(topic1, Message.newBuilder().setBody(\n-                ByteString.copyFromUtf8(\"Hello Again on old topic!\")).build(), new TestCallback(), null);\n+                                   ByteString.copyFromUtf8(\"Hello Again on old topic!\")).build(), new TestCallback(), null);\n         assertTrue(queue.take());\n     }\n \n@@ -156,7 +156,7 @@ public void testSyncSubscribe() throws Exception {\n     @Test\n     public void testAsyncSubscribe() throws Exception {\n         subscriber.asyncSubscribe(ByteString.copyFromUtf8(\"myAsyncSubscribeTopic\"), ByteString.copyFromUtf8(\"1\"),\n-                CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(), null);\n+                                  CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(), null);\n         assertTrue(queue.take());\n     }\n \n@@ -173,23 +173,23 @@ public void testSubscribeAndConsume() throws Exception {\n         // Now publish some messages for the topic to be consumed by the\n         // subscriber.\n         publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #1\")).build(),\n-                new TestCallback(), null);\n+                               new TestCallback(), null);\n         assertTrue(queue.take());\n         assertTrue(consumeQueue.take());\n         publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #2\")).build(),\n-                new TestCallback(), null);\n+                               new TestCallback(), null);\n         assertTrue(queue.take());\n         assertTrue(consumeQueue.take());\n         publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #3\")).build(),\n-                new TestCallback(), null);\n+                               new TestCallback(), null);\n         assertTrue(queue.take());\n         assertTrue(consumeQueue.take());\n         publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #4\")).build(),\n-                new TestCallback(), null);\n+                               new TestCallback(), null);\n         assertTrue(queue.take());\n         assertTrue(consumeQueue.take());\n         publisher.asyncPublish(topic, Message.newBuilder().setBody(ByteString.copyFromUtf8(\"Message #5\")).build(),\n-                new TestCallback(), null);\n+                               new TestCallback(), null);\n         assertTrue(queue.take());\n         assertTrue(consumeQueue.take());\n     }\n@@ -227,4 +227,4 @@ public void testAsyncSubscribeAndCloseSubscription() throws Exception {\n         assertTrue(true);\n     }\n \n-}\n\\ No newline at end of file\n+}"},{"sha":"125cd931e32046639243ae53e5542b8c9dd848b3","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -33,7 +33,7 @@\n /**\n  * This is a base class for any tests that need a Hedwig Hub(s) setup with an\n  * associated BookKeeper and ZooKeeper instance.\n- * \n+ *\n  */\n public abstract class HedwigHubTestBase extends TestCase {\n \n@@ -79,7 +79,7 @@ public int getSSLServerPort() {\n         public String getZkHost() {\n             return bktb.getZkHostPort();\n         }\n-        \n+\n         @Override\n         public boolean isSSLEnabled() {\n             return true;"},{"sha":"d320c6bf032ede0329c93c8a634c50ed4a0fd79a","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -39,7 +39,7 @@\n  * This is a base class for any tests that need a Hedwig Region(s) setup with a\n  * number of Hedwig hubs per region, an associated HedwigClient per region and\n  * the required BookKeeper and ZooKeeper instances.\n- * \n+ *\n  */\n public abstract class HedwigRegionTestBase extends TestCase {\n \n@@ -173,16 +173,16 @@ public void setUp() throws Exception {\n \n         // Create the Hedwig PubSubServer Hubs for all of the regions\n         regionServersMap = new HashMap<String, List<PubSubServer>>(numRegions, 1.0f);\n-        regionClientsMap = new HashMap<String, HedwigClient>(numRegions, 1.0f);        \n+        regionClientsMap = new HashMap<String, HedwigClient>(numRegions, 1.0f);\n         for (int i = 0; i < numRegions; i++) {\n             List<PubSubServer> serversList = new LinkedList<PubSubServer>();\n             // For the current region, create the necessary amount of hub\n             // servers. We will basically increment through the port numbers\n             // starting from the initial ones defined.\n             for (int j = 0; j < numServersPerRegion; j++) {\n                 serversList.add(new PubSubServer(getServerConfiguration(initialServerPort\n-                        + (j + i * numServersPerRegion), initialSSLServerPort + (j + i * numServersPerRegion),\n-                        REGION_PREFIX + i)));\n+                                                 + (j + i * numServersPerRegion), initialSSLServerPort + (j + i * numServersPerRegion),\n+                                                 REGION_PREFIX + i)));\n             }\n             // Store this list of servers created for the current region\n             regionServersMap.put(REGION_PREFIX + i, serversList);"},{"sha":"3ed363e7ba415699e845887ab49f2e3981657a93","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -60,9 +60,9 @@ public void testPubSubServerInstantiationWithConfig() throws Exception {\n     }\n \n     private void instantiateAndDestroyPubSubServer() throws IOException, InterruptedException, ConfigurationException,\n-            MalformedURLException, Exception {\n+        MalformedURLException, Exception {\n         String hedwigParams = \"default_server_host=localhost:4080\\n\" + \"zookeeper_connection_string=localhost:2181\\n\"\n-                + \"zk_timeout=2000\\n\";\n+                              + \"zk_timeout=2000\\n\";\n \n         File hedwigConfigFile = new File(System.getProperty(\"java.io.tmpdir\") + \"/hedwig.cfg\");\n         writeStringToFile(hedwigParams, hedwigConfigFile);"},{"sha":"3782e820f2ddde77d420170f33e27ce2e455b58c","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -36,7 +36,7 @@\n         public boolean isHubSubscriber;\n \n         public StartServingRequest(ByteString topic, ByteString subscriberId, MessageSeqId seqIdToStartFrom,\n-                DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber) {\n+                                   DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber) {\n             this.topic = topic;\n             this.subscriberId = subscriberId;\n             this.seqIdToStartFrom = seqIdToStartFrom;\n@@ -51,10 +51,10 @@ public StartServingRequest(ByteString topic, ByteString subscriberId, MessageSeq\n \n     @Override\n     public void startServingSubscription(ByteString topic, ByteString subscriberId, MessageSeqId seqIdToStartFrom,\n-            DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber) {\n+                                         DeliveryEndPoint endPoint, MessageFilter filter, boolean isHubSubscriber) {\n \n         lastRequest.add(new StartServingRequest(topic, subscriberId, seqIdToStartFrom, endPoint, filter,\n-                isHubSubscriber));\n+                                                isHubSubscriber));\n \n     }\n "},{"sha":"d24a86dfae1a8db4d8335b1a0ddde5135f514c7e","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -80,17 +80,17 @@ protected void setUp() throws Exception {\n \n         subRequestPrototype = SubscribeRequest.newBuilder().setSubscriberId(subscriberId).build();\n         pubSubRequestPrototype = PubSubRequest.newBuilder().setProtocolVersion(ProtocolVersion.VERSION_ONE).setType(\n-                OperationType.SUBSCRIBE).setTxnId(0).setTopic(topic).setSubscribeRequest(subRequestPrototype).build();\n+                                     OperationType.SUBSCRIBE).setTxnId(0).setTopic(topic).setSubscribeRequest(subRequestPrototype).build();\n \n         ush = new UnsubscribeHandler(tm, conf, sm, dm);\n     }\n \n     @Test\n     public void testNoSubscribeRequest() {\n         sh.handleRequestAtOwner(PubSubRequest.newBuilder(pubSubRequestPrototype).clearSubscribeRequest().build(),\n-                channel);\n+                                channel);\n         assertEquals(StatusCode.MALFORMED_REQUEST, ((PubSubResponse) channel.getMessagesWritten().get(0))\n-                .getStatusCode());\n+                     .getStatusCode());\n     }\n \n     @Test\n@@ -118,11 +118,11 @@ public void testSuccessCase() {\n         // make sure subscription was registered\n         StubCallback<MessageSeqId> callback1 = new StubCallback<MessageSeqId>();\n         sm.serveSubscribeRequest(topic, SubscribeRequest.newBuilder(subRequestPrototype).setCreateOrAttach(\n-                CreateOrAttach.CREATE).build(), MessageSeqId.newBuilder().setLocalComponent(10).build(), callback1,\n-                null);\n+                                     CreateOrAttach.CREATE).build(), MessageSeqId.newBuilder().setLocalComponent(10).build(), callback1,\n+                                 null);\n \n         assertEquals(PubSubException.ClientAlreadySubscribedException.class, ConcurrencyUtils.take(callback1.queue)\n-                .right().getClass());\n+                     .right().getClass());\n \n         // trying to subscribe again should throw an error\n         WriteRecordingChannel dupChannel = new WriteRecordingChannel();\n@@ -140,10 +140,10 @@ public void testSuccessCase() {\n         channel = new WriteRecordingChannel();\n         ush.handleRequestAtOwner(pubSubRequestPrototype, channel);\n         assertEquals(StatusCode.MALFORMED_REQUEST, ((PubSubResponse) channel.getMessagesWritten().get(0))\n-                .getStatusCode());\n+                     .getStatusCode());\n \n         PubSubRequest unsubRequest = PubSubRequest.newBuilder(pubSubRequestPrototype).setUnsubscribeRequest(\n-                UnsubscribeRequest.newBuilder().setSubscriberId(subscriberId)).build();\n+                                         UnsubscribeRequest.newBuilder().setSubscriberId(subscriberId)).build();\n         channel = new WriteRecordingChannel();\n         dm.lastRequest.clear();\n \n@@ -156,10 +156,10 @@ public void testSuccessCase() {\n         // make sure the info is gone from the sm\n         StubCallback<MessageSeqId> callback2 = new StubCallback<MessageSeqId>();\n         sm.serveSubscribeRequest(topic, SubscribeRequest.newBuilder(subRequestPrototype).setCreateOrAttach(\n-                CreateOrAttach.ATTACH).build(), MessageSeqId.newBuilder().setLocalComponent(10).build(), callback2,\n-                null);\n+                                     CreateOrAttach.ATTACH).build(), MessageSeqId.newBuilder().setLocalComponent(10).build(), callback2,\n+                                 null);\n         assertEquals(PubSubException.ClientNotSubscribedException.class, ConcurrencyUtils.take(callback2.queue).right()\n-                .getClass());\n+                     .getClass());\n \n     }\n "},{"sha":"8ccb35942330b6ce8038d5cd02b84500377c57a0","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -140,7 +140,7 @@ public TestMessageHandler(SynchronousQueue<Boolean> consumeQueue) {\n         }\n \n         public void consume(ByteString topic, ByteString subscriberId, final Message msg, Callback<Void> callback,\n-                Object context) {\n+                            Object context) {\n             if (!consumedMessages.contains(msg.getMsgId())) {\n                 // New message to consume. Add it to the Set of consumed\n                 // messages.\n@@ -154,7 +154,7 @@ public void consume(ByteString topic, ByteString subscriberId, final Message msg\n                         public void run() {\n                             if (logger.isDebugEnabled())\n                                 logger.debug(\"Consuming message that is out of order for msgId: \"\n-                                        + msg.getMsgId().getLocalComponent());\n+                                             + msg.getMsgId().getLocalComponent());\n                             ConcurrencyUtils.put(consumeQueue, false);\n                         }\n                     }).start();\n@@ -241,13 +241,13 @@ protected void startDelivery(ByteString topic, ByteString subscriberId, MessageH\n     }\n \n     protected void startDelivery(Subscriber subscriber, ByteString topic, ByteString subscriberId,\n-            MessageHandler handler) throws Exception {\n+                                 MessageHandler handler) throws Exception {\n         subscriber.startDelivery(topic, subscriberId, handler);\n         if (mode == Mode.PROXY) {\n             WriteRecordingChannel channel = new WriteRecordingChannel();\n             PubSubRequest request = PubSubRequest.newBuilder().setProtocolVersion(ProtocolVersion.VERSION_ONE)\n-                    .setTopic(topic).setTxnId(0).setType(OperationType.START_DELIVERY).setStartDeliveryRequest(\n-                            StartDeliveryRequest.newBuilder().setSubscriberId(subscriberId)).build();\n+                                    .setTopic(topic).setTxnId(0).setType(OperationType.START_DELIVERY).setStartDeliveryRequest(\n+                                        StartDeliveryRequest.newBuilder().setSubscriberId(subscriberId)).build();\n             proxy.getStartDeliveryHandler().handleRequest(request, channel);\n             assertEquals(StatusCode.SUCCESS, ((PubSubResponse) channel.getMessagesWritten().get(0)).getStatusCode());\n         }\n@@ -280,7 +280,7 @@ protected void subscribeToTopics(int batchSize) throws Exception {\n             logger.debug(\"Subscribing to topics and starting delivery.\");\n         for (int i = 0; i < batchSize; i++) {\n             subscriber.asyncSubscribe(getTopic(i), localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH,\n-                    new TestCallback(queue), null);\n+                                      new TestCallback(queue), null);\n             assertTrue(queue.take());\n         }\n \n@@ -327,7 +327,7 @@ public boolean isAutoSendConsumeMessageEnabled() {\n         ByteString myTopic = getTopic(0);\n         // Subscribe to a topic and start delivery on it\n         mySubscriber.asyncSubscribe(myTopic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH,\n-                new TestCallback(queue), null);\n+                                    new TestCallback(queue), null);\n         assertTrue(queue.take());\n         startDelivery(mySubscriber, myTopic, localSubscriberId, new TestMessageHandler(consumeQueue));\n         // Publish some messages\n@@ -342,7 +342,7 @@ public boolean isAutoSendConsumeMessageEnabled() {\n             boolean success = true;\n             try {\n                 mySubscriber.consume(myTopic, localSubscriberId, MessageSeqId.newBuilder().setLocalComponent(i + 1)\n-                        .build());\n+                                     .build());\n             } catch (ClientNotSubscribedException e) {\n                 success = false;\n             }\n@@ -364,7 +364,7 @@ public boolean isAutoSendConsumeMessageEnabled() {\n     public void testAttachToSubscriptionSuccess() throws Exception {\n         ByteString topic = getTopic(0);\n         subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue),\n-                null);\n+                                  null);\n         assertTrue(queue.take());\n         // Close the subscription asynchronously\n         subscriber.asyncCloseSubscription(topic, localSubscriberId, new TestCallback(queue), null);\n@@ -417,7 +417,7 @@ public void testServerFailover() throws Exception {\n     public void testUnsubscribe() throws Exception {\n         ByteString topic = getTopic(0);\n         subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue),\n-                null);\n+                                  null);\n         assertTrue(queue.take());\n         startDelivery(topic, localSubscriberId, new TestMessageHandler(consumeQueue));\n         publisher.asyncPublish(topic, getMsg(0), new TestCallback(queue), null);\n@@ -468,7 +468,7 @@ public void testAsyncUnsubscribeWithoutSubscription() throws Exception {\n     public void testCloseSubscription() throws Exception {\n         ByteString topic = getTopic(0);\n         subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue),\n-                null);\n+                                  null);\n         assertTrue(queue.take());\n         startDelivery(topic, localSubscriberId, new TestMessageHandler(consumeQueue));\n         publisher.asyncPublish(topic, getMsg(0), new TestCallback(queue), null);\n@@ -500,7 +500,7 @@ public void run() {\n     public void testStopDelivery() throws Exception {\n         ByteString topic = getTopic(0);\n         subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue),\n-                null);\n+                                  null);\n         assertTrue(queue.take());\n         startDelivery(topic, localSubscriberId, new TestMessageHandler(consumeQueue));\n         publisher.asyncPublish(topic, getMsg(0), new TestCallback(queue), null);\n@@ -541,7 +541,7 @@ public void run() {\n     public void testConsumedMessagesInOrder() throws Exception {\n         ByteString topic = getTopic(0);\n         subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue),\n-                null);\n+                                  null);\n         assertTrue(queue.take());\n         startDelivery(topic, localSubscriberId, new TestMessageHandler(consumeQueue));\n         // Now publish some messages and verify that they are delivered in order\n@@ -562,7 +562,7 @@ public void testConsumedMessagesInOrder() throws Exception {\n     public void testCreateSubscriptionFailure() throws Exception {\n         ByteString topic = getTopic(0);\n         subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue),\n-                null);\n+                                  null);\n         assertTrue(queue.take());\n         // Close the subscription asynchronously\n         subscriber.asyncCloseSubscription(topic, localSubscriberId, new TestCallback(queue), null);\n@@ -612,7 +612,7 @@ public void testSyncSubscribeWithInvalidSubscriberId() throws Exception {\n     @Test\n     public void testAsyncSubscribeWithInvalidSubscriberId() throws Exception {\n         subscriber.asyncSubscribe(getTopic(0), hubSubscriberId, CreateOrAttach.CREATE_OR_ATTACH,\n-                new TestCallback(queue), null);\n+                                  new TestCallback(queue), null);\n         assertFalse(queue.take());\n     }\n \n@@ -659,7 +659,7 @@ public void testAsyncHubSubscribeWithInvalidSubscriberId() throws Exception {\n         HedwigClient hubClient = new HedwigHubClient(new ClientConfiguration());\n         HedwigSubscriber hubSubscriber = hubClient.getSubscriber();\n         hubSubscriber.asyncSubscribe(getTopic(0), localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(\n-                queue), null);\n+                                         queue), null);\n         assertFalse(queue.take());\n         hubClient.stop();\n     }"},{"sha":"3a010c2743ff892cc03c3827fafaa0dcca0e3290","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -59,8 +59,8 @@ public void testMultiRegionSubscribeAndConsume() throws Exception {\n         for (HedwigClient client : regionClientsMap.values()) {\n             for (int i = 0; i < batchSize; i++) {\n                 client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8(\"Topic\" + i),\n-                        ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n-                        new TestCallback(queue), null);\n+                                                      ByteString.copyFromUtf8(\"LocalSubscriber\"), CreateOrAttach.CREATE_OR_ATTACH,\n+                                                      new TestCallback(queue), null);\n                 assertTrue(queue.take());\n             }\n         }\n@@ -69,7 +69,7 @@ public void testMultiRegionSubscribeAndConsume() throws Exception {\n         for (HedwigClient client : regionClientsMap.values()) {\n             for (int i = 0; i < batchSize; i++) {\n                 client.getSubscriber().startDelivery(ByteString.copyFromUtf8(\"Topic\" + i),\n-                        ByteString.copyFromUtf8(\"LocalSubscriber\"), new TestMessageHandler(consumeQueue));\n+                                                     ByteString.copyFromUtf8(\"LocalSubscriber\"), new TestMessageHandler(consumeQueue));\n             }\n         }\n \n@@ -79,15 +79,15 @@ public void testMultiRegionSubscribeAndConsume() throws Exception {\n         HedwigPublisher publisher = regionClientsMap.values().iterator().next().getPublisher();\n         for (int i = 0; i < batchSize; i++) {\n             publisher.asyncPublish(ByteString.copyFromUtf8(\"Topic\" + i), Message.newBuilder().setBody(\n-                    ByteString.copyFromUtf8(\"Message\" + i)).build(), new TestCallback(queue), null);\n+                                       ByteString.copyFromUtf8(\"Message\" + i)).build(), new TestCallback(queue), null);\n             assertTrue(queue.take());\n         }\n         // Make sure each region consumes the same set of published messages.\n         for (int i = 0; i < regionClientsMap.size(); i++) {\n             for (int j = 0; j < batchSize; j++) {\n                 assertTrue(consumeQueue.take());\n             }\n-        }       \n+        }\n     }\n \n }"},{"sha":"822f4421fc13e965cecb2817883621b0ed747061","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -77,7 +77,7 @@ public void uncaughtException(Thread t, Throwable e) {\n     }\n \n     PubSubServer startServer(final UncaughtExceptionHandler uncaughtExceptionHandler, final int port,\n-            final TopicManagerInstantiator instantiator) throws Exception {\n+                             final TopicManagerInstantiator instantiator) throws Exception {\n         PubSubServer server = new PubSubServer(new StandAloneServerConfiguration() {\n             @Override\n             public int getServerPort() {\n@@ -105,7 +105,7 @@ public InetSocketAddress getDefaultServerHost() {\n         }).getPublisher();\n \n         publisher.asyncPublish(ByteString.copyFromUtf8(\"blah\"), Message.newBuilder().setBody(\n-                ByteString.copyFromUtf8(\"blah\")).build(), new Callback<Void>() {\n+        ByteString.copyFromUtf8(\"blah\")).build(), new Callback<Void>() {\n             @Override\n             public void operationFailed(Object ctx, PubSubException exception) {\n                 assertTrue(false);\n@@ -132,8 +132,8 @@ public void testUncaughtExceptionInNettyThread() throws Exception {\n             public TopicManager instantiateTopicManager() throws IOException {\n                 return new AbstractTopicManager(new ServerConfiguration(), Executors.newSingleThreadScheduledExecutor()) {\n                     @Override\n-                    protected void realGetOwner(ByteString topic, boolean shouldClaim, \n-                            Callback<HedwigSocketAddress> cb, Object ctx) {\n+                    protected void realGetOwner(ByteString topic, boolean shouldClaim,\n+                    Callback<HedwigSocketAddress> cb, Object ctx) {\n                         throw new RuntimeException(\"this exception should be uncaught\");\n                     }\n \n@@ -164,8 +164,8 @@ public TopicManager instantiateTopicManager() throws IOException {\n                 return new AbstractTopicManager(new ServerConfiguration(), Executors.newSingleThreadScheduledExecutor()) {\n \n                     @Override\n-                    protected void realGetOwner(ByteString topic, boolean shouldClaim, \n-                            Callback<HedwigSocketAddress> cb, Object ctx) {\n+                    protected void realGetOwner(ByteString topic, boolean shouldClaim,\n+                    Callback<HedwigSocketAddress> cb, Object ctx) {\n                         ZooKeeper zookeeper;\n                         try {\n                             zookeeper = new ZooKeeper(hostPort, 60000, new Watcher() {\n@@ -182,7 +182,7 @@ public void process(WatchedEvent event) {\n                         zookeeper.getData(\"/fake\", false, new SafeAsyncZKCallback.DataCallback() {\n                             @Override\n                             public void safeProcessResult(int rc, String path, Object ctx, byte[] data,\n-                                    org.apache.zookeeper.data.Stat stat) {\n+                            org.apache.zookeeper.data.Stat stat) {\n                                 throw new RuntimeException(\"This should go to the uncaught exception handler\");\n                             }\n \n@@ -213,8 +213,8 @@ public boolean isInterRegionSSLEnabled() {\n             @Override\n             public List<String> getRegions() {\n                 List<String> regionsList = new LinkedList<String>();\n-                regionsList.add(\"regionHost1:4080:9876\"); \n-                regionsList.add(\"regionHost2:4080\"); \n+                regionsList.add(\"regionHost1:4080:9876\");\n+                regionsList.add(\"regionHost2:4080\");\n                 regionsList.add(\"regionHost3:4080:9876\");\n                 return regionsList;\n             }\n@@ -227,7 +227,7 @@ public boolean isInterRegionSSLEnabled() {\n             success = true;\n         }\n         assertTrue(success);\n-    }    \n+    }\n \n     @Test\n     public void testValidServerConfiguration() throws Exception {\n@@ -241,8 +241,8 @@ public boolean isInterRegionSSLEnabled() {\n             @Override\n             public List<String> getRegions() {\n                 List<String> regionsList = new LinkedList<String>();\n-                regionsList.add(\"regionHost1:4080:9876\"); \n-                regionsList.add(\"regionHost2:4080:2938\"); \n+                regionsList.add(\"regionHost1:4080:9876\");\n+                regionsList.add(\"regionHost2:4080:2938\");\n                 regionsList.add(\"regionHost3:4080:9876\");\n                 return regionsList;\n             }\n@@ -255,6 +255,6 @@ public boolean isInterRegionSSLEnabled() {\n             success = false;\n         }\n         assertTrue(success);\n-    }    \n+    }\n \n }"},{"sha":"b918d97d0413e476a91a9a5d7a665be45e39d798","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -38,7 +38,7 @@\n /**\n  * This is a base class for any tests that require a BookKeeper client/server\n  * setup.\n- * \n+ *\n  */\n public class BookKeeperTestBase extends ZooKeeperTestBase {\n     private static Logger logger = Logger.getLogger(BookKeeperTestBase.class);"},{"sha":"84b866dc159b9f418400fade9dc0eda645523f43","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -76,7 +76,7 @@ public void scanSingleMessage(ScanRequest request) {\n         }\n \n         request.getCallback().messageScanned(request.getCtx(),\n-                messages.get(request.getTopic()).get((int) request.getStartSeqId()));\n+                                             messages.get(request.getTopic()).get((int) request.getStartSeqId()));\n \n     }\n \n@@ -90,7 +90,7 @@ public void scanMessages(RangeScanRequest request) {\n         long startSeqId = request.getStartSeqId();\n         for (int i = 0; i < request.getMessageLimit(); i++) {\n             List<Message> messageList = MapMethods.getAfterInsertingIfAbsent(messages, request.getTopic(),\n-                    ArrayListMessageFactory.instance);\n+                                        ArrayListMessageFactory.instance);\n             if (startSeqId + i > messageList.size()) {\n                 request.getCallback().scanFinished(request.getCtx(), ReasonForFinish.NO_MORE_MESSAGES);\n                 return;"},{"sha":"e9fbd0877559952f14a665127964fad6bdbb6aa0","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -24,25 +24,25 @@\n import org.apache.hedwig.util.ConcurrencyUtils;\n import org.apache.hedwig.util.Either;\n \n-public class StubScanCallback implements ScanCallback{\n+public class StubScanCallback implements ScanCallback {\n \n     public static Message END_MESSAGE = Message.newBuilder().setBody(ByteString.EMPTY).build();\n-    \n+\n     LinkedBlockingQueue<Either<Message, Exception>> queue = new LinkedBlockingQueue<Either<Message,Exception>>();\n-    \n+\n     @Override\n     public void messageScanned(Object ctx, Message message) {\n-       ConcurrencyUtils.put(queue, Either.of(message, (Exception) null));\n+        ConcurrencyUtils.put(queue, Either.of(message, (Exception) null));\n     }\n-    \n+\n     @Override\n     public void scanFailed(Object ctx, Exception exception) {\n         ConcurrencyUtils.put(queue, Either.of((Message) null, exception));\n     }\n-    \n+\n     @Override\n     public void scanFinished(Object ctx, ReasonForFinish reason) {\n         ConcurrencyUtils.put(queue, Either.of(END_MESSAGE, (Exception) null));\n-        \n+\n     }\n }"},{"sha":"57bc95d751f51016332b05c2e65d1a60028b0950","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -31,8 +31,8 @@\n \n public class TestBookKeeperPersistenceManagerBlackBox extends TestPersistenceManagerBlackBox {\n     BookKeeperTestBase bktb;\n-    private final int numBookies = 3;   \n-    \n+    private final int numBookies = 3;\n+\n     @Override\n     @Before\n     protected void setUp() throws Exception {\n@@ -61,7 +61,7 @@ PersistenceManager instantiatePersistenceManager() throws Exception {\n         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n \n         return new BookkeeperPersistenceManager(bktb.bk, bktb.getZooKeeperClient(), new TrivialOwnAllTopicManager(conf,\n-                scheduler), conf, scheduler);\n+                                                scheduler), conf, scheduler);\n     }\n \n     @Override"},{"sha":"47c70307ed0489c6c1684a23ff657079ad6e441e","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -78,7 +78,7 @@ public void testEmptyDirtyLedger() throws Exception {\n         // now abandon, and try another time, the prev ledger should be dirty\n \n         bkpm = new BookkeeperPersistenceManager(new BookKeeper(bktb.getZkHostPort()), bktb.getZooKeeperClient(), tm,\n-                conf, scheduler);\n+                                                conf, scheduler);\n         bkpm.acquiredTopic(topic, stubCallback, null);\n         assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n         assertEquals(0, bkpm.topicInfos.get(topic).ledgerRanges.size());\n@@ -92,7 +92,7 @@ public void testNonEmptyDirtyLedger() throws Exception {\n         int index = 0;\n         int numPrevLedgers = 0;\n         List<Message> messages = HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,\n-                SIZE_OF_MESSAGES_TO_TEST);\n+                                 SIZE_OF_MESSAGES_TO_TEST);\n \n         while (index < messages.size()) {\n "},{"sha":"e89dd4c5ebf94bd047a81af3fe198bdcdcc6d246","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -163,13 +163,13 @@ public void run() {\n                     PersistenceManagerWithRangeScan rangePersistenceManager = (PersistenceManagerWithRangeScan) persistenceManager;\n \n                     rangePersistenceManager.scanMessages(new RangeScanRequest(topic, getLowestSeqId(),\n-                            NUM_MESSAGES_TO_TEST + 1, Long.MAX_VALUE, listener, statusQueue));\n+                                                         NUM_MESSAGES_TO_TEST + 1, Long.MAX_VALUE, listener, statusQueue));\n \n                 } else {\n \n                     ScanCallback listener = new PointScanVerifierListener(pubMsgs, topic);\n                     persistenceManager\n-                            .scanSingleMessage(new ScanRequest(topic, getLowestSeqId(), listener, statusQueue));\n+                    .scanSingleMessage(new ScanRequest(topic, getLowestSeqId(), listener, statusQueue));\n \n                 }\n                 // now listen for it to finish\n@@ -295,7 +295,7 @@ public void operationFinished(Object ctx, Void res) {\n         assertEquals(null, failureException);\n         for (int i = 0; i < NUM_TOPICS_TO_TEST; i++) {\n             assertEquals(persistenceManager.getCurrentSeqIdForTopic(getTopicName(i)).getLocalComponent(),\n-                    getExpectedSeqId(NUM_MESSAGES_TO_TEST));\n+                         getExpectedSeqId(NUM_MESSAGES_TO_TEST));\n         }\n \n     }"},{"sha":"33f067a3ee6088bb7434655fa018c3c32ad6e284","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -90,7 +90,7 @@ public void tearDown() throws Exception {\n     }\n \n     @Test\n-    public void testPersistMessage() throws Exception{\n+    public void testPersistMessage() throws Exception {\n         StubCallback<Long> callback = new StubCallback<Long>();\n         PersistRequest request = new PersistRequest(topic, messages.get(0), callback, null);\n \n@@ -99,20 +99,20 @@ public void testPersistMessage() throws Exception{\n         assertNotNull(ConcurrencyUtils.take(callback.queue).right());\n \n         CacheKey key = new CacheKey(topic, cacheBasedPersistenceManager.getCurrentSeqIdForTopic(topic)\n-                .getLocalComponent());\n+                                    .getLocalComponent());\n         assertFalse(cacheBasedPersistenceManager.cache.containsKey(key));\n \n         stubPersistenceManager.failure = false;\n         persistMessage(messages.get(0));\n     }\n \n-    private void persistMessage(Message msg) throws Exception{\n+    private void persistMessage(Message msg) throws Exception {\n         StubCallback<Long> callback = new StubCallback<Long>();\n         PersistRequest request = new PersistRequest(topic, msg, callback, null);\n         cacheBasedPersistenceManager.persistMessage(request);\n         assertNotNull(ConcurrencyUtils.take(callback.queue).left());\n         CacheKey key = new CacheKey(topic, cacheBasedPersistenceManager.getCurrentSeqIdForTopic(topic)\n-                .getLocalComponent());\n+                                    .getLocalComponent());\n         CacheValue cacheValue = cacheBasedPersistenceManager.cache.get(key);\n         assertNotNull(cacheValue);\n         assertFalse(cacheValue.isStub());\n@@ -140,7 +140,7 @@ public void testScanSingleMessage() throws Exception {\n     }\n \n     @Test\n-    public void testDeliveredUntil() throws Exception{\n+    public void testDeliveredUntil() throws Exception {\n         for (Message m : messages) {\n             persistMessage(m);\n         }\n@@ -184,7 +184,7 @@ public void testDoReadAhead() {\n     }\n \n     @Test\n-    public void testReadAheadSizeLimit() throws Exception{\n+    public void testReadAheadSizeLimit() throws Exception {\n         for (Message m : messages) {\n             persistMessage(m);\n         }\n@@ -195,17 +195,17 @@ public void testReadAheadSizeLimit() throws Exception{\n \n         assertTrue(callback.isSuccess());\n         assertEquals((int) Math.ceil(myConf.readAheadSize / (MSG_SIZE + 0.0)), cacheBasedPersistenceManager.cache\n-                .size());\n+                     .size());\n \n     }\n \n     @Test\n-    public void testDoReadAheadStartingFrom() throws Exception{\n+    public void testDoReadAheadStartingFrom() throws Exception {\n         persistMessage(messages.get(0));\n         int readAheadCount = 5;\n         int start = 1;\n         RangeScanRequest readAheadRequest = cacheBasedPersistenceManager.doReadAheadStartingFrom(topic, start,\n-                readAheadCount);\n+                                            readAheadCount);\n         assertNull(readAheadRequest);\n \n         StubScanCallback callback = new StubScanCallback();"},{"sha":"255880b038fb6ebe9d62fb84ab8a8368c20579d6","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -41,7 +41,7 @@ public StubSubscriptionManager(TopicManager tm, PersistenceManager pm, ServerCon\n \n     @Override\n     public void serveSubscribeRequest(ByteString topic, SubscribeRequest subRequest, MessageSeqId consumeSeqId,\n-            Callback<MessageSeqId> callback, Object ctx) {\n+                                      Callback<MessageSeqId> callback, Object ctx) {\n         if (fail) {\n             callback.operationFailed(ctx, new PubSubException.ServiceDownException(\"Asked to fail\"));\n             return;"},{"sha":"f6d533f659103cd8644a496b23dffc90d95494b1","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","status":"modified","additions":17,"deletions":17,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -108,12 +108,12 @@ public void testBasics() throws Exception {\n         sm.serveSubscribeRequest(topic1, subRequest, msgId, msgIdCallback, null);\n \n         Assert.assertEquals(ConcurrencyUtils.take(msgIdCallbackQueue).right().getClass(),\n-                PubSubException.ServerNotResponsibleForTopicException.class);\n+                            PubSubException.ServerNotResponsibleForTopicException.class);\n \n         sm.unsubscribe(topic1, sub1, voidCallback, null);\n \n         Assert.assertEquals(ConcurrencyUtils.take(BooleanCallbackQueue).right().getClass(),\n-                PubSubException.ServerNotResponsibleForTopicException.class);\n+                            PubSubException.ServerNotResponsibleForTopicException.class);\n \n         //\n         // Acquire topic.\n@@ -127,59 +127,59 @@ public void testBasics() throws Exception {\n \n         sm.unsubscribe(topic1, sub1, voidCallback, null);\n         Assert.assertEquals(ConcurrencyUtils.take(BooleanCallbackQueue).right().getClass(),\n-                PubSubException.ClientNotSubscribedException.class);\n+                            PubSubException.ClientNotSubscribedException.class);\n \n         //\n         // Try to attach to a subscription.\n         subRequest = SubscribeRequest.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH).setSubscriberId(sub1)\n-                .build();\n+                     .build();\n \n         sm.serveSubscribeRequest(topic1, subRequest, msgId, msgIdCallback, null);\n         Assert.assertEquals(ConcurrencyUtils.take(msgIdCallbackQueue).right().getClass(),\n-                PubSubException.ClientNotSubscribedException.class);\n+                            PubSubException.ClientNotSubscribedException.class);\n \n         // now create\n         subRequest = SubscribeRequest.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE).setSubscriberId(sub1)\n-                .build();\n+                     .build();\n         sm.serveSubscribeRequest(topic1, subRequest, msgId, msgIdCallback, null);\n         Assert.assertEquals(msgId.getLocalComponent(), ConcurrencyUtils.take(msgIdCallbackQueue).left().getLocalComponent());\n         Assert.assertEquals(msgId.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n \n         // try to create again\n         sm.serveSubscribeRequest(topic1, subRequest, msgId, msgIdCallback, null);\n         Assert.assertEquals(ConcurrencyUtils.take(msgIdCallbackQueue).right().getClass(),\n-                PubSubException.ClientAlreadySubscribedException.class);\n+                            PubSubException.ClientAlreadySubscribedException.class);\n         Assert.assertEquals(msgId.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n \n         sm.lostTopic(topic1);\n         sm.acquiredTopic(topic1, voidCallback, null);\n         Assert.assertTrue(BooleanCallbackQueue.take().left());\n \n         // try to attach\n         subRequest = SubscribeRequest.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH).setSubscriberId(sub1)\n-                .build();\n+                     .build();\n         MessageSeqId msgId1 = MessageSeqId.newBuilder().setLocalComponent(msgId.getLocalComponent() + 10).build();\n         sm.serveSubscribeRequest(topic1, subRequest, msgId1, msgIdCallback, null);\n         Assert.assertEquals(msgId.getLocalComponent(), msgIdCallbackQueue.take().left().getLocalComponent());\n         Assert.assertEquals(msgId.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n \n         // now manipulate the consume ptrs\n         // dont give it enough to have it persist to ZK\n         MessageSeqId msgId2 = MessageSeqId.newBuilder().setLocalComponent(\n-                msgId.getLocalComponent() + cfg.getConsumeInterval() - 1).build();\n+                                  msgId.getLocalComponent() + cfg.getConsumeInterval() - 1).build();\n         sm.setConsumeSeqIdForSubscriber(topic1, sub1, msgId2, voidCallback, null);\n         Assert.assertTrue(BooleanCallbackQueue.take().left());\n         Assert.assertEquals(msgId2.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n         Assert.assertEquals(msgId.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getSubscriptionState().getMsgId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n \n         // give it more so that it will write to ZK\n         MessageSeqId msgId3 = MessageSeqId.newBuilder().setLocalComponent(\n-                msgId.getLocalComponent() + cfg.getConsumeInterval() + 1).build();\n+                                  msgId.getLocalComponent() + cfg.getConsumeInterval() + 1).build();\n         sm.setConsumeSeqIdForSubscriber(topic1, sub1, msgId3, voidCallback, null);\n         Assert.assertTrue(BooleanCallbackQueue.take().left());\n \n@@ -188,9 +188,9 @@ public void testBasics() throws Exception {\n         Assert.assertTrue(BooleanCallbackQueue.take().left());\n \n         Assert.assertEquals(msgId3.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n         Assert.assertEquals(msgId3.getLocalComponent(), sm.top2sub2seq.get(topic1).get(sub1).getSubscriptionState().getMsgId()\n-                .getLocalComponent());\n+                            .getLocalComponent());\n \n         // finally unsubscribe\n         sm.unsubscribe(topic1, sub1, voidCallback, null);"},{"sha":"aa770391c8ccbb0c79e25b8742c73fa41c609439","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -44,8 +44,8 @@ public StubTopicManager(ServerConfiguration conf) throws UnknownHostException {\n     }\n \n     @Override\n-    protected void realGetOwner(ByteString topic, boolean shouldClaim, \n-            Callback<HedwigSocketAddress> cb, Object ctx) {\n+    protected void realGetOwner(ByteString topic, boolean shouldClaim,\n+                                Callback<HedwigSocketAddress> cb, Object ctx) {\n \n         if (shouldError) {\n             cb.operationFailed(ctx, new PubSubException.ServiceDownException(\"Asked to fail\"));"},{"sha":"dc28830764f14ae44e7fa77dd8d52ce38d21ced0","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -126,7 +126,7 @@ public int getServerPort() {\n     @Test\n     public void testGetOwnerMulti() throws Exception {\n         ServerConfiguration cfg1 = new CustomServerConfiguration(cfg.getServerPort() + 1), cfg2 = new CustomServerConfiguration(\n-                cfg.getServerPort() + 2);\n+            cfg.getServerPort() + 2);\n         // TODO change cfg1 cfg2 params\n         ZkTopicManager tm1 = new ZkTopicManager(zk, cfg1, scheduler), tm2 = new ZkTopicManager(zk, cfg2, scheduler);\n \n@@ -265,7 +265,7 @@ public void testOwnershipChange() throws Exception {\n         Assert.assertEquals(topic, pair.first());\n         Assert.assertTrue(pair.second());\n         Assert.assertEquals(PubSubException.ServiceDownException.class, ((CompositeException) addrCbq.take().right())\n-                .getExceptions().iterator().next().getClass());\n+                            .getExceptions().iterator().next().getClass());\n         Assert.assertFalse(tm.topics.contains(topic));\n         Thread.sleep(100);\n         assertOwnershipNodeDoesntExist();"},{"sha":"2a5dfc019f029128a00e4f4fa7f7da156b60af65","filename":"hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/ba9ebc213c14aa5d16a26f2e0601a39ac5888e10/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java?ref=ba9ebc213c14aa5d16a26f2e0601a39ac5888e10","patch":"@@ -32,7 +32,7 @@\n \n /**\n  * This is a base class for any tests that need a ZooKeeper client/server setup.\n- * \n+ *\n  */\n public abstract class ZooKeeperTestBase extends ClientBase {\n "}]}

