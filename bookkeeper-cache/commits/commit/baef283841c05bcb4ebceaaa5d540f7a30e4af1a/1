{"sha":"baef283841c05bcb4ebceaaa5d540f7a30e4af1a","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiYWVmMjgzODQxYzA1YmNiNGViY2VhYWE1ZDU0MGY3YTMwZTRhZjFh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-07T11:21:52Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-07T11:21:52Z"},"message":"BOOKKEEPER-453: Extract commonality from MultiplexSubscribeResponseHandler and SimpleSubscribeResponseHandler and put into an abstract class  (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1418280 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"46c911485787f0de932e5c90bdc5274aa58bb1aa","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/46c911485787f0de932e5c90bdc5274aa58bb1aa"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/baef283841c05bcb4ebceaaa5d540f7a30e4af1a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/baef283841c05bcb4ebceaaa5d540f7a30e4af1a","html_url":"https://github.com/apache/bookkeeper/commit/baef283841c05bcb4ebceaaa5d540f7a30e4af1a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"366d393f2e58acdd5494da4ae60513c3ae5730c4","url":"https://api.github.com/repos/apache/bookkeeper/commits/366d393f2e58acdd5494da4ae60513c3ae5730c4","html_url":"https://github.com/apache/bookkeeper/commit/366d393f2e58acdd5494da4ae60513c3ae5730c4"}],"stats":{"total":1970,"additions":911,"deletions":1059},"files":[{"sha":"874068fbbb2ff8476edd7958c0e4f971db533f9f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -284,6 +284,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-370: implement multiplexing cpp client. (sijie via ivank)\n \n+        BOOKKEEPER-453: Extract commonality from MultiplexSubscribeResponseHandler and SimpleSubscribeResponseHandler and put into an abstract class  (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"6fb89784bd34c894fee74a2804d5e26de5f823d4","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -573,6 +573,9 @@ public void run() {\n         }\n     }\n \n+    protected abstract void restartDelivery(TopicSubscriber topicSubscriber)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException;\n+\n     /**\n      * Chekout the pub/sub requests on subscription channels.\n      */"},{"sha":"3a3b7491c116685ff6196437430dbd462a4010d1","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","status":"added","additions":363,"deletions":0,"changes":363,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -0,0 +1,363 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.SubscriptionListener;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public abstract class AbstractSubscribeResponseHandler extends SubscribeResponseHandler {\n+\n+    private static Logger logger =\n+        LoggerFactory.getLogger(AbstractSubscribeResponseHandler.class);\n+\n+    protected final ReentrantReadWriteLock disconnectLock =\n+        new ReentrantReadWriteLock();\n+\n+    protected final ConcurrentMap<TopicSubscriber, ActiveSubscriber> subscriptions\n+        = new ConcurrentHashMap<TopicSubscriber, ActiveSubscriber>();\n+    protected final AbstractHChannelManager aChannelManager;\n+\n+    protected AbstractSubscribeResponseHandler(ClientConfiguration cfg,\n+                                               HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        this.aChannelManager = (AbstractHChannelManager) channelManager;\n+    }\n+\n+    protected HChannelManager getHChannelManager() {\n+        return this.channelManager;\n+    }\n+\n+    protected ClientConfiguration getConfiguration() {\n+        return cfg;\n+    }\n+\n+    protected ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n+        return subscriptions.get(ts);\n+    }\n+\n+    protected ActiveSubscriber createActiveSubscriber(\n+        ClientConfiguration cfg, AbstractHChannelManager channelManager,\n+        TopicSubscriber ts, PubSubData op, SubscriptionPreferences preferences,\n+        Channel channel) {\n+        return new ActiveSubscriber(cfg, channelManager, ts, op, preferences, channel);\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe response: {}, pubSubData: {}, host: {}.\",\n+                         va(response, pubSubData, NetUtils.getHostFromChannel(channel)));\n+        }\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            TopicSubscriber ts = new TopicSubscriber(pubSubData.topic,\n+                                                     pubSubData.subscriberId);\n+            SubscriptionPreferences preferences = null;\n+            if (response.hasResponseBody()) {\n+                ResponseBody respBody = response.getResponseBody();\n+                if (respBody.hasSubscribeResponse()) {\n+                    SubscribeResponse resp = respBody.getSubscribeResponse();\n+                    if (resp.hasPreferences()) {\n+                        preferences = resp.getPreferences();\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Receive subscription preferences for {} : {}\",\n+                                         va(ts,\n+                                            SubscriptionStateUtils.toString(preferences)));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ActiveSubscriber ss = createActiveSubscriber(cfg, aChannelManager, ts,\n+                                                         pubSubData, preferences, channel);\n+            boolean success = false;\n+            // Store the Subscribe state\n+            disconnectLock.readLock().lock();\n+            try {\n+                ActiveSubscriber oldSS = subscriptions.putIfAbsent(ts, ss);\n+                if (null != oldSS) {\n+                    logger.warn(\"Subscribe {} has existed in channel {}.\",\n+                                va(ts, channel));\n+                    success = false;\n+                } else {\n+                    logger.debug(\"Succeed to add subscription {} in channel {}.\",\n+                                 va(ts, channel));\n+                    success = true;\n+                }\n+            } finally {\n+                disconnectLock.readLock().unlock();\n+            }\n+            if (success) {\n+                handleSuccessResponse(ts, ss, channel);\n+                // Response was success so invoke the callback's operationFinished\n+                // method.\n+                pubSubData.getCallback().operationFinished(pubSubData.context, null);\n+            } else {\n+                ClientAlreadySubscribedException exception =\n+                    new ClientAlreadySubscribedException(\"Client is already subscribed for \" + ts);\n+                pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            }\n+            break;\n+        case CLIENT_ALREADY_SUBSCRIBED:\n+            // For Subscribe requests, the server says that the client is\n+            // already subscribed to it.\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                    new ClientAlreadySubscribedException(\"Client is already subscribed for topic: \"\n+                                                         + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                                         + pubSubData.subscriberId.toStringUtf8()));\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original Subscribe\n+            // Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a status code of: \"\n+                                                     + response.getStatusCode()));\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Handle success response for a specific TopicSubscriber <code>ts</code>. The method\n+     * is triggered after subscribed successfully.\n+     *\n+     * @param ts\n+     *          Topic Subscriber.\n+     * @param ss\n+     *          Active Subscriber Object handle subscription actions for the subscriber.\n+     * @param channel\n+     *          Subscription Channel.\n+     */\n+    protected abstract void handleSuccessResponse(TopicSubscriber ts, ActiveSubscriber as,\n+                                                  Channel channel);\n+\n+    @Override\n+    public void handleSubscribeMessage(PubSubResponse response) {\n+        Message message = response.getMessage();\n+        TopicSubscriber ts = new TopicSubscriber(response.getTopic(),\n+                                                 response.getSubscriberId());\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe message in response: {}, {}\",\n+                         va(response, ts));\n+        }\n+        ActiveSubscriber ss = getActiveSubscriber(ts);\n+        if (null == ss) {\n+            logger.error(\"Subscriber {} is not found receiving its message {}.\",\n+                         va(ts, MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        ss.handleMessage(message);\n+    }\n+\n+    @Override\n+    protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n+                                       Message message) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.error(\"Subscriber {} is not found delivering its message {}.\",\n+                         va(topicSubscriber,\n+                            MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        ss.asyncMessageDeliver(message);\n+    }\n+\n+    @Override\n+    protected void messageConsumed(TopicSubscriber topicSubscriber,\n+                                   Message message) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.warn(\"Subscriber {} is not found consumed its message {}.\",\n+                        va(topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Message has been successfully consumed by the client app : {}, {}\",\n+                         va(message, topicSubscriber));\n+        }\n+        ss.messageConsumed(message);\n+    }\n+\n+    @Override\n+    public void handleSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                                        SubscriptionEvent event) {\n+        TopicSubscriber ts = new TopicSubscriber(topic, subscriberId);\n+        ActiveSubscriber ss = getActiveSubscriber(ts);\n+        if (null == ss) {\n+            logger.warn(\"No subscription {} found receiving subscription event {}.\",\n+                        va(ts, event));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Received subscription event {} for ({}).\",\n+                         va(event, ts));\n+        }\n+        processSubscriptionEvent(ss, event);\n+    }\n+\n+    protected void processSubscriptionEvent(ActiveSubscriber as, SubscriptionEvent event) {\n+        switch (event) {\n+        // for all cases we need to resubscribe for the subscription\n+        case TOPIC_MOVED:\n+        case SUBSCRIPTION_FORCED_CLOSED:\n+            resubscribeIfNecessary(as, event);\n+            break;\n+        default:\n+            logger.error(\"Receive unknown subscription event {} for {}.\",\n+                         va(event, as.getTopicSubscriber()));\n+        }\n+    }\n+\n+    @Override\n+    public void startDelivery(final TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Start delivering message for {} using message handler {}\",\n+                         va(topicSubscriber, messageHandler));\n+        }\n+        ss.startDelivery(messageHandler);\n+    }\n+\n+    @Override\n+    public void stopDelivery(final TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Stop delivering messages for {}\", topicSubscriber);\n+        }\n+        ss.stopDelivery();\n+    }\n+\n+    @Override\n+    public boolean hasSubscription(TopicSubscriber topicSubscriber) {\n+        return subscriptions.containsKey(topicSubscriber);\n+    }\n+\n+    @Override\n+    public void consume(final TopicSubscriber topicSubscriber,\n+                        final MessageSeqId messageSeqId) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.warn(\"Subscriber {} is not found consuming message {}.\",\n+                        va(topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(messageSeqId)));\n+            return;\n+        }\n+        ss.consume(messageSeqId);\n+    }\n+\n+    @Override\n+    public void onChannelDisconnected(InetSocketAddress host, Channel channel) {\n+        disconnectLock.writeLock().lock();\n+        try {\n+            onDisconnect(host);\n+        } finally {\n+            disconnectLock.writeLock().unlock();\n+        }\n+    }\n+\n+    private void onDisconnect(InetSocketAddress host) {\n+        for (ActiveSubscriber ss : subscriptions.values()) {\n+            onDisconnect(ss, host);\n+        }\n+    }\n+\n+    private void onDisconnect(ActiveSubscriber ss, InetSocketAddress host) {\n+        logger.info(\"Subscription channel for ({}) is disconnected.\", ss);\n+        resubscribeIfNecessary(ss, SubscriptionEvent.TOPIC_MOVED);\n+    }\n+\n+    protected boolean removeSubscription(TopicSubscriber ts, ActiveSubscriber ss) {\n+        return subscriptions.remove(ts, ss);\n+    }\n+\n+    protected void resubscribeIfNecessary(ActiveSubscriber ss, SubscriptionEvent event) {\n+        // if subscriber has been changed, we don't need to resubscribe\n+        if (!removeSubscription(ss.getTopicSubscriber(), ss)) {\n+            return;\n+        }\n+        ss.resubscribeIfNecessary(event);\n+    }\n+\n+}"},{"sha":"c17a3d1c0c5f9af686a7954e2e276a71507839ac","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","status":"added","additions":378,"deletions":0,"changes":378,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -0,0 +1,378 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * an active subscriber handles subscription actions in a channel.\n+ */\n+public class ActiveSubscriber {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ActiveSubscriber.class);\n+\n+    protected final ClientConfiguration cfg;\n+    protected final AbstractHChannelManager channelManager;\n+\n+    // Subscriber related variables\n+    protected final TopicSubscriber topicSubscriber;\n+    protected final PubSubData op;\n+    protected final SubscriptionPreferences preferences;\n+\n+    // the underlying netty channel to send request\n+    protected final Channel channel;\n+\n+    // Counter for the number of consumed messages so far to buffer up before we\n+    // send the Consume message back to the server along with the last/largest\n+    // message seq ID seen so far in that batch.\n+    private int numConsumedMessagesInBuffer = 0;\n+    private MessageSeqId lastMessageSeqId = null;\n+\n+    // Message Handler\n+    private MessageHandler msgHandler = null;\n+\n+    // Queue used for subscribes when the MessageHandler hasn't been registered\n+    // yet but we've already received subscription messages from the server.\n+    // This will be lazily created as needed.\n+    private final Queue<Message> msgQueue = new LinkedList<Message>();\n+\n+    /**\n+     * Construct an active subscriber instance.\n+     *\n+     * @param cfg\n+     *          Client configuration object.\n+     * @param channelManager\n+     *          Channel manager instance.\n+     * @param ts\n+     *          Topic subscriber.\n+     * @param op\n+     *          Pub/Sub request.\n+     * @param preferences\n+     *          Subscription preferences for the subscriber.\n+     * @param channel\n+     *          Netty channel the subscriber lived.\n+     */\n+    public ActiveSubscriber(ClientConfiguration cfg,\n+                            AbstractHChannelManager channelManager,\n+                            TopicSubscriber ts, PubSubData op,\n+                            SubscriptionPreferences preferences,\n+                            Channel channel) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+        this.topicSubscriber = ts;\n+        this.op = op;\n+        this.preferences = preferences;\n+        this.channel = channel;\n+    }\n+\n+    /**\n+     * @return pub/sub request for the subscription.\n+     */\n+    public PubSubData getPubSubData() {\n+        return this.op;\n+    }\n+\n+    /**\n+     * @return topic subscriber id for the active subscriber.\n+     */\n+    public TopicSubscriber getTopicSubscriber() {\n+        return this.topicSubscriber;\n+    }\n+\n+    /**\n+     * Start delivering messages using given message handler.\n+     *\n+     * @param messageHandler\n+     *          Message handler to deliver messages\n+     * @throws AlreadyStartDeliveryException if someone already started delivery.\n+     * @throws ClientNotSubscribedException when start delivery before subscribe.\n+     */\n+    public synchronized void startDelivery(MessageHandler messageHandler)\n+    throws AlreadyStartDeliveryException, ClientNotSubscribedException {\n+        if (null != this.msgHandler) {\n+            throw new AlreadyStartDeliveryException(\"A message handler \" + msgHandler\n+                + \" has been started for \" + topicSubscriber);\n+        }\n+        if (null != messageHandler && messageHandler instanceof FilterableMessageHandler) {\n+            FilterableMessageHandler filterMsgHandler =\n+                (FilterableMessageHandler) messageHandler;\n+            if (filterMsgHandler.hasMessageFilter()) {\n+                if (null == preferences) {\n+                    // no preferences means talking to an old version hub server\n+                    logger.warn(\"Start delivering messages with filter but no subscription \"\n+                              + \"preferences found. It might due to talking to an old version\"\n+                              + \" hub server.\");\n+                    // use the original message handler.\n+                    messageHandler = filterMsgHandler.getMessageHandler();\n+                } else {\n+                    // pass subscription preferences to message filter\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Start delivering messages with filter on {}, preferences: {}\",\n+                                     va(topicSubscriber,\n+                                        SubscriptionStateUtils.toString(preferences)));\n+                    }\n+                    ClientMessageFilter msgFilter = filterMsgHandler.getMessageFilter();\n+                    msgFilter.setSubscriptionPreferences(topicSubscriber.getTopic(),\n+                                                         topicSubscriber.getSubscriberId(),\n+                                                         preferences);\n+                }\n+            }\n+        }\n+\n+        this.msgHandler = messageHandler;\n+        // Once the MessageHandler is registered, see if we have any queued up\n+        // subscription messages sent to us already from the server. If so,\n+        // consume those first. Do this only if the MessageHandler registered is\n+        // not null (since that would be the HedwigSubscriber.stopDelivery\n+        // call).\n+        if (null == msgHandler) {\n+            return;\n+        }\n+        if (msgQueue.size() > 0) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Consuming {} queued up messages for {}\",\n+                             va(msgQueue.size(), topicSubscriber));\n+            }\n+            for (Message message : msgQueue) {\n+                asyncMessageDeliver(message);\n+            }\n+            // Now we can remove the queued up messages since they are all\n+            // consumed.\n+            msgQueue.clear();\n+        }\n+    }\n+\n+    /**\n+     * Stop delivering messages to the subscriber.\n+     */\n+    public synchronized void stopDelivery() {\n+        this.msgHandler = null;\n+    }\n+\n+    /**\n+     * Handle received message.\n+     *\n+     * @param message\n+     *          Received message.\n+     */\n+    public synchronized void handleMessage(Message message) {\n+        if (null != msgHandler) {\n+            asyncMessageDeliver(message);\n+        } else {\n+            // MessageHandler has not yet been registered so queue up these\n+            // messages for the Topic Subscription. Make the initial lazy\n+            // creation of the message queue thread safe just so we don't\n+            // run into a race condition where two simultaneous threads process\n+            // a received message and both try to create a new instance of\n+            // the message queue. Performance overhead should be okay\n+            // because the delivery of the topic has not even started yet\n+            // so these messages are not consumed and just buffered up here.\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Message {} has arrived but no MessageHandler provided for {}\"\n+                             + \" yet so queueing up the message.\",\n+                             va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n+                                topicSubscriber));\n+            }\n+            msgQueue.add(message);\n+        }\n+    }\n+\n+    /**\n+     * Deliver message to the client.\n+     *\n+     * @param message\n+     *          Message to deliver.\n+     */\n+    public synchronized void asyncMessageDeliver(Message message) {\n+        if (null == msgHandler) {\n+            logger.error(\"No message handler found to deliver message {} to {}.\",\n+                         va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n+                            topicSubscriber));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Call the client app's MessageHandler asynchronously to deliver the message {} to {}\",\n+                         va(message, topicSubscriber));\n+        }\n+        unsafeDeliverMessage(message);\n+    }\n+\n+    /**\n+     * Unsafe version to deliver message to a message handler.\n+     * Caller need to handle synchronization issue.\n+     *\n+     * @param message\n+     *          Message to deliver.\n+     */\n+    protected void unsafeDeliverMessage(Message message) {\n+        MessageConsumeData messageConsumeData =\n+            new MessageConsumeData(topicSubscriber, message);\n+        msgHandler.deliver(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n+                           message, channelManager.getConsumeCallback(),\n+                           messageConsumeData);\n+    }\n+\n+    private synchronized boolean updateLastMessageSeqId(MessageSeqId seqId) {\n+        if (null != lastMessageSeqId &&\n+            seqId.getLocalComponent() <= lastMessageSeqId.getLocalComponent()) {\n+            return false;\n+        }\n+        ++numConsumedMessagesInBuffer;\n+        lastMessageSeqId = seqId;\n+        if (numConsumedMessagesInBuffer >= cfg.getConsumedMessagesBufferSize()) {\n+            numConsumedMessagesInBuffer = 0;\n+            lastMessageSeqId = null;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Consume a specific message.\n+     *\n+     * @param messageSeqId\n+     *          Message seq id.\n+     */\n+    public void consume(final MessageSeqId messageSeqId) {\n+        PubSubRequest.Builder pubsubRequestBuilder =\n+            NetUtils.buildConsumeRequest(channelManager.nextTxnId(),\n+                                         topicSubscriber, messageSeqId);\n+\n+        // For Consume requests, we will send them from the client in a fire and\n+        // forget manner. We are not expecting the server to send back an ack\n+        // response so no need to register this in the ResponseHandler. There\n+        // are no callbacks to invoke since this isn't a client initiated\n+        // action. Instead, just have a future listener that will log an error\n+        // message if there was a problem writing the consume request.\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Writing a Consume request to channel: {} with messageSeqId: {} for {}\",\n+                         va(channel, messageSeqId, topicSubscriber));\n+        }\n+        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error writing a Consume request to channel: {} with messageSeqId: {} for {}\",\n+                                 va(channel, messageSeqId, topicSubscriber));\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Application acked to consume message.\n+     *\n+     * @param message\n+     *          Message consumed by application.\n+     */\n+    public void messageConsumed(Message message) {\n+        // For consume response to server, there is a config param on how many\n+        // messages to consume and buffer up before sending the consume request.\n+        // We just need to keep a count of the number of messages consumed\n+        // and the largest/latest msg ID seen so far in this batch. Messages\n+        // should be delivered in order and without gaps. Do this only if\n+        // auto-sending of consume messages is enabled.\n+        if (cfg.isAutoSendConsumeMessageEnabled()) {\n+            // Update these variables only if we are auto-sending consume\n+            // messages to the server. Otherwise the onus is on the client app\n+            // to call the Subscriber consume API to let the server know which\n+            // messages it has successfully consumed.\n+            if (updateLastMessageSeqId(message.getMsgId())) {\n+                // Send the consume request and reset the consumed messages buffer\n+                // variables. We will use the same Channel created from the\n+                // subscribe request for the TopicSubscriber.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Consume message {} when reaching consumed message buffer limit.\",\n+                                 message.getMsgId());\n+                }\n+                consume(message.getMsgId());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Resubscribe a subscriber if necessary.\n+     *\n+     * @param event\n+     *          Subscription Event.\n+     */\n+    public void resubscribeIfNecessary(SubscriptionEvent event) {\n+        // clear topic ownership\n+        if (SubscriptionEvent.TOPIC_MOVED == event) {\n+            channelManager.clearHostForTopic(topicSubscriber.getTopic(),\n+                                             NetUtils.getHostFromChannel(channel));\n+        }\n+        if (!op.options.getEnableResubscribe()) {\n+            channelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n+                topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(), event);\n+            return;\n+        }\n+        // Since the connection to the server host that was responsible\n+        // for the topic died, we are not sure about the state of that\n+        // server. Resend the original subscribe request data to the default\n+        // server host/VIP. Also clear out all of the servers we've\n+        // contacted or attempted to from this request as we are starting a\n+        // \"fresh\" subscribe request.\n+        op.clearServersList();\n+        // Set a new type of VoidCallback for this async call. We need this\n+        // hook so after the resubscribe has completed, delivery for\n+        // that topic subscriber should also be restarted (if it was that\n+        // case before the channel disconnect).\n+        final long retryWaitTime = cfg.getSubscribeReconnectRetryWaitTime();\n+        ResubscribeCallback resubscribeCb =\n+            new ResubscribeCallback(topicSubscriber, op,\n+                                    channelManager, retryWaitTime);\n+        op.setCallback(resubscribeCb);\n+        op.context = null;\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Resubscribe {} with origSubData {}\",\n+                         va(topicSubscriber, op));\n+        }\n+        // resubmit the request\n+        channelManager.submitOp(op);\n+    }\n+}"},{"sha":"11bb34bc8c74a35090c1d708c5d65bb898d22cf2","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","status":"renamed","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.hedwig.client.netty.impl.multiplex;\n+package org.apache.hedwig.client.netty.impl;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -41,13 +41,13 @@\n     // Private member variables\n     private final TopicSubscriber origTopicSubscriber;\n     private final PubSubData origSubData;\n-    private final MultiplexHChannelManager channelManager;\n+    private final AbstractHChannelManager channelManager;\n     private final long retryWaitTime;\n \n     // Constructor\n     ResubscribeCallback(TopicSubscriber origTopicSubscriber,\n                         PubSubData origSubData,\n-                        MultiplexHChannelManager channelManager,\n+                        AbstractHChannelManager channelManager,\n                         long retryWaitTime) {\n         this.origTopicSubscriber = origTopicSubscriber;\n         this.origSubData = origSubData;\n@@ -90,6 +90,9 @@ public void operationFailed(Object ctx, PubSubException exception) {\n     }\n \n     private void retrySubscribeRequest() {\n+        if (channelManager.isClosed()) {\n+            return;\n+        }\n         origSubData.clearServersList();\n         logger.debug(\"Resubmit subscribe request for {} in {} ms later.\",\n                      va(origTopicSubscriber, retryWaitTime));","previous_filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/ResubscribeCallback.java"},{"sha":"da234f64890e96b24275e19036f856a6e5350434","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -194,6 +194,7 @@ public void startDelivery(TopicSubscriber topicSubscriber,\n         startDelivery(topicSubscriber, messageHandler, false);\n     }\n \n+    @Override\n     protected void restartDelivery(TopicSubscriber topicSubscriber)\n         throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n         startDelivery(topicSubscriber, null, true);"},{"sha":"2224930265dd334b4e951ac0e491330075644572","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","status":"modified","additions":9,"deletions":521,"changes":530,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -18,301 +18,34 @@\n package org.apache.hedwig.client.netty.impl.multiplex;\n \n import java.net.InetSocketAddress;\n-import java.util.LinkedList;\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n-import com.google.protobuf.ByteString;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFuture;\n-import org.jboss.netty.channel.ChannelFutureListener;\n \n-import org.apache.hedwig.client.api.MessageHandler;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.data.MessageConsumeData;\n import org.apache.hedwig.client.data.PubSubData;\n import org.apache.hedwig.client.data.TopicSubscriber;\n-import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n-import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n import org.apache.hedwig.client.netty.HChannelManager;\n import org.apache.hedwig.client.netty.HChannel;\n import org.apache.hedwig.client.netty.NetUtils;\n-import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.client.netty.impl.AbstractSubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.impl.ActiveSubscriber;\n import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n-import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n-import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n-import org.apache.hedwig.filter.ClientMessageFilter;\n-import org.apache.hedwig.protocol.PubSubProtocol.Message;\n-import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n-import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n-import org.apache.hedwig.protoextensions.MessageIdUtils;\n-import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n-import org.apache.hedwig.util.SubscriptionListener;\n import static org.apache.hedwig.util.VarArgs.va;\n \n-public class MultiplexSubscribeResponseHandler extends SubscribeResponseHandler {\n+public class MultiplexSubscribeResponseHandler extends AbstractSubscribeResponseHandler {\n \n     private static Logger logger =\n         LoggerFactory.getLogger(MultiplexSubscribeResponseHandler.class);\n \n-    class ActiveSubscriber implements SubscriptionListener {\n-        private final TopicSubscriber topicSubscriber;\n-        private final PubSubData op;\n-        private final SubscriptionPreferences preferences;\n-\n-        // the underlying netty channel to send request\n-        private final Channel channel;\n-\n-        // Counter for the number of consumed messages so far to buffer up before we\n-        // send the Consume message back to the server along with the last/largest\n-        // message seq ID seen so far in that batch.\n-        private int numConsumedMessagesInBuffer = 0;\n-        private MessageSeqId lastMessageSeqId;\n-\n-        // Message Handler\n-        private MessageHandler msgHandler;\n-\n-        // Queue used for subscribes when the MessageHandler hasn't been registered\n-        // yet but we've already received subscription messages from the server.\n-        // This will be lazily created as needed.\n-        private Queue<Message> msgQueue = new LinkedList<Message>();\n-\n-        ActiveSubscriber(TopicSubscriber ts, PubSubData op,\n-                        SubscriptionPreferences preferences,\n-                        Channel channel) {\n-            this.topicSubscriber = ts;\n-            this.op = op;\n-            this.preferences = preferences;\n-            this.channel = channel;\n-        }\n-\n-        PubSubData getPubSubData() {\n-            return this.op;\n-        }\n-\n-        TopicSubscriber getTopicSubscriber() {\n-            return this.topicSubscriber;\n-        }\n-\n-        synchronized boolean updateLastMessageSeqId(MessageSeqId seqId) {\n-            if (null != lastMessageSeqId &&\n-                seqId.getLocalComponent() <= lastMessageSeqId.getLocalComponent()) {\n-                return false;\n-            }\n-            ++numConsumedMessagesInBuffer;\n-            lastMessageSeqId = seqId;\n-            if (numConsumedMessagesInBuffer >= cfg.getConsumedMessagesBufferSize()) {\n-                numConsumedMessagesInBuffer = 0;\n-                lastMessageSeqId = null;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        synchronized void startDelivery(MessageHandler messageHandler)\n-        throws AlreadyStartDeliveryException, ClientNotSubscribedException {\n-            if (null != this.msgHandler) {\n-                throw new AlreadyStartDeliveryException(\"A message handler \" + msgHandler \n-                    + \" has been started for \" + topicSubscriber);\n-            }\n-            if (null != messageHandler && messageHandler instanceof FilterableMessageHandler) {\n-                FilterableMessageHandler filterMsgHandler =\n-                    (FilterableMessageHandler) messageHandler;\n-                if (filterMsgHandler.hasMessageFilter()) {\n-                    if (null == preferences) {\n-                        // no preferences means talking to an old version hub server\n-                        logger.warn(\"Start delivering messages with filter but no subscription \"\n-                                  + \"preferences found. It might due to talking to an old version\"\n-                                  + \" hub server.\");\n-                        // use the original message handler.\n-                        messageHandler = filterMsgHandler.getMessageHandler();\n-                    } else {\n-                        // pass subscription preferences to message filter\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Start delivering messages with filter on {}, preferences: {}\",\n-                                         va(topicSubscriber,\n-                                            SubscriptionStateUtils.toString(preferences)));\n-                        }\n-                        ClientMessageFilter msgFilter = filterMsgHandler.getMessageFilter();\n-                        msgFilter.setSubscriptionPreferences(topicSubscriber.getTopic(),\n-                                                             topicSubscriber.getSubscriberId(),\n-                                                             preferences);\n-                    }\n-                }\n-            }\n-\n-            this.msgHandler = messageHandler;\n-            // Once the MessageHandler is registered, see if we have any queued up\n-            // subscription messages sent to us already from the server. If so,\n-            // consume those first. Do this only if the MessageHandler registered is\n-            // not null (since that would be the HedwigSubscriber.stopDelivery\n-            // call).\n-            if (null == msgHandler) {\n-                return;\n-            }\n-            if (msgQueue.size() > 0) {\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Consuming {} queued up messages for {}\",\n-                                 va(msgQueue.size(), topicSubscriber));\n-                }\n-                for (Message message : msgQueue) {\n-                    asyncMessageDeliver(message);\n-                }\n-                // Now we can remove the queued up messages since they are all\n-                // consumed.\n-                msgQueue.clear();\n-            }\n-        }\n-\n-        synchronized void stopDelivery() {\n-            this.msgHandler = null;\n-        }\n-\n-        synchronized void handleMessage(Message message) {\n-            if (null != msgHandler) {\n-                asyncMessageDeliver(message);\n-            } else {\n-                // MessageHandler has not yet been registered so queue up these\n-                // messages for the Topic Subscription. Make the initial lazy\n-                // creation of the message queue thread safe just so we don't\n-                // run into a race condition where two simultaneous threads process\n-                // a received message and both try to create a new instance of\n-                // the message queue. Performance overhead should be okay\n-                // because the delivery of the topic has not even started yet\n-                // so these messages are not consumed and just buffered up here.\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Message {} has arrived but no MessageHandler provided for {}\"\n-                                 + \" yet so queueing up the message.\",\n-                                 va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n-                                    topicSubscriber));\n-                }\n-                msgQueue.add(message);\n-            }\n-        }\n-\n-        synchronized void asyncMessageDeliver(Message message) {\n-            if (null == msgHandler) {\n-                logger.error(\"No message handler found to deliver message {} to {}.\",\n-                             va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n-                                topicSubscriber));\n-                return;\n-            }\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Call the client app's MessageHandler asynchronously to deliver the message {} to {}\",\n-                             va(message, topicSubscriber));\n-            }\n-            MessageConsumeData messageConsumeData =\n-                new MessageConsumeData(topicSubscriber, message);\n-            msgHandler.deliver(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n-                               message, sChannelManager.getConsumeCallback(),\n-                               messageConsumeData);\n-        }\n-\n-        void consume(final MessageSeqId messageSeqId) {\n-            PubSubRequest.Builder pubsubRequestBuilder =\n-                NetUtils.buildConsumeRequest(sChannelManager.nextTxnId(),\n-                                             topicSubscriber, messageSeqId);  \n-\n-            // For Consume requests, we will send them from the client in a fire and\n-            // forget manner. We are not expecting the server to send back an ack\n-            // response so no need to register this in the ResponseHandler. There\n-            // are no callbacks to invoke since this isn't a client initiated\n-            // action. Instead, just have a future listener that will log an error\n-            // message if there was a problem writing the consume request.\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Writing a Consume request to host: {} with messageSeqId: {} for {}\",\n-                             va(NetUtils.getHostFromChannel(channel),\n-                                messageSeqId, topicSubscriber));\n-            }\n-            ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n-            future.addListener(new ChannelFutureListener() {\n-                @Override\n-                public void operationComplete(ChannelFuture future) throws Exception {\n-                    if (!future.isSuccess()) {\n-                        logger.error(\"Error writing a Consume request to host: {} with messageSeqId: {} for {}\",\n-                                     va(host, messageSeqId, topicSubscriber));\n-                    }\n-                }\n-            });\n-        }\n-\n-        @Override\n-        public void processEvent(ByteString topic, ByteString subscriberId,\n-                                 SubscriptionEvent event) {\n-            switch (event) {\n-            // for all cases we need to resubscribe for the subscription\n-            case TOPIC_MOVED:\n-                sChannelManager.clearHostForTopic(topic, NetUtils.getHostFromChannel(channel));\n-                resubscribeIfNecessary(event);\n-                break;\n-            case SUBSCRIPTION_FORCED_CLOSED:\n-                resubscribeIfNecessary(event);\n-                break;\n-            default:\n-                logger.error(\"Receive unknown subscription event {} for {}.\",\n-                             va(event, topicSubscriber));\n-            }\n-        }\n-\n-        private void resubscribeIfNecessary(SubscriptionEvent event) {\n-            // if subscriber has been changed, we don't need to resubscribe\n-            if (!subscriptions.remove(topicSubscriber, this)) {\n-                return;\n-            }\n-            if (!op.options.getEnableResubscribe()) {\n-                sChannelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n-                    topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(), event);\n-                return;\n-            }\n-            // Since the connection to the server host that was responsible\n-            // for the topic died, we are not sure about the state of that\n-            // server. Resend the original subscribe request data to the default\n-            // server host/VIP. Also clear out all of the servers we've\n-            // contacted or attempted to from this request as we are starting a\n-            // \"fresh\" subscribe request.\n-            op.clearServersList();\n-            // Set a new type of VoidCallback for this async call. We need this\n-            // hook so after the resubscribe has completed, delivery for\n-            // that topic subscriber should also be restarted (if it was that\n-            // case before the channel disconnect).\n-            final long retryWaitTime = cfg.getSubscribeReconnectRetryWaitTime();\n-            ResubscribeCallback resubscribeCb =\n-                new ResubscribeCallback(topicSubscriber, op,\n-                                        sChannelManager, retryWaitTime);\n-            op.setCallback(resubscribeCb);\n-            op.context = null;\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Resubscribe {} with origSubData {}\",\n-                             va(topicSubscriber, op));\n-            }\n-            // resubmit the request\n-            sChannelManager.submitOp(op);\n-        }\n-    }\n-\n-    protected final ReentrantReadWriteLock disconnectLock =\n-        new ReentrantReadWriteLock();\n-\n     // the underlying subscription channel\n     volatile HChannel hChannel;\n-    InetSocketAddress host; \n-    protected final ConcurrentMap<TopicSubscriber, ActiveSubscriber> subscriptions\n-        = new ConcurrentHashMap<TopicSubscriber, ActiveSubscriber>();\n     private final MultiplexHChannelManager sChannelManager;\n \n     protected MultiplexSubscribeResponseHandler(ClientConfiguration cfg,\n@@ -321,23 +54,11 @@ protected MultiplexSubscribeResponseHandler(ClientConfiguration cfg,\n         sChannelManager = (MultiplexHChannelManager) channelManager;\n     }\n \n-    protected HChannelManager getHChannelManager() {\n-        return this.sChannelManager;\n-    }\n-\n-    protected ClientConfiguration getConfiguration() {\n-        return cfg;\n-    }\n-\n-    private ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n-        return subscriptions.get(ts);\n-    }\n-\n     @Override\n     public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n                                Channel channel) throws Exception {\n         if (null == hChannel) {\n-            host = NetUtils.getHostFromChannel(channel);\n+            InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n             hChannel = sChannelManager.getSubscriptionChannel(host);\n             if (null == hChannel ||\n                 !channel.equals(hChannel.getChannel())) {\n@@ -347,205 +68,13 @@ public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n                 return;\n             }\n         }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Handling a Subscribe response: {}, pubSubData: {}, host: {}.\",\n-                         va(response, pubSubData, NetUtils.getHostFromChannel(channel)));\n-        }\n-        switch (response.getStatusCode()) {\n-        case SUCCESS:\n-            TopicSubscriber ts = new TopicSubscriber(pubSubData.topic,\n-                                                     pubSubData.subscriberId);\n-            SubscriptionPreferences preferences = null;\n-            if (response.hasResponseBody()) {\n-                ResponseBody respBody = response.getResponseBody(); \n-                if (respBody.hasSubscribeResponse()) {\n-                    SubscribeResponse resp = respBody.getSubscribeResponse();\n-                    if (resp.hasPreferences()) {\n-                        preferences = resp.getPreferences();\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Receive subscription preferences for {} : {}\",\n-                                         va(ts,\n-                                            SubscriptionStateUtils.toString(preferences)));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ActiveSubscriber ss = new ActiveSubscriber(ts, pubSubData, preferences,\n-                                                       channel);\n-\n-            boolean success = false;\n-            // Store the Subscribe state\n-            disconnectLock.readLock().lock();\n-            try {\n-                ActiveSubscriber oldSS = subscriptions.putIfAbsent(ts, ss);\n-                if (null != oldSS) {\n-                    logger.warn(\"Subscribe {} has existed in channel {}.\",\n-                                va(ts, channel));\n-                    success = false;\n-                } else {\n-                    logger.debug(\"Succeed to add subscription {} in channel {}.\",\n-                                 va(ts, channel));\n-                    success = true;\n-                }\n-            } finally {\n-                disconnectLock.readLock().unlock();\n-            }\n-            if (success) {\n-                // Response was success so invoke the callback's operationFinished\n-                // method.\n-                pubSubData.getCallback().operationFinished(pubSubData.context, null);\n-            } else {\n-                ClientAlreadySubscribedException exception =\n-                    new ClientAlreadySubscribedException(\"Client is already subscribed for \" + ts);\n-                pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n-            }\n-            break;\n-        case CLIENT_ALREADY_SUBSCRIBED:\n-            // For Subscribe requests, the server says that the client is\n-            // already subscribed to it.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientAlreadySubscribedException(\n-                                                     \"Client is already subscribed for topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                                                     + pubSubData.subscriberId.toStringUtf8()));\n-            break;\n-        case SERVICE_DOWN:\n-            // Response was service down failure so just invoke the callback's\n-            // operationFailed method.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                     \"Server responded with a SERVICE_DOWN status\"));\n-            break;\n-        case NOT_RESPONSIBLE_FOR_TOPIC:\n-            // Redirect response so we'll need to repost the original Subscribe\n-            // Request\n-            handleRedirectResponse(response, pubSubData, channel);\n-            break;\n-        default:\n-            // Consider all other status codes as errors, operation failed\n-            // cases.\n-            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                     \"Server responded with a status code of: \" + response.getStatusCode()));\n-            break;\n-        }\n-    }\n-\n-    @Override\n-    public void handleSubscribeMessage(PubSubResponse response) {\n-        Message message = response.getMessage();\n-        TopicSubscriber ts = new TopicSubscriber(response.getTopic(),\n-                                                 response.getSubscriberId());\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Handling a Subscribe message in response: {}, {}\",\n-                         va(response, ts));\n-        }\n-        ActiveSubscriber ss = getActiveSubscriber(ts);\n-        if (null == ss) {\n-            logger.error(\"Subscriber {} is not found receiving its message {}.\",\n-                         va(ts, MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n-            return;\n-        }\n-        ss.handleMessage(message);\n-    }\n-\n-    @Override\n-    protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n-                                       Message message) {\n-        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n-        if (null == ss) {\n-            logger.error(\"Subscriber {} is not found delivering its message {}.\",\n-                         va(topicSubscriber,\n-                            MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n-            return;\n-        }\n-        ss.asyncMessageDeliver(message);\n-    }\n-\n-    @Override\n-    protected void messageConsumed(TopicSubscriber topicSubscriber,\n-                                   Message message) {\n-        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n-        if (null == ss) {\n-            logger.warn(\"Subscriber {} is not found consumed its message {}.\",\n-                        va(topicSubscriber,\n-                           MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n-            return;\n-        }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Message has been successfully consumed by the client app : {}, {}\",\n-                         va(message, topicSubscriber));\n-        }\n-        // For consume response to server, there is a config param on how many\n-        // messages to consume and buffer up before sending the consume request.\n-        // We just need to keep a count of the number of messages consumed\n-        // and the largest/latest msg ID seen so far in this batch. Messages\n-        // should be delivered in order and without gaps. Do this only if\n-        // auto-sending of consume messages is enabled.\n-        if (cfg.isAutoSendConsumeMessageEnabled()) {\n-            // Update these variables only if we are auto-sending consume\n-            // messages to the server. Otherwise the onus is on the client app\n-            // to call the Subscriber consume API to let the server know which\n-            // messages it has successfully consumed.\n-            if (ss.updateLastMessageSeqId(message.getMsgId())) {\n-                // Send the consume request and reset the consumed messages buffer\n-                // variables. We will use the same Channel created from the\n-                // subscribe request for the TopicSubscriber.\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Consume message {} when reaching consumed message buffer limit.\",\n-                                 message.getMsgId());\n-                }\n-                ss.consume(message.getMsgId());\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void handleSubscriptionEvent(ByteString topic, ByteString subscriberId,\n-                                        SubscriptionEvent event) {\n-        TopicSubscriber ts = new TopicSubscriber(topic, subscriberId);\n-        ActiveSubscriber ss = getActiveSubscriber(ts);\n-        if (null == ss) {\n-            logger.warn(\"No subscription {} found receiving subscription event {}.\",\n-                        va(ts, event));\n-            return;\n-        }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Received subscription event {} for ({}).\",\n-                         va(event, ts));\n-        }\n-        ss.processEvent(topic, subscriberId, event);\n-    }\n-\n-    @Override\n-    public void startDelivery(final TopicSubscriber topicSubscriber,\n-                              MessageHandler messageHandler)\n-    throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n-        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n-        if (null == ss) {\n-            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n-        }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Start delivering message for {} using message handler {}\",\n-                         va(topicSubscriber, messageHandler));\n-        }\n-        ss.startDelivery(messageHandler); \n-    }\n-\n-    @Override\n-    public void stopDelivery(final TopicSubscriber topicSubscriber)\n-    throws ClientNotSubscribedException {\n-        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n-        if (null == ss) {\n-            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n-        }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Stop delivering messages for {}\", topicSubscriber);\n-        }\n-        ss.stopDelivery();\n+        super.handleResponse(response, pubSubData, channel);\n     }\n \n     @Override\n-    public boolean hasSubscription(TopicSubscriber topicSubscriber) {\n-        return subscriptions.containsKey(topicSubscriber);\n+    protected void handleSuccessResponse(TopicSubscriber ts, ActiveSubscriber as,\n+                                         Channel channel) {\n+        // do nothing now\n     }\n \n     @Override\n@@ -562,12 +91,7 @@ public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n         Callback<ResponseBody> closeCb = new Callback<ResponseBody>() {\n             @Override\n             public void operationFinished(Object ctx, ResponseBody respBody) {\n-                disconnectLock.readLock().lock();\n-                try {\n-                    subscriptions.remove(topicSubscriber, ss);\n-                } finally {\n-                    disconnectLock.readLock().unlock();\n-                }\n+                removeSubscription(topicSubscriber, ss);\n                 callback.operationFinished(context, null);\n             }\n \n@@ -583,40 +107,4 @@ public void operationFailed(Object ctx, PubSubException exception) {\n         hChannel.submitOp(closeOp);\n     }\n \n-    @Override\n-    public void consume(final TopicSubscriber topicSubscriber,\n-                        final MessageSeqId messageSeqId) {\n-        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n-        if (null == ss) {\n-            logger.warn(\"Subscriber {} is not found consuming message {}.\",\n-                        va(topicSubscriber,\n-                           MessageIdUtils.msgIdToReadableString(messageSeqId)));\n-            return;\n-        }\n-        ss.consume(messageSeqId); \n-    }\n-\n-    @Override\n-    public void onChannelDisconnected(InetSocketAddress host, Channel channel) {\n-        disconnectLock.writeLock().lock();\n-        try {\n-            onDisconnect(host);\n-        } finally {\n-            disconnectLock.writeLock().unlock();\n-        }\n-    }\n-\n-    private void onDisconnect(InetSocketAddress host) {\n-        for (ActiveSubscriber ss : subscriptions.values()) {\n-            onDisconnect(ss, host);\n-        }\n-    }\n-\n-    private void onDisconnect(ActiveSubscriber ss, InetSocketAddress host) {\n-        TopicSubscriber ts = ss.getTopicSubscriber();\n-        logger.info(\"Subscription channel for ({}) is disconnected.\", ts);\n-        ss.processEvent(ts.getTopic(), ts.getSubscriberId(),\n-                        SubscriptionEvent.TOPIC_MOVED);\n-    }\n-\n }"},{"sha":"ed31f9ef0a5a3b3875cee29be481e515478c1c7c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -182,6 +182,7 @@ public void startDelivery(TopicSubscriber topicSubscriber,\n         startDelivery(topicSubscriber, messageHandler, false);\n     }\n \n+    @Override\n     protected void restartDelivery(TopicSubscriber topicSubscriber)\n         throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n         startDelivery(topicSubscriber, null, true);"},{"sha":"f84a88ed8644cc5ab6c8e829f46cf1a450ec373f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","status":"modified","additions":148,"deletions":435,"changes":583,"blob_url":"https://github.com/apache/bookkeeper/blob/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/baef283841c05bcb4ebceaaa5d540f7a30e4af1a/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java?ref=baef283841c05bcb4ebceaaa5d540f7a30e4af1a","patch":"@@ -18,394 +18,113 @@\n package org.apache.hedwig.client.netty.impl.simple;\n \n import java.net.InetSocketAddress;\n+import java.util.Set;\n import java.util.Collections;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.LinkedList;\n-import java.util.Queue;\n-import java.util.Set;\n-\n-import com.google.protobuf.ByteString;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelFuture;\n import org.jboss.netty.channel.ChannelFutureListener;\n \n+import com.google.protobuf.ByteString;\n+\n import org.apache.hedwig.client.api.MessageHandler;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.data.MessageConsumeData;\n import org.apache.hedwig.client.data.PubSubData;\n import org.apache.hedwig.client.data.TopicSubscriber;\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n import org.apache.hedwig.client.netty.HChannelManager;\n-import org.apache.hedwig.client.netty.HChannel;\n-import org.apache.hedwig.client.netty.NetUtils;\n-import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.AbstractSubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.impl.ActiveSubscriber;\n import org.apache.hedwig.client.netty.impl.HChannelImpl;\n import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n-import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n-import org.apache.hedwig.filter.ClientMessageFilter;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n-import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n-import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n-import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n import org.apache.hedwig.util.Callback;\n-import static org.apache.hedwig.util.VarArgs.va;\n \n-public class SimpleSubscribeResponseHandler extends SubscribeResponseHandler {\n+public class SimpleSubscribeResponseHandler extends AbstractSubscribeResponseHandler {\n \n     private static Logger logger = LoggerFactory.getLogger(SimpleSubscribeResponseHandler.class);\n \n-    // Member variables used when this ResponseHandler is for a Subscribe\n-    // channel. We need to be able to consume messages sent back to us from\n-    // the server, and to also recreate the Channel connection if it ever goes\n-    // down. For that, we need to store the original PubSubData for the\n-    // subscribe request, and also the MessageHandler that was registered when\n-    // delivery of messages started for the subscription.\n-    private volatile PubSubData origSubData;\n-    private volatile TopicSubscriber origTopicSubscriber;\n-    private SubscriptionPreferences preferences;\n-    private Channel subscribeChannel;\n-    private MessageHandler messageHandler;\n-    // Counter for the number of consumed messages so far to buffer up before we\n-    // send the Consume message back to the server along with the last/largest\n-    // message seq ID seen so far in that batch.\n-    private int numConsumedMessagesInBuffer = 0;\n-    private MessageSeqId lastMessageSeqId;\n-    // Queue used for subscribes when the MessageHandler hasn't been registered\n-    // yet but we've already received subscription messages from the server.\n-    // This will be lazily created as needed.\n-    private Queue<Message> subscribeMsgQueue;\n-    // Set to store all of the outstanding subscribed messages that are pending\n-    // to be consumed by the client app's MessageHandler. If this ever grows too\n-    // big (e.g. problem at the client end for message consumption), we can\n-    // throttle things by temporarily setting the Subscribe Netty Channel\n-    // to not be readable. When the Set has shrunk sufficiently, we can turn the\n-    // channel back on to read new messages.\n-    private Set<Message> outstandingMsgSet;\n-\n-    private SimpleHChannelManager sChannelManager;\n-\n-    protected SimpleSubscribeResponseHandler(ClientConfiguration cfg,\n-                                             HChannelManager channelManager) {\n-        super(cfg, channelManager);\n-        sChannelManager = (SimpleHChannelManager) channelManager;\n-        origTopicSubscriber = null;\n-    }\n-\n-    protected HChannelManager getHChannelManager() {\n-        return this.sChannelManager;\n-    }\n-\n-    protected ClientConfiguration getConfiguration() {\n-        return cfg;\n-    }\n-\n-    protected MessageHandler getMessageHandler() {\n-        return messageHandler;\n-    }\n-\n-    @Override\n-    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n-                               Channel channel) throws Exception {\n-        // If this was not a successful response to the Subscribe request, we\n-        // won't be using the Netty Channel created so just close it.\n-        if (!response.getStatusCode().equals(StatusCode.SUCCESS)) {\n-            HChannelImpl.getHChannelHandlerFromChannel(channel).closeExplicitly();\n-            channel.close();\n-        }\n-\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Handling a Subscribe response: {}, pubSubData: {}, host: {}.\",\n-                         va(response, pubSubData, NetUtils.getHostFromChannel(channel)));\n-        }\n-        switch (response.getStatusCode()) {\n-        case SUCCESS:\n-            // Store the original PubSubData used to create this successful\n-            // Subscribe request.\n-            origSubData = pubSubData;\n-            origTopicSubscriber = new TopicSubscriber(pubSubData.topic,\n-                                                      pubSubData.subscriberId);\n-            synchronized(this) {\n-                // For successful Subscribe requests, store this Channel locally\n-                // and set it to not be readable initially.\n-                // This way we won't be delivering messages for this topic\n-                // subscription until the client explicitly says so.\n-                subscribeChannel = channel;\n-                subscribeChannel.setReadable(false);\n-                if (response.hasResponseBody()) {\n-                    ResponseBody respBody = response.getResponseBody(); \n-                    if (respBody.hasSubscribeResponse()) {\n-                        SubscribeResponse resp = respBody.getSubscribeResponse();\n-                        if (resp.hasPreferences()) {\n-                            preferences = resp.getPreferences();\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Receive subscription preferences for {} : {}\",\n-                                             va(origTopicSubscriber,\n-                                                SubscriptionStateUtils.toString(preferences)));\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Store the mapping for the TopicSubscriber to the Channel.\n-                // This is so we can control the starting and stopping of\n-                // message deliveries from the server on that Channel. Store\n-                // this only on a successful ack response from the server.\n-                sChannelManager.storeSubscriptionChannel(origTopicSubscriber,\n-                                                                    channel);\n-\n-                // Lazily create the Set (from a concurrent hashmap) to keep track\n-                // of outstanding Messages to be consumed by the client app. At this\n-                // stage, delivery for that topic hasn't started yet so creation of\n-                // this Set should be thread safe. We'll create the Set with an initial\n-                // capacity equal to the configured parameter for the maximum number of\n-                // outstanding messages to allow. The load factor will be set to\n-                // 1.0f which means we'll only rehash and allocate more space if\n-                // we ever exceed the initial capacity. That should be okay\n-                // because when that happens, things are slow already and piling\n-                // up on the client app side to consume messages.\n-                outstandingMsgSet = Collections.newSetFromMap(\n-                        new ConcurrentHashMap<Message,Boolean>(\n-                                cfg.getMaximumOutstandingMessages(), 1.0f));\n-            }\n-            // Response was success so invoke the callback's operationFinished\n-            // method.\n-            pubSubData.getCallback().operationFinished(pubSubData.context, null);\n-            break;\n-        case CLIENT_ALREADY_SUBSCRIBED:\n-            // For Subscribe requests, the server says that the client is\n-            // already subscribed to it.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientAlreadySubscribedException(\n-                                                     \"Client is already subscribed for topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                                                     + pubSubData.subscriberId.toStringUtf8()));\n-            break;\n-        case SERVICE_DOWN:\n-            // Response was service down failure so just invoke the callback's\n-            // operationFailed method.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                     \"Server responded with a SERVICE_DOWN status\"));\n-            break;\n-        case NOT_RESPONSIBLE_FOR_TOPIC:\n-            // Redirect response so we'll need to repost the original Subscribe\n-            // Request\n-            handleRedirectResponse(response, pubSubData, channel);\n-            break;\n-        default:\n-            // Consider all other status codes as errors, operation failed\n-            // cases.\n-            logger.error(\"Unexpected error response from server for PubSubResponse: {}\", response);\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                     \"Server responded with a status code of: \" + response.getStatusCode()));\n-            break;\n-        }\n-    }\n-\n-    @Override\n-    public void handleSubscribeMessage(PubSubResponse response) {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Handling a Subscribe message in response: {}, {}\",\n-                         va(response, origTopicSubscriber));\n-        }\n-        Message message = response.getMessage();\n-\n-        synchronized (this) {\n-            // Consume the message asynchronously that the client is subscribed\n-            // to. Do this only if delivery for the subscription has started and\n-            // a MessageHandler has been registered for the TopicSubscriber.\n-            if (messageHandler != null) {\n-                asyncMessageDeliver(origTopicSubscriber, message);\n-            } else {\n-                // MessageHandler has not yet been registered so queue up these\n-                // messages for the Topic Subscription. Make the initial lazy\n-                // creation of the message queue thread safe just so we don't\n-                // run into a race condition where two simultaneous threads process\n-                // a received message and both try to create a new instance of\n-                // the message queue. Performance overhead should be okay\n-                // because the delivery of the topic has not even started yet\n-                // so these messages are not consumed and just buffered up here.\n-                if (subscribeMsgQueue == null)\n-                    subscribeMsgQueue = new LinkedList<Message>();\n-                if (logger.isDebugEnabled()) {\n-                    logger\n-                    .debug(\"Message has arrived but Subscribe channel does not have a registered MessageHandler yet so queueing up the message: {}\",\n-                           message);\n-                }\n-                subscribeMsgQueue.add(message);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void handleSubscriptionEvent(ByteString topic, ByteString subscriberId,\n-                                        SubscriptionEvent event) {\n-        Channel channel;\n-        synchronized (this) {\n-            channel = subscribeChannel;\n-        }\n-        if (null == channel) {\n-            logger.warn(\"No subscription channel found when receiving subscription event {} for (topic:{}, subscriber:{}).\",\n-                        va(event, topic, subscriberId));\n-            return;\n+    /**\n+     * Simple Active Subscriber enabling client-side throttling.\n+     */\n+    static class SimpleActiveSubscriber extends ActiveSubscriber {\n+\n+        // Set to store all of the outstanding subscribed messages that are pending\n+        // to be consumed by the client app's MessageHandler. If this ever grows too\n+        // big (e.g. problem at the client end for message consumption), we can\n+        // throttle things by temporarily setting the Subscribe Netty Channel\n+        // to not be readable. When the Set has shrunk sufficiently, we can turn the\n+        // channel back on to read new messages.\n+        private final Set<Message> outstandingMsgSet;\n+\n+        public SimpleActiveSubscriber(ClientConfiguration cfg,\n+                                      AbstractHChannelManager channelManager,\n+                                      TopicSubscriber ts, PubSubData op,\n+                                      SubscriptionPreferences preferences,\n+                                      Channel channel) {\n+            super(cfg, channelManager, ts, op, preferences, channel);\n+            outstandingMsgSet = Collections.newSetFromMap(\n+                    new ConcurrentHashMap<Message, Boolean>(\n+                            cfg.getMaximumOutstandingMessages(), 1.0f));\n         }\n-        processSubscriptionEvent(event, NetUtils.getHostFromChannel(channel), channel);\n-    }\n \n-    @Override\n-    protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n-                                       Message message) {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Call the client app's MessageHandler asynchronously to deliver the message {} to {}\",\n-                         va(message, topicSubscriber));\n-        }\n-        synchronized (this) { \n+        @Override\n+        protected void unsafeDeliverMessage(Message message) {\n             // Add this \"pending to be consumed\" message to the outstandingMsgSet.\n             outstandingMsgSet.add(message);\n             // Check if we've exceeded the max size for the outstanding message set.\n-            if (outstandingMsgSet.size() >= cfg.getMaximumOutstandingMessages()\n-                    && subscribeChannel.isReadable()) {\n+            if (outstandingMsgSet.size() >= cfg.getMaximumOutstandingMessages() &&\n+                channel.isReadable()) {\n                 // Too many outstanding messages so throttle it by setting the Netty\n                 // Channel to not be readable.\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Too many outstanding messages ({}) so throttling the subscribe netty Channel\",\n                                  outstandingMsgSet.size());\n                 }\n-                subscribeChannel.setReadable(false);\n+                channel.setReadable(false);\n             }\n+            super.unsafeDeliverMessage(message);\n         }\n-        MessageConsumeData messageConsumeData =\n-            new MessageConsumeData(topicSubscriber, message);\n-        messageHandler.deliver(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n-                               message, sChannelManager.getConsumeCallback(),\n-                               messageConsumeData);\n-    }\n \n-    @Override\n-    protected synchronized void messageConsumed(TopicSubscriber topicSubscriber,\n-                                                Message message) {\n-        logger.debug(\"Message has been successfully consumed by the client app for message:  {}, {}\",\n-                     message, topicSubscriber);\n-        // Update the consumed messages buffer variables\n-        if (cfg.isAutoSendConsumeMessageEnabled()) {\n-            // Update these variables only if we are auto-sending consume\n-            // messages to the server. Otherwise the onus is on the client app\n-            // to call the Subscriber consume API to let the server know which\n-            // messages it has successfully consumed.\n-            numConsumedMessagesInBuffer++;\n-            lastMessageSeqId = message.getMsgId();\n-        }\n-        // Remove this consumed message from the outstanding Message Set.\n-        outstandingMsgSet.remove(message);\n-\n-        // For consume response to server, there is a config param on how many\n-        // messages to consume and buffer up before sending the consume request.\n-        // We just need to keep a count of the number of messages consumed\n-        // and the largest/latest msg ID seen so far in this batch. Messages\n-        // should be delivered in order and without gaps. Do this only if\n-        // auto-sending of consume messages is enabled.\n-        if (cfg.isAutoSendConsumeMessageEnabled()\n-                && numConsumedMessagesInBuffer >= cfg.getConsumedMessagesBufferSize()) {\n-            // Send the consume request and reset the consumed messages buffer\n-            // variables. We will use the same Channel created from the\n-            // subscribe request for the TopicSubscriber.\n-            if (logger.isDebugEnabled()) {\n-                logger\n-                .debug(\"Consumed message buffer limit reached so send the Consume Request to the server with lastMessageSeqId: {}\",\n-                       lastMessageSeqId);\n+        @Override\n+        public synchronized void messageConsumed(Message message) {\n+            super.messageConsumed(message);\n+            // Remove this consumed message from the outstanding Message Set.\n+            outstandingMsgSet.remove(message);\n+            // Check if we throttled message consumption previously when the\n+            // outstanding message limit was reached. For now, only turn the\n+            // delivery back on if there are no more outstanding messages to\n+            // consume. We could make this a configurable parameter if needed.\n+            if (!channel.isReadable() && outstandingMsgSet.size() == 0) {\n+                if (logger.isDebugEnabled())\n+                    logger.debug(\"Message consumption has caught up so okay to turn off\"\n+                                 + \" throttling of messages on the subscribe channel for {}\",\n+                                 topicSubscriber);\n+                channel.setReadable(true);\n             }\n-            consume(topicSubscriber, lastMessageSeqId);\n-            numConsumedMessagesInBuffer = 0;\n-            lastMessageSeqId = null;\n-        }\n-\n-        // Check if we throttled message consumption previously when the\n-        // outstanding message limit was reached. For now, only turn the\n-        // delivery back on if there are no more outstanding messages to\n-        // consume. We could make this a configurable parameter if needed.\n-        if (!subscribeChannel.isReadable() && outstandingMsgSet.size() == 0) {\n-            if (logger.isDebugEnabled())\n-                logger\n-                .debug(\"Message consumption has caught up so okay to turn off throttling of messages on the subscribe channel for {}\",\n-                       topicSubscriber);\n-            subscribeChannel.setReadable(true);\n         }\n-    }\n \n-    @Override\n-    public void startDelivery(final TopicSubscriber topicSubscriber,\n-                              MessageHandler messageHandler)\n-    throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Start delivering message for {} using message handler {}\",\n-                         va(topicSubscriber, messageHandler));\n-        }\n-        if (!hasSubscription(topicSubscriber)) {\n-            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n-        }\n-        synchronized (this) {\n-            if (null != this.messageHandler) {\n-                    throw new AlreadyStartDeliveryException(\"A message handler \" + this.messageHandler\n-                        + \" has been started for \" + topicSubscriber);\n-            }\n-            // instantiante a message handler\n-            if (null != messageHandler &&\n-                messageHandler instanceof FilterableMessageHandler) {\n-                FilterableMessageHandler filterMsgHandler =\n-                    (FilterableMessageHandler) messageHandler;\n-                // pass subscription preferences to message filter\n-                if (null == preferences) {\n-                    // no preferences means talking to an old version hub server\n-                    logger.warn(\"Start delivering messages with filter but no subscription \"\n-                              + \"preferences found. It might due to talking to an old version\"\n-                              + \" hub server.\");\n-                    // use the original message handler.\n-                    messageHandler = filterMsgHandler.getMessageHandler();\n-                } else {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Start delivering messages with filter on {}, preferences: {}\",\n-                                     va(topicSubscriber,\n-                                        SubscriptionStateUtils.toString(preferences)));\n-                    }\n-                    ClientMessageFilter msgFilter = filterMsgHandler.getMessageFilter();\n-                    msgFilter.setSubscriptionPreferences(\n-                        topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n-                        preferences);\n-                }\n-            }\n-\n-            this.messageHandler = messageHandler;\n-            // Once the MessageHandler is registered, see if we have any queued up\n-            // subscription messages sent to us already from the server. If so,\n-            // consume those first. Do this only if the MessageHandler registered is\n-            // not null (since that would be the HedwigSubscriber.stopDelivery\n-            // call).\n-            if (messageHandler != null && subscribeMsgQueue != null && subscribeMsgQueue.size() > 0) {\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Consuming {} queued up messages for {}\",\n-                                 va(subscribeMsgQueue.size(), topicSubscriber));\n-                }\n-                for (Message message : subscribeMsgQueue) {\n-                    asyncMessageDeliver(topicSubscriber, message);\n-                }\n-                // Now we can remove the queued up messages since they are all\n-                // consumed.\n-                subscribeMsgQueue.clear();\n-            }\n+        @Override\n+        public synchronized void startDelivery(MessageHandler messageHandler)\n+        throws AlreadyStartDeliveryException, ClientNotSubscribedException {\n+            super.startDelivery(messageHandler);\n             // Now make the TopicSubscriber Channel readable (it is set to not be\n             // readable when the initial subscription is done). Note that this is an\n             // asynchronous call. If this fails (not likely), the futureListener\n             // will just log an error message for now.\n-            ChannelFuture future = subscribeChannel.setReadable(true);\n+            ChannelFuture future = channel.setReadable(true);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n@@ -416,26 +135,15 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 }\n             });\n         }\n-    }\n-\n-    @Override\n-    public void stopDelivery(final TopicSubscriber topicSubscriber)\n-    throws ClientNotSubscribedException {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Stop delivering messages for {}\", topicSubscriber);\n-        }\n \n-        if (!hasSubscription(topicSubscriber)) {\n-            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n-        }\n-\n-        synchronized (this) {\n-            this.messageHandler = null;\n+        @Override\n+        public synchronized void stopDelivery() {\n+            super.stopDelivery();\n             // Now make the TopicSubscriber channel not-readable. This will buffer\n             // up messages if any are sent from the server. Note that this is an\n             // asynchronous call. If this fails (not likely), the futureListener\n             // will just log an error message for now.\n-            ChannelFuture future = subscribeChannel.setReadable(false);\n+            ChannelFuture future = channel.setReadable(false);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n@@ -446,79 +154,114 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 }\n             });\n         }\n+\n+    }\n+\n+    // Track which subscriber is alive in this response handler\n+    // Which is used for backward compat, since old version hub\n+    // server doesn't carry (topic, subscriberid) in each message.\n+    private volatile TopicSubscriber origTopicSubscriber;\n+    private volatile ActiveSubscriber origActiveSubscriber;\n+\n+    private SimpleHChannelManager sChannelManager;\n+\n+    protected SimpleSubscribeResponseHandler(ClientConfiguration cfg,\n+                                             HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        sChannelManager = (SimpleHChannelManager) channelManager;\n+    }\n+\n+    @Override\n+    protected ActiveSubscriber createActiveSubscriber(\n+        ClientConfiguration cfg, AbstractHChannelManager channelManager,\n+        TopicSubscriber ts, PubSubData op, SubscriptionPreferences preferences,\n+        Channel channel) {\n+        return new SimpleActiveSubscriber(cfg, channelManager, ts, op, preferences, channel);\n+    }\n+\n+    @Override\n+    protected synchronized ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n+        if (null == origTopicSubscriber || !origTopicSubscriber.equals(ts)) {\n+            return null;\n+        }\n+        return origActiveSubscriber;\n+    }\n+\n+    private synchronized ActiveSubscriber getActiveSubscriber() {\n+        return origActiveSubscriber;\n     }\n \n     @Override\n-    public boolean hasSubscription(TopicSubscriber topicSubscriber) {\n+    public synchronized boolean hasSubscription(TopicSubscriber ts) {\n         if (null == origTopicSubscriber) {\n             return false;\n-        } else {\n-            return origTopicSubscriber.equals(topicSubscriber);\n         }\n+        return origTopicSubscriber.equals(ts);\n     }\n \n     @Override\n-    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n-                                       final Callback<ResponseBody> callback,\n-                                       final Object context) {\n-        // nothing to do just clear status\n-        // channel manager takes the responsibility to close the channel\n-        callback.operationFinished(context, (ResponseBody)null);\n+    protected synchronized boolean removeSubscription(TopicSubscriber ts, ActiveSubscriber ss) {\n+        if (null != origTopicSubscriber && !origTopicSubscriber.equals(ts)) {\n+            return false;\n+        }\n+        origTopicSubscriber = null;\n+        origActiveSubscriber = null;\n+        return super.removeSubscription(ts, ss);\n     }\n \n     @Override\n-    public synchronized  void consume(final TopicSubscriber topicSubscriber,\n-                                      final MessageSeqId messageSeqId) {\n-        PubSubRequest.Builder pubsubRequestBuilder =\n-            NetUtils.buildConsumeRequest(sChannelManager.nextTxnId(),\n-                                         topicSubscriber, messageSeqId);  \n-\n-        // For Consume requests, we will send them from the client in a fire and\n-        // forget manner. We are not expecting the server to send back an ack\n-        // response so no need to register this in the ResponseHandler. There\n-        // are no callbacks to invoke since this isn't a client initiated\n-        // action. Instead, just have a future listener that will log an error\n-        // message if there was a problem writing the consume request.\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Writing a Consume request to host: {} with messageSeqId: {} for {}\",\n-                         va(NetUtils.getHostFromChannel(subscribeChannel),\n-                            messageSeqId, topicSubscriber));\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        // If this was not a successful response to the Subscribe request, we\n+        // won't be using the Netty Channel created so just close it.\n+        if (!response.getStatusCode().equals(StatusCode.SUCCESS)) {\n+            HChannelImpl.getHChannelHandlerFromChannel(channel).closeExplicitly();\n+            channel.close();\n         }\n-        ChannelFuture future = subscribeChannel.write(pubsubRequestBuilder.build());\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (!future.isSuccess()) {\n-                    logger.error(\"Error writing a Consume request to host: {} with messageSeqId: {} for {}\",\n-                                 va(NetUtils.getHostFromChannel(subscribeChannel),\n-                                    messageSeqId, topicSubscriber));\n-                }\n-            }\n-        });\n+        super.handleResponse(response, pubSubData, channel);\n     }\n \n     @Override\n-    public void onChannelDisconnected(InetSocketAddress host,\n-                                      Channel channel) {\n-        if (origTopicSubscriber == null) {\n+    public void handleSubscribeMessage(PubSubResponse response) {\n+        Message message = response.getMessage();\n+        ActiveSubscriber ss = getActiveSubscriber();\n+        if (null == ss) {\n+            logger.error(\"No Subscriber is alive receiving its message {}.\",\n+                         MessageIdUtils.msgIdToReadableString(message.getMsgId()));\n             return;\n         }\n-        processSubscriptionEvent(SubscriptionEvent.TOPIC_MOVED, host, channel);\n+        ss.handleMessage(message);\n     }\n \n-    private void processSubscriptionEvent(final SubscriptionEvent event, InetSocketAddress host,\n-                                          final Channel channel) {\n-        if (SubscriptionEvent.TOPIC_MOVED != event &&\n-            SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED != event) {\n-            logger.warn(\"Ignore subscription event {} received from channel {}.\",\n-                        event, channel);\n-            return;\n-        }\n-        if (SubscriptionEvent.TOPIC_MOVED == event) {\n-            sChannelManager.clearHostForTopic(origTopicSubscriber.getTopic(), host);\n+    @Override\n+    protected void handleSuccessResponse(TopicSubscriber ts, ActiveSubscriber as,\n+                                         Channel channel) {\n+        synchronized (this) {\n+            origTopicSubscriber = ts;\n+            origActiveSubscriber = as;\n         }\n+        // Store the mapping for the TopicSubscriber to the Channel.\n+        // This is so we can control the starting and stopping of\n+        // message deliveries from the server on that Channel. Store\n+        // this only on a successful ack response from the server.\n+        sChannelManager.storeSubscriptionChannel(ts, channel);\n+    }\n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        // nothing to do just clear status\n+        // channel manager takes the responsibility to close the channel\n+        callback.operationFinished(context, (ResponseBody)null);\n+    }\n+\n+    @Override\n+    protected void resubscribeIfNecessary(final ActiveSubscriber ss,\n+                                          final SubscriptionEvent event) {\n+        final TopicSubscriber ts = ss.getTopicSubscriber();\n         // clear subscription status\n-        sChannelManager.asyncCloseSubscription(origTopicSubscriber, new Callback<ResponseBody>() {\n+        sChannelManager.asyncCloseSubscription(ts, new Callback<ResponseBody>() {\n \n             @Override\n             public void operationFinished(Object ctx, ResponseBody result) {\n@@ -531,39 +274,9 @@ public void operationFailed(Object ctx, PubSubException exception) {\n             }\n \n             private void finish() {\n-                // Since the connection to the server host that was responsible\n-                // for the topic died, we are not sure about the state of that\n-                // server. Resend the original subscribe request data to the default\n-                // server host/VIP. Also clear out all of the servers we've\n-                // contacted or attempted to from this request as we are starting a\n-                // \"fresh\" subscribe request.\n-                origSubData.clearServersList();\n-                // do resubscribe if the subscription enables it\n-                if (origSubData.options.getEnableResubscribe()) {\n-                    // Set a new type of VoidCallback for this async call. We need this\n-                    // hook so after the subscribe reconnect has completed, delivery for\n-                    // that topic subscriber should also be restarted (if it was that\n-                    // case before the channel disconnect).\n-                    final long retryWaitTime = cfg.getSubscribeReconnectRetryWaitTime();\n-                    SubscribeReconnectCallback reconnectCb =\n-                        new SubscribeReconnectCallback(origTopicSubscriber,\n-                                                       origSubData,\n-                                                       sChannelManager,\n-                                                       retryWaitTime);\n-                    origSubData.setCallback(reconnectCb);\n-                    origSubData.context = null;\n-                    // Clear the shouldClaim flag\n-                    origSubData.shouldClaim = false;\n-                    logger.debug(\"Reconnect {}'s subscription channel with origSubData {}\",\n-                                 origTopicSubscriber, origSubData);\n-                    sChannelManager.submitOpToDefaultServer(origSubData);\n-                } else {\n-                    logger.info(\"Subscription channel {} for ({}) is disconnected.\",\n-                                channel, origTopicSubscriber);\n-                    sChannelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n-                        origSubData.topic, origSubData.subscriberId, event);\n-                }\n+                SimpleSubscribeResponseHandler.super.resubscribeIfNecessary(ss, event);\n             }\n+\n         }, null);\n     }\n "},{"sha":"e6f4ecd088e1831ec93b7053e6c7b9b54baa7d4a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/366d393f2e58acdd5494da4ae60513c3ae5730c4/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/366d393f2e58acdd5494da4ae60513c3ae5730c4/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java?ref=366d393f2e58acdd5494da4ae60513c3ae5730c4","patch":"@@ -1,100 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.client.netty.impl.simple;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.client.data.TopicSubscriber;\n-import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n-import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n-import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n-import org.apache.hedwig.util.Callback;\n-import static org.apache.hedwig.util.VarArgs.va;\n-\n-/**\n- * This class is used when a Subscribe channel gets disconnected and we attempt\n- * to re-establish the connection. Once the connection to the server host for\n- * the topic is completed, we need to restart delivery for that topic if that\n- * was the case before the original channel got disconnected. This async\n- * callback will be the hook for this.\n- *\n- */\n-class SubscribeReconnectCallback implements Callback<ResponseBody> {\n-\n-    private static Logger logger = LoggerFactory.getLogger(SubscribeReconnectCallback.class);\n-\n-    // Private member variables\n-    private final TopicSubscriber origTopicSubscriber;\n-    private final PubSubData origSubData;\n-    private final SimpleHChannelManager channelManager;\n-    private final long retryWaitTime;\n-\n-    // Constructor\n-    SubscribeReconnectCallback(TopicSubscriber origTopicSubscriber,\n-                               PubSubData origSubData,\n-                               SimpleHChannelManager channelManager,\n-                               long retryWaitTime) {\n-        this.origTopicSubscriber = origTopicSubscriber;\n-        this.origSubData = origSubData;\n-        this.channelManager = channelManager;\n-        this.retryWaitTime = retryWaitTime;\n-    }\n-\n-    @Override\n-    public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n-        logger.debug(\"Subscribe reconnect succeeded for origSubData: {}\", origSubData);\n-        // Now we want to restart delivery for the subscription channel only\n-        // if delivery was started at the time the original subscribe channel\n-        // was disconnected.\n-        try {\n-            channelManager.restartDelivery(origTopicSubscriber);\n-        } catch (ClientNotSubscribedException e) {\n-            // This exception should never be thrown here but just in case,\n-            // log an error and just keep retrying the subscribe request.\n-            logger.error(\"Subscribe was successful but error starting delivery for {} : {}\",\n-                         va(origTopicSubscriber, e.getMessage()));\n-            retrySubscribeRequest();\n-        } catch (AlreadyStartDeliveryException asde) {\n-            // should not reach here\n-        }\n-    }\n-\n-    @Override\n-    public void operationFailed(Object ctx, PubSubException exception) {\n-        // If the subscribe reconnect fails, just keep retrying the subscribe\n-        // request. There isn't a way to flag to the application layer that\n-        // a topic subscription has failed. So instead, we'll just keep\n-        // retrying in the background until success.\n-        logger.error(\"Subscribe reconnect failed with error: \", exception);\n-        // we don't retry subscribe request is channel manager is closing\n-        // otherwise it might overflow the stack.\n-        if (!channelManager.isClosed()) {\n-            retrySubscribeRequest();\n-        }\n-    }\n-\n-    private void retrySubscribeRequest() {\n-        origSubData.clearServersList();\n-        logger.debug(\"Reconnect subscription channel for {} in {} ms later.\",\n-                     va(origTopicSubscriber, retryWaitTime));\n-        channelManager.submitOpAfterDelay(origSubData, retryWaitTime);\n-    }\n-}"}]}

