{"sha":"bdf3bfd631493d82688404dde35eed491ec946ad","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiZGYzYmZkNjMxNDkzZDgyNjg4NDA0ZGRlMzVlZWQ0OTFlYzk0NmFk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-03T09:55:01Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-03T09:55:01Z"},"message":"[REVERT] BOOKKEEPER-336 bookie readEntries is taking more time if the ensemble has failed bookie(s) Basic speculative functionality  in place\nAccidently committed this change, before approval. Reverting (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1416408 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4e4697d62ce1a8a9dab1db303abbed647bce5e29","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4e4697d62ce1a8a9dab1db303abbed647bce5e29"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/bdf3bfd631493d82688404dde35eed491ec946ad","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/bdf3bfd631493d82688404dde35eed491ec946ad","html_url":"https://github.com/apache/bookkeeper/commit/bdf3bfd631493d82688404dde35eed491ec946ad","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/bdf3bfd631493d82688404dde35eed491ec946ad/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"6a6d25e7e9a2c3cc4370799ec2529915929e5acc","url":"https://api.github.com/repos/apache/bookkeeper/commits/6a6d25e7e9a2c3cc4370799ec2529915929e5acc","html_url":"https://github.com/apache/bookkeeper/commit/6a6d25e7e9a2c3cc4370799ec2529915929e5acc"}],"stats":{"total":527,"additions":21,"deletions":506},"files":[{"sha":"3b46bf9a261e301516effa41c495930c2fb67403","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":19,"deletions":139,"changes":158,"blob_url":"https://github.com/apache/bookkeeper/blob/bdf3bfd631493d82688404dde35eed491ec946ad/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/bdf3bfd631493d82688404dde35eed491ec946ad/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=bdf3bfd631493d82688404dde35eed491ec946ad","patch":"@@ -21,19 +21,11 @@\n  *\n  */\n import java.net.InetSocketAddress;\n-import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.NoSuchElementException;\n import java.util.Queue;\n-import java.util.BitSet;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.List;\n-\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n import java.util.concurrent.atomic.AtomicBoolean;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n@@ -53,146 +45,67 @@\n class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     Logger LOG = LoggerFactory.getLogger(PendingReadOp.class);\n \n-    final int speculativeReadTimeout;\n-    Timer speculativeReadTimer;\n     Queue<LedgerEntryRequest> seq;\n-    Set<InetSocketAddress> heardFromHosts;\n     ReadCallback cb;\n     Object ctx;\n     LedgerHandle lh;\n     long numPendingEntries;\n     long startEntryId;\n     long endEntryId;\n \n-    class LedgerEntryRequest extends LedgerEntry {\n+    private class LedgerEntryRequest extends LedgerEntry {\n         int nextReplicaIndexToReadFrom = 0;\n         AtomicBoolean complete = new AtomicBoolean(false);\n \n         int firstError = BKException.Code.OK;\n \n         final ArrayList<InetSocketAddress> ensemble;\n-        final List<Integer> writeSet;\n-        final BitSet sentReplicas;\n-        final BitSet erroredReplicas;\n \n         LedgerEntryRequest(ArrayList<InetSocketAddress> ensemble, long lId, long eId) {\n             super(lId, eId);\n \n             this.ensemble = ensemble;\n-            this.writeSet = lh.distributionSchedule.getWriteSet(entryId);\n-            this.sentReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n-            this.erroredReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n-        }\n-\n-        private int getReplicaIndex(InetSocketAddress host) {\n-            int bookieIndex = ensemble.indexOf(host);\n-            if (bookieIndex == -1) {\n-                return -1;\n-            }\n-            return writeSet.indexOf(bookieIndex);\n-        }\n-\n-        private BitSet getSentToBitSet() {\n-            BitSet b = new BitSet(ensemble.size());\n-\n-            for (int i = 0; i < sentReplicas.length(); i++) {\n-                if (sentReplicas.get(i)) {\n-                    b.set(writeSet.get(i));\n-                }\n-            }\n-            return b;\n-        }\n-\n-        private BitSet getHeardFromBitSet(Set<InetSocketAddress> heardFromHosts) {\n-            BitSet b = new BitSet(ensemble.size());\n-            for (InetSocketAddress i : heardFromHosts) {\n-                int index = ensemble.indexOf(i);\n-                if (index != -1) {\n-                    b.set(index);\n-                }\n-            }\n-            return b;\n-        }\n-\n-        private boolean readsOutstanding() {\n-            return (sentReplicas.cardinality() - erroredReplicas.cardinality()) > 0;\n-        }\n-\n-        /**\n-         * Send to next replica speculatively, if required and possible.\n-         * This returns the host we may have sent to for unit testing.\n-         * @return host we sent to if we sent. null otherwise.\n-         */\n-        synchronized InetSocketAddress maybeSendSpeculativeRead(Set<InetSocketAddress> heardFromHosts) {\n-            if (nextReplicaIndexToReadFrom >= lh.getLedgerMetadata().getWriteQuorumSize()) {\n-                return null;\n-            }\n-\n-            BitSet sentTo = getSentToBitSet();\n-            BitSet heardFrom = getHeardFromBitSet(heardFromHosts);\n-            sentTo.and(heardFrom);\n-\n-            // only send another read, if we have had no response at all (even for other entries)\n-            // from any of the other bookies we have sent the request to\n-            if (sentTo.cardinality() == 0) {\n-                return sendNextRead();\n-            } else {\n-                return null;\n-            }\n         }\n \n-        synchronized InetSocketAddress sendNextRead() {\n+        void sendNextRead() {\n             if (nextReplicaIndexToReadFrom >= lh.metadata.getWriteQuorumSize()) {\n                 // we are done, the read has failed from all replicas, just fail the\n                 // read\n                 submitCallback(firstError);\n-                return null;\n+                return;\n             }\n \n-            int replica = nextReplicaIndexToReadFrom;\n             int bookieIndex = lh.distributionSchedule.getWriteSet(entryId).get(nextReplicaIndexToReadFrom);\n             nextReplicaIndexToReadFrom++;\n \n             try {\n-                InetSocketAddress to = ensemble.get(bookieIndex);\n-                sendReadTo(to, this);\n-                sentReplicas.set(replica);\n-                return to;\n+                sendReadTo(ensemble.get(bookieIndex), this);\n             } catch (InterruptedException ie) {\n                 LOG.error(\"Interrupted reading entry \" + this, ie);\n                 Thread.currentThread().interrupt();\n                 submitCallback(BKException.Code.ReadException);\n-                return null;\n             }\n         }\n \n-        synchronized void logErrorAndReattemptRead(InetSocketAddress host, String errMsg, int rc) {\n+        void logErrorAndReattemptRead(String errMsg, int rc) {\n             if (firstError == BKException.Code.OK) {\n                 firstError = rc;\n             }\n \n+            int bookieIndex = lh.distributionSchedule.getWriteSet(entryId).get(nextReplicaIndexToReadFrom - 1);\n             LOG.error(errMsg + \" while reading entry: \" + entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n-                      + host);\n-\n-            int replica = getReplicaIndex(host);\n-            if (replica == -1) {\n-                LOG.error(\"Received error from a host which is not in the ensemble {} {}.\", host, ensemble);\n-                return;\n-            }\n-            erroredReplicas.set(replica);\n+                      + ensemble.get(bookieIndex));\n \n-            if (!readsOutstanding()) {\n-                sendNextRead();\n-            }\n+            sendNextRead();\n         }\n \n         // return true if we managed to complete the entry\n-        boolean complete(InetSocketAddress host, final ChannelBuffer buffer) {\n+        boolean complete(final ChannelBuffer buffer) {\n             ChannelBufferInputStream is;\n             try {\n                 is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n             } catch (BKDigestMatchException e) {\n-                logErrorAndReattemptRead(host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n+                logErrorAndReattemptRead(\"Mac mismatch\", BKException.Code.DigestMatchException);\n                 return false;\n             }\n \n@@ -220,40 +133,23 @@ public String toString() {\n     }\n \n     PendingReadOp(LedgerHandle lh, long startEntryId, long endEntryId, ReadCallback cb, Object ctx) {\n-        seq = new ArrayBlockingQueue<LedgerEntryRequest>((int) ((endEntryId + 1) - startEntryId));\n+\n+        seq = new ArrayDeque<LedgerEntryRequest>((int) (endEntryId - startEntryId));\n         this.cb = cb;\n         this.ctx = ctx;\n         this.lh = lh;\n         this.startEntryId = startEntryId;\n         this.endEntryId = endEntryId;\n         numPendingEntries = endEntryId - startEntryId + 1;\n-        speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n-        if (speculativeReadTimeout > 0) {\n-            speculativeReadTimer = new Timer(\"SpeculativeRead-L\"+lh.getId()+\"-S\"+startEntryId+\"-E\"+endEntryId);\n-        } else {\n-            speculativeReadTimer = null;\n-        }\n-        heardFromHosts = new HashSet<InetSocketAddress>();\n     }\n \n     public void initiate() throws InterruptedException {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n \n         ArrayList<InetSocketAddress> ensemble = null;\n-\n-        if (speculativeReadTimer != null) {\n-            speculativeReadTimer.schedule(new TimerTask() {\n-                    public void run() {\n-                        for (LedgerEntryRequest r : seq) {\n-                            if (!r.isComplete()) {\n-                                r.maybeSendSpeculativeRead(heardFromHosts);\n-                            }\n-                        }\n-                    }\n-                }, speculativeReadTimeout, speculativeReadTimeout);\n-        }\n-\n         do {\n+            LOG.debug(\"Acquiring lock: {}\", i);\n+\n             if (i == nextEnsembleChange) {\n                 ensemble = lh.metadata.getEnsemble(i);\n                 nextEnsembleChange = lh.metadata.getNextEnsembleChange(i);\n@@ -266,27 +162,16 @@ public void run() {\n         } while (i <= endEntryId);\n     }\n \n-    private static class ReadContext {\n-        final InetSocketAddress to;\n-        final LedgerEntryRequest entry;\n-\n-        ReadContext(InetSocketAddress to, LedgerEntryRequest entry) {\n-            this.to = to;\n-            this.entry = entry;\n-        }\n-    }\n-\n     void sendReadTo(InetSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n         lh.opCounterSem.acquire();\n \n         lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId, \n-                                     this, new ReadContext(to, entry));\n+                                     this, entry);\n     }\n \n     @Override\n     public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n-        final ReadContext rctx = (ReadContext)ctx;\n-        final LedgerEntryRequest entry = rctx.entry;\n+        final LedgerEntryRequest entry = (LedgerEntryRequest) ctx;\n \n         lh.opCounterSem.release();\n \n@@ -305,13 +190,11 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n         }\n \n         if (rc != BKException.Code.OK) {\n-            entry.logErrorAndReattemptRead(rctx.to, \"Error: \" + BKException.getMessage(rc), rc);\n+            entry.logErrorAndReattemptRead(\"Error: \" + BKException.getMessage(rc), rc);\n             return;\n         }\n \n-        heardFromHosts.add(rctx.to);\n-\n-        if (entry.complete(rctx.to, buffer)) {\n+        if (entry.complete(buffer)) {\n             numPendingEntries--;\n         }\n \n@@ -324,9 +207,6 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n     }\n \n     private void submitCallback(int code) {\n-        if (speculativeReadTimer != null) {\n-            speculativeReadTimer.cancel();\n-        }\n         cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);\n     }\n     public boolean hasMoreElements() {"},{"sha":"8443c27b681e8a122a805465e5f537d754be1952","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/bdf3bfd631493d82688404dde35eed491ec946ad/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/bdf3bfd631493d82688404dde35eed491ec946ad/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=bdf3bfd631493d82688404dde35eed491ec946ad","patch":"@@ -43,7 +43,6 @@\n     // NIO Parameters\n     protected final static String CLIENT_TCP_NODELAY = \"clientTcpNoDelay\";\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n-    protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n \n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n@@ -276,39 +275,4 @@ public ClientConfiguration setNumWorkerThreads(int numThreads) {\n         setProperty(NUM_WORKER_THREADS, numThreads);\n         return this;\n     }\n-\n-    /**\n-     * Get the period of time after which a speculative entry read should be triggered.\n-     * A speculative entry read is sent to the next replica bookie before\n-     * an error or response has been received for the previous entry read request.\n-     *\n-     * A speculative entry read is only sent if we have not heard from the current\n-     * replica bookie during the entire read operation which may comprise of many entries.\n-     *\n-     * Speculative reads allow the client to avoid having to wait for the connect timeout\n-     * in the case that a bookie has failed. It induces higher load on the network and on\n-     * bookies. This should be taken into account before changing this configuration value.\n-     *\n-     * @see org.apache.bookkeeper.client.LedgerHandle#asyncReadEntries\n-     * @return the speculative read timeout in milliseconds. Default 2000.\n-     */\n-    public int getSpeculativeReadTimeout() {\n-        return getInt(SPECULATIVE_READ_TIMEOUT, 2000);\n-    }\n-\n-    /**\n-     * Set the speculative read timeout. A lower timeout will reduce read latency in the\n-     * case of a failed bookie, while increasing the load on bookies and the network.\n-     *\n-     * The default is 2000 milliseconds. A value of 0 will disable speculative reads\n-     * completely.\n-     *\n-     * @see #getSpeculativeReadTimeout()\n-     * @param timeout the timeout value, in milliseconds\n-     * @return client configuration\n-     */\n-    public ClientConfiguration setSpeculativeReadTimeout(int timeout) {\n-        setProperty(SPECULATIVE_READ_TIMEOUT, timeout);\n-        return this;\n-    }\n }"},{"sha":"887d97ee18ef2139678bcbf28b583ffd0f8dad9b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"removed","additions":0,"deletions":329,"changes":329,"blob_url":"https://github.com/apache/bookkeeper/blob/6a6d25e7e9a2c3cc4370799ec2529915929e5acc/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","raw_url":"https://github.com/apache/bookkeeper/raw/6a6d25e7e9a2c3cc4370799ec2529915929e5acc/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java?ref=6a6d25e7e9a2c3cc4370799ec2529915929e5acc","patch":"@@ -1,329 +0,0 @@\n-package org.apache.bookkeeper.client;\n-\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-import org.junit.*;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayList;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.Enumeration;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.CountDownLatch;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.test.BaseTestCase;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * This unit test tests ledger fencing;\n- *\n- */\n-public class TestSpeculativeRead extends BaseTestCase {\n-    static Logger LOG = LoggerFactory.getLogger(TestSpeculativeRead.class);\n-\n-    DigestType digestType;\n-    byte[] passwd = \"specPW\".getBytes();\n-\n-    public TestSpeculativeRead(DigestType digestType) {\n-        super(10);\n-        this.digestType = digestType;\n-    }\n-\n-    long getLedgerToRead(int ensemble, int quorum) throws Exception {\n-        byte[] data = \"Data for test\".getBytes();\n-        LedgerHandle l = bkc.createLedger(ensemble, quorum, digestType, passwd);\n-        for (int i = 0; i < 10; i++) {\n-            l.addEntry(data);\n-        }\n-        l.close();\n-\n-        return l.getId();\n-    }\n-\n-    BookKeeper createClient(int specTimeout) throws Exception {\n-        ClientConfiguration conf = new ClientConfiguration()\n-            .setSpeculativeReadTimeout(specTimeout)\n-            .setReadTimeout(30000);\n-        conf.setZkServers(zkUtil.getZooKeeperConnectString());\n-        return new BookKeeper(conf);\n-    }\n-\n-    class LatchCallback implements ReadCallback {\n-        CountDownLatch l = new CountDownLatch(1);\n-        boolean success = false;\n-        long startMillis = System.currentTimeMillis();\n-        long endMillis = Long.MAX_VALUE;\n-\n-        public void readComplete(int rc,\n-                                 LedgerHandle lh,\n-                                 Enumeration<LedgerEntry> seq,\n-                                 Object ctx) {\n-            endMillis = System.currentTimeMillis();\n-            LOG.debug(\"Got response {} {}\", rc, getDuration());\n-            success = rc == BKException.Code.OK;\n-            l.countDown();\n-        }\n-\n-        long getDuration() {\n-            return endMillis - startMillis;\n-        }\n-\n-        void expectSuccess(int milliseconds) throws Exception {\n-            assertTrue(l.await(milliseconds, TimeUnit.MILLISECONDS));\n-            assertTrue(success);\n-        }\n-\n-        void expectFail(int milliseconds) throws Exception {\n-            assertTrue(l.await(milliseconds, TimeUnit.MILLISECONDS));\n-            assertFalse(success);\n-        }\n-\n-        void expectTimeout(int milliseconds) throws Exception {\n-            assertFalse(l.await(milliseconds, TimeUnit.MILLISECONDS));\n-        }\n-    }\n-\n-    /**\n-     * Test basic speculative functionallity.\n-     * - Create 2 clients with read timeout disabled, one with spec\n-     *   read enabled, the other not.\n-     * - create ledger\n-     * - sleep second bookie in ensemble\n-     * - read first entry, both should find on first bookie.\n-     * - read second bookie, spec client should find on bookie three,\n-     *   non spec client should hang.\n-     */\n-    @Test\n-    public void testSpeculativeRead() throws Exception {\n-        long id = getLedgerToRead(3,2);\n-        BookKeeper bknospec = createClient(0); // disabled\n-        BookKeeper bkspec = createClient(2000);\n-\n-        LedgerHandle lnospec = bknospec.openLedger(id, digestType, passwd);\n-        LedgerHandle lspec = bkspec.openLedger(id, digestType, passwd);\n-\n-        // sleep second bookie\n-        CountDownLatch sleepLatch = new CountDownLatch(1);\n-        InetSocketAddress second = lnospec.getLedgerMetadata().getEnsembles().get(0L).get(1);\n-        sleepBookie(second, sleepLatch);\n-\n-        try {\n-            // read first entry, both go to first bookie, should be fine\n-            LatchCallback nospeccb = new LatchCallback();\n-            LatchCallback speccb = new LatchCallback();\n-            lnospec.asyncReadEntries(0, 0, nospeccb, null);\n-            lspec.asyncReadEntries(0, 0, speccb, null);\n-            nospeccb.expectSuccess(2000);\n-            speccb.expectSuccess(2000);\n-\n-            // read second entry, both look for second book, spec read client\n-            // tries third bookie, nonspec client hangs as read timeout is very long.\n-            nospeccb = new LatchCallback();\n-            speccb = new LatchCallback();\n-            lnospec.asyncReadEntries(1, 1, nospeccb, null);\n-            lspec.asyncReadEntries(1, 1, speccb, null);\n-            speccb.expectSuccess(4000);\n-            nospeccb.expectTimeout(4000);\n-        } finally {\n-            sleepLatch.countDown();\n-            lspec.close();\n-            lnospec.close();\n-            bkspec.close();\n-            bknospec.close();\n-        }\n-    }\n-\n-    /**\n-     * Test that if more than one replica is down, we can still read, as long as the quorum\n-     * size is larger than the number of down replicas.\n-     */\n-    @Test\n-    public void testSpeculativeReadMultipleReplicasDown() throws Exception {\n-        long id = getLedgerToRead(5,5);\n-        int timeout = 5000;\n-        BookKeeper bkspec = createClient(timeout);\n-\n-        LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n-\n-        // sleep bookie 1, 2 & 4\n-        CountDownLatch sleepLatch = new CountDownLatch(1);\n-        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(1), sleepLatch);\n-        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(2), sleepLatch);\n-        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(4), sleepLatch);\n-\n-        try {\n-            // read first entry, should complete faster than timeout\n-            // as bookie 0 has the entry\n-            LatchCallback latch0 = new LatchCallback();\n-            l.asyncReadEntries(0, 0, latch0, null);\n-            latch0.expectSuccess(timeout/2);\n-\n-            // second should have to hit two timeouts (bookie 1 & 2)\n-            // bookie 3 has the entry\n-            LatchCallback latch1 = new LatchCallback();\n-            l.asyncReadEntries(1, 1, latch1, null);\n-            latch1.expectTimeout(timeout);\n-            latch1.expectSuccess(timeout*2);\n-            assertTrue(\"should have taken longer than two timeouts, but less than 3\",\n-                       latch1.getDuration() > timeout*2\n-                       && latch1.getDuration() < timeout*3);\n-\n-            // third should have to hit one timeouts (bookie 2)\n-            // bookie 3 has the entry\n-            LatchCallback latch2 = new LatchCallback();\n-            l.asyncReadEntries(2, 2, latch2, null);\n-            latch2.expectTimeout(timeout/2);\n-            latch2.expectSuccess(timeout);\n-            assertTrue(\"should have taken longer than one timeout, but less than 2\",\n-                       latch2.getDuration() > timeout \n-                       && latch2.getDuration() < timeout*2);\n-\n-            // fourth should have no timeout\n-            // bookie 3 has the entry\n-            LatchCallback latch3 = new LatchCallback();\n-            l.asyncReadEntries(3, 3, latch3, null);\n-            latch3.expectSuccess(timeout/2);\n-\n-            // fifth should hit one timeout, (bookie 4)\n-            // bookie 0 has the entry\n-            LatchCallback latch4 = new LatchCallback();\n-            l.asyncReadEntries(4, 4, latch4, null);\n-            latch4.expectTimeout(timeout/2);\n-            latch4.expectSuccess(timeout);\n-            assertTrue(\"should have taken longer than one timeout, but less than 2\",\n-                       latch4.getDuration() > timeout\n-                       && latch4.getDuration() < timeout*2);\n-\n-        } finally {\n-            sleepLatch.countDown();\n-            l.close();\n-            bkspec.close();\n-        }\n-    }\n-\n-    /**\n-     * Test that if after a speculative read is kicked off, the original read completes\n-     * nothing bad happens.\n-     */\n-    @Test\n-    public void testSpeculativeReadFirstReadCompleteIsOk() throws Exception {\n-        long id = getLedgerToRead(2,2);\n-        int timeout = 1000;\n-        BookKeeper bkspec = createClient(timeout);\n-\n-        LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n-\n-        // sleep bookies\n-        CountDownLatch sleepLatch0 = new CountDownLatch(1);\n-        CountDownLatch sleepLatch1 = new CountDownLatch(1);\n-        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(0), sleepLatch0);\n-        sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(1), sleepLatch1);\n-\n-        try {\n-            // read goes to first bookie, spec read timeout occurs,\n-            // goes to second\n-            LatchCallback latch0 = new LatchCallback();\n-            l.asyncReadEntries(0, 0, latch0, null);\n-            latch0.expectTimeout(timeout);\n-\n-            // wake up first bookie\n-            sleepLatch0.countDown();\n-            latch0.expectSuccess(timeout/2);\n-\n-            sleepLatch1.countDown();\n-\n-            // check we can read next entry without issue\n-            LatchCallback latch1 = new LatchCallback();\n-            l.asyncReadEntries(1, 1, latch1, null);\n-            latch1.expectSuccess(timeout/2);\n-\n-        } finally {\n-            sleepLatch0.countDown();\n-            sleepLatch1.countDown();\n-            l.close();\n-            bkspec.close();\n-        }\n-    }\n-\n-    /**\n-     * Unit test for the speculative read scheduling method\n-     */\n-    @Test\n-    public void testSpeculativeReadScheduling() throws Exception {\n-        long id = getLedgerToRead(3,2);\n-        int timeout = 1000;\n-        BookKeeper bkspec = createClient(timeout);\n-\n-        LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n-\n-        ArrayList<InetSocketAddress> ensemble = l.getLedgerMetadata().getEnsembles().get(0L);\n-        Set<InetSocketAddress> allHosts = new HashSet(ensemble);\n-        Set<InetSocketAddress> noHost = new HashSet();\n-        Set<InetSocketAddress> secondHostOnly = new HashSet();\n-        secondHostOnly.add(ensemble.get(1));\n-        try {\n-            LatchCallback latch0 = new LatchCallback();\n-            PendingReadOp op = new PendingReadOp(l, 0, 5, latch0, null);\n-\n-            // if we've already heard from all hosts,\n-            // we only send the initial read\n-            PendingReadOp.LedgerEntryRequest req0\n-                = op.new LedgerEntryRequest(ensemble, l.getId(), 0);\n-            assertTrue(\"Should have sent to first\",\n-                       req0.maybeSendSpeculativeRead(allHosts).equals(ensemble.get(0)));\n-            assertNull(\"Should not have sent another\",\n-                       req0.maybeSendSpeculativeRead(allHosts));\n-\n-            // if we have heard from some hosts, but not one we have sent to\n-            // send again\n-            PendingReadOp.LedgerEntryRequest req2\n-                = op.new LedgerEntryRequest(ensemble, l.getId(), 2);\n-            assertTrue(\"Should have sent to third\",\n-                       req2.maybeSendSpeculativeRead(noHost).equals(ensemble.get(2)));\n-            assertTrue(\"Should have sent to first\",\n-                       req2.maybeSendSpeculativeRead(secondHostOnly).equals(ensemble.get(0)));\n-\n-            // if we have heard from some hosts, which includes one we sent to\n-            // do not read again\n-            PendingReadOp.LedgerEntryRequest req4\n-                = op.new LedgerEntryRequest(ensemble, l.getId(), 4);\n-            assertTrue(\"Should have sent to second\",\n-                       req4.maybeSendSpeculativeRead(noHost).equals(ensemble.get(1)));\n-            assertNull(\"Should not have sent another\",\n-                       req4.maybeSendSpeculativeRead(secondHostOnly));\n-        } finally {\n-            // wait for all ops to complete\n-            l.opCounterSem.acquire(bkspec.getConf().getThrottleValue());\n-\n-            l.close();\n-            bkspec.close();\n-        }\n-    }\n-}\n\\ No newline at end of file"},{"sha":"12e4afc8869b57dfcc3034ceb00308e437aed27b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/bdf3bfd631493d82688404dde35eed491ec946ad/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/bdf3bfd631493d82688404dde35eed491ec946ad/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=bdf3bfd631493d82688404dde35eed491ec946ad","patch":"@@ -234,7 +234,7 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n     public CountDownLatch sleepBookie(InetSocketAddress addr, final int seconds)\n             throws InterruptedException, IOException {\n         final CountDownLatch l = new CountDownLatch(1);\n-        final String name = \"NIOServerFactory-\" + addr.getPort();\n+        final String name = \"BookieJournal-\" + addr.getPort();\n         Thread[] allthreads = new Thread[Thread.activeCount()];\n         Thread.enumerate(allthreads);\n         for (final Thread t : allthreads) {\n@@ -271,7 +271,7 @@ public void run() {\n      */\n     public void sleepBookie(InetSocketAddress addr, final CountDownLatch l)\n             throws InterruptedException, IOException {\n-        final String name = \"NIOServerFactory-\" + addr.getPort();\n+        final String name = \"BookieJournal-\" + addr.getPort();\n         Thread[] allthreads = new Thread[Thread.activeCount()];\n         Thread.enumerate(allthreads);\n         for (final Thread t : allthreads) {"}]}

