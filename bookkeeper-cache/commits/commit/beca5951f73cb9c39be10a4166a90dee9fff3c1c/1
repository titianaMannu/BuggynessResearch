{"sha":"beca5951f73cb9c39be10a4166a90dee9fff3c1c","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiZWNhNTk1MWY3M2NiOWMzOWJlMTBhNDE2NmE5MGRlZTlmZmYzYzFj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T14:54:29Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T14:54:29Z"},"message":"BOOKKEEPER-165: Add versioning support for journal files (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241922 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"496c20256ef3a2ab3aef4771bac079d703d219f7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/496c20256ef3a2ab3aef4771bac079d703d219f7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c","html_url":"https://github.com/apache/bookkeeper/commit/beca5951f73cb9c39be10a4166a90dee9fff3c1c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","url":"https://api.github.com/repos/apache/bookkeeper/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","html_url":"https://github.com/apache/bookkeeper/commit/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3"}],"stats":{"total":634,"additions":597,"deletions":37},"files":[{"sha":"afcb108f35473476788fe8d88b101aa590553f21","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/beca5951f73cb9c39be10a4166a90dee9fff3c1c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/beca5951f73cb9c39be10a4166a90dee9fff3c1c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=beca5951f73cb9c39be10a4166a90dee9fff3c1c","patch":"@@ -47,6 +47,8 @@ Trunk (unreleased changes)\n \n \tBOOKKEEPER-157:\tFor small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n \n+        BOOKKEEPER-165: Add versioning support for journal files (ivank)\n+\n       hedwig-server/\n \n         BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)"},{"sha":"8abe87a207409b514c0a6453291d1ff1b4803c25","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":13,"deletions":36,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=beca5951f73cb9c39be10a4166a90dee9fff3c1c","patch":"@@ -302,12 +302,12 @@ public boolean accept(long journalId) {\n         ByteBuffer lenBuff = ByteBuffer.allocate(4);\n         ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n         for(Long id: logs) {\n-            FileChannel recLog ;\n+            JournalChannel recLog;\n             if(id == markedLogId) {\n-              long markedLogPosition = lastLogMark.txnLogPosition;\n-              recLog = openChannel(id, markedLogPosition);\n+                long markedLogPosition = lastLogMark.txnLogPosition;\n+                recLog = new JournalChannel(journalDirectory, id, markedLogPosition);\n             } else {\n-              recLog = openChannel(id);\n+                recLog = new JournalChannel(journalDirectory, id);\n             }\n \n             while(true) {\n@@ -344,6 +344,7 @@ public boolean accept(long journalId) {\n                     putHandle(handle);\n                 }\n             }\n+            recLog.close();\n         }\n         // pass zookeeper instance here\n         // since GarbageCollector thread should only start after journal\n@@ -602,7 +603,7 @@ private void createDirectoryLayoutVersionFile(File dir) throws IOException {\n         }\n     }\n \n-    private static int fullRead(FileChannel fc, ByteBuffer bb) throws IOException {\n+    private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException {\n         int total = 0;\n         while(bb.remaining() > 0) {\n             int rc = fc.read(bb);\n@@ -712,10 +713,6 @@ private LedgerDescriptor createHandle(long ledgerId, boolean readOnly) throws IO\n \n     LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n \n-    public final static long preAllocSize = 4*1024*1024;\n-\n-    public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n-\n     class LastLogMark {\n         long txnLogId;\n         long txnLogPosition;\n@@ -825,7 +822,7 @@ public void run() {\n         ByteBuffer lenBuff = ByteBuffer.allocate(4);\n         try {\n             long logId = 0;\n-            FileChannel logFile = null;\n+            JournalChannel logFile = null;\n             BufferedChannel bc = null;\n             long nextPrealloc = 0;\n             long lastFlushPosition = 0;\n@@ -835,12 +832,10 @@ public void run() {\n                 // new journal file to write\n                 if (null == logFile) {\n                     logId = System.currentTimeMillis();\n-                    logFile = openChannel(logId);\n-                    bc = new BufferedChannel(logFile, 65536);\n-                    zeros.clear();\n-                    nextPrealloc = preAllocSize;\n+                    logFile = new JournalChannel(journalDirectory, logId);\n+                    bc = logFile.getBufferedChannel();\n+\n                     lastFlushPosition = 0;\n-                    logFile.write(zeros, nextPrealloc);\n                 }\n \n                 if (qe == null) {\n@@ -884,11 +879,9 @@ public void run() {\n                 // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n                 bc.write(lenBuff);\n                 bc.write(qe.entry);\n-                if (bc.position() > nextPrealloc) {\n-                    nextPrealloc = (logFile.size() / preAllocSize + 1) * preAllocSize;\n-                    zeros.clear();\n-                    logFile.write(zeros, nextPrealloc);\n-                }\n+\n+                logFile.preAllocIfNeeded();\n+\n                 toFlush.add(qe);\n                 qe = null;\n             }\n@@ -897,22 +890,6 @@ public void run() {\n         }\n     }\n \n-    private FileChannel openChannel(long logId) throws FileNotFoundException {\n-        return openChannel(logId, 0);\n-    }\n-\n-    private FileChannel openChannel(long logId, long position) throws FileNotFoundException {\n-        FileChannel logFile = new RandomAccessFile(new File(journalDirectory,\n-                Long.toHexString(logId) + \".txn\"),\n-                \"rw\").getChannel();\n-        try {\n-            logFile.position(position);\n-        } catch (IOException e) {\n-            LOG.error(\"Bookie journal file can seek to position :\", e);\n-        }\n-        return logFile;\n-    }\n-\n     public synchronized void shutdown() throws InterruptedException {\n         if (!running) { // avoid shutdown twice\n             return;"},{"sha":"10ecac777ce868d1ab333e6c9f0347af92ae3376","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","status":"added","additions":157,"deletions":0,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java?ref=beca5951f73cb9c39be10a4166a90dee9fff3c1c","patch":"@@ -0,0 +1,157 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.util.Arrays;\n+\n+import java.io.File;\n+import java.io.RandomAccessFile;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.ByteBuffer;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Simple wrapper around FileChannel to add versioning\n+ * information to the file.\n+ */\n+class JournalChannel {\n+    static Logger LOG = LoggerFactory.getLogger(JournalChannel.class);\n+\n+    final FileChannel fc;\n+    final BufferedChannel bc;\n+    final int formatVersion;\n+    long nextPrealloc = 0;\n+\n+    final byte[] MAGIC_WORD = \"BKLG\".getBytes();\n+\n+    private final static int START_OF_FILE = -12345;\n+\n+    int HEADER_SIZE = 8; // 4byte magic word, 4 byte version\n+    int MIN_COMPAT_JOURNAL_FORMAT_VERSION = 1;\n+    int CURRENT_JOURNAL_FORMAT_VERSION = 2;\n+\n+    public final static long preAllocSize = 4*1024*1024;\n+    public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n+\n+    JournalChannel(File journalDirectory, long logId) throws IOException {\n+        this(journalDirectory, logId, START_OF_FILE);\n+    }\n+\n+    JournalChannel(File journalDirectory, long logId, long position) throws IOException {\n+        File fn = new File(journalDirectory, Long.toHexString(logId) + \".txn\");\n+\n+        LOG.info(\"Opening journal {}\", fn);\n+        if (!fn.exists()) { // new file, write version\n+            fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+            formatVersion = CURRENT_JOURNAL_FORMAT_VERSION;\n+\n+            ByteBuffer bb = ByteBuffer.allocate(HEADER_SIZE);\n+            bb.put(MAGIC_WORD);\n+            bb.putInt(formatVersion);\n+            bb.flip();\n+            fc.write(bb);\n+            fc.force(true);\n+\n+            bc = new BufferedChannel(fc, 65536);\n+\n+            nextPrealloc = preAllocSize;\n+            fc.write(zeros, nextPrealloc);\n+        } else {  // open an existing file\n+            fc = new RandomAccessFile(fn, \"r\").getChannel();\n+            bc = null; // readonly\n+\n+            ByteBuffer bb = ByteBuffer.allocate(HEADER_SIZE);\n+            int c = fc.read(bb);\n+            bb.flip();\n+\n+            if (c == HEADER_SIZE) {\n+                byte[] first4 = new byte[4];\n+                bb.get(first4);\n+\n+                if (Arrays.equals(first4, MAGIC_WORD)) {\n+                    formatVersion = bb.getInt();\n+                } else {\n+                    // pre magic word journal, reset to 0;\n+                    formatVersion = 1;\n+                }\n+            } else {\n+                // no header, must be old version\n+                formatVersion = 1;\n+            }\n+\n+            if (formatVersion < MIN_COMPAT_JOURNAL_FORMAT_VERSION\n+                || formatVersion > CURRENT_JOURNAL_FORMAT_VERSION) {\n+                String err = String.format(\"Invalid journal version, unable to read.\"\n+                        + \" Expected between (%d) and (%d), got (%d)\",\n+                        MIN_COMPAT_JOURNAL_FORMAT_VERSION, CURRENT_JOURNAL_FORMAT_VERSION,\n+                        formatVersion);\n+                LOG.error(err);\n+                throw new IOException(err);\n+            }\n+\n+            try {\n+                if (position == START_OF_FILE) {\n+                    if (formatVersion >= 2) {\n+                        fc.position(HEADER_SIZE);\n+                    } else {\n+                        fc.position(0);\n+                    }\n+                } else {\n+                    fc.position(position);\n+                }\n+            } catch (IOException e) {\n+                LOG.error(\"Bookie journal file can seek to position :\", e);\n+            }\n+        }\n+    }\n+\n+    int getFormatVersion() {\n+        return formatVersion;\n+    }\n+\n+    BufferedChannel getBufferedChannel() throws IOException {\n+        if (bc == null) {\n+            throw new IOException(\"Read only journal channel\");\n+        }\n+        return bc;\n+    }\n+\n+    void preAllocIfNeeded() throws IOException {\n+        if (bc.position() > nextPrealloc) {\n+            nextPrealloc = ((fc.size() + HEADER_SIZE) / preAllocSize + 1) * preAllocSize;\n+            zeros.clear();\n+            fc.write(zeros, nextPrealloc);\n+        }\n+    }\n+\n+    int read(ByteBuffer dst)\n+            throws IOException {\n+        return fc.read(dst);\n+    }\n+\n+    void close() throws IOException {\n+        fc.close();\n+    }\n+}\n\\ No newline at end of file"},{"sha":"771c0ba28dae43563488e6568cfc8a654e7f45f5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=beca5951f73cb9c39be10a4166a90dee9fff3c1c","patch":"@@ -197,7 +197,7 @@ public long getEntryOffset(long ledger, long entry) throws IOException {\n         }\n     }\n \n-    static final private String getLedgerName(long ledgerId) {\n+    static final String getLedgerName(long ledgerId) {\n         int parent = (int) (ledgerId & 0xff);\n         int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n         StringBuilder sb = new StringBuilder();"},{"sha":"ae637103ac090dfda11b1365ad1c96a87613d21d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","status":"added","additions":394,"deletions":0,"changes":394,"blob_url":"https://github.com/apache/bookkeeper/blob/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java?ref=beca5951f73cb9c39be10a4166a90dee9fff3c1c","patch":"@@ -0,0 +1,394 @@\n+package org.apache.bookkeeper.bookie;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.io.File;\n+import java.io.RandomAccessFile;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.Arrays;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeperTestClient;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.ClientUtil;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public class BookieJournalTest {\n+    static Logger LOG = LoggerFactory.getLogger(BookieJournalTest.class);\n+\n+    private void writeIndexFileForLedger(File indexDir, long ledgerId,\n+                                         byte[] masterKey)\n+            throws Exception {\n+        File fn = new File(indexDir, LedgerCache.getLedgerName(ledgerId));\n+        fn.getParentFile().mkdirs();\n+        FileInfo fi = new FileInfo(fn);\n+        fi.writeMasterKey(masterKey);\n+        fi.close();\n+    }\n+\n+    private void writeJunkJournal(File journalDir) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        File fn = new File(journalDir, Long.toHexString(logId) + \".txn\");\n+\n+        FileChannel fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+\n+        ByteBuffer zeros = ByteBuffer.allocate(512);\n+        fc.write(zeros, 4*1024*1024);\n+        fc.position(0);\n+\n+        for (int i = 1; i <= 10; i++) {\n+            fc.write(ByteBuffer.wrap(\"JunkJunkJunk\".getBytes()));\n+        }\n+    }\n+\n+    private void writePreV2Journal(File journalDir, int numEntries) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        File fn = new File(journalDir, Long.toHexString(logId) + \".txn\");\n+\n+        FileChannel fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+\n+        ByteBuffer zeros = ByteBuffer.allocate(512);\n+        fc.write(zeros, 4*1024*1024);\n+        fc.position(0);\n+\n+        byte[] data = \"JournalTestData\".getBytes();\n+        long lastConfirmed = -1;\n+        for (int i = 1; i <= numEntries; i++) {\n+            ByteBuffer packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+\n+            fc.write(lenBuff);\n+            fc.write(packet);\n+        }\n+    }\n+\n+    private JournalChannel writePostV2Journal(File journalDir, int numEntries) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        JournalChannel jc = new JournalChannel(journalDir, logId);\n+\n+        BufferedChannel bc = jc.getBufferedChannel();\n+\n+        byte[] data = new byte[1024];\n+        Arrays.fill(data, (byte)'X');\n+        long lastConfirmed = -1;\n+        for (int i = 1; i <= numEntries; i++) {\n+            ByteBuffer packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+\n+            bc.write(lenBuff);\n+            bc.write(packet);\n+        }\n+        bc.flush(true);\n+\n+        return jc;\n+    }\n+\n+    /**\n+     * test that we can open a journal written without the magic\n+     * word at the start. This is for versions of bookkeeper before\n+     * the magic word was introduced\n+     */\n+    @Test\n+    public void testPreV2Journal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        writePreV2Journal(journalDir, 100);\n+        writeIndexFileForLedger(ledgerDir, 1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+\n+        b.readEntry(1, 100);\n+        try {\n+            b.readEntry(1, 101);\n+            fail(\"Shouldn't have found entry 101\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that if the journal is all journal, we can not\n+     * start the bookie. An admin should look to see what has\n+     * happened in this case\n+     */\n+    @Test\n+    public void testAllJunkJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        writeJunkJournal(journalDir);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+        Bookie b = null;\n+        try {\n+            b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start without admin\");\n+        } catch (Throwable t) {\n+            // correct behaviour\n+        } finally {\n+            if (b != null) {\n+                b.shutdown();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test that we can start with an empty journal.\n+     * This can happen if the bookie crashes between creating the\n+     * journal and writing the magic word. It could also happen before\n+     * the magic word existed, if the bookie started but nothing was\n+     * ever written.\n+     */\n+    @Test\n+    public void testEmptyJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        writePreV2Journal(journalDir, 0);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that a journal can load if only the magic word and\n+     * version are there.\n+     */\n+    @Test\n+    public void testHeaderOnlyJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        writePostV2Journal(journalDir, 0);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that if a journal has junk at the end, it does not load.\n+     * If the journal is corrupt like this, admin intervention is needed\n+     */\n+    @Test\n+    public void testJunkEndedJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        JournalChannel jc = writePostV2Journal(journalDir, 0);\n+        jc.getBufferedChannel().write(ByteBuffer.wrap(\"JunkJunkJunk\".getBytes()));\n+        jc.getBufferedChannel().flush(true);\n+\n+        writeIndexFileForLedger(ledgerDir, 1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = null;\n+        try {\n+            b = new Bookie(conf);\n+        } catch (Throwable t) {\n+            // correct behaviour\n+        } finally {\n+            if (b != null) {\n+                b.shutdown();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test that if the bookie crashes while writing the length\n+     * of an entry, that we can recover.\n+     *\n+     * This is currently not the case, which is bad as recovery\n+     * should be fine here. The bookie has crashed while writing\n+     * but so the client has not be notified of success.\n+     */\n+    //    @Test TODO, fix and reenable\n+    public void testTruncatedInLenJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        JournalChannel jc = writePostV2Journal(journalDir, 100);\n+        ByteBuffer zeros = ByteBuffer.allocate(2048);\n+\n+        jc.fc.position(jc.getBufferedChannel().position() - 0x429);\n+        jc.fc.write(zeros);\n+        jc.fc.force(false);\n+\n+        writeIndexFileForLedger(ledgerDir, 1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+\n+        b.readEntry(1, 99);\n+\n+        try {\n+            b.readEntry(1, 100);\n+            fail(\"Shouldn't have found entry 100\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that if the bookie crashes in the middle of writing\n+     * the actual entry it can recover.\n+     * In this case the entry will be available, but it will corrupt.\n+     * This is ok, as the client will disregard the entry after looking\n+     * at its checksum.\n+     */\n+    @Test\n+    public void testTruncatedInEntryJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+\n+        JournalChannel jc = writePostV2Journal(journalDir, 100);\n+        ByteBuffer zeros = ByteBuffer.allocate(2048);\n+\n+        jc.fc.position(jc.getBufferedChannel().position() - 0x300);\n+        jc.fc.write(zeros);\n+        jc.fc.force(false);\n+\n+        writeIndexFileForLedger(ledgerDir, 1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.readEntry(1, 99);\n+\n+        // still able to read last entry, but it's junk\n+        ByteBuffer buf = b.readEntry(1, 100);\n+        assertEquals(\"Ledger Id is wrong\", buf.getLong(), 1);\n+        assertEquals(\"Entry Id is wrong\", buf.getLong(), 100);\n+        assertEquals(\"Last confirmed is wrong\", buf.getLong(), 99);\n+        assertEquals(\"Length is wrong\", buf.getLong(), 100*1024);\n+        buf.getLong(); // skip checksum\n+        boolean allX = true;\n+        for (int i = 0; i < 1024; i++) {\n+            byte x = buf.get();\n+            allX = allX && x == (byte)'X';\n+        }\n+        assertFalse(\"Some of buffer should have been zeroed\", allX);\n+\n+        try {\n+            b.readEntry(1, 101);\n+            fail(\"Shouldn't have found entry 101\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+\n+        b.shutdown();\n+    }\n+\n+}"},{"sha":"d4b62880f180f0059f91304fdba51b0ed2f6dbd5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/beca5951f73cb9c39be10a4166a90dee9fff3c1c/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java?ref=beca5951f73cb9c39be10a4166a90dee9fff3c1c","patch":"@@ -0,0 +1,30 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+public class ClientUtil {\n+    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed, \n+                                        long length, byte[] data) {\n+        CRC32DigestManager dm = new CRC32DigestManager(ledgerId);\n+        return dm.computeDigestAndPackageForSending(entryId, lastAddConfirmed, length,\n+                                                    data, 0, data.length);\n+    }\n+}\n\\ No newline at end of file"}]}

