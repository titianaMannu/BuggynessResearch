{"sha":"bf4a4d6a07f9d615752054c6743035cebd86716e","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiZjRhNGQ2YTA3ZjlkNjE1NzUyMDU0YzY3NDMwMzVjZWJkODY3MTZl","commit":{"author":{"name":"eolivelli","email":"eolivelli@gmail.com","date":"2016-10-13T07:27:18Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-10-13T07:27:18Z"},"message":"BOOKKEEPER-924: addEntry() is susceptible to spurious wakeups\n\nUse Java8 CompletableFuture instead of SyncCounter\n\nAuthor: eolivelli <eolivelli@gmail.com>\n\nReviewers: sijie@apache.org <sijie@apache.org>\n\nCloses #60 from eolivelli/BOOKKEEPER-924 and squashes the following commits:\n\n61e6b1a [eolivelli] BOOKKEEPER-924 addEntry() is susceptible to spurious wakeups\n7d7eaf7 [eolivelli] BOOKKEEPER-924 addEntry() is susceptible to spurious wakeups\nf865610 [eolivelli] BOOKKEEPER-924 addEntry() is susceptible to spurious wakeups\ne75569a [eolivelli] BOOKKEEPER-924 addEntry() is susceptible to spurious wakeups\ncdd32c3 [eolivelli] BOOKKEEPER-924 addEntry() is susceptible to spurious wakeups","tree":{"sha":"bf823000cc2827958beba614671f89cb1de7c456","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/bf823000cc2827958beba614671f89cb1de7c456"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/bf4a4d6a07f9d615752054c6743035cebd86716e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/bf4a4d6a07f9d615752054c6743035cebd86716e","html_url":"https://github.com/apache/bookkeeper/commit/bf4a4d6a07f9d615752054c6743035cebd86716e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/bf4a4d6a07f9d615752054c6743035cebd86716e/comments","author":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"bbd1eb8d8560b03834175fbd996b85237df09f5c","url":"https://api.github.com/repos/apache/bookkeeper/commits/bbd1eb8d8560b03834175fbd996b85237df09f5c","html_url":"https://github.com/apache/bookkeeper/commit/bbd1eb8d8560b03834175fbd996b85237df09f5c"}],"stats":{"total":292,"additions":139,"deletions":153},"files":[{"sha":"08c24b0f0298f7fda45c436b4d7a15f691a6974b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":25,"deletions":66,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=bf4a4d6a07f9d615752054c6743035cebd86716e","patch":"@@ -65,6 +65,8 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n \n /**\n  * BookKeeper client. We assume there is one single writer to a ledger at any\n@@ -616,27 +618,20 @@ public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorum\n     public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorumSize,\n                                      DigestType digestType, byte passwd[], final Map<String, byte[]> customMetadata)\n             throws InterruptedException, BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n+\n         /*\n          * Calls asynchronous version\n          */\n         asyncCreateLedger(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd,\n                           new SyncCreateCallback(), counter, customMetadata);\n \n-        /*\n-         * Wait\n-         */\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            LOG.error(\"Error while creating ledger : {}\", counter.getrc());\n-            throw BKException.create(counter.getrc());\n-        } else if (counter.getLh() == null) {\n+        LedgerHandle lh = SynchCallbackUtils.waitForResult(counter);\n+        if (lh == null) {\n             LOG.error(\"Unexpected condition : no ledger handle returned for a success ledger creation\");\n             throw BKException.create(BKException.Code.UnexpectedConditionException);\n         }\n-\n-        return counter.getLh();\n+        return lh;\n     }\n \n     /**\n@@ -682,27 +677,20 @@ public LedgerHandle createLedgerAdv(int ensSize, int writeQuorumSize, int ackQuo\n     public LedgerHandle createLedgerAdv(int ensSize, int writeQuorumSize, int ackQuorumSize,\n                                         DigestType digestType, byte passwd[], final Map<String, byte[]> customMetadata)\n             throws InterruptedException, BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n+\n         /*\n          * Calls asynchronous version\n          */\n         asyncCreateLedgerAdv(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd,\n                              new SyncCreateCallback(), counter, customMetadata);\n \n-        /*\n-         * Wait\n-         */\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            LOG.error(\"Error while creating ledger : {}\", counter.getrc());\n-            throw BKException.create(counter.getrc());\n-        } else if (counter.getLh() == null) {\n+        LedgerHandle lh = SynchCallbackUtils.waitForResult(counter);\n+        if (lh == null) {\n             LOG.error(\"Unexpected condition : no ledger handle returned for a success ledger creation\");\n             throw BKException.create(BKException.Code.UnexpectedConditionException);\n         }\n-\n-        return counter.getLh();\n+        return lh;\n     }\n \n     /**\n@@ -855,22 +843,14 @@ public void asyncOpenLedgerNoRecovery(final long lId, final DigestType digestTyp\n \n     public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n             throws BKException, InterruptedException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n \n         /*\n          * Calls async open ledger\n          */\n         asyncOpenLedger(lId, digestType, passwd, new SyncOpenCallback(), counter);\n \n-        /*\n-         * Wait\n-         */\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK)\n-            throw BKException.create(counter.getrc());\n-\n-        return counter.getLh();\n+        return SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -890,23 +870,15 @@ public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n \n     public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte passwd[])\n             throws BKException, InterruptedException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n \n         /*\n          * Calls async open ledger\n          */\n         asyncOpenLedgerNoRecovery(lId, digestType, passwd,\n                                   new SyncOpenCallback(), counter);\n \n-        /*\n-         * Wait\n-         */\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK)\n-            throw BKException.create(counter.getrc());\n-\n-        return counter.getLh();\n+        return SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -944,16 +916,11 @@ public void asyncDeleteLedger(final long lId, final DeleteCallback cb, final Obj\n      * @throws BKException\n      */\n     public void deleteLedger(long lId) throws InterruptedException, BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<Void> counter = new CompletableFuture<>();\n         // Call asynchronous version\n         asyncDeleteLedger(lId, new SyncDeleteCallback(), counter);\n-        // Wait\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            LOG.error(\"Error deleting ledger \" + lId + \" : \" + counter.getrc());\n-            throw BKException.create(counter.getrc());\n-        }\n+\n+        SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -1079,11 +1046,9 @@ public void close() throws InterruptedException, BKException {\n          *          optional control object\n          */\n         @Override\n+        @SuppressWarnings(\"unchecked\")\n         public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n-            SyncCounter counter = (SyncCounter) ctx;\n-            counter.setLh(lh);\n-            counter.setrc(rc);\n-            counter.dec();\n+            SynchCallbackUtils.finish(rc, lh, (CompletableFuture<LedgerHandle>) ctx);\n         }\n     }\n \n@@ -1099,14 +1064,9 @@ public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n          *          optional control object\n          */\n         @Override\n+        @SuppressWarnings(\"unchecked\")\n         public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n-            SyncCounter counter = (SyncCounter) ctx;\n-            counter.setLh(lh);\n-\n-            LOG.debug(\"Open complete: {}\", rc);\n-\n-            counter.setrc(rc);\n-            counter.dec();\n+            SynchCallbackUtils.finish(rc, lh, (CompletableFuture<LedgerHandle>) ctx);\n         }\n     }\n \n@@ -1120,10 +1080,9 @@ public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n          *            optional control object\n          */\n         @Override\n+        @SuppressWarnings(\"unchecked\")\n         public void deleteComplete(int rc, Object ctx) {\n-            SyncCounter counter = (SyncCounter) ctx;\n-            counter.setrc(rc);\n-            counter.dec();\n+            SynchCallbackUtils.finish(rc, null, (CompletableFuture<Void>) ctx);\n         }\n     }\n "},{"sha":"dd8fde40a16cb5fcb026df9cb56d939e0284ae5a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":26,"deletions":38,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=bf4a4d6a07f9d615752054c6743035cebd86716e","patch":"@@ -27,6 +27,7 @@\n import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.LinkedList;\n@@ -35,6 +36,8 @@\n import java.util.NoSuchElementException;\n import java.util.Random;\n import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n \n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n@@ -260,18 +263,11 @@ public void asyncOpenLedger(final long lId, final OpenCallback cb, final Object\n      */\n     public LedgerHandle openLedger(final long lId) throws InterruptedException,\n             BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n+\n         new LedgerOpenOp(bkc, lId, new SyncOpenCallback(), counter).initiate();\n-        /*\n-         * Wait\n-         */\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(counter.getrc());\n-        }\n \n-        return counter.getLh();\n+        return SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -303,19 +299,12 @@ public void asyncOpenLedgerNoRecovery(final long lId, final OpenCallback cb, fin\n      */\n     public LedgerHandle openLedgerNoRecovery(final long lId)\n             throws InterruptedException, BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n+\n         new LedgerOpenOp(bkc, lId, new SyncOpenCallback(), counter)\n                 .initiateWithoutRecovery();\n-        /*\n-         * Wait\n-         */\n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(counter.getrc());\n-        }\n \n-        return counter.getLh();\n+        return SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -384,16 +373,13 @@ public boolean hasNext() {\n             }\n             if (lastEntryId == -1 || nextEntryId <= lastEntryId) {\n                 try {\n-                    SyncCounter counter = new SyncCounter();\n-                    counter.inc();\n+                    CompletableFuture<Enumeration<LedgerEntry>> counter = new CompletableFuture<>();\n \n                     handle.asyncReadEntriesInternal(nextEntryId, nextEntryId, new LedgerHandle.SyncReadCallback(),\n                             counter);\n-                    counter.block(0);\n-                    if (counter.getrc() != BKException.Code.OK) {\n-                        throw BKException.create(counter.getrc());\n-                    }\n-                    currentEntry = counter.getSequence().nextElement();\n+\n+                    currentEntry = SynchCallbackUtils.waitForResult(counter).nextElement();\n+\n                     return true;\n                 } catch (Exception e) {\n                     if (e instanceof BKException.BKNoSuchEntryException && lastEntryId == -1) {\n@@ -862,31 +848,33 @@ public void replicateLedgerFragment(LedgerHandle lh,\n             final LedgerFragment ledgerFragment,\n             final BookieSocketAddress targetBookieAddress)\n             throws InterruptedException, BKException {\n-        SyncCounter syncCounter = new SyncCounter();\n-        ResultCallBack resultCallBack = new ResultCallBack(syncCounter);\n+        CompletableFuture<Void> counter = new CompletableFuture<>();\n+        ResultCallBack resultCallBack = new ResultCallBack(counter);\n         SingleFragmentCallback cb = new SingleFragmentCallback(resultCallBack,\n                 lh, ledgerFragment.getFirstEntryId(), ledgerFragment\n                         .getAddress(), targetBookieAddress);\n-        syncCounter.inc();\n+\n         asyncRecoverLedgerFragment(lh, ledgerFragment, cb, targetBookieAddress);\n-        syncCounter.block(0);\n-        if (syncCounter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(bkc.getReturnRc(syncCounter.getrc()));\n+\n+        try {\n+            SynchCallbackUtils.waitForResult(counter);\n+        } catch (BKException err) {\n+            throw BKException.create(bkc.getReturnRc(err.getCode()));\n         }\n     }\n \n     /** This is the class for getting the replication result */\n     static class ResultCallBack implements AsyncCallback.VoidCallback {\n-        private SyncCounter sync;\n+        private final CompletableFuture<Void> sync;\n \n-        public ResultCallBack(SyncCounter sync) {\n+        public ResultCallBack(CompletableFuture<Void> sync) {\n             this.sync = sync;\n         }\n \n         @Override\n-        public void processResult(int rc, String s, Object obj) {\n-            sync.setrc(rc);\n-            sync.dec();\n+        @SuppressWarnings(\"unchecked\")\n+        public void processResult(int rc, String s, Object ctx) {\n+            SynchCallbackUtils.finish(rc, null, sync);\n         }\n     }\n "},{"sha":"5c3392914e4b7170f43a201fe9c10018c3ecb6dc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":14,"deletions":42,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=bf4a4d6a07f9d615752054c6743035cebd86716e","patch":"@@ -55,6 +55,8 @@\n \n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.RateLimiter;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n \n /**\n  * Ledger handle contains ledger metadata and is used to access the read and\n@@ -266,15 +268,11 @@ void writeLedgerConfig(GenericCallback<Void> writeCb) {\n      */\n     public void close()\n             throws InterruptedException, BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<Void> counter = new CompletableFuture<>();\n \n         asyncClose(new SyncCloseCallback(), counter);\n \n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(counter.getrc());\n-        }\n+        SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -461,17 +459,11 @@ public String toString() {\n      */\n     public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n             throws InterruptedException, BKException {\n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<Enumeration<LedgerEntry>> counter = new CompletableFuture<>();\n \n         asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(), counter);\n \n-        counter.block(0);\n-        if (counter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(counter.getrc());\n-        }\n-\n-        return counter.getSequence();\n+        return SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -550,18 +542,12 @@ public long addEntry(byte[] data, int offset, int length)\n             throws InterruptedException, BKException {\n         LOG.debug(\"Adding entry {}\", data);\n \n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<Long> counter = new CompletableFuture<>();\n \n         SyncAddCallback callback = new SyncAddCallback();\n         asyncAddEntry(data, offset, length, callback, counter);\n-        counter.block(0);\n-\n-        if (counter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(counter.getrc());\n-        }\n \n-        return callback.entryId;\n+        return SynchCallbackUtils.waitForResult(counter);\n     }\n \n     /**\n@@ -1353,21 +1339,14 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n          *          control object\n          */\n         @Override\n+        @SuppressWarnings(\"unchecked\")\n         public void readComplete(int rc, LedgerHandle lh,\n                                  Enumeration<LedgerEntry> seq, Object ctx) {\n-\n-            SyncCounter counter = (SyncCounter) ctx;\n-            synchronized (counter) {\n-                counter.setSequence(seq);\n-                counter.setrc(rc);\n-                counter.dec();\n-                counter.notify();\n-            }\n+            SynchCallbackUtils.finish(rc, seq, (CompletableFuture<Enumeration<LedgerEntry>>)ctx);\n         }\n     }\n \n     static class SyncAddCallback implements AddCallback {\n-        long entryId = -1;\n \n         /**\n          * Implementation of callback interface for synchronous read method.\n@@ -1382,12 +1361,9 @@ public void readComplete(int rc, LedgerHandle lh,\n          *          control object\n          */\n         @Override\n+        @SuppressWarnings(\"unchecked\")\n         public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n-            SyncCounter counter = (SyncCounter) ctx;\n-\n-            this.entryId = entry;\n-            counter.setrc(rc);\n-            counter.dec();\n+            SynchCallbackUtils.finish(rc, entry, (CompletableFuture<Long>)ctx);\n         }\n     }\n \n@@ -1416,13 +1392,9 @@ public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n          * @param ctx\n          */\n         @Override\n+        @SuppressWarnings(\"unchecked\")\n         public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n-            SyncCounter counter = (SyncCounter) ctx;\n-            counter.setrc(rc);\n-            synchronized (counter) {\n-                counter.dec();\n-                counter.notify();\n-            }\n+            SynchCallbackUtils.finish(rc, null, (CompletableFuture<Void>)ctx);\n         }\n     }\n }"},{"sha":"4a7de57f371d86aef9118d5886624fb325ffae74","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java","raw_url":"https://github.com/apache/bookkeeper/raw/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java?ref=bf4a4d6a07f9d615752054c6743035cebd86716e","patch":"@@ -24,6 +24,8 @@\n import java.io.Serializable;\n import java.security.GeneralSecurityException;\n import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n \n@@ -90,18 +92,16 @@ public long addEntry(final long entryId, byte[] data, int offset, int length) th\n             BKException {\n         LOG.debug(\"Adding entry {}\", data);\n \n-        SyncCounter counter = new SyncCounter();\n-        counter.inc();\n+        CompletableFuture<Long> counter = new CompletableFuture<>();\n \n         SyncAddCallback callback = new SyncAddCallback();\n         asyncAddEntry(entryId, data, offset, length, callback, counter);\n \n-        counter.block(0);\n-\n-        if (counter.getrc() != BKException.Code.OK) {\n-            throw BKException.create(counter.getrc());\n+        try {\n+            return counter.get();\n+        } catch (ExecutionException err) {\n+            throw (BKException) err.getCause();\n         }\n-        return callback.entryId;\n     }\n \n     /**"},{"sha":"d1ef9e4997aca6480178927cc7a6f13ce6fb044e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SynchCallbackUtils.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/bookkeeper/blob/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SynchCallbackUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/bf4a4d6a07f9d615752054c6743035cebd86716e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SynchCallbackUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SynchCallbackUtils.java?ref=bf4a4d6a07f9d615752054c6743035cebd86716e","patch":"@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2016 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * Utility for callbacks\n+ * \n+ */\n+public class SynchCallbackUtils {\n+\n+    /**\n+     * Wait for a result. This is convenience method to implement callbacks\n+     *\n+     * @param <T>\n+     * @param future\n+     * @return\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    public static <T> T waitForResult(CompletableFuture<T> future) throws InterruptedException, BKException {\n+        try {\n+            return future.get();\n+        } catch (ExecutionException err) {\n+            if (err.getCause() instanceof BKException) {\n+                throw (BKException) err.getCause();\n+            } else {\n+                BKException unexpectedConditionException\n+                    = BKException.create(BKException.Code.UnexpectedConditionException);\n+                unexpectedConditionException.initCause(err.getCause());\n+                throw unexpectedConditionException;\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Handle the Response Code and transform it to a BKException\n+     * @param <T>\n+     * @param rc\n+     * @param result\n+     * @param future \n+     */\n+    public static <T> void finish(int rc, T result, CompletableFuture<T> future) {\n+        if (rc != BKException.Code.OK) {\n+            future.completeExceptionally(BKException.create(rc).fillInStackTrace());\n+        } else {\n+            future.complete(result);\n+        }\n+    }\n+\n+}"}]}

