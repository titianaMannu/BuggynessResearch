{"sha":"c0cef66c6b34c635ec69a69ef033f96600ca5b99","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjMGNlZjY2YzZiMzRjNjM1ZWM2OWE2OWVmMDMzZjk2NjAwY2E1Yjk5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-08-18T21:03:41Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-08-18T21:03:41Z"},"message":"BOOKKEEPER-630: Add tag to o.a.b.net.* to indict which release of hadoop they came from, move DNS to o.a.b.net.* and indent (sijie via ivank)\n\nChange-Id: I9dd16912da6f23543d069434e9419495fdf8f314\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1618737 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f90bea53214cda44705431243cc3c99f96fc1bc4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/f90bea53214cda44705431243cc3c99f96fc1bc4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c0cef66c6b34c635ec69a69ef033f96600ca5b99","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c0cef66c6b34c635ec69a69ef033f96600ca5b99","html_url":"https://github.com/apache/bookkeeper/commit/c0cef66c6b34c635ec69a69ef033f96600ca5b99","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c0cef66c6b34c635ec69a69ef033f96600ca5b99/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"38a6fd30048c5fe165409a9ca536fb1ffbdbf537","url":"https://api.github.com/repos/apache/bookkeeper/commits/38a6fd30048c5fe165409a9ca536fb1ffbdbf537","html_url":"https://github.com/apache/bookkeeper/commit/38a6fd30048c5fe165409a9ca536fb1ffbdbf537"}],"stats":{"total":712,"additions":352,"deletions":360},"files":[{"sha":"9d26ae71bf245a308510cc83aa9e38cf1ef79dd0","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -214,6 +214,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-704: reconnectable zookeeper client wrapper (sijie via ivank)\n \n+        BOOKKEEPER-630: Add tag to o.a.b.net.* to indict which release of hadoop they came from, move DNS to o.a.b.net.* and indent (sijie via ivank)\n+\n       bookkeeper-benchmark:\n \n         BOOKKEEPER-768: fix typo 'seconds' to milliseconds in benchmark output (jialin via sijie)"},{"sha":"667ee9c64af89809309244eb3b1bcd687311051e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -49,6 +49,7 @@\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.DNS;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.Gauge;\n@@ -58,7 +59,6 @@\n import org.apache.bookkeeper.util.IOUtils;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.util.net.DNS;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.io.FileUtils;\n import org.apache.zookeeper.CreateMode;"},{"sha":"a4600bc5f087df057e755c621715251e1637f3e5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -18,12 +18,12 @@\n \n package org.apache.bookkeeper.meta;\n \n+import org.apache.bookkeeper.net.DNS;\n import org.apache.bookkeeper.replication.ReplicationEnableCb;\n import org.apache.bookkeeper.replication.ReplicationException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.bookkeeper.util.net.DNS;\n \n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;"},{"sha":"cba1f7ebdad4d7ce36c5e12d7c30da49ccfa089a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.util.HashSet;"},{"sha":"96acbc2409fa39ee5c0a7da7f1ef734b27470c42","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.util.ArrayList;"},{"sha":"a5dce939076ce7468b053c0b82baff50743a8ae0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","status":"added","additions":340,"deletions":0,"changes":340,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -0,0 +1,340 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+// This code has been copied from hadoop-common 2.0.4-alpha\n+package org.apache.bookkeeper.net;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.LinkedHashSet;\n+import java.util.Vector;\n+\n+import javax.naming.NamingException;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+\n+/**\n+ * A class that provides direct and reverse lookup functionalities, allowing\n+ * the querying of specific network interfaces or nameservers.\n+ */\n+public class DNS {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DNS.class);\n+\n+    /**\n+     * The cached hostname -initially null.\n+     */\n+\n+    private static final String cachedHostname = resolveLocalHostname();\n+    private static final String cachedHostAddress = resolveLocalHostIPAddress();\n+    private static final String LOCALHOST = \"localhost\";\n+\n+    /**\n+     * Returns the hostname associated with the specified IP address by the\n+     * provided nameserver.\n+     * <p/>\n+     * Loopback addresses\n+     *\n+     * @param hostIp The address to reverse lookup\n+     * @param ns     The host name of a reachable DNS server\n+     * @return The host name associated with the provided IP\n+     * @throws NamingException If a NamingException is encountered\n+     */\n+    public static String reverseDns(InetAddress hostIp, String ns)\n+            throws NamingException {\n+        //\n+        // Builds the reverse IP lookup form\n+        // This is formed by reversing the IP numbers and appending in-addr.arpa\n+        //\n+        String[] parts = hostIp.getHostAddress().split(\"\\\\.\");\n+        String reverseIP = parts[3] + \".\" + parts[2] + \".\" + parts[1] + \".\"\n+                + parts[0] + \".in-addr.arpa\";\n+\n+        DirContext ictx = new InitialDirContext();\n+        Attributes attribute;\n+        try {\n+            attribute = ictx.getAttributes(\"dns://\"               // Use \"dns:///\" if the default\n+                    + ((ns == null) ? \"\" : ns) +\n+                    // nameserver is to be used\n+                    \"/\" + reverseIP, new String[]{\"PTR\"});\n+        } finally {\n+            ictx.close();\n+        }\n+\n+        return attribute.get(\"PTR\").get().toString();\n+    }\n+\n+    /**\n+     * @return NetworkInterface for the given subinterface name (eg eth0:0)\n+     * or null if no interface with the given name can be found\n+     */\n+    private static NetworkInterface getSubinterface(String strInterface)\n+            throws SocketException {\n+        Enumeration<NetworkInterface> nifs =\n+                NetworkInterface.getNetworkInterfaces();\n+\n+        while (nifs.hasMoreElements()) {\n+            Enumeration<NetworkInterface> subNifs =\n+                    nifs.nextElement().getSubInterfaces();\n+\n+            while (subNifs.hasMoreElements()) {\n+                NetworkInterface nif = subNifs.nextElement();\n+                if (nif.getName().equals(strInterface)) {\n+                    return nif;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param nif network interface to get addresses for\n+     * @return set containing addresses for each subinterface of nif,\n+     * see below for the rationale for using an ordered set\n+     */\n+    private static LinkedHashSet<InetAddress> getSubinterfaceInetAddrs(\n+            NetworkInterface nif) {\n+        LinkedHashSet<InetAddress> addrs = new LinkedHashSet<InetAddress>();\n+        Enumeration<NetworkInterface> subNifs = nif.getSubInterfaces();\n+        while (subNifs.hasMoreElements()) {\n+            NetworkInterface subNif = subNifs.nextElement();\n+            addrs.addAll(Collections.list(subNif.getInetAddresses()));\n+        }\n+        return addrs;\n+    }\n+\n+    /**\n+     * Like {@link DNS#getIPs(String, boolean), but returns all\n+     * IPs associated with the given interface and its subinterfaces.\n+     */\n+    public static String[] getIPs(String strInterface)\n+            throws UnknownHostException {\n+        return getIPs(strInterface, true);\n+    }\n+\n+    /**\n+     * Returns all the IPs associated with the provided interface, if any, in\n+     * textual form.\n+     *\n+     * @param strInterface        The name of the network interface or sub-interface to query\n+     *                            (eg eth0 or eth0:0) or the string \"default\"\n+     * @param returnSubinterfaces Whether to return IPs associated with subinterfaces of\n+     *                            the given interface\n+     * @return A string vector of all the IPs associated with the provided\n+     * interface. The local host IP is returned if the interface\n+     * name \"default\" is specified or there is an I/O error looking\n+     * for the given interface.\n+     * @throws UnknownHostException If the given interface is invalid\n+     */\n+    public static String[] getIPs(String strInterface,\n+                                  boolean returnSubinterfaces) throws UnknownHostException {\n+        if (\"default\".equals(strInterface)) {\n+            return new String[]{cachedHostAddress};\n+        }\n+        NetworkInterface netIf;\n+        try {\n+            netIf = NetworkInterface.getByName(strInterface);\n+            if (netIf == null) {\n+                netIf = getSubinterface(strInterface);\n+            }\n+        } catch (SocketException e) {\n+            LOG.warn(\"I/O error finding interface \" + strInterface +\n+                    \": \" + e.getMessage());\n+            return new String[]{cachedHostAddress};\n+        }\n+        if (netIf == null) {\n+            throw new UnknownHostException(\"No such interface \" + strInterface);\n+        }\n+\n+        // NB: Using a LinkedHashSet to preserve the order for callers\n+        // that depend on a particular element being 1st in the array.\n+        // For example, getDefaultIP always returns the first element.\n+        LinkedHashSet<InetAddress> allAddrs = new LinkedHashSet<InetAddress>();\n+        allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n+        if (!returnSubinterfaces) {\n+            allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n+        }\n+\n+        String ips[] = new String[allAddrs.size()];\n+        int i = 0;\n+        for (InetAddress addr : allAddrs) {\n+            ips[i++] = addr.getHostAddress();\n+        }\n+        return ips;\n+    }\n+\n+\n+    /**\n+     * Returns the first available IP address associated with the provided\n+     * network interface or the local host IP if \"default\" is given.\n+     *\n+     * @param strInterface The name of the network interface or subinterface to query\n+     *                     (e.g. eth0 or eth0:0) or the string \"default\"\n+     * @return The IP address in text form, the local host IP is returned\n+     * if the interface name \"default\" is specified\n+     * @throws UnknownHostException If the given interface is invalid\n+     */\n+    public static String getDefaultIP(String strInterface)\n+            throws UnknownHostException {\n+        String[] ips = getIPs(strInterface);\n+        return ips[0];\n+    }\n+\n+    /**\n+     * Returns all the host names associated by the provided nameserver with the\n+     * address bound to the specified network interface\n+     *\n+     * @param strInterface The name of the network interface or subinterface to query\n+     *                     (e.g. eth0 or eth0:0)\n+     * @param nameserver   The DNS host name\n+     * @return A string vector of all host names associated with the IPs tied to\n+     * the specified interface\n+     * @throws UnknownHostException if the given interface is invalid\n+     */\n+    public static String[] getHosts(String strInterface, String nameserver)\n+            throws UnknownHostException {\n+        String[] ips = getIPs(strInterface);\n+        Vector<String> hosts = new Vector<String>();\n+        for (int ctr = 0; ctr < ips.length; ctr++) {\n+            try {\n+                hosts.add(reverseDns(InetAddress.getByName(ips[ctr]),\n+                        nameserver));\n+            } catch (UnknownHostException ignored) {\n+            } catch (NamingException ignored) {\n+            }\n+        }\n+        if (hosts.isEmpty()) {\n+            LOG.warn(\"Unable to determine hostname for interface \" + strInterface);\n+            return new String[]{cachedHostname};\n+        } else {\n+            return hosts.toArray(new String[hosts.size()]);\n+        }\n+    }\n+\n+\n+    /**\n+     * Determine the local hostname; retrieving it from cache if it is known\n+     * If we cannot determine our host name, return \"localhost\"\n+     *\n+     * @return the local hostname or \"localhost\"\n+     */\n+    private static String resolveLocalHostname() {\n+        String localhost;\n+        try {\n+            localhost = InetAddress.getLocalHost().getCanonicalHostName();\n+        } catch (UnknownHostException e) {\n+            LOG.warn(\"Unable to determine local hostname \"\n+                    + \"-falling back to \\\"\" + LOCALHOST + \"\\\"\", e);\n+            localhost = LOCALHOST;\n+        }\n+        return localhost;\n+    }\n+\n+\n+    /**\n+     * Get the IPAddress of the local host as a string.\n+     * This will be a loop back value if the local host address cannot be\n+     * determined.\n+     * If the loopback address of \"localhost\" does not resolve, then the system's\n+     * network is in such a state that nothing is going to work. A message is\n+     * logged at the error level and a null pointer returned, a pointer\n+     * which will trigger failures later on the application\n+     *\n+     * @return the IPAddress of the local host or null for a serious problem.\n+     */\n+    private static String resolveLocalHostIPAddress() {\n+        String address;\n+        try {\n+            address = InetAddress.getLocalHost().getHostAddress();\n+        } catch (UnknownHostException e) {\n+            LOG.warn(\"Unable to determine address of the host\"\n+                    + \"-falling back to \\\"\" + LOCALHOST + \"\\\" address\", e);\n+            try {\n+                address = InetAddress.getByName(LOCALHOST).getHostAddress();\n+            } catch (UnknownHostException noLocalHostAddressException) {\n+                //at this point, deep trouble\n+                LOG.error(\"Unable to determine local loopback address \"\n+                        + \"of \\\"\" + LOCALHOST + \"\\\" \" +\n+                        \"-this system's network configuration is unsupported\", e);\n+                address = null;\n+            }\n+        }\n+        return address;\n+    }\n+\n+    /**\n+     * Returns all the host names associated by the default nameserver with the\n+     * address bound to the specified network interface\n+     *\n+     * @param strInterface The name of the network interface to query (e.g. eth0)\n+     * @return The list of host names associated with IPs bound to the network\n+     * interface\n+     * @throws UnknownHostException If one is encountered while querying the default interface\n+     */\n+    public static String[] getHosts(String strInterface)\n+            throws UnknownHostException {\n+        return getHosts(strInterface, null);\n+    }\n+\n+    /**\n+     * Returns the default (first) host name associated by the provided\n+     * nameserver with the address bound to the specified network interface\n+     *\n+     * @param strInterface The name of the network interface to query (e.g. eth0)\n+     * @param nameserver   The DNS host name\n+     * @return The default host names associated with IPs bound to the network\n+     * interface\n+     * @throws UnknownHostException If one is encountered while querying the default interface\n+     */\n+    public static String getDefaultHost(String strInterface, String nameserver)\n+            throws UnknownHostException {\n+        if (\"default\".equals(strInterface)) {\n+            return cachedHostname;\n+        }\n+\n+        if (\"default\".equals(nameserver)) {\n+            return getDefaultHost(strInterface);\n+        }\n+\n+        String[] hosts = getHosts(strInterface, nameserver);\n+        return hosts[0];\n+    }\n+\n+    /**\n+     * Returns the default (first) host name associated by the default\n+     * nameserver with the address bound to the specified network interface\n+     *\n+     * @param strInterface The name of the network interface to query (e.g. eth0).\n+     *                     Must not be null.\n+     * @return The default host name associated with IPs bound to the network\n+     * interface\n+     * @throws UnknownHostException If one is encountered while querying the default interface\n+     */\n+    public static String getDefaultHost(String strInterface)\n+            throws UnknownHostException {\n+        return getDefaultHost(strInterface, null);\n+    }\n+\n+}"},{"sha":"35f9a36da4cfd9e4f49ca283300ee8a1ccad7215","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.util.List;"},{"sha":"bcc880c66ea91f9339a31c0d3422824f248ef456","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.net.InetAddress;"},{"sha":"26abc96159f85bbf0fddaaaee0a984a161ddbdce","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.util.ArrayList;"},{"sha":"f11e0a76a2df38b00244458efddf990838f68d96","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import com.google.common.annotations.Beta;"},{"sha":"f1a4b85cec3edc6563de27b1063abc901a521f41","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n /** A base class that implements interface Node"},{"sha":"1671cc888b7ffa77e683851fd9949f072b9a71e2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","raw_url":"https://github.com/apache/bookkeeper/raw/c0cef66c6b34c635ec69a69ef033f96600ca5b99/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java?ref=c0cef66c6b34c635ec69a69ef033f96600ca5b99","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n+// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.io.File;"},{"sha":"cc182f73efaec8d21f3e95b981dcfcae18842325","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java","status":"removed","additions":0,"deletions":356,"changes":356,"blob_url":"https://github.com/apache/bookkeeper/blob/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java","raw_url":"https://github.com/apache/bookkeeper/raw/38a6fd30048c5fe165409a9ca536fb1ffbdbf537/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java?ref=38a6fd30048c5fe165409a9ca536fb1ffbdbf537","patch":"@@ -1,356 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-// This code has been copied from hadoop-common 2.0.4-alpha\n-package org.apache.bookkeeper.util.net;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.net.InetAddress;\n-import java.net.NetworkInterface;\n-import java.net.SocketException;\n-import java.net.UnknownHostException;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.LinkedHashSet;\n-import java.util.Vector;\n-\n-import javax.naming.NamingException;\n-import javax.naming.directory.Attributes;\n-import javax.naming.directory.DirContext;\n-import javax.naming.directory.InitialDirContext;\n-\n-/**\n- *\n- * A class that provides direct and reverse lookup functionalities, allowing\n- * the querying of specific network interfaces or nameservers.\n- *\n- *\n- */\n-public class DNS {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(DNS.class);\n-\n-  /**\n-   * The cached hostname -initially null.\n-   */\n-\n-  private static final String cachedHostname = resolveLocalHostname();\n-  private static final String cachedHostAddress = resolveLocalHostIPAddress();\n-  private static final String LOCALHOST = \"localhost\";\n-\n-  /**\n-   * Returns the hostname associated with the specified IP address by the\n-   * provided nameserver.\n-   *\n-   * Loopback addresses\n-   * @param hostIp The address to reverse lookup\n-   * @param ns The host name of a reachable DNS server\n-   * @return The host name associated with the provided IP\n-   * @throws NamingException If a NamingException is encountered\n-   */\n-  public static String reverseDns(InetAddress hostIp, String ns)\n-    throws NamingException {\n-    //\n-    // Builds the reverse IP lookup form\n-    // This is formed by reversing the IP numbers and appending in-addr.arpa\n-    //\n-    String[] parts = hostIp.getHostAddress().split(\"\\\\.\");\n-    String reverseIP = parts[3] + \".\" + parts[2] + \".\" + parts[1] + \".\"\n-      + parts[0] + \".in-addr.arpa\";\n-\n-    DirContext ictx = new InitialDirContext();\n-    Attributes attribute;\n-    try {\n-      attribute = ictx.getAttributes(\"dns://\"               // Use \"dns:///\" if the default\n-                         + ((ns == null) ? \"\" : ns) +\n-                         // nameserver is to be used\n-                         \"/\" + reverseIP, new String[] { \"PTR\" });\n-    } finally {\n-      ictx.close();\n-    }\n-\n-    return attribute.get(\"PTR\").get().toString();\n-  }\n-\n-  /**\n-   * @return NetworkInterface for the given subinterface name (eg eth0:0)\n-   *    or null if no interface with the given name can be found\n-   */\n-  private static NetworkInterface getSubinterface(String strInterface)\n-      throws SocketException {\n-    Enumeration<NetworkInterface> nifs =\n-      NetworkInterface.getNetworkInterfaces();\n-\n-    while (nifs.hasMoreElements()) {\n-      Enumeration<NetworkInterface> subNifs =\n-        nifs.nextElement().getSubInterfaces();\n-\n-      while (subNifs.hasMoreElements()) {\n-        NetworkInterface nif = subNifs.nextElement();\n-        if (nif.getName().equals(strInterface)) {\n-          return nif;\n-        }\n-      }\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * @param nif network interface to get addresses for\n-   * @return set containing addresses for each subinterface of nif,\n-   *    see below for the rationale for using an ordered set\n-   */\n-  private static LinkedHashSet<InetAddress> getSubinterfaceInetAddrs(\n-      NetworkInterface nif) {\n-    LinkedHashSet<InetAddress> addrs = new LinkedHashSet<InetAddress>();\n-    Enumeration<NetworkInterface> subNifs = nif.getSubInterfaces();\n-    while (subNifs.hasMoreElements()) {\n-      NetworkInterface subNif = subNifs.nextElement();\n-      addrs.addAll(Collections.list(subNif.getInetAddresses()));\n-    }\n-    return addrs;\n-  }\n-\n-  /**\n-   * Like {@link DNS#getIPs(String, boolean), but returns all\n-   * IPs associated with the given interface and its subinterfaces.\n-   */\n-  public static String[] getIPs(String strInterface)\n-      throws UnknownHostException {\n-    return getIPs(strInterface, true);\n-  }\n-\n-  /**\n-   * Returns all the IPs associated with the provided interface, if any, in\n-   * textual form.\n-   *\n-   * @param strInterface\n-   *            The name of the network interface or sub-interface to query\n-   *            (eg eth0 or eth0:0) or the string \"default\"\n-   * @param returnSubinterfaces\n-   *            Whether to return IPs associated with subinterfaces of\n-   *            the given interface\n-   * @return A string vector of all the IPs associated with the provided\n-   *         interface. The local host IP is returned if the interface\n-   *         name \"default\" is specified or there is an I/O error looking\n-   *         for the given interface.\n-   * @throws UnknownHostException\n-   *             If the given interface is invalid\n-   *\n-   */\n-  public static String[] getIPs(String strInterface,\n-      boolean returnSubinterfaces) throws UnknownHostException {\n-    if (\"default\".equals(strInterface)) {\n-      return new String[] { cachedHostAddress };\n-    }\n-    NetworkInterface netIf;\n-    try {\n-      netIf = NetworkInterface.getByName(strInterface);\n-      if (netIf == null) {\n-        netIf = getSubinterface(strInterface);\n-      }\n-    } catch (SocketException e) {\n-      LOG.warn(\"I/O error finding interface \" + strInterface +\n-          \": \" + e.getMessage());\n-      return new String[] { cachedHostAddress };\n-    }\n-    if (netIf == null) {\n-      throw new UnknownHostException(\"No such interface \" + strInterface);\n-    }\n-\n-    // NB: Using a LinkedHashSet to preserve the order for callers\n-    // that depend on a particular element being 1st in the array.\n-    // For example, getDefaultIP always returns the first element.\n-    LinkedHashSet<InetAddress> allAddrs = new LinkedHashSet<InetAddress>();\n-    allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n-    if (!returnSubinterfaces) {\n-      allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n-    }\n-\n-    String ips[] = new String[allAddrs.size()];\n-    int i = 0;\n-    for (InetAddress addr : allAddrs) {\n-      ips[i++] = addr.getHostAddress();\n-    }\n-    return ips;\n-  }\n-\n-\n-  /**\n-   * Returns the first available IP address associated with the provided\n-   * network interface or the local host IP if \"default\" is given.\n-   *\n-   * @param strInterface\n-   *            The name of the network interface or subinterface to query\n-   *             (e.g. eth0 or eth0:0) or the string \"default\"\n-   * @return The IP address in text form, the local host IP is returned\n-   *         if the interface name \"default\" is specified\n-   * @throws UnknownHostException\n-   *             If the given interface is invalid\n-   */\n-  public static String getDefaultIP(String strInterface)\n-    throws UnknownHostException {\n-    String[] ips = getIPs(strInterface);\n-    return ips[0];\n-  }\n-\n-  /**\n-   * Returns all the host names associated by the provided nameserver with the\n-   * address bound to the specified network interface\n-   *\n-   * @param strInterface\n-   *            The name of the network interface or subinterface to query\n-   *            (e.g. eth0 or eth0:0)\n-   * @param nameserver\n-   *            The DNS host name\n-   * @return A string vector of all host names associated with the IPs tied to\n-   *         the specified interface\n-   * @throws UnknownHostException if the given interface is invalid\n-   */\n-  public static String[] getHosts(String strInterface, String nameserver)\n-    throws UnknownHostException {\n-    String[] ips = getIPs(strInterface);\n-    Vector<String> hosts = new Vector<String>();\n-    for (int ctr = 0; ctr < ips.length; ctr++) {\n-      try {\n-        hosts.add(reverseDns(InetAddress.getByName(ips[ctr]),\n-                             nameserver));\n-      } catch (UnknownHostException ignored) {\n-      } catch (NamingException ignored) {\n-      }\n-    }\n-    if (hosts.isEmpty()) {\n-      LOG.warn(\"Unable to determine hostname for interface \" + strInterface);\n-      return new String[] { cachedHostname };\n-    } else {\n-      return hosts.toArray(new String[hosts.size()]);\n-    }\n-  }\n-\n-\n-  /**\n-   * Determine the local hostname; retrieving it from cache if it is known\n-   * If we cannot determine our host name, return \"localhost\"\n-   * @return the local hostname or \"localhost\"\n-   */\n-  private static String resolveLocalHostname() {\n-    String localhost;\n-    try {\n-      localhost = InetAddress.getLocalHost().getCanonicalHostName();\n-    } catch (UnknownHostException e) {\n-      LOG.warn(\"Unable to determine local hostname \"\n-          + \"-falling back to \\\"\" + LOCALHOST + \"\\\"\", e);\n-      localhost = LOCALHOST;\n-    }\n-    return localhost;\n-  }\n-\n-\n-  /**\n-   * Get the IPAddress of the local host as a string.\n-   * This will be a loop back value if the local host address cannot be\n-   * determined.\n-   * If the loopback address of \"localhost\" does not resolve, then the system's\n-   * network is in such a state that nothing is going to work. A message is\n-   * logged at the error level and a null pointer returned, a pointer\n-   * which will trigger failures later on the application\n-   * @return the IPAddress of the local host or null for a serious problem.\n-   */\n-  private static String resolveLocalHostIPAddress() {\n-    String address;\n-      try {\n-        address = InetAddress.getLocalHost().getHostAddress();\n-      } catch (UnknownHostException e) {\n-        LOG.warn(\"Unable to determine address of the host\"\n-                + \"-falling back to \\\"\" + LOCALHOST + \"\\\" address\", e);\n-        try {\n-          address = InetAddress.getByName(LOCALHOST).getHostAddress();\n-        } catch (UnknownHostException noLocalHostAddressException) {\n-          //at this point, deep trouble\n-          LOG.error(\"Unable to determine local loopback address \"\n-                  + \"of \\\"\" + LOCALHOST + \"\\\" \" +\n-                  \"-this system's network configuration is unsupported\", e);\n-          address = null;\n-        }\n-      }\n-    return address;\n-  }\n-\n-  /**\n-   * Returns all the host names associated by the default nameserver with the\n-   * address bound to the specified network interface\n-   *\n-   * @param strInterface\n-   *            The name of the network interface to query (e.g. eth0)\n-   * @return The list of host names associated with IPs bound to the network\n-   *         interface\n-   * @throws UnknownHostException\n-   *             If one is encountered while querying the default interface\n-   *\n-   */\n-  public static String[] getHosts(String strInterface)\n-    throws UnknownHostException {\n-    return getHosts(strInterface, null);\n-  }\n-\n-  /**\n-   * Returns the default (first) host name associated by the provided\n-   * nameserver with the address bound to the specified network interface\n-   *\n-   * @param strInterface\n-   *            The name of the network interface to query (e.g. eth0)\n-   * @param nameserver\n-   *            The DNS host name\n-   * @return The default host names associated with IPs bound to the network\n-   *         interface\n-   * @throws UnknownHostException\n-   *             If one is encountered while querying the default interface\n-   */\n-  public static String getDefaultHost(String strInterface, String nameserver)\n-    throws UnknownHostException {\n-    if (\"default\".equals(strInterface)) {\n-      return cachedHostname;\n-    }\n-\n-    if (\"default\".equals(nameserver)) {\n-      return getDefaultHost(strInterface);\n-    }\n-\n-    String[] hosts = getHosts(strInterface, nameserver);\n-    return hosts[0];\n-  }\n-\n-  /**\n-   * Returns the default (first) host name associated by the default\n-   * nameserver with the address bound to the specified network interface\n-   *\n-   * @param strInterface\n-   *            The name of the network interface to query (e.g. eth0).\n-   *            Must not be null.\n-   * @return The default host name associated with IPs bound to the network\n-   *         interface\n-   * @throws UnknownHostException\n-   *             If one is encountered while querying the default interface\n-   */\n-  public static String getDefaultHost(String strInterface)\n-    throws UnknownHostException {\n-    return getDefaultHost(strInterface, null);\n-  }\n-\n-}"}]}

