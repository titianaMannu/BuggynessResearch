{"sha":"c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjMWM4YmVmNjEyNWNiNzBlZDJkYTY4ZTkyYmI0OWU0NWY0ZWE2NGE5","commit":{"author":{"name":"Benjamin Reed","email":"breed@apache.org","date":"2011-03-30T23:29:21Z"},"committer":{"name":"Benjamin Reed","email":"breed@apache.org","date":"2011-03-30T23:29:21Z"},"message":"ZOOKEEPER-1038. Move bookkeeper and hedwig code in subversion\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1087134 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a0a079ca2025033ccadb1af22232651eb54e0486","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a0a079ca2025033ccadb1af22232651eb54e0486"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","html_url":"https://github.com/apache/bookkeeper/commit/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/comments","author":{"login":"breed","id":143779,"node_id":"MDQ6VXNlcjE0Mzc3OQ==","avatar_url":"https://avatars.githubusercontent.com/u/143779?v=4","gravatar_id":"","url":"https://api.github.com/users/breed","html_url":"https://github.com/breed","followers_url":"https://api.github.com/users/breed/followers","following_url":"https://api.github.com/users/breed/following{/other_user}","gists_url":"https://api.github.com/users/breed/gists{/gist_id}","starred_url":"https://api.github.com/users/breed/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/breed/subscriptions","organizations_url":"https://api.github.com/users/breed/orgs","repos_url":"https://api.github.com/users/breed/repos","events_url":"https://api.github.com/users/breed/events{/privacy}","received_events_url":"https://api.github.com/users/breed/received_events","type":"User","site_admin":false},"committer":{"login":"breed","id":143779,"node_id":"MDQ6VXNlcjE0Mzc3OQ==","avatar_url":"https://avatars.githubusercontent.com/u/143779?v=4","gravatar_id":"","url":"https://api.github.com/users/breed","html_url":"https://github.com/breed","followers_url":"https://api.github.com/users/breed/followers","following_url":"https://api.github.com/users/breed/following{/other_user}","gists_url":"https://api.github.com/users/breed/gists{/gist_id}","starred_url":"https://api.github.com/users/breed/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/breed/subscriptions","organizations_url":"https://api.github.com/users/breed/orgs","repos_url":"https://api.github.com/users/breed/repos","events_url":"https://api.github.com/users/breed/events{/privacy}","received_events_url":"https://api.github.com/users/breed/received_events","type":"User","site_admin":false},"parents":[{"sha":"9ea37773fa07e8e1c16e654020ae34c3d6564963","url":"https://api.github.com/repos/apache/bookkeeper/commits/9ea37773fa07e8e1c16e654020ae34c3d6564963","html_url":"https://github.com/apache/bookkeeper/commit/9ea37773fa07e8e1c16e654020ae34c3d6564963"}],"stats":{"total":41546,"additions":41546,"deletions":0},"files":[{"sha":"d645695673349e3947e8e5ae42332d0ac3164cd7","filename":"LICENSE.txt","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/LICENSE.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/LICENSE.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/LICENSE.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License."},{"sha":"2cbefade9d4b38b410ffdf724e56d68aaed19b9c","filename":"NOTICE.txt","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/NOTICE.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/NOTICE.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/NOTICE.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,2 @@\n+Copyright (c) 2010 Yahoo! Inc.  All rights reserved.\n+"},{"sha":"4a9445e7efc7fa1406110e81f3e0b3d636080a19","filename":"README","status":"added","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/README","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/README","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/README?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,3 @@\n+Hedwig is a large scale pub/sub system built on top of ZooKeeper and BookKeeper.\n+\n+For documentation on building, setting up, and using Hedwig see the `doc` directory."},{"sha":"84f9330375c3a2deef1ef25f7656d3cc52b65212","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","status":"added","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/MySqlClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,137 @@\n+package org.apache.bookkeeper.benchmark;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.FileOutputStream;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.QuorumEngine;\n+import org.apache.log4j.Logger;\n+\n+\n+import org.apache.zookeeper.KeeperException;\n+\n+public class MySqlClient {\n+\tstatic Logger LOG = Logger.getLogger(QuorumEngine.class);\n+\n+\tBookKeeper x;\n+\tLedgerHandle lh;\n+\tInteger entryId;\n+\tHashMap<Integer, Integer> map;\n+\n+\tFileOutputStream fStream;\n+\tFileOutputStream fStreamLocal;\n+\tlong start, lastId;\n+\tConnection con;\n+\tStatement stmt;\n+\t\n+\t\n+\tpublic MySqlClient(String hostport, String user, String pass) \n+\t\t\tthrows ClassNotFoundException {\n+\t\tentryId = 0;\n+\t\tmap = new HashMap<Integer, Integer>();\n+\t\tClass.forName(\"com.mysql.jdbc.Driver\");\n+\t\t// database is named \"bookkeeper\"\n+\t\tString url = \"jdbc:mysql://\" + hostport + \"/bookkeeper\";\n+\t\ttry {\n+\t\t\tcon = DriverManager.getConnection(url, user, pass);\n+\t\t\tstmt = con.createStatement();\n+\t\t\t// drop table and recreate it\n+\t\t\tstmt.execute(\"DROP TABLE IF EXISTS data;\");\n+\t\t\tstmt.execute(\"create table data(transaction_id bigint PRIMARY KEY AUTO_INCREMENT, content TEXT);\");\n+\t\t\tLOG.info(\"Database initialization terminated\");\n+\t\t} catch (SQLException e) {\n+\t\t\t\n+\t\t\t// TODO Auto-generated catch block\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\n+\tpublic void closeHandle() throws KeeperException, InterruptedException, SQLException{\n+\t\tcon.close();\n+\t}\n+\t/**\n+\t * First parameter is an integer defining the length of the message \n+\t * Second parameter is the number of writes\n+\t * Third parameter is host:port \n+\t * Fourth parameter is username\n+\t * Fifth parameter is password\n+\t * @param args\n+\t * @throws ClassNotFoundException \n+\t * @throws SQLException \n+\t */\n+\tpublic static void main(String[] args) throws ClassNotFoundException, SQLException {\t\t\n+\t\tint lenght = Integer.parseInt(args[1]);\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\twhile(lenght-- > 0){\n+\t\t\tsb.append('a');\n+\t\t}\n+\t\ttry {\n+\t\t\tMySqlClient c = new MySqlClient(args[2], args[3], args[4]);\n+\t\t\tc.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[0]));\n+\t\t\tc.writeSameEntry(sb.toString().getBytes(), Integer.parseInt(args[0]));\n+\t\t\tc.closeHandle();\n+\t\t} catch (NumberFormatException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (InterruptedException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (KeeperException e) {\n+\t\t\te.printStackTrace();\n+\t\t} \n+\n+\t}\n+\n+\t/**\t\n+\t * \tAdds  data entry to the DB \n+\t * \t@param data \tthe entry to be written, given as a byte array \n+\t * \t@param times\tthe number of times the entry should be written on the DB\t*/\n+\tvoid writeSameEntryBatch(byte[] data, int times) throws InterruptedException, SQLException{\n+\t\tstart = System.currentTimeMillis();\n+\t\tint count = times;\n+\t\tString content = new String(data);\n+\t\tSystem.out.println(\"Data: \" + content + \", \" + data.length);\n+\t\twhile(count-- > 0){\n+\t\t\tstmt.addBatch(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n+\t\t}\n+\t\tLOG.info(\"Finished writing batch SQL command in ms: \" + (System.currentTimeMillis() - start));\n+\t\tstart = System.currentTimeMillis();\n+\t\tstmt.executeBatch();\n+\t\tSystem.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));       \n+\t\tLOG.info(\"Ended computation\");\n+\t}\n+\n+\tvoid writeSameEntry(byte[] data, int times) throws InterruptedException, SQLException{\n+\t\tstart = System.currentTimeMillis();\n+\t\tint count = times;\n+\t\tString content = new String(data);\n+\t\tSystem.out.println(\"Data: \" + content + \", \" + data.length);\n+\t\twhile(count-- > 0){\n+\t\t\tstmt.executeUpdate(\"insert into data(content) values(\\\"\" + content + \"\\\");\");\n+\t\t}\n+\t\tSystem.out.println(\"Finished \" + times + \" writes in ms: \" + (System.currentTimeMillis() - start));       \n+\t\tLOG.info(\"Ended computation\");\n+\t}\n+\n+}\n\\ No newline at end of file"},{"sha":"d24bf7aac1eaf5da88f40a3b95a6e5c2a93e1d01","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","status":"added","additions":252,"deletions":0,"changes":252,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,252 @@\n+package org.apache.bookkeeper.benchmark;\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+\n+import org.apache.bookkeeper.client.AddCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.QuorumEngine;\n+import org.apache.bookkeeper.client.ReadCallback;\n+import org.apache.bookkeeper.client.LedgerHandle.QMode;\n+import org.apache.log4j.Logger;\n+\n+import org.apache.zookeeper.KeeperException;\n+\n+/**\n+ * This is a simple test program to compare the performance of writing to\n+ * BookKeeper and to the local file system.\n+ * \n+ */\n+\n+public class TestClient \n+    implements AddCallback, ReadCallback{\n+    private static final Logger LOG = Logger.getLogger(TestClient.class);\n+    \n+    BookKeeper x;\n+    LedgerHandle lh;\n+    Integer entryId;\n+    HashMap<Integer, Integer> map;\n+    \n+    FileOutputStream fStream;\n+    FileOutputStream fStreamLocal;\n+    long start, lastId;\n+    \n+    public TestClient() {\n+        entryId = 0;\n+        map = new HashMap<Integer, Integer>();\n+    }\n+    \n+    public TestClient(String servers) throws KeeperException, IOException, InterruptedException{\n+        this();\n+        x = new BookKeeper(servers);\n+        try{\n+        lh = x.createLedger(new byte[] {'a', 'b'});\n+        } catch (BKException e) {\n+            LOG.error(e.toString());\n+        }\n+    }\n+    \n+    public TestClient(String servers, int ensSize, int qSize)\n+    throws KeeperException, IOException, InterruptedException{\n+        this();\n+        x = new BookKeeper(servers);\n+        try{\n+        lh = x.createLedger(ensSize, qSize, QMode.VERIFIABLE, new byte[] {'a', 'b'});\n+        } catch (BKException e) {\n+            LOG.error(e.toString());\n+        }\n+    }\n+    \n+    public TestClient(FileOutputStream fStream)\n+    throws FileNotFoundException {\n+        this.fStream = fStream;\n+        this.fStreamLocal = new FileOutputStream(\"./local.log\");\n+    }\n+    \n+    \n+    public Integer getFreshEntryId(int val){\n+        ++this.entryId;\n+        synchronized (map) {\n+            map.put(this.entryId, val);\n+        }\n+        return this.entryId;\n+    }\n+    \n+    public boolean removeEntryId(Integer id){\n+        boolean retVal = false;\n+        synchronized (map) {\n+                map.remove(id);\n+                retVal = true;\n+     \n+            if(map.size() == 0) map.notifyAll();\n+            else{\n+                if(map.size() < 4)\n+                    LOG.error(map.toString());\n+            }\n+        }\n+        return retVal;\n+    }\n+\n+    public void closeHandle() throws KeeperException, InterruptedException{\n+        x.closeLedger(lh);\n+    }\n+    /**\n+     * First says if entries should be written to BookKeeper (0) or to the local\n+     * disk (1). Second parameter is an integer defining the length of a ledger entry. \n+     * Third parameter is the number of writes.\n+     * \n+     * @param args\n+     */\n+    public static void main(String[] args) {\n+        \n+        int lenght = Integer.parseInt(args[1]);\n+        StringBuilder sb = new StringBuilder();\n+        while(lenght-- > 0){\n+            sb.append('a');\n+        }\n+        \n+        Integer selection = Integer.parseInt(args[0]);\n+        switch(selection){\n+        case 0:           \n+            StringBuilder servers_sb = new StringBuilder();\n+            for (int i = 4; i < args.length; i++){\n+                servers_sb.append(args[i] + \" \");\n+            }\n+        \n+            String servers = servers_sb.toString().trim().replace(' ', ',');\n+            try {\n+                TestClient c = new TestClient(servers, Integer.parseInt(args[3]), Integer.parseInt(args[4]));\n+                c.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[2]));\n+                //c.writeConsecutiveEntriesBatch(Integer.parseInt(args[0]));\n+                c.closeHandle();\n+            } catch (NumberFormatException e) {\n+                LOG.error(e);\n+            } catch (InterruptedException e) {\n+                LOG.error(e);\n+            } catch (KeeperException e) {\n+                LOG.error(e);\n+            } catch (IOException e) {\n+                LOG.error(e);\n+            }\n+            break;\n+        case 1:\n+            \n+            try{\n+                TestClient c = new TestClient(new FileOutputStream(args[2]));\n+                c.writeSameEntryBatchFS(sb.toString().getBytes(), Integer.parseInt(args[3]));\n+            } catch(FileNotFoundException e){\n+                LOG.error(e);\n+            }\n+            break;\n+        case 2:\n+            break;\n+        }\n+    }\n+\n+    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException{\n+        start = System.currentTimeMillis();\n+        int count = times;\n+        LOG.debug(\"Data: \" + new String(data) + \", \" + data.length);\n+        while(count-- > 0){\n+            x.asyncAddEntry(lh, data, this, this.getFreshEntryId(2));\n+        }\n+        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));       \n+        synchronized (map) {\n+            if(map.size() != 0)\n+                map.wait();\n+        }\n+        LOG.debug(\"Finished processing in ms: \" + (System.currentTimeMillis() - start));\n+        \n+        LOG.debug(\"Ended computation\");\n+    }\n+    \n+    void writeConsecutiveEntriesBatch(int times) throws InterruptedException{\n+        start = System.currentTimeMillis();\n+        int count = times;\n+        while(count-- > 0){\n+            byte[] write = new byte[2];\n+            int j = count%100;\n+            int k = (count+1)%100;\n+            write[0] = (byte) j;\n+            write[1] = (byte) k;\n+            x.asyncAddEntry(lh, write, this, this.getFreshEntryId(2));\n+        }\n+        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));       \n+        synchronized (map) {\n+            if(map.size() != 0)\n+                map.wait();\n+        }\n+        LOG.debug(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n+        \n+        Integer mon = Integer.valueOf(0);\n+        synchronized(mon){\n+            try{\n+                x.asyncReadEntries(lh, 1, times - 1, this, mon);\n+                mon.wait();\n+            } catch (BKException e){\n+                LOG.error(e);\n+            }\n+        }\n+        LOG.error(\"Ended computation\");\n+    }\n+\n+    void writeSameEntryBatchFS(byte[] data, int times) {\n+        int count = times;\n+        LOG.debug(\"Data: \" + data.length + \", \" + times);\n+        try{\n+            start = System.currentTimeMillis();\n+            while(count-- > 0){\n+                fStream.write(data);\n+                fStreamLocal.write(data);\n+                fStream.flush();\n+            }\n+            fStream.close();\n+            System.out.println(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n+        } catch(IOException e){\n+            LOG.error(e);\n+        }\n+    }\n+        \n+   \n+    public void addComplete(int rc, long ledgerId, long entryId, Object ctx) {\n+        this.removeEntryId((Integer) ctx);\n+    }\n+   \n+    public void readComplete(int rc, long ledgerId, Enumeration<LedgerEntry> seq, Object ctx){\n+        System.out.println(\"Read callback: \" + rc);\n+        while(seq.hasMoreElements()){\n+            LedgerEntry le = seq.nextElement();\n+            LOG.debug(new String(le.getEntry()));\n+        }\n+        synchronized(ctx){\n+            ctx.notify();\n+        }\n+    }\n+}"},{"sha":"910bd54e2d6a7071dfea8c4bc3991fc294c2630d","filename":"bookkeeper/README.txt","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/README.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/README.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/README.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,62 @@\n+BookKeeper README\n+\n+1- Overview\n+BookKeeper is a highly available logging service. As many critical services rely upon write-ahead logs to provide persistence along with high performance, an alternative to make such a service highly available despite the failures of individual servers it to offload write-ahead logs to an external service. \n+\n+This is exactly what BookKeeper provides. With BookKeeper, a service (or application) writes to a set of servers dedicated to storing such logs. An example of such an application is the Namenode of the Hadoop Distributed File System. \n+\n+The main components of BookKeeper are:\n+* Client: Applications interact with BookKeeper through the interface of of a BookKeeper client;\n+* Ledger: A ledger is our equivalent to a log file. Clients read entries from and write entries to ledgers;  \n+* Bookie: Bookies are BookKeeper servers and they store the content of ledgers. Typically there are multiple bookies implementing a ledger.\n+\n+2- How to compile\n+Run \"ant\" from \"trunk/contrib/bookkeeper\". This will generate the bookkeeper jar in \"trunk/build/contrib/bookkeeper\".\n+\n+3- Setting up\n+\n+A typical BookKeeper configuration includes a set of bookies and a ZooKeeper ensemble, where the ZooKeeper instance stores metadata for BookKeeper. As an example of such metadata, BookKeeper clients learn about available bookies by consulting a ZooKeeper service. \n+\n+To set up BookKeeper, follow these steps:\n+* Once bookies and ZooKeeper servers are running, create two znodes: \"/ledgers\" and \"/ledgers/available\". \n+* To run a bookie, run the java class \"org.apache.bookkeeper.proto.BookieServer\". It takes 3 parameters: a port, one directory path for transaction logs, and one directory path for indexes and data. Here is an example: java -cp .:bookkeeper.jar:../ZooKeeper/zookeeper-<version>.jar:/usr/local/apache-log4j-1.2.15/log4j-1.2.15.jar -Dlog4j.configuration=log4j.properties org.apache.bookkeeper.proto.BookieServer 3181 /disk1/bk/ /disk2/bk/\n+* For each bookie b, if <host> is the host name of b and <port> is the bookie port, then create a znode \"/ledgers/available/<host>:<port>\".\n+* It is ready to run! \n+\n+For test purposes, there is a class named \"org.apache.bookkeeper.util.LocalBookkeeper\" which runs a custom number on BookKeeper servers, along with a ZooKeeper server, on a single node. A typical invocation would be: \n+java -cp:<classpath> org.apache.bookkeeper.util.LocalBookKeeper <number-of-bookies>\n+\n+4- Developing applications\n+\n+BookKeeper is written in Java. When implementing an application that uses BookKeeper, follow these steps:\n+\n+a. Instantiate a BookKeeper object. The single parameter to the BookKeeper constructor is a list of ZooKeeper servers;\n+b. Once we have a BookKeeper object, we can create a ledger with createLedger. The default call to createLedger takes a single parameter, which is supposed to be for password authentication, but currently it has no effect. A call to createLedger returns a ledger handle (type LedgerHandle);\n+c. Once we have a ledger, we can write to the ledger by calling either addEntry or asyncAddEntry. The first call is synchronous, whereas the second call is asynchronous, and both write byte arrays as entries. To use the asynchronous version, the application has to implement the AddCallback interface;\n+d. Ideally, once the application finishes writing to the ledger, it should close it by calling close on the ledger handle. If it doesn't then BookKeeper will try to recover the ledger when a client tries to open it. By closing the ledger properly, we avoid this recovery step, which is recommended but not mandatory;\n+e. Before reading from a ledger, a client has to open it by calling openLedger on a BookKeeper object, and readEntries or asycnReadEntries to read entries. Both read calls take as input two entry numbers, n1 and n2, and return all entries from n1 through n2.   \n+\n+Here is a simple example of a method that creates a BookKeeper object, creates a ledger, writes an entry to the ledger, and closes it:\n+\n+BookKeeper bk;\n+LedgerHandle lh;\n+\n+public void allInOne(String servers) throws KeeperException, IOException, InterruptedException{\n+        bk = new BookKeeper(servers);\n+        try{\n+          lh = bk.createLedger(new byte[] {'a', 'b'});\n+          bk.addEntry(lh, new byte[]{'a', 'b'});\n+          bk.close(lh);\n+        } catch (BKException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+5- Selecting quorum mode and number of bookies (advanced)\n+\n+There are two methods to store ledgers with BookKeeper:\n+\n+a. Self-verifying: Each entry includes a digest that is used to guarantee that upon a read, the value read is the same as the one written. This mode requires n > 2t bookies, and quorums of size t + 1. By default, a call to createLedger uses this method and 3 servers;\n+b. Generic: Entries do not include a digest, and it requires more replicas: n > 3t and quorums of size 2t + 1. \n+\n+The quorum mode and number of bookies can be selected through the createLedger method."},{"sha":"3f6d347b3aff04e2328eab2ebcbfdb33868dd200","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"added","additions":545,"deletions":0,"changes":545,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,545 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+\n+\n+\n+/**\n+ * Implements a bookie.\n+ *\n+ */\n+\n+public class Bookie extends Thread {\n+    HashMap<Long, LedgerDescriptor> ledgers = new HashMap<Long, LedgerDescriptor>();\n+    static Logger LOG = Logger.getLogger(Bookie.class);\n+    \n+    final File journalDirectory;\n+\n+    final File ledgerDirectories[];\n+    \n+    // ZK registration path for this bookie\n+    static final String BOOKIE_REGISTRATION_PATH = \"/ledgers/available/\";\n+\n+    // ZooKeeper client instance for the Bookie\n+    ZooKeeper zk;\n+    \n+    // Running flag\n+    private volatile boolean running = false;\n+\n+    public static class NoLedgerException extends IOException {\n+        private static final long serialVersionUID = 1L;\n+        private long ledgerId;\n+        public NoLedgerException(long ledgerId) {\n+            this.ledgerId = ledgerId;\n+        }\n+        public long getLedgerId() {\n+            return ledgerId;\n+        }\n+    }\n+    public static class NoEntryException extends IOException {\n+        private static final long serialVersionUID = 1L;\n+        private long ledgerId;\n+        private long entryId;\n+        public NoEntryException(long ledgerId, long entryId) {\n+            super(\"Entry \" + entryId + \" not found in \" + ledgerId);\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+        }\n+        public long getLedger() {\n+            return ledgerId;\n+        }\n+        public long getEntry() {\n+            return entryId;\n+        }\n+    }\n+\n+    EntryLogger entryLogger;\n+    LedgerCache ledgerCache;\n+    class SyncThread extends Thread {\n+        volatile boolean running = true;\n+        public SyncThread() {\n+            super(\"SyncThread\");\n+        }\n+        @Override\n+        public void run() {\n+            while(running) {\n+                synchronized(this) {\n+                    try {\n+                        wait(100);\n+                        if (!entryLogger.testAndClearSomethingWritten()) {\n+                            continue;\n+                        }\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        continue;\n+                    }\n+                }\n+                lastLogMark.markLog();\n+                try {\n+                    ledgerCache.flushLedger(true);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+                try {\n+                    entryLogger.flush();\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+                lastLogMark.rollLog();\n+            }\n+        }\n+    }\n+    SyncThread syncThread = new SyncThread();\n+    public Bookie(int port, String zkServers, File journalDirectory, File ledgerDirectories[]) throws IOException {\n+        instantiateZookeeperClient(port, zkServers);\n+        this.journalDirectory = journalDirectory;\n+        this.ledgerDirectories = ledgerDirectories;\n+        entryLogger = new EntryLogger(ledgerDirectories, this);\n+        ledgerCache = new LedgerCache(ledgerDirectories);\n+        lastLogMark.readLog();\n+        final long markedLogId = lastLogMark.txnLogId;\n+        if (markedLogId > 0) {\n+            File logFiles[] = journalDirectory.listFiles();\n+            ArrayList<Long> logs = new ArrayList<Long>();\n+            for(File f: logFiles) {\n+                String name = f.getName();\n+                if (!name.endsWith(\".txn\")) {\n+                    continue;\n+                }\n+                String idString = name.split(\"\\\\.\")[0];\n+                long id = Long.parseLong(idString, 16);\n+                if (id < markedLogId) {\n+                    continue;\n+                }\n+                logs.add(id);\n+            }\n+            Collections.sort(logs);\n+            if (logs.size() == 0 || logs.get(0) != markedLogId) {\n+                throw new IOException(\"Recovery log \" + markedLogId + \" is missing\");\n+            }\n+            // TODO: When reading in the journal logs that need to be synced, we\n+            // should use BufferedChannels instead to minimize the amount of\n+            // system calls done.\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n+            for(Long id: logs) {\n+                FileChannel recLog = openChannel(id);\n+                while(true) {\n+                    lenBuff.clear();\n+                    fullRead(recLog, lenBuff);\n+                    if (lenBuff.remaining() != 0) {\n+                        break;\n+                    }\n+                    lenBuff.flip();\n+                    int len = lenBuff.getInt();\n+                    if (len == 0) {\n+                        break;\n+                    }\n+                    recBuff.clear();\n+                    if (recBuff.remaining() < len) {\n+                        recBuff = ByteBuffer.allocate(len);\n+                    }\n+                    recBuff.limit(len);\n+                    if (fullRead(recLog, recBuff) != len) {\n+                        // This seems scary, but it just means that this is where we\n+                        // left off writing\n+                        break;\n+                    }\n+                    recBuff.flip();\n+                    long ledgerId = recBuff.getLong();\n+                    // XXX we net to make sure we set the master keys appropriately!\n+                    LedgerDescriptor handle = getHandle(ledgerId, false);\n+                    try {\n+                        recBuff.rewind();\n+                        handle.addEntry(recBuff);\n+                    } finally {\n+                        putHandle(handle);\n+                    }\n+                }\n+            }\n+        }\n+        setDaemon(true);\n+        LOG.debug(\"I'm starting a bookie with journal directory \" + journalDirectory.getName());\n+        start();\n+        syncThread.start();\n+    }\n+\n+    /**\n+     * Instantiate the ZooKeeper client for the Bookie.\n+     */\n+    private void instantiateZookeeperClient(int port, String zkServers) throws IOException {\n+        if (zkServers == null) {\n+            LOG.warn(\"No ZK servers passed to Bookie constructor so BookKeeper clients won't know about this server!\");\n+            zk = null;\n+            return;\n+        }\n+        // Create the ZooKeeper client instance\n+        zk = new ZooKeeper(zkServers, 10000, new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                // TODO: handle session disconnects and expires\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n+                }\n+            }\n+        });\n+        // Create the ZK ephemeral node for this Bookie.\n+        try {\n+            zk.create(BOOKIE_REGISTRATION_PATH + InetAddress.getLocalHost().getHostAddress() + \":\" + port, new byte[0],\n+                    Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+        } catch (Exception e) {\n+            LOG.fatal(\"ZK exception registering ephemeral Znode for Bookie!\", e);\n+            // Throw an IOException back up. This will cause the Bookie\n+            // constructor to error out. Alternatively, we could do a System\n+            // exit here as this is a fatal error.\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private static int fullRead(FileChannel fc, ByteBuffer bb) throws IOException {\n+        int total = 0;\n+        while(bb.remaining() > 0) {\n+            int rc = fc.read(bb);\n+            if (rc <= 0) {\n+                return total;\n+            }\n+            total += rc;\n+        }\n+        return total;\n+    }\n+    private void putHandle(LedgerDescriptor handle) {\n+        synchronized (ledgers) {\n+            handle.decRef();\n+        }\n+    }\n+\n+    private LedgerDescriptor getHandle(long ledgerId, boolean readonly, byte[] masterKey) throws IOException {\n+        LedgerDescriptor handle = null;\n+        synchronized (ledgers) {\n+            handle = ledgers.get(ledgerId);\n+            if (handle == null) {\n+                if (readonly) {\n+                    throw new NoLedgerException(ledgerId);\n+                }\n+                handle = createHandle(ledgerId, readonly);\n+                ledgers.put(ledgerId, handle);\n+                handle.setMasterKey(ByteBuffer.wrap(masterKey));\n+            } \n+            handle.incRef();\n+        }\n+        return handle;\n+    }\n+    \n+    private LedgerDescriptor getHandle(long ledgerId, boolean readonly) throws IOException {\n+        LedgerDescriptor handle = null;\n+        synchronized (ledgers) {\n+            handle = ledgers.get(ledgerId);\n+            if (handle == null) {\n+                if (readonly) {\n+                    throw new NoLedgerException(ledgerId);\n+                }\n+                handle = createHandle(ledgerId, readonly);\n+                ledgers.put(ledgerId, handle);\n+            } \n+            handle.incRef();\n+        }\n+        return handle;\n+    }\n+    \n+\n+    private LedgerDescriptor createHandle(long ledgerId, boolean readOnly) throws IOException {\n+        return new LedgerDescriptor(ledgerId, entryLogger, ledgerCache);\n+    }\n+    \n+    static class QueueEntry {\n+        QueueEntry(ByteBuffer entry, long ledgerId, long entryId, \n+                WriteCallback cb, Object ctx) {\n+            this.entry = entry.duplicate();\n+            this.cb = cb;\n+            this.ctx = ctx;\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+        }\n+\n+        ByteBuffer entry;\n+        \n+        long ledgerId;\n+        \n+        long entryId;\n+\n+        WriteCallback cb;\n+\n+        Object ctx;\n+    }\n+\n+    LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n+\n+    public final static long preAllocSize = 4*1024*1024;\n+    \n+    public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n+    \n+    class LastLogMark {\n+        long txnLogId;\n+        long txnLogPosition;\n+        LastLogMark lastMark;\n+        LastLogMark(long logId, long logPosition) {\n+            this.txnLogId = logId;\n+            this.txnLogPosition = logPosition;\n+        }\n+        synchronized void setLastLogMark(long logId, long logPosition) {\n+            txnLogId = logId;\n+            txnLogPosition = logPosition;\n+        }\n+        synchronized void markLog() {\n+            lastMark = new LastLogMark(txnLogId, txnLogPosition);\n+        }\n+        synchronized void rollLog() {\n+            byte buff[] = new byte[16];\n+            ByteBuffer bb = ByteBuffer.wrap(buff);\n+            bb.putLong(txnLogId);\n+            bb.putLong(txnLogPosition);\n+            for(File dir: ledgerDirectories) {\n+                File file = new File(dir, \"lastMark\");\n+                try {\n+                    FileOutputStream fos = new FileOutputStream(file);\n+                    fos.write(buff);\n+                    fos.getChannel().force(true);\n+                    fos.close();\n+                } catch (IOException e) {\n+                    LOG.error(\"Problems writing to \" + file, e);\n+                }\n+            }\n+        }\n+        synchronized void readLog() {\n+            byte buff[] = new byte[16];\n+            ByteBuffer bb = ByteBuffer.wrap(buff);\n+            for(File dir: ledgerDirectories) {\n+                File file = new File(dir, \"lastMark\");\n+                try {\n+                    FileInputStream fis = new FileInputStream(file);\n+                    fis.read(buff);\n+                    fis.close();\n+                    bb.clear();\n+                    long i = bb.getLong();\n+                    long p = bb.getLong();\n+                    if (i > txnLogId) {\n+                        txnLogId = i;\n+                    }\n+                    if (p > txnLogPosition) {\n+                        txnLogPosition = p;\n+                    }\n+                } catch (IOException e) {\n+                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n+                }\n+            }\n+        }\n+    }\n+    \n+    private LastLogMark lastLogMark = new LastLogMark(0, 0);\n+    \n+    public boolean isRunning(){\n+        return running;\n+    }\n+    \n+    @Override\n+    public void run() {\n+        LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n+        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+        try {\n+            long logId = System.currentTimeMillis();\n+            FileChannel logFile = openChannel(logId);\n+            BufferedChannel bc = new BufferedChannel(logFile, 65536);\n+            zeros.clear();\n+            long nextPrealloc = preAllocSize;\n+            long lastFlushPosition = 0;\n+            logFile.write(zeros, nextPrealloc);\n+            running = true;\n+            // TODO: Currently, when we roll over the journal logs, the older\n+            // ones are never garbage collected. We should remove a journal log\n+            // once all of its entries have been synced with the entry logs.\n+            while (true) {\n+                QueueEntry qe = null;\n+                if (toFlush.isEmpty()) {\n+                    qe = queue.take();\n+                } else {\n+                    qe = queue.poll();\n+                    if (qe == null || bc.position() > lastFlushPosition + 512*1024) {\n+                        //logFile.force(false);\n+                        bc.flush(true);\n+                        lastFlushPosition = bc.position();\n+                        lastLogMark.setLastLogMark(logId, lastFlushPosition);\n+                        for (QueueEntry e : toFlush) {\n+                            e.cb.writeComplete(0, e.ledgerId, e.entryId, null, e.ctx);\n+                        }\n+                        toFlush.clear();\n+                    }\n+                }\n+                if (qe == null) {\n+                    continue;\n+                }\n+                lenBuff.clear();\n+                lenBuff.putInt(qe.entry.remaining());\n+                lenBuff.flip();\n+                //\n+                // we should be doing the following, but then we run out of\n+                // direct byte buffers\n+                // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n+                bc.write(lenBuff);\n+                bc.write(qe.entry);\n+                if (bc.position() > nextPrealloc) {\n+                    nextPrealloc = (logFile.size() / preAllocSize + 1) * preAllocSize;\n+                    zeros.clear();\n+                    logFile.write(zeros, nextPrealloc);\n+                }\n+                toFlush.add(qe);\n+            }\n+        } catch (Exception e) {\n+            LOG.fatal(\"Bookie thread exiting\", e);\n+        }\n+        running = false;\n+    }\n+\n+    private FileChannel openChannel(long logId) throws FileNotFoundException {\n+        FileChannel logFile = new RandomAccessFile(new File(journalDirectory,\n+                Long.toHexString(logId) + \".txn\"),\n+                \"rw\").getChannel();\n+        return logFile;\n+    }\n+\n+    public void shutdown() throws InterruptedException {\n+        // Shutdown the ZK client\n+        if(zk != null) zk.close();\n+        this.interrupt();\n+        this.join();\n+        syncThread.running = false;\n+        syncThread.join();\n+        for(LedgerDescriptor d: ledgers.values()) {\n+            d.close();\n+        }\n+        // Shutdown the EntryLogger which has the GarbageCollector Thread running\n+        entryLogger.shutdown();\n+    }\n+    \n+    public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] masterKey)\n+            throws IOException, BookieException {\n+        long ledgerId = entry.getLong();\n+        LedgerDescriptor handle = getHandle(ledgerId, false, masterKey);\n+        \n+        if(!handle.cmpMasterKey(ByteBuffer.wrap(masterKey))){\n+            throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+        }\n+        try {\n+            entry.rewind();\n+            long entryId = handle.addEntry(entry);\n+            entry.rewind();\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Adding \" + entryId + \"@\" + ledgerId);\n+            }\n+            queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n+        } finally {\n+            putHandle(handle);\n+        }\n+    }\n+\n+    public ByteBuffer readEntry(long ledgerId, long entryId) throws IOException {\n+        LedgerDescriptor handle = getHandle(ledgerId, true);\n+        try {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Reading \" + entryId + \"@\" + ledgerId);\n+            }\n+            return handle.readEntry(entryId);\n+        } finally {\n+            putHandle(handle);\n+        }\n+    }\n+\n+    // The rest of the code is test stuff\n+    static class CounterCallback implements WriteCallback {\n+        int count;\n+\n+        synchronized public void writeComplete(int rc, long l, long e, InetSocketAddress addr, Object ctx) {\n+            count--;\n+            if (count == 0) {\n+                notifyAll();\n+            }\n+        }\n+\n+        synchronized public void incCount() {\n+            count++;\n+        }\n+\n+        synchronized public void waitZero() throws InterruptedException {\n+            while (count > 0) {\n+                wait();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param args\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    public static void main(String[] args) throws IOException,\n+            InterruptedException, BookieException {\n+        Bookie b = new Bookie(5000, null, new File(\"/tmp\"), new File[] { new File(\"/tmp\") });\n+        CounterCallback cb = new CounterCallback();\n+        long start = System.currentTimeMillis();\n+        for (int i = 0; i < 100000; i++) {\n+            ByteBuffer buff = ByteBuffer.allocate(1024);\n+            buff.putLong(1);\n+            buff.putLong(i);\n+            buff.limit(1024);\n+            buff.position(0);\n+            cb.incCount();\n+            b.addEntry(buff, cb, null, new byte[0]);\n+        }\n+        cb.waitZero();\n+        long end = System.currentTimeMillis();\n+        System.out.println(\"Took \" + (end-start) + \"ms\");\n+    }\n+}"},{"sha":"d60f40f48048b0f571e6a2359bd4095188d0a4bf","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BookieException.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,81 @@\n+package org.apache.bookkeeper.bookie;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+ \n+ \n+ import java.lang.Exception;\n+ \n+ @SuppressWarnings(\"serial\")\n+public abstract class BookieException extends Exception {\n+\n+    private int code;\n+    public BookieException(int code){\n+        this.code = code;\n+    }\n+    \n+    public static BookieException create(int code){\n+        switch(code){\n+        case Code.UnauthorizedAccessException:\n+            return new BookieUnauthorizedAccessException();\n+        default:\n+            return new BookieIllegalOpException();\n+        }\n+    }\n+    \n+    public interface Code {\n+        int OK = 0;\n+        int UnauthorizedAccessException = -1;\n+        \n+        int IllegalOpException = -100;\n+    }\n+    \n+    public void setCode(int code){\n+        this.code = code;\n+    }\n+    \n+    public int getCode(){\n+        return this.code;\n+    }\n+    \n+    public String getMessage(int code){\n+        switch(code){\n+        case Code.OK:\n+            return \"No problem\";\n+        case Code.UnauthorizedAccessException:\n+            return \"Error while reading ledger\";\n+        default:\n+            return \"Invalid operation\";\n+        }\n+    }\n+    \n+    public static class BookieUnauthorizedAccessException extends BookieException {\n+        public BookieUnauthorizedAccessException(){\n+            super(Code.UnauthorizedAccessException);\n+        }   \n+    }\n+    \n+    public static class BookieIllegalOpException extends BookieException {\n+        public BookieIllegalOpException(){\n+            super(Code.UnauthorizedAccessException);\n+        }   \n+    }\n+}\n\\ No newline at end of file"},{"sha":"c025ebe2366e71044f71bd54a43839d71b083793","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,168 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * Provides a buffering layer in front of a FileChannel.\n+ */\n+public class BufferedChannel \n+{\n+    ByteBuffer writeBuffer;\n+    ByteBuffer readBuffer;\n+    private FileChannel bc;\n+    long position;\n+    int capacity;\n+    long readBufferStartPosition;\n+    long writeBufferStartPosition;\n+    BufferedChannel(FileChannel bc, int capacity) throws IOException {\n+        this.bc = bc;\n+        this.capacity = capacity;\n+        position = bc.position();\n+        writeBufferStartPosition = position;\n+    }\n+/*    public void close() throws IOException {\n+        bc.close();\n+    }\n+*/\n+//    public boolean isOpen() {\n+//        return bc.isOpen();\n+//    }\n+\n+    synchronized public int write(ByteBuffer src) throws IOException {\n+        int copied = 0;\n+        if (writeBuffer == null) {\n+            writeBuffer = ByteBuffer.allocateDirect(capacity);\n+        }\n+        while(src.remaining() > 0) {\n+            int truncated = 0;\n+            if (writeBuffer.remaining() < src.remaining()) {\n+                truncated = src.remaining() - writeBuffer.remaining();\n+                src.limit(src.limit()-truncated);\n+            }\n+            copied += src.remaining();\n+            writeBuffer.put(src);\n+            src.limit(src.limit()+truncated);\n+            if (writeBuffer.remaining() == 0) {\n+                writeBuffer.flip();\n+                bc.write(writeBuffer);\n+                writeBuffer.clear();\n+                writeBufferStartPosition = bc.position();\n+            }\n+        }\n+        position += copied;\n+        return copied;\n+    }\n+    \n+    public long position() {\n+        return position;\n+    }\n+    \n+    /**\n+     * Retrieve the current size of the underlying FileChannel\n+     * \n+     * @return FileChannel size measured in bytes\n+     * \n+     * @throws IOException if some I/O error occurs reading the FileChannel\n+     */\n+    public long size() throws IOException {\n+        return bc.size();\n+    }\n+    \n+    public void flush(boolean sync) throws IOException {\n+        synchronized(this) {\n+            if (writeBuffer == null) {\n+                return;\n+            }\n+            writeBuffer.flip();\n+            bc.write(writeBuffer);\n+            writeBuffer.clear();\n+            writeBufferStartPosition = bc.position();\n+        }\n+        if (sync) {\n+            bc.force(false);\n+        }\n+    }\n+\n+    /*public Channel getInternalChannel() {\n+        return bc;\n+    }*/\n+    synchronized public int read(ByteBuffer buff, long pos) throws IOException {\n+        if (readBuffer == null) {\n+            readBuffer = ByteBuffer.allocateDirect(capacity);\n+            readBufferStartPosition = Long.MIN_VALUE;\n+        }\n+        int rc = buff.remaining();\n+        while(buff.remaining() > 0) {\n+            // check if it is in the write buffer    \n+            if (writeBuffer != null && writeBufferStartPosition <= pos) {\n+                long positionInBuffer = pos - writeBufferStartPosition;\n+                long bytesToCopy = writeBuffer.position()-positionInBuffer;\n+                if (bytesToCopy > buff.remaining()) {\n+                    bytesToCopy = buff.remaining();\n+                }\n+                if (bytesToCopy == 0) {\n+                    throw new IOException(\"Read past EOF\");\n+                }\n+                ByteBuffer src = writeBuffer.duplicate();\n+                src.position((int) positionInBuffer);\n+                src.limit((int) (positionInBuffer+bytesToCopy));\n+                buff.put(src);\n+                pos+= bytesToCopy;\n+                // first check if there is anything we can grab from the readBuffer\n+            } else if (readBufferStartPosition <= pos && pos < readBufferStartPosition+readBuffer.capacity()) {\n+                long positionInBuffer = pos - readBufferStartPosition;\n+                long bytesToCopy = readBuffer.capacity()-positionInBuffer;\n+                if (bytesToCopy > buff.remaining()) {\n+                    bytesToCopy = buff.remaining();\n+                }\n+                ByteBuffer src = readBuffer.duplicate();\n+                src.position((int) positionInBuffer);\n+                src.limit((int) (positionInBuffer+bytesToCopy));\n+                buff.put(src);\n+                pos += bytesToCopy;\n+            // let's read it\n+            } else {\n+                readBufferStartPosition = pos;\n+                readBuffer.clear();\n+                // make sure that we don't overlap with the write buffer\n+                if (readBufferStartPosition + readBuffer.capacity() >= writeBufferStartPosition) {\n+                    readBufferStartPosition = writeBufferStartPosition - readBuffer.capacity();\n+                    if (readBufferStartPosition < 0) {\n+                        readBuffer.put(LedgerEntryPage.zeroPage, 0, (int)-readBufferStartPosition);\n+                    }\n+                }\n+                while(readBuffer.remaining() > 0) {\n+                    if (bc.read(readBuffer, readBufferStartPosition+readBuffer.position()) <= 0) {\n+                        throw new IOException(\"Short read\");\n+                    }\n+                }\n+                readBuffer.put(LedgerEntryPage.zeroPage, 0, readBuffer.remaining());\n+                readBuffer.clear();\n+            }\n+        }\n+        return rc;\n+    }\n+}"},{"sha":"30e5e161ae1cb6b0773ee6758688b2da6646fe48","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"added","additions":487,"deletions":0,"changes":487,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,487 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+\n+/**\n+ * This class manages the writing of the bookkeeper entries. All the new\n+ * entries are written to a common log. The LedgerCache will have pointers\n+ * into files created by this class with offsets into the files to find\n+ * the actual ledger entry. The entry log files created by this class are\n+ * identified by a long.\n+ */\n+public class EntryLogger {\n+    private static final Logger LOG = Logger.getLogger(EntryLogger.class);\n+    private File dirs[];\n+    // This is a handle to the Bookie parent instance. We need this to get\n+    // access to the LedgerCache as well as the ZooKeeper client handle.\n+    private final Bookie bookie;\n+\n+    private long logId;\n+    /**\n+     * The maximum size of a entry logger file.\n+     */\n+    final static long LOG_SIZE_LIMIT = Long.getLong(\"logSizeLimit\", 2 * 1024 * 1024 * 1024L);\n+    private volatile BufferedChannel logChannel;\n+    /**\n+     * The 1K block at the head of the entry logger file\n+     * that contains the fingerprint and (future) meta-data\n+     */\n+    final static int LOGFILE_HEADER_SIZE = 1024;\n+    final ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n+\n+    // this indicates that a write has happened since the last flush\n+    private volatile boolean somethingWritten = false;\n+\n+    // ZK ledgers related String constants\n+    static final String LEDGERS_PATH = \"/ledgers\";\n+    static final String LEDGER_NODE_PREFIX = \"L\";\n+    static final String AVAILABLE_NODE = \"available\";\n+\n+    // Maps entry log files to the set of ledgers that comprise the file.\n+    private ConcurrentMap<Long, ConcurrentHashMap<Long, Boolean>> entryLogs2LedgersMap = new ConcurrentHashMap<Long, ConcurrentHashMap<Long, Boolean>>();\n+    // This is the thread that garbage collects the entry logs that do not\n+    // contain any active ledgers in them.\n+    GarbageCollectorThread gcThread = new GarbageCollectorThread();\n+    // This is how often we want to run the Garbage Collector Thread (in milliseconds). \n+    // This should be passed as a System property. Default it to 1000 ms (1sec).\n+    final static int gcWaitTime = Integer.getInteger(\"gcWaitTime\", 1000);\n+\n+    /**\n+     * Create an EntryLogger that stores it's log files in the given\n+     * directories\n+     */\n+    public EntryLogger(File dirs[], Bookie bookie) throws IOException {\n+        this.dirs = dirs;\n+        this.bookie = bookie;\n+        // Initialize the entry log header buffer. This cannot be a static object\n+        // since in our unit tests, we run multiple Bookies and thus EntryLoggers\n+        // within the same JVM. All of these Bookie instances access this header\n+        // so there can be race conditions when entry logs are rolled over and\n+        // this header buffer is cleared before writing it into the new logChannel.\n+        LOGFILE_HEADER.put(\"BKLO\".getBytes());\n+        // Find the largest logId\n+        for(File f: dirs) {\n+            long lastLogId = getLastLogId(f);\n+            if (lastLogId >= logId) {\n+                logId = lastLogId+1;\n+            }\n+        }\n+        createLogId(logId);\n+        // Start the Garbage Collector thread to prune unneeded entry logs.\n+        gcThread.start();\n+    }\n+    \n+    /**\n+     * Maps entry log files to open channels.\n+     */\n+    private ConcurrentHashMap<Long, BufferedChannel> channels = new ConcurrentHashMap<Long, BufferedChannel>();\n+\n+    /**\n+     * This is the garbage collector thread that runs in the background to\n+     * remove any entry log files that no longer contains any active ledger.\n+     */\n+    class GarbageCollectorThread extends Thread {\n+        volatile boolean running = true;\n+\n+        public GarbageCollectorThread() {\n+            super(\"GarbageCollectorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (running) {\n+                synchronized (this) {\n+                    try {\n+                        wait(gcWaitTime);\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        continue;\n+                    }\n+                }\n+                // Initialization check. No need to run any logic if we are still starting up.\n+                if (entryLogs2LedgersMap.isEmpty() || bookie.ledgerCache == null\n+                        || bookie.ledgerCache.activeLedgers == null) {\n+                    continue;\n+                }\n+                // First sync ZK to make sure we're reading the latest active/available ledger nodes.\n+                bookie.zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"ZK error syncing the ledgers node when getting children: \", KeeperException\n+                                    .create(KeeperException.Code.get(rc), path));\n+                            return;\n+                        }\n+                        // Sync has completed successfully so now we can poll ZK \n+                        // and read in the latest set of active ledger nodes.\n+                        List<String> ledgerNodes;\n+                        try {\n+                            ledgerNodes = bookie.zk.getChildren(LEDGERS_PATH, null);\n+                        } catch (Exception e) {\n+                            LOG.error(\"Error polling ZK for the available ledger nodes: \", e);\n+                            // We should probably wait a certain amount of time before retrying in case of temporary issues.\n+                            return;\n+                        }\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Retrieved current set of ledger nodes: \" + ledgerNodes);\n+                        }\n+                        // Convert the ZK retrieved ledger nodes to a HashSet for easier comparisons.\n+                        HashSet<Long> allActiveLedgers = new HashSet<Long>(ledgerNodes.size(), 1.0f);\n+                        for (String ledgerNode : ledgerNodes) {\n+                            try {\n+                                // The available node is also stored in this path so ignore that.\n+                                // That node is the path for the set of available Bookie Servers.\n+                                if (ledgerNode.equals(AVAILABLE_NODE))\n+                                    continue;\n+                                String parts[] = ledgerNode.split(LEDGER_NODE_PREFIX);\n+                                allActiveLedgers.add(Long.parseLong(parts[parts.length - 1]));\n+                            } catch (NumberFormatException e) {\n+                                LOG.fatal(\"Error extracting ledgerId from ZK ledger node: \" + ledgerNode);\n+                                // This is a pretty bad error as it indicates a ledger node in ZK\n+                                // has an incorrect format. For now just continue and consider\n+                                // this as a non-existent ledger.\n+                                continue;\n+                            }\n+                        }\n+                        ConcurrentMap<Long, Boolean> curActiveLedgers = bookie.ledgerCache.activeLedgers;\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"All active ledgers from ZK: \" + allActiveLedgers);\n+                            LOG.debug(\"Current active ledgers from Bookie: \" + curActiveLedgers.keySet());\n+                        }\n+                        // Remove any active ledgers that don't exist in ZK.\n+                        for (Long ledger : curActiveLedgers.keySet()) {\n+                            if (!allActiveLedgers.contains(ledger)) {\n+                                // Remove it from the current active ledgers set and also from all \n+                                // LedgerCache data references to the ledger, i.e. the physical ledger index file.\n+                                LOG.info(\"Removing a non-active/deleted ledger: \" + ledger);\n+                                curActiveLedgers.remove(ledger);\n+                                try {\n+                                    bookie.ledgerCache.deleteLedger(ledger);\n+                                } catch (IOException e) {\n+                                    LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n+                                }\n+                            }\n+                        }\n+                        // Loop through all of the entry logs and remove the non-active ledgers.\n+                        for (Long entryLogId : entryLogs2LedgersMap.keySet()) {\n+                            ConcurrentHashMap<Long, Boolean> entryLogLedgers = entryLogs2LedgersMap.get(entryLogId);\n+                            for (Long entryLogLedger : entryLogLedgers.keySet()) {\n+                                // Remove the entry log ledger from the set if it isn't active.\n+                                if (!bookie.ledgerCache.activeLedgers.containsKey(entryLogLedger)) {\n+                                    entryLogLedgers.remove(entryLogLedger);\n+                                }\n+                            }\n+                            if (entryLogLedgers.isEmpty()) {\n+                                // This means the entry log is not associated with any active ledgers anymore.\n+                                // We can remove this entry log file now.\n+                                LOG.info(\"Deleting entryLogId \" + entryLogId + \" as it has no active ledgers!\");\n+                                File entryLogFile;\n+                                try {\n+                                    entryLogFile = findFile(entryLogId);\n+                                } catch (FileNotFoundException e) {\n+                                    LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n+                                            + entryLogId + \".log\");\n+                                    continue;\n+                                }\n+                                entryLogFile.delete();\n+                                channels.remove(entryLogId);\n+                                entryLogs2LedgersMap.remove(entryLogId);\n+                            }\n+                        }\n+                    };\n+                }, null);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Creates a new log file with the given id.\n+     */\n+    private void createLogId(long logId) throws IOException {\n+        List<File> list = Arrays.asList(dirs);\n+        Collections.shuffle(list);\n+        File firstDir = list.get(0);\n+        if (logChannel != null) {\n+            logChannel.flush(true);\n+        }\n+        logChannel = new BufferedChannel(new RandomAccessFile(new File(firstDir, Long.toHexString(logId)+\".log\"), \"rw\").getChannel(), 64*1024);\n+        logChannel.write((ByteBuffer) LOGFILE_HEADER.clear());\n+        channels.put(logId, logChannel);\n+        for(File f: dirs) {\n+            setLastLogId(f, logId);\n+        }\n+        // Extract all of the ledger ID's that comprise all of the entry logs\n+        // (except for the current new one which is still being written to).\n+        extractLedgersFromEntryLogs();\n+    }\n+\n+    /**\n+     * writes the given id to the \"lastId\" file in the given directory.\n+     */\n+    private void setLastLogId(File dir, long logId) throws IOException {\n+        FileOutputStream fos;\n+        fos = new FileOutputStream(new File(dir, \"lastId\"));\n+        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));\n+        try {\n+            bw.write(Long.toHexString(logId) + \"\\n\");\n+            bw.flush();\n+        } finally {\n+            try {\n+                fos.close();\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * reads id from the \"lastId\" file in the given directory.\n+     */\n+    private long getLastLogId(File f) {\n+        FileInputStream fis;\n+        try {\n+            fis = new FileInputStream(new File(f, \"lastId\"));\n+        } catch (FileNotFoundException e) {\n+            return -1;\n+        }\n+        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+        try {\n+            String lastIdString = br.readLine();\n+            return Long.parseLong(lastIdString);\n+        } catch (IOException e) {\n+            return -1;\n+        } catch(NumberFormatException e) {\n+            return -1;\n+        } finally {\n+            try {\n+                fis.close();\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+    \n+    private void openNewChannel() throws IOException {\n+        createLogId(++logId);\n+    }\n+    \n+    synchronized void flush() throws IOException {\n+        if (logChannel != null) {\n+            logChannel.flush(true);\n+        }\n+    }\n+    synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n+        if (logChannel.position() + entry.remaining() + 4 > LOG_SIZE_LIMIT) {\n+            openNewChannel();\n+        }\n+        ByteBuffer buff = ByteBuffer.allocate(4);\n+        buff.putInt(entry.remaining());\n+        buff.flip();\n+        logChannel.write(buff);\n+        long pos = logChannel.position();\n+        logChannel.write(entry);\n+        //logChannel.flush(false);\n+        somethingWritten = true;\n+        return (logId << 32L) | pos;\n+    }\n+    \n+    byte[] readEntry(long ledgerId, long entryId, long location) throws IOException {\n+        long entryLogId = location >> 32L;\n+        long pos = location & 0xffffffffL;\n+        ByteBuffer sizeBuff = ByteBuffer.allocate(4);\n+        pos -= 4; // we want to get the ledgerId and length to check\n+        BufferedChannel fc;\n+        try {\n+            fc = getChannelForLogId(entryLogId);\n+        } catch (FileNotFoundException e) {\n+            FileNotFoundException newe = new FileNotFoundException(e.getMessage() + \" for \" + ledgerId + \" with location \" + location);\n+            newe.setStackTrace(e.getStackTrace());\n+            throw newe;\n+        }\n+        if (fc.read(sizeBuff, pos) != sizeBuff.capacity()) {\n+            throw new IOException(\"Short read from entrylog \" + entryLogId);\n+        }\n+        pos += 4;\n+        sizeBuff.flip();\n+        int entrySize = sizeBuff.getInt();\n+        // entrySize does not include the ledgerId\n+        if (entrySize > 1024*1024) {\n+            LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \" + entryLogId);\n+            \n+        }\n+        byte data[] = new byte[entrySize];\n+        ByteBuffer buff = ByteBuffer.wrap(data);\n+        int rc = fc.read(buff, pos);\n+        if ( rc != data.length) {\n+            throw new IOException(\"Short read for \" + ledgerId + \"@\" + entryId + \" in \" + entryLogId + \"@\" + pos + \"(\"+rc+\"!=\"+data.length+\")\");\n+        }\n+        buff.flip();\n+        long thisLedgerId = buff.getLong();\n+        if (thisLedgerId != ledgerId) {\n+            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry belongs to \" + thisLedgerId + \" not \" + ledgerId);\n+        }\n+        long thisEntryId = buff.getLong();\n+        if (thisEntryId != entryId) {\n+            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry is \" + thisEntryId + \" not \" + entryId);\n+        }\n+        \n+        return data;\n+    }\n+    \n+    private BufferedChannel getChannelForLogId(long entryLogId) throws IOException {\n+        BufferedChannel fc = channels.get(entryLogId);\n+        if (fc != null) {\n+            return fc;\n+        }\n+        File file = findFile(entryLogId);\n+        FileChannel newFc = new RandomAccessFile(file, \"rw\").getChannel();\n+        // If the file already exists before creating a BufferedChannel layer above it,\n+        // set the FileChannel's position to the end so the write buffer knows where to start.\n+        newFc.position(newFc.size());\n+        synchronized (channels) {\n+            fc = channels.get(entryLogId);\n+            if (fc != null){\n+                newFc.close();\n+                return fc;\n+            }\n+            fc = new BufferedChannel(newFc, 8192);\n+            channels.put(entryLogId, fc);\n+            return fc;\n+        }\n+    }\n+\n+    private File findFile(long logId) throws FileNotFoundException {\n+        for(File d: dirs) {\n+            File f = new File(d, Long.toHexString(logId)+\".log\");\n+            if (f.exists()) {\n+                return f;\n+            }\n+        }\n+        throw new FileNotFoundException(\"No file for log \" + Long.toHexString(logId));\n+    }\n+    \n+    synchronized public boolean testAndClearSomethingWritten() {\n+        try {\n+            return somethingWritten;\n+        } finally {\n+            somethingWritten = false;\n+        }\n+    }\n+\n+    /**\n+     * Method to read in all of the entry logs (those that we haven't done so yet),\n+     * and find the set of ledger ID's that make up each entry log file.\n+     */\n+    private void extractLedgersFromEntryLogs() throws IOException {\n+        // Extract it for every entry log except for the current one.\n+        // Entry Log ID's are just a long value that starts at 0 and increments\n+        // by 1 when the log fills up and we roll to a new one.\n+        ByteBuffer sizeBuff = ByteBuffer.allocate(4);\n+        BufferedChannel bc;\n+        for (long entryLogId = 0; entryLogId < logId; entryLogId++) {\n+            // Comb the current entry log file if it has not already been extracted.\n+            if (entryLogs2LedgersMap.containsKey(entryLogId)) {\n+                continue;\n+            }\n+            LOG.info(\"Extracting the ledgers from entryLogId: \" + entryLogId);\n+            // Get the BufferedChannel for the current entry log file\n+            try {\n+                bc = getChannelForLogId(entryLogId);\n+            } catch (FileNotFoundException e) {\n+                // If we can't find the entry log file, just log a warning message and continue.\n+                // This could be a deleted/garbage collected entry log.\n+                LOG.warn(\"Entry Log file not found in log directories: \" + entryLogId + \".log\");\n+                continue;\n+            }\n+            // Start the read position in the current entry log file to be after\n+            // the header where all of the ledger entries are.\n+            long pos = LOGFILE_HEADER_SIZE;\n+            ConcurrentHashMap<Long, Boolean> entryLogLedgers = new ConcurrentHashMap<Long, Boolean>();\n+            // Read through the entry log file and extract the ledger ID's.\n+            while (true) {\n+                // Check if we've finished reading the entry log file.\n+                if (pos >= bc.size()) {\n+                    break;\n+                }\n+                if (bc.read(sizeBuff, pos) != sizeBuff.capacity()) {\n+                    throw new IOException(\"Short read from entrylog \" + entryLogId);\n+                }\n+                pos += 4;\n+                sizeBuff.flip();\n+                int entrySize = sizeBuff.getInt();\n+                if (entrySize > 1024 * 1024) {\n+                    LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \"\n+                            + entryLogId);\n+                }\n+                byte data[] = new byte[entrySize];\n+                ByteBuffer buff = ByteBuffer.wrap(data);\n+                int rc = bc.read(buff, pos);\n+                if (rc != data.length) {\n+                    throw new IOException(\"Short read for entryLog \" + entryLogId + \"@\" + pos + \"(\" + rc + \"!=\"\n+                            + data.length + \")\");\n+                }\n+                buff.flip();\n+                long ledgerId = buff.getLong();\n+                entryLogLedgers.put(ledgerId, true);\n+                // Advance position to the next entry and clear sizeBuff.\n+                pos += entrySize;\n+                sizeBuff.clear();\n+            }\n+            LOG.info(\"Retrieved all ledgers that comprise entryLogId: \" + entryLogId + \", values: \" + entryLogLedgers);\n+            entryLogs2LedgersMap.put(entryLogId, entryLogLedgers);\n+        }\n+    }\n+\n+    /**\n+     * Shutdown method to gracefully stop all threads spawned in this class and exit.\n+     * \n+     * @throws InterruptedException if there is an exception stopping threads.\n+     */\n+    public void shutdown() throws InterruptedException {\n+        gcThread.running = false;\n+        gcThread.interrupt();\n+        gcThread.join();\n+    }\n+\n+}"},{"sha":"310bef04b808e68e127e8884f5446eea39237f52","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,124 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * This is the file handle for a ledger's index file that maps entry ids to location.\n+ * It is used by LedgerCache.\n+ */\n+class FileInfo {\n+    private FileChannel fc;\n+    private final File lf;\n+    /**\n+     * The fingerprint of a ledger index file\n+     */\n+    private byte header[] = \"BKLE\\0\\0\\0\\0\".getBytes();\n+    static final long START_OF_DATA = 1024;\n+    private long size;\n+    private int useCount;\n+    private boolean isClosed;\n+    public FileInfo(File lf) throws IOException {\n+        this.lf = lf;\n+        fc = new RandomAccessFile(lf, \"rws\").getChannel();\n+        size = fc.size();\n+        if (size == 0) {\n+            fc.write(ByteBuffer.wrap(header));\n+        }\n+    }\n+\n+    synchronized public long size() {\n+        long rc = size-START_OF_DATA;\n+        if (rc < 0) {\n+            rc = 0;\n+        }\n+        return rc;\n+    }\n+\n+    synchronized public int read(ByteBuffer bb, long position) throws IOException {\n+        int total = 0;\n+        while(bb.remaining() > 0) {\n+            int rc = fc.read(bb, position+START_OF_DATA);\n+            if (rc <= 0) {\n+                throw new IOException(\"Short read\");\n+            }\n+            total += rc;\n+        }\n+        return total;\n+    }\n+\n+    synchronized public void close() throws IOException {\n+        isClosed = true;\n+        if (useCount == 0) {\n+            fc.close();\n+        }\n+    }\n+\n+    synchronized public long write(ByteBuffer[] buffs, long position) throws IOException {\n+        long total = 0;\n+        try {\n+            fc.position(position+START_OF_DATA);\n+            while(buffs[buffs.length-1].remaining() > 0) {\n+                long rc = fc.write(buffs);\n+                if (rc <= 0) {\n+                    throw new IOException(\"Short write\");\n+                }\n+                total += rc;\n+            }\n+        } finally {\n+            long newsize = position+START_OF_DATA+total;\n+            if (newsize > size) {\n+                size = newsize;\n+            }\n+        }\n+        return total;\n+    }\n+\n+    synchronized public void use() {\n+        useCount++;\n+    }\n+    \n+    synchronized public void release() {\n+        useCount--;\n+        if (isClosed && useCount == 0) {\n+            try {\n+                fc.close();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Getter to a handle on the actual ledger index file.\n+     * This is used when we are deleting a ledger and want to physically remove the index file.\n+     */\n+    File getFile() {\n+        return lf;\n+    }\n+\n+}"},{"sha":"bb9ac45d1f7bc8313150254cece6f7991e6b966f","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"added","additions":536,"deletions":0,"changes":536,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,536 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * This class maps a ledger entry number into a location (entrylogid, offset) in\n+ * an entry log file. It does user level caching to more efficiently manage disk\n+ * head scheduling.\n+ */\n+public class LedgerCache {\n+    private final static Logger LOG = Logger.getLogger(LedgerDescriptor.class);\n+    \n+    final File ledgerDirectories[];\n+\n+    public LedgerCache(File ledgerDirectories[]) {\n+        this.ledgerDirectories = ledgerDirectories;\n+        // Retrieve all of the active ledgers.\n+        getActiveLedgers();\n+    }\n+    /**\n+     * the list of potentially clean ledgers\n+     */\n+    LinkedList<Long> cleanLedgers = new LinkedList<Long>();\n+    \n+    /**\n+     * the list of potentially dirty ledgers\n+     */\n+    LinkedList<Long> dirtyLedgers = new LinkedList<Long>();\n+    \n+    HashMap<Long, FileInfo> fileInfoCache = new HashMap<Long, FileInfo>();\n+    \n+    LinkedList<Long> openLedgers = new LinkedList<Long>();\n+    \n+    // Stores the set of active (non-deleted) ledgers.\n+    ConcurrentMap<Long, Boolean> activeLedgers = new ConcurrentHashMap<Long, Boolean>();\n+\n+    static int OPEN_FILE_LIMIT = 900;\n+    static {\n+        if (System.getProperty(\"openFileLimit\") != null) {\n+            OPEN_FILE_LIMIT = Integer.parseInt(System.getProperty(\"openFileLimit\"));\n+        }\n+        LOG.info(\"openFileLimit is \" + OPEN_FILE_LIMIT);\n+    }\n+    \n+    // allocate half of the memory to the page cache\n+    private static int pageLimit = (int)(Runtime.getRuntime().maxMemory() / 3) / LedgerEntryPage.PAGE_SIZE;\n+    static {\n+        LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n+        if (System.getProperty(\"pageLimit\") != null) {\n+            pageLimit = Integer.parseInt(System.getProperty(\"pageLimit\"));\n+        }\n+        LOG.info(\"pageLimit is \" + pageLimit);\n+    }\n+    // The number of pages that have actually been used\n+    private int pageCount;\n+    HashMap<Long, HashMap<Long,LedgerEntryPage>> pages = new HashMap<Long, HashMap<Long,LedgerEntryPage>>();\n+    \n+    private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, LedgerEntryPage lep) {\n+        HashMap<Long, LedgerEntryPage> map = table.get(lep.getLedger());\n+        if (map == null) {\n+            map = new HashMap<Long, LedgerEntryPage>();\n+            table.put(lep.getLedger(), map);\n+        }\n+        map.put(lep.getFirstEntry(), lep);\n+    }\n+    \n+    private static LedgerEntryPage getFromTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, Long ledger, Long firstEntry) {\n+        HashMap<Long, LedgerEntryPage> map = table.get(ledger);\n+        if (map != null) {\n+            return map.get(firstEntry);\n+        }\n+        return null;\n+    }\n+    \n+   synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n+        LedgerEntryPage lep = getFromTable(pages, ledger, firstEntry);\n+        try {\n+            if (onlyDirty && lep.isClean()) {\n+                return null;\n+            }\n+            return lep;\n+        } finally {\n+            if (lep != null) {\n+                lep.usePage();\n+            }\n+        }\n+    }\n+\n+   public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n+        int offsetInPage = (int) (entry%LedgerEntryPage.ENTRIES_PER_PAGES);\n+        // find the id of the first entry of the page that has the entry\n+        // we are looking for\n+        long pageEntry = entry-offsetInPage;\n+        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        if (lep == null) {\n+            // find a free page\n+            lep = grabCleanPage(ledger, pageEntry);\n+            updatePage(lep);\n+            synchronized(this) {\n+                putIntoTable(pages, lep);\n+            }\n+        }\n+        if (lep != null) {\n+            lep.setOffset(offset, offsetInPage*8);\n+            lep.releasePage();\n+            return;\n+        }\n+    }\n+    \n+    public long getEntryOffset(long ledger, long entry) throws IOException {\n+        int offsetInPage = (int) (entry%LedgerEntryPage.ENTRIES_PER_PAGES);\n+        // find the id of the first entry of the page that has the entry\n+        // we are looking for\n+        long pageEntry = entry-offsetInPage;\n+        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        try {\n+            if (lep == null) {\n+                lep = grabCleanPage(ledger, pageEntry);\n+                synchronized(this) {\n+                    putIntoTable(pages, lep);\n+                }\n+                updatePage(lep);\n+                \n+            }\n+            return lep.getOffset(offsetInPage*8);\n+        } finally {\n+            if (lep != null) {\n+                lep.releasePage();\n+            }\n+        }\n+    }\n+    \n+    static final private String getLedgerName(long ledgerId) {\n+        int parent = (int) (ledgerId & 0xff);\n+        int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(Integer.toHexString(grandParent));\n+        sb.append('/');\n+        sb.append(Integer.toHexString(parent));\n+        sb.append('/');\n+        sb.append(Long.toHexString(ledgerId));\n+        sb.append(\".idx\");\n+        return sb.toString();\n+    }\n+    \n+    static final private void checkParents(File f) throws IOException {\n+        File parent = f.getParentFile();\n+        if (parent.exists()) {\n+            return;\n+        }\n+        if (parent.mkdirs() == false) {\n+            throw new IOException(\"Counldn't mkdirs for \" + parent);\n+        }\n+    }\n+    \n+    static final private Random rand = new Random();\n+\n+    static final private File pickDirs(File dirs[]) {\n+        return dirs[rand.nextInt(dirs.length)];\n+    }\n+\n+    FileInfo getFileInfo(Long ledger, boolean create) throws IOException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledger);\n+            if (fi == null) {\n+                String ledgerName = getLedgerName(ledger);\n+                File lf = null;\n+                for(File d: ledgerDirectories) {\n+                    lf = new File(d, ledgerName);\n+                    if (lf.exists()) {\n+                        break;\n+                    }\n+                    lf = null;\n+                }\n+                if (lf == null) {\n+                    if (!create) {\n+                        throw new Bookie.NoLedgerException(ledger);\n+                    }\n+                    File dir = pickDirs(ledgerDirectories);\n+                    lf = new File(dir, ledgerName);\n+                    checkParents(lf);\n+                    // A new ledger index file has been created for this Bookie.\n+                    // Add this new ledger to the set of active ledgers.\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"New ledger index file created for ledgerId: \" + ledger);\n+                    }\n+                    activeLedgers.put(ledger, true);\n+                }\n+                if (openLedgers.size() > OPEN_FILE_LIMIT) {\n+                    fileInfoCache.remove(openLedgers.removeFirst()).close();\n+                }\n+                fi = new FileInfo(lf);\n+                fileInfoCache.put(ledger, fi);\n+                openLedgers.add(ledger);\n+            }\n+            if (fi != null) {\n+                fi.use();\n+            }\n+            return fi;\n+        }\n+    }\n+    private void updatePage(LedgerEntryPage lep) throws IOException {\n+        if (!lep.isClean()) {\n+            throw new IOException(\"Trying to update a dirty page\");\n+        }\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(lep.getLedger(), true);\n+            long pos = lep.getFirstEntry()*8;\n+            if (pos >= fi.size()) {\n+                lep.zeroPage();\n+            } else {\n+                lep.readPage(fi);\n+            }\n+        } finally {\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    void flushLedger(boolean doAll) throws IOException {\n+        synchronized(dirtyLedgers) {\n+            if (dirtyLedgers.isEmpty()) {\n+                synchronized(this) {\n+                    for(Long l: pages.keySet()) {\n+                        if (LOG.isTraceEnabled()) {\n+                            LOG.trace(\"Adding \" + Long.toHexString(l) + \" to dirty pages\");\n+                        }\n+                        dirtyLedgers.add(l);\n+                    }\n+                }\n+            }\n+            if (dirtyLedgers.isEmpty()) {\n+                return;\n+            }\n+            while(!dirtyLedgers.isEmpty()) {\n+                Long l = dirtyLedgers.removeFirst();\n+                LinkedList<Long> firstEntryList;\n+                synchronized(this) {\n+                    HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n+                    if (pageMap == null || pageMap.isEmpty()) {\n+                        continue;\n+                    }\n+                    firstEntryList = new LinkedList<Long>();\n+                    for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n+                        LedgerEntryPage lep = entry.getValue();\n+                        if (lep.isClean()) {\n+                            if (LOG.isTraceEnabled()) {\n+                                LOG.trace(\"Page is clean \" + lep);\n+                            }\n+                            continue;\n+                        }\n+                        firstEntryList.add(lep.getFirstEntry());\n+                    }\n+                }\n+                // Now flush all the pages of a ledger\n+                List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n+                FileInfo fi = null;\n+                try {\n+                    for(Long firstEntry: firstEntryList) {\n+                        LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n+                        if (lep != null) {\n+                            entries.add(lep);\n+                        }\n+                    }\n+                    Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n+                        @Override\n+                        public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n+                            return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n+                        }});\n+                    ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n+                    fi = getFileInfo(l, true);\n+                    int start = 0;\n+                    long lastOffset = -1;\n+                    for(int i = 0; i < entries.size(); i++) {\n+                        versions.add(i, entries.get(i).getVersion());\n+                        if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != LedgerEntryPage.ENTRIES_PER_PAGES) {\n+                            // send up a sequential list\n+                            int count = i - start;\n+                            if (count == 0) {\n+                                System.out.println(\"Count cannot possibly be zero!\");\n+                            }\n+                            writeBuffers(l, entries, fi, start, count);\n+                            start = i;\n+                        }\n+                        lastOffset = entries.get(i).getFirstEntry();\n+                    }\n+                    if (entries.size()-start == 0 && entries.size() != 0) {\n+                        System.out.println(\"Nothing to write, but there were entries!\");\n+                    }\n+                    writeBuffers(l, entries, fi, start, entries.size()-start);\n+                    synchronized(this) {\n+                        for(int i = 0; i < entries.size(); i++) {\n+                            LedgerEntryPage lep = entries.get(i);\n+                            lep.setClean(versions.get(i));\n+                        }\n+                    }\n+                } finally {\n+                    for(LedgerEntryPage lep: entries) {\n+                        lep.releasePage();\n+                    }\n+                    if (fi != null) {\n+                        fi.release();\n+                    }\n+                }\n+                if (!doAll) {\n+                    break;\n+                }\n+                // Yeild. if we are doing all the ledgers we don't want to block other flushes that\n+                // need to happen\n+                try {\n+                    dirtyLedgers.wait(1);\n+                } catch (InterruptedException e) {\n+                    // just pass it on\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+        }\n+    }\n+    \n+    private void writeBuffers(Long ledger,\n+            List<LedgerEntryPage> entries, FileInfo fi,\n+            int start, int count) throws IOException {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Writing \" + count + \" buffers of \" + Long.toHexString(ledger));\n+        }\n+        if (count == 0) {\n+            //System.out.println(\"Count is zero!\");\n+            return;\n+        }\n+        ByteBuffer buffs[] = new ByteBuffer[count];\n+        for(int j = 0; j < count; j++) {\n+            buffs[j] = entries.get(start+j).getPageToWrite();\n+            if (entries.get(start+j).getLedger() != ledger) {\n+                throw new IOException(\"Writing to \" + ledger + \" but page belongs to \" + entries.get(start+j).getLedger());\n+            }\n+        }\n+        long totalWritten = 0;\n+        while(buffs[buffs.length-1].remaining() > 0) {\n+            long rc = fi.write(buffs, entries.get(start+0).getFirstEntry()*8);\n+            if (rc <= 0) {\n+                throw new IOException(\"Short write to ledger \" + ledger + \" rc = \" + rc);\n+            }\n+            //System.out.println(\"Wrote \" + rc + \" to \" + ledger);\n+            totalWritten += rc;\n+        }\n+        if (totalWritten != count*LedgerEntryPage.PAGE_SIZE) {\n+            throw new IOException(\"Short write to ledger \" + ledger + \" wrote \" + totalWritten + \" expected \" + count*LedgerEntryPage.PAGE_SIZE);\n+        }\n+    }\n+    private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOException {\n+        if (entry % LedgerEntryPage.ENTRIES_PER_PAGES != 0) {\n+            throw new IllegalArgumentException(entry + \" is not a multiple of \" + LedgerEntryPage.ENTRIES_PER_PAGES);\n+        }\n+        synchronized(this) {\n+            if (pageCount  < pageLimit) {\n+                // let's see if we can allocate something\n+                LedgerEntryPage lep = new LedgerEntryPage();\n+                lep.setLedger(ledger);\n+                lep.setFirstEntry(entry);\n+                // note, this will not block since it is a new page\n+                lep.usePage();\n+                pageCount++;\n+                return lep;\n+            }\n+        }\n+        \n+        outerLoop:\n+        while(true) {\n+            synchronized(cleanLedgers) {\n+                if (cleanLedgers.isEmpty()) {\n+                    flushLedger(false);\n+                    synchronized(this) {\n+                        for(Long l: pages.keySet()) {\n+                            cleanLedgers.add(l);\n+                        }\n+                    }\n+                }\n+                synchronized(this) {\n+                    Long cleanLedger = cleanLedgers.getFirst();\n+                    Map<Long, LedgerEntryPage> map = pages.get(cleanLedger);\n+                    if (map == null || map.isEmpty()) {\n+                        cleanLedgers.removeFirst();\n+                        continue;\n+                    }\n+                    Iterator<Map.Entry<Long, LedgerEntryPage>> it = map.entrySet().iterator();\n+                    LedgerEntryPage lep = it.next().getValue();\n+                    while((lep.inUse() || !lep.isClean())) {\n+                        if (it.hasNext()) {\n+                            continue outerLoop;\n+                        }\n+                        lep = it.next().getValue();\n+                    }\n+                    it.remove();\n+                    if (map.isEmpty()) {\n+                        pages.remove(lep.getLedger());\n+                    }\n+                    lep.usePage();\n+                    lep.zeroPage();\n+                    lep.setLedger(ledger);\n+                    lep.setFirstEntry(entry);\n+                    return lep;\n+                }\n+            }\n+        }\n+    }\n+\n+    public long getLastEntry(long ledgerId) {\n+        long lastEntry = 0;\n+        // Find the last entry in the cache\n+        synchronized(this) {\n+            Map<Long, LedgerEntryPage> map = pages.get(ledgerId);\n+            if (map != null) {\n+                for(LedgerEntryPage lep: map.values()) {\n+                    if (lep.getFirstEntry() + LedgerEntryPage.ENTRIES_PER_PAGES < lastEntry) {\n+                        continue;\n+                    }\n+                    lep.usePage();\n+                    long highest = lep.getLastEntry();\n+                    if (highest > lastEntry) {\n+                        lastEntry = highest;\n+                    }\n+                    lep.releasePage();\n+                }\n+            }\n+        }\n+        \n+        return lastEntry;\n+    }\n+\n+    /**\n+     * This method will look within the ledger directories for the ledger index\n+     * files. That will comprise the set of active ledgers this particular\n+     * BookieServer knows about that have not yet been deleted by the BookKeeper\n+     * Client. This is called only once during initialization.\n+     */\n+    private void getActiveLedgers() {\n+        // Ledger index files are stored in a file hierarchy with a parent and\n+        // grandParent directory. We'll have to go two levels deep into these\n+        // directories to find the index files.\n+        for (File ledgerDirectory : ledgerDirectories) {\n+            for (File grandParent : ledgerDirectory.listFiles()) {\n+                if (grandParent.isDirectory()) {\n+                    for (File parent : grandParent.listFiles()) {\n+                        if (parent.isDirectory()) {\n+                            for (File index : parent.listFiles()) {\n+                                if (!index.isFile() || !index.getName().endsWith(\".idx\")) {\n+                                    continue;\n+                                }\n+                                // We've found a ledger index file. The file name is the \n+                                // HexString representation of the ledgerId.\n+                                String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n+                                activeLedgers.put(Long.parseLong(ledgerIdInHex, 16), true);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Active ledgers found: \" + activeLedgers);\n+        }\n+    }\n+    \n+    /**\n+     * This method is called whenever a ledger is deleted by the BookKeeper Client\n+     * and we want to remove all relevant data for it stored in the LedgerCache.\n+     */\n+    void deleteLedger(long ledgerId) throws IOException {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Deleting ledgerId: \" + ledgerId);\n+        // Delete the ledger's index file and close the FileInfo\n+        FileInfo fi = getFileInfo(ledgerId, false);\n+        fi.getFile().delete();\n+        fi.close();\n+\n+        // Remove it from the activeLedgers set\n+        activeLedgers.remove(ledgerId);\n+\n+        // Now remove it from all the other lists and maps. \n+        // These data structures need to be synchronized first before removing entries. \n+        synchronized(this) {\n+            pages.remove(ledgerId);\n+        }\n+        synchronized(fileInfoCache) {\n+            fileInfoCache.remove(ledgerId);\n+        }\n+        synchronized(cleanLedgers) {\n+            cleanLedgers.remove(ledgerId);\n+        }\n+        synchronized(dirtyLedgers) {\n+            dirtyLedgers.remove(ledgerId);\n+        }\n+        synchronized(openLedgers) {\n+            openLedgers.remove(ledgerId);\n+        }\n+    }\n+\n+}"},{"sha":"653b34be37f3cd5d7063b59f3ec92c4abb11cbc6","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,133 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.log4j.Logger;\n+\n+\n+\n+/**\n+ * Implements a ledger inside a bookie. In particular, it implements operations\n+ * to write entries to a ledger and read entries from a ledger.\n+ *\n+ */\n+public class LedgerDescriptor {\n+    final static Logger LOG = Logger.getLogger(LedgerDescriptor.class);\n+    LedgerCache ledgerCache;\n+    LedgerDescriptor(long ledgerId, EntryLogger entryLogger, LedgerCache ledgerCache) {\n+        this.ledgerId = ledgerId;\n+        this.entryLogger = entryLogger;\n+        this.ledgerCache = ledgerCache;\n+    }\n+    \n+    private ByteBuffer masterKey = null;\n+    \n+    void setMasterKey(ByteBuffer masterKey){\n+        this.masterKey = masterKey;\n+    }\n+    \n+    boolean cmpMasterKey(ByteBuffer masterKey){\n+        return this.masterKey.equals(masterKey);\n+    }\n+    \n+    private long ledgerId;\n+    EntryLogger entryLogger;\n+    private int refCnt;\n+    synchronized public void incRef() {\n+        refCnt++;\n+    }\n+    synchronized public void decRef() {\n+        refCnt--;\n+    }\n+    synchronized public int getRefCnt() {\n+        return refCnt;\n+    }\n+    long addEntry(ByteBuffer entry) throws IOException {\n+        long ledgerId = entry.getLong();\n+        if (ledgerId != this.ledgerId) {\n+            throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n+        }\n+        long entryId = entry.getLong();\n+        entry.rewind();\n+        \n+        /*\n+         * Log the entry\n+         */\n+        long pos = entryLogger.addEntry(ledgerId, entry);\n+        \n+        \n+        /*\n+         * Set offset of entry id to be the current ledger position\n+         */\n+        ledgerCache.putEntryOffset(ledgerId, entryId, pos);\n+        return entryId;\n+    }\n+    ByteBuffer readEntry(long entryId) throws IOException {\n+        long offset;\n+        /*\n+         * If entryId is -1, then return the last written.\n+         */\n+        if (entryId == -1) {\n+            long lastEntry = ledgerCache.getLastEntry(ledgerId);\n+            FileInfo fi = null;\n+            try {\n+                fi = ledgerCache.getFileInfo(ledgerId, false);\n+                long size = fi.size();\n+                // we may not have the last entry in the cache\n+                if (size > lastEntry*8) {\n+                    ByteBuffer bb = ByteBuffer.allocate(LedgerEntryPage.PAGE_SIZE);\n+                    long position = size-LedgerEntryPage.PAGE_SIZE;\n+                    if (position < 0) {\n+                        position = 0;\n+                    }\n+                    fi.read(bb, position);\n+                    bb.flip();\n+                    long startingEntryId = position/8;\n+                    for(int i = LedgerEntryPage.ENTRIES_PER_PAGES-1; i >= 0; i--) {\n+                        if (bb.getLong(i*8) != 0) {\n+                            if (lastEntry < startingEntryId+i) {\n+                                lastEntry = startingEntryId+i;\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            } finally {\n+                if (fi != null) {\n+                    fi.release();\n+                }\n+            }\n+            entryId = lastEntry;\n+        }\n+        \n+        offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n+        if (offset == 0) {\n+            throw new Bookie.NoEntryException(ledgerId, entryId);\n+        }\n+        return ByteBuffer.wrap(entryLogger.readEntry(ledgerId, entryId, offset));\n+    }\n+    void close() {\n+    }\n+}"},{"sha":"58847eb4872d199a1b948a78bee346781dafda2a","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,151 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This is a page in the LedgerCache. It holds the locations\n+ * (entrylogfile, offset) for entry ids.\n+ */\n+public class LedgerEntryPage {\n+    public static final int PAGE_SIZE = 8192;\n+    public static final int ENTRIES_PER_PAGES = PAGE_SIZE/8;\n+    private long ledger = -1;\n+    private long firstEntry = -1;\n+    private ByteBuffer page = ByteBuffer.allocateDirect(PAGE_SIZE);\n+    private boolean clean = true;\n+    private boolean pinned = false;\n+    private int useCount;\n+    private int version;\n+    \n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(getLedger());\n+        sb.append('@');\n+        sb.append(getFirstEntry());\n+        sb.append(clean ? \" clean \" : \" dirty \");\n+        sb.append(useCount);\n+        return sb.toString();\n+    }\n+    synchronized public void usePage() {\n+        useCount++;\n+    }\n+    synchronized public void pin() {\n+        pinned = true;\n+    }\n+    synchronized public void unpin() {\n+        pinned = false;\n+    }\n+    synchronized public boolean isPinned() {\n+        return pinned;\n+    }\n+    synchronized public void releasePage() {\n+        useCount--;\n+        if (useCount < 0) {\n+            throw new IllegalStateException(\"Use count has gone below 0\");\n+        }\n+    }\n+    synchronized private void checkPage() {\n+        if (useCount <= 0) {\n+            throw new IllegalStateException(\"Page not marked in use\");\n+        }\n+    }\n+    @Override\n+    public boolean equals(Object other) {\n+        LedgerEntryPage otherLEP = (LedgerEntryPage) other;\n+        return otherLEP.getLedger() == getLedger() && otherLEP.getFirstEntry() == getFirstEntry();\n+    }\n+    @Override\n+    public int hashCode() {\n+        return (int)getLedger() ^ (int)(getFirstEntry());\n+    }\n+    void setClean(int versionOfCleaning) {\n+        this.clean = (versionOfCleaning == version);\n+    }\n+    boolean isClean() {\n+        return clean;\n+    }\n+    public void setOffset(long offset, int position) {\n+        checkPage();\n+        version++;\n+        this.clean = false;\n+        page.putLong(position, offset);\n+    }\n+    public long getOffset(int position) {\n+        checkPage();\n+        return page.getLong(position);\n+    }\n+    static final byte zeroPage[] = new byte[64*1024];\n+    public void zeroPage() {\n+        checkPage();\n+        page.clear();\n+        page.put(zeroPage, 0, page.remaining());\n+        clean = true;\n+    }\n+    public void readPage(FileInfo fi) throws IOException {\n+        checkPage();\n+        page.clear();\n+        while(page.remaining() != 0) {\n+            if (fi.read(page, getFirstEntry()*8) <= 0) {\n+                throw new IOException(\"Short page read of ledger \" + getLedger() + \" tried to get \" + page.capacity() + \" from position \" + getFirstEntry()*8 + \" still need \" + page.remaining());\n+            }\n+        }\n+        clean = true;\n+    }\n+    public ByteBuffer getPageToWrite() {\n+        checkPage();\n+        page.clear();\n+        return page;\n+    }\n+    void setLedger(long ledger) {\n+        this.ledger = ledger;\n+    }\n+    long getLedger() {\n+        return ledger;\n+    }\n+    int getVersion() {\n+        return version;\n+    }\n+    void setFirstEntry(long firstEntry) {\n+        if (firstEntry % ENTRIES_PER_PAGES != 0) {\n+            throw new IllegalArgumentException(firstEntry + \" is not a multiple of \" + ENTRIES_PER_PAGES);\n+        }\n+        this.firstEntry = firstEntry;\n+    }\n+    long getFirstEntry() {\n+        return firstEntry;\n+    }\n+    public boolean inUse() {\n+        return useCount > 0;\n+    }\n+    public long getLastEntry() {\n+        for(int i = ENTRIES_PER_PAGES - 1; i >= 0; i--) {\n+            if (getOffset(i*8) > 0) {\n+                return i + firstEntry;\n+            }\n+        }\n+        return 0;\n+    }\n+}"},{"sha":"8ed63bb29f5b29260a8c69d2c05f6abd60ac6881","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","status":"added","additions":147,"deletions":0,"changes":147,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,147 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * This class is just a stub that can be used in collections with\n+ * FileChannels\n+ */\n+public class MarkerFileChannel extends FileChannel {\n+\n+    @Override\n+    public void force(boolean metaData) throws IOException {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public FileLock lock(long position, long size, boolean shared)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public MappedByteBuffer map(MapMode mode, long position, long size)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public long position() throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public FileChannel position(long newPosition) throws IOException {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public int read(ByteBuffer dst) throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public int read(ByteBuffer dst, long position) throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long read(ByteBuffer[] dsts, int offset, int length)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long size() throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long transferFrom(ReadableByteChannel src, long position, long count)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long transferTo(long position, long count, WritableByteChannel target)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public FileChannel truncate(long size) throws IOException {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public FileLock tryLock(long position, long size, boolean shared)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer src) throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer src, long position) throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long write(ByteBuffer[] srcs, int offset, int length)\n+            throws IOException {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void implCloseChannel() throws IOException {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+}"},{"sha":"07a2e58ea60a27f0d43bb26aace78fa56b5abbf2","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"added","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,126 @@\n+package org.apache.bookkeeper.client;\n+\n+import java.util.Enumeration;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+public interface AsyncCallback {\n+  public interface AddCallback {\n+    /**\n+     * Callback declaration\n+     * \n+     * @param rc\n+     *          return code\n+     * @param ledgerId\n+     *          ledger identifier\n+     * @param entryId\n+     *          entry identifier\n+     * @param ctx\n+     *          control object\n+     */\n+    void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n+  }\n+\n+  public interface CloseCallback {\n+    /**\n+     * Callback definition\n+     * \n+     * @param rc\n+     *          return code\n+     * @param ledgerId\n+     *          ledger identifier\n+     * @param ctx\n+     *          control object\n+     */\n+    void closeComplete(int rc, LedgerHandle lh, Object ctx);\n+  }\n+\n+  public interface CreateCallback {\n+    /**\n+     * Declaration of callback method\n+     * \n+     * @param rc\n+     *          return status\n+     * @param lh\n+     *          ledger handle\n+     * @param ctx\n+     *          control object\n+     */\n+\n+    void createComplete(int rc, LedgerHandle lh, Object ctx);\n+  }\n+\n+  public interface OpenCallback {\n+    /**\n+     * Callback for asynchronous call to open ledger\n+     * \n+     * @param rc\n+     *          Return code\n+     * @param lh\n+     *          ledger handle\n+     * @param ctx\n+     *          control object\n+     */\n+\n+    public void openComplete(int rc, LedgerHandle lh, Object ctx);\n+\n+  }\n+\n+  public interface ReadCallback {\n+    /**\n+     * Callback declaration\n+     * \n+     * @param rc\n+     *          return code\n+     * @param ledgerId\n+     *          ledger identifier\n+     * @param seq\n+     *          sequence of entries\n+     * @param ctx\n+     *          control object\n+     */\n+\n+    void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n+        Object ctx);\n+  }\n+  \n+  public interface DeleteCallback {\n+      /**\n+       * Callback definition for delete operations\n+       * \n+       * @param rc\n+       *          return code\n+       * @param ctx\n+       *          control object\n+       */\n+      void deleteComplete(int rc, Object ctx);\n+    }\n+\n+  public interface RecoverCallback {\n+      /**\n+       * Callback definition for bookie recover operations\n+       * \n+       * @param rc\n+       *          return code\n+       * @param ctx\n+       *          control object\n+       */\n+      void recoverComplete(int rc, Object ctx);\n+    }\n+\n+}"},{"sha":"4a0beacc8dd3d88b487ee1bf146fb3ae9e79cc58","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"added","additions":249,"deletions":0,"changes":249,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,249 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.lang.Exception;\n+\n+/**\n+ * Class the enumerates all the possible error conditions\n+ * \n+ */\n+\n+@SuppressWarnings(\"serial\")\n+public abstract class BKException extends Exception {\n+\n+    private int code;\n+\n+    BKException(int code) {\n+        this.code = code;\n+    }\n+\n+    /**\n+     * Create an exception from an error code\n+     * @param code return error code\n+     * @return correponding exception\n+     */\n+    public static BKException create(int code) {\n+        switch (code) {\n+        case Code.ReadException:\n+            return new BKReadException();\n+        case Code.QuorumException:\n+            return new BKQuorumException();\n+        case Code.NoBookieAvailableException:\n+            return new BKBookieException();\n+        case Code.DigestNotInitializedException:\n+            return new BKDigestNotInitializedException();\n+        case Code.DigestMatchException:\n+            return new BKDigestMatchException();\n+        case Code.NotEnoughBookiesException:\n+            return new BKNotEnoughBookiesException();\n+        case Code.NoSuchLedgerExistsException:\n+            return new BKNoSuchLedgerExistsException();\n+        case Code.BookieHandleNotAvailableException:\n+            return new BKBookieHandleNotAvailableException();\n+        case Code.ZKException:\n+            return new ZKException();\n+        case Code.LedgerRecoveryException:\n+            return new BKLedgerRecoveryException();\n+        case Code.LedgerClosedException:\n+            return new BKLedgerClosedException();\n+        case Code.WriteException:\n+            return new BKWriteException();\n+        case Code.NoSuchEntryException:\n+            return new BKNoSuchEntryException();\n+        case Code.IncorrectParameterException:\n+            return new BKIncorrectParameterException();\n+        case Code.InterruptedException:\n+            return new BKInterruptedException();\n+        default:\n+            return new BKIllegalOpException();\n+        }\n+    }\n+\n+    /**\n+     * List of return codes\n+     *\n+     */\n+    public interface Code {\n+        int OK = 0;\n+        int ReadException = -1;\n+        int QuorumException = -2;\n+        int NoBookieAvailableException = -3;\n+        int DigestNotInitializedException = -4;\n+        int DigestMatchException = -5;\n+        int NotEnoughBookiesException = -6;\n+        int NoSuchLedgerExistsException = -7;\n+        int BookieHandleNotAvailableException = -8;\n+        int ZKException = -9;\n+        int LedgerRecoveryException = -10;\n+        int LedgerClosedException = -11;\n+        int WriteException = -12;\n+        int NoSuchEntryException = -13;\n+        int IncorrectParameterException = -14;\n+        int InterruptedException = -15;\n+        \n+        int IllegalOpException = -100;\n+    }\n+\n+    public void setCode(int code) {\n+        this.code = code;\n+    }\n+\n+    public int getCode() {\n+        return this.code;\n+    }\n+\n+    public static String getMessage(int code) {\n+        switch (code) {\n+        case Code.OK:\n+            return \"No problem\";\n+        case Code.ReadException:\n+            return \"Error while reading ledger\";\n+        case Code.QuorumException:\n+            return \"Invalid quorum size on ensemble size\";\n+        case Code.NoBookieAvailableException:\n+            return \"Invalid quorum size on ensemble size\";\n+        case Code.DigestNotInitializedException:\n+            return \"Digest engine not initialized\";\n+        case Code.DigestMatchException:\n+            return \"Entry digest does not match\";\n+        case Code.NotEnoughBookiesException:\n+            return \"Not enough non-faulty bookies available\";\n+        case Code.NoSuchLedgerExistsException:\n+            return \"No such ledger exists\";\n+        case Code.BookieHandleNotAvailableException:\n+            return \"Bookie handle is not available\";\n+        case Code.ZKException:\n+            return \"Error while using ZooKeeper\";\n+        case Code.LedgerRecoveryException:\n+            return \"Error while recovering ledger\";\n+        case Code.LedgerClosedException:\n+            return \"Attempt to write to a closed ledger\";\n+        case Code.WriteException:\n+            return \"Write failed on bookie\";\n+        case Code.NoSuchEntryException:\n+            return \"No such entry\";\n+        case Code.IncorrectParameterException:\n+            return \"Incorrect parameter input\";\n+        case Code.InterruptedException:\n+            return \"Interrupted while waiting for permit\";\n+        default:\n+            return \"Invalid operation\";\n+        }\n+    }\n+\n+    public static class BKReadException extends BKException {\n+        public BKReadException() {\n+            super(Code.ReadException);\n+        }\n+    }\n+\n+    public static class BKNoSuchEntryException extends BKException {\n+        public BKNoSuchEntryException() {\n+            super(Code.NoSuchEntryException);\n+        }\n+    }\n+\n+    public static class BKQuorumException extends BKException {\n+        public BKQuorumException() {\n+            super(Code.QuorumException);\n+        }\n+    }\n+\n+    public static class BKBookieException extends BKException {\n+        public BKBookieException() {\n+            super(Code.NoBookieAvailableException);\n+        }\n+    }\n+\n+    public static class BKDigestNotInitializedException extends BKException {\n+        public BKDigestNotInitializedException() {\n+            super(Code.DigestNotInitializedException);\n+        }\n+    }\n+\n+    public static class BKDigestMatchException extends BKException {\n+        public BKDigestMatchException() {\n+            super(Code.DigestMatchException);\n+        }\n+    }\n+\n+    public static class BKIllegalOpException extends BKException {\n+        public BKIllegalOpException() {\n+            super(Code.IllegalOpException);\n+        }\n+    }\n+\n+    public static class BKNotEnoughBookiesException extends BKException {\n+        public BKNotEnoughBookiesException() {\n+            super(Code.NotEnoughBookiesException);\n+        }\n+    }\n+\n+    public static class BKWriteException extends BKException {\n+        public BKWriteException() {\n+            super(Code.WriteException);\n+        }\n+    }\n+\n+    public static class BKNoSuchLedgerExistsException extends BKException {\n+        public BKNoSuchLedgerExistsException() {\n+            super(Code.NoSuchLedgerExistsException);\n+        }\n+    }\n+\n+    public static class BKBookieHandleNotAvailableException extends BKException {\n+        public BKBookieHandleNotAvailableException() {\n+            super(Code.BookieHandleNotAvailableException);\n+        }\n+    }\n+\n+    public static class ZKException extends BKException {\n+        public ZKException() {\n+            super(Code.ZKException);\n+        }\n+    }\n+\n+    public static class BKLedgerRecoveryException extends BKException {\n+        public BKLedgerRecoveryException() {\n+            super(Code.LedgerRecoveryException);\n+        }\n+    }\n+\n+    public static class BKLedgerClosedException extends BKException {\n+        public BKLedgerClosedException() {\n+            super(Code.LedgerClosedException);\n+        }\n+    }\n+    \n+    public static class BKIncorrectParameterException extends BKException {\n+        public BKIncorrectParameterException() {\n+            super(Code.IncorrectParameterException);\n+        }\n+    }\n+    \n+    public static class BKInterruptedException extends BKException {\n+        public BKInterruptedException() {\n+            super(Code.InterruptedException);\n+        }\n+    }\n+}"},{"sha":"99166b89c7f7d9e9a0f7572aac651cb583d26c1e","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"added","additions":410,"deletions":0,"changes":410,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,410 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n+import org.apache.bookkeeper.client.BKException.Code;\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+/**\n+ * BookKeeper client. We assume there is one single writer to a ledger at any\n+ * time.\n+ * \n+ * There are four possible operations: start a new ledger, write to a ledger,\n+ * read from a ledger and delete a ledger.\n+ * \n+ * The exceptions resulting from synchronous calls and error code resulting from\n+ * asynchronous calls can be found in the class {@link BKException}.\n+ * \n+ * \n+ */\n+\n+public class BookKeeper implements OpenCallback, CreateCallback, DeleteCallback {\n+\n+  static final Logger LOG = Logger.getLogger(BookKeeper.class);\n+\n+  ZooKeeper zk = null;\n+  // whether the zk handle is one we created, or is owned by whoever\n+  // instantiated us\n+  boolean ownZKHandle = false;\n+\n+  ClientSocketChannelFactory channelFactory;\n+  // whether the socket factory is one we created, or is owned by whoever\n+  // instantiated us\n+  boolean ownChannelFactory = false;\n+\n+  BookieClient bookieClient;\n+  BookieWatcher bookieWatcher;\n+\n+  OrderedSafeExecutor callbackWorker = new OrderedSafeExecutor(Runtime\n+      .getRuntime().availableProcessors());\n+  OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime\n+      .getRuntime().availableProcessors());\n+\n+  /**\n+   * Create a bookkeeper client. A zookeeper client and a client socket factory\n+   * will be instantiated as part of this constructor.\n+   * \n+   * @param servers\n+   *          A list of one of more servers on which zookeeper is running. The\n+   *          client assumes that the running bookies have been registered with\n+   *          zookeeper under the path\n+   *          {@link BookieWatcher#BOOKIE_REGISTRATION_PATH}\n+   * @throws IOException\n+   * @throws InterruptedException\n+   * @throws KeeperException\n+   */\n+  public BookKeeper(String servers) throws IOException, InterruptedException,\n+      KeeperException {\n+    this(new ZooKeeper(servers, 10000, new Watcher() {\n+      @Override\n+      public void process(WatchedEvent event) {\n+        // TODO: handle session disconnects and expires\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n+        }\n+      }\n+    }), new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+        Executors.newCachedThreadPool()));\n+\n+    ownZKHandle = true;\n+    ownChannelFactory = true;\n+  }\n+\n+  /**\n+   * Create a bookkeeper client but use the passed in zookeeper client instead\n+   * of instantiating one.\n+   * \n+   * @param zk\n+   *          Zookeeper client instance connected to the zookeeper with which\n+   *          the bookies have registered\n+   * @throws InterruptedException\n+   * @throws KeeperException\n+   */\n+  public BookKeeper(ZooKeeper zk) throws InterruptedException, KeeperException {\n+    this(zk, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+        Executors.newCachedThreadPool()));\n+    ownChannelFactory = true;\n+  }\n+\n+  /**\n+   * Create a bookkeeper client but use the passed in zookeeper client and\n+   * client socket channel factory instead of instantiating those.\n+   * \n+   * @param zk\n+   *          Zookeeper client instance connected to the zookeeper with which\n+   *          the bookies have registered\n+   * @param channelFactory\n+   *          A factory that will be used to create connections to the bookies\n+   * @throws InterruptedException\n+   * @throws KeeperException\n+   */\n+  public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n+      throws InterruptedException, KeeperException {\n+    if (zk == null || channelFactory == null) {\n+      throw new NullPointerException();\n+    }\n+    this.zk = zk;\n+    this.channelFactory = channelFactory;\n+    bookieWatcher = new BookieWatcher(this);\n+    bookieWatcher.readBookiesBlocking();\n+    bookieClient = new BookieClient(channelFactory, mainWorkerPool);\n+  }\n+\n+  /**\n+   * There are 2 digest types that can be used for verification. The CRC32 is\n+   * cheap to compute but does not protect against byzantine bookies (i.e., a\n+   * bookie might report fake bytes and a matching CRC32). The MAC code is more\n+   * expensive to compute, but is protected by a password, i.e., a bookie can't\n+   * report fake bytes with a mathching MAC unless it knows the password\n+   */\n+  public enum DigestType {\n+    MAC, CRC32\n+  };\n+\n+  public ZooKeeper getZkHandle() {\n+    return zk;\n+  }\n+\n+  /**\n+   * Get the BookieClient, currently used for doing bookie recovery.\n+   * \n+   * @return BookieClient for the BookKeeper instance.\n+   */\n+  public BookieClient getBookieClient() {\n+      return bookieClient;\n+  }\n+  \n+  /**\n+   * Creates a new ledger asynchronously. To create a ledger, we need to specify\n+   * the ensemble size, the quorum size, the digest type, a password, a callback\n+   * implementation, and an optional control object. The ensemble size is how\n+   * many bookies the entries should be striped among and the quorum size is the\n+   * degree of replication of each entry. The digest type is either a MAC or a\n+   * CRC. Note that the CRC option is not able to protect a client against a\n+   * bookie that replaces an entry. The password is used not only to\n+   * authenticate access to a ledger, but also to verify entries in ledgers.\n+   * \n+   * @param ensSize\n+   *          ensemble size\n+   * @param qSize\n+   *          quorum size\n+   * @param digestType\n+   *          digest type, either MAC or CRC32\n+   * @param passwd\n+   *          password\n+   * @param cb\n+   *          createCallback implementation\n+   * @param ctx\n+   *          optional control object\n+   */\n+  public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,\n+      byte[] passwd, CreateCallback cb, Object ctx) {\n+\n+    new LedgerCreateOp(this, ensSize, qSize, digestType, passwd, cb, ctx)\n+        .initiate();\n+\n+  }\n+\n+  /**\n+   * Create callback implementation for synchronous create call.\n+   * \n+   * @param rc\n+   *          return code\n+   * @param lh\n+   *          ledger handle object\n+   * @param ctx\n+   *          optional control object\n+   */\n+  public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n+    SyncCounter counter = (SyncCounter) ctx;\n+    counter.setLh(lh);\n+    counter.setrc(rc);\n+    counter.dec();\n+  }\n+\n+  /**\n+   * Creates a new ledger. Default of 3 servers, and quorum of 2 servers.\n+   * \n+   * @param digestType\n+   *          digest type, either MAC or CRC32\n+   * @param passwd\n+   *          password\n+   * @return\n+   * @throws KeeperException\n+   * @throws InterruptedException\n+   * @throws BKException\n+   */\n+  public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n+      throws KeeperException, BKException, InterruptedException, IOException {\n+    return createLedger(3, 2, digestType, passwd);\n+  }\n+\n+  /**\n+   * Synchronous call to create ledger. Parameters match those of\n+   * {@link #asyncCreateLedger(int, int, DigestType, byte[], CreateCallback, Object)}\n+   * \n+   * @param ensSize\n+   * @param qSize\n+   * @param digestType\n+   * @param passwd\n+   * @return\n+   * @throws KeeperException\n+   * @throws InterruptedException\n+   * @throws IOException\n+   * @throws BKException\n+   */\n+  public LedgerHandle createLedger(int ensSize, int qSize,\n+      DigestType digestType, byte passwd[]) throws KeeperException,\n+      InterruptedException, IOException, BKException {\n+    SyncCounter counter = new SyncCounter();\n+    counter.inc();\n+    /*\n+     * Calls asynchronous version\n+     */\n+    asyncCreateLedger(ensSize, qSize, digestType, passwd, this, counter);\n+\n+    /*\n+     * Wait\n+     */\n+    counter.block(0);\n+    if (counter.getLh() == null) {\n+      LOG.error(\"ZooKeeper error: \" + counter.getrc());\n+      throw BKException.create(Code.ZKException);\n+    }\n+\n+    return counter.getLh();\n+  }\n+\n+  /**\n+   * Open existing ledger asynchronously for reading.\n+   * \n+   * @param lId\n+   *          ledger identifier\n+   * @param digestType\n+   *          digest type, either MAC or CRC32\n+   * @param passwd\n+   *          password\n+   * @param ctx\n+   *          optional control object\n+   */\n+  public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n+      OpenCallback cb, Object ctx) {\n+\n+    new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiate();\n+\n+  }\n+\n+  /**\n+   * Callback method for synchronous open operation\n+   * \n+   * @param rc\n+   *          return code\n+   * @param lh\n+   *          ledger handle\n+   * @param ctx\n+   *          optional control object\n+   */\n+  public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+    SyncCounter counter = (SyncCounter) ctx;\n+    counter.setLh(lh);\n+\n+    LOG.debug(\"Open complete: \" + rc);\n+\n+    counter.setrc(rc);\n+    counter.dec();\n+  }\n+\n+  /**\n+   * Synchronous open ledger call\n+   * \n+   * @param lId\n+   *          ledger identifier\n+   * @param digestType\n+   *          digest type, either MAC or CRC32\n+   * @param passwd\n+   *          password\n+   * @return\n+   * @throws InterruptedException\n+   * @throws BKException\n+   */\n+\n+  public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[])\n+      throws BKException, InterruptedException {\n+    SyncCounter counter = new SyncCounter();\n+    counter.inc();\n+\n+    /*\n+     * Calls async open ledger\n+     */\n+    asyncOpenLedger(lId, digestType, passwd, this, counter);\n+\n+    /*\n+     * Wait\n+     */\n+    counter.block(0);\n+    if (counter.getrc() != BKException.Code.OK)\n+      throw BKException.create(counter.getrc());\n+\n+    return counter.getLh();\n+  }\n+\n+  /**\n+   * Deletes a ledger asynchronously.\n+   * \n+   * @param lId\n+   *            ledger Id\n+   * @param cb\n+   *            deleteCallback implementation\n+   * @param ctx\n+   *            optional control object\n+   */\n+  public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) {\n+      new LedgerDeleteOp(this, lId, cb, ctx).initiate();\n+  }\n+  \n+  /**\n+   * Delete callback implementation for synchronous delete call.\n+   * \n+   * @param rc\n+   *            return code\n+   * @param ctx\n+   *            optional control object\n+   */\n+  public void deleteComplete(int rc, Object ctx) {\n+      SyncCounter counter = (SyncCounter) ctx;\n+      counter.setrc(rc);\n+      counter.dec();\n+  }\n+\n+  /**\n+   * Synchronous call to delete a ledger. Parameters match those of\n+   * {@link #asyncDeleteLedger(long, DeleteCallback, Object)}\n+   * \n+   * @param lId\n+   *            ledgerId\n+   * @throws InterruptedException\n+   * @throws BKException\n+   */\n+  public void deleteLedger(long lId) throws InterruptedException, BKException {\n+      SyncCounter counter = new SyncCounter();\n+      counter.inc();\n+      // Call asynchronous version\n+      asyncDeleteLedger(lId, this, counter);\n+      // Wait\n+      counter.block(0);\n+      if (counter.getrc() != KeeperException.Code.OK.intValue()) { \n+          LOG.error(\"ZooKeeper error deleting ledger node: \" + counter.getrc());\n+          throw BKException.create(Code.ZKException);\n+      }\n+  }\n+  \n+  /**\n+   * Shuts down client.\n+   * \n+   */\n+  public void halt() throws InterruptedException {\n+    bookieClient.close();\n+    bookieWatcher.halt();\n+    if (ownChannelFactory) {\n+      channelFactory.releaseExternalResources();\n+    }\n+    if (ownZKHandle) {\n+      zk.close();\n+    }\n+    callbackWorker.shutdown();\n+    mainWorkerPool.shutdown();\n+  }\n+}"},{"sha":"0063825d9c4ff3108399082bc2881476d01e6795","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"added","additions":204,"deletions":0,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,204 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.util.SafeRunnable;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.AsyncCallback.ChildrenCallback;\n+import org.apache.zookeeper.KeeperException.Code;\n+\n+/**\n+ * This class is responsible for maintaining a consistent view of what bookies\n+ * are available by reading Zookeeper (and setting watches on the bookie nodes).\n+ * When a bookie fails, the other parts of the code turn to this class to find a\n+ * replacement\n+ * \n+ */\n+class BookieWatcher implements Watcher, ChildrenCallback {\n+    static final Logger logger = Logger.getLogger(BookieWatcher.class);\n+    \n+    public static final String BOOKIE_REGISTRATION_PATH = \"/ledgers/available\";\n+    static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n+    public static int ZK_CONNECT_BACKOFF_SEC = 1;\n+\n+    BookKeeper bk;\n+    ScheduledExecutorService scheduler;\n+\n+    Set<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n+\n+    SafeRunnable reReadTask = new SafeRunnable() {\n+        @Override\n+        public void safeRun() {\n+            readBookies();\n+        }\n+    };\n+\n+    public BookieWatcher(BookKeeper bk) {\n+        this.bk = bk;\n+        this.scheduler = Executors.newSingleThreadScheduledExecutor();\n+    }\n+    \n+    public void halt(){\n+        scheduler.shutdown();\n+    }\n+\n+    public void readBookies() {\n+        readBookies(this);\n+    }\n+\n+    public void readBookies(ChildrenCallback callback) {\n+        bk.getZkHandle().getChildren( BOOKIE_REGISTRATION_PATH, this, callback, null);\n+    }\n+\n+    @Override\n+    public void process(WatchedEvent event) {\n+        readBookies();\n+    }\n+\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+\n+        if (rc != KeeperException.Code.OK.intValue()) {\n+            //logger.error(\"Error while reading bookies\", KeeperException.create(Code.get(rc), path));\n+            // try the read after a second again\n+            scheduler.schedule(reReadTask, ZK_CONNECT_BACKOFF_SEC, TimeUnit.SECONDS);\n+            return;\n+        }\n+\n+        // Read the bookie addresses into a set for efficient lookup\n+        Set<InetSocketAddress> newBookieAddrs = new HashSet<InetSocketAddress>();\n+        for (String bookieAddrString : children) {\n+            InetSocketAddress bookieAddr;\n+            try {\n+                bookieAddr = StringUtils.parseAddr(bookieAddrString);\n+            } catch (IOException e) {\n+                logger.error(\"Could not parse bookie address: \" + bookieAddrString + \", ignoring this bookie\");\n+                continue;\n+            }\n+            newBookieAddrs.add(bookieAddr);\n+        }\n+\n+        synchronized (this) {\n+            knownBookies = newBookieAddrs;\n+        }\n+    }\n+\n+    /**\n+     * Blocks until bookies are read from zookeeper, used in the {@link BookKeeper} constructor.\n+     * @throws InterruptedException\n+     * @throws KeeperException\n+     */\n+    public void readBookiesBlocking() throws InterruptedException, KeeperException {\n+        final LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>();\n+        readBookies(new ChildrenCallback() {\n+            public void processResult(int rc, String path, Object ctx, List<String> children) {\n+                try {\n+                    BookieWatcher.this.processResult(rc, path, ctx, children);\n+                    queue.put(rc);\n+                } catch (InterruptedException e) {\n+                    logger.error(\"Interruped when trying to read bookies in a blocking fashion\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        int rc = queue.take();\n+\n+        if (rc != KeeperException.Code.OK.intValue()) {\n+            throw KeeperException.create(Code.get(rc));\n+        }\n+    }\n+\n+    /**\n+     * Wrapper over the {@link #getAdditionalBookies(Set, int)} method when there is no exclusion list (or exisiting bookies)\n+     * @param numBookiesNeeded\n+     * @return\n+     * @throws BKNotEnoughBookiesException\n+     */\n+    public ArrayList<InetSocketAddress> getNewBookies(int numBookiesNeeded) throws BKNotEnoughBookiesException {\n+        return getAdditionalBookies(EMPTY_SET, numBookiesNeeded);\n+    }\n+\n+    /**\n+     * Wrapper over the {@link #getAdditionalBookies(Set, int)} method when you just need 1 extra bookie\n+     * @param existingBookies\n+     * @return\n+     * @throws BKNotEnoughBookiesException\n+     */\n+    public InetSocketAddress getAdditionalBookie(List<InetSocketAddress> existingBookies)\n+            throws BKNotEnoughBookiesException {\n+        return getAdditionalBookies(new HashSet<InetSocketAddress>(existingBookies), 1).get(0);\n+    }\n+\n+    /**\n+     * Returns additional bookies given an exclusion list and how many are needed\n+     * @param existingBookies\n+     * @param numAdditionalBookiesNeeded\n+     * @return\n+     * @throws BKNotEnoughBookiesException\n+     */\n+    public ArrayList<InetSocketAddress> getAdditionalBookies(Set<InetSocketAddress> existingBookies,\n+            int numAdditionalBookiesNeeded) throws BKNotEnoughBookiesException {\n+\n+        ArrayList<InetSocketAddress> newBookies = new ArrayList<InetSocketAddress>();\n+\n+        if (numAdditionalBookiesNeeded <= 0) {\n+            return newBookies;\n+        }\n+\n+        List<InetSocketAddress> allBookies;\n+\n+        synchronized (this) {\n+            allBookies = new ArrayList<InetSocketAddress>(knownBookies);\n+        }\n+\n+        Collections.shuffle(allBookies);\n+\n+        for (InetSocketAddress bookie : allBookies) {\n+            if (existingBookies.contains(bookie)) {\n+                continue;\n+            }\n+\n+            newBookies.add(bookie);\n+            numAdditionalBookiesNeeded--;\n+\n+            if (numAdditionalBookiesNeeded == 0) {\n+                return newBookies;\n+            }\n+        }\n+\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+}"},{"sha":"3014847f2ecd2c6df964617396033dad50f70ebc","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,50 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+\n+import java.nio.ByteBuffer;\n+import java.util.zip.CRC32;\n+\n+class CRC32DigestManager extends DigestManager {\n+    CRC32 crc = new CRC32();\n+    \n+    public CRC32DigestManager(long ledgerId) {\n+        super(ledgerId);\n+    }\n+\n+    @Override\n+    int getMacCodeLength() {\n+        return 8;\n+    }\n+    \n+    @Override\n+    byte[] getValueAndReset() {\n+        byte[] value = new byte[8];\n+        ByteBuffer buf = ByteBuffer.wrap(value);\n+        buf.putLong(crc.getValue());\n+        crc.reset();\n+        return value;\n+    }\n+    \n+    @Override\n+    void update(byte[] data, int offset, int length) {\n+        crc.update(data, offset, length);\n+    }\n+}"},{"sha":"61041581ec92b8b80be1740ae3d8bd5bee7a4925","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,184 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+\n+import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBufferInputStream;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+\n+/**\n+ * This class takes an entry, attaches a digest to it and packages it with relevant\n+ * data so that it can be shipped to the bookie. On the return side, it also\n+ * gets a packet, checks that the digest matches, and extracts the original entry\n+ * for the packet. Currently 2 types of digests are supported: MAC (based on SHA-1) and CRC32\n+ */\n+\n+public abstract class DigestManager {\n+    static final Logger logger = Logger.getLogger(DigestManager.class);\n+    \n+    static final int METADATA_LENGTH = 32;\n+    \n+    long ledgerId;\n+    \n+    abstract int getMacCodeLength();\n+    \n+    void update(byte[] data){\n+        update(data, 0, data.length);\n+    }\n+    \n+    abstract void update(byte[] data, int offset, int length);\n+    abstract byte[] getValueAndReset();\n+    \n+    final int macCodeLength;\n+\n+    public DigestManager(long ledgerId) {\n+        this.ledgerId = ledgerId;\n+        macCodeLength = getMacCodeLength();\n+    }\n+    \n+    static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digestType) throws GeneralSecurityException{\n+        switch(digestType){\n+        case MAC:\n+            return new MacDigestManager(ledgerId, passwd);\n+        case CRC32:\n+            return new CRC32DigestManager(ledgerId);\n+        default:\n+            throw new GeneralSecurityException(\"Unknown checksum type: \" + digestType);\n+        }\n+    }\n+\n+    /**\n+     * Computes the digest for an entry and put bytes together for sending.\n+     *  \n+     * @param entryId\n+     * @param lastAddConfirmed\n+     * @param length\n+     * @param data\n+     * @return\n+     */\n+    \n+    public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data) {\n+\n+        byte[] bufferArray = new byte[METADATA_LENGTH + macCodeLength];\n+        ByteBuffer buffer = ByteBuffer.wrap(bufferArray);\n+        buffer.putLong(ledgerId);\n+        buffer.putLong(entryId);\n+        buffer.putLong(lastAddConfirmed);\n+        buffer.putLong(length);\n+        buffer.flip();\n+\n+        update(buffer.array(), 0, METADATA_LENGTH);\n+        update(data);\n+        byte[] digest = getValueAndReset();\n+\n+        buffer.limit(buffer.capacity());\n+        buffer.position(METADATA_LENGTH);\n+        buffer.put(digest);\n+        buffer.flip();\n+\n+        return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer), ChannelBuffers.wrappedBuffer(data));\n+    }\n+\n+    private void verifyDigest(ChannelBuffer dataReceived) throws BKDigestMatchException {\n+        verifyDigest(-1, dataReceived, true);\n+    }\n+\n+    private void verifyDigest(long entryId, ChannelBuffer dataReceived) throws BKDigestMatchException {\n+        verifyDigest(entryId, dataReceived, false);\n+    }\n+\n+    private void verifyDigest(long entryId, ChannelBuffer dataReceived, boolean skipEntryIdCheck)\n+            throws BKDigestMatchException {\n+\n+        ByteBuffer dataReceivedBuffer = dataReceived.toByteBuffer();\n+        byte[] digest;\n+\n+        update(dataReceivedBuffer.array(), dataReceivedBuffer.position(), METADATA_LENGTH);\n+\n+        int offset = METADATA_LENGTH + macCodeLength;\n+        update(dataReceivedBuffer.array(), dataReceivedBuffer.position() + offset, dataReceived.readableBytes() - offset);\n+        digest = getValueAndReset();\n+\n+        for (int i = 0; i < digest.length; i++) {\n+            if (digest[i] != dataReceived.getByte(METADATA_LENGTH + i)) {\n+                logger.error(\"Mac mismatch for ledger-id: \" + ledgerId + \", entry-id: \" + entryId);\n+                throw new BKDigestMatchException();\n+            }\n+        }\n+\n+        long actualLedgerId = dataReceived.readLong();\n+        long actualEntryId = dataReceived.readLong();\n+\n+        if (actualLedgerId != ledgerId) {\n+            logger.error(\"Ledger-id mismatch in authenticated message, expected: \" + ledgerId + \" , actual: \"\n+                    + actualLedgerId);\n+            throw new BKDigestMatchException();\n+        }\n+\n+        if (!skipEntryIdCheck && actualEntryId != entryId) {\n+            logger.error(\"Entry-id mismatch in authenticated message, expected: \" + entryId + \" , actual: \"\n+                    + actualEntryId);\n+            throw new BKDigestMatchException();\n+        }\n+\n+    }\n+    \n+    /**\n+     * Verify that the digest matches and returns the data in the entry.\n+     * \n+     * @param entryId\n+     * @param dataReceived\n+     * @return\n+     * @throws BKDigestMatchException\n+     */\n+    ChannelBufferInputStream verifyDigestAndReturnData(long entryId, ChannelBuffer dataReceived)\n+            throws BKDigestMatchException {\n+        verifyDigest(entryId, dataReceived);\n+        dataReceived.readerIndex(METADATA_LENGTH + macCodeLength);\n+        return new ChannelBufferInputStream(dataReceived);\n+    }\n+\n+    static class RecoveryData {\n+        long lastAddConfirmed;\n+        long entryId;\n+\n+        public RecoveryData(long lastAddConfirmed, long entryId) {\n+            this.lastAddConfirmed = lastAddConfirmed;\n+            this.entryId = entryId;\n+        }\n+\n+    }\n+\n+    RecoveryData verifyDigestAndReturnLastConfirmed(ChannelBuffer dataReceived) throws BKDigestMatchException {\n+        verifyDigest(dataReceived);\n+        dataReceived.readerIndex(8);\n+\n+        long entryId = dataReceived.readLong();\n+        long lastAddConfirmed = dataReceived.readLong();\n+        long length = dataReceived.readLong();\n+        return new RecoveryData(lastAddConfirmed, entryId);\n+\n+    }\n+}"},{"sha":"2f65adfde2781cba0daaf2e5dcaea5bb5d26846d","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,61 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * This interface determins how entries are distributed among bookies.\n+ * \n+ * Every entry gets replicated to some number of replicas. The first replica for\n+ * an entry is given a replicaIndex of 0, and so on. To distribute write load,\n+ * not all entries go to all bookies. Given an entry-id and replica index, an\n+ * {@link DistributionSchedule} determines which bookie that replica should go\n+ * to.\n+ */\n+\n+public interface DistributionSchedule {\n+\n+    /**\n+     * \n+     * @param entryId\n+     * @param replicaIndex\n+     * @return index of bookie that should get this replica\n+     */\n+    public int getBookieIndex(long entryId, int replicaIndex);\n+\n+    /**\n+     * \n+     * @param entryId\n+     * @param bookieIndex\n+     * @return -1 if the given bookie index is not a replica for the given\n+     *         entryId\n+     */\n+    public int getReplicaIndex(long entryId, int bookieIndex);\n+\n+    /**\n+     * Specifies whether its ok to proceed with recovery given that we have\n+     * heard back from the given bookie index. These calls will be a made in a\n+     * sequence and an implementation of this interface should accumulate\n+     * history about which bookie indexes we have heard from. Once this method\n+     * has returned true, it wont be called again on the same instance\n+     * \n+     * @param bookieIndexHeardFrom\n+     * @return true if its ok to proceed with recovery\n+     */\n+    public boolean canProceedWithRecovery(int bookieIndexHeardFrom);\n+}"},{"sha":"6c0d11a680b719fd779e3752417163577936366a","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"added","additions":167,"deletions":0,"changes":167,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,167 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayList;\n+import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.AsyncCallback.StatCallback;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.data.Stat;\n+\n+/**\n+ * Encapsulates asynchronous ledger create operation\n+ * \n+ */\n+class LedgerCreateOp implements StringCallback, StatCallback {\n+\n+    static final Logger LOG = Logger.getLogger(LedgerCreateOp.class);\n+\n+    CreateCallback cb;\n+    LedgerMetadata metadata;\n+    LedgerHandle lh;\n+    Object ctx;\n+    byte[] passwd;\n+    BookKeeper bk;\n+    DigestType digestType;\n+\n+   /**\n+    * Constructor\n+    * \n+    * @param bk\n+    *       BookKeeper object\n+    * @param ensembleSize\n+    *       ensemble size\n+    * @param quorumSize\n+    *       quorum size\n+    * @param digestType\n+    *       digest type, either MAC or CRC32\n+    * @param passwd\n+    *       passowrd\n+    * @param cb\n+    *       callback implementation\n+    * @param ctx\n+    *       optional control object\n+    */\n+\n+    LedgerCreateOp(BookKeeper bk, int ensembleSize, int quorumSize, DigestType digestType, byte[] passwd, CreateCallback cb, Object ctx) {\n+        this.bk = bk;\n+        this.metadata = new LedgerMetadata(ensembleSize, quorumSize);\n+        this.digestType = digestType;\n+        this.passwd = passwd;\n+        this.cb = cb;\n+        this.ctx = ctx;\n+    }\n+\n+    /**\n+     * Initiates the operation\n+     */\n+    public void initiate() {\n+        /*\n+         * Create ledger node on ZK. We get the id from the sequence number on\n+         * the node.\n+         */\n+\n+        bk.getZkHandle().create(StringUtils.prefix, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT_SEQUENTIAL, this, null);\n+\n+        // calls the children callback method below\n+    }\n+\n+\n+    /**\n+     * Implements ZooKeeper string callback.\n+     * \n+     * @see org.apache.zookeeper.AsyncCallback.StringCallback#processResult(int, java.lang.String, java.lang.Object, java.lang.String)\n+     */\n+    public void processResult(int rc, String path, Object ctx, String name) {\n+\n+        if (rc != KeeperException.Code.OK.intValue()) {\n+            LOG.error(\"Could not create node for ledger\", KeeperException.create(KeeperException.Code.get(rc), path));\n+            cb.createComplete(BKException.Code.ZKException, null, this.ctx);\n+            return;\n+        }\n+\n+        /*\n+         * Extract ledger id.\n+         */\n+        long ledgerId;\n+        try {\n+            ledgerId = StringUtils.getLedgerId(name);\n+        } catch (IOException e) {\n+            LOG.error(\"Could not extract ledger-id from path:\" + path, e);\n+            cb.createComplete(BKException.Code.ZKException, null, this.ctx);\n+            return;\n+        }\n+\n+        /*\n+         * Adding bookies to ledger handle\n+         */\n+\n+        ArrayList<InetSocketAddress> ensemble;\n+        try {\n+            ensemble = bk.bookieWatcher.getNewBookies(metadata.ensembleSize);\n+        } catch (BKNotEnoughBookiesException e) {\n+            LOG.error(\"Not enough bookies to create ledger\" + ledgerId);\n+            cb.createComplete(e.getCode(), null, this.ctx);\n+            return;\n+        }\n+\n+        /*\n+         * Add ensemble to the configuration\n+         */\n+        metadata.addEnsemble(new Long(0), ensemble);\n+        try {\n+            lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n+        } catch (GeneralSecurityException e) {\n+            LOG.error(\"Security exception while creating ledger: \" + ledgerId, e);\n+            cb.createComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);\n+            return;\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Incorrectly entered parameter throttle: \" + System.getProperty(\"throttle\"), e);\n+            cb.createComplete(BKException.Code.IncorrectParameterException, null, this.ctx);\n+            return;\n+        }\n+\n+        lh.writeLedgerConfig(this, null);\n+\n+    }\n+\n+    /**\n+     * Implements ZooKeeper stat callback.\n+     * \n+     * @see org.apache.zookeeper.AsyncCallback.StatCallback#processResult(int, String, Object, Stat)\n+     */\n+    public void processResult(int rc, String path, Object ctx, Stat stat) {\n+        cb.createComplete(rc, lh, this.ctx);\n+    }\n+\n+}"},{"sha":"eb847bf677bf66a9168c02f55f4ef452d2620011","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+\n+/**\n+ * Encapsulates asynchronous ledger delete operation\n+ * \n+ */\n+class LedgerDeleteOp implements VoidCallback {\n+\n+    static final Logger LOG = Logger.getLogger(LedgerDeleteOp.class);\n+\n+    BookKeeper bk;\n+    long ledgerId;\n+    DeleteCallback cb;\n+    Object ctx;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param bk\n+     *            BookKeeper object\n+     * @param ledgerId\n+     *            ledger Id\n+     * @param cb\n+     *            callback implementation\n+     * @param ctx\n+     *            optional control object\n+     */\n+    LedgerDeleteOp(BookKeeper bk, long ledgerId, DeleteCallback cb, Object ctx) {\n+        this.bk = bk;\n+        this.ledgerId = ledgerId;\n+        this.cb = cb;\n+        this.ctx = ctx;\n+    }\n+\n+    /**\n+     * Initiates the operation\n+     */\n+    public void initiate() {\n+        // Asynchronously delete the ledger node in ZK.\n+        // When this completes, it will invoke the callback method below.\n+        bk.getZkHandle().delete(StringUtils.getLedgerNodePath(ledgerId), -1, this, null);\n+    }\n+\n+    /**\n+     * Implements ZooKeeper Void Callback.\n+     * \n+     * @see org.apache.zookeeper.AsyncCallback.VoidCallback#processResult(int,\n+     *      java.lang.String, java.lang.Object)\n+     */\n+    public void processResult(int rc, String path, Object ctx) {\n+        cb.deleteComplete(rc, this.ctx);\n+    }\n+\n+}"},{"sha":"4c32255bee63bcc01c0b121f2cc1173aebd721ed","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,83 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBufferInputStream;\n+\n+/**\n+ * Ledger entry. Its a simple tuple containing the ledger id, the entry-id, and\n+ * the entry content.\n+ * \n+ */\n+\n+public class LedgerEntry {\n+  Logger LOG = Logger.getLogger(LedgerEntry.class);\n+\n+  long ledgerId;\n+  long entryId;\n+  long length;\n+  ChannelBufferInputStream entryDataStream;\n+\n+  int nextReplicaIndexToReadFrom = 0;\n+\n+  LedgerEntry(long lId, long eId) {\n+    this.ledgerId = lId;\n+    this.entryId = eId;\n+  }\n+\n+  public long getLedgerId() {\n+    return ledgerId;\n+  }\n+\n+  public long getEntryId() {\n+    return entryId;\n+  }\n+  \n+  public long getLength() {\n+      return length;\n+  }\n+\n+  public byte[] getEntry() {\n+    try {\n+      // In general, you can't rely on the available() method of an input\n+      // stream, but ChannelBufferInputStream is backed by a byte[] so it\n+      // accurately knows the # bytes available\n+      byte[] ret = new byte[entryDataStream.available()];\n+      entryDataStream.readFully(ret);\n+      return ret;\n+    } catch (IOException e) {\n+      // The channelbufferinput stream doesnt really throw the\n+      // ioexceptions, it just has to be in the signature because\n+      // InputStream says so. Hence this code, should never be reached.\n+      LOG.fatal(\"Unexpected IOException while reading from channel buffer\", e);\n+      return new byte[0];\n+    }\n+  }\n+\n+  public InputStream getEntryInputStream() {\n+    return entryDataStream;\n+  }\n+}"},{"sha":"647b76283977dd74fab57d07fd9cab3a201d57dd","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"added","additions":547,"deletions":0,"changes":547,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,547 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.net.InetSocketAddress;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Queue;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.util.SafeRunnable;\n+import org.apache.bookkeeper.util.StringUtils;\n+\n+import org.apache.log4j.Logger;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.AsyncCallback.StatCallback;\n+import org.apache.zookeeper.data.Stat;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * Ledger handle contains ledger metadata and is used to access the read and\n+ * write operations to a ledger.\n+ */\n+public class LedgerHandle implements ReadCallback, AddCallback, CloseCallback {\n+  final static Logger LOG = Logger.getLogger(LedgerHandle.class);\n+\n+  final byte[] ledgerKey;\n+  final LedgerMetadata metadata;\n+  final BookKeeper bk;\n+  final long ledgerId;\n+  long lastAddPushed;\n+  long lastAddConfirmed;\n+  long length;\n+  final DigestManager macManager;\n+  final DistributionSchedule distributionSchedule;\n+\n+  final Semaphore opCounterSem;\n+  private Integer throttling = 5000;\n+  \n+  final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();\n+  \n+  LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n+      DigestType digestType, byte[] password)\n+      throws GeneralSecurityException, NumberFormatException {\n+    this.bk = bk;\n+    this.metadata = metadata;\n+    if (metadata.isClosed()) {\n+      lastAddConfirmed = lastAddPushed = metadata.close;\n+      length = metadata.length;\n+    } else {\n+      lastAddConfirmed = lastAddPushed = -1;\n+      length = 0;\n+    }\n+    \n+    this.ledgerId = ledgerId;\n+    \n+    String throttleValue = System.getProperty(\"throttle\");\n+    if(throttleValue != null){\n+        this.throttling = new Integer(throttleValue); \n+    }\n+    this.opCounterSem = new Semaphore(throttling);\n+    \n+    macManager = DigestManager.instantiate(ledgerId, password, digestType);\n+    this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n+    distributionSchedule = new RoundRobinDistributionSchedule(\n+        metadata.quorumSize, metadata.ensembleSize);\n+  }\n+  \n+  /**\n+   * Get the id of the current ledger\n+   * \n+   * @return\n+   */\n+  public long getId() {\n+    return ledgerId;\n+  }\n+\n+  /**\n+   * Get the last confirmed entry id on this ledger\n+   * \n+   * @return\n+   */\n+  public long getLastAddConfirmed() {\n+    return lastAddConfirmed;\n+  }\n+\n+  /**\n+   * Get the entry id of the last entry that has been enqueued for addition (but\n+   * may not have possibly been persited to the ledger)\n+   * \n+   * @return\n+   */\n+  public long getLastAddPushed() {\n+    return lastAddPushed;\n+  }\n+\n+  /**\n+   * Get the Ledger's key/password.\n+   * \n+   * @return byte array for the ledger's key/password.\n+   */\n+  public byte[] getLedgerKey() {\n+      return ledgerKey;\n+  }\n+  \n+  /**\n+   * Get the LedgerMetadata\n+   * \n+   * @return LedgerMetadata for the LedgerHandle\n+   */\n+  public LedgerMetadata getLedgerMetadata() {\n+      return metadata;\n+  }\n+  \n+  /**\n+   * Get the DigestManager\n+   * \n+   * @return DigestManager for the LedgerHandle\n+   */\n+  public DigestManager getDigestManager() {\n+      return macManager;\n+  }\n+  \n+  /**\n+   * Return total number of available slots.\n+   * \n+   * @return int    available slots\n+   */\n+  Semaphore getAvailablePermits(){\n+      return this.opCounterSem;\n+  }\n+  \n+  /**\n+   *  Add to the length of the ledger in bytes.\n+   *  \n+   * @param delta\n+   * @return\n+   */\n+  long addToLength(long delta){\n+      this.length += delta;\n+      return this.length;\n+  }\n+  \n+  /**\n+   * Returns the length of the ledger in bytes. \n+   * \n+   * @return\n+   */\n+  public long getLength(){\n+      return this.length;\n+  }\n+  \n+  /**\n+   * Get the Distribution Schedule\n+   * \n+   * @return DistributionSchedule for the LedgerHandle\n+   */\n+  public DistributionSchedule getDistributionSchedule() {\n+      return distributionSchedule;\n+  }\n+  \n+  public void writeLedgerConfig(StatCallback callback, Object ctx) {\n+    bk.getZkHandle().setData(StringUtils.getLedgerNodePath(ledgerId),\n+        metadata.serialize(), -1, callback, ctx);\n+  }\n+\n+  /**\n+   * Close this ledger synchronously.\n+   * \n+   */\n+  public void close() throws InterruptedException {\n+    SyncCounter counter = new SyncCounter();\n+    counter.inc();\n+\n+    asyncClose(this, counter);\n+\n+    counter.block(0);\n+  }\n+\n+  /**\n+   * Asynchronous close, any adds in flight will return errors\n+   * \n+   * @param cb\n+   *          callback implementation\n+   * @param ctx\n+   *          control object\n+   * @throws InterruptedException\n+   */\n+  public void asyncClose(CloseCallback cb, Object ctx) {\n+    asyncClose(cb, ctx, BKException.Code.LedgerClosedException);\n+  }\n+\n+  /**\n+   * Same as public version of asynClose except that this one takes an\n+   * additional parameter which is the return code to hand to all the pending\n+   * add ops\n+   * \n+   * @param cb\n+   * @param ctx\n+   * @param rc\n+   */\n+  private void asyncClose(final CloseCallback cb, final Object ctx, final int rc) {\n+\n+    bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+\n+      @Override\n+      public void safeRun() {\n+        metadata.length = length;\n+        // Close operation is idempotent, so no need to check if we are\n+        // already closed\n+        metadata.close(lastAddConfirmed);\n+        errorOutPendingAdds(rc);\n+        lastAddPushed = lastAddConfirmed;\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n+              + metadata.close + \" with this many bytes: \" + metadata.length);\n+        }\n+\n+        writeLedgerConfig(new StatCallback() {\n+          @Override\n+          public void processResult(int rc, String path, Object subctx,\n+              Stat stat) {\n+            if (rc != KeeperException.Code.OK.intValue()) {\n+              cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n+                  ctx);\n+            } else {\n+              cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n+            }\n+          }\n+        }, null);\n+\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Read a sequence of entries synchronously.\n+   * \n+   * @param firstEntry\n+   *          id of first entry of sequence (included)\n+   * @param lastEntry\n+   *          id of last entry of sequence (included)\n+   * \n+   */\n+  public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n+      throws InterruptedException, BKException {\n+    SyncCounter counter = new SyncCounter();\n+    counter.inc();\n+\n+    asyncReadEntries(firstEntry, lastEntry, this, counter);\n+\n+    counter.block(0);\n+    if (counter.getrc() != BKException.Code.OK) {\n+      throw BKException.create(counter.getrc());\n+    }\n+\n+    return counter.getSequence();\n+  }\n+\n+  /**\n+   * Read a sequence of entries asynchronously.\n+   * \n+   * @param firstEntry\n+   *          id of first entry of sequence\n+   * @param lastEntry\n+   *          id of last entry of sequence\n+   * @param cb\n+   *          object implementing read callback interface\n+   * @param ctx\n+   *          control object\n+   */\n+  public void asyncReadEntries(long firstEntry, long lastEntry,\n+      ReadCallback cb, Object ctx) {\n+    // Little sanity check\n+    if (firstEntry < 0 || lastEntry > lastAddConfirmed\n+        || firstEntry > lastEntry) {\n+      cb.readComplete(BKException.Code.ReadException, this, null, ctx);\n+      return;\n+    }\n+\n+    try{\n+        new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();\n+  \n+    } catch (InterruptedException e) {\n+        cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);\n+    }\n+  }\n+\n+  /**\n+   * Add entry synchronously to an open ledger.\n+   * \n+   * @param data\n+   *         array of bytes to be written to the ledger\n+   */\n+\n+  public long addEntry(byte[] data) throws InterruptedException, BKException {\n+    LOG.debug(\"Adding entry \" + data);\n+    SyncCounter counter = new SyncCounter();\n+    counter.inc();\n+\n+    asyncAddEntry(data, this, counter);\n+    counter.block(0);\n+\n+    return counter.getrc();\n+  }\n+\n+  /**\n+   * Add entry asynchronously to an open ledger.\n+   * \n+   * @param data\n+   *          array of bytes to be written\n+   * @param cb\n+   *          object implementing callbackinterface\n+   * @param ctx\n+   *          some control object\n+   */\n+  public void asyncAddEntry(final byte[] data, final AddCallback cb,\n+      final Object ctx) {\n+      try{\n+          opCounterSem.acquire();\n+      } catch (InterruptedException e) {\n+          cb.addComplete(BKException.Code.InterruptedException,\n+                  LedgerHandle.this, -1, ctx);\n+      }\n+      \n+      try{\n+          bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+              @Override\n+              public void safeRun() {\n+                  if (metadata.isClosed()) {\n+                      LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n+                      LedgerHandle.this.opCounterSem.release();\n+                      cb.addComplete(BKException.Code.LedgerClosedException,\n+                              LedgerHandle.this, -1, ctx);\n+                      return;\n+                  }\n+\n+                  long entryId = ++lastAddPushed;\n+                  long currentLength = addToLength(data.length);\n+                  PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);\n+                  pendingAddOps.add(op);\n+                  ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n+                          entryId, lastAddConfirmed, currentLength, data);\n+                  op.initiate(toSend);\n+              }\n+          });\n+      } catch (RuntimeException e) {\n+          opCounterSem.release();\n+          throw e;\n+      }\n+  }\n+\n+  // close the ledger and send fails to all the adds in the pipeline\n+  void handleUnrecoverableErrorDuringAdd(int rc) {\n+    asyncClose(NoopCloseCallback.instance, null, rc);\n+  }\n+\n+  void errorOutPendingAdds(int rc) {\n+    PendingAddOp pendingAddOp;\n+    while ((pendingAddOp = pendingAddOps.poll()) != null) {\n+      pendingAddOp.submitCallback(rc);\n+    }\n+  }\n+\n+  void sendAddSuccessCallbacks() {\n+    // Start from the head of the queue and proceed while there are\n+    // entries that have had all their responses come back\n+    PendingAddOp pendingAddOp;\n+    while ((pendingAddOp = pendingAddOps.peek()) != null) {\n+      if (pendingAddOp.numResponsesPending != 0) {\n+        return;\n+      }\n+      pendingAddOps.remove();\n+      lastAddConfirmed = pendingAddOp.entryId;\n+      pendingAddOp.submitCallback(BKException.Code.OK);\n+    }\n+\n+  }\n+\n+  void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n+    InetSocketAddress newBookie;\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Handling failure of bookie: \" + addr + \" index: \"\n+          + bookieIndex);\n+    }\n+\n+    try {\n+      newBookie = bk.bookieWatcher\n+          .getAdditionalBookie(metadata.currentEnsemble);\n+    } catch (BKNotEnoughBookiesException e) {\n+      LOG\n+          .error(\"Could not get additional bookie to remake ensemble, closing ledger: \"\n+              + ledgerId);\n+      handleUnrecoverableErrorDuringAdd(e.getCode());\n+      return;\n+    }\n+\n+    final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>(\n+        metadata.currentEnsemble);\n+    newEnsemble.set(bookieIndex, newBookie);\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble + \" to: \"\n+          + newEnsemble + \" for ledger: \" + ledgerId + \" starting at entry: \"\n+          + (lastAddConfirmed + 1));\n+    }\n+\n+    metadata.addEnsemble(lastAddConfirmed + 1, newEnsemble);\n+\n+    writeLedgerConfig(new StatCallback() {\n+      @Override\n+      public void processResult(final int rc, String path, Object ctx, Stat stat) {\n+\n+        bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+          @Override\n+          public void safeRun() {\n+            if (rc != KeeperException.Code.OK.intValue()) {\n+              LOG\n+                  .error(\"Could not persist ledger metadata while changing ensemble to: \"\n+                      + newEnsemble + \" , closing ledger\");\n+              handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+              return;\n+            }\n+\n+            for (PendingAddOp pendingAddOp : pendingAddOps) {\n+              pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n+            }\n+          }\n+        });\n+\n+      }\n+    }, null);\n+\n+  }\n+\n+  void recover(GenericCallback<Void> cb) {\n+    if (metadata.isClosed()) {\n+      // We are already closed, nothing to do\n+      cb.operationComplete(BKException.Code.OK, null);\n+      return;\n+    }\n+\n+    new LedgerRecoveryOp(this, cb).initiate();\n+  }\n+\n+  static class NoopCloseCallback implements CloseCallback {\n+    static NoopCloseCallback instance = new NoopCloseCallback();\n+\n+    @Override\n+    public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n+      // noop\n+    }\n+  }\n+\n+  /**\n+   * Implementation of callback interface for synchronous read method.\n+   * \n+   * @param rc\n+   *          return code\n+   * @param leder\n+   *          ledger identifier\n+   * @param seq\n+   *          sequence of entries\n+   * @param ctx\n+   *          control object\n+   */\n+  public void readComplete(int rc, LedgerHandle lh,\n+      Enumeration<LedgerEntry> seq, Object ctx) {\n+\n+    SyncCounter counter = (SyncCounter) ctx;\n+    synchronized (counter) {\n+      counter.setSequence(seq);\n+      counter.setrc(rc);\n+      counter.dec();\n+      counter.notify();\n+    }\n+  }\n+\n+  /**\n+   * Implementation of callback interface for synchronous read method.\n+   * \n+   * @param rc\n+   *          return code\n+   * @param leder\n+   *          ledger identifier\n+   * @param entry\n+   *          entry identifier\n+   * @param ctx\n+   *          control object\n+   */\n+  public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {\n+    SyncCounter counter = (SyncCounter) ctx;\n+\n+    counter.setrc(rc);\n+    counter.dec();\n+  }\n+\n+  /**\n+   * Close callback method\n+   * \n+   * @param rc\n+   * @param lh\n+   * @param ctx\n+   */\n+  public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n+\n+    SyncCounter counter = (SyncCounter) ctx;\n+    counter.setrc(rc);\n+    synchronized (counter) {\n+      counter.dec();\n+      counter.notify();\n+    }\n+\n+  }\n+}"},{"sha":"bd204b41558c447ab3d019ce3111709f73adf11d","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"added","additions":198,"deletions":0,"changes":198,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,198 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * This class encapsulates all the ledger metadata that is persistently stored\n+ * in zookeeper. It provides parsing and serialization methods of such metadata.\n+ * \n+ */\n+public class LedgerMetadata {\n+    static final Logger LOG = Logger.getLogger(LedgerMetadata.class);\n+\n+    private static final String closed = \"CLOSED\";\n+    private static final String lSplitter = \"\\n\";\n+    private static final String tSplitter = \"\\t\";\n+\n+    // can't use -1 for NOTCLOSED because that is reserved for a closed, empty\n+    // ledger\n+    public static final int NOTCLOSED = -101;\n+    int ensembleSize;\n+    int quorumSize;\n+    long length;\n+    long close;\n+    private SortedMap<Long, ArrayList<InetSocketAddress>> ensembles = new TreeMap<Long, ArrayList<InetSocketAddress>>();\n+    ArrayList<InetSocketAddress> currentEnsemble;\n+\n+    public LedgerMetadata(int ensembleSize, int quorumSize) {\n+        this.ensembleSize = ensembleSize;\n+        this.quorumSize = quorumSize;\n+        \n+        /*\n+         * It is set in PendingReadOp.readEntryComplete, and \n+         * we read it in LedgerRecoveryOp.readComplete.\n+         */\n+        this.length = 0;\n+        this.close = NOTCLOSED;\n+    };\n+\n+    private LedgerMetadata() {\n+        this(0, 0);\n+    }\n+\n+    /**\n+     * Get the Map of bookie ensembles for the various ledger fragments \n+     * that make up the ledger.\n+     * \n+     * @return SortedMap of Ledger Fragments and the corresponding \n+     * bookie ensembles that store the entries.\n+     */\n+    public SortedMap<Long, ArrayList<InetSocketAddress>> getEnsembles() {\n+        return ensembles;\n+    }\n+    \n+    boolean isClosed() {\n+        return close != NOTCLOSED;\n+    }\n+\n+    void close(long entryId) {\n+        close = entryId;\n+    }\n+    \n+    void addEnsemble(long startEntryId, ArrayList<InetSocketAddress> ensemble) {\n+        assert ensembles.isEmpty() || startEntryId >= ensembles.lastKey();\n+\n+        ensembles.put(startEntryId, ensemble);\n+        currentEnsemble = ensemble;\n+    }\n+\n+    ArrayList<InetSocketAddress> getEnsemble(long entryId) {\n+        // the head map cannot be empty, since we insert an ensemble for\n+        // entry-id 0, right when we start\n+        return ensembles.get(ensembles.headMap(entryId + 1).lastKey());\n+    }\n+\n+    /**\n+     * the entry id > the given entry-id at which the next ensemble change takes\n+     * place ( -1 if no further ensemble changes)\n+     * \n+     * @param entryId\n+     * @return\n+     */\n+    long getNextEnsembleChange(long entryId) {\n+        SortedMap<Long, ArrayList<InetSocketAddress>> tailMap = ensembles.tailMap(entryId + 1);\n+\n+        if (tailMap.isEmpty()) {\n+            return -1;\n+        } else {\n+            return tailMap.firstKey();\n+        }\n+    }\n+\n+    /**\n+     * Generates a byte array based on a LedgerConfig object received.\n+     * \n+     * @param config\n+     *            LedgerConfig object\n+     * @return byte[]\n+     */\n+    public byte[] serialize() {\n+        StringBuilder s = new StringBuilder();\n+        s.append(quorumSize).append(lSplitter).append(ensembleSize).append(lSplitter).append(length);\n+\n+        for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : ensembles.entrySet()) {\n+            s.append(lSplitter).append(entry.getKey());\n+            for (InetSocketAddress addr : entry.getValue()) {\n+                s.append(tSplitter);\n+                StringUtils.addrToString(s, addr);\n+            }\n+        }\n+        \n+        if (close != NOTCLOSED) {\n+            s.append(lSplitter).append(close).append(tSplitter).append(closed);\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Serialized config: \" + s.toString());\n+        }\n+\n+        return s.toString().getBytes();\n+    }\n+\n+    /**\n+     * Parses a given byte array and transforms into a LedgerConfig object\n+     * \n+     * @param array\n+     *            byte array to parse\n+     * @return LedgerConfig\n+     * @throws IOException\n+     *             if the given byte[] cannot be parsed\n+     */\n+\n+    static LedgerMetadata parseConfig(byte[] bytes) throws IOException {\n+\n+        LedgerMetadata lc = new LedgerMetadata();\n+        String config = new String(bytes);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Parsing Config: \" + config);\n+        }\n+\n+        String lines[] = config.split(lSplitter);\n+\n+        if (lines.length < 2) {\n+            throw new IOException(\"Quorum size or ensemble size absent from config: \" + config);\n+        }\n+\n+        try {\n+            lc.quorumSize = new Integer(lines[0]);\n+            lc.ensembleSize = new Integer(lines[1]);\n+            lc.length = new Long(lines[2]); \n+            \n+            for (int i = 3; i < lines.length; i++) {\n+                String parts[] = lines[i].split(tSplitter);\n+\n+                if (parts[1].equals(closed)) {\n+                    lc.close = new Long(parts[0]);\n+                    break;\n+                }\n+\n+                ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n+                for (int j = 1; j < parts.length; j++) {\n+                    addrs.add(StringUtils.parseAddr(parts[j]));\n+                }\n+                lc.addEnsemble(new Long(parts[0]), addrs);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+        return lc;\n+    }\n+\n+}"},{"sha":"1c08d9850fb0bd0609ea0c87f874d83999e99c8a","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,140 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.AsyncCallback.DataCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.zookeeper.data.Stat;\n+\n+/**\n+ * Encapsulates the ledger open operation\n+ * \n+ */\n+class LedgerOpenOp implements DataCallback {\n+    static final Logger LOG = Logger.getLogger(LedgerOpenOp.class);\n+    \n+    BookKeeper bk;\n+    long ledgerId;\n+    OpenCallback cb;\n+    Object ctx;\n+    LedgerHandle lh;\n+    byte[] passwd;\n+    DigestType digestType;\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param bk\n+     * @param ledgerId\n+     * @param digestType\n+     * @param passwd\n+     * @param cb\n+     * @param ctx\n+     */\n+    \n+    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, OpenCallback cb, Object ctx) {\n+        this.bk = bk;\n+        this.ledgerId = ledgerId;\n+        this.passwd = passwd;\n+        this.cb = cb;\n+        this.ctx = ctx;\n+        this.digestType = digestType;\n+    }\n+\n+    /**\n+     * Inititates the ledger open operation\n+     */\n+    public void initiate() {\n+        /**\n+         * Asynchronously read the ledger metadata node.\n+         */\n+\n+        bk.getZkHandle().getData(StringUtils.getLedgerNodePath(ledgerId), false, this, ctx);\n+\n+    }\n+\n+    /**\n+     * Implements ZooKeeper data callback.\n+     * @see org.apache.zookeeper.AsyncCallback.DataCallback#processResult(int, String, Object, byte[], Stat)\n+     */\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+\n+        if (rc == KeeperException.Code.NONODE.intValue()) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No such ledger: \" + ledgerId, KeeperException.create(KeeperException.Code.get(rc), path));\n+            }\n+            cb.openComplete(BKException.Code.NoSuchLedgerExistsException, null, this.ctx);\n+            return;\n+        }\n+        if (rc != KeeperException.Code.OK.intValue()) {\n+            LOG.error(\"Could not read metadata for ledger: \" + ledgerId, KeeperException.create(KeeperException.Code\n+                    .get(rc), path));\n+            cb.openComplete(BKException.Code.ZKException, null, this.ctx);\n+            return;\n+        }\n+\n+        LedgerMetadata metadata;\n+        try {\n+            metadata = LedgerMetadata.parseConfig(data);\n+        } catch (IOException e) {\n+            LOG.error(\"Could not parse ledger metadata for ledger: \" + ledgerId, e);\n+            cb.openComplete(BKException.Code.ZKException, null, this.ctx);\n+            return;\n+        }\n+\n+        try {\n+            lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n+        } catch (GeneralSecurityException e) {\n+            LOG.error(\"Security exception while opening ledger: \" + ledgerId, e);\n+            cb.openComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);\n+            return;\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Incorrectly entered parameter throttle: \" + System.getProperty(\"throttle\"), e);\n+            cb.openComplete(BKException.Code.IncorrectParameterException, null, this.ctx);\n+            return;\n+        }\n+\n+        if (metadata.close != LedgerMetadata.NOTCLOSED) {\n+            // Ledger was closed properly\n+            cb.openComplete(BKException.Code.OK, lh, this.ctx);\n+            return;\n+        }\n+\n+        lh.recover(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (rc != BKException.Code.OK) {\n+                    cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n+                } else {\n+                    cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n+                }\n+            }\n+        });\n+    }\n+}"},{"sha":"82a85dabfb25823a08f97e97b8616d13762f8d2a","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,178 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.util.Enumeration;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;\n+import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * This class encapsulated the ledger recovery operation. It first does a read\n+ * with entry-id of -1 to all bookies. Then starting from the last confirmed\n+ * entry (from hints in the ledger entries), it reads forward until it is not\n+ * able to find a particular entry. It closes the ledger at that entry.\n+ * \n+ */\n+class LedgerRecoveryOp implements ReadEntryCallback, ReadCallback, AddCallback {\n+    static final Logger LOG = Logger.getLogger(LedgerRecoveryOp.class);\n+    LedgerHandle lh;\n+    int numResponsesPending;\n+    boolean proceedingWithRecovery = false;\n+    long maxAddPushed = -1;\n+    long maxAddConfirmed = -1;\n+    long maxLength = 0;\n+\n+    GenericCallback<Void> cb;\n+\n+    public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n+        this.cb = cb;\n+        this.lh = lh;\n+        numResponsesPending = lh.metadata.ensembleSize;\n+    }\n+\n+    public void initiate() {\n+        for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, -1, this, i);\n+        }\n+    }\n+\n+    public synchronized void readEntryComplete(final int rc, final long ledgerId, final long entryId,\n+            final ChannelBuffer buffer, final Object ctx) {\n+\n+        // Already proceeding with recovery, nothing to do\n+        if (proceedingWithRecovery) {\n+            return;\n+        }\n+\n+        int bookieIndex = (Integer) ctx;\n+\n+        numResponsesPending--;\n+\n+        boolean heardValidResponse = false;\n+\n+        if (rc == BKException.Code.OK) {\n+            try {\n+                RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n+                maxAddConfirmed = Math.max(maxAddConfirmed, recoveryData.lastAddConfirmed);\n+                maxAddPushed = Math.max(maxAddPushed, recoveryData.entryId);\n+                heardValidResponse = true;\n+            } catch (BKDigestMatchException e) {\n+                // Too bad, this bookie didnt give us a valid answer, we\n+                // still might be able to recover though so continue\n+                LOG.error(\"Mac mismatch while reading last entry from bookie: \"\n+                        + lh.metadata.currentEnsemble.get(bookieIndex));\n+            }\n+        }\n+\n+        if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n+            // this still counts as a valid response, e.g., if the\n+            // client\n+            // crashed without writing any entry\n+            heardValidResponse = true;\n+        }\n+\n+        // other return codes dont count as valid responses\n+        if (heardValidResponse && lh.distributionSchedule.canProceedWithRecovery(bookieIndex)) {\n+            proceedingWithRecovery = true;\n+            lh.lastAddPushed = lh.lastAddConfirmed = maxAddConfirmed;\n+            lh.length = maxLength;\n+            doRecoveryRead();\n+            return;\n+        }\n+\n+        if (numResponsesPending == 0) {\n+            // Have got all responses back but was still not enough to\n+            // start\n+            // recovery, just fail the operation\n+            LOG.error(\"While recovering ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n+            cb.operationComplete(BKException.Code.LedgerRecoveryException, null);\n+        }\n+\n+    }\n+\n+    /**\n+     * Try to read past the last confirmed.\n+     */\n+    private void doRecoveryRead() {\n+        lh.lastAddConfirmed++;\n+        lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, this, null);\n+    }\n+\n+    @Override\n+    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+        // get back to prev value\n+        lh.lastAddConfirmed--;\n+        if (rc == BKException.Code.OK) {\n+            LedgerEntry entry = seq.nextElement(); \n+            byte[] data = entry.getEntry();\n+            \n+            /*\n+             * We will add this entry again to make sure it is written to enough\n+             * replicas. We subtract the length of the data itself, since it will\n+             * be added again when processing the call to add it.\n+             */\n+            lh.length = entry.getLength() - (long) data.length;\n+            lh.asyncAddEntry(data, this, null);\n+            \n+            return;\n+        }\n+\n+        if (rc == BKException.Code.NoSuchEntryException || rc == BKException.Code.NoSuchLedgerExistsException) {\n+            lh.asyncClose(NoopCloseCallback.instance, null);\n+            // we don't need to wait for the close to complete. Since we mark\n+            // the\n+            // ledger closed in memory, the application wont be able to add to\n+            // it\n+\n+            cb.operationComplete(BKException.Code.OK, null);\n+            LOG.debug(\"After closing length is: \" + lh.getLength());\n+            return;\n+        }\n+\n+        // otherwise, some other error, we can't handle\n+        LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + lh.lastAddConfirmed + 1\n+                + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n+        cb.operationComplete(rc, null);\n+        return;\n+    }\n+\n+    @Override\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        if (rc != BKException.Code.OK) {\n+            // Give up, we can't recover from this error\n+\n+            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + lh.lastAddConfirmed + 1\n+                    + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n+            cb.operationComplete(rc, null);\n+            return;\n+        }\n+\n+        doRecoveryRead();\n+\n+    }\n+\n+}"},{"sha":"1dbc27f2ab3c95142ced87d8ec6c034cf1bfb9b9","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,67 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+import java.security.GeneralSecurityException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+class MacDigestManager extends DigestManager {\n+    public static String DIGEST_ALGORITHM = \"SHA-1\";\n+    public static String KEY_ALGORITHM = \"HmacSHA1\";\n+    Mac mac;\n+\n+    public MacDigestManager(long ledgerId, byte[] passwd) throws GeneralSecurityException {\n+        super(ledgerId);\n+        byte[] macKey = genDigest(\"mac\", passwd);\n+        SecretKeySpec keySpec = new SecretKeySpec(macKey, KEY_ALGORITHM);\n+        mac = Mac.getInstance(KEY_ALGORITHM);\n+        mac.init(keySpec);\n+        \n+        \n+    }\n+\n+    static byte[] genDigest(String pad, byte[] passwd) throws NoSuchAlgorithmException {\n+        MessageDigest digest = MessageDigest.getInstance(DIGEST_ALGORITHM);\n+        digest.update(pad.getBytes());\n+        digest.update(passwd);\n+                return digest.digest();\n+    }\n+\n+    @Override\n+    int getMacCodeLength() {\n+        return 20;\n+    }\n+\n+    \n+    @Override\n+    byte[] getValueAndReset() {\n+        return mac.doFinal();\n+    }\n+    \n+    @Override\n+    void update(byte[] data, int offset, int length) {\n+        mac.update(data, offset, length);\n+    }\n+    \n+    \n+}"},{"sha":"1b6d16791c15ca49be9a364e33bdc4b512202bc6","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,138 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.net.InetSocketAddress;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * This represents a pending add operation. When it has got success from all\n+ * bookies, it sees if its at the head of the pending adds queue, and if yes,\n+ * sends ack back to the application. If a bookie fails, a replacement is made\n+ * and placed at the same position in the ensemble. The pending adds are then\n+ * rereplicated.\n+ * \n+ * \n+ */\n+class PendingAddOp implements WriteCallback {\n+    final static Logger LOG = Logger.getLogger(PendingAddOp.class);\n+\n+    ChannelBuffer toSend;\n+    AddCallback cb;\n+    Object ctx;\n+    long entryId;\n+    boolean[] successesSoFar;\n+    int numResponsesPending;\n+    LedgerHandle lh;\n+\n+    PendingAddOp(LedgerHandle lh, AddCallback cb, Object ctx, long entryId) {\n+        this.lh = lh;\n+        this.cb = cb;\n+        this.ctx = ctx;\n+        this.entryId = entryId;\n+        successesSoFar = new boolean[lh.metadata.quorumSize];\n+        numResponsesPending = successesSoFar.length;\n+    }\n+\n+    void sendWriteRequest(int bookieIndex, int arrayIndex) {\n+        lh.bk.bookieClient.addEntry(lh.metadata.currentEnsemble.get(bookieIndex), lh.ledgerId, lh.ledgerKey, entryId, toSend,\n+                this, arrayIndex);\n+    }\n+\n+    void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n+        if (toSend == null) {\n+            // this addOp hasn't yet had its mac computed. When the mac is\n+            // computed, its write requests will be sent, so no need to send it\n+            // now\n+            return;\n+        }\n+\n+        int replicaIndex = lh.distributionSchedule.getReplicaIndex(entryId, bookieIndex);\n+        if (replicaIndex < 0) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Leaving unchanged, ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n+                        + bookieIndex);\n+            }\n+            return;\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Unsetting success for ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n+                    + bookieIndex);\n+        }\n+\n+        // if we had already heard a success from this array index, need to\n+        // increment our number of responses that are pending, since we are\n+        // going to unset this success\n+        if (successesSoFar[replicaIndex]) {\n+            successesSoFar[replicaIndex] = false;\n+            numResponsesPending++;\n+        }\n+        \n+         sendWriteRequest(bookieIndex, replicaIndex);\n+    }\n+\n+    void initiate(ChannelBuffer toSend) {\n+        this.toSend = toSend;\n+        for (int i = 0; i < successesSoFar.length; i++) {\n+            int bookieIndex = lh.distributionSchedule.getBookieIndex(entryId, i);\n+            sendWriteRequest(bookieIndex, i);\n+        }\n+    }\n+\n+    @Override\n+    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+\n+        Integer replicaIndex = (Integer) ctx;\n+        int bookieIndex = lh.distributionSchedule.getBookieIndex(entryId, replicaIndex);\n+\n+        if (!lh.metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n+            // ensemble has already changed, failure of this addr is immaterial\n+            LOG.warn(\"Write did not succeed: \" + ledgerId + \", \" + entryId + \". But we have already fixed it.\");\n+            return;\n+        }\n+        \n+        if (rc != BKException.Code.OK) {\n+            LOG.warn(\"Write did not succeed: \" + ledgerId + \", \" + entryId);\n+            lh.handleBookieFailure(addr, bookieIndex);\n+            return;\n+        }\n+\n+\n+        if (!successesSoFar[replicaIndex]) {\n+            successesSoFar[replicaIndex] = true;\n+            numResponsesPending--;\n+            \n+            // do some quick checks to see if some adds may have finished. All\n+            // this will be checked under locks again\n+            if (numResponsesPending == 0 && lh.pendingAddOps.peek() == this) {\n+                lh.sendAddSuccessCallbacks();\n+            }\n+        } \n+    }\n+\n+    void submitCallback(final int rc) {\n+        cb.addComplete(rc, lh, entryId, ctx);\n+        lh.opCounterSem.release();\n+    }\n+\n+}\n\\ No newline at end of file"},{"sha":"99c9720ef12cf146ac362a1f8e40cff34eba5c75","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"added","additions":170,"deletions":0,"changes":170,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,170 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBufferInputStream;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Sequence of entries of a ledger that represents a pending read operation.\n+ * When all the data read has come back, the application callback is called.\n+ * This class could be improved because we could start pushing data to the\n+ * application as soon as it arrives rather than waiting for the whole thing.\n+ * \n+ */\n+\n+class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n+    Logger LOG = Logger.getLogger(PendingReadOp.class);\n+\n+    Queue<LedgerEntry> seq;\n+    ReadCallback cb;\n+    Object ctx;\n+    LedgerHandle lh;\n+    long numPendingReads;\n+    long startEntryId;\n+    long endEntryId;\n+\n+    PendingReadOp(LedgerHandle lh, long startEntryId, long endEntryId, ReadCallback cb, Object ctx) {\n+\n+        seq = new ArrayDeque<LedgerEntry>((int) (endEntryId - startEntryId));\n+        this.cb = cb;\n+        this.ctx = ctx;\n+        this.lh = lh;\n+        this.startEntryId = startEntryId;\n+        this.endEntryId = endEntryId;\n+        numPendingReads = endEntryId - startEntryId + 1;\n+    }\n+\n+    public void initiate() throws InterruptedException {\n+        long nextEnsembleChange = startEntryId, i = startEntryId;\n+\n+        ArrayList<InetSocketAddress> ensemble = null;\n+        do {\n+\n+            if(LOG.isDebugEnabled()){\n+                LOG.debug(\"Acquiring lock: \" + i);\n+            }\n+           \n+            lh.opCounterSem.acquire();\n+            \n+            if (i == nextEnsembleChange) {\n+                ensemble = lh.metadata.getEnsemble(i);\n+                nextEnsembleChange = lh.metadata.getNextEnsembleChange(i);\n+            }\n+            LedgerEntry entry = new LedgerEntry(lh.ledgerId, i);\n+            seq.add(entry);\n+            i++;\n+            sendRead(ensemble, entry, BKException.Code.ReadException);\n+\n+        } while (i <= endEntryId);\n+    }\n+\n+    void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int lastErrorCode) {\n+        if (entry.nextReplicaIndexToReadFrom >= lh.metadata.quorumSize) {\n+            // we are done, the read has failed from all replicas, just fail the\n+            // read\n+            submitCallback(lastErrorCode);\n+            return;\n+        }\n+\n+        int bookieIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom);\n+        entry.nextReplicaIndexToReadFrom++;\n+        lh.bk.bookieClient.readEntry(ensemble.get(bookieIndex), lh.ledgerId, entry.entryId, this, entry);\n+    }\n+\n+    void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n+        ArrayList<InetSocketAddress> ensemble = lh.metadata.getEnsemble(entry.entryId);\n+        int bookeIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom - 1);\n+        LOG.error(errMsg + \" while reading entry: \" + entry.entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n+                + ensemble.get(bookeIndex));\n+        sendRead(ensemble, entry, rc);\n+        return;\n+    }\n+\n+    @Override\n+    public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n+        final LedgerEntry entry = (LedgerEntry) ctx;\n+\n+        if (rc != BKException.Code.OK) {\n+            logErrorAndReattemptRead(entry, \"Error: \" + BKException.getMessage(rc), rc);\n+            return;\n+        }\n+        \n+        ChannelBufferInputStream is;\n+        try {\n+            is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n+        } catch (BKDigestMatchException e) {\n+            logErrorAndReattemptRead(entry, \"Mac mismatch\", BKException.Code.DigestMatchException);\n+            return;\n+        }\n+        \n+        entry.entryDataStream = is;\n+        \n+        /*\n+         * The length is a long and it is the last field of the metadata of an entry.\n+         * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n+         */\n+        entry.length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n+\n+        numPendingReads--;\n+        if (numPendingReads == 0) {\n+            submitCallback(BKException.Code.OK);\n+        }\n+        \n+        if(LOG.isDebugEnabled()){\n+            LOG.debug(\"Releasing lock: \" + entryId);\n+        }\n+        \n+        lh.opCounterSem.release();\n+        \n+        if(numPendingReads < 0)\n+            LOG.error(\"Read too many values\");\n+    }\n+\n+    private void submitCallback(int code){\n+        cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);\n+    }\n+    public boolean hasMoreElements() {\n+        return !seq.isEmpty();\n+    }\n+\n+    public LedgerEntry nextElement() throws NoSuchElementException {\n+        return seq.remove();\n+    }\n+\n+    public int size() {\n+        return seq.size();\n+    }\n+}"},{"sha":"4660ab169900c18ceb663bd4cf76dcfb635f26db","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,87 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+\n+/**\n+ * A specific {@link DistributionSchedule} that places entries in round-robin\n+ * fashion. For ensemble size 3, and quorum size 2, Entry 0 goes to bookie 0 and\n+ * 1, entry 1 goes to bookie 1 and 2, and entry 2 goes to bookie 2 and 0, and so\n+ * on.\n+ * \n+ */\n+class RoundRobinDistributionSchedule implements DistributionSchedule {\n+    int quorumSize;\n+    int ensembleSize;\n+\n+    // covered[i] is true if the quorum starting at bookie index i has been\n+    // covered by a recovery reply\n+    boolean[] covered = null;\n+    int numQuorumsUncovered;\n+\n+    public RoundRobinDistributionSchedule(int quorumSize, int ensembleSize) {\n+        this.quorumSize = quorumSize;\n+        this.ensembleSize = ensembleSize;\n+    }\n+\n+    @Override\n+    public int getBookieIndex(long entryId, int replicaIndex) {\n+        return (int) ((entryId + replicaIndex) % ensembleSize);\n+    }\n+\n+    @Override\n+    public int getReplicaIndex(long entryId, int bookieIndex) {\n+        // NOTE: Java's % operator returns the sign of the dividend and is hence\n+        // not always positive\n+\n+        int replicaIndex = MathUtils.signSafeMod(bookieIndex - entryId, ensembleSize);\n+\n+        return replicaIndex < quorumSize ? replicaIndex : -1;\n+\n+    }\n+\n+    public synchronized boolean canProceedWithRecovery(int bookieIndexHeardFrom) {\n+        if (covered == null) {\n+            covered = new boolean[ensembleSize];\n+            numQuorumsUncovered = ensembleSize;\n+        }\n+\n+        if (numQuorumsUncovered == 0) {\n+            return true;\n+        }\n+\n+        for (int i = 0; i < quorumSize; i++) {\n+            int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n+            if (!covered[quorumStartIndex]) {\n+                covered[quorumStartIndex] = true;\n+                numQuorumsUncovered--;\n+\n+                if (numQuorumsUncovered == 0) {\n+                    return true;\n+                }\n+            }\n+\n+        }\n+\n+        return false;\n+\n+    }\n+\n+}"},{"sha":"1f20ff4e2b0ebf6fd4f704b42fe3da0ed80a9005","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/client/SyncCounter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/client/SyncCounter.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,85 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.util.Enumeration;\n+\n+/**\n+ * Implements objects to help with the synchronization of asynchronous calls\n+ * \n+ */\n+\n+class SyncCounter {\n+    int i;\n+    int rc;\n+    int total;\n+    Enumeration<LedgerEntry> seq = null;\n+    LedgerHandle lh = null;\n+\n+    synchronized void inc() {\n+        i++;\n+        total++;\n+    }\n+\n+    synchronized void dec() {\n+        i--;\n+        notifyAll();\n+    }\n+\n+    synchronized void block(int limit) throws InterruptedException {\n+        while (i > limit) {\n+            int prev = i;\n+            wait();\n+            if (i == prev) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    synchronized int total() {\n+        return total;\n+    }\n+\n+    void setrc(int rc) {\n+        this.rc = rc;\n+    }\n+\n+    int getrc() {\n+        return rc;\n+    }\n+\n+    void setSequence(Enumeration<LedgerEntry> seq) {\n+        this.seq = seq;\n+    }\n+\n+    Enumeration<LedgerEntry> getSequence() {\n+        return seq;\n+    }\n+\n+    void setLh(LedgerHandle lh) {\n+        this.lh = lh;\n+    }\n+\n+    LedgerHandle getLh() {\n+        return lh;\n+    }\n+}"},{"sha":"4911be414071b0881ec05210646f9353bf6fcb9d","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,178 @@\n+package org.apache.bookkeeper.proto;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+/**\n+ * Implements the client-side part of the BookKeeper protocol.\n+ * \n+ */\n+public class BookieClient {\n+    static final Logger LOG = Logger.getLogger(BookieClient.class);\n+\n+    // This is global state that should be across all BookieClients\n+    AtomicLong totalBytesOutstanding = new AtomicLong();\n+\n+    OrderedSafeExecutor executor;\n+    ClientSocketChannelFactory channelFactory;\n+    ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient> channels = new ConcurrentHashMap<InetSocketAddress, PerChannelBookieClient>();\n+\n+    public BookieClient(ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n+        this.channelFactory = channelFactory;\n+        this.executor = executor;\n+    }\n+\n+    public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n+        PerChannelBookieClient channel = channels.get(addr);\n+\n+        if (channel == null) {\n+            channel = new PerChannelBookieClient(executor, channelFactory, addr, totalBytesOutstanding);\n+            PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n+            if (prevChannel != null) {\n+                channel = prevChannel;\n+            }\n+        }\n+\n+        return channel;\n+    }\n+\n+    public void addEntry(final InetSocketAddress addr, final long ledgerId, final byte[] masterKey, final long entryId,\n+            final ChannelBuffer toSend, final WriteCallback cb, final Object ctx) {\n+\n+        final PerChannelBookieClient client = lookupClient(addr);\n+\n+        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (rc != BKException.Code.OK) {\n+                    cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+                    return;\n+                }\n+                client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx);\n+            }\n+        });\n+    }\n+\n+    public void readEntry(final InetSocketAddress addr, final long ledgerId, final long entryId,\n+            final ReadEntryCallback cb, final Object ctx) {\n+\n+        final PerChannelBookieClient client = lookupClient(addr);\n+\n+        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+\n+                if (rc != BKException.Code.OK) {\n+                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                    return;\n+                }\n+                client.readEntry(ledgerId, entryId, cb, ctx);\n+            }\n+        });\n+    }\n+\n+    public void close(){\n+        for (PerChannelBookieClient channel: channels.values()){\n+            channel.close();\n+        }\n+    }\n+\n+    private static class Counter {\n+        int i;\n+        int total;\n+\n+        synchronized void inc() {\n+            i++;\n+            total++;\n+        }\n+\n+        synchronized void dec() {\n+            i--;\n+            notifyAll();\n+        }\n+\n+        synchronized void wait(int limit) throws InterruptedException {\n+            while (i > limit) {\n+                wait();\n+            }\n+        }\n+\n+        synchronized int total() {\n+            return total;\n+        }\n+    }\n+\n+    /**\n+     * @param args\n+     * @throws IOException\n+     * @throws NumberFormatException\n+     * @throws InterruptedException\n+     */\n+    public static void main(String[] args) throws NumberFormatException, IOException, InterruptedException {\n+        if (args.length != 3) {\n+            System.err.println(\"USAGE: BookieClient bookieHost port ledger#\");\n+            return;\n+        }\n+        WriteCallback cb = new WriteCallback() {\n+\n+            public void writeComplete(int rc, long ledger, long entry, InetSocketAddress addr, Object ctx) {\n+                Counter counter = (Counter) ctx;\n+                counter.dec();\n+                if (rc != 0) {\n+                    System.out.println(\"rc = \" + rc + \" for \" + entry + \"@\" + ledger);\n+                }\n+            }\n+        };\n+        Counter counter = new Counter();\n+        byte hello[] = \"hello\".getBytes();\n+        long ledger = Long.parseLong(args[2]);\n+        ClientSocketChannelFactory channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n+                .newCachedThreadPool());\n+        OrderedSafeExecutor executor = new OrderedSafeExecutor(1);\n+        BookieClient bc = new BookieClient(channelFactory, executor);\n+        InetSocketAddress addr = new InetSocketAddress(args[0], Integer.parseInt(args[1]));\n+\n+        for (int i = 0; i < 100000; i++) {\n+            counter.inc();\n+            bc.addEntry(addr, ledger, new byte[0], i, ChannelBuffers.wrappedBuffer(hello), cb, counter);\n+        }\n+        counter.wait(0);\n+        System.out.println(\"Total = \" + counter.total());\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+}"},{"sha":"c35685b9868ed97fa902c1b25c760c79f1cfa899","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,75 @@\n+package org.apache.bookkeeper.proto;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+/**\n+ * The packets of the Bookie protocol all have a 4-byte integer indicating the\n+ * type of request or response at the very beginning of the packet followed by a\n+ * payload.\n+ * \n+ */\n+public interface BookieProtocol {\n+    /**\n+     * The Add entry request payload will be a ledger entry exactly as it should\n+     * be logged. The response payload will be a 4-byte integer that has the\n+     * error code followed by the 8-byte ledger number and 8-byte entry number\n+     * of the entry written.\n+     */\n+    public static final int ADDENTRY = 1;\n+    /**\n+     * The Read entry request payload will be the ledger number and entry number\n+     * to read. (The ledger number is an 8-byte integer and the entry number is\n+     * a 8-byte integer.) The response payload will be a 4-byte integer\n+     * representing an error code and a ledger entry if the error code is EOK,\n+     * otherwise it will be the 8-byte ledger number and the 4-byte entry number\n+     * requested. (Note that the first sixteen bytes of the entry happen to be\n+     * the ledger number and entry number as well.)\n+     */\n+    public static final int READENTRY = 2;\n+\n+    /**\n+     * The error code that indicates success\n+     */\n+    public static final int EOK = 0;\n+    /**\n+     * The error code that indicates that the ledger does not exist\n+     */\n+    public static final int ENOLEDGER = 1;\n+    /**\n+     * The error code that indicates that the requested entry does not exist\n+     */\n+    public static final int ENOENTRY = 2;\n+    /**\n+     * The error code that indicates an invalid request type\n+     */\n+    public static final int EBADREQ = 100;\n+    /**\n+     * General error occurred at the server\n+     */\n+    public static final int EIO = 101;\n+\n+    /**\n+     * Unauthorized access to ledger\n+     */\n+    public static final int EUA = 102;\n+\n+}"},{"sha":"5881fcb88a013f8b0f0bab29fdd313c9bf6256be","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,209 @@\n+package org.apache.bookkeeper.proto;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.NIOServerFactory.Cnxn;\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * Implements the server-side part of the BookKeeper protocol.\n+ * \n+ */\n+public class BookieServer implements NIOServerFactory.PacketProcessor, BookkeeperInternalCallbacks.WriteCallback {\n+    int port;\n+    NIOServerFactory nioServerFactory;\n+    private volatile boolean running = false;\n+    Bookie bookie;\n+    static Logger LOG = Logger.getLogger(BookieServer.class);\n+\n+    public BookieServer(int port, String zkServers, File journalDirectory, File ledgerDirectories[]) throws IOException {\n+        this.port = port;\n+        this.bookie = new Bookie(port, zkServers, journalDirectory, ledgerDirectories);\n+    }\n+\n+    public void start() throws IOException {\n+        nioServerFactory = new NIOServerFactory(port, this);\n+        running = true;\n+    }\n+\n+    public void shutdown() throws InterruptedException {\n+        running = false;\n+        nioServerFactory.shutdown();\n+        bookie.shutdown();\n+    }\n+\n+    public boolean isRunning(){\n+        return bookie.isRunning() && nioServerFactory.isRunning() && running;\n+    }\n+\n+    public void join() throws InterruptedException {\n+        nioServerFactory.join();\n+    }\n+\n+    /**\n+     * @param args\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        if (args.length < 4) {\n+            System.err.println(\"USAGE: BookieServer port zkServers journalDirectory ledgerDirectory [ledgerDirectory]*\");\n+            return;\n+        }\n+        int port = Integer.parseInt(args[0]);\n+        String zkServers = args[1];\n+        File journalDirectory = new File(args[2]);\n+        File ledgerDirectory[] = new File[args.length - 3];\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < ledgerDirectory.length; i++) {\n+            ledgerDirectory[i] = new File(args[i + 3]);\n+            if (i != 0) {\n+                sb.append(',');\n+            }\n+            sb.append(ledgerDirectory[i]);\n+        }\n+        String hello = String.format(\n+                \"Hello, I'm your bookie, listening on port %1$s. ZKServers are on %2$s. Journals are in %3$s. Ledgers are stored in %4$s.\",\n+                port, zkServers, journalDirectory, sb);\n+        LOG.info(hello);\n+        BookieServer bs = new BookieServer(port, zkServers, journalDirectory, ledgerDirectory);\n+        bs.start();\n+        bs.join();\n+    }\n+\n+    public void processPacket(ByteBuffer packet, Cnxn src) {\n+        int type = packet.getInt();\n+        switch (type) {\n+        case BookieProtocol.ADDENTRY:\n+            try {\n+                byte[] masterKey = new byte[20];\n+                packet.get(masterKey, 0, 20);\n+                // LOG.debug(\"Master key: \" + new String(masterKey));\n+                bookie.addEntry(packet.slice(), this, src, masterKey);\n+            } catch (IOException e) {\n+                ByteBuffer bb = packet.duplicate();\n+\n+                long ledgerId = bb.getLong();\n+                long entryId = bb.getLong();\n+                LOG.error(\"Error writing \" + entryId + \"@\" + ledgerId, e);\n+                ByteBuffer eio = ByteBuffer.allocate(8 + 16);\n+                eio.putInt(type);\n+                eio.putInt(BookieProtocol.EIO);\n+                eio.putLong(ledgerId);\n+                eio.putLong(entryId);\n+                eio.flip();\n+                src.sendResponse(new ByteBuffer[] { eio });\n+            } catch (BookieException e) {\n+                ByteBuffer bb = packet.duplicate();\n+                long ledgerId = bb.getLong();\n+                long entryId = bb.getLong();\n+\n+                LOG.error(\"Unauthorized access to ledger \" + ledgerId);\n+\n+                ByteBuffer eio = ByteBuffer.allocate(8 + 16);\n+                eio.putInt(type);\n+                eio.putInt(BookieProtocol.EUA);\n+                eio.putLong(ledgerId);\n+                eio.putLong(entryId);\n+                eio.flip();\n+                src.sendResponse(new ByteBuffer[] { eio });\n+            }\n+            break;\n+        case BookieProtocol.READENTRY:\n+            ByteBuffer[] rsp = new ByteBuffer[2];\n+            ByteBuffer rc = ByteBuffer.allocate(8 + 8 + 8);\n+            rsp[0] = rc;\n+            rc.putInt(type);\n+\n+            long ledgerId = packet.getLong();\n+            long entryId = packet.getLong();\n+            LOG.debug(\"Received new read request: \" + ledgerId + \", \" + entryId);\n+            try {\n+                rsp[1] = bookie.readEntry(ledgerId, entryId);\n+                LOG.debug(\"##### Read entry ##### \" + rsp[1].remaining());\n+                rc.putInt(BookieProtocol.EOK);\n+            } catch (Bookie.NoLedgerException e) {\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n+                }\n+                rc.putInt(BookieProtocol.ENOLEDGER);\n+            } catch (Bookie.NoEntryException e) {\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n+                }\n+                rc.putInt(BookieProtocol.ENOENTRY);\n+            } catch (IOException e) {\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n+                }\n+                rc.putInt(BookieProtocol.EIO);\n+            }\n+            rc.putLong(ledgerId);\n+            rc.putLong(entryId);\n+            rc.flip();\n+            if (LOG.isTraceEnabled()) {\n+                int rcCode = rc.getInt();\n+                rc.rewind();\n+                LOG.trace(\"Read entry rc = \" + rcCode + \" for \" + entryId + \"@\" + ledgerId);\n+            }\n+            if (rsp[1] == null) {\n+                // We haven't filled in entry data, so we have to send back\n+                // the ledger and entry ids here\n+                rsp[1] = ByteBuffer.allocate(16);\n+                rsp[1].putLong(ledgerId);\n+                rsp[1].putLong(entryId);\n+                rsp[1].flip();\n+            }\n+            LOG.debug(\"Sending response for: \" + entryId + \", \" + new String(rsp[1].array()));\n+            src.sendResponse(rsp);\n+            break;\n+        default:\n+            ByteBuffer badType = ByteBuffer.allocate(8);\n+            badType.putInt(type);\n+            badType.putInt(BookieProtocol.EBADREQ);\n+            badType.flip();\n+            src.sendResponse(new ByteBuffer[] { packet });\n+        }\n+    }\n+\n+    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+        Cnxn src = (Cnxn) ctx;\n+        ByteBuffer bb = ByteBuffer.allocate(24);\n+        bb.putInt(BookieProtocol.ADDENTRY);\n+        bb.putInt(rc);\n+        bb.putLong(ledgerId);\n+        bb.putLong(entryId);\n+        bb.flip();\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Add entry rc = \" + rc + \" for \" + entryId + \"@\" + ledgerId);\n+        }\n+        src.sendResponse(new ByteBuffer[] { bb });\n+    }\n+    \n+}"},{"sha":"a4801526a803504303a55c9d2022b8367cde31bc","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+package org.apache.bookkeeper.proto;\n+\n+import java.net.InetSocketAddress;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * Declaration of a callback interfaces used in bookkeeper client library but\n+ * not exposed to the client application.\n+ */\n+\n+public class BookkeeperInternalCallbacks {\n+    /**\n+     * Callback for calls from BookieClient objects. Such calls are for replies\n+     * of write operations (operations to add an entry to a ledger).\n+     * \n+     */\n+\n+    public interface WriteCallback {\n+        void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx);\n+    }\n+\n+    public interface GenericCallback<T> {\n+        void operationComplete(int rc, T result);\n+    }\n+    \n+    /**\n+     * Declaration of a callback implementation for calls from BookieClient objects.\n+     * Such calls are for replies of read operations (operations to read an entry\n+     * from a ledger).\n+     * \n+     */\n+\n+    public interface ReadEntryCallback {\n+        void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx);\n+    }\n+}"},{"sha":"377b14fa1d973458257288a4459a4a34e49af4ff","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","status":"added","additions":521,"deletions":0,"changes":521,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,521 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.Channel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * This class handles communication with clients using NIO. There is one Cnxn\n+ * per client, but only one thread doing the communication.\n+ */\n+public class NIOServerFactory extends Thread {\n+\n+    public interface PacketProcessor {\n+        public void processPacket(ByteBuffer packet, Cnxn src);\n+    }\n+    \n+    ServerStats stats = new ServerStats();\n+\n+    Logger LOG = Logger.getLogger(NIOServerFactory.class);\n+\n+    ServerSocketChannel ss;\n+\n+    Selector selector = Selector.open();\n+\n+    /**\n+     * We use this buffer to do efficient socket I/O. Since there is a single\n+     * sender thread per NIOServerCnxn instance, we can use a member variable to\n+     * only allocate it once.\n+     */\n+    ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);\n+\n+    HashSet<Cnxn> cnxns = new HashSet<Cnxn>();\n+\n+    int outstandingLimit = 2000;\n+\n+    PacketProcessor processor;\n+\n+    long minLatency = 99999999;\n+\n+    public NIOServerFactory(int port, PacketProcessor processor) throws IOException {\n+        super(\"NIOServerFactory\");\n+        setDaemon(true);\n+        this.processor = processor;\n+        this.ss = ServerSocketChannel.open();\n+        ss.socket().bind(new InetSocketAddress(port));\n+        ss.configureBlocking(false);\n+        ss.register(selector, SelectionKey.OP_ACCEPT);\n+        start();\n+    }\n+\n+    public InetSocketAddress getLocalAddress() {\n+        return (InetSocketAddress) ss.socket().getLocalSocketAddress();\n+    }\n+\n+    private void addCnxn(Cnxn cnxn) {\n+        synchronized (cnxns) {\n+            cnxns.add(cnxn);\n+        }\n+    }\n+\n+    public boolean isRunning() {\n+        return !ss.socket().isClosed();\n+    }\n+    \n+    @Override\n+    public void run() {\n+        while (!ss.socket().isClosed()) {\n+            try {\n+                selector.select(1000);\n+                Set<SelectionKey> selected;\n+                synchronized (this) {\n+                    selected = selector.selectedKeys();\n+                }\n+                ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(selected);\n+                Collections.shuffle(selectedList);\n+                for (SelectionKey k : selectedList) {\n+                    if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {\n+                        SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n+                        sc.configureBlocking(false);\n+                        SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);\n+                        Cnxn cnxn = new Cnxn(sc, sk);\n+                        sk.attach(cnxn);\n+                        addCnxn(cnxn);\n+                    } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {\n+                        Cnxn c = (Cnxn) k.attachment();\n+                        c.doIO(k);\n+                    }\n+                }\n+                selected.clear();\n+            } catch (Exception e) {\n+                LOG.warn(e);\n+            }\n+        }\n+        LOG.debug(\"NIOServerCnxn factory exitedloop.\");\n+        clear();\n+        // System.exit(0);\n+    }\n+\n+    /**\n+     * clear all the connections in the selector\n+     * \n+     */\n+    synchronized public void clear() {\n+        selector.wakeup();\n+        synchronized (cnxns) {\n+            // got to clear all the connections that we have in the selector\n+            for (Iterator<Cnxn> it = cnxns.iterator(); it.hasNext();) {\n+                Cnxn cnxn = it.next();\n+                it.remove();\n+                try {\n+                    cnxn.close();\n+                } catch (Exception e) {\n+                    // Do nothing.\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    public void shutdown() {\n+        try {\n+            ss.close();\n+            clear();\n+            this.interrupt();\n+            this.join();\n+        } catch (InterruptedException e) {\n+            LOG.warn(\"Interrupted\", e);\n+        } catch (Exception e) {\n+            LOG.error(\"Unexpected exception\", e);\n+        }\n+    }\n+\n+    /**\n+     * The buffer will cause the connection to be close when we do a send.\n+     */\n+    static final ByteBuffer closeConn = ByteBuffer.allocate(0);\n+\n+    public class Cnxn {\n+\n+        private SocketChannel sock;\n+\n+        private SelectionKey sk;\n+\n+        boolean initialized;\n+\n+        ByteBuffer lenBuffer = ByteBuffer.allocate(4);\n+\n+        ByteBuffer incomingBuffer = lenBuffer;\n+\n+        LinkedBlockingQueue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();\n+\n+        int sessionTimeout;\n+\n+        int packetsSent;\n+\n+        int packetsReceived;\n+\n+        void doIO(SelectionKey k) throws InterruptedException {\n+            try {\n+                if (sock == null) {\n+                    return;\n+                }\n+                if (k.isReadable()) {\n+                    int rc = sock.read(incomingBuffer);\n+                    if (rc < 0) {\n+                        throw new IOException(\"Read error\");\n+                    }\n+                    if (incomingBuffer.remaining() == 0) {\n+                        incomingBuffer.flip();\n+                        if (incomingBuffer == lenBuffer) {\n+                            readLength(k);\n+                        } else {\n+                            cnxnStats.packetsReceived++;\n+                            stats.incrementPacketsReceived();\n+                            try {\n+                                readRequest();\n+                            } finally {\n+                                lenBuffer.clear();\n+                                incomingBuffer = lenBuffer;\n+                            }\n+                        }\n+                    }\n+                }\n+                if (k.isWritable()) {\n+                    if (outgoingBuffers.size() > 0) {\n+                        // ZooLog.logTraceMessage(LOG,\n+                        // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,\n+                        // \"sk \" + k + \" is valid: \" +\n+                        // k.isValid());\n+\n+                        /*\n+                         * This is going to reset the buffer position to 0 and\n+                         * the limit to the size of the buffer, so that we can\n+                         * fill it with data from the non-direct buffers that we\n+                         * need to send.\n+                         */\n+                        directBuffer.clear();\n+\n+                        for (ByteBuffer b : outgoingBuffers) {\n+                            if (directBuffer.remaining() < b.remaining()) {\n+                                /*\n+                                 * When we call put later, if the directBuffer\n+                                 * is to small to hold everything, nothing will\n+                                 * be copied, so we've got to slice the buffer\n+                                 * if it's too big.\n+                                 */\n+                                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n+                            }\n+                            /*\n+                             * put() is going to modify the positions of both\n+                             * buffers, put we don't want to change the position\n+                             * of the source buffers (we'll do that after the\n+                             * send, if needed), so we save and reset the\n+                             * position after the copy\n+                             */\n+                            int p = b.position();\n+                            directBuffer.put(b);\n+                            b.position(p);\n+                            if (directBuffer.remaining() == 0) {\n+                                break;\n+                            }\n+                        }\n+                        /*\n+                         * Do the flip: limit becomes position, position gets\n+                         * set to 0. This sets us up for the write.\n+                         */\n+                        directBuffer.flip();\n+\n+                        int sent = sock.write(directBuffer);\n+                        ByteBuffer bb;\n+\n+                        // Remove the buffers that we have sent\n+                        while (outgoingBuffers.size() > 0) {\n+                            bb = outgoingBuffers.peek();\n+                            if (bb == closeConn) {\n+                                throw new IOException(\"closing\");\n+                            }\n+                            int left = bb.remaining() - sent;\n+                            if (left > 0) {\n+                                /*\n+                                 * We only partially sent this buffer, so we\n+                                 * update the position and exit the loop.\n+                                 */\n+                                bb.position(bb.position() + sent);\n+                                break;\n+                            }\n+                            cnxnStats.packetsSent++;\n+                            /* We've sent the whole buffer, so drop the buffer */\n+                            sent -= bb.remaining();\n+                            ServerStats.getInstance().incrementPacketsSent();\n+                            outgoingBuffers.remove();\n+                        }\n+                        // ZooLog.logTraceMessage(LOG,\n+                        // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, \"after send,\n+                        // outgoingBuffers.size() = \" + outgoingBuffers.size());\n+                    }\n+                    synchronized (this) {\n+                        if (outgoingBuffers.size() == 0) {\n+                            if (!initialized && (sk.interestOps() & SelectionKey.OP_READ) == 0) {\n+                                throw new IOException(\"Responded to info probe\");\n+                            }\n+                            sk.interestOps(sk.interestOps() & (~SelectionKey.OP_WRITE));\n+                        } else {\n+                            sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);\n+                        }\n+                    }\n+                }\n+            } catch (CancelledKeyException e) {\n+                close();\n+            } catch (IOException e) {\n+                // LOG.error(\"FIXMSG\",e);\n+                close();\n+            }\n+        }\n+\n+        private void readRequest() throws IOException {\n+            incomingBuffer = incomingBuffer.slice();\n+            processor.processPacket(incomingBuffer, this);\n+        }\n+\n+        public void disableRecv() {\n+            sk.interestOps(sk.interestOps() & (~SelectionKey.OP_READ));\n+        }\n+\n+        public void enableRecv() {\n+            if (sk.isValid()) {\n+                int interest = sk.interestOps();\n+                if ((interest & SelectionKey.OP_READ) == 0) {\n+                    sk.interestOps(interest | SelectionKey.OP_READ);\n+                }\n+            }\n+        }\n+\n+        private void readLength(SelectionKey k) throws IOException {\n+            // Read the length, now get the buffer\n+            int len = lenBuffer.getInt();\n+            if (len < 0 || len > 0xfffff) {\n+                throw new IOException(\"Len error \" + len);\n+            }\n+            incomingBuffer = ByteBuffer.allocate(len);\n+        }\n+\n+        /**\n+         * The number of requests that have been submitted but not yet responded\n+         * to.\n+         */\n+        int outstandingRequests;\n+\n+        /*\n+         * (non-Javadoc)\n+         * \n+         * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n+         */\n+        public int getSessionTimeout() {\n+            return sessionTimeout;\n+        }\n+\n+        String peerName;\n+\n+        public Cnxn(SocketChannel sock, SelectionKey sk) throws IOException {\n+            this.sock = sock;\n+            this.sk = sk;\n+            sock.socket().setTcpNoDelay(true);\n+            sock.socket().setSoLinger(true, 2);\n+            sk.interestOps(SelectionKey.OP_READ);\n+            if (LOG.isTraceEnabled()) {\n+                peerName = sock.socket().toString();\n+            }\n+\n+            lenBuffer.clear();\n+            incomingBuffer = lenBuffer;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"NIOServerCnxn object with sock = \" + sock + \" and sk = \" + sk;\n+        }\n+\n+        boolean closed;\n+\n+        /*\n+         * (non-Javadoc)\n+         * \n+         * @see org.apache.zookeeper.server.ServerCnxnIface#close()\n+         */\n+        public void close() {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            synchronized (cnxns) {\n+                cnxns.remove(this);\n+            }\n+            LOG.debug(\"close  NIOServerCnxn: \" + sock);\n+            try {\n+                /*\n+                 * The following sequence of code is stupid! You would think\n+                 * that only sock.close() is needed, but alas, it doesn't work\n+                 * that way. If you just do sock.close() there are cases where\n+                 * the socket doesn't actually close...\n+                 */\n+                sock.socket().shutdownOutput();\n+            } catch (IOException e) {\n+                // This is a relatively common exception that we can't avoid\n+            }\n+            try {\n+                sock.socket().shutdownInput();\n+            } catch (IOException e) {\n+            }\n+            try {\n+                sock.socket().close();\n+            } catch (IOException e) {\n+                LOG.error(\"FIXMSG\", e);\n+            }\n+            try {\n+                sock.close();\n+                // XXX The next line doesn't seem to be needed, but some posts\n+                // to forums suggest that it is needed. Keep in mind if errors\n+                // in\n+                // this section arise.\n+                // factory.selector.wakeup();\n+            } catch (IOException e) {\n+                LOG.error(\"FIXMSG\", e);\n+            }\n+            sock = null;\n+            if (sk != null) {\n+                try {\n+                    // need to cancel this selection key from the selector\n+                    sk.cancel();\n+                } catch (Exception e) {\n+                }\n+            }\n+        }\n+\n+        private void makeWritable(SelectionKey sk) {\n+            try {\n+                selector.wakeup();\n+                if (sk.isValid()) {\n+                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);\n+                }\n+            } catch (RuntimeException e) {\n+                LOG.error(\"Problem setting writable\", e);\n+                throw e;\n+            }\n+        }\n+\n+        private void sendBuffers(ByteBuffer bb[]) {\n+            ByteBuffer len = ByteBuffer.allocate(4);\n+            int total = 0;\n+            for (int i = 0; i < bb.length; i++) {\n+                if (bb[i] != null) {\n+                    total += bb[i].remaining();\n+                }\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.debug(\"Sending response of size \" + total + \" to \" + peerName);\n+            }\n+            len.putInt(total);\n+            len.flip();\n+            outgoingBuffers.add(len);\n+            for (int i = 0; i < bb.length; i++) {\n+                if (bb[i] != null) {\n+                    outgoingBuffers.add(bb[i]);\n+                }\n+            }\n+            makeWritable(sk);\n+        }\n+\n+        synchronized public void sendResponse(ByteBuffer bb[]) {\n+            if (closed) {\n+                return;\n+            }\n+            sendBuffers(bb);\n+            synchronized (NIOServerFactory.this) {\n+                outstandingRequests--;\n+                // check throttling\n+                if (outstandingRequests < outstandingLimit) {\n+                    sk.selector().wakeup();\n+                    enableRecv();\n+                }\n+            }\n+        }\n+\n+        public InetSocketAddress getRemoteAddress() {\n+            return (InetSocketAddress) sock.socket().getRemoteSocketAddress();\n+        }\n+\n+        private class CnxnStats {\n+            long packetsReceived;\n+\n+            long packetsSent;\n+\n+            /**\n+             * The number of requests that have been submitted but not yet\n+             * responded to.\n+             */\n+            public long getOutstandingRequests() {\n+                return outstandingRequests;\n+            }\n+\n+            public long getPacketsReceived() {\n+                return packetsReceived;\n+            }\n+\n+            public long getPacketsSent() {\n+                return packetsSent;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                StringBuilder sb = new StringBuilder();\n+                Channel channel = sk.channel();\n+                if (channel instanceof SocketChannel) {\n+                    sb.append(\" \").append(((SocketChannel) channel).socket().getRemoteSocketAddress()).append(\"[\")\n+                            .append(Integer.toHexString(sk.interestOps())).append(\"](queued=\").append(\n+                                    getOutstandingRequests()).append(\",recved=\").append(getPacketsReceived()).append(\n+                                    \",sent=\").append(getPacketsSent()).append(\")\\n\");\n+                }\n+                return sb.toString();\n+            }\n+        }\n+\n+        private CnxnStats cnxnStats = new CnxnStats();\n+\n+        public CnxnStats getStats() {\n+            return cnxnStats;\n+        }\n+    }\n+}"},{"sha":"14879b67f62570ae76ab28f92894eda38f894faf","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"added","additions":573,"deletions":0,"changes":573,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,573 @@\n+package org.apache.bookkeeper.proto;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.bookkeeper.util.SafeRunnable;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.bootstrap.ClientBootstrap;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.channel.ChannelPipelineCoverage;\n+import org.jboss.netty.channel.ChannelPipelineFactory;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.Channels;\n+import org.jboss.netty.channel.ExceptionEvent;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.handler.codec.frame.CorruptedFrameException;\n+import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n+import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n+\n+/**\n+ * This class manages all details of connection to a particular bookie. It also\n+ * has reconnect logic if a connection to a bookie fails.\n+ * \n+ */\n+\n+@ChannelPipelineCoverage(\"one\")\n+public class PerChannelBookieClient extends SimpleChannelHandler implements ChannelPipelineFactory {\n+\n+    static final Logger LOG = Logger.getLogger(PerChannelBookieClient.class);\n+\n+    static final long maxMemory = Runtime.getRuntime().maxMemory() / 5;\n+    public static int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n+\n+    InetSocketAddress addr;\n+    boolean connected = false;\n+    Semaphore opCounterSem = new Semaphore(2000);\n+    AtomicLong totalBytesOutstanding;\n+    ClientSocketChannelFactory channelFactory;\n+    OrderedSafeExecutor executor;\n+\n+    ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n+    ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n+\n+    /**\n+     * The following member variables do not need to be concurrent, or volatile\n+     * because they are always updated under a lock\n+     */\n+    Queue<GenericCallback<Void>> pendingOps = new ArrayDeque<GenericCallback<Void>>();\n+    boolean connectionAttemptInProgress;\n+    Channel channel = null;\n+\n+    public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+            InetSocketAddress addr, AtomicLong totalBytesOutstanding) {\n+        this.addr = addr;\n+        this.executor = executor;\n+        this.totalBytesOutstanding = totalBytesOutstanding;\n+        this.channelFactory = channelFactory;\n+        connect(channelFactory);\n+    }\n+\n+    void connect(ChannelFactory channelFactory) {\n+\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Connecting to bookie: \" + addr);\n+\n+        // Set up the ClientBootStrap so we can create a new Channel connection\n+        // to the bookie.\n+        ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);\n+        bootstrap.setPipelineFactory(this);\n+        bootstrap.setOption(\"tcpNoDelay\", true);\n+        bootstrap.setOption(\"keepAlive\", true);\n+\n+        // Start the connection attempt to the input server host.\n+        connectionAttemptInProgress = true;\n+\n+        ChannelFuture future = bootstrap.connect(addr);\n+\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                int rc;\n+                Queue<GenericCallback<Void>> oldPendingOps;\n+\n+                synchronized (PerChannelBookieClient.this) {\n+\n+                    if (future.isSuccess()) {\n+                        LOG.info(\"Successfully connected to bookie: \" + addr);\n+                        rc = BKException.Code.OK;\n+                        channel = future.getChannel();\n+                        connected = true;\n+                    } else {\n+                        LOG.error(\"Could not connect to bookie: \" + addr);\n+                        rc = BKException.Code.BookieHandleNotAvailableException;\n+                        channel = null;\n+                        connected = false;\n+                    }\n+\n+                    connectionAttemptInProgress = false;\n+                    PerChannelBookieClient.this.channel = channel;\n+\n+                    // trick to not do operations under the lock, take the list\n+                    // of pending ops and assign it to a new variable, while\n+                    // emptying the pending ops by just assigning it to a new\n+                    // list\n+                    oldPendingOps = pendingOps;\n+                    pendingOps = new ArrayDeque<GenericCallback<Void>>();\n+                }\n+\n+                for (GenericCallback<Void> pendingOp : oldPendingOps) {\n+                    pendingOp.operationComplete(rc, null);\n+                }\n+\n+            }\n+        });\n+    }\n+\n+    void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n+        boolean doOpNow;\n+\n+        // common case without lock first\n+        if (channel != null && connected) {\n+            doOpNow = true;\n+        } else {\n+\n+            synchronized (this) {\n+                // check again under lock\n+                if (channel != null && connected) {\n+                    doOpNow = true;\n+                } else {\n+\n+                    // if reached here, channel is either null (first connection\n+                    // attempt),\n+                    // or the channel is disconnected\n+                    doOpNow = false;\n+\n+                    // connection attempt is still in progress, queue up this\n+                    // op. Op will be executed when connection attempt either\n+                    // fails\n+                    // or\n+                    // succeeds\n+                    pendingOps.add(op);\n+\n+                    if (!connectionAttemptInProgress) {\n+                        connect(channelFactory);\n+                    }\n+\n+                }\n+            }\n+        }\n+\n+        if (doOpNow) {\n+            op.operationComplete(BKException.Code.OK, null);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method should be called only after connection has been checked for\n+     * {@link #connectIfNeededAndDoOp(GenericCallback)}\n+     * \n+     * @param ledgerId\n+     * @param masterKey\n+     * @param entryId\n+     * @param lastConfirmed\n+     * @param macCode\n+     * @param data\n+     * @param cb\n+     * @param ctx\n+     */\n+    void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n+            Object ctx) {\n+\n+        final int entrySize = toSend.readableBytes();\n+        \n+        // if (totalBytesOutstanding.get() > maxMemory) {\n+        // // TODO: how to throttle, throw an exception, or call the callback?\n+        // // Maybe this should be done at the layer above?\n+        // }\n+\n+        final CompletionKey completionKey = new CompletionKey(ledgerId, entryId);\n+\n+        addCompletions.put(completionKey, new AddCompletion(cb, entrySize, ctx));\n+\n+        int totalHeaderSize = 4 // for the length of the packet\n+        + 4 // for the type of request\n+        + masterKey.length; // for the master key\n+\n+        ChannelBuffer header = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+        header.writeInt(totalHeaderSize - 4 + entrySize);\n+        header.writeInt(BookieProtocol.ADDENTRY);\n+        header.writeBytes(masterKey);\n+\n+        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer(header, toSend);\n+\n+        ChannelFuture future = channel.write(wrappedBuffer);\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (future.isSuccess()) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Successfully wrote request for adding entry: \" + entryId + \" ledger-id: \" + ledgerId\n+                                + \" bookie: \" + channel.getRemoteAddress() + \" entry length: \" + entrySize);\n+                    }\n+                    // totalBytesOutstanding.addAndGet(entrySize);\n+                } else {\n+                    errorOutAddKey(completionKey);\n+                }\n+            }\n+        });\n+\n+    }\n+\n+    public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n+\n+        final CompletionKey key = new CompletionKey(ledgerId, entryId);\n+        readCompletions.put(key, new ReadCompletion(cb, ctx));\n+\n+        int totalHeaderSize = 4 // for the length of the packet\n+        + 4 // for request type\n+        + 8 // for ledgerId\n+        + 8; // for entryId\n+\n+        ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+        tmpEntry.writeInt(totalHeaderSize - 4);\n+        tmpEntry.writeInt(BookieProtocol.READENTRY);\n+        tmpEntry.writeLong(ledgerId);\n+        tmpEntry.writeLong(entryId);\n+\n+        ChannelFuture future = channel.write(tmpEntry);\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (future.isSuccess()) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Successfully wrote request for reading entry: \" + entryId + \" ledger-id: \"\n+                                + ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+                    }\n+                } else {\n+                    errorOutReadKey(key);\n+                }\n+            }\n+        });\n+\n+    }\n+\n+    public void close() {\n+        if (channel != null) {\n+            channel.close();\n+        }\n+    }\n+\n+    void errorOutReadKey(final CompletionKey key) {\n+        executor.submitOrdered(key.ledgerId, new SafeRunnable() {\n+            @Override\n+            public void safeRun() {\n+\n+                ReadCompletion readCompletion = readCompletions.remove(key);\n+\n+                if (readCompletion != null) {\n+                    LOG.error(\"Could not write  request for reading entry: \" + key.entryId + \" ledger-id: \"\n+                            + key.ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+\n+                    readCompletion.cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException,\n+                            key.ledgerId, key.entryId, null, readCompletion.ctx);\n+                }\n+            }\n+\n+        });\n+    }\n+\n+    void errorOutAddKey(final CompletionKey key) {\n+        executor.submitOrdered(key.ledgerId, new SafeRunnable() {\n+            @Override\n+            public void safeRun() {\n+\n+                AddCompletion addCompletion = addCompletions.remove(key);\n+\n+                if (addCompletion != null) {\n+                    String bAddress = \"null\";\n+                    if(channel != null)\n+                        bAddress = channel.getRemoteAddress().toString();\n+                    LOG.error(\"Could not write request for adding entry: \" + key.entryId + \" ledger-id: \"\n+                            + key.ledgerId + \" bookie: \" + bAddress);\n+\n+                    addCompletion.cb.writeComplete(BKException.Code.BookieHandleNotAvailableException, key.ledgerId,\n+                            key.entryId, addr, addCompletion.ctx);\n+                    LOG.error(\"Invoked callback method: \" + key.entryId);\n+                }\n+            }\n+\n+        });\n+\n+    }\n+\n+    /**\n+     * Errors out pending entries. We call this method from one thread to avoid\n+     * concurrent executions to QuorumOpMonitor (implements callbacks). It seems\n+     * simpler to call it from BookieHandle instead of calling directly from\n+     * here.\n+     */\n+\n+    void errorOutOutstandingEntries() {\n+\n+        // DO NOT rewrite these using Map.Entry iterations. We want to iterate\n+        // on keys and see if we are successfully able to remove the key from\n+        // the map. Because the add and the read methods also do the same thing\n+        // in case they get a write failure on the socket. The one who\n+        // successfully removes the key from the map is the one responsible for\n+        // calling the application callback.\n+\n+        for (CompletionKey key : addCompletions.keySet()) {\n+            errorOutAddKey(key);\n+        }\n+\n+        for (CompletionKey key : readCompletions.keySet()) {\n+            errorOutReadKey(key);\n+        }\n+    }\n+\n+    /**\n+     * In the netty pipeline, we need to split packets based on length, so we\n+     * use the {@link LengthFieldBasedFrameDecoder}. Other than that all actions\n+     * are carried out in this class, e.g., making sense of received messages,\n+     * prepending the length to outgoing packets etc.\n+     */\n+    @Override\n+    public ChannelPipeline getPipeline() throws Exception {\n+        ChannelPipeline pipeline = Channels.pipeline();\n+        pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));\n+        pipeline.addLast(\"mainhandler\", this);\n+        return pipeline;\n+    }\n+\n+    /**\n+     * If our channel has disconnected, we just error out the pending entries\n+     */\n+    @Override\n+    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        LOG.info(\"Disconnected from bookie: \" + addr);\n+    \terrorOutOutstandingEntries();\n+        channel.close();\n+\n+        connected = false;\n+\n+        // we don't want to reconnect right away. If someone sends a request to\n+        // this address, we will reconnect.\n+    }\n+\n+    /**\n+     * Called by netty when an exception happens in one of the netty threads\n+     * (mostly due to what we do in the netty threads)\n+     */\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n+        Throwable t = e.getCause();\n+        if (t instanceof CorruptedFrameException || t instanceof TooLongFrameException) {\n+            LOG.error(\"Corrupted fram recieved from bookie: \" + e.getChannel().getRemoteAddress());\n+            return;\n+        }\n+        if (t instanceof IOException) {\n+            // these are thrown when a bookie fails, logging them just pollutes\n+            // the logs (the failure is logged from the listeners on the write\n+            // operation), so I'll just ignore it here.\n+            return;\n+        }\n+\n+        LOG.fatal(\"Unexpected exception caught by bookie client channel handler\", t);\n+        // Since we are a library, cant terminate App here, can we?\n+    }\n+\n+    /**\n+     * Called by netty when a message is received on a channel\n+     */\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+        if (!(e.getMessage() instanceof ChannelBuffer)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n+\n+        final ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n+        final int type, rc;\n+        final long ledgerId, entryId;\n+\n+        try {\n+            type = buffer.readInt();\n+            rc = buffer.readInt();\n+            ledgerId = buffer.readLong();\n+            entryId = buffer.readLong();\n+        } catch (IndexOutOfBoundsException ex) {\n+            LOG.error(\"Unparseable response from bookie: \" + addr, ex);\n+            return;\n+        }\n+\n+        executor.submitOrdered(ledgerId, new SafeRunnable() {\n+            @Override\n+            public void safeRun() {\n+                switch (type) {\n+                case BookieProtocol.ADDENTRY:\n+                    handleAddResponse(ledgerId, entryId, rc);\n+                    break;\n+                case BookieProtocol.READENTRY:\n+                    handleReadResponse(ledgerId, entryId, rc, buffer);\n+                    break;\n+                default:\n+                    LOG.error(\"Unexpected response, type: \" + type + \" recieved from bookie: \" + addr + \" , ignoring\");\n+                }\n+            }\n+\n+        });\n+    }\n+\n+    void handleAddResponse(long ledgerId, long entryId, int rc) {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n+                    + entryId + \" rc: \" + rc);\n+        }\n+\n+        // convert to BKException code because thats what the uppper\n+        // layers expect. This is UGLY, there should just be one set of\n+        // error codes.\n+        if (rc != BookieProtocol.EOK) {\n+            LOG.error(\"Add for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n+                    + \" with code: \" + rc);\n+            rc = BKException.Code.WriteException;\n+        } else {\n+            rc = BKException.Code.OK;\n+        }\n+\n+        AddCompletion ac;\n+        ac = addCompletions.remove(new CompletionKey(ledgerId, entryId));\n+        if (ac == null) {\n+            LOG.error(\"Unexpected add response received from bookie: \" + addr + \" for ledger: \" + ledgerId\n+                    + \", entry: \" + entryId + \" , ignoring\");\n+            return;\n+        }\n+\n+        // totalBytesOutstanding.addAndGet(-ac.size);\n+\n+        ac.cb.writeComplete(rc, ledgerId, entryId, addr, ac.ctx);\n+\n+    }\n+\n+    void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffer) {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n+                    + entryId + \" rc: \" + rc + \"entry length: \" + buffer.readableBytes());\n+        }\n+\n+        // convert to BKException code because thats what the uppper\n+        // layers expect. This is UGLY, there should just be one set of\n+        // error codes.\n+        if (rc == BookieProtocol.EOK) {\n+            rc = BKException.Code.OK;\n+        } else if (rc == BookieProtocol.ENOENTRY || rc == BookieProtocol.ENOLEDGER) {\n+            rc = BKException.Code.NoSuchEntryException;\n+        } else {\n+            LOG.error(\"Read for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n+                    + \" with code: \" + rc);\n+            rc = BKException.Code.ReadException;\n+        }\n+\n+        CompletionKey key = new CompletionKey(ledgerId, entryId);\n+        ReadCompletion readCompletion = readCompletions.remove(key);\n+\n+        if (readCompletion == null) {\n+            /*\n+             * This is a special case. When recovering a ledger, a client\n+             * submits a read request with id -1, and receives a response with a\n+             * different entry id.\n+             */\n+            readCompletion = readCompletions.remove(new CompletionKey(ledgerId, -1));\n+        }\n+\n+        if (readCompletion == null) {\n+            LOG.error(\"Unexpected read response recieved from bookie: \" + addr + \" for ledger: \" + ledgerId\n+                    + \", entry: \" + entryId + \" , ignoring\");\n+            return;\n+        }\n+\n+        readCompletion.cb.readEntryComplete(rc, ledgerId, entryId, buffer.slice(), readCompletion.ctx);\n+    }\n+\n+    /**\n+     * Boiler-plate wrapper classes follow\n+     * \n+     */\n+\n+    private static class ReadCompletion {\n+        final ReadEntryCallback cb;\n+        final Object ctx;\n+\n+        public ReadCompletion(ReadEntryCallback cb, Object ctx) {\n+            this.cb = cb;\n+            this.ctx = ctx;\n+        }\n+    }\n+\n+    private static class AddCompletion {\n+        final WriteCallback cb;\n+        //final long size;\n+        final Object ctx;\n+\n+        public AddCompletion(WriteCallback cb, long size, Object ctx) {\n+            this.cb = cb;\n+            //this.size = size;\n+            this.ctx = ctx;\n+        }\n+    }\n+\n+    private static class CompletionKey {\n+        long ledgerId;\n+        long entryId;\n+\n+        CompletionKey(long ledgerId, long entryId) {\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof CompletionKey) || obj == null) {\n+                return false;\n+            }\n+            CompletionKey that = (CompletionKey) obj;\n+            return this.ledgerId == that.ledgerId && this.entryId == that.entryId;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return ((int) ledgerId << 16) ^ ((int) entryId);\n+        }\n+\n+    }\n+\n+}"},{"sha":"65c051fc03860fcb352dee393738e4434e9f1726","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/proto/ServerStats.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/ServerStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/proto/ServerStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/proto/ServerStats.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,148 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.proto;\n+\n+public class ServerStats {\n+    private static ServerStats instance = new ServerStats();\n+    private long packetsSent;\n+    private long packetsReceived;\n+    private long maxLatency;\n+    private long minLatency = Long.MAX_VALUE;\n+    private long totalLatency = 0;\n+    private long count = 0;\n+\n+    public interface Provider {\n+        public long getOutstandingRequests();\n+\n+        public long getLastProcessedZxid();\n+    }\n+\n+    private Provider provider = null;\n+    private Object mutex = new Object();\n+\n+    static public ServerStats getInstance() {\n+        return instance;\n+    }\n+\n+    static public void registerAsConcrete() {\n+        setInstance(new ServerStats());\n+    }\n+\n+    static synchronized public void unregister() {\n+        instance = null;\n+    }\n+\n+    static synchronized protected void setInstance(ServerStats newInstance) {\n+        assert instance == null;\n+        instance = newInstance;\n+    }\n+\n+    protected ServerStats() {\n+    }\n+\n+    // getters\n+    synchronized public long getMinLatency() {\n+        return (minLatency == Long.MAX_VALUE) ? 0 : minLatency;\n+    }\n+\n+    synchronized public long getAvgLatency() {\n+        if (count != 0)\n+            return totalLatency / count;\n+        return 0;\n+    }\n+\n+    synchronized public long getMaxLatency() {\n+        return maxLatency;\n+    }\n+\n+    public long getOutstandingRequests() {\n+        synchronized (mutex) {\n+            return (provider != null) ? provider.getOutstandingRequests() : -1;\n+        }\n+    }\n+\n+    public long getLastProcessedZxid() {\n+        synchronized (mutex) {\n+            return (provider != null) ? provider.getLastProcessedZxid() : -1;\n+        }\n+    }\n+\n+    synchronized public long getPacketsReceived() {\n+        return packetsReceived;\n+    }\n+\n+    synchronized public long getPacketsSent() {\n+        return packetsSent;\n+    }\n+\n+    public String getServerState() {\n+        return \"standalone\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Latency min/avg/max: \" + getMinLatency() + \"/\" + getAvgLatency() + \"/\" + getMaxLatency() + \"\\n\");\n+        sb.append(\"Received: \" + getPacketsReceived() + \"\\n\");\n+        sb.append(\"Sent: \" + getPacketsSent() + \"\\n\");\n+        if (provider != null) {\n+            sb.append(\"Outstanding: \" + getOutstandingRequests() + \"\\n\");\n+            sb.append(\"Zxid: 0x\" + Long.toHexString(getLastProcessedZxid()) + \"\\n\");\n+        }\n+        sb.append(\"Mode: \" + getServerState() + \"\\n\");\n+        return sb.toString();\n+    }\n+\n+    // mutators\n+    public void setStatsProvider(Provider zk) {\n+        synchronized (mutex) {\n+            provider = zk;\n+        }\n+    }\n+\n+    synchronized void updateLatency(long requestCreateTime) {\n+        long latency = System.currentTimeMillis() - requestCreateTime;\n+        totalLatency += latency;\n+        count++;\n+        if (latency < minLatency) {\n+            minLatency = latency;\n+        }\n+        if (latency > maxLatency) {\n+            maxLatency = latency;\n+        }\n+    }\n+\n+    synchronized public void resetLatency() {\n+        totalLatency = count = maxLatency = 0;\n+        minLatency = Long.MAX_VALUE;\n+    }\n+\n+    synchronized public void resetMaxLatency() {\n+        maxLatency = getMinLatency();\n+    }\n+\n+    synchronized public void incrementPacketsReceived() {\n+        packetsReceived++;\n+    }\n+\n+    synchronized public void incrementPacketsSent() {\n+        packetsSent++;\n+    }\n+\n+    synchronized public void resetRequestCounters() {\n+        packetsReceived = packetsSent = 0;\n+    }\n+\n+}"},{"sha":"5566aa29afc70c00260a8d9d61f9cc43233219a7","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","status":"added","additions":173,"deletions":0,"changes":173,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerInputStream.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,173 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+package org.apache.bookkeeper.streaming;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Enumeration;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.log4j.Logger;\n+\n+public class LedgerInputStream extends InputStream {\n+    Logger LOG = Logger.getLogger(LedgerInputStream.class);\n+    private LedgerHandle lh;\n+    private ByteBuffer bytebuff;\n+    byte[] bbytes;\n+    long lastEntry = 0;\n+    int increment = 50;\n+    int defaultSize = 1024 * 1024; // 1MB default size\n+    Enumeration<LedgerEntry> ledgerSeq = null;\n+\n+    /**\n+     * construct a outputstream from a ledger handle\n+     * \n+     * @param lh\n+     *            ledger handle\n+     * @throws {@link BKException}, {@link InterruptedException}\n+     */\n+    public LedgerInputStream(LedgerHandle lh) throws BKException, InterruptedException {\n+        this.lh = lh;\n+        bbytes = new byte[defaultSize];\n+        this.bytebuff = ByteBuffer.wrap(bbytes);\n+        this.bytebuff.position(this.bytebuff.limit());\n+        lastEntry = Math.min(lh.getLastAddConfirmed(), increment);\n+        ledgerSeq = lh.readEntries(0, lastEntry);\n+    }\n+\n+    /**\n+     * construct a outputstream from a ledger handle\n+     * \n+     * @param lh\n+     *            the ledger handle\n+     * @param size\n+     *            the size of the buffer\n+     * @throws {@link BKException}, {@link InterruptedException}\n+     */\n+    public LedgerInputStream(LedgerHandle lh, int size) throws BKException, InterruptedException {\n+        this.lh = lh;\n+        bbytes = new byte[size];\n+        this.bytebuff = ByteBuffer.wrap(bbytes);\n+        this.bytebuff.position(this.bytebuff.limit());\n+        lastEntry = Math.min(lh.getLastAddConfirmed(), increment);\n+        ledgerSeq = lh.readEntries(0, lastEntry);\n+    }\n+\n+    /**\n+     * Method close currently doesn't do anything. The application\n+     * is supposed to open and close the ledger handle backing up \n+     * a stream ({@link LedgerHandle}).\n+     */\n+    @Override\n+    public void close() {\n+        // do nothing\n+        // let the application\n+        // close the ledger\n+    }\n+\n+    /**\n+     * refill the buffer, we need to read more bytes\n+     * \n+     * @return if we can refill or not\n+     */\n+    private synchronized boolean refill() throws IOException {\n+        bytebuff.clear();\n+        if (!ledgerSeq.hasMoreElements() && lastEntry >= lh.getLastAddConfirmed()) {\n+            return false;\n+        }\n+        if (!ledgerSeq.hasMoreElements()) {\n+            // do refill\n+            long last = Math.min(lastEntry + increment, lh.getLastAddConfirmed());\n+            try {\n+                ledgerSeq = lh.readEntries(lastEntry + 1, last);\n+            } catch (BKException bk) {\n+                IOException ie = new IOException(bk.getMessage());\n+                ie.initCause(bk);\n+                throw ie;\n+            } catch (InterruptedException ie) {\n+                Thread.currentThread().interrupt();\n+            }\n+            lastEntry = last;\n+        }\n+        LedgerEntry le = ledgerSeq.nextElement();\n+        bbytes = le.getEntry();\n+        bytebuff = ByteBuffer.wrap(bbytes);\n+        return true;\n+    }\n+\n+    @Override\n+    public synchronized int read() throws IOException {\n+        boolean toread = true;\n+        if (bytebuff.remaining() == 0) {\n+            // their are no remaining bytes\n+            toread = refill();\n+        }\n+        if (toread) {\n+            int ret = 0xFF & bytebuff.get();\n+            return ret;\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    public synchronized int read(byte[] b) throws IOException {\n+        // be smart ... just copy the bytes\n+        // once and return the size\n+        // user will call it again\n+        boolean toread = true;\n+        if (bytebuff.remaining() == 0) {\n+            toread = refill();\n+        }\n+        if (toread) {\n+            int bcopied = bytebuff.remaining();\n+            int tocopy = Math.min(bcopied, b.length);\n+            // cannot used gets because of\n+            // the underflow/overflow exceptions\n+            System.arraycopy(bbytes, bytebuff.position(), b, 0, tocopy);\n+            bytebuff.position(bytebuff.position() + tocopy);\n+            return tocopy;\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    public synchronized int read(byte[] b, int off, int len) throws IOException {\n+        // again dont need ot fully\n+        // fill b, just return\n+        // what we have and let the application call read\n+        // again\n+        boolean toread = true;\n+        if (bytebuff.remaining() == 0) {\n+            toread = refill();\n+        }\n+        if (toread) {\n+            int bcopied = bytebuff.remaining();\n+            int tocopy = Math.min(bcopied, len);\n+            System.arraycopy(bbytes, bytebuff.position(), b, off, tocopy);\n+            bytebuff.position(bytebuff.position() + tocopy);\n+            return tocopy;\n+        }\n+        return -1;\n+    }\n+}"},{"sha":"8938d2abc75489e80314fad4174f401f8b2cb713","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","status":"added","additions":147,"deletions":0,"changes":147,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/streaming/LedgerOutputStream.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,147 @@\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+package org.apache.bookkeeper.streaming;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * this class provides a streaming api to get an output stream from a ledger\n+ * handle and write to it as a stream of bytes. This is built on top of\n+ * ledgerhandle api and uses a buffer to cache the data written to it and writes\n+ * out the entry to the ledger.\n+ */\n+public class LedgerOutputStream extends OutputStream {\n+    Logger LOG = Logger.getLogger(LedgerOutputStream.class);\n+    private LedgerHandle lh;\n+    private ByteBuffer bytebuff;\n+    byte[] bbytes;\n+    int defaultSize = 1024 * 1024; // 1MB default size\n+\n+    /**\n+     * construct a outputstream from a ledger handle\n+     * \n+     * @param lh\n+     *            ledger handle\n+     */\n+    public LedgerOutputStream(LedgerHandle lh) {\n+        this.lh = lh;\n+        bbytes = new byte[defaultSize];\n+        this.bytebuff = ByteBuffer.wrap(bbytes);\n+    }\n+\n+    /**\n+     * construct a outputstream from a ledger handle\n+     * \n+     * @param lh\n+     *            the ledger handle\n+     * @param size\n+     *            the size of the buffer\n+     */\n+    public LedgerOutputStream(LedgerHandle lh, int size) {\n+        this.lh = lh;\n+        bbytes = new byte[size];\n+        this.bytebuff = ByteBuffer.wrap(bbytes);\n+    }\n+\n+    @Override\n+    public void close() {\n+        // flush everything\n+        // we have\n+        flush();\n+    }\n+\n+    @Override\n+    public synchronized void flush() {\n+        // lets flush all the data\n+        // into the ledger entry\n+        if (bytebuff.position() > 0) {\n+            // copy the bytes into\n+            // a new byte buffer and send it out\n+            byte[] b = new byte[bytebuff.position()];\n+            LOG.info(\"Comment: flushing with params \" + \" \" + bytebuff.position());\n+            System.arraycopy(bbytes, 0, b, 0, bytebuff.position());\n+            try {\n+                lh.addEntry(b);\n+            } catch (InterruptedException ie) {\n+                LOG.warn(\"Interrupted while flusing \" + ie);\n+                Thread.currentThread().interrupt();\n+            } catch (BKException bke) {\n+                LOG.warn(\"BookKeeper exception \", bke);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * make space for len bytes to be written to the buffer.\n+     * \n+     * @param len\n+     * @return if true then we can make space for len if false we cannot\n+     */\n+    private boolean makeSpace(int len) {\n+        if (bytebuff.remaining() < len) {\n+            flush();\n+            bytebuff.clear();\n+            if (bytebuff.capacity() < len) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] b) {\n+        if (makeSpace(b.length)) {\n+            bytebuff.put(b);\n+        } else {\n+            try {\n+                lh.addEntry(b);\n+            } catch (InterruptedException ie) {\n+                LOG.warn(\"Interrupted while writing\", ie);\n+                Thread.currentThread().interrupt();\n+            } catch (BKException bke) {\n+                LOG.warn(\"BookKeeper exception\", bke);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] b, int off, int len) {\n+        if (!makeSpace(len)) {\n+            // lets try making the buffer bigger\n+            bbytes = new byte[len];\n+            bytebuff = ByteBuffer.wrap(bbytes);\n+        }\n+        bytebuff.put(b, off, len);\n+    }\n+\n+    @Override\n+    public synchronized void write(int b) throws IOException {\n+        makeSpace(1);\n+        byte oneB = (byte) (b & 0xFF);\n+        bytebuff.put(oneB);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"3cf886af45aaa205ed44e804cbbcf511babad2e1","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"added","additions":763,"deletions":0,"changes":763,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,763 @@\n+package org.apache.bookkeeper.tools;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.data.Stat;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * Provides Admin Tools to manage the BookKeeper cluster.\n+ * \n+ */\n+public class BookKeeperTools {\n+\n+    private static Logger LOG = Logger.getLogger(BookKeeperTools.class);\n+\n+    // ZK client instance\n+    private ZooKeeper zk;\n+    // ZK ledgers related String constants\n+    static final String LEDGERS_PATH = \"/ledgers\";\n+    static final String LEDGER_NODE_PREFIX = \"L\";\n+    static final String AVAILABLE_NODE = \"available\";\n+    static final String BOOKIES_PATH = LEDGERS_PATH + \"/\" + AVAILABLE_NODE;\n+    static final String COLON = \":\";\n+\n+    // BookKeeper client instance\n+    private BookKeeper bkc;\n+\n+    /*\n+     * Random number generator used to choose an available bookie server to\n+     * replicate data from a dead bookie.\n+     */\n+    private Random rand = new Random();\n+\n+    /*\n+     * For now, assume that all ledgers were created with the same DigestType\n+     * and password. In the future, this admin tool will need to know for each\n+     * ledger, what was the DigestType and password used to create it before it\n+     * can open it. These values will come from System properties, though hard\n+     * coded defaults are defined here.\n+     */\n+    private DigestType DIGEST_TYPE = DigestType.valueOf(System.getProperty(\"digestType\", DigestType.CRC32.toString()));\n+    private byte[] PASSWD = System.getProperty(\"passwd\", \"\").getBytes();\n+\n+    /**\n+     * Constructor that takes in a ZooKeeper servers connect string so we know\n+     * how to connect to ZooKeeper to retrieve information about the BookKeeper\n+     * cluster. We need this before we can do any type of admin operations on\n+     * the BookKeeper cluster.\n+     * \n+     * @param zkServers\n+     *            Comma separated list of hostname:port pairs for the ZooKeeper\n+     *            servers cluster.\n+     * @throws IOException\n+     *             Throws this exception if there is an error instantiating the\n+     *             ZooKeeper client.\n+     * @throws InterruptedException\n+     *             Throws this exception if there is an error instantiating the\n+     *             BookKeeper client.\n+     * @throws KeeperException\n+     *             Throws this exception if there is an error instantiating the\n+     *             BookKeeper client.\n+     */\n+    public BookKeeperTools(String zkServers) throws IOException, InterruptedException, KeeperException {\n+        // Create the ZooKeeper client instance\n+        zk = new ZooKeeper(zkServers, 10000, new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n+                }\n+            }\n+        });\n+        // Create the BookKeeper client instance\n+        bkc = new BookKeeper(zk);\n+    }\n+\n+    /**\n+     * Shutdown method to gracefully release resources that this class uses.\n+     * \n+     * @throws InterruptedException\n+     *             if there is an error shutting down the clients that this\n+     *             class uses.\n+     */\n+    public void shutdown() throws InterruptedException {\n+        bkc.halt();\n+        zk.close();\n+    }\n+\n+    /**\n+     * This is a multi callback object for bookie recovery that waits for all of\n+     * the multiple async operations to complete. If any fail, then we invoke\n+     * the final callback with a BK LedgerRecoveryException.\n+     */\n+    class MultiCallback implements AsyncCallback.VoidCallback {\n+        // Number of expected callbacks\n+        final int expected;\n+        // Final callback and the corresponding context to invoke\n+        final AsyncCallback.VoidCallback cb;\n+        final Object context;\n+        // This keeps track of how many operations have completed\n+        final AtomicInteger done = new AtomicInteger();\n+        // List of the exceptions from operations that completed unsuccessfully\n+        final LinkedBlockingQueue<Integer> exceptions = new LinkedBlockingQueue<Integer>();\n+\n+        MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context) {\n+            this.expected = expected;\n+            this.cb = cb;\n+            this.context = context;\n+            if (expected == 0) {\n+                cb.processResult(Code.OK.intValue(), null, context);\n+            }\n+        }\n+\n+        private void tick() {\n+            if (done.incrementAndGet() == expected) {\n+                if (exceptions.isEmpty()) {\n+                    cb.processResult(Code.OK.intValue(), null, context);\n+                } else {\n+                    cb.processResult(BKException.Code.LedgerRecoveryException, null, context);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void processResult(int rc, String path, Object ctx) {\n+            if (rc != Code.OK.intValue()) {\n+                LOG.error(\"BK error recovering ledger data\", BKException.create(rc));\n+                exceptions.add(rc);\n+            }\n+            tick();\n+        }\n+\n+    }\n+\n+    /**\n+     * Method to get the input ledger's digest type. For now, this is just a\n+     * placeholder function since there is no way we can get this information\n+     * easily. In the future, BookKeeper should store this ledger metadata\n+     * somewhere such that an admin tool can access it.\n+     * \n+     * @param ledgerId\n+     *            LedgerId we are retrieving the digestType for.\n+     * @return DigestType for the input ledger\n+     */\n+    private DigestType getLedgerDigestType(long ledgerId) {\n+        return DIGEST_TYPE;\n+    }\n+\n+    /**\n+     * Method to get the input ledger's password. For now, this is just a\n+     * placeholder function since there is no way we can get this information\n+     * easily. In the future, BookKeeper should store this ledger metadata\n+     * somewhere such that an admin tool can access it.\n+     * \n+     * @param ledgerId\n+     *            LedgerId we are retrieving the password for.\n+     * @return Password for the input ledger\n+     */\n+    private byte[] getLedgerPasswd(long ledgerId) {\n+        return PASSWD;\n+    }\n+\n+    // Object used for calling async methods and waiting for them to complete.\n+    class SyncObject {\n+        boolean value;\n+\n+        public SyncObject() {\n+            value = false;\n+        }\n+    }\n+\n+    /**\n+     * Synchronous method to rebuild and recover the ledger fragments data that\n+     * was stored on the source bookie. That bookie could have failed completely\n+     * and now the ledger data that was stored on it is under replicated. An\n+     * optional destination bookie server could be given if we want to copy all\n+     * of the ledger fragments data on the failed source bookie to it.\n+     * Otherwise, we will just randomly distribute the ledger fragments to the\n+     * active set of bookies, perhaps based on load. All ZooKeeper ledger\n+     * metadata will be updated to point to the new bookie(s) that contain the\n+     * replicated ledger fragments.\n+     * \n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     */\n+    public void recoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest)\n+            throws InterruptedException {\n+        SyncObject sync = new SyncObject();\n+        // Call the async method to recover bookie data.\n+        asyncRecoverBookieData(bookieSrc, bookieDest, new RecoverCallback() {\n+            @Override\n+            public void recoverComplete(int rc, Object ctx) {\n+                LOG.info(\"Recover bookie operation completed with rc: \" + rc);\n+                SyncObject syncObj = (SyncObject) ctx;\n+                synchronized (syncObj) {\n+                    syncObj.value = true;\n+                    syncObj.notify();\n+                }\n+            }\n+        }, sync);\n+\n+        // Wait for the async method to complete.\n+        synchronized (sync) {\n+            while (sync.value == false) {\n+                sync.wait();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Async method to rebuild and recover the ledger fragments data that was\n+     * stored on the source bookie. That bookie could have failed completely and\n+     * now the ledger data that was stored on it is under replicated. An\n+     * optional destination bookie server could be given if we want to copy all\n+     * of the ledger fragments data on the failed source bookie to it.\n+     * Otherwise, we will just randomly distribute the ledger fragments to the\n+     * active set of bookies, perhaps based on load. All ZooKeeper ledger\n+     * metadata will be updated to point to the new bookie(s) that contain the\n+     * replicated ledger fragments.\n+     * \n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     * @param cb\n+     *            RecoverCallback to invoke once all of the data on the dead\n+     *            bookie has been recovered and replicated.\n+     * @param context\n+     *            Context for the RecoverCallback to call.\n+     */\n+    public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+            final RecoverCallback cb, final Object context) {\n+        // Sync ZK to make sure we're reading the latest bookie/ledger data.\n+        zk.sync(LEDGERS_PATH, new AsyncCallback.VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error syncing: \", KeeperException.create(KeeperException.Code.get(rc), path));\n+                    cb.recoverComplete(BKException.Code.ZKException, context);\n+                    return;\n+                }\n+                getAvailableBookies(bookieSrc, bookieDest, cb, context);\n+            };\n+        }, null);\n+    }\n+\n+    /**\n+     * This method asynchronously gets the set of available Bookies that the\n+     * dead input bookie's data will be copied over into. If the user passed in\n+     * a specific destination bookie, then just use that one. Otherwise, we'll\n+     * randomly pick one of the other available bookies to use for each ledger\n+     * fragment we are replicating.\n+     * \n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     * @param cb\n+     *            RecoverCallback to invoke once all of the data on the dead\n+     *            bookie has been recovered and replicated.\n+     * @param context\n+     *            Context for the RecoverCallback to call.\n+     */\n+    private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+            final RecoverCallback cb, final Object context) {\n+        final List<InetSocketAddress> availableBookies = new LinkedList<InetSocketAddress>();\n+        if (bookieDest != null) {\n+            availableBookies.add(bookieDest);\n+            // Now poll ZK to get the active ledgers\n+            getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n+        } else {\n+            zk.getChildren(BOOKIES_PATH, null, new AsyncCallback.ChildrenCallback() {\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, List<String> children) {\n+                    if (rc != Code.OK.intValue()) {\n+                        LOG.error(\"ZK error getting bookie nodes: \", KeeperException.create(KeeperException.Code\n+                                .get(rc), path));\n+                        cb.recoverComplete(BKException.Code.ZKException, context);\n+                        return;\n+                    }\n+                    for (String bookieNode : children) {\n+                        String parts[] = bookieNode.split(COLON);\n+                        if (parts.length < 2) {\n+                            LOG.error(\"Bookie Node retrieved from ZK has invalid name format: \" + bookieNode);\n+                            cb.recoverComplete(BKException.Code.ZKException, context);\n+                            return;\n+                        }\n+                        availableBookies.add(new InetSocketAddress(parts[0], Integer.parseInt(parts[1])));\n+                    }\n+                    // Now poll ZK to get the active ledgers\n+                    getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n+                }\n+            }, null);\n+        }\n+    }\n+\n+    /**\n+     * This method asynchronously polls ZK to get the current set of active\n+     * ledgers. From this, we can open each ledger and look at the metadata to\n+     * determine if any of the ledger fragments for it were stored at the dead\n+     * input bookie.\n+     * \n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param bookieDest\n+     *            Optional destination bookie that if passed, we will copy all\n+     *            of the ledger fragments from the source bookie over to it.\n+     * @param cb\n+     *            RecoverCallback to invoke once all of the data on the dead\n+     *            bookie has been recovered and replicated.\n+     * @param context\n+     *            Context for the RecoverCallback to call.\n+     * @param availableBookies\n+     *            List of Bookie Servers that are available to use for\n+     *            replicating data on the failed bookie. This could contain a\n+     *            single bookie server if the user explicitly chose a bookie\n+     *            server to replicate data to.\n+     */\n+    private void getActiveLedgers(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n+            final RecoverCallback cb, final Object context, final List<InetSocketAddress> availableBookies) {\n+        zk.getChildren(LEDGERS_PATH, null, new AsyncCallback.ChildrenCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, List<String> children) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error getting ledger nodes: \", KeeperException.create(KeeperException.Code.get(rc),\n+                            path));\n+                    cb.recoverComplete(BKException.Code.ZKException, context);\n+                    return;\n+                }\n+                // Wrapper class around the RecoverCallback so it can be used\n+                // as the final VoidCallback to invoke within the MultiCallback.\n+                class RecoverCallbackWrapper implements AsyncCallback.VoidCallback {\n+                    final RecoverCallback cb;\n+\n+                    RecoverCallbackWrapper(RecoverCallback cb) {\n+                        this.cb = cb;\n+                    }\n+\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx) {\n+                        cb.recoverComplete(rc, ctx);\n+                    }\n+                }\n+                // Recover each of the ledgers asynchronously\n+                MultiCallback ledgerMcb = new MultiCallback(children.size(), new RecoverCallbackWrapper(cb), context);\n+                for (final String ledgerNode : children) {\n+                    recoverLedger(bookieSrc, ledgerNode, ledgerMcb, availableBookies);\n+                }\n+            }\n+        }, null);\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a given ledger if any of the ledger\n+     * entries were stored on the failed bookie.\n+     * \n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param ledgerNode\n+     *            Ledger Node name as retrieved from ZooKeeper we want to\n+     *            recover.\n+     * @param ledgerMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger.\n+     * @param availableBookies\n+     *            List of Bookie Servers that are available to use for\n+     *            replicating data on the failed bookie. This could contain a\n+     *            single bookie server if the user explicitly chose a bookie\n+     *            server to replicate data to.\n+     */\n+    private void recoverLedger(final InetSocketAddress bookieSrc, final String ledgerNode,\n+            final MultiCallback ledgerMcb, final List<InetSocketAddress> availableBookies) {\n+        /*\n+         * The available node is also stored in this path so ignore that. That\n+         * node is the path for the set of available Bookie Servers.\n+         */\n+        if (ledgerNode.equals(AVAILABLE_NODE)) {\n+            ledgerMcb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n+        // Parse out the ledgerId from the ZK ledger node.\n+        String parts[] = ledgerNode.split(LEDGER_NODE_PREFIX);\n+        if (parts.length < 2) {\n+            LOG.error(\"Ledger Node retrieved from ZK has invalid name format: \" + ledgerNode);\n+            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n+            return;\n+        }\n+        final long lId;\n+        try {\n+            lId = Long.parseLong(parts[parts.length - 1]);\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Error retrieving ledgerId from ledgerNode: \" + ledgerNode, e);\n+            ledgerMcb.processResult(BKException.Code.ZKException, null, null);\n+            return;\n+        }\n+        /*\n+         * For the current ledger, open it to retrieve the LedgerHandle. This\n+         * will contain the LedgerMetadata indicating which bookie servers the\n+         * ledger fragments are stored on. Check if any of the ledger fragments\n+         * for the current ledger are stored on the input dead bookie.\n+         */\n+        DigestType digestType = getLedgerDigestType(lId);\n+        byte[] passwd = getLedgerPasswd(lId);\n+        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n+            @Override\n+            public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"BK error opening ledger: \" + lId, BKException.create(rc));\n+                    ledgerMcb.processResult(rc, null, null);\n+                    return;\n+                }\n+                /*\n+                 * This List stores the ledger fragments to recover indexed by\n+                 * the start entry ID for the range. The ensembles TreeMap is\n+                 * keyed off this.\n+                 */\n+                final List<Long> ledgerFragmentsToRecover = new LinkedList<Long>();\n+                /*\n+                 * This Map will store the start and end entry ID values for\n+                 * each of the ledger fragment ranges. The only exception is the\n+                 * current active fragment since it has no end yet. In the event\n+                 * of a bookie failure, a new ensemble is created so the current\n+                 * ensemble should not contain the dead bookie we are trying to\n+                 * recover.\n+                 */\n+                Map<Long, Long> ledgerFragmentsRange = new HashMap<Long, Long>();\n+                Long curEntryId = null;\n+                for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : lh.getLedgerMetadata().getEnsembles()\n+                        .entrySet()) {\n+                    if (curEntryId != null)\n+                        ledgerFragmentsRange.put(curEntryId, entry.getKey() - 1);\n+                    curEntryId = entry.getKey();\n+                    if (entry.getValue().contains(bookieSrc)) {\n+                        /*\n+                         * Current ledger fragment has entries stored on the\n+                         * dead bookie so we'll need to recover them.\n+                         */\n+                        ledgerFragmentsToRecover.add(entry.getKey());\n+                    }\n+                }\n+                /*\n+                 * See if this current ledger contains any ledger fragment that\n+                 * needs to be re-replicated. If not, then just invoke the\n+                 * multiCallback and return.\n+                 */\n+                if (ledgerFragmentsToRecover.size() == 0) {\n+                    ledgerMcb.processResult(BKException.Code.OK, null, null);\n+                    return;\n+                }\n+                /*\n+                 * We have ledger fragments that need to be re-replicated to a\n+                 * new bookie. Choose one randomly from the available set of\n+                 * bookies.\n+                 */\n+                final InetSocketAddress newBookie = availableBookies.get(rand.nextInt(availableBookies.size()));\n+\n+                /*\n+                 * Wrapper class around the ledger MultiCallback. Once all\n+                 * ledger fragments for the ledger have been replicated to a new\n+                 * bookie, we need to update ZK with this new metadata to point\n+                 * to the new bookie instead of the old dead one. That should be\n+                 * done at the end prior to invoking the ledger MultiCallback.\n+                 */\n+                class LedgerMultiCallbackWrapper implements AsyncCallback.VoidCallback {\n+                    final MultiCallback ledgerMcb;\n+\n+                    LedgerMultiCallbackWrapper(MultiCallback ledgerMcb) {\n+                        this.ledgerMcb = ledgerMcb;\n+                    }\n+\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"BK error replicating ledger fragments for ledger: \" + lId, BKException\n+                                    .create(rc));\n+                            ledgerMcb.processResult(rc, null, null);\n+                            return;\n+                        }\n+                        /*\n+                         * Update the ledger metadata's ensemble info to point\n+                         * to the new bookie.\n+                         */\n+                        for (final Long startEntryId : ledgerFragmentsToRecover) {\n+                            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().get(\n+                                    startEntryId);\n+                            int deadBookieIndex = ensemble.indexOf(bookieSrc);\n+                            ensemble.remove(deadBookieIndex);\n+                            ensemble.add(deadBookieIndex, newBookie);\n+                        }\n+                        lh.writeLedgerConfig(new AsyncCallback.StatCallback() {\n+                            @Override\n+                            public void processResult(int rc, String path, Object ctx, Stat stat) {\n+                                if (rc != Code.OK.intValue()) {\n+                                    LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n+                                            KeeperException.create(KeeperException.Code.get(rc), path));\n+                                } else {\n+                                    LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId()\n+                                            + \") to point ledger fragments from old dead bookie: (\" + bookieSrc\n+                                            + \") to new bookie: (\" + newBookie + \")\");\n+                                }\n+                                /*\n+                                 * Pass the return code result up the chain with\n+                                 * the parent callback.\n+                                 */\n+                                ledgerMcb.processResult(rc, null, null);\n+                            }\n+                        }, null);\n+                    }\n+                }\n+\n+                /*\n+                 * Now recover all of the necessary ledger fragments\n+                 * asynchronously using a MultiCallback for every fragment.\n+                 */\n+                MultiCallback ledgerFragmentMcb = new MultiCallback(ledgerFragmentsToRecover.size(),\n+                        new LedgerMultiCallbackWrapper(ledgerMcb), null);\n+                for (final Long startEntryId : ledgerFragmentsToRecover) {\n+                    Long endEntryId = ledgerFragmentsRange.get(startEntryId);\n+                    try {\n+                        recoverLedgerFragment(bookieSrc, lh, startEntryId, endEntryId, ledgerFragmentMcb, newBookie);\n+                    } catch(InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        return;\n+                    }\n+                }\n+            }\n+        }, null);\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a ledger fragment which is a\n+     * contiguous portion of a ledger that was stored in an ensemble that\n+     * included the failed bookie.\n+     * \n+     * @param bookieSrc\n+     *            Source bookie that had a failure. We want to replicate the\n+     *            ledger fragments that were stored there.\n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param startEntryId\n+     *            Start entry Id for the ledger fragment\n+     * @param endEntryId\n+     *            End entry Id for the ledger fragment\n+     * @param ledgerFragmentMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger fragment.\n+     * @param newBookie\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final LedgerHandle lh,\n+            final Long startEntryId, final Long endEntryId, final MultiCallback ledgerFragmentMcb,\n+            final InetSocketAddress newBookie) throws InterruptedException {\n+        if (endEntryId == null) {\n+            /*\n+             * Ideally this should never happen if bookie failure is taken care\n+             * of properly. Nothing we can do though in this case.\n+             */\n+            LOG.warn(\"Dead bookie (\" + bookieSrc + \") is still part of the current active ensemble for ledgerId: \"\n+                    + lh.getId());\n+            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n+\n+        ArrayList<InetSocketAddress> curEnsemble = lh.getLedgerMetadata().getEnsembles().get(startEntryId);\n+        int bookieIndex = 0;\n+        for (int i = 0; i < curEnsemble.size(); i++) {\n+            if (curEnsemble.get(i).equals(bookieSrc)) {\n+                bookieIndex = i;\n+                break;\n+            }\n+        }\n+        /*\n+         * Loop through all entries in the current ledger fragment range and\n+         * find the ones that were stored on the dead bookie.\n+         */\n+        List<Long> entriesToReplicate = new LinkedList<Long>();\n+        for (long i = startEntryId; i <= endEntryId; i++) {\n+            if (lh.getDistributionSchedule().getReplicaIndex(i, bookieIndex) >= 0) {\n+                /*\n+                 * Current entry is stored on the dead bookie so we'll need to\n+                 * read it and replicate it to a new bookie.\n+                 */\n+                entriesToReplicate.add(i);\n+            }\n+        }\n+        /*\n+         * Now asynchronously replicate all of the entries for the ledger\n+         * fragment that were on the dead bookie.\n+         */\n+        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(entriesToReplicate.size(), ledgerFragmentMcb, null);\n+        for (final Long entryId : entriesToReplicate) {\n+            recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb, newBookie);\n+        }\n+    }\n+\n+    /**\n+     * This method asynchronously recovers a specific ledger entry by reading\n+     * the values via the BookKeeper Client (which would read it from the other\n+     * replicas) and then writing it to the chosen new bookie.\n+     * \n+     * @param entryId\n+     *            Ledger Entry ID to recover.\n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param ledgerFragmentEntryMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger entry.\n+     * @param newBookie\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n+            final MultiCallback ledgerFragmentEntryMcb, final InetSocketAddress newBookie) throws InterruptedException {\n+        /*\n+         * Read the ledger entry using the LedgerHandle. This will allow us to\n+         * read the entry from one of the other replicated bookies other than\n+         * the dead one.\n+         */\n+        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {\n+            @Override\n+            public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"BK error reading ledger entry: \" + entryId, BKException.create(rc));\n+                    ledgerFragmentEntryMcb.processResult(rc, null, null);\n+                    return;\n+                }\n+                /*\n+                 * Now that we've read the ledger entry, write it to the new\n+                 * bookie we've selected.\n+                 */\n+                LedgerEntry entry = seq.nextElement();\n+                ChannelBuffer toSend = lh.getDigestManager().computeDigestAndPackageForSending(entryId,\n+                        lh.getLastAddConfirmed(), entry.getLength(), entry.getEntry());\n+                bkc.getBookieClient().addEntry(newBookie, lh.getId(), lh.getLedgerKey(), entryId, toSend,\n+                        new WriteCallback() {\n+                            @Override\n+                            public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr,\n+                                    Object ctx) {\n+                                if (rc != Code.OK.intValue()) {\n+                                    LOG.error(\"BK error writing entry for ledgerId: \" + ledgerId + \", entryId: \"\n+                                            + entryId + \", bookie: \" + addr, BKException.create(rc));\n+                                } else {\n+                                    LOG.debug(\"Success writing ledger entry to a new bookie!\");\n+                                }\n+                                /*\n+                                 * Pass the return code result up the chain with\n+                                 * the parent callback.\n+                                 */\n+                                ledgerFragmentEntryMcb.processResult(rc, null, null);\n+                            }\n+                        }, null);\n+            }\n+        }, null);\n+    }\n+\n+    /**\n+     * Main method so we can invoke the bookie recovery via command line.\n+     * \n+     * @param args\n+     *            Arguments to BookKeeperTools. 2 are required and the third is\n+     *            optional. The first is a comma separated list of ZK server\n+     *            host:port pairs. The second is the host:port socket address\n+     *            for the bookie we are trying to recover. The third is the\n+     *            host:port socket address of the optional destination bookie\n+     *            server we want to replicate the data over to.\n+     * @throws InterruptedException\n+     * @throws IOException\n+     * @throws KeeperException\n+     */\n+    public static void main(String[] args) throws InterruptedException, IOException, KeeperException {\n+        // Validate the inputs\n+        if (args.length < 2) {\n+            System.err.println(\"USAGE: BookKeeperTools zkServers bookieSrc [bookieDest]\");\n+            return;\n+        }\n+        // Parse out the input arguments\n+        String zkServers = args[0];\n+        String bookieSrcString[] = args[1].split(COLON);\n+        if (bookieSrcString.length < 2) {\n+            System.err.println(\"BookieSrc inputted has invalid name format (host:port expected): \" + bookieSrcString);\n+            return;\n+        }\n+        final InetSocketAddress bookieSrc = new InetSocketAddress(bookieSrcString[0], Integer\n+                .parseInt(bookieSrcString[1]));\n+        InetSocketAddress bookieDest = null;\n+        if (args.length < 3) {\n+            String bookieDestString[] = args[2].split(COLON);\n+            if (bookieDestString.length < 2) {\n+                System.err.println(\"BookieDest inputted has invalid name format (host:port expected): \"\n+                        + bookieDestString);\n+                return;\n+            }\n+            bookieDest = new InetSocketAddress(bookieDestString[0], Integer.parseInt(bookieDestString[1]));\n+        }\n+\n+        // Create the BookKeeperTools instance and perform the bookie recovery\n+        // synchronously.\n+        BookKeeperTools bkTools = new BookKeeperTools(zkServers);\n+        bkTools.recoverBookieData(bookieSrc, bookieDest);\n+\n+        // Shutdown the resources used in the BookKeeperTools instance.\n+        bkTools.shutdown();\n+    }\n+\n+}"},{"sha":"5d8ecfc099734d0d74a668ecd9cfe5ba786a53dd","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,209 @@\n+package org.apache.bookkeeper.util;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.log4j.ConsoleAppender;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.PatternLayout;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.server.NIOServerCnxnFactory;\n+import org.apache.zookeeper.server.ZooKeeperServer;\n+\n+public class LocalBookKeeper {\n+    protected static final Logger LOG = Logger.getLogger(LocalBookKeeper.class);\n+    public static final int CONNECTION_TIMEOUT = 30000;\n+    \n+\tConsoleAppender ca;\n+\tint numberOfBookies;\n+\t\n+\tpublic LocalBookKeeper() {\n+\t\tca = new ConsoleAppender(new PatternLayout());\n+\t\tLOG.addAppender(ca);\n+\t\tLOG.setLevel(Level.INFO);\n+\t\tnumberOfBookies = 3;\n+\t}\n+\t\n+\tpublic LocalBookKeeper(int numberOfBookies){\n+\t\tthis();\n+\t\tthis.numberOfBookies = numberOfBookies;\n+\t\tLOG.info(\"Running \" + this.numberOfBookies + \" bookie(s).\");\n+\t}\n+\t\n+\tprivate final String HOSTPORT = \"127.0.0.1:2181\";\n+\tNIOServerCnxnFactory serverFactory;\n+\tZooKeeperServer zks;\n+\tZooKeeper zkc;\n+\tint ZooKeeperDefaultPort = 2181;\n+\tFile ZkTmpDir;\n+\n+\t//BookKeeper variables\n+\tFile tmpDirs[];\n+\tBookieServer bs[];\n+\tInteger initialPort = 5000;\n+\n+\t/**\n+\t * @param args\n+\t */\n+\t\n+\tprivate void runZookeeper(int maxCC) throws IOException{\n+\t\t// create a ZooKeeper server(dataDir, dataLogDir, port)\n+\t\tLOG.info(\"Starting ZK server\");\n+\t\t//ServerStats.registerAsConcrete();\n+\t\t//ClientBase.setupTestEnv();\n+\t\tZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n+        ZkTmpDir.delete();\n+        ZkTmpDir.mkdir();\n+\t\t    \n+\t\ttry {\n+\t\t\tzks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n+\t\t\tserverFactory =  new NIOServerCnxnFactory();\n+\t\t\tserverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), maxCC);\n+\t\t\tserverFactory.startup(zks);\n+\t\t} catch (Exception e) {\n+\t\t\t// TODO Auto-generated catch block\n+\t\t\tLOG.fatal(\"Exception while instantiating ZooKeeper\", e);\n+\t\t} \n+\n+        boolean b = waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT);\n+        LOG.debug(\"ZooKeeper server up: \" + b);\n+\t}\n+\t\n+\tprivate void initializeZookeper(){\n+\t\tLOG.info(\"Instantiate ZK Client\");\n+\t\t//initialize the zk client with values\n+\t\ttry {\n+\t\t\tzkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n+\t\t\tzkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\t\t\tzkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            // No need to create an entry for each requested bookie anymore as the \n+            // BookieServers will register themselves with ZooKeeper on startup.\n+\t\t} catch (KeeperException e) {\n+\t\t\t// TODO Auto-generated catch block\n+\t\t\tLOG.fatal(\"Exception while creating znodes\", e);\n+\t\t} catch (InterruptedException e) {\n+\t\t\t// TODO Auto-generated catch block\n+\t\t\tLOG.fatal(\"Interrupted while creating znodes\", e);\n+\t\t} catch (IOException e) {\n+\t\t\t// TODO Auto-generated catch block\n+\t\t\tLOG.fatal(\"Exception while creating znodes\", e);\n+\t\t}\t\t\n+\t}\n+\tprivate void runBookies() throws IOException{\n+\t\tLOG.info(\"Starting Bookie(s)\");\n+\t\t// Create Bookie Servers (B1, B2, B3)\n+\t\t\n+\t\ttmpDirs = new File[numberOfBookies];\t\t\n+\t\tbs = new BookieServer[numberOfBookies];\n+\t\t\n+\t\tfor(int i = 0; i < numberOfBookies; i++){\n+\t\t\ttmpDirs[i] = File.createTempFile(\"bookie\" + Integer.toString(i), \"test\");\n+\t\t\ttmpDirs[i].delete();\n+\t\t\ttmpDirs[i].mkdir();\n+\t\t\t\n+\t\t\tbs[i] = new BookieServer(initialPort + i, InetAddress.getLocalHost().getHostAddress() + \":\"\n+                    + ZooKeeperDefaultPort, tmpDirs[i], new File[]{tmpDirs[i]});\n+\t\t\tbs[i].start();\n+\t\t}\t\t\n+\t}\n+\t\n+\tpublic static void main(String[] args) throws IOException, InterruptedException {\n+\t\tif(args.length < 1){\n+\t\t\tusage();\n+\t\t\tSystem.exit(-1);\n+\t\t}\n+\t\tLocalBookKeeper lb = new LocalBookKeeper(Integer.parseInt(args[0]));\n+\t\tlb.runZookeeper(1000);\n+\t\tlb.initializeZookeper();\n+\t\tlb.runBookies();\n+\t\twhile (true){\n+\t\t\tThread.sleep(5000);\n+\t\t}\n+\t}\n+\n+\tprivate static void usage() {\n+\t\tSystem.err.println(\"Usage: LocalBookKeeper number-of-bookies\");\t\n+\t}\n+\n+\t/*\tUser for testing purposes, void */\n+\tclass emptyWatcher implements Watcher{\n+\t\tpublic void process(WatchedEvent event) {}\n+\t}\n+\t\n+\tpublic static boolean waitForServerUp(String hp, long timeout) {\n+        long start = System.currentTimeMillis();\n+        String split[] = hp.split(\":\");\n+        String host = split[0];\n+        int port = Integer.parseInt(split[1]);\n+        while (true) {\n+            try {\n+                Socket sock = new Socket(host, port);\n+                BufferedReader reader = null;\n+                try {\n+                    OutputStream outstream = sock.getOutputStream();\n+                    outstream.write(\"stat\".getBytes());\n+                    outstream.flush();\n+\n+                    reader =\n+                        new BufferedReader(\n+                                new InputStreamReader(sock.getInputStream()));\n+                    String line = reader.readLine();\n+                    if (line != null && line.startsWith(\"Zookeeper version:\")) {\n+                        LOG.info(\"Server UP\");\n+                        return true;\n+                    }\n+                } finally {\n+                    sock.close();\n+                    if (reader != null) {\n+                        reader.close();\n+                    }\n+                }\n+            } catch (IOException e) {\n+                // ignore as this is expected\n+                LOG.info(\"server \" + hp + \" not up \" + e);\n+            }\n+\n+            if (System.currentTimeMillis() > start + timeout) {\n+                break;\n+            }\n+            try {\n+                Thread.sleep(250);\n+            } catch (InterruptedException e) {\n+                // ignore\n+            }\n+        }\n+        return false;\n+    }\n+\t\n+}"},{"sha":"27335411f4d8abcc766a402fdea40b2caf67a3ba","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/util/Main.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/Main.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/Main.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/util/Main.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,54 @@\n+package org.apache.bookkeeper.util;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieServer;\n+\n+public class Main {\n+\n+    static void usage() {\n+        System.err.println(\"USAGE: bookeeper client|bookie\");\n+    }\n+\n+    /**\n+     * @param args\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        if (args.length < 1 || !(args[0].equals(\"client\") || args[0].equals(\"bookie\"))) {\n+            usage();\n+            return;\n+        }\n+        String newArgs[] = new String[args.length - 1];\n+        System.arraycopy(args, 1, newArgs, 0, newArgs.length);\n+        if (args[0].equals(\"bookie\")) {\n+            BookieServer.main(newArgs);\n+        } else {\n+            BookieClient.main(newArgs);\n+        }\n+    }\n+\n+}"},{"sha":"69fad814e46d0829932e613dee66e3d382490296","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/util/MathUtils.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/MathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/MathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/util/MathUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,38 @@\n+package org.apache.bookkeeper.util;\n+\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * Provides misc math functions that dont come standard\n+ */\n+public class MathUtils {\n+\n+    public static int signSafeMod(long dividend, int divisor){\n+        int mod = (int) (dividend % divisor);\n+        \n+        if (mod < 0){\n+            mod += divisor;\n+        }\n+        \n+        return mod;\n+        \n+    }\n+\n+}"},{"sha":"349dc8a85553bf6389381d14939917c46d286f73","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,98 @@\n+package org.apache.bookkeeper.util;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * This class provides 2 things over the java {@link ScheduledExecutorService}.\n+ * \n+ * 1. It takes {@link SafeRunnable objects} instead of plain Runnable objects.\n+ * This means that exceptions in scheduled tasks wont go unnoticed and will be\n+ * logged.\n+ * \n+ * 2. It supports submitting tasks with an ordering key, so that tasks submitted\n+ * with the same key will always be executed in order, but tasks across\n+ * different keys can be unordered. This retains parallelism while retaining the\n+ * basic amount of ordering we want (e.g. , per ledger handle). Ordering is\n+ * achieved by hashing the key objects to threads by their {@link #hashCode()}\n+ * method.\n+ * \n+ */\n+public class OrderedSafeExecutor {\n+    ExecutorService threads[];\n+    Random rand = new Random();\n+\n+    public OrderedSafeExecutor(int numThreads) {\n+        if (numThreads <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        threads = new ExecutorService[numThreads];\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i] = Executors.newSingleThreadExecutor();\n+        }\n+    }\n+\n+    ExecutorService chooseThread() {\n+        // skip random # generation in this special case\n+        if (threads.length == 1) {\n+            return threads[0];\n+        }\n+\n+        return threads[rand.nextInt(threads.length)];\n+\n+    }\n+\n+    ExecutorService chooseThread(Object orderingKey) {\n+        // skip hashcode generation in this special case\n+        if (threads.length == 1) {\n+            return threads[0];\n+        }\n+\n+        return threads[MathUtils.signSafeMod(orderingKey.hashCode(), threads.length)];\n+\n+    }\n+\n+    /**\n+     * schedules a one time action to execute \n+     */\n+    public void submit(SafeRunnable r) {\n+        chooseThread().submit(r);\n+    }\n+\n+    /**\n+     * schedules a one time action to execute with an ordering guarantee on the key\n+     * @param orderingKey\n+     * @param r\n+     */\n+    public void submitOrdered(Object orderingKey, SafeRunnable r) {\n+        chooseThread(orderingKey).submit(r);\n+    }\n+\n+    public void shutdown() {\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i].shutdown();\n+        }\n+    }\n+\n+}"},{"sha":"5a7648505d168f629633502bef20f0c78895d8cf","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/util/SafeRunnable.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,38 @@\n+package org.apache.bookkeeper.util;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.log4j.Logger;\n+\n+public abstract class SafeRunnable implements Runnable{\n+\n+    static final Logger logger = Logger.getLogger(SafeRunnable.class);\n+    \n+@Override\n+    public void run() {\n+        try{\n+            safeRun();\n+        }catch(Throwable t){\n+            logger.fatal(\"Unexpected throwable caught \", t);\n+        }\n+    }\n+    \n+    public abstract void safeRun();\n+    \n+}"},{"sha":"f457cc88109a82e0569d4a86887a895e1a6a34b1","filename":"bookkeeper/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/StringUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/main/java/org/apache/bookkeeper/util/StringUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/main/java/org/apache/bookkeeper/util/StringUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,94 @@\n+package org.apache.bookkeeper.util;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Provided utilites for parsing network addresses, ledger-id from node paths\n+ * etc.\n+ * \n+ */\n+public class StringUtils {\n+\n+    /*\n+     * Path to ledger metadata. ZooKeeper appends a sequence number to L.\n+     */\n+    static public final String prefix = \"/ledgers/L\";\n+\n+    /**\n+     * Parses address into IP and port.\n+     * \n+     * @param addr\n+     *            String\n+     */\n+\n+    public static InetSocketAddress parseAddr(String s) throws IOException {\n+\n+        String parts[] = s.split(\":\");\n+        if (parts.length != 2) {\n+            throw new IOException(s + \" does not have the form host:port\");\n+        }\n+        int port;\n+        try {\n+            port = Integer.parseInt(parts[1]);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(s + \" does not have the form host:port\");\n+        }\n+\n+        InetSocketAddress addr = new InetSocketAddress(parts[0], port);\n+        return addr;\n+    }\n+\n+    public static StringBuilder addrToString(StringBuilder sb, InetSocketAddress addr) {\n+        return sb.append(addr.getAddress().getHostAddress()).append(\":\").append(addr.getPort());\n+    }\n+\n+    /**\n+     * Formats ledger ID according to ZooKeeper rules\n+     * \n+     * @param id\n+     *            znode id\n+     */\n+    public static String getZKStringId(long id) {\n+        return String.format(\"%010d\", id);\n+    }\n+\n+    /**\n+     * Get the path for the ledger metadata node\n+     * \n+     * @return\n+     */\n+    public static String getLedgerNodePath(long ledgerId) {\n+        return prefix + StringUtils.getZKStringId(ledgerId);\n+    }\n+\n+    public static long getLedgerId(String nodeName) throws IOException {\n+        long ledgerId;\n+        try {\n+            String parts[] = nodeName.split(prefix);\n+            ledgerId = Long.parseLong(parts[parts.length - 1]);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+        return ledgerId;\n+    }\n+\n+}"},{"sha":"f96bfa3a78295b9a2c6e49149d2c557da5c64fc7","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","status":"added","additions":256,"deletions":0,"changes":256,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/AsyncLedgerOpsTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,256 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * This test tests read and write, synchronous and asynchronous, strings and\n+ * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n+ * and three BookKeepers.\n+ * \n+ */\n+public class AsyncLedgerOpsTest extends BaseTestCase implements AddCallback, ReadCallback, CreateCallback,\n+        CloseCallback, OpenCallback {\n+    static Logger LOG = Logger.getLogger(BookieClientTest.class);\n+\n+    DigestType digestType;\n+    \n+    public AsyncLedgerOpsTest(DigestType digestType) {\n+        super(3);\n+        this.digestType = digestType;\n+    }\n+    \n+    @Parameters\n+    public static Collection<Object[]> configs(){\n+        return Arrays.asList(new Object[][]{ {DigestType.MAC }, {DigestType.CRC32}});\n+    }\n+    \n+ \n+    byte[] ledgerPassword = \"aaa\".getBytes();\n+    LedgerHandle lh, lh2;\n+    long ledgerId;\n+    Enumeration<LedgerEntry> ls;\n+\n+    // test related variables\n+    int numEntriesToWrite = 20;\n+    int maxInt = 2147483647;\n+    Random rng; // Random Number Generator\n+    ArrayList<byte[]> entries; // generated entries\n+    ArrayList<Integer> entriesSize;\n+\n+    // Synchronization\n+    SyncObj sync;\n+    Set<Object> syncObjs;\n+\n+    class SyncObj {\n+        int counter;\n+        boolean value;\n+\n+        public SyncObj() {\n+            counter = 0;\n+            value = false;\n+        }\n+    }\n+\n+    class ControlObj {\n+        LedgerHandle lh;\n+\n+        void setLh(LedgerHandle lh) {\n+            this.lh = lh;\n+        }\n+\n+        LedgerHandle getLh() {\n+            return lh;\n+        }\n+    }\n+\n+    @Test\n+    public void testAsyncCreateClose() throws IOException {\n+        try {\n+            \n+            ControlObj ctx = new ControlObj();\n+\n+            synchronized (ctx) {\n+                LOG.info(\"Going to create ledger asynchronously\");\n+                bkc.asyncCreateLedger(3, 2, digestType, ledgerPassword, this, ctx);\n+\n+                ctx.wait();\n+            }\n+\n+            // bkc.initMessageDigest(\"SHA1\");\n+            LedgerHandle lh = ctx.getLh();\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.asyncAddEntry(entry.array(), this, sync);\n+            }\n+\n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.info(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            synchronized (ctx) {\n+                lh.asyncClose(this, ctx);\n+                ctx.wait();\n+            }\n+\n+            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n+\n+            // open ledger\n+            synchronized (ctx) {\n+                bkc.asyncOpenLedger(ledgerId, digestType, ledgerPassword, this, ctx);\n+                ctx.wait();\n+            }\n+            lh = ctx.getLh();\n+\n+            LOG.debug(\"Number of entries written: \" + lh.getLastAddConfirmed());\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            // read entries\n+            lh.asyncReadEntries(0, numEntriesToWrite - 1, this, sync);\n+\n+            synchronized (sync) {\n+                while (sync.value == false) {\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** READ COMPLETE ***\");\n+\n+            // at this point, Enumeration<LedgerEntry> ls is filled with the returned\n+            // values\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer origbb = ByteBuffer.wrap(entries.get(i));\n+                Integer origEntry = origbb.getInt();\n+                byte[] entry = ls.nextElement().getEntry();\n+                ByteBuffer result = ByteBuffer.wrap(entry);\n+                LOG.debug(\"Length of result: \" + result.capacity());\n+                LOG.debug(\"Original entry: \" + origEntry);\n+\n+                Integer retrEntry = result.getInt();\n+                LOG.debug(\"Retrieved entry: \" + retrEntry);\n+                assertTrue(\"Checking entry \" + i + \" for equality\", origEntry.equals(retrEntry));\n+                assertTrue(\"Checking entry \" + i + \" for size\", entry.length == entriesSize.get(i).intValue());\n+                i++;\n+            }\n+            assertTrue(\"Checking number of read entries\", i == numEntriesToWrite);\n+            lh.close();\n+        } catch (InterruptedException e) {\n+            LOG.error(e);\n+            fail(\"InterruptedException\");\n+        } // catch (NoSuchAlgorithmException e) {\n+        // e.printStackTrace();\n+        // }\n+\n+    }\n+\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        SyncObj x = (SyncObj) ctx;\n+        synchronized (x) {\n+            x.counter++;\n+            x.notify();\n+        }\n+    }\n+\n+    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+        ls = seq;\n+        synchronized (sync) {\n+            sync.value = true;\n+            sync.notify();\n+        }\n+\n+    }\n+\n+    public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n+        synchronized (ctx) {\n+            ControlObj cobj = (ControlObj) ctx;\n+            cobj.setLh(lh);\n+            cobj.notify();\n+        }\n+    }\n+\n+    public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+        synchronized (ctx) {\n+            ControlObj cobj = (ControlObj) ctx;\n+            cobj.setLh(lh);\n+            cobj.notify();\n+        }\n+    }\n+\n+    public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n+        synchronized (ctx) {\n+            ControlObj cobj = (ControlObj) ctx;\n+            cobj.notify();\n+        }\n+    }\n+\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+                                                      // Number Generator\n+        entries = new ArrayList<byte[]>(); // initialize the entries list\n+        entriesSize = new ArrayList<Integer>();\n+        sync = new SyncObj(); // initialize the synchronization data structure\n+    }\n+\n+    \n+\n+\n+\n+}\n\\ No newline at end of file"},{"sha":"f9f18178319c13ce0f351ccb1e49843740f508e9","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"added","additions":176,"deletions":0,"changes":176,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,176 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.test;\n+\n+import java.io.File;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.server.NIOServerCnxnFactory;\n+import org.apache.zookeeper.server.ZooKeeperServer;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import junit.framework.TestCase;\n+\n+@RunWith(Parameterized.class)\n+public abstract class BaseTestCase extends TestCase {\n+    static final Logger LOG = Logger.getLogger(BaseTestCase.class);\n+    // ZooKeeper related variables\n+    static final String HOSTPORT = \"127.0.0.1:2181\";\n+    static Integer ZooKeeperDefaultPort = 2181;\n+    ZooKeeperServer zks;\n+    ZooKeeper zkc; // zookeeper client\n+    NIOServerCnxnFactory serverFactory;\n+    File ZkTmpDir;\n+\n+    // BookKeeper\n+    List<File> tmpDirs = new ArrayList<File>();\n+    List<BookieServer> bs = new ArrayList<BookieServer>();\n+    Integer initialPort = 5000;\n+    int numBookies;\n+    BookKeeper bkc;\n+\n+    public BaseTestCase(int numBookies) {\n+        this.numBookies = numBookies;\n+    }\n+    \n+    @Parameters\n+    public static Collection<Object[]> configs(){\n+        return Arrays.asList(new Object[][]{ {DigestType.MAC }, {DigestType.CRC32}});\n+    }\n+\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        try {\n+        // create a ZooKeeper server(dataDir, dataLogDir, port)\n+        LOG.debug(\"Running ZK server\");\n+        // ServerStats.registerAsConcrete();\n+        ClientBase.setupTestEnv();\n+        ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n+        ZkTmpDir.delete();\n+        ZkTmpDir.mkdir();\n+\n+        zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n+        serverFactory = new NIOServerCnxnFactory();\n+        serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), 100);\n+        serverFactory.startup(zks);\n+\n+        boolean b = ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT);\n+\n+        LOG.debug(\"Server up: \" + b);\n+\n+        // create a zookeeper client\n+        LOG.debug(\"Instantiate ZK Client\");\n+        zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n+\n+        // initialize the zk client with values\n+        zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        // Create Bookie Servers (B1, B2, B3)\n+        for (int i = 0; i < numBookies; i++) {\n+            File f = File.createTempFile(\"bookie\", \"test\");\n+            tmpDirs.add(f);\n+            f.delete();\n+            f.mkdir();\n+\n+            BookieServer server = new BookieServer(initialPort + i, HOSTPORT, f, new File[] { f });\n+            server.start();\n+            bs.add(server);\n+        }\n+        zkc.close();\n+        bkc = new BookKeeper(\"127.0.0.1\");\n+        } catch(Exception e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        LOG.info(\"TearDown\");\n+\n+        if (bkc != null) {\n+            bkc.halt();;\n+        }\n+        \n+        for (BookieServer server : bs) {\n+            server.shutdown();\n+        }\n+\n+        for (File f : tmpDirs) {\n+            cleanUpDir(f);\n+        }\n+\n+        // shutdown ZK server\n+        if (serverFactory != null) {\n+            serverFactory.shutdown();\n+            assertTrue(\"waiting for server down\", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));\n+        }\n+        // ServerStats.unregister();\n+        cleanUpDir(ZkTmpDir);\n+        \n+\n+    }\n+\n+    /* Clean up a directory recursively */\n+    protected boolean cleanUpDir(File dir) {\n+        if (dir.isDirectory()) {\n+            LOG.info(\"Cleaning up \" + dir.getName());\n+            String[] children = dir.list();\n+            for (String string : children) {\n+                boolean success = cleanUpDir(new File(dir, string));\n+                if (!success)\n+                    return false;\n+            }\n+        }\n+        // The directory is now empty so delete it\n+        return dir.delete();\n+    }\n+\n+    /* User for testing purposes, void */\n+    class emptyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+        }\n+    }\n+\n+}"},{"sha":"e626a4ec7d9617b00a36e5359543acfa1e841c9e","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"added","additions":232,"deletions":0,"changes":232,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,232 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.File;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.Executors;\n+\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.junit.Test;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.log4j.Logger;\n+\n+import junit.framework.TestCase;\n+\n+public class BookieClientTest extends TestCase {\n+    static Logger LOG = Logger.getLogger(BookieClientTest.class);\n+    BookieServer bs;\n+    File tmpDir;\n+    int port = 13645;\n+    ClientSocketChannelFactory channelFactory;\n+    OrderedSafeExecutor executor;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        tmpDir = File.createTempFile(\"bookie\", \"test\");\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        // Since this test does not rely on the BookKeeper client needing to\n+        // know via ZooKeeper which Bookies are available, okay, so pass in null\n+        // for the zkServers input parameter when constructing the BookieServer.\n+        bs = new BookieServer(port, null, tmpDir, new File[] { tmpDir });\n+        bs.start();\n+        channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n+                .newCachedThreadPool());\n+        executor = new OrderedSafeExecutor(2);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        bs.shutdown();\n+        recursiveDelete(tmpDir);\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+\n+    private static void recursiveDelete(File dir) {\n+        File children[] = dir.listFiles();\n+        if (children != null) {\n+            for (File child : children) {\n+                recursiveDelete(child);\n+            }\n+        }\n+        dir.delete();\n+    }\n+\n+    static class ResultStruct {\n+        int rc;\n+        ByteBuffer entry;\n+    }\n+\n+    ReadEntryCallback recb = new ReadEntryCallback() {\n+\n+        public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer bb, Object ctx) {\n+            ResultStruct rs = (ResultStruct) ctx;\n+            synchronized (rs) {\n+                rs.rc = rc;\n+                if (bb != null) {\n+                    bb.readerIndex(16);\n+                    rs.entry = bb.toByteBuffer();\n+                    rs.notifyAll();\n+                }\n+            }\n+        }\n+\n+    };\n+\n+    WriteCallback wrcb = new WriteCallback() {\n+        public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+            if (ctx != null) {\n+                synchronized (ctx) {\n+                    ctx.notifyAll();\n+                }\n+            }\n+        }\n+    };\n+\n+    @Test\n+    public void testWriteGaps() throws Exception {\n+        final Object notifyObject = new Object();\n+        byte[] passwd = new byte[20];\n+        Arrays.fill(passwd, (byte) 'a');\n+        InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", port);\n+        ResultStruct arc = new ResultStruct();\n+\n+        BookieClient bc = new BookieClient(channelFactory, executor);\n+        ChannelBuffer bb;\n+        bb = createByteBuffer(1, 1, 1);\n+        bc.addEntry(addr, 1, passwd, 1, bb, wrcb, null);\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 1, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(1, arc.entry.getInt());\n+        }\n+        bb = createByteBuffer(2, 1, 2);\n+        bc.addEntry(addr, 1, passwd, 2, bb, wrcb, null);\n+        bb = createByteBuffer(3, 1, 3);\n+        bc.addEntry(addr, 1, passwd, 3, bb, wrcb, null);\n+        bb = createByteBuffer(5, 1, 5);\n+        bc.addEntry(addr, 1, passwd, 5, bb, wrcb, null);\n+        bb = createByteBuffer(7, 1, 7);\n+        bc.addEntry(addr, 1, passwd, 7, bb, wrcb, null);\n+        synchronized (notifyObject) {\n+            bb = createByteBuffer(11, 1, 11);\n+            bc.addEntry(addr, 1, passwd, 11, bb, wrcb, notifyObject);\n+            notifyObject.wait();\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 6, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 7, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(7, arc.entry.getInt());\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 1, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(1, arc.entry.getInt());\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 2, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(2, arc.entry.getInt());\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 3, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(3, arc.entry.getInt());\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 4, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 11, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(11, arc.entry.getInt());\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 5, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(0, arc.rc);\n+            assertEquals(5, arc.entry.getInt());\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 10, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 12, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+        }\n+        synchronized (arc) {\n+            bc.readEntry(addr, 1, 13, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+        }\n+    }\n+\n+    private ChannelBuffer createByteBuffer(int i, long lid, long eid) {\n+        ByteBuffer bb;\n+        bb = ByteBuffer.allocate(4 + 16);\n+        bb.putLong(lid);\n+        bb.putLong(eid);\n+        bb.putInt(i);\n+        bb.flip();\n+        return ChannelBuffers.wrappedBuffer(bb);\n+    }\n+\n+    @Test\n+    public void testNoLedger() throws Exception {\n+        ResultStruct arc = new ResultStruct();\n+        InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", port);\n+        BookieClient bc = new BookieClient(channelFactory, executor);\n+        synchronized (arc) {\n+            bc.readEntry(addr, 2, 13, recb, arc);\n+            arc.wait(1000);\n+            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+        }\n+    }\n+}"},{"sha":"ec285c7d50a0a1b538555ff7327b3a149ebc5dbf","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"added","additions":305,"deletions":0,"changes":305,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,305 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * This test tests read and write, synchronous and asynchronous, strings and\n+ * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n+ * and three BookKeepers.\n+ * \n+ */\n+\n+public class BookieFailureTest extends BaseTestCase implements AddCallback, ReadCallback {\n+\n+    // Depending on the taste, select the amount of logging\n+    // by decommenting one of the two lines below\n+    // static Logger LOG = Logger.getRootLogger();\n+    static Logger LOG = Logger.getLogger(BookieFailureTest.class);\n+\n+    byte[] ledgerPassword = \"aaa\".getBytes();\n+    LedgerHandle lh, lh2;\n+    long ledgerId;\n+    Enumeration<LedgerEntry> ls;\n+\n+    // test related variables\n+    int numEntriesToWrite = 200;\n+    int maxInt = 2147483647;\n+    Random rng; // Random Number Generator\n+    ArrayList<byte[]> entries; // generated entries\n+    ArrayList<Integer> entriesSize;\n+    DigestType digestType;\n+    \n+    // Synchronization\n+    SyncObj sync;\n+    Set<Object> syncObjs;\n+\n+    class SyncObj {\n+        int counter;\n+        boolean value;\n+\n+        public SyncObj() {\n+            counter = 0;\n+            value = false;\n+        }\n+    }\n+\n+    public BookieFailureTest(DigestType digestType) {\n+        super(4);\n+        this.digestType = digestType;        \n+    }\n+    \n+    /**\n+     * Tests writes and reads when a bookie fails.\n+     * \n+     * @throws {@link IOException}\n+     */\n+    @Test\n+    public void testAsyncBK1() throws IOException {\n+        LOG.info(\"#### BK1 ####\");\n+        auxTestReadWriteAsyncSingleClient(bs.get(0));\n+    }\n+    \n+    @Test\n+    public void testAsyncBK2() throws IOException {\n+        LOG.info(\"#### BK2 ####\");\n+        auxTestReadWriteAsyncSingleClient(bs.get(1));\n+    }\n+\n+    @Test\n+    public void testAsyncBK3() throws IOException {\n+        LOG.info(\"#### BK3 ####\");\n+        auxTestReadWriteAsyncSingleClient(bs.get(2));\n+    }\n+\n+    @Test\n+    public void testAsyncBK4() throws IOException {\n+        LOG.info(\"#### BK4 ####\");\n+        auxTestReadWriteAsyncSingleClient(bs.get(3));\n+    }\n+    \n+    @Test\n+    public void testBookieRecovery() throws Exception{\n+        bkc = new BookKeeper(\"127.0.0.1\");\n+        \n+        //Shutdown all but 1 bookie\n+        bs.get(0).shutdown();\n+        bs.get(1).shutdown();\n+        bs.get(2).shutdown();\n+        \n+        byte[] passwd = \"blah\".getBytes();\n+        LedgerHandle lh = bkc.createLedger(1, 1,digestType, passwd);\n+        \n+        int numEntries = 100;\n+        for (int i=0; i< numEntries; i++){\n+            byte[] data = (\"\"+i).getBytes();\n+            lh.addEntry(data);\n+        }\n+        \n+        bs.get(3).shutdown();\n+        BookieServer server = new BookieServer(initialPort + 3, HOSTPORT, tmpDirs.get(3), new File[] { tmpDirs.get(3)});\n+        server.start();\n+        bs.set(3, server);\n+\n+        assertEquals(numEntries - 1 , lh.getLastAddConfirmed());\n+        Enumeration<LedgerEntry> entries = lh.readEntries(0, lh.getLastAddConfirmed());\n+        \n+        int numScanned = 0;\n+        while (entries.hasMoreElements()){\n+            assertEquals((\"\"+numScanned), new String(entries.nextElement().getEntry()));\n+            numScanned++;\n+        }\n+        assertEquals(numEntries, numScanned);\n+        \n+        \n+    }\n+\n+    void auxTestReadWriteAsyncSingleClient(BookieServer bs) throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            lh = bkc.createLedger(3, 2, digestType, ledgerPassword);\n+\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.asyncAddEntry(entry.array(), this, sync);\n+                \n+            }\n+            \n+            LOG.info(\"Wrote \" + numEntriesToWrite + \" and now going to fail bookie.\");\n+            // Bookie fail\n+            bs.shutdown();\n+\n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+\n+            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n+\n+            // open ledger\n+            bkc.halt();\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            // read entries\n+\n+            lh.asyncReadEntries(0, numEntriesToWrite - 1, this, sync);\n+\n+            synchronized (sync) {\n+                while (sync.value == false) {\n+                    sync.wait(10000);\n+                    assertTrue(\"Haven't received entries\", sync.value);\n+                }\n+            }\n+\n+            LOG.debug(\"*** READ COMPLETE ***\");\n+\n+            // at this point, Enumeration<LedgerEntry> ls is filled with the returned\n+            // values\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer origbb = ByteBuffer.wrap(entries.get(i));\n+                Integer origEntry = origbb.getInt();\n+                byte[] entry = ls.nextElement().getEntry();\n+                ByteBuffer result = ByteBuffer.wrap(entry);\n+\n+                Integer retrEntry = result.getInt();\n+                LOG.debug(\"Retrieved entry: \" + i);\n+                assertTrue(\"Checking entry \" + i + \" for equality\", origEntry.equals(retrEntry));\n+                assertTrue(\"Checking entry \" + i + \" for size\", entry.length == entriesSize.get(i).intValue());\n+                i++;\n+            }\n+\n+            assertTrue(\"Checking number of read entries\", i == numEntriesToWrite);\n+\n+            LOG.info(\"Verified that entries are ok, and now closing ledger\");\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Caught KeeperException\", e);\n+            fail(e.toString());\n+        } catch (BKException e) {\n+            LOG.error(\"Caught BKException\", e);\n+            fail(e.toString());\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Caught InterruptedException\", e);\n+            fail(e.toString());\n+        }\n+\n+    }\n+\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        if (rc != 0)\n+            fail(\"Failed to write entry: \" + entryId);\n+        SyncObj x = (SyncObj) ctx;\n+        synchronized (x) {\n+            x.counter++;\n+            x.notify();\n+        }\n+    }\n+\n+    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+        if (rc != 0)\n+            fail(\"Failed to write entry\");\n+        ls = seq;\n+        synchronized (sync) {\n+            sync.value = true;\n+            sync.notify();\n+        }\n+\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+                                                      // Number Generator\n+        entries = new ArrayList<byte[]>(); // initialize the entries list\n+        entriesSize = new ArrayList<Integer>();\n+        sync = new SyncObj(); // initialize the synchronization data structure\n+\n+        zkc.close();\n+    }\n+\n+\n+    /* Clean up a directory recursively */\n+    @Override\n+    protected boolean cleanUpDir(File dir) {\n+        if (dir.isDirectory()) {\n+            LOG.info(\"Cleaning up \" + dir.getName());\n+            String[] children = dir.list();\n+            for (String string : children) {\n+                boolean success = cleanUpDir(new File(dir, string));\n+                if (!success)\n+                    return false;\n+            }\n+        }\n+        // The directory is now empty so delete it\n+        return dir.delete();\n+    }\n+\n+    /* User for testing purposes, void */\n+    class emptyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+        }\n+    }\n+\n+}\n\\ No newline at end of file"},{"sha":"2762dd46a0a99ae130435ef7ae6f3f5e0d3389bc","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"added","additions":720,"deletions":0,"changes":720,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,720 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.NoSuchFieldException;\n+import java.lang.IllegalAccessException;\n+import java.lang.reflect.Field;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Semaphore;\n+\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.streaming.LedgerInputStream;\n+import org.apache.bookkeeper.streaming.LedgerOutputStream;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * This test tests read and write, synchronous and asynchronous, strings and\n+ * integers for a BookKeeper client. The test deployment uses a ZooKeeper server\n+ * and three BookKeepers.\n+ * \n+ */\n+\n+public class BookieReadWriteTest extends BaseTestCase implements AddCallback, ReadCallback {\n+\n+    // Depending on the taste, select the amount of logging\n+    // by decommenting one of the two lines below\n+    // static Logger LOG = Logger.getRootLogger();\n+    static Logger LOG = Logger.getLogger(BookieReadWriteTest.class);\n+\n+    byte[] ledgerPassword = \"aaa\".getBytes();\n+    LedgerHandle lh, lh2;\n+    long ledgerId;\n+    Enumeration<LedgerEntry> ls;\n+\n+    // test related variables\n+    int numEntriesToWrite = 200;\n+    int maxInt = 2147483647;\n+    Random rng; // Random Number Generator\n+    ArrayList<byte[]> entries; // generated entries\n+    ArrayList<Integer> entriesSize;\n+    \n+    DigestType digestType;\n+    \n+    public BookieReadWriteTest(DigestType digestType){\n+        super(3);\n+        this.digestType = digestType;\n+    }\n+    // Synchronization\n+    SyncObj sync;\n+    Set<Object> syncObjs;\n+\n+    class SyncObj {\n+        volatile int counter;\n+        boolean value;\n+\n+        public SyncObj() {\n+            counter = 0;\n+            value = false;\n+        }\n+    }\n+\n+    @Test\n+    public void testOpenException() throws KeeperException, IOException, InterruptedException {\n+        try {\n+            lh = bkc.openLedger(0, digestType, ledgerPassword);\n+            fail(\"Haven't thrown exception\");\n+        } catch (BKException e) {\n+            LOG.warn(\"Successfully thrown and caught exception:\", e);\n+        }\n+    }\n+\n+    /**\n+     * test the streaming api for reading and writing\n+     * \n+     * @throws {@link IOException}, {@link KeeperException}\n+     */\n+    @Test\n+    public void testStreamingClients() throws IOException, KeeperException, BKException, InterruptedException {\n+        bkc = new BookKeeper(\"127.0.0.1\");\n+        lh = bkc.createLedger(digestType, ledgerPassword);\n+        // write a string so that we cna\n+        // create a buffer of a single bytes\n+        // and check for corner cases\n+        String toWrite = \"we need to check for this string to match \" + \"and for the record mahadev is the best\";\n+        LedgerOutputStream lout = new LedgerOutputStream(lh, 1);\n+        byte[] b = toWrite.getBytes();\n+        lout.write(b);\n+        lout.close();\n+        long lId = lh.getId();\n+        lh.close();\n+        // check for sanity\n+        lh = bkc.openLedger(lId, digestType, ledgerPassword);\n+        LedgerInputStream lin = new LedgerInputStream(lh, 1);\n+        byte[] bread = new byte[b.length];\n+        int read = 0;\n+        while (read < b.length) {\n+            read = read + lin.read(bread, read, b.length);\n+        }\n+\n+        String newString = new String(bread);\n+        assertTrue(\"these two should same\", toWrite.equals(newString));\n+        lin.close();\n+        lh.close();\n+        // create another ledger to write one byte at a time\n+        lh = bkc.createLedger(digestType, ledgerPassword);\n+        lout = new LedgerOutputStream(lh);\n+        for (int i = 0; i < b.length; i++) {\n+            lout.write(b[i]);\n+        }\n+        lout.close();\n+        lId = lh.getId();\n+        lh.close();\n+        lh = bkc.openLedger(lId, digestType, ledgerPassword);\n+        lin = new LedgerInputStream(lh);\n+        bread = new byte[b.length];\n+        read = 0;\n+        while (read < b.length) {\n+            read = read + lin.read(bread, read, b.length);\n+        }\n+        newString = new String(bread);\n+        assertTrue(\"these two should be same \", toWrite.equals(newString));\n+        lin.close();\n+        lh.close();\n+    }\n+\n+    @Test\n+    public void testReadWriteAsyncSingleClient() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.asyncAddEntry(entry.array(), this, sync);\n+            }\n+\n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+\n+            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n+\n+            // open ledger\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            // read entries\n+            lh.asyncReadEntries(0, numEntriesToWrite - 1, this, (Object) sync);\n+\n+            synchronized (sync) {\n+                while (sync.value == false) {\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** READ COMPLETE ***\");\n+\n+            // at this point, Enumeration<LedgerEntry> ls is filled with the returned\n+            // values\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer origbb = ByteBuffer.wrap(entries.get(i));\n+                Integer origEntry = origbb.getInt();\n+                byte[] entry = ls.nextElement().getEntry();\n+                ByteBuffer result = ByteBuffer.wrap(entry);\n+                LOG.debug(\"Length of result: \" + result.capacity());\n+                LOG.debug(\"Original entry: \" + origEntry);\n+\n+                Integer retrEntry = result.getInt();\n+                LOG.debug(\"Retrieved entry: \" + retrEntry);\n+                assertTrue(\"Checking entry \" + i + \" for equality\", origEntry.equals(retrEntry));\n+                assertTrue(\"Checking entry \" + i + \" for size\", entry.length == entriesSize.get(i).intValue());\n+                i++;\n+            }\n+            assertTrue(\"Checking number of read entries\", i == numEntriesToWrite);\n+\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n+    class ThrottleTestCallback implements ReadCallback {\n+        int throttle;\n+        \n+        ThrottleTestCallback(int threshold){\n+            this.throttle = threshold;\n+        }\n+        \n+        public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx){\n+            if(rc != BKException.Code.OK){\n+                fail(\"Return code is not OK: \" + rc);\n+            }\n+        \n+            ls = seq;\n+            synchronized(sync){\n+                sync.counter += throttle;\n+                sync.notify();\n+            }\n+            LOG.info(\"Current counter: \" + sync.counter);\n+        }\n+    }\n+    \n+    /**\n+     * Method for obtaining the available permits of a ledger handle\n+     * using reflection to avoid adding a new public method to the\n+     * class.\n+     *   \n+     * @param lh\n+     * @return\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    int getAvailablePermits(LedgerHandle lh) throws\n+    NoSuchFieldException, IllegalAccessException\n+    { \n+        Field field = LedgerHandle.class.getDeclaredField(\"opCounterSem\"); \n+        field.setAccessible(true); \n+        return ((Semaphore)field.get(lh)).availablePermits(); \n+    }\n+    \n+    @Test\n+    public void testReadWriteAsyncSingleClientThrottle() throws \n+    IOException, NoSuchFieldException, IllegalAccessException {\n+        try {\n+                       \n+            Integer throttle = 100;\n+            ThrottleTestCallback tcb = new ThrottleTestCallback(throttle);\n+            // Create a BookKeeper client and a ledger\n+            System.setProperty(\"throttle\", throttle.toString());\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            \n+            numEntriesToWrite = 8000; \n+            for (int i = 0; i < (numEntriesToWrite - 2000); i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.asyncAddEntry(entry.array(), this, sync);\n+                /*\n+                 * Check that the difference is no larger than the throttling threshold\n+                 */\n+                int testValue = getAvailablePermits(lh);\n+                assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n+            }\n+            \n+\n+            for (int i = 0; i < 2000; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.asyncAddEntry(entry.array(), this, sync);\n+                \n+                /*\n+                 * Check that the difference is no larger than the throttling threshold\n+                 */\n+                int testValue = getAvailablePermits(lh);\n+                assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n+            }\n+            \n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+\n+            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n+            \n+            // open ledger\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            // read entries\n+            sync.counter = 0;\n+            for (int i = 0; i < numEntriesToWrite; i+=throttle) {\n+                lh.asyncReadEntries(i, i + throttle - 1, tcb, (Object) sync);\n+                int testValue = getAvailablePermits(lh);\n+                assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n+            }\n+            \n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.info(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** READ COMPLETE ***\");\n+\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+    \n+    @Test\n+    public void testSyncReadAsyncWriteStringsSingleClient() throws IOException {\n+        LOG.info(\"TEST READ WRITE STRINGS MIXED SINGLE CLIENT\");\n+        String charset = \"utf-8\";\n+        LOG.debug(\"Default charset: \" + Charset.defaultCharset());\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                int randomInt = rng.nextInt(maxInt);\n+                byte[] entry = new String(Integer.toString(randomInt)).getBytes(charset);\n+                entries.add(entry);\n+                lh.asyncAddEntry(entry, this, sync);\n+            }\n+\n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+\n+            LOG.debug(\"*** ASYNC WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+\n+            // *** WRITING PART COMPLETED // READ PART BEGINS ***\n+\n+            // open ledger\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            // read entries\n+            ls = lh.readEntries(0, numEntriesToWrite - 1);\n+\n+            LOG.debug(\"*** SYNC READ COMPLETE ***\");\n+\n+            // at this point, Enumeration<LedgerEntry> ls is filled with the returned\n+            // values\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                byte[] origEntryBytes = entries.get(i++);\n+                byte[] retrEntryBytes = ls.nextElement().getEntry();\n+\n+                LOG.debug(\"Original byte entry size: \" + origEntryBytes.length);\n+                LOG.debug(\"Saved byte entry size: \" + retrEntryBytes.length);\n+\n+                String origEntry = new String(origEntryBytes, charset);\n+                String retrEntry = new String(retrEntryBytes, charset);\n+\n+                LOG.debug(\"Original entry: \" + origEntry);\n+                LOG.debug(\"Retrieved entry: \" + retrEntry);\n+\n+                assertTrue(\"Checking entry \" + i + \" for equality\", origEntry.equals(retrEntry));\n+            }\n+            assertTrue(\"Checking number of read entries\", i == numEntriesToWrite);\n+\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testReadWriteSyncSingleClient() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+                entries.add(entry.array());\n+                lh.addEntry(entry.array());\n+            }\n+            lh.close();\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + lh.getLastAddConfirmed());\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            ls = lh.readEntries(0, numEntriesToWrite - 1);\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer origbb = ByteBuffer.wrap(entries.get(i++));\n+                Integer origEntry = origbb.getInt();\n+                ByteBuffer result = ByteBuffer.wrap(ls.nextElement().getEntry());\n+                LOG.debug(\"Length of result: \" + result.capacity());\n+                LOG.debug(\"Original entry: \" + origEntry);\n+\n+                Integer retrEntry = result.getInt();\n+                LOG.debug(\"Retrieved entry: \" + retrEntry);\n+                assertTrue(\"Checking entry \" + i + \" for equality\", origEntry.equals(retrEntry));\n+            }\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n+    @Test\n+    public void testReadWriteZero() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                lh.addEntry(new byte[0]);\n+            }\n+\n+            /*\n+             * Write a non-zero entry\n+             */\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            entries.add(entry.array());\n+            lh.addEntry(entry.array());\n+\n+            lh.close();\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            LOG.debug(\"Number of entries written: \" + lh.getLastAddConfirmed());\n+            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == numEntriesToWrite);\n+\n+            ls = lh.readEntries(0, numEntriesToWrite - 1);\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer result = ByteBuffer.wrap(ls.nextElement().getEntry());\n+                LOG.debug(\"Length of result: \" + result.capacity());\n+\n+                assertTrue(\"Checking if entry \" + i + \" has zero bytes\", result.capacity() == 0);\n+            }\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiLedger() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            lh2 = bkc.createLedger(digestType, ledgerPassword);\n+\n+            long ledgerId = lh.getId();\n+            long ledgerId2 = lh2.getId();\n+\n+            // bkc.initMessageDigest(\"SHA1\");\n+            LOG.info(\"Ledger ID 1: \" + lh.getId() + \", Ledger ID 2: \" + lh2.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                lh.addEntry(new byte[0]);\n+                lh2.addEntry(new byte[0]);\n+            }\n+\n+            lh.close();\n+            lh2.close();\n+\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            lh2 = bkc.openLedger(ledgerId2, digestType, ledgerPassword);\n+\n+            LOG.debug(\"Number of entries written: \" + lh.getLastAddConfirmed() + \", \" + lh2.getLastAddConfirmed());\n+            assertTrue(\"Verifying number of entries written lh (\" + lh.getLastAddConfirmed() + \")\", lh\n+                    .getLastAddConfirmed() == (numEntriesToWrite - 1));\n+            assertTrue(\"Verifying number of entries written lh2 (\" + lh2.getLastAddConfirmed() + \")\", lh2\n+                    .getLastAddConfirmed() == (numEntriesToWrite - 1));\n+\n+            ls = lh.readEntries(0, numEntriesToWrite - 1);\n+            int i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer result = ByteBuffer.wrap(ls.nextElement().getEntry());\n+                LOG.debug(\"Length of result: \" + result.capacity());\n+\n+                assertTrue(\"Checking if entry \" + i + \" has zero bytes\", result.capacity() == 0);\n+            }\n+            lh.close();\n+            ls = lh2.readEntries(0, numEntriesToWrite - 1);\n+            i = 0;\n+            while (ls.hasMoreElements()) {\n+                ByteBuffer result = ByteBuffer.wrap(ls.nextElement().getEntry());\n+                LOG.debug(\"Length of result: \" + result.capacity());\n+\n+                assertTrue(\"Checking if entry \" + i + \" has zero bytes\", result.capacity() == 0);\n+            }\n+            lh2.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n+    @Test\n+    public void testReadWriteAsyncLength() throws IOException {\n+        try {\n+            // Create a BookKeeper client and a ledger\n+            bkc = new BookKeeper(\"127.0.0.1\");\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.asyncAddEntry(entry.array(), this, sync);\n+            }\n+\n+            // wait for all entries to be acknowledged\n+            synchronized (sync) {\n+                while (sync.counter < numEntriesToWrite) {\n+                    LOG.debug(\"Entries counter = \" + sync.counter);\n+                    sync.wait();\n+                }\n+            }\n+            long length = numEntriesToWrite * 4;\n+            assertTrue(\"Ledger length before closing: \" + lh.getLength(), lh.getLength() == length);\n+            \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+\n+            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n+\n+            // open ledger\n+            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+            assertTrue(\"Ledger length after opening: \" + lh.getLength(), lh.getLength() == length);\n+\n+\n+            lh.close();\n+        } catch (KeeperException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to ZooKeeper exception\");\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+    \n+    \n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n+        \n+        SyncObj x = (SyncObj) ctx;\n+        \n+        synchronized (x) {\n+            x.counter++;\n+            x.notify();\n+        }\n+    }\n+\n+    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+        if(rc != BKException.Code.OK) fail(\"Return code is not OK: \" + rc);\n+        \n+        ls = seq;\n+\n+        synchronized (sync) {\n+            sync.value = true;\n+            sync.notify();\n+        }\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception{\n+        super.setUp();\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+                                                      // Number Generator\n+        entries = new ArrayList<byte[]>(); // initialize the entries list\n+        entriesSize = new ArrayList<Integer>();\n+        sync = new SyncObj(); // initialize the synchronization data structure\n+        \n+    }\n+\n+    /* Clean up a directory recursively */\n+    protected boolean cleanUpDir(File dir) {\n+        if (dir.isDirectory()) {\n+            LOG.info(\"Cleaning up \" + dir.getName());\n+            String[] children = dir.list();\n+            for (String string : children) {\n+                boolean success = cleanUpDir(new File(dir, string));\n+                if (!success)\n+                    return false;\n+            }\n+        }\n+        // The directory is now empty so delete it\n+        return dir.delete();\n+    }\n+\n+    /* User for testing purposes, void */\n+    class emptyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+        }\n+    }\n+\n+}"},{"sha":"9815bce5d5f49b55f64236aedf3b55d0d6bd826e","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","status":"added","additions":400,"deletions":0,"changes":400,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/BookieRecoveryTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,400 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.tools.BookKeeperTools;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * This class tests the bookie recovery admin functionality.\n+ */\n+public class BookieRecoveryTest extends BaseTestCase {\n+    static Logger LOG = Logger.getLogger(BookieRecoveryTest.class);\n+\n+    // Object used for synchronizing async method calls\n+    class SyncObject {\n+        boolean value;\n+\n+        public SyncObject() {\n+            value = false;\n+        }\n+    }\n+\n+    // Object used for implementing the Bookie RecoverCallback for this jUnit\n+    // test. This verifies that the operation completed successfully.\n+    class BookieRecoverCallback implements RecoverCallback {\n+        @Override\n+        public void recoverComplete(int rc, Object ctx) {\n+            LOG.info(\"Recovered bookie operation completed with rc: \" + rc);\n+            assertTrue(rc == Code.OK.intValue());\n+            SyncObject sync = (SyncObject) ctx;\n+            synchronized (sync) {\n+                sync.value = true;\n+                sync.notify();\n+            }\n+        }\n+    }\n+\n+    // Objects to use for this jUnit test.\n+    DigestType digestType;\n+    SyncObject sync;\n+    BookieRecoverCallback bookieRecoverCb;\n+    BookKeeperTools bkTools;\n+\n+    // Constructor\n+    public BookieRecoveryTest(DigestType digestType) {\n+        super(3);\n+        this.digestType = digestType;\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        // Set up the configuration properties needed.\n+        System.setProperty(\"digestType\", digestType.toString());\n+        System.setProperty(\"passwd\", \"\");\n+        sync = new SyncObject();\n+        bookieRecoverCb = new BookieRecoverCallback();\n+        bkTools = new BookKeeperTools(HOSTPORT);\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        // Release any resources used by the BookKeeperTools instance.\n+        bkTools.shutdown();\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Helper method to create a number of ledgers\n+     * \n+     * @param numLedgers\n+     *            Number of ledgers to create\n+     * @return List of LedgerHandles for each of the ledgers created\n+     * @throws BKException\n+     * @throws KeeperException\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    private List<LedgerHandle> createLedgers(int numLedgers) throws BKException, KeeperException, IOException,\n+            InterruptedException {\n+        List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n+        for (int i = 0; i < numLedgers; i++) {\n+            lhs.add(bkc.createLedger(digestType, System.getProperty(\"passwd\").getBytes()));\n+        }\n+        return lhs;\n+    }\n+\n+    /**\n+     * Helper method to write dummy ledger entries to all of the ledgers passed.\n+     * \n+     * @param numEntries\n+     *            Number of ledger entries to write for each ledger\n+     * @param startEntryId\n+     *            The first entry Id we're expecting to write for each ledger\n+     * @param lhs\n+     *            List of LedgerHandles for all ledgers to write entries to\n+     * @throws BKException\n+     * @throws InterruptedException\n+     */\n+    private void writeEntriestoLedgers(int numEntries, long startEntryId, List<LedgerHandle> lhs) throws BKException,\n+            InterruptedException {\n+        for (LedgerHandle lh : lhs) {\n+            for (int i = 0; i < numEntries; i++) {\n+                lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (startEntryId + i)).getBytes());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method to startup a new bookie server with the indicated port\n+     * number\n+     * \n+     * @param port\n+     *            Port to start the new bookie server on\n+     * @throws IOException\n+     */\n+    private void startNewBookie(int port)\n+    throws IOException, InterruptedException {\n+        File f = File.createTempFile(\"bookie\", \"test\");\n+        tmpDirs.add(f);\n+        f.delete();\n+        f.mkdir();\n+        BookieServer server = new BookieServer(port, HOSTPORT, f, new File[] { f });\n+        server.start();\n+        bs.add(server);\n+        while(!server.isRunning()){\n+            Thread.sleep(500);\n+        }\n+        LOG.info(\"New bookie on port \" + port + \" has been created.\");\n+    }\n+\n+    /**\n+     * Helper method to verify that we can read the recovered ledger entries.\n+     * \n+     * @param numLedgers\n+     *            Number of ledgers to verify\n+     * @param startEntryId\n+     *            Start Entry Id to read\n+     * @param endEntryId\n+     *            End Entry Id to read\n+     * @throws BKException\n+     * @throws InterruptedException\n+     */\n+    private void verifyRecoveredLedgers(int numLedgers, long startEntryId, long endEntryId) throws BKException,\n+            InterruptedException {\n+        // Get a set of LedgerHandles for all of the ledgers to verify\n+        List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n+        for (int i = 0; i < numLedgers; i++) {\n+            lhs.add(bkc.openLedger(i + 1, digestType, System.getProperty(\"passwd\").getBytes()));\n+        }\n+        // Read the ledger entries to verify that they are all present and\n+        // correct in the new bookie.\n+        for (LedgerHandle lh : lhs) {\n+            Enumeration<LedgerEntry> entries = lh.readEntries(startEntryId, endEntryId);\n+            while (entries.hasMoreElements()) {\n+                LedgerEntry entry = entries.nextElement();\n+                assertTrue(new String(entry.getEntry()).equals(\"LedgerId: \" + entry.getLedgerId() + \", EntryId: \"\n+                        + entry.getEntryId()));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * This tests the asynchronous bookie recovery functionality by writing\n+     * entries into 3 bookies, killing one bookie, starting up a new one to\n+     * replace it, and then recovering the ledger entries from the killed bookie\n+     * onto the new one. We'll verify that the entries stored on the killed\n+     * bookie are properly copied over and restored onto the new one.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers);\n+\n+        // Write the entries for the ledgers with dummy values.\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+\n+        // Startup a new bookie server\n+        int newBookiePort = initialPort + numBookies;\n+        startNewBookie(newBookiePort);\n+\n+        // Write some more entries for the ledgers so a new ensemble will be\n+        // created for them.\n+        writeEntriestoLedgers(numMsgs, 10, lhs);\n+\n+        // Call the async recover bookie method.\n+        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n+        InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n+                + bookieDest + \")\");\n+        // Initiate the sync object\n+        sync.value = false;\n+        bkTools.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n+\n+        // Wait for the async method to complete.\n+        synchronized (sync) {\n+            while (sync.value == false) {\n+                sync.wait();\n+            }\n+        }\n+\n+        // Verify the recovered ledger entries are okay.\n+        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+    }\n+\n+    /**\n+     * This tests the asynchronous bookie recovery functionality by writing\n+     * entries into 3 bookies, killing one bookie, starting up a few new\n+     * bookies, and then recovering the ledger entries from the killed bookie\n+     * onto random available bookie servers. We'll verify that the entries\n+     * stored on the killed bookie are properly copied over and restored onto\n+     * the other bookies.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers);\n+\n+        // Write the entries for the ledgers with dummy values.\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+\n+        // Startup three new bookie servers\n+        for (int i = 0; i < 3; i++) {\n+            int newBookiePort = initialPort + numBookies + i;\n+            startNewBookie(newBookiePort);\n+        }\n+\n+        // Write some more entries for the ledgers so a new ensemble will be\n+        // created for them.\n+        writeEntriestoLedgers(numMsgs, 10, lhs);\n+\n+        // Call the async recover bookie method.\n+        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n+                + \") and replicate it to a random available one\");\n+        // Initiate the sync object\n+        sync.value = false;\n+        bkTools.asyncRecoverBookieData(bookieSrc, bookieDest, bookieRecoverCb, sync);\n+\n+        // Wait for the async method to complete.\n+        synchronized (sync) {\n+            while (sync.value == false) {\n+                sync.wait();\n+            }\n+        }\n+\n+        // Verify the recovered ledger entries are okay.\n+        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+    }\n+\n+    /**\n+     * This tests the synchronous bookie recovery functionality by writing\n+     * entries into 3 bookies, killing one bookie, starting up a new one to\n+     * replace it, and then recovering the ledger entries from the killed bookie\n+     * onto the new one. We'll verify that the entries stored on the killed\n+     * bookie are properly copied over and restored onto the new one.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers);\n+\n+        // Write the entries for the ledgers with dummy values.\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+\n+        // Startup a new bookie server\n+        int newBookiePort = initialPort + numBookies;\n+        startNewBookie(newBookiePort);\n+\n+        // Write some more entries for the ledgers so a new ensemble will be\n+        // created for them.\n+        writeEntriestoLedgers(numMsgs, 10, lhs);\n+\n+        // Call the sync recover bookie method.\n+        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n+        InetSocketAddress bookieDest = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), newBookiePort);\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc + \") and replicate it to the new one (\"\n+                + bookieDest + \")\");\n+        bkTools.recoverBookieData(bookieSrc, bookieDest);\n+\n+        // Verify the recovered ledger entries are okay.\n+        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+    }\n+\n+    /**\n+     * This tests the synchronous bookie recovery functionality by writing\n+     * entries into 3 bookies, killing one bookie, starting up a few new\n+     * bookies, and then recovering the ledger entries from the killed bookie\n+     * onto random available bookie servers. We'll verify that the entries\n+     * stored on the killed bookie are properly copied over and restored onto\n+     * the other bookies.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers);\n+\n+        // Write the entries for the ledgers with dummy values.\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        LOG.info(\"Finished writing all ledger entries so shutdown one of the bookies.\");\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+\n+        // Startup three new bookie servers\n+        for (int i = 0; i < 3; i++) {\n+            int newBookiePort = initialPort + numBookies + i;\n+            startNewBookie(newBookiePort);\n+        }\n+\n+        // Write some more entries for the ledgers so a new ensemble will be\n+        // created for them.\n+        writeEntriestoLedgers(numMsgs, 10, lhs);\n+\n+        // Call the sync recover bookie method.\n+        InetSocketAddress bookieSrc = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), initialPort);\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieSrc\n+                + \") and replicate it to a random available one\");\n+        bkTools.recoverBookieData(bookieSrc, bookieDest);\n+\n+        // Verify the recovered ledger entries are okay.\n+        verifyRecoveredLedgers(numLedgers, 0, 2 * numMsgs - 1);\n+    }\n+\n+}"},{"sha":"af43f66916e14d260ea63cfc329b2b8262862a48","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/CloseTest.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/CloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/CloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/CloseTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,74 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import org.junit.*;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * This unit test tests closing ledgers sequentially. It creates 4 ledgers, then\n+ * write 1000 entries to each ledger and close it.\n+ * \n+ */\n+\n+public class CloseTest extends BaseTestCase{\n+    static Logger LOG = Logger.getLogger(CloseTest.class);\n+    DigestType digestType;\n+\n+    public CloseTest(DigestType digestType) {\n+        super(3);\n+        this.digestType = digestType;\n+    }\n+\n+    @Test\n+    public void testClose() throws Exception {\n+\n+        /*\n+         * Create 4 ledgers.\n+         */\n+        int numLedgers = 4;\n+        int numMsgs = 100;\n+\n+        LedgerHandle[] lh = new LedgerHandle[numLedgers];\n+        for (int i = 0; i < numLedgers; i++) {\n+            lh[i] = bkc.createLedger(digestType, \"\".getBytes());\n+        }\n+\n+        String tmp = \"BookKeeper is cool!\";\n+\n+        /*\n+         * Write 1000 entries to lh1.\n+         */\n+        for (int i = 0; i < numMsgs; i++) {\n+            for (int j = 0; j < numLedgers; j++) {\n+                lh[j].addEntry(tmp.getBytes());\n+            }\n+        }\n+\n+        for (int i = 0; i < numLedgers; i++) {\n+\n+            lh[i].close();\n+        }\n+    }\n+}"},{"sha":"7888e563db08fe736fa74946acca55670be6f64b","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,178 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests writing to concurrent ledgers\n+ */\n+public class ConcurrentLedgerTest extends TestCase {\n+    Bookie bookie;\n+    File txnDir, ledgerDir;\n+    int recvTimeout = 10000;\n+    Semaphore throttle;\n+    \n+    @Override\n+    @Before\n+    public void setUp() throws IOException {\n+        String txnDirName = System.getProperty(\"txnDir\");\n+        if (txnDirName != null) {\n+            txnDir = new File(txnDirName);\n+        }\n+        String ledgerDirName = System.getProperty(\"ledgerDir\");\n+        if (ledgerDirName != null) {\n+            ledgerDir = new File(ledgerDirName);\n+        }\n+        File tmpFile = File.createTempFile(\"book\", \".txn\", txnDir);\n+        tmpFile.delete();\n+        txnDir = new File(tmpFile.getParent(), tmpFile.getName()+\".dir\");\n+        txnDir.mkdirs();\n+        tmpFile = File.createTempFile(\"book\", \".ledger\", ledgerDir);\n+        ledgerDir = new File(tmpFile.getParent(), tmpFile.getName()+\".dir\");\n+        ledgerDir.mkdirs();\n+        \n+        bookie = new Bookie(5000, null, txnDir, new File[] {ledgerDir});\n+    }\n+    \n+    static void recursiveDelete(File f) {\n+        if (f.isFile()) {\n+            f.delete();\n+        } else {\n+            for(File i: f.listFiles()) {\n+                recursiveDelete(i);\n+            }\n+            f.delete();\n+        }\n+    }\n+    \n+    @Override\n+    @After\n+    public void tearDown() {\n+        try {\n+            bookie.shutdown();\n+            recursiveDelete(txnDir);\n+            recursiveDelete(ledgerDir);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    byte zeros[] = new byte[16];\n+\n+    int iterations = 51;\n+    {\n+        String iterationsString = System.getProperty(\"iterations\");\n+        if (iterationsString != null) {\n+            iterations = Integer.parseInt(iterationsString);\n+        }\n+    }\n+    int iterationStep = 25;\n+    {\n+        String iterationsString = System.getProperty(\"iterationStep\");\n+        if (iterationsString != null) {\n+            iterationStep = Integer.parseInt(iterationsString);\n+        }\n+    }\n+    @Test\n+    public void testConcurrentWrite() throws IOException, InterruptedException, BookieException {\n+        int size = 1024;\n+        int totalwrites = 128;\n+        if (System.getProperty(\"totalwrites\") != null) {\n+            totalwrites = Integer.parseInt(System.getProperty(\"totalwrites\"));\n+        }\n+        System.out.println(\"Running up to \" + iterations + \" iterations\");\n+        System.out.println(\"Total writes = \" + totalwrites);\n+        int ledgers;\n+        for(ledgers = 1; ledgers <= iterations; ledgers += iterationStep) {\n+            long duration = doWrites(ledgers, size, totalwrites);\n+            System.out.println(totalwrites + \" on \" + ledgers + \" took \" + duration + \" ms\");\n+        }\n+        System.out.println(\"ledgers \" + ledgers);\n+        for(ledgers = 1; ledgers <= iterations; ledgers += iterationStep) {\n+            long duration = doReads(ledgers, size, totalwrites);\n+            System.out.println(ledgers + \" read \" + duration + \" ms\");\n+        }\n+    }\n+\n+    private long doReads(int ledgers, int size, int totalwrites)\n+            throws IOException, InterruptedException, BookieException {\n+        long start = System.currentTimeMillis();\n+        for(int i = 1; i <= totalwrites/ledgers; i++) {\n+            for(int j = 1; j <= ledgers; j++) {\n+                ByteBuffer entry = bookie.readEntry(j, i);\n+                // skip the ledger id and the entry id\n+                entry.getLong();\n+                entry.getLong();\n+                assertEquals(j + \"@\" + i, j+2, entry.getLong());\n+                assertEquals(j + \"@\" + i, i+3, entry.getLong());\n+            }\n+        }\n+        long finish = System.currentTimeMillis();\n+        return finish - start;\n+    }\n+    private long doWrites(int ledgers, int size, int totalwrites)\n+            throws IOException, InterruptedException, BookieException {\n+        throttle = new Semaphore(10000);\n+        WriteCallback cb = new WriteCallback() {\n+            @Override\n+            public void writeComplete(int rc, long ledgerId, long entryId,\n+                    InetSocketAddress addr, Object ctx) {\n+                AtomicInteger counter = (AtomicInteger)ctx;\n+                counter.getAndIncrement();\n+                throttle.release();\n+            }\n+        };\n+        AtomicInteger counter = new AtomicInteger();\n+        long start = System.currentTimeMillis();\n+        for(int i = 1; i <= totalwrites/ledgers; i++) {\n+            for(int j = 1; j <= ledgers; j++) {\n+                ByteBuffer bytes = ByteBuffer.allocate(size);\n+                bytes.putLong(j);\n+                bytes.putLong(i);\n+                bytes.putLong(j+2);\n+                bytes.putLong(i+3);\n+                bytes.put((\"This is ledger \" + j + \" entry \" + i).getBytes());\n+                bytes.position(0);\n+                bytes.limit(bytes.capacity());\n+                throttle.acquire();\n+                bookie.addEntry(bytes, cb, counter, zeros);\n+            }\n+        }\n+        long finish = System.currentTimeMillis();\n+        return finish - start;\n+    }\n+}"},{"sha":"b8ad6905d90ba65582ab9c25847d80dc200bd83a","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,163 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.io.File;\n+\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * This class tests the ledger delete functionality both from the BookKeeper\n+ * client and the server side.\n+ */\n+public class LedgerDeleteTest extends BaseTestCase {\n+    static Logger LOG = Logger.getLogger(LedgerDeleteTest.class);\n+    DigestType digestType;\n+\n+    public LedgerDeleteTest(DigestType digestType) {\n+        super(3);\n+        this.digestType = digestType;\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        // Set up the configuration properties needed.\n+        System.setProperty(\"logSizeLimit\", Long.toString(2 * 1024 * 1024L));\n+        System.setProperty(\"gcWaitTime\", \"1000\");\n+        super.setUp();\n+    }\n+\n+    /**\n+     * Common method to create ledgers and write entries to them.\n+     */\n+    private LedgerHandle[] writeLedgerEntries(int numLedgers, int msgSize, int numMsgs) throws Exception {\n+        // Create the ledgers\n+        LedgerHandle[] lhs = new LedgerHandle[numLedgers];\n+        for (int i = 0; i < numLedgers; i++) {\n+            lhs[i] = bkc.createLedger(digestType, \"\".getBytes());\n+        }\n+\n+        // Create a dummy message string to write as ledger entries\n+        StringBuilder msgSB = new StringBuilder();\n+        for (int i = 0; i < msgSize; i++) {\n+            msgSB.append(\"a\");\n+        }\n+        String msg = msgSB.toString();\n+\n+        // Write all of the entries for all of the ledgers\n+        for (int i = 0; i < numMsgs; i++) {\n+            for (int j = 0; j < numLedgers; j++) {\n+                lhs[j].addEntry(msg.getBytes());\n+            }\n+        }\n+\n+        // Return the ledger handles to the inserted ledgers and entries\n+        return lhs;\n+    }\n+\n+    /**\n+     * This test writes enough ledger entries to roll over the entry log file.\n+     * It will then delete all of the ledgers from the client and let the\n+     * server's EntryLogger garbage collector thread delete the initial entry\n+     * log file.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testLedgerDelete() throws Exception {\n+        // Write enough ledger entries so that we roll over the initial entryLog (0.log)\n+        LedgerHandle[] lhs = writeLedgerEntries(3, 1024, 1024);\n+\n+        // Delete all of these ledgers from the BookKeeper client\n+        for (LedgerHandle lh : lhs) {\n+            bkc.deleteLedger(lh.getId());\n+        }\n+        LOG.info(\"Finished deleting all ledgers so waiting for the GC thread to clean up the entryLogs\");\n+        Thread.sleep(2000);\n+\n+        // Verify that the first entry log (0.log) has been deleted from all of the Bookie Servers.\n+        for (File ledgerDirectory : tmpDirs) {\n+            for (File f : ledgerDirectory.listFiles()) {\n+                assertFalse(\"Found the entry log file (0.log) that should have been deleted in ledgerDirectory: \"\n+                        + ledgerDirectory, f.isFile() && f.getName().equals(\"0.log\"));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This test is similar to testLedgerDelete() except it will stop and\n+     * restart the Bookie Servers after it has written out the ledger entries.\n+     * On restart, there will be existing entry logs and ledger index files for\n+     * the EntryLogger and LedgerCache to read and store into memory.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testLedgerDeleteWithExistingEntryLogs() throws Exception {\n+        // Write enough ledger entries so that we roll over the initial entryLog (0.log)\n+        LedgerHandle[] lhs = writeLedgerEntries(3, 1024, 1024);\n+\n+        /*\n+         * Shutdown the Bookie Servers and restart them using the same ledger\n+         * directories. This will test the reading of pre-existing ledger index\n+         * files in the LedgerCache during startup of a Bookie Server.\n+         */\n+        for (BookieServer server : bs) {\n+            server.shutdown();\n+        }\n+        bs.clear();\n+        int j = 0;\n+        for (File f : tmpDirs) {\n+            BookieServer server = new BookieServer(initialPort + j, HOSTPORT, f, new File[] { f });\n+            server.start();\n+            bs.add(server);\n+            j++;\n+        }\n+\n+        // Delete all of these ledgers from the BookKeeper client\n+        for (LedgerHandle lh : lhs) {\n+            bkc.deleteLedger(lh.getId());\n+        }\n+        LOG.info(\"Finished deleting all ledgers so waiting for the GC thread to clean up the entryLogs\");\n+        Thread.sleep(2000);\n+\n+        /*\n+         * Verify that the first two entry logs ([0,1].log) have been deleted\n+         * from all of the Bookie Servers. When we restart the servers in this\n+         * test, a new entry log is created. We know then that the first two\n+         * entry logs should be deleted.\n+         */\n+        for (File ledgerDirectory : tmpDirs) {\n+            for (File f : ledgerDirectory.listFiles()) {\n+                assertFalse(\"Found the entry log file ([0,1].log) that should have been deleted in ledgerDirectory: \"\n+                        + ledgerDirectory, f.isFile() && (f.getName().equals(\"0.log\") || f.getName().equals(\"1.log\")));\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"632502c2360a29c7812b928df5492d17675d260b","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,88 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import org.junit.*;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * This unit test tests ledger recovery.\n+ * \n+ */\n+\n+public class LedgerRecoveryTest extends BaseTestCase {\n+    static Logger LOG = Logger.getLogger(LedgerRecoveryTest.class);\n+\n+    DigestType digestType;\n+\n+    public LedgerRecoveryTest(DigestType digestType) {\n+        super(3);\n+        this.digestType = digestType;\n+    }\n+\n+    private void testInternal(int numEntries) throws Exception {\n+        /*\n+         * Create ledger.\n+         */\n+        LedgerHandle beforelh = null;\n+        beforelh = bkc.createLedger(digestType, \"\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i = 0; i < numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n+\n+        long length = (long) (numEntries * tmp.length());\n+        \n+        /*\n+         * Try to open ledger.\n+         */\n+        LedgerHandle afterlh = bkc.openLedger(beforelh.getId(), digestType, \"\".getBytes());\n+\n+        /*\n+         * Check if has recovered properly.\n+         */\n+        assertTrue(\"Has not recovered correctly: \" + afterlh.getLastAddConfirmed(),\n+                afterlh.getLastAddConfirmed() == numEntries - 1);       \n+        assertTrue(\"Has not set the length correctly: \" + afterlh.getLength() + \", \" + length, \n+                afterlh.getLength() == length);\n+    }\n+    \n+    @Test\n+    public void testLedgerRecovery() throws Exception {\n+        testInternal(100);\n+     \n+    }\n+\n+    @Test\n+    public void testEmptyLedgerRecoveryOne() throws Exception{\n+        testInternal(1);\n+    }\n+\n+    @Test\n+    public void testEmptyLedgerRecovery() throws Exception{\n+        testInternal(0);\n+    }\n+\n+}"},{"sha":"faf97911a12b6f5a113f249beced19bae650c1d8","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,117 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.net.InetSocketAddress;\n+import java.io.IOException;\n+import java.lang.InterruptedException;\n+import java.util.Arrays;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.log4j.Logger;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+/**\n+ * This class tests BookieClient. It just sends the a new entry to itself.\n+ * \n+ * \n+ * \n+ */\n+\n+class LoopbackClient implements WriteCallback {\n+    Logger LOG = Logger.getLogger(LoopbackClient.class);\n+    BookieClient client;\n+    static int recvTimeout = 2000;\n+    long begin = 0;\n+    int limit;\n+    OrderedSafeExecutor executor;\n+\n+    static class Counter {\n+        int c;\n+        int limit;\n+\n+        Counter(int limit) {\n+            this.c = 0;\n+            this.limit = limit;\n+        }\n+\n+        synchronized void increment() {\n+            if (++c == limit)\n+                this.notify();\n+        }\n+    }\n+\n+    LoopbackClient(ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor, long begin, int limit) throws IOException {\n+        this.client = new BookieClient(channelFactory, executor);\n+        this.begin = begin;\n+    }\n+\n+    void write(long ledgerId, long entry, byte[] data, InetSocketAddress addr, WriteCallback cb, Object ctx)\n+            throws IOException, InterruptedException {\n+        LOG.info(\"Ledger id: \" + ledgerId + \", Entry: \" + entry);\n+        byte[] passwd = new byte[20];\n+        Arrays.fill(passwd, (byte) 'a');\n+\n+        client.addEntry(addr, ledgerId, passwd, entry, ChannelBuffers.wrappedBuffer(data), cb, ctx);\n+    }\n+\n+    public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n+        Counter counter = (Counter) ctx;\n+        counter.increment();\n+    }\n+\n+    public static void main(String args[]) {\n+        byte[] data = new byte[Integer.parseInt(args[0])];\n+        Integer limit = Integer.parseInt(args[1]);\n+        Counter c = new Counter(limit);\n+        long ledgerId = Long.valueOf(\"0\").longValue();\n+        long begin = System.currentTimeMillis();\n+\n+        LoopbackClient lb;\n+        ClientSocketChannelFactory channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n+                .newCachedThreadPool());\n+        OrderedSafeExecutor executor = new OrderedSafeExecutor(2);\n+        try {\n+            InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", Integer.valueOf(args[2]).intValue());\n+            lb = new LoopbackClient(channelFactory, executor, begin, limit.intValue());\n+\n+            for (int i = 0; i < limit; i++) {\n+                lb.write(ledgerId, i, data, addr, lb, c);\n+            }\n+\n+            synchronized (c) {\n+                c.wait();\n+                System.out.println(\"Time to write all entries: \" + (System.currentTimeMillis() - begin));\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+}"},{"sha":"980f59d2e47da3e051f09ac1b5b4188dfd2184dd","filename":"bookkeeper/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/bookkeeper/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,60 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * \n+ */\n+\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.bookkeeper.proto.NIOServerFactory;\n+import org.apache.bookkeeper.proto.NIOServerFactory.Cnxn;\n+import org.apache.bookkeeper.proto.NIOServerFactory.PacketProcessor;\n+import org.junit.Test;\n+\n+import junit.framework.TestCase;\n+\n+public class NIOServerFactoryTest extends TestCase {\n+    PacketProcessor problemProcessor = new PacketProcessor() {\n+\n+        public void processPacket(ByteBuffer packet, Cnxn src) {\n+            if (packet.getInt() == 1) {\n+                throw new RuntimeException(\"Really bad thing happened\");\n+            }\n+            src.sendResponse(new ByteBuffer[] { ByteBuffer.allocate(4) });\n+        }\n+\n+    };\n+\n+    @Test\n+    public void testProblemProcessor() throws Exception {\n+        NIOServerFactory factory = new NIOServerFactory(22334, problemProcessor);\n+        Socket s = new Socket(\"127.0.0.1\", 22334);\n+        s.setSoTimeout(5000);\n+        try {\n+            s.getOutputStream().write(\"\\0\\0\\0\\4\\0\\0\\0\\1\".getBytes());\n+            s.getOutputStream().write(\"\\0\\0\\0\\4\\0\\0\\0\\2\".getBytes());\n+            s.getInputStream().read();\n+        } finally {\n+            s.close();\n+            factory.shutdown();\n+        }\n+    }\n+}"},{"sha":"a7948e59fedabb5ff4fc58c4ead418187f85363f","filename":"conf/hw_client_sample.conf","status":"added","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/conf/hw_client_sample.conf","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/conf/hw_client_sample.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/conf/hw_client_sample.conf?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,7 @@\n+# The default Hedwig server host to contact (this ideally should be a VIP \n+# that fronts all of the Hedwig server hubs).\n+default_server_host=hwServer1:4080:9876\n+# This parameter is a boolean flag indicating if communication with the\n+# server should be done via SSL for encryption. The Hedwig server hubs also\n+# need to be SSL enabled for this to work.\n+ssl_enabled=false"},{"sha":"590adfd0e9d9298dcb6b74e65d198228ddf6da63","filename":"conf/hw_server_sample.conf","status":"added","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/conf/hw_server_sample.conf","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/conf/hw_server_sample.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/conf/hw_server_sample.conf?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,10 @@\n+# The ZooKeeper server host(s) for the Hedwig Server to use.\n+zk_host=zkServer1:2181\n+# The number of milliseconds of each tick in ZooKeeper.\n+zk_timeout=2000\n+# The port at which the clients will connect.\n+server_port=4080\n+# The SSL port at which the clients will connect (only if SSL is enabled).\n+ssl_server_port=9876\n+# Flag indicating if the server should also operate in SSL mode.\n+ssl_enabled=false"},{"sha":"c294b3d4eca47534a8bd06b3fcc6b435ad2a8efe","filename":"conf/log4j.properties","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/conf/log4j.properties?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,72 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+#\n+# ZooKeeper Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+log4j.rootLogger=INFO, CONSOLE\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.ConsoleAppender\n+log4j.appender.ROLLINGFILE.Threshold=DEBUG\n+log4j.appender.ROLLINGFILE.File=bookkeeper.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"83c129ad2d976a8e8ef21204ef03424102db494b","filename":"doc/build.txt","status":"added","additions":146,"deletions":0,"changes":146,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/build.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/build.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/build.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,146 @@\n+% Building Hedwig\n+% Yang Zhang\n+\n+Pre-requisites\n+==============\n+\n+For the core itself:\n+\n+- JDK 6: <http://java.sun.com/>.  Ensure `$JAVA_HOME` is correctly set.\n+- Maven 2: <http://maven.apache.org/>.\n+- Protocol Buffers 2.3.0: <http://protobuf.googlecode.com/>.\n+- Zookeeper 3.4.0: <http://hadoop.apache.org/zookeeper/>.  See below.\n+- Bookkeeper 3.4.0: <http://hadoop.apache.org/zookeeper/>.  See below.\n+\n+Hedwig has been tested on Windows XP, Linux 2.6, and OS X.\n+\n+For the deployment and distributed support scripts in `hw.bash`:\n+\n+- Ant: <http://ant.apache.org/>, if you want to build Zookeeper.\n+- Bash: <http://www.gnu.org/software/bash/>.\n+- Coreutils: <http://www.gnu.org/software/coreutils/>.\n+- Expect: <http://expect.nist.gov/>, if you want `unbuffer`.\n+- Findutils: <http://www.gnu.org/software/findutils/>.\n+- OpenSSH: <http://www.openssh.com/>.\n+- Python 2.6: <http://python.org/>.\n+\n+Protocol Buffers\n+----------------\n+\n+Hedwig requires the use of the Java runtime libraries of Protocol Buffers 2.3.0.\n+These libraries need to be installed into your local maven repository. (Maven allows\n+multiple versions to be installed.) To install protocol buffels to your local\n+repository, you have to download the tarball and follow the README.txt \n+instructions. Note that you must first install the C++ package which contains the\n+compiler (protoc) before you can build the java libraries. That will install the\n+library jar's in the local maven repository where Hedwig is currently configured\n+to point to.\n+\n+Zookeeper and Bookkeeper\n+------------------------\n+\n+Hedwig currently requires the version of Bookkeeper maintained in Apache's current\n+trunk SVN respository (version 3.4.0). This is not a released version yet but certain\n+features needed for BookKeeper are only available there.\n+\n+Hedwig also depends on ZK testing code for its own testing code.\n+\n+Since Hedwig is a Maven project, all these dependencies must be made available\n+as Maven artifacts.  However, neither ZK nor BK are currently Mavenized.\n+Hedwig provides some bash scripts to ease the installation of ZK, ZK tests, and\n+BK, all as Maven artifacts.\n+\n+Currently, we have included the necessary ZooKeeper and BookKeeper jars in the Hedwig\n+source itself in the $HEDWIG_DIR/server/lib directory. There is no need to retrieve\n+them directly from the Apache download site as they are non-released trunk versions.\n+\n+#Not relevant right now since we already have the ZK jars already in the Hedwig source.\n+To fetch and build ZK 3.4.0 (and its tests) in the current directory, run:\n+\n+  $HEDWIG_DIR/scripts/hw.bash get-zk\n+\n+#Not relevant right now, but when we start using the apache version of BK, to\n+build the local version of BK:\n+\n+  $HEDWIG_DIR/scripts/hw.bash get-bk\n+\n+The $HEDWIG_DIR/server/lib directory contains all of the the class and source jars for\n+ZK, ZK tests, and BK.  To install these, go to that directory and run the following\n+command to install them into your local maven repository:\n+\n+  $HEDWIG_DIR/scripts/hw.bash install-zk-bk\n+\n+Command-Line Instructions\n+=========================\n+\n+From the main Hedwig directory, run `mvn package`.  This will produce the\n+executable jars for both the client and server, as well as a server \"assembly\n+jar\" containing all dependencies as well for easier deployment.\n+\n+See the User's Guide for instructions on running and usage.\n+\n+Eclipse Instructions\n+====================\n+\n+To check out, build, and develop using Eclipse:\n+\n+1. Install the Subclipse plugin.  Update site:\n+   <http://subclipse.tigris.org/update_1.4.x>.\n+\n+2. Install the Maven plugin.  Update site:\n+   <http://m2eclipse.sonatype.org/update>.  From the list of packages available\n+   from this site, select everything under the \"Maven Integration\" category,\n+   and from the optional components select the ones with the word \"SCM\" in them.\n+\n+3. Go to Preferences > Team > SVN.  For the SVN interface, choose \"Pure Java\".\n+\n+4. Choose File > New > Project... > Maven > Checkout Maven Projects from SCM.\n+\n+5. For the SCM URL type, choose SVN.  For the URL, enter\n+   SVN URL.  Maven will automatically\n+   create a top-level Eclipse project for each of the 4 Maven modules\n+   (recommended).  If you want fewer top-level projects, uncheck the option of\n+   having a project for each module (under Advanced).\n+\n+6. Right-click on the `protocol` project and choose Run As > Maven\n+   generate-sources.  This will generate the Java and C++ code for Protocol\n+   Buffers.\n+\n+7. Refresh the workspace to pick up the generated code and add\n+   `hedwig/protocol/target/generated-sources/java` as a source folder.  (6 & 7\n+   should really be doable automatically, but I haven't figured out how.)\n+\n+You are now ready to run and debug the client and server code.  See the User's\n+Guide for instructions on running and usage.\n+\n+Utilities\n+=========\n+\n+Removing Conflicting Files in Jars\n+----------------------------------\n+\n+The Maven assembly plugin that produces the fat assembly jar may end up putting\n+into the jar files with the same conflicting paths from multiple dependencies.\n+This makes working with the files from certain tools (like `jar`) a bit jarring.\n+In our case, these files are not things like class files, but rather README and\n+LICENSE files, so we can safely remove conflicts by choosing an arbitrary winner.\n+To do so, run:\n+\n+  $HEDWIG_DIR/scripts/hw.bash strip-jar\n+\n+Adjusting Logging\n+-----------------\n+\n+The logging level is something that is baked into the jar in the\n+`log4j.properties` resource.  However, it would be wasteful to go through a\n+Maven build cycle to update and adjust this.  If you're working from a source\n+tree, it's also annoying to have to edit a source file to adjust the logging.\n+\n+We have a little script for tweaking the logging level.  After running\n+`strip-jar`, run:\n+\n+  $HEDWIG_DIR/scripts/hw.bash set-logging WARN\n+\n+To see what the current logging level is:\n+\n+  $HEDWIG_DIR/scripts/hw.bash get-logging"},{"sha":"e40d1a4bf8abb87ab45a08b2a217a578d7d28b31","filename":"doc/dev.txt","status":"added","additions":338,"deletions":0,"changes":338,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/dev.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/dev.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/dev.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,338 @@\n+% Developer's Guide\n+\n+Style\n+=====\n+\n+We have provided an Eclipse Formatter file `formatter.xml` with all the\n+formatting conventions currently used in the project.  Highlights include no\n+tabs, 4-space indentation, and 120-char width.  Please respect this so as to\n+reduce the amount of formatting-related noise produced in commits.\n+\n+Static Analysis\n+===============\n+\n+We would like to use static analysis tools PMD and FindBugs to maintain code\n+quality.  However, we have not yet arrived at a consensus on what rules to\n+adhere to, and what to ignore.\n+\n+Netty Notes\n+===========\n+\n+The asynchronous network IO infrastructure that Hedwig uses is [Netty].  Here\n+are some notes on Netty's concurrency architecture and its filter pipeline\n+design.\n+\n+[Netty]: http://www.jboss.org/netty\n+\n+Concurrency Architecture\n+------------------------\n+\n+After calling `ServerBootstrap.bind()`, Netty starts a boss thread\n+(`NioServerSocketPipelineSink.Boss`) that just accepts new connections and\n+registers them with one of the workers from the `NioWorker` pool in round-robin\n+fashion (pool size defaults to CPU count).  Each worker runs its own select\n+loop over just the set of keys that have been registered with it.  Workers\n+start lazily on demand and run only so long as there are interested fd's/keys.\n+All selected events are handled in the same thread and sent up the pipeline\n+attached to the channel (this association is established by the boss as soon as\n+a new connection is accepted).\n+\n+All workers, and the boss, run via the executor thread pool; hence, the\n+executor must support at least two simultaneous threads.\n+\n+Handler Pipeline\n+----------------\n+\n+A pipeline implements the intercepting filter pattern.  A pipeline is a\n+sequence of handlers.  Whenever a packet is read from the wire, it travels up\n+the stream, stopping at each handler that can handle upstream events.\n+Vice-versa for writes.  Between each filter, control flows back through the\n+centralized pipeline, and a linked list of contexts keeps track of where we are\n+in the pipeline (one context object per handler).\n+\n+Distributed Performance Evaluation\n+==================================\n+\n+We've included some scripts to repeatedly run varying configurations of Hedwig\n+on a distributed testbed and collect the resulting data.  The experiments use\n+the `org.apache.hedwig.client.App` client application and are driven by\n+`scripts/hw.bash` (via the `app` command).\n+\n+Currently, we have two types of experiments: subscription benchmarks and\n+publishing benchmarks.\n+\n+Subscription Benchmarks\n+-----------------------\n+\n+The subscription benchmark compares synchronous and asynchronous subscriptions.\n+Because the synchronicity of subscriptions is a server configuration parameter,\n+the servers must be restarted to change this.  The benchmarks varies the\n+maximum number of outstanding subscription requests.\n+\n+To run the subscription benchmark with wilbur6 as the subscriber and wilbur1 as\n+its default hub:\n+\n+  hosts=wilbur6 scripts/hw.bash sub-exp wilbur1\n+\n+This produces log files into the `sub` directory, which may then be analyzed\n+using the analysis scripts.\n+\n+Publishing Benchmarks\n+---------------------\n+\n+The publishing benchmark measures the throughput and latency of publishing\n+messages within a LAN and across a WAN.  It varies the following parameters:\n+\n+- maximum number of outstanding publish requests\n+- number of publishers\n+- number of (local) receivers\n+\n+We vary each dimension separately (and have default settings) to avoid a\n+combinatorial explosion in the number of configurations to explore.\n+\n+First, start a (standalone) instance:\n+\n+  scripts/hw.bash start-region '' $hwhost $zkhost $bk1host $bk2host $bk3host\n+\n+To run this over `$host1` through `$host3`, with the number of\n+publishers/subscribers varying linearly over this set:\n+\n+  npars=\"20 40 60 80 100\" scripts/hw.bash pub-exps \"$host1 $host2 $host3\" $hwhost $zkhost\n+\n+This will vary the number of outstanding publish requests as specified in\n+`npars`.\n+\n+You may also optionally run this experiment with a second subscribing region:\n+\n+  scripts/hw.bash start-zk-bks $zkhost $bk1host $bk2host $bk3host\n+  npars=\"...\" scripts/hw.bash pub-exps \"$host1 $host2 $host3\" $hwhost $zkhost $rrecv $rhwhost $rzkhost\n+\n+where the final three extra arguments specify the client receiver, Hedwig, and\n+Zookeeper hosts, in that order.\n+\n+This command will produce files into `./pub/`, which can then be process using\n+`analyze.py`.\n+\n+Analysis and Visualization\n+==========================\n+\n+`scripts/analyze.py` produces plots from the collected experimental data.  It\n+has just a few immediate dependencies. In the following, the\n+indentation signifies nested dependencies, like an upside-down tree:\n+\n+      component AAA that component AA requires\n+      component AAB that component AA requires\n+    component AA that component A requires\n+      component ABA that component AB requires\n+      component ABB that component AB requires\n+    component AB that component A requires\n+  component A that analysis tools depend on\n+      component BAA that component BA requires\n+      component BAB that component BA requires\n+    component BA that component B requires\n+      component BBA that component BB requires\n+      component BBB that component BB requires\n+    component BB that component B requires\n+  component B that analysis tools depend on\n+\n+The reason the tree is upside-down is so that you can treat this whole thing as\n+a chunk of bash script.\n+\n+[toast] is a utility that makes it a breeze to install all this software, but\n+you do need to make sure your environment is set up correctly (e.g.\n+`PKG_CONFIG_PATH` must point to `~/.toast/armed/lib/pkgconfig/`).\n+\n+Setup:\n+\n+  wget -O- http://toastball.net/toast/toast|perl -x - arm toast\n+\n+  toast arm \"http://www.python.org/ftp/python/2.6.2/Python-2.6.2.tar.bz2\"\n+\n+  toast arm numpy\n+\n+        toast arm libpng\n+\n+        toast arm pixman\n+\n+        toast arm freetype\n+\n+          toast arm 'ftp://xmlsoft.org/libxml2/libxml2-2.7.3.tar.gz'\n+\n+        toast arm fontconfig\n+\n+      toast arm cairo\n+\n+    toast arm pycairo\n+\n+  hg clone https://yang@bitbucket.org/yang/pycha/\n+  pycha/setup.bash -d -p $path_to_install_to\n+\n+  svn co https://assorted.svn.sourceforge.net/svnroot/assorted/python-commons/trunk/ python-commons/\n+  python-commons/setup.bash -d -p $path_to_install_to\n+\n+To analyze the publishing experiments, change to the `pub` data directory and\n+run:\n+\n+  scripts/analyze.py pub\n+\n+To analyze the subscription experiments, change to the `sub` data directory\n+and run:\n+\n+  scripts/analyze.py sub\n+\n+[toast]: http://toastball.net/toast/\n+\n+Debugging\n+=========\n+\n+You can attach an Eclipse debugger (or any debugger) to a Java process running\n+on a remote host, as long as it has been started with the appropriate JVM\n+flags.  (See the Building Hedwig document to set up your Eclipse environment.)\n+To launch something using `hw.bash` with debugger attachment enabled, prefix\n+the command with `attach=true`, e.g.:\n+\n+  attach=true scripts/hw.bash start-regions myregions.cfg\n+\n+Profiling\n+=========\n+\n+The scripts we have provided include ways for you to launch with YourKit\n+profiling enabled.\n+\n+To deploy YourKit onto a number of machines:\n+\n+  hosts=\"...\" scripts/hw.bash setup-yjp $path_to_yjp\n+\n+where the path points to the [YourKit Linux zip archive] (which is freely\n+available and doesn't require any license to use).\n+\n+Now when using the scripts to run distributed experiments, to profile anything\n+with YourKit, prefix the command with `use_yjp=true`.  E.g.:\n+\n+  use_yjp=true scripts/hw.bash start-regions regions.cfg\n+\n+Now you may start on your local machine the YourKit GUI and connect to the\n+hosts that you're interested in.\n+\n+Note that you may want to disable the default set of filters in YourKit.\n+\n+[YourKit Linux zip archive]: http://www.yourkit.com/download/yjp-8.0.15.zip\n+\n+Pseudocode\n+==========\n+\n+This summarizes the control flow through the system.\n+\n+  publishhandler\n+    topicmgr.getowner\n+      (maybe) claim the topic, calling back into persmgr.acquiredtopic\n+        read /hedwig/standalone/topics/TOPIC (which should initially be empty)\n+        for each line, parse as \"STARTSEQ\\tLEDGERID\" # TODO how is this written?\n+          ledger = bk.openledger(ledgerid)\n+          lastid = ledger.getlast\n+          if lastid > 0, lrs[startseq] = persmgr.ledger2lr[ledgerid] = new LedgerRange(ledger, ledgerid, startseq, startseq + lastid # TODO what are ledger ranges?\n+        create new ledger for topic\n+          # TODO read\n+          lr = new LedgerRange(ledger, ledgerid, lastid, -1)\n+          lrs[lastid] = lr\n+          persmgr.topic2ranges[topic] = lrs\n+    add region info to pub req and send that to persmgr.persistmessage\n+      entryid = persmgr.topic2ranges[topic].last.ledger.addentry(the pub'd data)\n+      update persmgr.topic2lastseq[topic]:\n+        .local = persmgr.ledger2lr[ledger id].startseq + entryid\n+        .regions = maxes of orig seq and incoming pub seq\n+\n+  subscribehandler\n+    topicmgr.getowner...\n+    delivmgr.startservingsubscription(topic, endpoint, ishubsubscriber)\n+      delivmgr.endpoint2sub[endpoint] = new subscriber(lastseq = persmgr.getcurrentseqidfortopic(topic).local)\n+      delivmgr.topic2ptr2subs[topic][ptr].add(sub)\n+      sub.delivernextmessage\n+        sub.curseq = persmgr.getseqidafterskipping(topic, sub.lastseq, skip = 1)\n+        msg = persmgr.scansinglemessage(topic, seq = sub.curseq)\n+          if persmgr.topic2lastseq[topic].local >= seq\n+            lr = persmgr.topic2ranges[topic].floor(seq)\n+            return lr.ledger.read(first = last = seq - lr.startseq)\n+        if failed, then retry in 1 s\n+        endpoint.send(msg)\n+        movedeliveryptr\n+          delivmgr.topic2ptr2subs[topic][sub.lastseq].remove(sub)\n+          delivmgr.topic2ptr2subs[topic][sub.curseq].add(sub)\n+        previd = sub.lastseq, sub.lastseq = sub.curseq\n+        sub.delivernextmessage...\n+\n+ReadAhead Cache\n+================\n+\n+The delivery manager class is responsible for pushing published messages from \n+the hubs to the subscribers. The most common case is that all subscribers are \n+connected and either caught up, or close to the tail end of the topic. In this \n+case, we don't want the delivery manager to be polling bookkeeper for any newly \n+arrived messages on the topic; new messages should just be pushed to the \n+delivery manager. However, there is also the uncommon case when a subscriber is \n+behind, and messages must be pulled from Bookkeeper.\n+\n+Since all publishes go through the hub, it is possible to cache the recently \n+published messages in the hub, and then the delivery manager won't have to make \n+the trip to bookkeeper to get the messages but instead get them from local \n+process memory.\n+\n+These ideas of push, pull, and caching are unified in the following way:\n+- A hub has a cache of messages\n+\n+- When the delivery manager wants to deliver a message, it asks the cache for \n+  it. There are 3 cases:\n+  - The message is available in the cache, in which case it is given to the \n+    delivery manager\n+  - The message is not present in the cache and the seq-id of the message is \n+    beyond the last message published on that topic (this happens if the \n+    subscriber is totally caught up for that topic). In this case, a stub is put \n+    in the cache in order to notify the delivery manager when that message does \n+    happen to be published.\n+  - The message is not in the cache but has been published to the topic. In this \n+    case, a stub is put in the cache, and a read is issued to bookkeeper.\n+\n+- Whenever a message is published, it is cached. If there is a stub already in \n+  the cache for that message, the delivery manager is notified. \n+\n+- Whenever a message is read from bookkeeper, it is cached. There must be a stub \n+  for that message (since reads to bookkeeper are issued only after putting a \n+  stub), so the delivery manager is notified. \n+\n+- The cache does readahead, i.e., if a message requested by the delivery manager \n+  is not in the cache, a stub is established not only for that message, but also \n+  for the next n messages where n is configurable (default 10). On a cache hit, \n+  we look ahead n/2 messages, and if that message is not present, we establish \n+  another n/2 stubs. In short, we always ensure that the next n stubs are always \n+  established.\n+\n+- Over time, the cache will grow in size. There are 2 pruning mechanisms:\n+  \n+  - Once all subscribers have consumed up to a particular seq-id, they notify \n+    the cache, and all messages up to that seq-id are pruned from the cache.\n+  - If the above pruning is not working (e.g., because some subscribers are \n+    down), the cache will eventually hit its size limit which is configurable  \n+    (default, half of maximum jvm heap size). At this point, messages are just \n+    pruned in FIFO order. We use the size of the blobs in the message for \n+    estimating the cache size. The assumption is that that size will dominate \n+    over fixed, object-level size overheads. \n+  - Stubs are not purged because according to the above simplification, they are \n+    of 0 size.\n+\n+Scalability Bottlenecks Down the Road\n+=====================================\n+\n+- Currently each topic subscription is served on a different channel. The number \n+  of channels will become a bottleneck at higher channels. We should switch to \n+  an architecture, where multiple topic subscriptions between the same client, \n+  hub pair should be served on the same channel. We can have commands to start, \n+  stop subscriptions sent all the way to the server (right now these are local).\n+- Publishes for a topic are serialized through a hub, to get ordering \n+  guarantees. Currently, all subscriptions to that topic are served from the \n+  same hub. If we start having large number of subscribers to heavy-volume \n+  topics, the outbound bandwidth at the hub, or the CPU at that hub might become \n+  the bottleneck. In that case, we can setup other regions through which the \n+  messages are routed (this hierarchical scheme) reduces bandwidth requirements \n+  at any single node. It should be possible to do this entirely through \n+  configuration.\n+"},{"sha":"36f2c0bae97d7e3f270bf2740ecd9ddfe3444d4e","filename":"doc/doc.txt","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/doc.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/doc.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/doc.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,17 @@\n+% Meta-Documentation\n+\n+In the documentation directory, you'll find:\n+\n+- `build.txt`: Building Hedwig, or how to set up Hedwig\n+- `user.txt`: User's Guide, or how to program against the Hedwig API and how to\n+  run it\n+- `dev.txt`: Developer's Guide, or Hedwig internals and hacking details\n+\n+These documents are all written in the [Pandoc] dialect of [Markdown].  This\n+makes them readable as plain text files, but also capable of generating HTML or\n+LaTeX documentation.\n+\n+[Pandoc]: http://johnmacfarlane.net/pandoc/\n+[Markdown]: http://daringfireball.net/projects/markdown/\n+\n+Documents are wrapped at 80 chars and use 2-space indentation."},{"sha":"242e97695ec1f629aab7216aae980da0a153d7df","filename":"doc/user.txt","status":"added","additions":252,"deletions":0,"changes":252,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/user.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/doc/user.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/user.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,252 @@\n+% User's Guide\n+% Yang Zhang\n+\n+Design\n+======\n+\n+In Hedwig, clients publish messages associated with a topic, and they subscribe\n+to a topic to receive all messages published with that topic.  Clients are\n+associated with (publish to and subscribe from) a Hedwig _instance_ (also\n+referred to as a _region_), which consists of a number of servers called\n+_hubs_.  The hubs partition up topic ownership among themselves, and all\n+publishes and subscribes to a topic must be done to its owning hub.  When a\n+client doesn't know the owning hub, it tries a default hub, which may redirect\n+the client.\n+\n+Running a Hedwig instance requires a Zookeeper server and at least three\n+Bookkeeper servers.\n+\n+An instance is designed to run within a datacenter.  For wide-area messaging\n+across datacenters, specify in the server configuration the set of default\n+servers for each of the other instances.  Dissemination among instances\n+currently takes place over an all-to-all topology.  Local subscriptions cause\n+the hub to subscribe to all other regions on this topic, so that the local\n+region receives all updates to it.  Future work includes allowing the user to\n+overlay alternative topologies.\n+\n+Because all messages on a topic go through a single hub per region, all\n+messages within a region are ordered.  This means that, for a given topic,\n+messages are delivered in the same order to all subscribers within a region,\n+and messages from any particular region are delivered in the same order to all\n+subscribers globally, but messages from different regions may be delivered in\n+different orders to different regions.  Providing global ordering is\n+prohibitively expensive in the wide area.  However, in Hedwig clients such as\n+PNUTS, the lack of global ordering is not a problem, as PNUTS serializes all\n+updates to a table row at a single designated master for that row.\n+\n+Topics are independent; Hedwig provides no ordering across different topics.\n+\n+Version vectors are associated with each topic and serve as the identifiers for\n+each message.  Vectors consist of one component per region.  A component value\n+is the region's local sequence number on the topic, and is incremented each\n+time a hub persists a message (published either locally or remotely) to BK.\n+\n+TODO: More on how version vectors are to be used, and on maintaining\n+vector-maxes.\n+\n+Entry Points\n+============\n+\n+The main class for running the server is\n+`org.apache.hedwig.server.netty.PubSubServer`.  It takes a single argument,\n+which is a [Commons Configuration] file.  Currently, for configuration, the\n+source is the documentation.  See\n+`org.apache.hedwig.server.conf.ServerConfiguration` for server configuration\n+parameters.\n+\n+The client is a library intended to be consumed by user applications.  It takes\n+a Commons Configuration object, for which the source/documentation is in\n+`org.apache.hedwig.client.conf.ClientConfiguration`.\n+\n+We have provided a simple client application, `org.apache.hedwig.client.App`,\n+that can drive a number of benchmarks.  This also takes a single configuration\n+file argument, which is fed to the client library.\n+\n+We've provided a number of scripts to faciliate running servers and clients\n+in a variety of configurations, including over distributed hosts.  These are\n+all consolidated in `scripts/hw.bash`.  Although the snippets in this\n+documentation run the script from the hedwig main directory, you can run it\n+from any location.  Apologies in advance for these being bash scripts; time\n+permitting, a more robust and maintainable support/tooling infrastructure would\n+be ideal.\n+\n+[Commons Configuration]: http://commons.apache.org/configuration/\n+\n+Deployment\n+==========\n+\n+When ssh-ing into a new host, you are requested to verify and accept the host\n+key.  In order to automatically accept the host keys for many new hosts\n+(dangerous), use:\n+\n+  hosts=\"$host1 $host2 ...\" scripts/hw.bash warmup\n+\n+The `hosts` variable is set here to the list of hosts that you would like to\n+warm up.\n+\n+To set up JDK6 on some hosts, use:\n+\n+  hosts=\"...\" scripts/hw.bash setup-java $path_to_modified_jdk6\n+\n+The argument must point to a JDK6 binary self-extracting executable, but with\n+the `more` command that displays the License agreement replaced with\n+`cat`.  Unfortunately, this step must be performed manually.  This script will\n+extract the JDK directly into the home directory and update `$PATH` in\n+`~/.bashrc` (in an idempotent fashion).\n+\n+Because the current implementation uses a single socket per subscription, the\n+Hedwig launching scripts all require a high `ulimit` on the number of open file\n+descriptors.  Non-root users can only use up to the limit specified in\n+`/etc/security/limits.conf`; to raise this to 1024^2, run:\n+\n+  hosts=\"...\" scripts/hw.bash setup-limits\n+\n+This uses `ssh` so that you need to enter your password for `sudo` just\n+once.\n+\n+For most of the commands presented in the next section, you may prefix the\n+command with:\n+\n+  push_jar=true ...\n+\n+to first push the assembly jar (assumed to be available in `server/target/`) to\n+all hosts.\n+\n+Running Servers\n+===============\n+\n+To start three BK bookies on ports 3181-3183 on localhost (directories must all\n+exist):\n+\n+  scripts/hw.bash bk 3181 $bk1_journal_dir $bk1_ledger_dir &\n+  scripts/hw.bash bk 3182 $bk2_journal_dir $bk2_ledger_dir &\n+  scripts/hw.bash bk 3183 $bk3_journal_dir $bk3_ledger_dir &\n+\n+To start a ZK on port 2181 (directory must exist):\n+\n+  scripts/hw.bash zk 2181 /path/for/zk/ &\n+\n+To register the BKs with the ZK (so that Hedwig knows where to find the\n+bookies):\n+\n+  scripts/hw.bash setup-bk localhost:2181 `hostname`:3181 `hostname`:3182 `hostname`:3183\n+\n+Everything up to this point may be done using a single command over a set of\n+hosts, with ZK on port 9877 and BK on port 9878. The following function takes\n+2 arguments.  The first is the ZK host.  The second is a string list of BK hosts:\n+\n+  scripts/hw.bash start-zk-bks $zkhost \"$bk1host $bk2host $bk3host ...\"\n+\n+Note that the hosts may be SSH profile aliases in your `~/.ssh/config`; the\n+script will parse this file and look up their hostnames where necessary.  This\n+applies for the hosts specified in the other commands.\n+\n+Also, the scripts use the `bk-journal` and `bk-ledger` functions in `hw.bash`\n+to determine where to place the BK journal and ledger, given a hostname.\n+\n+To start a Hedwig server locally:\n+\n+  scripts/hw.bash hw server.conf &\n+\n+To start Hedwig servers on some hosts \"$hw1host $hw2host $hw3host ...\" on port 9876, \n+using $zkhost as the ZK server:\n+\n+  scripts/hw.bash start-hw '' \"$hw1host $hw2host $hw3host ...\" $zkhost\n+\n+Above, the first empty string argument is the list of default servers to each \n+of the other regions.  You may run multiple connected instances of Hedwig this way.  \n+E.g., to start three regions each with a single Hedwig hub that talk to each other,\n+and using the hw.bash default server ports of 9875 (non-SSL) and 9876 (SSL):\n+\n+  scripts/hw.bash start-hw \"$hw2host:9875:9876 $hw3host:9875:9876\" \"$hw1host\" $zk1host\n+  scripts/hw.bash start-hw \"$hw1host:9875:9876 $hw3host:9875:9876\" \"$hw2host\" $zk2host\n+  scripts/hw.bash start-hw \"$hw1host:9875:9876 $hw2host:9875:9876\" \"$hw3host\" $zk3host\n+\n+Everything up to this point may be done using a single command over a set of\n+hosts:\n+\n+  scripts/hw.bash start-region '' \"$hw1host $hw2host $hw3host ...\" $zkhost \"$bk1host $bk2host $bk3host ...\"\n+\n+The first three arguments are the same as for `start-hw`.\n+\n+You may start multiple regions as well:\n+\n+  scripts/hw.bash start-regions regions.cfg\n+\n+\"regions.cfg\" is a list of all regions, one per line, with each region having \n+the following format:\n+\n+  region=<Region name>, hub=<list of hub servers>, default=<single hub server>, zk=<single ZK server>, bk=<list of BK servers>\n+\n+This will create all of the regions with an all-to-all topology. Each region \n+is connected to the default hub server of every other region. The \", \" delimiter\n+is used to separate out the different parts of a region along with the hard-coded \n+parameter names. There also needs to be a newline after the last region line.\n+Here is an example file specifying three regions:\n+\n+  region=wilbur, hub=wilbur90 wilbur91, default=wilbur90, zk=wilbur93, bk=wilbur93 wilbur94 wilbur95\n+  region=re1, hub=sherpa7 sherpa8, default=sherpa7, zk=sherpa9, bk=sherpa9 sherpa10 sherpa11\n+  region=peanuts, hub=peanuts1 peanuts2, default=peanuts2, zk=peanuts3, bk=peanuts3 peanuts4 peanuts5\n+\n+Running the Client\n+==================\n+\n+To run the test client:\n+\n+  JAVAFLAGS=\"...\" scripts/hw.bash hwc $conf_path\n+\n+where `$conf_path` is a client configuration file.\n+\n+To run the test client on some other hosts:\n+\n+  hosts=\"...\" JAVAFLAGS=\"...\" scripts/hw.bash app $hwhost\n+\n+This will generate a simple configuration file assuming $hwhost is listening on\n+the default SSL and non-SSL ports which are specified as global variables in hw.bash.\n+Currently these are 9875 for non-SSL and 9876 for SSL.\n+\n+Client usage is currently documented in the source.  To run a subscription\n+benchmark, set `JAVAFLAGS` to:\n+\n+  -Dmode=sub -Dcount=10000 -Dnpar=100 -Dstart=5 -Dnwarmups=30\n+\n+This will first create 30 warm-up subscriptions to topics \"warmup-5\" through\n+\"warmup-34\", then 10,000 benchmarked subscriptions to topics \"topic-5\" through\n+\"topic-10,004\".  It will have a pipeline depth of 100 requests, meaning that\n+there will be at most 100 outstanding (unresponded) messages in flight at any\n+moment.\n+\n+To run a publishing benchmark, set `JAVAFLAGS` to:\n+\n+  -Dmode=pub -Dcount=10000 -Dnpar=100 -Dstart=5\n+\n+This will publish 10,000 messages to topic \"topic-5\", with a pipeline depth of\n+100 requests.\n+\n+At the end, the programs will print throughput and latency information.\n+\n+Utilities\n+=========\n+\n+To kill all the user's Java processes running on some machines, use:\n+\n+  hosts=\"...\" scripts/hw.bash dkill\n+\n+To check if any processes are running and are using ports of interest (esp.\n+9876-9878):\n+\n+  hosts=\"...\" scripts/hw.bash dstatus\n+\n+Add an argument to `dstatus` (may be anything) to get a more detailed listing.\n+\n+To check if there's anything consuming the CPU on some machines:\n+\n+  hosts=\"...\" scripts/hw.bash tops\n+\n+To run an arbitrary command on multiple hosts in parallel:\n+\n+  hosts=\"...\" scripts/hw.bash parssh $command\n+\n+To do this in sequence:\n+\n+  hosts=\"...\" xargs= scripts/hw.bash parssh $command"},{"sha":"f828df1c1e03621fdf12a4a0f27a0436c9a618ca","filename":"formatter.xml","status":"added","additions":286,"deletions":0,"changes":286,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/formatter.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/formatter.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/formatter.xml?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,286 @@\n+<!--\r\n+   Licensed to the Apache Software Foundation (ASF) under one or more\r\n+   contributor license agreements.  See the NOTICE file distributed with\r\n+   this work for additional information regarding copyright ownership.\r\n+   The ASF licenses this file to You under the Apache License, Version 2.0\r\n+   (the \"License\"); you may not use this file except in compliance with\r\n+   the License.  You may obtain a copy of the License at\r\n+\r\n+       http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+   Unless required by applicable law or agreed to in writing, software\r\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+   See the License for the specific language governing permissions and\r\n+   limitations under the License.\r\n+-->\r\n+\r\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n+<profiles version=\"11\">\r\n+<profile kind=\"CodeFormatterProfile\" name=\"Hedwig\" version=\"11\">\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_field\" value=\"0\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_ellipsis\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_multiple_fields\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_conditional_expression\" value=\"80\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_binary_operator\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_array_initializer\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_after_package\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.continuation_indentation\" value=\"2\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_binary_operator\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_package\" value=\"0\"/>\r\n+<setting id=\"org.eclipse.jdt.core.compiler.source\" value=\"1.5\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.format_line_comments\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.join_wrapped_lines\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_member_type\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.align_type_members_on_columns\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_unary_operator\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.indent_parameter_description\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.lineSplit\" value=\"120\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration\" value=\"0\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indentation.size\" value=\"4\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_assignment\" value=\"0\"/>\r\n+<setting id=\"org.eclipse.jdt.core.compiler.problem.assertIdentifier\" value=\"error\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.tabulation.char\" value=\"space\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_statements_compare_to_body\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_method\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_switch\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.compiler.problem.enumIdentifier\" value=\"error\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_ellipsis\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_block\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_method_declaration\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.compact_else_if\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_enum_constant\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.indent_root_tags\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.tabulation.size\" value=\"4\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_empty_lines\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_block_in_case\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.compiler.compliance\" value=\"1.5\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer\" value=\"2\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_unary_operator\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_binary_expression\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode\" value=\"enabled\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.format_javadoc_comments\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.line_length\" value=\"80\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_between_import_groups\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_semicolon\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body\" value=\"0\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.wrap_before_binary_operator\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_statements_compare_to_block\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.join_lines_in_comments\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_compact_if\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_before_imports\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.format_html\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.format_source_code\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration\" value=\"16\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.compiler.codegen.targetPlatform\" value=\"1.5\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.format_header\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.comment.format_block_comments\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.alignment_for_enum_constants\" value=\"0\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.brace_position_for_type_declaration\" value=\"end_of_line\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.blank_lines_after_imports\" value=\"1\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header\" value=\"true\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for\" value=\"insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments\" value=\"do not insert\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column\" value=\"false\"/>\r\n+<setting id=\"org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line\" value=\"false\"/>\r\n+</profile>\r\n+</profiles>\r"},{"sha":"05f2a8a0e45fca30b5becdf4b9d051a62dfcf9e3","filename":"hedwig-client/pom.xml","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/pom.xml?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,86 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <parent>\n+    <groupId>org.apache.hedwig</groupId>\n+    <artifactId>hedwig</artifactId>\n+    <version>1.0-SNAPSHOT</version>\n+  </parent>\n+  <properties>\n+      <mainclass>org.apache.hedwig.client.App</mainclass>\n+  </properties>\n+  <groupId>org.apache.hedwig</groupId>\n+  <artifactId>client</artifactId>\n+  <packaging>jar</packaging>\n+  <version>1.0-SNAPSHOT</version>\n+  <name>client</name>\n+  <url>http://maven.apache.org</url>\n+  <dependencies>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>4.8.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.hedwig</groupId>\n+      <artifactId>protocol</artifactId>\n+      <version>1.0-SNAPSHOT</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>log4j</groupId>\n+      <artifactId>log4j</artifactId>\n+      <version>1.2.14</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.jboss.netty</groupId>\n+      <artifactId>netty</artifactId>\n+      <version>3.1.2.GA</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>commons-configuration</groupId>\n+      <artifactId>commons-configuration</artifactId>\n+      <version>1.6</version>\n+    </dependency>\n+    <dependency>\n+    \t<groupId>org.apache.zookeeper</groupId>\n+    \t<artifactId>zookeeper</artifactId>\n+    \t<version>3.3.3</version>\n+    \t<type>jar</type>\n+    </dependency>\n+    <dependency>\n+    \t<groupId>org.apache.bookkeeper</groupId>\n+    \t<artifactId>bookkeeper</artifactId>\n+    \t<version>3.4.0-SNAPSHOT</version>\n+    \t<type>pom</type>\n+    \t<scope>compile</scope>\n+    </dependency>\n+  </dependencies>\n+  <repositories>\n+    <repository>\n+      <id>jboss.release</id>\n+      <name>JBoss releases</name>\n+      <url>http://repository.jboss.org/maven2</url>\n+    </repository>\n+  </repositories>\n+</project>"},{"sha":"b683095e6b8c0ede6018db1d0c2cd7f0ea616760","filename":"hedwig-client/src/main/cpp/Makefile.am","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/Makefile.am?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,29 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+ACLOCAL_AMFLAGS = -I m4\n+\n+SUBDIRS = lib test\n+\n+library_includedir=$(includedir)/hedwig-0.1/hedwig\n+library_include_HEADERS = inc/hedwig/callback.h inc/hedwig/client.h inc/hedwig/exceptions.h inc/hedwig/publish.h inc/hedwig/subscribe.h \n+\n+pkgconfigdir = $(libdir)/pkgconfig\n+nodist_pkgconfig_DATA = hedwig-0.1.pc\n+\n+EXTRA_DIST = $(DX_CONFIG) doc/html"},{"sha":"420049eca3564dd70362b6d980574d0c36cf4fc5","filename":"hedwig-client/src/main/cpp/aminclude.am","status":"added","additions":186,"deletions":0,"changes":186,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/aminclude.am","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/aminclude.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/aminclude.am?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,186 @@\n+# Copyright (C) 2004 Oren Ben-Kiki\n+# This file is distributed under the same terms as the Automake macro files.\n+\n+# Generate automatic documentation using Doxygen. Goals and variables values\n+# are controlled by the various DX_COND_??? conditionals set by autoconf.\n+#\n+# The provided goals are:\n+# doxygen-doc: Generate all doxygen documentation.\n+# doxygen-run: Run doxygen, which will generate some of the documentation\n+#              (HTML, CHM, CHI, MAN, RTF, XML) but will not do the post\n+#              processing required for the rest of it (PS, PDF, and some MAN).\n+# doxygen-man: Rename some doxygen generated man pages.\n+# doxygen-ps: Generate doxygen PostScript documentation.\n+# doxygen-pdf: Generate doxygen PDF documentation.\n+#\n+# Note that by default these are not integrated into the automake goals. If\n+# doxygen is used to generate man pages, you can achieve this integration by\n+# setting man3_MANS to the list of man pages generated and then adding the\n+# dependency:\n+#\n+#   $(man3_MANS): doxygen-doc\n+#\n+# This will cause make to run doxygen and generate all the documentation.\n+#\n+# The following variable is intended for use in Makefile.am:\n+#\n+# DX_CLEANFILES = everything to clean.\n+#\n+# This is usually added to MOSTLYCLEANFILES.\n+\n+## --------------------------------- ##\n+## Format-independent Doxygen rules. ##\n+## --------------------------------- ##\n+\n+if DX_COND_doc\n+\n+## ------------------------------- ##\n+## Rules specific for HTML output. ##\n+## ------------------------------- ##\n+\n+if DX_COND_html\n+\n+DX_CLEAN_HTML = @DX_DOCDIR@/html\n+\n+endif DX_COND_html\n+\n+## ------------------------------ ##\n+## Rules specific for CHM output. ##\n+## ------------------------------ ##\n+\n+if DX_COND_chm\n+\n+DX_CLEAN_CHM = @DX_DOCDIR@/chm\n+\n+if DX_COND_chi\n+\n+DX_CLEAN_CHI = @DX_DOCDIR@/@PACKAGE@.chi\n+\n+endif DX_COND_chi\n+\n+endif DX_COND_chm\n+\n+## ------------------------------ ##\n+## Rules specific for MAN output. ##\n+## ------------------------------ ##\n+\n+if DX_COND_man\n+\n+DX_CLEAN_MAN = @DX_DOCDIR@/man\n+\n+endif DX_COND_man\n+\n+## ------------------------------ ##\n+## Rules specific for RTF output. ##\n+## ------------------------------ ##\n+\n+if DX_COND_rtf\n+\n+DX_CLEAN_RTF = @DX_DOCDIR@/rtf\n+\n+endif DX_COND_rtf\n+\n+## ------------------------------ ##\n+## Rules specific for XML output. ##\n+## ------------------------------ ##\n+\n+if DX_COND_xml\n+\n+DX_CLEAN_XML = @DX_DOCDIR@/xml\n+\n+endif DX_COND_xml\n+\n+## ----------------------------- ##\n+## Rules specific for PS output. ##\n+## ----------------------------- ##\n+\n+if DX_COND_ps\n+\n+DX_CLEAN_PS = @DX_DOCDIR@/@PACKAGE@.ps\n+\n+DX_PS_GOAL = doxygen-ps\n+\n+doxygen-ps: @DX_DOCDIR@/@PACKAGE@.ps\n+\n+@DX_DOCDIR@/@PACKAGE@.ps: @DX_DOCDIR@/@PACKAGE@.tag\n+\tcd @DX_DOCDIR@/latex; \\\n+\trm -f *.aux *.toc *.idx *.ind *.ilg *.log *.out; \\\n+\t$(DX_LATEX) refman.tex; \\\n+\t$(MAKEINDEX_PATH) refman.idx; \\\n+\t$(DX_LATEX) refman.tex; \\\n+\tcountdown=5; \\\n+\twhile $(DX_EGREP) 'Rerun (LaTeX|to get cross-references right)' \\\n+\t                  refman.log > /dev/null 2>&1 \\\n+\t   && test $$countdown -gt 0; do \\\n+\t    $(DX_LATEX) refman.tex; \\\n+\t    countdown=`expr $$countdown - 1`; \\\n+\tdone; \\\n+\t$(DX_DVIPS) -o ../@PACKAGE@.ps refman.dvi\n+\n+endif DX_COND_ps\n+\n+## ------------------------------ ##\n+## Rules specific for PDF output. ##\n+## ------------------------------ ##\n+\n+if DX_COND_pdf\n+\n+DX_CLEAN_PDF = @DX_DOCDIR@/@PACKAGE@.pdf\n+\n+DX_PDF_GOAL = doxygen-pdf\n+\n+doxygen-pdf: @DX_DOCDIR@/@PACKAGE@.pdf\n+\n+@DX_DOCDIR@/@PACKAGE@.pdf: @DX_DOCDIR@/@PACKAGE@.tag\n+\tcd @DX_DOCDIR@/latex; \\\n+\trm -f *.aux *.toc *.idx *.ind *.ilg *.log *.out; \\\n+\t$(DX_PDFLATEX) refman.tex; \\\n+\t$(DX_MAKEINDEX) refman.idx; \\\n+\t$(DX_PDFLATEX) refman.tex; \\\n+\tcountdown=5; \\\n+\twhile $(DX_EGREP) 'Rerun (LaTeX|to get cross-references right)' \\\n+\t                  refman.log > /dev/null 2>&1 \\\n+\t   && test $$countdown -gt 0; do \\\n+\t    $(DX_PDFLATEX) refman.tex; \\\n+\t    countdown=`expr $$countdown - 1`; \\\n+\tdone; \\\n+\tmv refman.pdf ../@PACKAGE@.pdf\n+\n+endif DX_COND_pdf\n+\n+## ------------------------------------------------- ##\n+## Rules specific for LaTeX (shared for PS and PDF). ##\n+## ------------------------------------------------- ##\n+\n+if DX_COND_latex\n+\n+DX_CLEAN_LATEX = @DX_DOCDIR@/latex\n+\n+endif DX_COND_latex\n+\n+.PHONY: doxygen-run doxygen-doc $(DX_PS_GOAL) $(DX_PDF_GOAL)\n+\n+.INTERMEDIATE: doxygen-run $(DX_PS_GOAL) $(DX_PDF_GOAL)\n+\n+doxygen-run: @DX_DOCDIR@/@PACKAGE@.tag\n+\n+doxygen-doc: doxygen-run $(DX_PS_GOAL) $(DX_PDF_GOAL)\n+\n+@DX_DOCDIR@/@PACKAGE@.tag: $(DX_CONFIG) $(pkginclude_HEADERS)\n+\trm -rf @DX_DOCDIR@\n+\t$(DX_ENV) $(DX_DOXYGEN) $(srcdir)/$(DX_CONFIG)\n+\n+DX_CLEANFILES = \\\n+    @DX_DOCDIR@/@PACKAGE@.tag \\\n+    -r \\\n+    $(DX_CLEAN_HTML) \\\n+    $(DX_CLEAN_CHM) \\\n+    $(DX_CLEAN_CHI) \\\n+    $(DX_CLEAN_MAN) \\\n+    $(DX_CLEAN_RTF) \\\n+    $(DX_CLEAN_XML) \\\n+    $(DX_CLEAN_PS) \\\n+    $(DX_CLEAN_PDF) \\\n+    $(DX_CLEAN_LATEX)\n+\n+endif DX_COND_doc"},{"sha":"8e1999e2400af3032c5edfb998c160e418d8ced8","filename":"hedwig-client/src/main/cpp/c-doc.Doxyfile","status":"added","additions":1252,"deletions":0,"changes":1252,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/c-doc.Doxyfile","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/c-doc.Doxyfile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/c-doc.Doxyfile?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,1252 @@\n+# Doxyfile 1.4.7\r\n+\r\n+# This file describes the settings to be used by the documentation system\r\n+# doxygen (www.doxygen.org) for a project\r\n+#\r\n+# All text after a hash (#) is considered a comment and will be ignored\r\n+# The format is:\r\n+#       TAG = value [value, ...]\r\n+# For lists items can also be appended using:\r\n+#       TAG += value [value, ...]\r\n+# Values that contain spaces should be placed between quotes (\" \")\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# Project related configuration options\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded \r\n+# by quotes) that should identify the project.\r\n+\r\n+PROJECT_NAME = $(PROJECT)-$(VERSION)\r\n+\r\n+# The PROJECT_NUMBER tag can be used to enter a project or revision number. \r\n+# This could be handy for archiving the generated documentation or \r\n+# if some version control system is used.\r\n+\r\n+PROJECT_NUMBER = \r\n+\r\n+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) \r\n+# base path where the generated documentation will be put. \r\n+# If a relative path is entered, it will be relative to the location \r\n+# where doxygen was started. If left blank the current directory will be used.\r\n+\r\n+OUTPUT_DIRECTORY = $(DOCDIR)\r\n+\r\n+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create \r\n+# 4096 sub-directories (in 2 levels) under the output directory of each output \r\n+# format and will distribute the generated files over these directories. \r\n+# Enabling this option can be useful when feeding doxygen a huge amount of \r\n+# source files, where putting all generated files in the same directory would \r\n+# otherwise cause performance problems for the file system.\r\n+\r\n+CREATE_SUBDIRS = NO\r\n+\r\n+# The OUTPUT_LANGUAGE tag is used to specify the language in which all \r\n+# documentation generated by doxygen is written. Doxygen will use this \r\n+# information to generate all constant output in the proper language. \r\n+# The default language is English, other supported languages are: \r\n+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, \r\n+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, \r\n+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, \r\n+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, \r\n+# Swedish, and Ukrainian.\r\n+\r\n+OUTPUT_LANGUAGE = English\r\n+\r\n+# This tag can be used to specify the encoding used in the generated output. \r\n+# The encoding is not always determined by the language that is chosen, \r\n+# but also whether or not the output is meant for Windows or non-Windows users. \r\n+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES \r\n+# forces the Windows encoding (this is the default for the Windows binary), \r\n+# whereas setting the tag to NO uses a Unix-style encoding (the default for \r\n+# all platforms other than Windows).\r\n+\r\n+USE_WINDOWS_ENCODING = NO\r\n+\r\n+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will \r\n+# include brief member descriptions after the members that are listed in \r\n+# the file and class documentation (similar to JavaDoc). \r\n+# Set to NO to disable this.\r\n+\r\n+BRIEF_MEMBER_DESC = YES\r\n+\r\n+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend \r\n+# the brief description of a member or function before the detailed description. \r\n+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the \r\n+# brief descriptions will be completely suppressed.\r\n+\r\n+REPEAT_BRIEF = YES\r\n+\r\n+# This tag implements a quasi-intelligent brief description abbreviator \r\n+# that is used to form the text in various listings. Each string \r\n+# in this list, if found as the leading text of the brief description, will be \r\n+# stripped from the text and the result after processing the whole list, is \r\n+# used as the annotated text. Otherwise, the brief description is used as-is. \r\n+# If left blank, the following values are used (\"$name\" is automatically \r\n+# replaced with the name of the entity): \"The $name class\" \"The $name widget\" \r\n+# \"The $name file\" \"is\" \"provides\" \"specifies\" \"contains\" \r\n+# \"represents\" \"a\" \"an\" \"the\"\r\n+\r\n+ABBREVIATE_BRIEF = \r\n+\r\n+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then \r\n+# Doxygen will generate a detailed section even if there is only a brief \r\n+# description.\r\n+\r\n+ALWAYS_DETAILED_SEC = NO\r\n+\r\n+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all \r\n+# inherited members of a class in the documentation of that class as if those \r\n+# members were ordinary class members. Constructors, destructors and assignment \r\n+# operators of the base classes will not be shown.\r\n+\r\n+INLINE_INHERITED_MEMB = NO\r\n+\r\n+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full \r\n+# path before files name in the file list and in the header files. If set \r\n+# to NO the shortest path that makes the file name unique will be used.\r\n+\r\n+FULL_PATH_NAMES = YES\r\n+\r\n+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag \r\n+# can be used to strip a user-defined part of the path. Stripping is \r\n+# only done if one of the specified strings matches the left-hand part of \r\n+# the path. The tag can be used to show relative paths in the file list. \r\n+# If left blank the directory from which doxygen is run is used as the \r\n+# path to strip.\r\n+\r\n+STRIP_FROM_PATH = \r\n+\r\n+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of \r\n+# the path mentioned in the documentation of a class, which tells \r\n+# the reader which header file to include in order to use a class. \r\n+# If left blank only the name of the header file containing the class \r\n+# definition is used. Otherwise one should specify the include paths that \r\n+# are normally passed to the compiler using the -I flag.\r\n+\r\n+STRIP_FROM_INC_PATH = \r\n+\r\n+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter \r\n+# (but less readable) file names. This can be useful is your file systems \r\n+# doesn't support long names like on DOS, Mac, or CD-ROM.\r\n+\r\n+SHORT_NAMES = NO\r\n+\r\n+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen \r\n+# will interpret the first line (until the first dot) of a JavaDoc-style \r\n+# comment as the brief description. If set to NO, the JavaDoc \r\n+# comments will behave just like the Qt-style comments (thus requiring an \r\n+# explicit @brief command for a brief description.\r\n+\r\n+JAVADOC_AUTOBRIEF = NO\r\n+\r\n+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen \r\n+# treat a multi-line C++ special comment block (i.e. a block of //! or /// \r\n+# comments) as a brief description. This used to be the default behaviour. \r\n+# The new default is to treat a multi-line C++ comment block as a detailed \r\n+# description. Set this tag to YES if you prefer the old behaviour instead.\r\n+\r\n+MULTILINE_CPP_IS_BRIEF = NO\r\n+\r\n+# If the DETAILS_AT_TOP tag is set to YES then Doxygen \r\n+# will output the detailed description near the top, like JavaDoc.\r\n+# If set to NO, the detailed description appears after the member \r\n+# documentation.\r\n+\r\n+DETAILS_AT_TOP = NO\r\n+\r\n+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented \r\n+# member inherits the documentation from any documented member that it \r\n+# re-implements.\r\n+\r\n+INHERIT_DOCS = YES\r\n+\r\n+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce \r\n+# a new page for each member. If set to NO, the documentation of a member will \r\n+# be part of the file/class/namespace that contains it.\r\n+\r\n+SEPARATE_MEMBER_PAGES = NO\r\n+\r\n+# The TAB_SIZE tag can be used to set the number of spaces in a tab. \r\n+# Doxygen uses this value to replace tabs by spaces in code fragments.\r\n+\r\n+TAB_SIZE = 8\r\n+\r\n+# This tag can be used to specify a number of aliases that acts \r\n+# as commands in the documentation. An alias has the form \"name=value\". \r\n+# For example adding \"sideeffect=\\par Side Effects:\\n\" will allow you to \r\n+# put the command \\sideeffect (or @sideeffect) in the documentation, which \r\n+# will result in a user-defined paragraph with heading \"Side Effects:\". \r\n+# You can put \\n's in the value part of an alias to insert newlines.\r\n+\r\n+ALIASES = \r\n+\r\n+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C \r\n+# sources only. Doxygen will then generate output that is more tailored for C. \r\n+# For instance, some of the names that are used will be different. The list \r\n+# of all members will be omitted, etc.\r\n+\r\n+OPTIMIZE_OUTPUT_FOR_C = YES\r\n+\r\n+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java \r\n+# sources only. Doxygen will then generate output that is more tailored for Java. \r\n+# For instance, namespaces will be presented as packages, qualified scopes \r\n+# will look different, etc.\r\n+\r\n+OPTIMIZE_OUTPUT_JAVA = NO\r\n+\r\n+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to \r\n+# include (a tag file for) the STL sources as input, then you should \r\n+# set this tag to YES in order to let doxygen match functions declarations and \r\n+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. \r\n+# func(std::string) {}). This also make the inheritance and collaboration \r\n+# diagrams that involve STL classes more complete and accurate.\r\n+\r\n+BUILTIN_STL_SUPPORT = NO\r\n+\r\n+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC \r\n+# tag is set to YES, then doxygen will reuse the documentation of the first \r\n+# member in the group (if any) for the other members of the group. By default \r\n+# all members of a group must be documented explicitly.\r\n+\r\n+DISTRIBUTE_GROUP_DOC = NO\r\n+\r\n+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of \r\n+# the same type (for instance a group of public functions) to be put as a \r\n+# subgroup of that type (e.g. under the Public Functions section). Set it to \r\n+# NO to prevent subgrouping. Alternatively, this can be done per class using \r\n+# the \\nosubgrouping command.\r\n+\r\n+SUBGROUPING = YES\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# Build related configuration options\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in \r\n+# documentation are documented, even if no documentation was available. \r\n+# Private class members and static file members will be hidden unless \r\n+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES\r\n+\r\n+EXTRACT_ALL = NO\r\n+\r\n+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class \r\n+# will be included in the documentation.\r\n+\r\n+EXTRACT_PRIVATE = NO\r\n+\r\n+# If the EXTRACT_STATIC tag is set to YES all static members of a file \r\n+# will be included in the documentation.\r\n+\r\n+EXTRACT_STATIC = YES\r\n+\r\n+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) \r\n+# defined locally in source files will be included in the documentation. \r\n+# If set to NO only classes defined in header files are included.\r\n+\r\n+EXTRACT_LOCAL_CLASSES = YES\r\n+\r\n+# This flag is only useful for Objective-C code. When set to YES local \r\n+# methods, which are defined in the implementation section but not in \r\n+# the interface are included in the documentation. \r\n+# If set to NO (the default) only methods in the interface are included.\r\n+\r\n+EXTRACT_LOCAL_METHODS = NO\r\n+\r\n+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all \r\n+# undocumented members of documented classes, files or namespaces. \r\n+# If set to NO (the default) these members will be included in the \r\n+# various overviews, but no documentation section is generated. \r\n+# This option has no effect if EXTRACT_ALL is enabled.\r\n+\r\n+HIDE_UNDOC_MEMBERS = NO\r\n+\r\n+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all \r\n+# undocumented classes that are normally visible in the class hierarchy. \r\n+# If set to NO (the default) these classes will be included in the various \r\n+# overviews. This option has no effect if EXTRACT_ALL is enabled.\r\n+\r\n+HIDE_UNDOC_CLASSES = NO\r\n+\r\n+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all \r\n+# friend (class|struct|union) declarations. \r\n+# If set to NO (the default) these declarations will be included in the \r\n+# documentation.\r\n+\r\n+HIDE_FRIEND_COMPOUNDS = NO\r\n+\r\n+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any \r\n+# documentation blocks found inside the body of a function. \r\n+# If set to NO (the default) these blocks will be appended to the \r\n+# function's detailed documentation block.\r\n+\r\n+HIDE_IN_BODY_DOCS = NO\r\n+\r\n+# The INTERNAL_DOCS tag determines if documentation \r\n+# that is typed after a \\internal command is included. If the tag is set \r\n+# to NO (the default) then the documentation will be excluded. \r\n+# Set it to YES to include the internal documentation.\r\n+\r\n+INTERNAL_DOCS = NO\r\n+\r\n+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate \r\n+# file names in lower-case letters. If set to YES upper-case letters are also \r\n+# allowed. This is useful if you have classes or files whose names only differ \r\n+# in case and if your file system supports case sensitive file names. Windows \r\n+# and Mac users are advised to set this option to NO.\r\n+\r\n+CASE_SENSE_NAMES = YES\r\n+\r\n+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen \r\n+# will show members with their full class and namespace scopes in the \r\n+# documentation. If set to YES the scope will be hidden.\r\n+\r\n+HIDE_SCOPE_NAMES = NO\r\n+\r\n+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen \r\n+# will put a list of the files that are included by a file in the documentation \r\n+# of that file.\r\n+\r\n+SHOW_INCLUDE_FILES = NO\r\n+\r\n+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] \r\n+# is inserted in the documentation for inline members.\r\n+\r\n+INLINE_INFO = YES\r\n+\r\n+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen \r\n+# will sort the (detailed) documentation of file and class members \r\n+# alphabetically by member name. If set to NO the members will appear in \r\n+# declaration order.\r\n+\r\n+SORT_MEMBER_DOCS = YES\r\n+\r\n+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the \r\n+# brief documentation of file, namespace and class members alphabetically \r\n+# by member name. If set to NO (the default) the members will appear in \r\n+# declaration order.\r\n+\r\n+SORT_BRIEF_DOCS = NO\r\n+\r\n+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be \r\n+# sorted by fully-qualified names, including namespaces. If set to \r\n+# NO (the default), the class list will be sorted only by class name, \r\n+# not including the namespace part. \r\n+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.\r\n+# Note: This option applies only to the class list, not to the \r\n+# alphabetical list.\r\n+\r\n+SORT_BY_SCOPE_NAME = NO\r\n+\r\n+# The GENERATE_TODOLIST tag can be used to enable (YES) or \r\n+# disable (NO) the todo list. This list is created by putting \\todo \r\n+# commands in the documentation.\r\n+\r\n+GENERATE_TODOLIST = YES\r\n+\r\n+# The GENERATE_TESTLIST tag can be used to enable (YES) or \r\n+# disable (NO) the test list. This list is created by putting \\test \r\n+# commands in the documentation.\r\n+\r\n+GENERATE_TESTLIST = YES\r\n+\r\n+# The GENERATE_BUGLIST tag can be used to enable (YES) or \r\n+# disable (NO) the bug list. This list is created by putting \\bug \r\n+# commands in the documentation.\r\n+\r\n+GENERATE_BUGLIST = YES\r\n+\r\n+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or \r\n+# disable (NO) the deprecated list. This list is created by putting \r\n+# \\deprecated commands in the documentation.\r\n+\r\n+GENERATE_DEPRECATEDLIST = YES\r\n+\r\n+# The ENABLED_SECTIONS tag can be used to enable conditional \r\n+# documentation sections, marked by \\if sectionname ... \\endif.\r\n+\r\n+ENABLED_SECTIONS = \r\n+\r\n+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines \r\n+# the initial value of a variable or define consists of for it to appear in \r\n+# the documentation. If the initializer consists of more lines than specified \r\n+# here it will be hidden. Use a value of 0 to hide initializers completely. \r\n+# The appearance of the initializer of individual variables and defines in the \r\n+# documentation can be controlled using \\showinitializer or \\hideinitializer \r\n+# command in the documentation regardless of this setting.\r\n+\r\n+MAX_INITIALIZER_LINES = 30\r\n+\r\n+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated \r\n+# at the bottom of the documentation of classes and structs. If set to YES the \r\n+# list will mention the files that were used to generate the documentation.\r\n+\r\n+SHOW_USED_FILES = YES\r\n+\r\n+# If the sources in your project are distributed over multiple directories \r\n+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy \r\n+# in the documentation. The default is NO.\r\n+\r\n+SHOW_DIRECTORIES = NO\r\n+\r\n+# The FILE_VERSION_FILTER tag can be used to specify a program or script that \r\n+# doxygen should invoke to get the current version for each file (typically from the \r\n+# version control system). Doxygen will invoke the program by executing (via \r\n+# popen()) the command <command> <input-file>, where <command> is the value of \r\n+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file \r\n+# provided by doxygen. Whatever the program writes to standard output \r\n+# is used as the file version. See the manual for examples.\r\n+\r\n+FILE_VERSION_FILTER = \r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to warning and progress messages\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# The QUIET tag can be used to turn on/off the messages that are generated \r\n+# by doxygen. Possible values are YES and NO. If left blank NO is used.\r\n+\r\n+QUIET = NO\r\n+\r\n+# The WARNINGS tag can be used to turn on/off the warning messages that are \r\n+# generated by doxygen. Possible values are YES and NO. If left blank \r\n+# NO is used.\r\n+\r\n+WARNINGS = YES\r\n+\r\n+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings \r\n+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will \r\n+# automatically be disabled.\r\n+\r\n+WARN_IF_UNDOCUMENTED = YES\r\n+\r\n+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for \r\n+# potential errors in the documentation, such as not documenting some \r\n+# parameters in a documented function, or documenting parameters that \r\n+# don't exist or using markup commands wrongly.\r\n+\r\n+WARN_IF_DOC_ERROR = YES\r\n+\r\n+# This WARN_NO_PARAMDOC option can be abled to get warnings for \r\n+# functions that are documented, but have no documentation for their parameters \r\n+# or return value. If set to NO (the default) doxygen will only warn about \r\n+# wrong or incomplete parameter documentation, but not about the absence of \r\n+# documentation.\r\n+\r\n+WARN_NO_PARAMDOC = NO\r\n+\r\n+# The WARN_FORMAT tag determines the format of the warning messages that \r\n+# doxygen can produce. The string should contain the $file, $line, and $text \r\n+# tags, which will be replaced by the file and line number from which the \r\n+# warning originated and the warning text. Optionally the format may contain \r\n+# $version, which will be replaced by the version of the file (if it could \r\n+# be obtained via FILE_VERSION_FILTER)\r\n+\r\n+WARN_FORMAT = \"$file:$line: $text\"\r\n+\r\n+# The WARN_LOGFILE tag can be used to specify a file to which warning \r\n+# and error messages should be written. If left blank the output is written \r\n+# to stderr.\r\n+\r\n+WARN_LOGFILE = \r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the input files\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# The INPUT tag can be used to specify the files and/or directories that contain \r\n+# documented source files. You may enter file names like \"myfile.cpp\" or \r\n+# directories like \"/usr/src/myproject\". Separate the files or directories \r\n+# with spaces.\r\n+\r\n+INPUT = inc/ lib/\r\n+\r\n+# If the value of the INPUT tag contains directories, you can use the \r\n+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp \r\n+# and *.h) to filter out the source-files in the directories. If left \r\n+# blank the following patterns are tested: \r\n+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx \r\n+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py\r\n+\r\n+FILE_PATTERNS = \r\n+\r\n+# The RECURSIVE tag can be used to turn specify whether or not subdirectories \r\n+# should be searched for input files as well. Possible values are YES and NO. \r\n+# If left blank NO is used.\r\n+\r\n+RECURSIVE = NO\r\n+\r\n+# The EXCLUDE tag can be used to specify files and/or directories that should \r\n+# excluded from the INPUT source files. This way you can easily exclude a \r\n+# subdirectory from a directory tree whose root is specified with the INPUT tag.\r\n+\r\n+EXCLUDE = \r\n+\r\n+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or \r\n+# directories that are symbolic links (a Unix filesystem feature) are excluded \r\n+# from the input.\r\n+\r\n+EXCLUDE_SYMLINKS = NO\r\n+\r\n+# If the value of the INPUT tag contains directories, you can use the \r\n+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude \r\n+# certain files from those directories. Note that the wildcards are matched \r\n+# against the file with absolute path, so to exclude all test directories \r\n+# for example use the pattern */test/*\r\n+\r\n+EXCLUDE_PATTERNS = \r\n+\r\n+# The EXAMPLE_PATH tag can be used to specify one or more files or \r\n+# directories that contain example code fragments that are included (see \r\n+# the \\include command).\r\n+\r\n+EXAMPLE_PATH = \r\n+\r\n+# If the value of the EXAMPLE_PATH tag contains directories, you can use the \r\n+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp \r\n+# and *.h) to filter out the source-files in the directories. If left \r\n+# blank all files are included.\r\n+\r\n+EXAMPLE_PATTERNS = \r\n+\r\n+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be \r\n+# searched for input files to be used with the \\include or \\dontinclude \r\n+# commands irrespective of the value of the RECURSIVE tag. \r\n+# Possible values are YES and NO. If left blank NO is used.\r\n+\r\n+EXAMPLE_RECURSIVE = NO\r\n+\r\n+# The IMAGE_PATH tag can be used to specify one or more files or \r\n+# directories that contain image that are included in the documentation (see \r\n+# the \\image command).\r\n+\r\n+IMAGE_PATH = \r\n+\r\n+# The INPUT_FILTER tag can be used to specify a program that doxygen should \r\n+# invoke to filter for each input file. Doxygen will invoke the filter program \r\n+# by executing (via popen()) the command <filter> <input-file>, where <filter> \r\n+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an \r\n+# input file. Doxygen will then use the output that the filter program writes \r\n+# to standard output.  If FILTER_PATTERNS is specified, this tag will be \r\n+# ignored.\r\n+\r\n+INPUT_FILTER = \r\n+\r\n+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern \r\n+# basis.  Doxygen will compare the file name with each pattern and apply the \r\n+# filter if there is a match.  The filters are a list of the form: \r\n+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further \r\n+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER \r\n+# is applied to all files.\r\n+\r\n+FILTER_PATTERNS = \r\n+\r\n+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using \r\n+# INPUT_FILTER) will be used to filter the input files when producing source \r\n+# files to browse (i.e. when SOURCE_BROWSER is set to YES).\r\n+\r\n+FILTER_SOURCE_FILES = NO\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to source browsing\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the SOURCE_BROWSER tag is set to YES then a list of source files will \r\n+# be generated. Documented entities will be cross-referenced with these sources. \r\n+# Note: To get rid of all source code in the generated output, make sure also \r\n+# VERBATIM_HEADERS is set to NO.\r\n+\r\n+SOURCE_BROWSER = NO\r\n+\r\n+# Setting the INLINE_SOURCES tag to YES will include the body \r\n+# of functions and classes directly in the documentation.\r\n+\r\n+INLINE_SOURCES = NO\r\n+\r\n+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct \r\n+# doxygen to hide any special comment blocks from generated source code \r\n+# fragments. Normal C and C++ comments will always remain visible.\r\n+\r\n+STRIP_CODE_COMMENTS = YES\r\n+\r\n+# If the REFERENCED_BY_RELATION tag is set to YES (the default) \r\n+# then for each documented function all documented \r\n+# functions referencing it will be listed.\r\n+\r\n+REFERENCED_BY_RELATION = YES\r\n+\r\n+# If the REFERENCES_RELATION tag is set to YES (the default) \r\n+# then for each documented function all documented entities \r\n+# called/used by that function will be listed.\r\n+\r\n+REFERENCES_RELATION = YES\r\n+\r\n+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)\r\n+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from\r\n+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will\r\n+# link to the source code.  Otherwise they will link to the documentstion.\r\n+\r\n+REFERENCES_LINK_SOURCE = YES\r\n+\r\n+# If the USE_HTAGS tag is set to YES then the references to source code \r\n+# will point to the HTML generated by the htags(1) tool instead of doxygen \r\n+# built-in source browser. The htags tool is part of GNU's global source \r\n+# tagging system (see http://www.gnu.org/software/global/global.html). You \r\n+# will need version 4.8.6 or higher.\r\n+\r\n+USE_HTAGS = NO\r\n+\r\n+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen \r\n+# will generate a verbatim copy of the header file for each class for \r\n+# which an include is specified. Set to NO to disable this.\r\n+\r\n+VERBATIM_HEADERS = YES\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the alphabetical class index\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index \r\n+# of all compounds will be generated. Enable this if the project \r\n+# contains a lot of classes, structs, unions or interfaces.\r\n+\r\n+ALPHABETICAL_INDEX = NO\r\n+\r\n+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then \r\n+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns \r\n+# in which this list will be split (can be a number in the range [1..20])\r\n+\r\n+COLS_IN_ALPHA_INDEX = 5\r\n+\r\n+# In case all classes in a project start with a common prefix, all \r\n+# classes will be put under the same header in the alphabetical index. \r\n+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that \r\n+# should be ignored while generating the index headers.\r\n+\r\n+IGNORE_PREFIX = \r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the HTML output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will \r\n+# generate HTML output.\r\n+\r\n+GENERATE_HTML = $(GENERATE_HTML)\r\n+\r\n+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. \r\n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \r\n+# put in front of it. If left blank `html' will be used as the default path.\r\n+\r\n+HTML_OUTPUT = html\r\n+\r\n+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for \r\n+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank \r\n+# doxygen will generate files with .html extension.\r\n+\r\n+HTML_FILE_EXTENSION = .html\r\n+\r\n+# The HTML_HEADER tag can be used to specify a personal HTML header for \r\n+# each generated HTML page. If it is left blank doxygen will generate a \r\n+# standard header.\r\n+\r\n+HTML_HEADER = \r\n+\r\n+# The HTML_FOOTER tag can be used to specify a personal HTML footer for \r\n+# each generated HTML page. If it is left blank doxygen will generate a \r\n+# standard footer.\r\n+\r\n+HTML_FOOTER = \r\n+\r\n+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading \r\n+# style sheet that is used by each HTML page. It can be used to \r\n+# fine-tune the look of the HTML output. If the tag is left blank doxygen \r\n+# will generate a default style sheet. Note that doxygen will try to copy \r\n+# the style sheet file to the HTML output directory, so don't put your own \r\n+# stylesheet in the HTML output directory as well, or it will be erased!\r\n+\r\n+HTML_STYLESHEET = \r\n+\r\n+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, \r\n+# files or namespaces will be aligned in HTML using tables. If set to \r\n+# NO a bullet list will be used.\r\n+\r\n+HTML_ALIGN_MEMBERS = YES\r\n+\r\n+# If the GENERATE_HTMLHELP tag is set to YES, additional index files \r\n+# will be generated that can be used as input for tools like the \r\n+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) \r\n+# of the generated HTML documentation.\r\n+\r\n+GENERATE_HTMLHELP = $(GENERATE_HTMLHELP)\r\n+\r\n+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can \r\n+# be used to specify the file name of the resulting .chm file. You \r\n+# can add a path in front of the file if the result should not be \r\n+# written to the html output directory.\r\n+\r\n+CHM_FILE = ../$(PROJECT).chm\r\n+\r\n+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can \r\n+# be used to specify the location (absolute path including file name) of \r\n+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run \r\n+# the HTML help compiler on the generated index.hhp.\r\n+\r\n+HHC_LOCATION = $(HHC_PATH)\r\n+\r\n+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag \r\n+# controls if a separate .chi index file is generated (YES) or that \r\n+# it should be included in the master .chm file (NO).\r\n+\r\n+GENERATE_CHI = $(GENERATE_CHI)\r\n+\r\n+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag \r\n+# controls whether a binary table of contents is generated (YES) or a \r\n+# normal table of contents (NO) in the .chm file.\r\n+\r\n+BINARY_TOC = NO\r\n+\r\n+# The TOC_EXPAND flag can be set to YES to add extra items for group members \r\n+# to the contents of the HTML help documentation and to the tree view.\r\n+\r\n+TOC_EXPAND = NO\r\n+\r\n+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at \r\n+# top of each HTML page. The value NO (the default) enables the index and \r\n+# the value YES disables it.\r\n+\r\n+DISABLE_INDEX = NO\r\n+\r\n+# This tag can be used to set the number of enum values (range [1..20]) \r\n+# that doxygen will group on one line in the generated HTML documentation.\r\n+\r\n+ENUM_VALUES_PER_LINE = 4\r\n+\r\n+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be\r\n+# generated containing a tree-like index structure (just like the one that \r\n+# is generated for HTML Help). For this to work a browser that supports \r\n+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, \r\n+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are \r\n+# probably better off using the HTML help feature.\r\n+\r\n+GENERATE_TREEVIEW = NO\r\n+\r\n+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be \r\n+# used to set the initial width (in pixels) of the frame in which the tree \r\n+# is shown.\r\n+\r\n+TREEVIEW_WIDTH = 250\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the LaTeX output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will \r\n+# generate Latex output.\r\n+\r\n+GENERATE_LATEX = $(GENERATE_LATEX)\r\n+\r\n+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. \r\n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \r\n+# put in front of it. If left blank `latex' will be used as the default path.\r\n+\r\n+LATEX_OUTPUT = latex\r\n+\r\n+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be \r\n+# invoked. If left blank `latex' will be used as the default command name.\r\n+\r\n+LATEX_CMD_NAME = latex\r\n+\r\n+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to \r\n+# generate index for LaTeX. If left blank `makeindex' will be used as the \r\n+# default command name.\r\n+\r\n+MAKEINDEX_CMD_NAME = makeindex\r\n+\r\n+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact \r\n+# LaTeX documents. This may be useful for small projects and may help to \r\n+# save some trees in general.\r\n+\r\n+COMPACT_LATEX = NO\r\n+\r\n+# The PAPER_TYPE tag can be used to set the paper type that is used \r\n+# by the printer. Possible values are: a4, a4wide, letter, legal and \r\n+# executive. If left blank a4wide will be used.\r\n+\r\n+PAPER_TYPE = $(PAPER_SIZE)\r\n+\r\n+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX \r\n+# packages that should be included in the LaTeX output.\r\n+\r\n+EXTRA_PACKAGES = \r\n+\r\n+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for \r\n+# the generated latex document. The header should contain everything until \r\n+# the first chapter. If it is left blank doxygen will generate a \r\n+# standard header. Notice: only use this tag if you know what you are doing!\r\n+\r\n+LATEX_HEADER = \r\n+\r\n+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated \r\n+# is prepared for conversion to pdf (using ps2pdf). The pdf file will \r\n+# contain links (just like the HTML output) instead of page references \r\n+# This makes the output suitable for online browsing using a pdf viewer.\r\n+\r\n+PDF_HYPERLINKS = NO\r\n+\r\n+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of \r\n+# plain latex in the generated Makefile. Set this option to YES to get a \r\n+# higher quality PDF documentation.\r\n+\r\n+USE_PDFLATEX = $(GENERATE_PDF)\r\n+\r\n+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\\\batchmode. \r\n+# command to the generated LaTeX files. This will instruct LaTeX to keep \r\n+# running if errors occur, instead of asking the user for help. \r\n+# This option is also used when generating formulas in HTML.\r\n+\r\n+LATEX_BATCHMODE = NO\r\n+\r\n+# If LATEX_HIDE_INDICES is set to YES then doxygen will not \r\n+# include the index chapters (such as File Index, Compound Index, etc.) \r\n+# in the output.\r\n+\r\n+LATEX_HIDE_INDICES = NO\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the RTF output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output \r\n+# The RTF output is optimized for Word 97 and may not look very pretty with \r\n+# other RTF readers or editors.\r\n+\r\n+GENERATE_RTF = $(GENERATE_RTF)\r\n+\r\n+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. \r\n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \r\n+# put in front of it. If left blank `rtf' will be used as the default path.\r\n+\r\n+RTF_OUTPUT = rtf\r\n+\r\n+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact \r\n+# RTF documents. This may be useful for small projects and may help to \r\n+# save some trees in general.\r\n+\r\n+COMPACT_RTF = NO\r\n+\r\n+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated \r\n+# will contain hyperlink fields. The RTF file will \r\n+# contain links (just like the HTML output) instead of page references. \r\n+# This makes the output suitable for online browsing using WORD or other \r\n+# programs which support those fields. \r\n+# Note: wordpad (write) and others do not support links.\r\n+\r\n+RTF_HYPERLINKS = NO\r\n+\r\n+# Load stylesheet definitions from file. Syntax is similar to doxygen's \r\n+# config file, i.e. a series of assignments. You only have to provide \r\n+# replacements, missing definitions are set to their default value.\r\n+\r\n+RTF_STYLESHEET_FILE = \r\n+\r\n+# Set optional variables used in the generation of an rtf document. \r\n+# Syntax is similar to doxygen's config file.\r\n+\r\n+RTF_EXTENSIONS_FILE = \r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the man page output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will \r\n+# generate man pages\r\n+\r\n+GENERATE_MAN = $(GENERATE_MAN)\r\n+\r\n+# The MAN_OUTPUT tag is used to specify where the man pages will be put. \r\n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \r\n+# put in front of it. If left blank `man' will be used as the default path.\r\n+\r\n+MAN_OUTPUT = man\r\n+\r\n+# The MAN_EXTENSION tag determines the extension that is added to \r\n+# the generated man pages (default is the subroutine's section .3)\r\n+\r\n+MAN_EXTENSION = .3\r\n+\r\n+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, \r\n+# then it will generate one additional man file for each entity \r\n+# documented in the real man page(s). These additional files \r\n+# only source the real man page, but without them the man command \r\n+# would be unable to find the correct page. The default is NO.\r\n+\r\n+MAN_LINKS = NO\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the XML output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_XML tag is set to YES Doxygen will \r\n+# generate an XML file that captures the structure of \r\n+# the code including all documentation.\r\n+\r\n+GENERATE_XML = $(GENERATE_XML)\r\n+\r\n+# The XML_OUTPUT tag is used to specify where the XML pages will be put. \r\n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \r\n+# put in front of it. If left blank `xml' will be used as the default path.\r\n+\r\n+XML_OUTPUT = xml\r\n+\r\n+# The XML_SCHEMA tag can be used to specify an XML schema, \r\n+# which can be used by a validating XML parser to check the \r\n+# syntax of the XML files.\r\n+\r\n+XML_SCHEMA = \r\n+\r\n+# The XML_DTD tag can be used to specify an XML DTD, \r\n+# which can be used by a validating XML parser to check the \r\n+# syntax of the XML files.\r\n+\r\n+XML_DTD = \r\n+\r\n+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will \r\n+# dump the program listings (including syntax highlighting \r\n+# and cross-referencing information) to the XML output. Note that \r\n+# enabling this will significantly increase the size of the XML output.\r\n+\r\n+XML_PROGRAMLISTING = YES\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options for the AutoGen Definitions output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will \r\n+# generate an AutoGen Definitions (see autogen.sf.net) file \r\n+# that captures the structure of the code including all \r\n+# documentation. Note that this feature is still experimental \r\n+# and incomplete at the moment.\r\n+\r\n+GENERATE_AUTOGEN_DEF = NO\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# configuration options related to the Perl module output\r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the GENERATE_PERLMOD tag is set to YES Doxygen will \r\n+# generate a Perl module file that captures the structure of \r\n+# the code including all documentation. Note that this \r\n+# feature is still experimental and incomplete at the \r\n+# moment.\r\n+\r\n+GENERATE_PERLMOD = NO\r\n+\r\n+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate \r\n+# the necessary Makefile rules, Perl scripts and LaTeX code to be able \r\n+# to generate PDF and DVI output from the Perl module output.\r\n+\r\n+PERLMOD_LATEX = NO\r\n+\r\n+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be \r\n+# nicely formatted so it can be parsed by a human reader.  This is useful \r\n+# if you want to understand what is going on.  On the other hand, if this \r\n+# tag is set to NO the size of the Perl module output will be much smaller \r\n+# and Perl will parse it just the same.\r\n+\r\n+PERLMOD_PRETTY = YES\r\n+\r\n+# The names of the make variables in the generated doxyrules.make file \r\n+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. \r\n+# This is useful so different doxyrules.make files included by the same \r\n+# Makefile don't overwrite each other's variables.\r\n+\r\n+PERLMOD_MAKEVAR_PREFIX = \r\n+\r\n+#---------------------------------------------------------------------------\r\n+# Configuration options related to the preprocessor   \r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will \r\n+# evaluate all C-preprocessor directives found in the sources and include \r\n+# files.\r\n+\r\n+ENABLE_PREPROCESSING = YES\r\n+\r\n+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro \r\n+# names in the source code. If set to NO (the default) only conditional \r\n+# compilation will be performed. Macro expansion can be done in a controlled \r\n+# way by setting EXPAND_ONLY_PREDEF to YES.\r\n+\r\n+MACRO_EXPANSION = NO\r\n+\r\n+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES \r\n+# then the macro expansion is limited to the macros specified with the \r\n+# PREDEFINED and EXPAND_AS_DEFINED tags.\r\n+\r\n+EXPAND_ONLY_PREDEF = NO\r\n+\r\n+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files \r\n+# in the INCLUDE_PATH (see below) will be search if a #include is found.\r\n+\r\n+SEARCH_INCLUDES = YES\r\n+\r\n+# The INCLUDE_PATH tag can be used to specify one or more directories that \r\n+# contain include files that are not input files but should be processed by \r\n+# the preprocessor.\r\n+\r\n+INCLUDE_PATH = \r\n+\r\n+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard \r\n+# patterns (like *.h and *.hpp) to filter out the header-files in the \r\n+# directories. If left blank, the patterns specified with FILE_PATTERNS will \r\n+# be used.\r\n+\r\n+INCLUDE_FILE_PATTERNS = \r\n+\r\n+# The PREDEFINED tag can be used to specify one or more macro names that \r\n+# are defined before the preprocessor is started (similar to the -D option of \r\n+# gcc). The argument of the tag is a list of macros of the form: name \r\n+# or name=definition (no spaces). If the definition and the = are \r\n+# omitted =1 is assumed. To prevent a macro definition from being \r\n+# undefined via #undef or recursively expanded use the := operator \r\n+# instead of the = operator.\r\n+\r\n+PREDEFINED = \r\n+\r\n+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then \r\n+# this tag can be used to specify a list of macro names that should be expanded. \r\n+# The macro definition that is found in the sources will be used. \r\n+# Use the PREDEFINED tag if you want to use a different macro definition.\r\n+\r\n+EXPAND_AS_DEFINED = \r\n+\r\n+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then \r\n+# doxygen's preprocessor will remove all function-like macros that are alone \r\n+# on a line, have an all uppercase name, and do not end with a semicolon. Such \r\n+# function macros are typically used for boiler-plate code, and will confuse \r\n+# the parser if not removed.\r\n+\r\n+SKIP_FUNCTION_MACROS = YES\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# Configuration::additions related to external references   \r\n+#---------------------------------------------------------------------------\r\n+\r\n+# The TAGFILES option can be used to specify one or more tagfiles. \r\n+# Optionally an initial location of the external documentation \r\n+# can be added for each tagfile. The format of a tag file without \r\n+# this location is as follows: \r\n+#   TAGFILES = file1 file2 ... \r\n+# Adding location for the tag files is done as follows: \r\n+#   TAGFILES = file1=loc1 \"file2 = loc2\" ... \r\n+# where \"loc1\" and \"loc2\" can be relative or absolute paths or \r\n+# URLs. If a location is present for each tag, the installdox tool \r\n+# does not have to be run to correct the links.\r\n+# Note that each tag file must have a unique name\r\n+# (where the name does NOT include the path)\r\n+# If a tag file is not located in the directory in which doxygen \r\n+# is run, you must also specify the path to the tagfile here.\r\n+\r\n+TAGFILES = \r\n+\r\n+# When a file name is specified after GENERATE_TAGFILE, doxygen will create \r\n+# a tag file that is based on the input files it reads.\r\n+\r\n+GENERATE_TAGFILE = $(DOCDIR)/$(PROJECT).tag\r\n+\r\n+# If the ALLEXTERNALS tag is set to YES all external classes will be listed \r\n+# in the class index. If set to NO only the inherited external classes \r\n+# will be listed.\r\n+\r\n+ALLEXTERNALS = NO\r\n+\r\n+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed \r\n+# in the modules index. If set to NO, only the current project's groups will \r\n+# be listed.\r\n+\r\n+EXTERNAL_GROUPS = YES\r\n+\r\n+# The PERL_PATH should be the absolute path and name of the perl script \r\n+# interpreter (i.e. the result of `which perl').\r\n+\r\n+PERL_PATH = /usr/bin/perl\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# Configuration options related to the dot tool   \r\n+#---------------------------------------------------------------------------\r\n+\r\n+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will \r\n+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base \r\n+# or super classes. Setting the tag to NO turns the diagrams off. Note that \r\n+# this option is superseded by the HAVE_DOT option below. This is only a \r\n+# fallback. It is recommended to install and use dot, since it yields more \r\n+# powerful graphs.\r\n+\r\n+CLASS_DIAGRAMS = YES\r\n+\r\n+# If set to YES, the inheritance and collaboration graphs will hide \r\n+# inheritance and usage relations if the target is undocumented \r\n+# or is not a class.\r\n+\r\n+HIDE_UNDOC_RELATIONS = YES\r\n+\r\n+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is \r\n+# available from the path. This tool is part of Graphviz, a graph visualization \r\n+# toolkit from AT&T and Lucent Bell Labs. The other options in this section \r\n+# have no effect if this option is set to NO (the default)\r\n+\r\n+HAVE_DOT = $(HAVE_DOT)\r\n+\r\n+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen \r\n+# will generate a graph for each documented class showing the direct and \r\n+# indirect inheritance relations. Setting this tag to YES will force the \r\n+# the CLASS_DIAGRAMS tag to NO.\r\n+\r\n+CLASS_GRAPH = YES\r\n+\r\n+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen \r\n+# will generate a graph for each documented class showing the direct and \r\n+# indirect implementation dependencies (inheritance, containment, and \r\n+# class references variables) of the class with other documented classes.\r\n+\r\n+COLLABORATION_GRAPH = YES\r\n+\r\n+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen \r\n+# will generate a graph for groups, showing the direct groups dependencies\r\n+\r\n+GROUP_GRAPHS = YES\r\n+\r\n+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and \r\n+# collaboration diagrams in a style similar to the OMG's Unified Modeling \r\n+# Language.\r\n+\r\n+UML_LOOK = NO\r\n+\r\n+# If set to YES, the inheritance and collaboration graphs will show the \r\n+# relations between templates and their instances.\r\n+\r\n+TEMPLATE_RELATIONS = NO\r\n+\r\n+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT \r\n+# tags are set to YES then doxygen will generate a graph for each documented \r\n+# file showing the direct and indirect include dependencies of the file with \r\n+# other documented files.\r\n+\r\n+INCLUDE_GRAPH = YES\r\n+\r\n+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and \r\n+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each \r\n+# documented header file showing the documented files that directly or \r\n+# indirectly include this file.\r\n+\r\n+INCLUDED_BY_GRAPH = YES\r\n+\r\n+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will \r\n+# generate a call dependency graph for every global function or class method. \r\n+# Note that enabling this option will significantly increase the time of a run. \r\n+# So in most cases it will be better to enable call graphs for selected \r\n+# functions only using the \\callgraph command.\r\n+\r\n+CALL_GRAPH = NO\r\n+\r\n+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then doxygen will \r\n+# generate a caller dependency graph for every global function or class method. \r\n+# Note that enabling this option will significantly increase the time of a run. \r\n+# So in most cases it will be better to enable caller graphs for selected \r\n+# functions only using the \\callergraph command.\r\n+\r\n+CALLER_GRAPH = NO\r\n+\r\n+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen \r\n+# will graphical hierarchy of all classes instead of a textual one.\r\n+\r\n+GRAPHICAL_HIERARCHY = YES\r\n+\r\n+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES \r\n+# then doxygen will show the dependencies a directory has on other directories \r\n+# in a graphical way. The dependency relations are determined by the #include\r\n+# relations between the files in the directories.\r\n+\r\n+DIRECTORY_GRAPH = YES\r\n+\r\n+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images \r\n+# generated by dot. Possible values are png, jpg, or gif\r\n+# If left blank png will be used.\r\n+\r\n+DOT_IMAGE_FORMAT = png\r\n+\r\n+# The tag DOT_PATH can be used to specify the path where the dot tool can be \r\n+# found. If left blank, it is assumed the dot tool can be found in the path.\r\n+\r\n+DOT_PATH = $(DOT_PATH)\r\n+\r\n+# The DOTFILE_DIRS tag can be used to specify one or more directories that \r\n+# contain dot files that are included in the documentation (see the \r\n+# \\dotfile command).\r\n+\r\n+DOTFILE_DIRS = \r\n+\r\n+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width \r\n+# (in pixels) of the graphs generated by dot. If a graph becomes larger than \r\n+# this value, doxygen will try to truncate the graph, so that it fits within \r\n+# the specified constraint. Beware that most browsers cannot cope with very \r\n+# large images.\r\n+\r\n+MAX_DOT_GRAPH_WIDTH = 1024\r\n+\r\n+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height \r\n+# (in pixels) of the graphs generated by dot. If a graph becomes larger than \r\n+# this value, doxygen will try to truncate the graph, so that it fits within \r\n+# the specified constraint. Beware that most browsers cannot cope with very \r\n+# large images.\r\n+\r\n+MAX_DOT_GRAPH_HEIGHT = 1024\r\n+\r\n+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the \r\n+# graphs generated by dot. A depth value of 3 means that only nodes reachable \r\n+# from the root by following a path via at most 3 edges will be shown. Nodes \r\n+# that lay further from the root node will be omitted. Note that setting this \r\n+# option to 1 or 2 may greatly reduce the computation time needed for large \r\n+# code bases. Also note that a graph may be further truncated if the graph's \r\n+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH \r\n+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), \r\n+# the graph is not depth-constrained.\r\n+\r\n+MAX_DOT_GRAPH_DEPTH = 0\r\n+\r\n+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent \r\n+# background. This is disabled by default, which results in a white background. \r\n+# Warning: Depending on the platform used, enabling this option may lead to \r\n+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to \r\n+# read).\r\n+\r\n+DOT_TRANSPARENT = NO\r\n+\r\n+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output \r\n+# files in one run (i.e. multiple -o and -T options on the command line). This \r\n+# makes dot run faster, but since only newer versions of dot (>1.8.10) \r\n+# support this, this feature is disabled by default.\r\n+\r\n+DOT_MULTI_TARGETS = NO\r\n+\r\n+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will \r\n+# generate a legend page explaining the meaning of the various boxes and \r\n+# arrows in the dot generated graphs.\r\n+\r\n+GENERATE_LEGEND = YES\r\n+\r\n+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will \r\n+# remove the intermediate dot files that are used to generate \r\n+# the various graphs.\r\n+\r\n+DOT_CLEANUP = YES\r\n+\r\n+#---------------------------------------------------------------------------\r\n+# Configuration::additions related to the search engine   \r\n+#---------------------------------------------------------------------------\r\n+\r\n+# The SEARCHENGINE tag specifies whether or not a search engine should be \r\n+# used. If set to NO the values of all tags below this one will be ignored.\r\n+\r\n+SEARCHENGINE = NO\r"},{"sha":"19266b3b5e41b6282734d91a14a107f4297731c8","filename":"hedwig-client/src/main/cpp/config.h.in","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/config.h.in","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/config.h.in","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/config.h.in?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,56 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS"},{"sha":"6903cc59fcac99a89bb5696858e5d72e3ef7021d","filename":"hedwig-client/src/main/cpp/configure.ac","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/configure.ac","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/configure.ac","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/configure.ac?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,40 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+AC_INIT([Hedwig C++ Client], [0.1], [zookeeper-dev@hadoop.apache.org], [hedwig-cpp], [http://hadoop.apache.org/zookeeper//])\n+\n+AC_PREREQ([2.59])\n+AM_INIT_AUTOMAKE([1.9 no-define foreign])\n+AC_CONFIG_HEADERS([config.h])\n+AC_PROG_CXX\n+AC_LANG([C++])\n+AC_CONFIG_FILES([Makefile lib/Makefile test/Makefile hedwig-0.1.pc])\n+AC_PROG_LIBTOOL\n+AC_CONFIG_MACRO_DIR([m4])\n+PKG_CHECK_MODULES([DEPS], [liblog4cxx protobuf cppunit])\n+AX_BOOST_BASE\n+AX_BOOST_ASIO\t  \n+AX_BOOST_THREAD\n+\n+DX_HTML_FEATURE(ON)\n+DX_INIT_DOXYGEN(hedwig-c++, c-doc.Doxyfile, doc)\n+\n+CXXFLAGS=\"$CXXFLAGS -Wall\"\n+\n+AC_OUTPUT\n+"},{"sha":"1e7eea1644da3e9730b75a08a173bdee47efbffc","filename":"hedwig-client/src/main/cpp/hedwig-0.1.pc.in","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/hedwig-0.1.pc.in","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/hedwig-0.1.pc.in","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/hedwig-0.1.pc.in?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,30 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+prefix=@prefix@\n+exec_prefix=@exec_prefix@\n+libdir=@libdir@\n+includedir=@includedir@\n+\n+Name: something\n+Description: Some library.\n+Requires: \n+Version: @PACKAGE_VERSION@\n+Libs: -L${libdir} -lhedwig01\n+Cflags: -I${includedir}/hedwig-0.1 -I${libdir}/hedwig-0.1/include\n+"},{"sha":"c975e88efbf8a0a21fb457c52e2585ba3a380d2c","filename":"hedwig-client/src/main/cpp/inc/hedwig/callback.h","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/callback.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/callback.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/callback.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef HEDWIG_CALLBACK_H\n+#define HEDWIG_CALLBACK_H\n+\n+#include <string>\n+#include <hedwig/exceptions.h>\n+#include <hedwig/protocol.h>\n+#include <tr1/memory>\n+\n+namespace Hedwig {\n+  class OperationCallback {\n+  public:\n+    virtual void operationComplete() = 0;\n+    virtual void operationFailed(const std::exception& exception) = 0;\n+    \n+    virtual ~OperationCallback() {};\n+  };\n+  typedef std::tr1::shared_ptr<OperationCallback> OperationCallbackPtr;\n+\n+  class MessageHandlerCallback {\n+  public:\n+    virtual void consume(const std::string& topic, const std::string& subscriberId, const Message& msg, OperationCallbackPtr& callback) = 0;\n+    \n+    virtual ~MessageHandlerCallback() {};\n+  };\n+  typedef std::tr1::shared_ptr<MessageHandlerCallback> MessageHandlerCallbackPtr;\n+}\n+\n+#endif"},{"sha":"b540fe0c41416805952a9b203bea0c89b1c821da","filename":"hedwig-client/src/main/cpp/inc/hedwig/client.h","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/client.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/client.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/client.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef HEDWIG_CLIENT_H\n+#define HEDWIG_CLIENT_H\n+\n+#include <string>\n+#include <tr1/memory>\n+\n+#include <hedwig/subscribe.h>\n+#include <hedwig/publish.h>\n+#include <hedwig/exceptions.h>\n+#include <boost/noncopyable.hpp>\n+#include <boost/shared_ptr.hpp>\n+\n+namespace Hedwig {\n+\n+  class ClientImpl;\n+  typedef boost::shared_ptr<ClientImpl> ClientImplPtr;\n+\n+  class Configuration {\n+  public:\n+    static const std::string DEFAULT_SERVER;\n+    static const std::string MESSAGE_CONSUME_RETRY_WAIT_TIME;\n+    static const std::string SUBSCRIBER_CONSUME_RETRY_WAIT_TIME;\n+    static const std::string MAX_MESSAGE_QUEUE_SIZE;\n+    static const std::string RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME;\n+    static const std::string SYNC_REQUEST_TIMEOUT;\n+    static const std::string SUBSCRIBER_AUTOCONSUME;\n+\n+  public:\n+    Configuration() {};\n+    virtual int getInt(const std::string& key, int defaultVal) const = 0;\n+    virtual const std::string get(const std::string& key, const std::string& defaultVal) const = 0;\n+    virtual bool getBool(const std::string& key, bool defaultVal) const = 0;\n+\n+    virtual ~Configuration() {}\n+  };\n+\n+  /** \n+      Main Hedwig client class. This class is used to acquire an instance of the Subscriber of Publisher.\n+  */\n+  class Client : private boost::noncopyable {\n+  public: \n+    Client(const Configuration& conf);\n+\n+    /**\n+       Retrieve the subscriber object\n+    */\n+    Subscriber& getSubscriber();\n+\n+    /**\n+       Retrieve the publisher object\n+    */\n+    Publisher& getPublisher();\n+\n+    ~Client();\n+\n+  private:\n+    ClientImplPtr clientimpl;\n+  };\n+\n+ \n+};\n+\n+#endif"},{"sha":"72b7ac37e3b0d9ba25f17435e65058e699968507","filename":"hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,51 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef HEDWIG_EXCEPTION_H\n+#define HEDWIG_EXCEPTION_H\n+\n+#include <exception>\n+\n+namespace Hedwig {\n+\n+  class ClientException : public std::exception { };\n+\n+  class ClientTimeoutException : public ClientException {};\n+\n+  class ServiceDownException : public ClientException {};\n+  class CannotConnectException : public ClientException {};\n+  class UnexpectedResponseException : public ClientException {};\n+  class OomException : public ClientException {};\n+  class UnknownRequestException : public ClientException {};\n+  class InvalidRedirectException : public ClientException {};\n+\n+  class PublisherException : public ClientException { };\n+  \n+\n+  class SubscriberException : public ClientException { };\n+  class AlreadySubscribedException : public SubscriberException {};\n+  class NotSubscribedException : public SubscriberException {};\n+\n+  class ConfigurationException : public ClientException { };\n+  class InvalidPortException : public ConfigurationException {};\n+  class HostResolutionException : public ClientException {};\n+  \n+  class InvalidStateException : public ClientException {};\n+  class ShuttingDownException : public InvalidStateException {};\n+};\n+\n+#endif"},{"sha":"22009de7a9d5ef67ff00bde13e23ac4e07844be3","filename":"hedwig-client/src/main/cpp/inc/hedwig/publish.h","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/publish.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/publish.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/publish.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,61 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef HEDWIG_PUBLISH_H\n+#define HEDWIG_PUBLISH_H\n+\n+#include <string>\n+\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <hedwig/protocol.h>\n+#include <boost/noncopyable.hpp>\n+\n+namespace Hedwig {\n+\n+  /**\n+     Interface for publishing to a hedwig instance.\n+  */\n+  class Publisher : private boost::noncopyable {\n+  public:\n+    /**\n+       Publish message for topic, and block until we receive a ACK response from the hedwig server.\n+       \n+       @param topic Topic to publish to.\n+       @param message Data to publish for topic.\n+    */\n+    virtual void publish(const std::string& topic, const std::string& message) = 0;\n+    \n+    /** \n+\tAsynchronously publish message for topic. \n+\t\n+\t@code\n+\tOperationCallbackPtr callback(new MyCallback());\n+\tpub.asyncPublish(callback);\n+\t@endcode\n+\n+\t@param topic Topic to publish to.\n+\t@param message Data to publish to topic\n+\t@param callback Callback which will be used to report success or failure. Success is only reported once the server replies with an ACK response to the publication.\n+    */\n+    virtual void asyncPublish(const std::string& topic, const std::string& message, const OperationCallbackPtr& callback) = 0;\n+    \n+    virtual ~Publisher() {}\n+  };\n+};\n+\n+#endif"},{"sha":"775a32c15fd2e19f1d9826f431ab899972f4e8f5","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,52 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef HEDWIG_SUBSCRIBE_H\n+#define HEDWIG_SUBSCRIBE_H\n+\n+#include <string>\n+\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <hedwig/protocol.h>\n+#include <boost/noncopyable.hpp>\n+\n+namespace Hedwig {\n+\n+  /**\n+     Interface for subscribing to a hedwig instance. \n+  */\n+  class Subscriber : private boost::noncopyable {\n+  public:\n+    virtual void subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode) = 0;\n+    virtual void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback) = 0;\n+    \n+    virtual void unsubscribe(const std::string& topic, const std::string& subscriberId) = 0;\n+    virtual void asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback) = 0;  \n+\n+    virtual void consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId) = 0;\n+\n+    virtual void startDelivery(const std::string& topic, const std::string& subscriberId, const MessageHandlerCallbackPtr& callback) = 0;\n+    virtual void stopDelivery(const std::string& topic, const std::string& subscriberId) = 0;\n+\n+    virtual void closeSubscription(const std::string& topic, const std::string& subscriberId) = 0;\n+\n+    virtual ~Subscriber() {}\n+  };\n+};\n+\n+#endif"},{"sha":"9a5313889969ea4dd11efb79bbe3fa7a73eaad41","filename":"hedwig-client/src/main/cpp/lib/Makefile.am","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/Makefile.am?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,32 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+PROTODEF = ../../../../../protocol/src/main/protobuf/PubSubProtocol.proto\n+\n+lib_LTLIBRARIES = libhedwig01.la\n+libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp\n+libhedwig01_la_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS)\n+libhedwig01_la_LIBADD = $(DEPS_LIBS) $(BOOST_CPPFLAGS) \n+libhedwig01_la_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)\n+\n+protocol.cpp: $(PROTODEF)\n+\tprotoc --cpp_out=. -I`dirname $(PROTODEF)` $(PROTODEF)\n+\tsed \"s/PubSubProtocol.pb.h/hedwig\\/protocol.h/\" PubSubProtocol.pb.cc > protocol.cpp\n+\trm PubSubProtocol.pb.cc\n+\tmv PubSubProtocol.pb.h $(top_srcdir)/inc/hedwig/protocol.h\n+"},{"sha":"8e9397a02a9e3155e6933c9593668543546b50bd","filename":"hedwig-client/src/main/cpp/lib/channel.cpp","status":"added","additions":420,"deletions":0,"changes":420,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/channel.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/channel.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,420 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <arpa/inet.h>\n+#include <netinet/tcp.h>\n+#include <poll.h>\n+#include <iostream>\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <vector>\n+#include <utility>\n+#include <deque>\n+#include \"channel.h\"\n+#include \"util.h\"\n+#include \"clientimpl.h\"\n+\n+#include <log4cxx/logger.h>\n+#include <google/protobuf/io/zero_copy_stream_impl.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+DuplexChannel::DuplexChannel(EventDispatcher& dispatcher, const HostAddress& addr, \n+\t\t\t     const Configuration& cfg, const ChannelHandlerPtr& handler)\n+  : dispatcher(dispatcher), address(addr), handler(handler), \n+    socket(dispatcher.getService()), instream(&in_buf), copy_buf(NULL), copy_buf_length(0),\n+    state(UNINITIALISED), receiving(false), sending(false)\n+{\n+  LOG4CXX_DEBUG(logger, \"Creating DuplexChannel(\" << this << \")\");\n+}\n+\n+/*static*/ void DuplexChannel::connectCallbackHandler(DuplexChannelPtr channel,\n+\t\t\t\t\t\t      const boost::system::error_code& error) {\n+  LOG4CXX_DEBUG(logger,\"DuplexChannel::connectCallbackHandler error(\" << error \n+\t\t<< \") channel(\" << channel.get() << \")\");\n+\n+  if (error) {\n+    channel->channelDisconnected(ChannelConnectException());\n+    channel->setState(DEAD);\n+    return;\n+  }\n+\n+  channel->setState(CONNECTED);\n+\n+  boost::system::error_code ec;\n+  boost::asio::ip::tcp::no_delay option(true);\n+\n+  channel->socket.set_option(option, ec);\n+  if (ec) {\n+    channel->channelDisconnected(ChannelSetupException());\n+    channel->setState(DEAD);\n+    return;\n+  } \n+  \n+  channel->startSending();\n+  channel->startReceiving();\n+}\n+\n+void DuplexChannel::connect() {  \n+  setState(CONNECTING);\n+\n+  boost::asio::ip::tcp::endpoint endp(boost::asio::ip::address_v4(address.ip()), address.port());\n+  boost::system::error_code error = boost::asio::error::host_not_found;\n+\n+  socket.async_connect(endp, boost::bind(&DuplexChannel::connectCallbackHandler, \n+\t\t\t\t\t shared_from_this(), \n+\t\t\t\t\t boost::asio::placeholders::error)); \n+}\n+\n+/*static*/ void DuplexChannel::messageReadCallbackHandler(DuplexChannelPtr channel, \n+\t\t\t\t\t\t\t  std::size_t message_size,\n+\t\t\t\t\t\t\t  const boost::system::error_code& error, \n+\t\t\t\t\t\t\t  std::size_t bytes_transferred) {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::messageReadCallbackHandler \" << error << \", \" \n+\t\t<< bytes_transferred << \" channel(\" << channel.get() << \")\");\n+\t\t  \n+  if (error) {\n+    LOG4CXX_ERROR(logger, \"Invalid read error (\" << error << \") bytes_transferred (\" \n+\t\t  << bytes_transferred << \") channel(\" << channel.get() << \")\");\n+    channel->channelDisconnected(ChannelReadException());\n+    return;\n+  }\n+\n+  if (channel->copy_buf_length < message_size) {\n+    channel->copy_buf_length = message_size;\n+    channel->copy_buf = (char*)realloc(channel->copy_buf, channel->copy_buf_length);\n+    if (channel->copy_buf == NULL) {\n+      LOG4CXX_ERROR(logger, \"Error allocating buffer. channel(\" << channel.get() << \")\");\n+      return;\n+    }\n+  }\n+  \n+  channel->instream.read(channel->copy_buf, message_size);\n+  PubSubResponsePtr response(new PubSubResponse());\n+  bool err = response->ParseFromArray(channel->copy_buf, message_size);\n+\n+\n+  if (!err) {\n+    LOG4CXX_ERROR(logger, \"Error parsing message. channel(\" << channel.get() << \")\");\n+\n+    channel->channelDisconnected(ChannelReadException());\n+    return;\n+  } else {\n+    LOG4CXX_DEBUG(logger,  \"channel(\" << channel.get() << \") : \" << channel->in_buf.size() \n+\t\t  << \" bytes left in buffer\");\n+  }\n+\n+  ChannelHandlerPtr h;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(channel->destruction_lock);\n+    if (channel->handler.get()) {\n+      h = channel->handler;\n+    }\n+  }\n+  if (h.get()) {\n+    h->messageReceived(channel, response);\n+  }\n+\n+  DuplexChannel::readSize(channel);\n+}\n+\n+/*static*/ void DuplexChannel::sizeReadCallbackHandler(DuplexChannelPtr channel, \n+\t\t\t\t\t\t       const boost::system::error_code& error, \n+\t\t\t\t\t\t       std::size_t bytes_transferred) {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::sizeReadCallbackHandler \" << error << \", \" \n+\t\t<< bytes_transferred << \" channel(\" << channel.get() << \")\");\n+\n+  if (error) {\n+    LOG4CXX_ERROR(logger, \"Invalid read error (\" << error << \") bytes_transferred (\" \n+\t\t  << bytes_transferred << \") channel(\" << channel.get() << \")\");\n+    channel->channelDisconnected(ChannelReadException());\n+    return;\n+  }\n+  \n+  if (channel->in_buf.size() < sizeof(uint32_t)) {\n+    LOG4CXX_ERROR(logger, \"Not enough data in stream. Must have been an error reading. \" \n+\t\t  << \" Closing channel(\" << channel.get() << \")\");\n+    channel->channelDisconnected(ChannelReadException());\n+    return;\n+  }\n+\n+  uint32_t size;\n+  std::istream is(&channel->in_buf);\n+  is.read((char*)&size, sizeof(uint32_t));\n+  size = ntohl(size);\n+\n+  int toread = size - channel->in_buf.size();\n+  LOG4CXX_DEBUG(logger, \" size of incoming message \" << size << \", currently in buffer \" \n+\t\t<< channel->in_buf.size() << \" channel(\" << channel.get() << \")\");\n+  if (toread <= 0) {\n+    DuplexChannel::messageReadCallbackHandler(channel, size, error, 0);\n+  } else {\n+    boost::asio::async_read(channel->socket, channel->in_buf,\n+\t\t\t    boost::asio::transfer_at_least(toread),\n+\t\t\t    boost::bind(&DuplexChannel::messageReadCallbackHandler, \n+\t\t\t\t\tchannel, size,\n+\t\t\t\t\tboost::asio::placeholders::error, \n+\t\t\t\t\tboost::asio::placeholders::bytes_transferred));\n+  }\n+}\n+\n+/*static*/ void DuplexChannel::readSize(DuplexChannelPtr channel) {\n+  if (!channel->isReceiving()) {\n+    return;\n+  }\n+\n+  int toread = sizeof(uint32_t) - channel->in_buf.size();\n+  LOG4CXX_DEBUG(logger, \" size of incoming message \" << sizeof(uint32_t) \n+\t\t<< \", currently in buffer \" << channel->in_buf.size() \n+\t\t<< \" channel(\" << channel.get() << \")\");\n+\n+  if (toread < 0) {\n+    DuplexChannel::sizeReadCallbackHandler(channel, boost::system::error_code(), 0);\n+  } else {\n+    //  in_buf_size.prepare(sizeof(uint32_t));\n+    boost::asio::async_read(channel->socket, channel->in_buf, \n+\t\t\t    boost::asio::transfer_at_least(sizeof(uint32_t)),\n+\t\t\t    boost::bind(&DuplexChannel::sizeReadCallbackHandler, \n+\t\t\t\t\tchannel, \n+\t\t\t\t\tboost::asio::placeholders::error, \n+\t\t\t\t\tboost::asio::placeholders::bytes_transferred));\n+  }\n+}\n+\n+void DuplexChannel::startReceiving() {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::startReceiving channel(\" << this << \") currently receiving = \" << receiving);\n+  \n+  boost::lock_guard<boost::mutex> lock(receiving_lock);\n+  if (receiving) {\n+    return;\n+  } \n+  receiving = true;\n+  \n+  DuplexChannel::readSize(shared_from_this());\n+}\n+\n+bool DuplexChannel::isReceiving() {\n+  return receiving;\n+}\n+\n+void DuplexChannel::stopReceiving() {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::stopReceiving channel(\" << this << \")\");\n+  \n+  boost::lock_guard<boost::mutex> lock(receiving_lock);\n+  receiving = false;\n+}\n+\n+void DuplexChannel::startSending() {\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(state_lock);\n+    if (state != CONNECTED) {\n+      return;\n+    }\n+  }\n+\n+  boost::lock_guard<boost::mutex> lock(sending_lock);\n+  if (sending) {\n+    return;\n+  }\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::startSending channel(\" << this << \")\");\n+  \n+  WriteRequest w;\n+  { \n+    boost::lock_guard<boost::mutex> lock(write_lock);\n+    if (write_queue.empty()) {\n+      return;\n+    }\n+    w = write_queue.front();\n+    write_queue.pop_front();\n+  }\n+\n+  sending = true;\n+\n+  std::ostream os(&out_buf);\n+  uint32_t size = htonl(w.first->ByteSize());\n+  os.write((char*)&size, sizeof(uint32_t));\n+  \n+  bool err = w.first->SerializeToOstream(&os);\n+  if (!err) {\n+    w.second->operationFailed(ChannelWriteException());\n+    channelDisconnected(ChannelWriteException());\n+    return;\n+  }\n+\n+  boost::asio::async_write(socket, out_buf, \n+\t\t\t   boost::bind(&DuplexChannel::writeCallbackHandler, \n+\t\t\t\t       shared_from_this(), \n+\t\t\t\t       w.second,\n+\t\t\t\t       boost::asio::placeholders::error, \n+\t\t\t\t       boost::asio::placeholders::bytes_transferred));\n+}\n+\n+\n+const HostAddress& DuplexChannel::getHostAddress() const {\n+  return address;\n+}\n+\n+void DuplexChannel::channelDisconnected(const std::exception& e) {\n+  setState(DEAD);\n+  \n+  {\n+    boost::lock_guard<boost::mutex> lock(write_lock);\n+    while (!write_queue.empty()) {\n+      WriteRequest w = write_queue.front();\n+      write_queue.pop_front();\n+      w.second->operationFailed(e);\n+    }\n+  }\n+\n+  ChannelHandlerPtr h;\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(destruction_lock);\n+    if (handler.get()) {\n+      h = handler;\n+    }\n+  }\n+  if (h.get()) {\n+    h->channelDisconnected(shared_from_this(), e);\n+  }\n+}\n+\n+void DuplexChannel::kill() {\n+  LOG4CXX_DEBUG(logger, \"Killing duplex channel (\" << this << \")\");\n+    \n+  bool connected = false;\n+  {\n+    boost::shared_lock<boost::shared_mutex> statelock(state_lock);\n+    connected = (state == CONNECTING || state == CONNECTED);\n+  }\n+\n+  boost::lock_guard<boost::shared_mutex> lock(destruction_lock);\n+  if (connected) {\n+    setState(DEAD);\n+    \n+    socket.cancel();\n+    socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n+    socket.close();\n+  }\n+  handler = ChannelHandlerPtr(); // clear the handler in case it ever referenced the channel*/\n+}\n+\n+DuplexChannel::~DuplexChannel() {\n+  /** If we are going away, fail all transactions that haven't been completed */\n+  failAllTransactions();\n+  kill();\n+  free(copy_buf);\n+  copy_buf = NULL;\n+  copy_buf_length = 0;\n+\n+  LOG4CXX_DEBUG(logger, \"Destroying DuplexChannel(\" << this << \")\");\n+}\n+\n+/*static*/ void DuplexChannel::writeCallbackHandler(DuplexChannelPtr channel, OperationCallbackPtr callback,\n+\t\t\t\t\t\t    const boost::system::error_code& error, \n+\t\t\t\t\t\t    std::size_t bytes_transferred) {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::writeCallbackHandler \" << error << \", \" \n+\t\t<< bytes_transferred << \" channel(\" << channel.get() << \")\");\n+\n+  if (error) {\n+    callback->operationFailed(ChannelWriteException());\n+    channel->channelDisconnected(ChannelWriteException());\n+    return;\n+  }\n+\n+  callback->operationComplete();\n+\n+  channel->out_buf.consume(bytes_transferred);\n+\n+  {\n+    boost::lock_guard<boost::mutex> lock(channel->sending_lock);\n+    channel->sending = false;\n+  }\n+\n+  channel->startSending();\n+}\n+\n+void DuplexChannel::writeRequest(const PubSubRequestPtr& m, const OperationCallbackPtr& callback) {\n+  LOG4CXX_DEBUG(logger, \"DuplexChannel::writeRequest channel(\" << this << \") txnid(\" \n+\t\t<< m->txnid() << \") shouldClaim(\"<< m->has_shouldclaim() << \", \" \n+\t\t<< m->shouldclaim() << \")\");\n+\n+  {\n+    boost::shared_lock<boost::shared_mutex> lock(state_lock);\n+    if (state != CONNECTED && state != CONNECTING) {\n+      LOG4CXX_ERROR(logger,\"Tried to write transaction [\" << m->txnid() << \"] to a channel [\" \n+\t\t    << this << \"] which is \" << (state == DEAD ? \"DEAD\" : \"UNINITIALISED\"));\n+      callback->operationFailed(UninitialisedChannelException());\n+    }\n+  }\n+\n+  { \n+    boost::lock_guard<boost::mutex> lock(write_lock);\n+    WriteRequest w(m, callback);\n+    write_queue.push_back(w);\n+  }\n+\n+  startSending();\n+}\n+\n+/**\n+   Store the transaction data for a request.\n+*/\n+void DuplexChannel::storeTransaction(const PubSubDataPtr& data) {\n+  LOG4CXX_DEBUG(logger, \"Storing txnid(\" << data->getTxnId() << \") for channel(\" << this << \")\");\n+\n+  boost::lock_guard<boost::mutex> lock(txnid2data_lock);\n+  txnid2data[data->getTxnId()] = data;\n+}\n+\n+/**\n+   Give the transaction back to the caller. \n+*/\n+PubSubDataPtr DuplexChannel::retrieveTransaction(long txnid) {\n+  boost::lock_guard<boost::mutex> lock(txnid2data_lock);\n+\n+  PubSubDataPtr data = txnid2data[txnid];\n+  txnid2data.erase(txnid);\n+  if (data == NULL) {\n+    LOG4CXX_ERROR(logger, \"Transaction txnid(\" << txnid \n+\t\t  << \") doesn't exist in channel (\" << this << \")\");\n+  }\n+\n+  return data;\n+}\n+\n+void DuplexChannel::failAllTransactions() {\n+  boost::lock_guard<boost::mutex> lock(txnid2data_lock);\n+  for (TransactionMap::iterator iter = txnid2data.begin(); iter != txnid2data.end(); ++iter) {\n+    PubSubDataPtr& data = (*iter).second;\n+    data->getCallback()->operationFailed(ChannelDiedException());\n+  }\n+  txnid2data.clear();\n+}\n+\n+void DuplexChannel::setState(State s) {\n+  boost::lock_guard<boost::shared_mutex> lock(state_lock);\n+  state = s;\n+}"},{"sha":"ea7805482931b974e74d0e136ad5bebaa40bb3a3","filename":"hedwig-client/src/main/cpp/lib/channel.h","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/channel.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/channel.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/channel.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef HEDWIG_CHANNEL_H\n+#define HEDWIG_CHANNEL_H\n+\n+#include <hedwig/protocol.h>\n+#include <hedwig/callback.h>\n+#include <hedwig/client.h>\n+#include \"util.h\"\n+#include \"data.h\"\n+#include \"eventdispatcher.h\"\n+\n+#include <tr1/memory>\n+#include <tr1/unordered_map>\n+\n+#include <google/protobuf/io/zero_copy_stream_impl.h>\n+\n+#include <boost/shared_ptr.hpp>\n+#include <boost/enable_shared_from_this.hpp>\n+\n+#include <boost/asio/ip/tcp.hpp>\n+#include <boost/thread/mutex.hpp>\n+#include <boost/thread/shared_mutex.hpp>\n+\n+namespace Hedwig {\n+  class ChannelException : public std::exception { };\n+  class UninitialisedChannelException : public ChannelException {};\n+\n+  class ChannelConnectException : public ChannelException {};\n+  class CannotCreateSocketException : public ChannelConnectException {};\n+  class ChannelSetupException : public ChannelConnectException {};\n+  class ChannelNotConnectedException : public ChannelConnectException {};\n+\n+  class ChannelDiedException : public ChannelException {};\n+\n+  class ChannelWriteException : public ChannelException {};\n+  class ChannelReadException : public ChannelException {};\n+  class ChannelThreadException : public ChannelException {};\n+\n+  class DuplexChannel;\n+  typedef boost::shared_ptr<DuplexChannel> DuplexChannelPtr;\n+\n+  class ChannelHandler {\n+  public:\n+    virtual void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) = 0;\n+    virtual void channelConnected(const DuplexChannelPtr& channel) = 0;\n+\n+    virtual void channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e) = 0;\n+    virtual void exceptionOccurred(const DuplexChannelPtr& channel, const std::exception& e) = 0;\n+\n+    virtual ~ChannelHandler() {}\n+  };\n+\n+  typedef boost::shared_ptr<ChannelHandler> ChannelHandlerPtr;\n+\n+\n+  class DuplexChannel : public boost::enable_shared_from_this<DuplexChannel> {\n+  public:\n+    DuplexChannel(EventDispatcher& dispatcher, const HostAddress& addr, \n+\t\t  const Configuration& cfg, const ChannelHandlerPtr& handler);\n+    static void connectCallbackHandler(DuplexChannelPtr channel, \n+\t\t\t\t       const boost::system::error_code& error);\n+    void connect();\n+\n+    static void writeCallbackHandler(DuplexChannelPtr channel, OperationCallbackPtr callback, \n+\t\t\t\t     const boost::system::error_code& error, \n+\t\t\t\t     std::size_t bytes_transferred);\n+    void writeRequest(const PubSubRequestPtr& m, const OperationCallbackPtr& callback);\n+    \n+    const HostAddress& getHostAddress() const;\n+\n+    void storeTransaction(const PubSubDataPtr& data);\n+    PubSubDataPtr retrieveTransaction(long txnid);\n+    void failAllTransactions();\n+\n+    static void sizeReadCallbackHandler(DuplexChannelPtr channel, \n+\t\t\t\t\tconst boost::system::error_code& error, \n+\t\t\t\t\tstd::size_t bytes_transferred);\n+    static void messageReadCallbackHandler(DuplexChannelPtr channel, std::size_t messagesize, \n+\t\t\t\t\t   const boost::system::error_code& error, \n+\t\t\t\t\t   std::size_t bytes_transferred);\n+    static void readSize(DuplexChannelPtr channel);\n+\n+    void startReceiving();\n+    bool isReceiving();\n+    void stopReceiving();\n+    \n+    void startSending();\n+\n+    void channelDisconnected(const std::exception& e);\n+    virtual void kill();\n+\n+    virtual ~DuplexChannel();\n+  private:\n+    enum State { UNINITIALISED, CONNECTING, CONNECTED, DEAD };\n+\n+    void setState(State s);\n+\n+    EventDispatcher& dispatcher;\n+\n+    HostAddress address;\n+    ChannelHandlerPtr handler;\n+\n+    boost::asio::ip::tcp::socket socket;\n+    boost::asio::streambuf in_buf;\n+    std::istream instream;\n+    \n+    // only exists because protobufs can't play nice with streams (if there's more than message len in it, it tries to read all)\n+    char* copy_buf;\n+    std::size_t copy_buf_length;\n+\n+    boost::asio::streambuf out_buf;\n+    \n+    typedef std::pair<PubSubRequestPtr, OperationCallbackPtr> WriteRequest;\n+    boost::mutex write_lock;\n+    std::deque<WriteRequest> write_queue;\n+\n+    State state;\n+    boost::shared_mutex state_lock;\n+\n+    bool receiving;\n+    boost::mutex receiving_lock;\n+    \n+    bool sending;\n+    boost::mutex sending_lock;\n+\n+    typedef std::tr1::unordered_map<long, PubSubDataPtr> TransactionMap;\n+\n+    TransactionMap txnid2data;\n+    boost::mutex txnid2data_lock;\n+    boost::shared_mutex destruction_lock;\n+  };\n+  \n+\n+  struct DuplexChannelPtrHash : public std::unary_function<DuplexChannelPtr, size_t> {\n+    size_t operator()(const Hedwig::DuplexChannelPtr& channel) const {\n+      return reinterpret_cast<size_t>(channel.get());\n+    }\n+  };\n+};\n+#endif"},{"sha":"2900cff228c14d6ae67662f79e808721152e4dde","filename":"hedwig-client/src/main/cpp/lib/client.cpp","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/client.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/client.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/client.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <hedwig/client.h>\n+#include <memory>\n+\n+#include \"clientimpl.h\"\n+#include <log4cxx/logger.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+const std::string Configuration::DEFAULT_SERVER = \"hedwig.cpp.default_server\";\n+const std::string Configuration::MESSAGE_CONSUME_RETRY_WAIT_TIME = \"hedwig.cpp.message_consume_retry_wait_time\";\n+const std::string Configuration::SUBSCRIBER_CONSUME_RETRY_WAIT_TIME = \"hedwig.cpp.subscriber_consume_retry_wait_time\";\n+const std::string Configuration::MAX_MESSAGE_QUEUE_SIZE = \"hedwig.cpp.max_msgqueue_size\";\n+const std::string Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME = \"hedwig.cpp.reconnect_subscribe_retry_wait_time\";\n+const std::string Configuration::SYNC_REQUEST_TIMEOUT = \"hedwig.cpp.sync_request_timeout\";\n+const std::string Configuration::SUBSCRIBER_AUTOCONSUME = \"hedwig.cpp.subscriber_autoconsume\";\n+\n+Client::Client(const Configuration& conf) {\n+  LOG4CXX_DEBUG(logger, \"Client::Client (\" << this << \")\");\n+\n+  clientimpl = ClientImpl::Create( conf );\n+}\n+\n+Subscriber& Client::getSubscriber() {\n+  return clientimpl->getSubscriber();\n+}\n+\n+Publisher& Client::getPublisher() {\n+  return clientimpl->getPublisher();\n+}\n+\n+Client::~Client() {\n+  LOG4CXX_DEBUG(logger, \"Client::~Client (\" << this << \")\");\n+\n+  clientimpl->Destroy();\n+}\n+\n+"},{"sha":"67198dec31eb4f390e230b2db6e98dc7e4dc313e","filename":"hedwig-client/src/main/cpp/lib/clientimpl.cpp","status":"added","additions":376,"deletions":0,"changes":376,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/clientimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/clientimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,376 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#include \"clientimpl.h\"\n+#include \"channel.h\"\n+#include \"publisherimpl.h\"\n+#include \"subscriberimpl.h\"\n+#include <log4cxx/logger.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+const std::string DEFAULT_SERVER_DEFAULT_VAL = \"\";\n+\n+void SyncOperationCallback::wait() {\n+  boost::unique_lock<boost::mutex> lock(mut);\n+  while(response==PENDING) {\n+    if (cond.timed_wait(lock, boost::posix_time::milliseconds(timeout)) == false) {\n+      LOG4CXX_ERROR(logger, \"Timeout waiting for operation to complete \" << this);\n+\n+      response = TIMEOUT;\n+    }\n+  }\n+}\n+\n+void SyncOperationCallback::operationComplete() {\n+  if (response == TIMEOUT) {\n+    LOG4CXX_ERROR(logger, \"operationCompleted successfully after timeout \" << this);\n+    return;\n+  }\n+\n+  {\n+    boost::lock_guard<boost::mutex> lock(mut);\n+    response = SUCCESS;\n+  }\n+  cond.notify_all();\n+}\n+\n+void SyncOperationCallback::operationFailed(const std::exception& exception) {\n+  if (response == TIMEOUT) {\n+    LOG4CXX_ERROR(logger, \"operationCompleted unsuccessfully after timeout \" << this);\n+    return;\n+  }\n+\n+  {\n+    boost::lock_guard<boost::mutex> lock(mut);\n+    \n+    if (typeid(exception) == typeid(ChannelConnectException)) {\n+      response = NOCONNECT;\n+    } else if (typeid(exception) == typeid(ServiceDownException)) {\n+      response = SERVICEDOWN;\n+    } else if (typeid(exception) == typeid(AlreadySubscribedException)) {\n+      response = ALREADY_SUBSCRIBED;\n+    } else if (typeid(exception) == typeid(NotSubscribedException)) {\n+      response = NOT_SUBSCRIBED;\n+    } else {\n+      response = UNKNOWN;\n+    }\n+  }\n+  cond.notify_all();\n+}\n+\n+void SyncOperationCallback::throwExceptionIfNeeded() {\n+  switch (response) {\n+  case SUCCESS:\n+    break;\n+  case NOCONNECT:\n+    throw CannotConnectException();\n+    break;\n+  case SERVICEDOWN:\n+    throw ServiceDownException();\n+    break;\n+  case ALREADY_SUBSCRIBED:\n+    throw AlreadySubscribedException();\n+    break;\n+  case NOT_SUBSCRIBED:\n+    throw NotSubscribedException();\n+    break;\n+  case TIMEOUT:\n+    throw ClientTimeoutException();\n+    break;\n+  default:\n+    throw ClientException();\n+    break;\n+  }\n+}\n+\n+HedwigClientChannelHandler::HedwigClientChannelHandler(const ClientImplPtr& client) \n+  : client(client){\n+}\n+\n+void HedwigClientChannelHandler::messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) {\n+  LOG4CXX_DEBUG(logger, \"Message received txnid(\" << m->txnid() << \") status(\" \n+\t\t<< m->statuscode() << \")\");\n+  if (m->has_message()) {\n+    LOG4CXX_ERROR(logger, \"Subscription response, ignore for now\");\n+    return;\n+  }\n+  \n+  PubSubDataPtr data = channel->retrieveTransaction(m->txnid()); \n+  /* you now have ownership of data, don't leave this funciton without deleting it or \n+     palming it off to someone else */\n+\n+  if (data == NULL) {\n+    return;\n+  }\n+\n+  if (m->statuscode() == NOT_RESPONSIBLE_FOR_TOPIC) {\n+    client->redirectRequest(channel, data, m);\n+    return;\n+  }\n+\n+  switch (data->getType()) {\n+  case PUBLISH:\n+    client->getPublisherImpl().messageHandler(m, data);\n+    break;\n+  case SUBSCRIBE:\n+  case UNSUBSCRIBE:\n+    client->getSubscriberImpl().messageHandler(m, data);\n+    break;\n+  default:\n+    LOG4CXX_ERROR(logger, \"Unimplemented request type \" << data->getType());\n+    break;\n+  }\n+}\n+\n+\n+void HedwigClientChannelHandler::channelConnected(const DuplexChannelPtr& channel) {\n+  // do nothing \n+}\n+\n+void HedwigClientChannelHandler::channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e) {\n+  LOG4CXX_ERROR(logger, \"Channel disconnected\");\n+\n+  client->channelDied(channel);\n+}\n+\n+void HedwigClientChannelHandler::exceptionOccurred(const DuplexChannelPtr& channel, const std::exception& e) {\n+  LOG4CXX_ERROR(logger, \"Exception occurred\" << e.what());\n+}\n+\n+ClientTxnCounter::ClientTxnCounter() : counter(0) \n+{\n+}\n+\n+ClientTxnCounter::~ClientTxnCounter() {\n+}\n+\n+/**\n+Increment the transaction counter and return the new value.\n+\n+@returns the next transaction id\n+*/\n+long ClientTxnCounter::next() {  // would be nice to remove lock from here, look more into it\n+  boost::lock_guard<boost::mutex> lock(mutex);\n+\n+  long next= ++counter; \n+\n+  return next;\n+}\n+\n+ClientImplPtr ClientImpl::Create(const Configuration& conf) {\n+  ClientImplPtr impl(new ClientImpl(conf));\n+  LOG4CXX_DEBUG(logger, \"Creating Clientimpl \" << impl);\n+\n+  impl->dispatcher.start();\n+\n+  return impl;\n+}\n+\n+void ClientImpl::Destroy() {\n+  LOG4CXX_DEBUG(logger, \"destroying Clientimpl \" << this);\n+\n+  dispatcher.stop();\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n+    \n+    shuttingDownFlag = true;\n+    for (ChannelMap::iterator iter = allchannels.begin(); iter != allchannels.end(); ++iter ) {\n+      (*iter)->kill();\n+    }  \n+    allchannels.clear();\n+  }\n+\n+  /* destruction of the maps will clean up any items they hold */\n+  \n+  if (subscriber != NULL) {\n+    delete subscriber;\n+    subscriber = NULL;\n+  }\n+  if (publisher != NULL) {\n+    delete publisher;\n+    publisher = NULL;\n+  }\n+}\n+\n+ClientImpl::ClientImpl(const Configuration& conf) \n+  : conf(conf), publisher(NULL), subscriber(NULL), counterobj(), shuttingDownFlag(false)\n+{\n+}\n+\n+Subscriber& ClientImpl::getSubscriber() {\n+  return getSubscriberImpl();\n+}\n+\n+Publisher& ClientImpl::getPublisher() {\n+  return getPublisherImpl();\n+}\n+    \n+SubscriberImpl& ClientImpl::getSubscriberImpl() {\n+  if (subscriber == NULL) {\n+    boost::lock_guard<boost::mutex> lock(subscribercreate_lock);\n+    if (subscriber == NULL) {\n+      subscriber = new SubscriberImpl(shared_from_this());\n+    }\n+  }\n+  return *subscriber;\n+}\n+\n+PublisherImpl& ClientImpl::getPublisherImpl() {\n+  if (publisher == NULL) { \n+    boost::lock_guard<boost::mutex> lock(publishercreate_lock);\n+    if (publisher == NULL) {\n+      publisher = new PublisherImpl(shared_from_this());\n+    }\n+  }\n+  return *publisher;\n+}\n+\n+ClientTxnCounter& ClientImpl::counter() {\n+  return counterobj;\n+}\n+\n+void ClientImpl::redirectRequest(const DuplexChannelPtr& channel, PubSubDataPtr& data, const PubSubResponsePtr& response) {\n+  HostAddress oldhost = channel->getHostAddress();\n+  data->addTriedServer(oldhost);\n+  \n+  HostAddress h = HostAddress::fromString(response->statusmsg());\n+  if (data->hasTriedServer(h)) {\n+    LOG4CXX_ERROR(logger, \"We've been told to try request [\" << data->getTxnId() << \"] with [\" \n+\t\t  << h.getAddressString()<< \"] by \" << oldhost.getAddressString() \n+\t\t  << \" but we've already tried that. Failing operation\");\n+    data->getCallback()->operationFailed(InvalidRedirectException());\n+    return;\n+  }\n+  LOG4CXX_DEBUG(logger, \"We've been told  [\" << data->getTopic() << \"] is on [\" << h.getAddressString() \n+\t\t<< \"] by [\" << oldhost.getAddressString() << \"]. Redirecting request \" << data->getTxnId());\n+  data->setShouldClaim(true);\n+\n+  setHostForTopic(data->getTopic(), h);\n+  DuplexChannelPtr newchannel;\n+  try {\n+    if (data->getType() == SUBSCRIBE) {\n+      SubscriberClientChannelHandlerPtr handler(new SubscriberClientChannelHandler(shared_from_this(), \n+\t\t\t\t\t\t\t\t\t\t   this->getSubscriberImpl(), data));\n+      newchannel = createChannel(data->getTopic(), handler);\n+      handler->setChannel(newchannel);\n+      getSubscriberImpl().doSubscribe(newchannel, data, handler);\n+    } else if (data->getType() == PUBLISH) {\n+      newchannel = getChannel(data->getTopic());\n+      getPublisherImpl().doPublish(newchannel, data);\n+    } else {\n+      newchannel = getChannel(data->getTopic());\n+      getSubscriberImpl().doUnsubscribe(newchannel, data);\n+    }\n+  } catch (ShuttingDownException& e) {\n+    return; // no point in redirecting if we're shutting down\n+  }\n+}\n+\n+ClientImpl::~ClientImpl() {\n+  LOG4CXX_DEBUG(logger, \"deleting Clientimpl \" << this);\n+}\n+\n+DuplexChannelPtr ClientImpl::createChannel(const std::string& topic, const ChannelHandlerPtr& handler) {\n+  // get the host address\n+  // create a channel to the host\n+  HostAddress addr = topic2host[topic];\n+  if (addr.isNullHost()) {\n+    addr = HostAddress::fromString(conf.get(Configuration::DEFAULT_SERVER, DEFAULT_SERVER_DEFAULT_VAL));\n+    setHostForTopic(topic, addr);\n+  }\n+\n+  DuplexChannelPtr channel(new DuplexChannel(dispatcher, addr, conf, handler));\n+\n+  boost::lock_guard<boost::shared_mutex> lock(allchannels_lock);\n+  if (shuttingDownFlag) {\n+    channel->kill();\n+    throw ShuttingDownException();\n+  }\n+  channel->connect();\n+\n+  allchannels.insert(channel);\n+  LOG4CXX_DEBUG(logger, \"(create) All channels size: \" << allchannels.size());\n+\n+  return channel;\n+}\n+\n+DuplexChannelPtr ClientImpl::getChannel(const std::string& topic) {\n+  HostAddress addr = topic2host[topic];\n+  if (addr.isNullHost()) {\n+    addr = HostAddress::fromString(conf.get(Configuration::DEFAULT_SERVER, DEFAULT_SERVER_DEFAULT_VAL));\n+    setHostForTopic(topic, addr);\n+  }  \n+  DuplexChannelPtr channel = host2channel[addr];\n+\n+  if (channel.get() == 0) {\n+    LOG4CXX_DEBUG(logger, \" No channel for topic, creating new channel.get() \" << channel.get() << \" addr \" << addr.getAddressString());\n+    ChannelHandlerPtr handler(new HedwigClientChannelHandler(shared_from_this()));\n+    channel = createChannel(topic, handler);\n+\n+    boost::lock_guard<boost::shared_mutex> lock(host2channel_lock);\n+    host2channel[addr] = channel;\n+  } \n+\n+  return channel;\n+}\n+\n+void ClientImpl::setHostForTopic(const std::string& topic, const HostAddress& host) {\n+  boost::lock_guard<boost::shared_mutex> lock(topic2host_lock);\n+  topic2host[topic] = host;\n+}\n+\n+bool ClientImpl::shuttingDown() const {\n+  return shuttingDownFlag;\n+}\n+\n+/**\n+   A channel has just died. Remove it so we never give it to any other publisher or subscriber.\n+   \n+   This does not delete the channel. Some publishers or subscribers will still hold it and will be errored\n+   when they try to do anything with it. \n+*/\n+void ClientImpl::channelDied(const DuplexChannelPtr& channel) {\n+  if (shuttingDownFlag) {\n+    return;\n+  }\n+\n+  boost::lock_guard<boost::shared_mutex> h2tlock(host2topics_lock);\n+  boost::lock_guard<boost::shared_mutex> h2clock(host2channel_lock);\n+  boost::lock_guard<boost::shared_mutex> t2hlock(topic2host_lock);\n+  boost::lock_guard<boost::shared_mutex> aclock(allchannels_lock);\n+  // get host\n+  HostAddress addr = channel->getHostAddress();\n+  \n+  for (Host2TopicsMap::iterator iter = host2topics.find(addr); iter != host2topics.end(); ++iter) {\n+    topic2host.erase((*iter).second);\n+  }\n+  host2topics.erase(addr);\n+  host2channel.erase(addr);\n+\n+  allchannels.erase(channel); // channel should be deleted here\n+}\n+\n+const Configuration& ClientImpl::getConfiguration() {\n+  return conf;\n+}\n+\n+boost::asio::io_service& ClientImpl::getService() {\n+  return dispatcher.getService();\n+}"},{"sha":"22451b0dd6f536d03b506e4ac5d16c9100120ceb","filename":"hedwig-client/src/main/cpp/lib/clientimpl.h","status":"added","additions":150,"deletions":0,"changes":150,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/clientimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/clientimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/clientimpl.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,150 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#ifndef HEDWIG_CLIENT_IMPL_H\n+#define HEDWIG_CLIENT_IMPL_H\n+\n+#include <hedwig/client.h>\n+#include <hedwig/protocol.h>\n+\n+#include <boost/asio.hpp>\n+#include <boost/shared_ptr.hpp>\n+#include <boost/enable_shared_from_this.hpp>\n+#include <boost/thread/mutex.hpp>\n+#include <boost/thread/condition_variable.hpp>\n+\n+#include <tr1/unordered_map>\n+#include <list>\n+\n+#include \"util.h\"\n+#include \"channel.h\"\n+#include \"data.h\"\n+#include \"eventdispatcher.h\"\n+\n+namespace Hedwig {\n+  const int DEFAULT_SYNC_REQUEST_TIMEOUT = 5000;\n+\n+  class SyncOperationCallback : public OperationCallback {\n+  public:\n+  SyncOperationCallback(int timeout) : response(PENDING), timeout(timeout) {}\n+    virtual void operationComplete();\n+    virtual void operationFailed(const std::exception& exception);\n+    \n+    void wait();\n+    void throwExceptionIfNeeded();\n+    \n+  private:\n+    enum { \n+      PENDING, \n+      SUCCESS,\n+      NOCONNECT,\n+      SERVICEDOWN,\n+      NOT_SUBSCRIBED,\n+      ALREADY_SUBSCRIBED,\n+      TIMEOUT,\n+      UNKNOWN\n+    } response;\n+    \n+    boost::condition_variable cond;\n+    boost::mutex mut;\n+    int timeout;\n+  };\n+\n+  class HedwigClientChannelHandler : public ChannelHandler {\n+  public:\n+    HedwigClientChannelHandler(const ClientImplPtr& client);\n+    \n+    virtual void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m);\n+    virtual void channelConnected(const DuplexChannelPtr& channel);\n+    virtual void channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e);\n+    virtual void exceptionOccurred(const DuplexChannelPtr& channel, const std::exception& e);\n+    \n+  protected:\n+    const ClientImplPtr client;\n+  };\n+  \n+  class PublisherImpl;\n+  class SubscriberImpl;\n+  \n+  /**\n+     Implementation of the hedwig client. This class takes care of globals such as the topic->host map and the transaction id counter.\n+  */\n+  class ClientImpl : public boost::enable_shared_from_this<ClientImpl> {\n+  public:\n+    static ClientImplPtr Create(const Configuration& conf);\n+    void Destroy();\n+\n+    Subscriber& getSubscriber();\n+    Publisher& getPublisher();\n+\n+    ClientTxnCounter& counter();\n+\n+    void redirectRequest(const DuplexChannelPtr& channel, PubSubDataPtr& data, const PubSubResponsePtr& response);\n+\n+    const HostAddress& getHostForTopic(const std::string& topic);\n+\n+    //DuplexChannelPtr getChannelForTopic(const std::string& topic, OperationCallback& callback);\n+    //DuplexChannelPtr createChannelForTopic(const std::string& topic, ChannelHandlerPtr& handler, OperationCallback& callback);\n+    DuplexChannelPtr createChannel(const std::string& topic, const ChannelHandlerPtr& handler);    \n+    DuplexChannelPtr getChannel(const std::string& topic);\n+\n+    void setHostForTopic(const std::string& topic, const HostAddress& host);\n+\n+    void setChannelForHost(const HostAddress& address, const DuplexChannelPtr& channel);\n+    void channelDied(const DuplexChannelPtr& channel);\n+    bool shuttingDown() const;\n+    \n+    SubscriberImpl& getSubscriberImpl();\n+    PublisherImpl& getPublisherImpl();\n+\n+    const Configuration& getConfiguration();\n+    boost::asio::io_service& getService();\n+\n+    ~ClientImpl();\n+  private:\n+    ClientImpl(const Configuration& conf);\n+\n+    const Configuration& conf;\n+\n+    boost::mutex publishercreate_lock;\n+    PublisherImpl* publisher;\n+\n+    boost::mutex subscribercreate_lock;\n+    SubscriberImpl* subscriber;\n+\n+    ClientTxnCounter counterobj;\n+\n+    EventDispatcher dispatcher;\n+    \n+    typedef std::tr1::unordered_multimap<HostAddress, std::string, HostAddressHash > Host2TopicsMap;\n+    Host2TopicsMap host2topics;\n+    boost::shared_mutex host2topics_lock;\n+\n+    std::tr1::unordered_map<HostAddress, DuplexChannelPtr, HostAddressHash > host2channel;\n+    boost::shared_mutex host2channel_lock;\n+    std::tr1::unordered_map<std::string, HostAddress> topic2host;\n+    boost::shared_mutex topic2host_lock;\n+\n+    typedef std::tr1::unordered_set<DuplexChannelPtr, DuplexChannelPtrHash > ChannelMap;\n+    ChannelMap allchannels;\n+    boost::shared_mutex allchannels_lock;\n+\n+    bool shuttingDownFlag;\n+  };\n+};\n+#endif"},{"sha":"34a31259f3d7b19b95acbc60c9e19ad9c69e59d0","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <hedwig/protocol.h>\n+#include \"data.h\"\n+\n+#include <log4cxx/logger.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+PubSubDataPtr PubSubData::forPublishRequest(long txnid, const std::string& topic, const std::string& body, const OperationCallbackPtr& callback) {\n+  PubSubDataPtr ptr(new PubSubData());\n+  ptr->type = PUBLISH;\n+  ptr->txnid = txnid;\n+  ptr->topic = topic;\n+  ptr->body = body;\n+  ptr->callback = callback;\n+  return ptr;\n+}\n+\n+PubSubDataPtr PubSubData::forSubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback, SubscribeRequest::CreateOrAttach mode) {\n+  PubSubDataPtr ptr(new PubSubData());\n+  ptr->type = SUBSCRIBE;\n+  ptr->txnid = txnid;\n+  ptr->subscriberid = subscriberid;\n+  ptr->topic = topic;\n+  ptr->callback = callback;\n+  ptr->mode = mode;\n+  return ptr;  \n+}\n+\n+PubSubDataPtr PubSubData::forUnsubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback) {\n+  PubSubDataPtr ptr(new PubSubData());\n+  ptr->type = UNSUBSCRIBE;\n+  ptr->txnid = txnid;\n+  ptr->subscriberid = subscriberid;\n+  ptr->topic = topic;\n+  ptr->callback = callback;\n+  return ptr;  \n+}\n+\n+PubSubDataPtr PubSubData::forConsumeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const MessageSeqId msgid) {\n+  PubSubDataPtr ptr(new PubSubData());\n+  ptr->type = CONSUME;\n+  ptr->txnid = txnid;\n+  ptr->subscriberid = subscriberid;\n+  ptr->topic = topic;\n+  ptr->msgid = msgid;\n+  return ptr;  \n+}\n+\n+PubSubData::PubSubData() : shouldClaim(false) {  \n+}\n+\n+PubSubData::~PubSubData() {\n+}\n+\n+OperationType PubSubData::getType() const {\n+  return type;\n+}\n+\n+long PubSubData::getTxnId() const {\n+  return txnid;\n+}\n+\n+const std::string& PubSubData::getTopic() const {\n+  return topic;\n+}\n+\n+const std::string& PubSubData::getBody() const {\n+  return body;\n+}\n+\n+const MessageSeqId PubSubData::getMessageSeqId() const {\n+  return msgid;\n+}\n+\n+const PubSubRequestPtr PubSubData::getRequest() {\n+  PubSubRequestPtr request(new Hedwig::PubSubRequest());\n+  request->set_protocolversion(Hedwig::VERSION_ONE);\n+  request->set_type(type);\n+  request->set_txnid(txnid);\n+  if (shouldClaim) {\n+    request->set_shouldclaim(shouldClaim);\n+  }\n+  request->set_topic(topic);\n+    \n+  if (type == PUBLISH) {\n+    LOG4CXX_DEBUG(logger, \"Creating publish request\");\n+\n+    Hedwig::PublishRequest* pubreq = request->mutable_publishrequest();\n+    Hedwig::Message* msg = pubreq->mutable_msg();\n+    msg->set_body(body);\n+  } else if (type == SUBSCRIBE) {\n+    LOG4CXX_DEBUG(logger, \"Creating subscribe request\");\n+\n+    Hedwig::SubscribeRequest* subreq = request->mutable_subscriberequest();\n+    subreq->set_subscriberid(subscriberid);\n+    subreq->set_createorattach(mode);\n+  } else if (type == CONSUME) {\n+    LOG4CXX_DEBUG(logger, \"Creating consume request\");\n+\n+    Hedwig::ConsumeRequest* conreq = request->mutable_consumerequest();\n+    conreq->set_subscriberid(subscriberid);\n+    conreq->mutable_msgid()->CopyFrom(msgid);\n+  } else if (type == UNSUBSCRIBE) {\n+    LOG4CXX_DEBUG(logger, \"Creating unsubscribe request\");\n+    \n+    Hedwig::UnsubscribeRequest* unsubreq = request->mutable_unsubscriberequest();\n+    unsubreq->set_subscriberid(subscriberid);    \n+  } else {\n+    LOG4CXX_ERROR(logger, \"Tried to create a request message for the wrong type [\" << type << \"]\");\n+    throw UnknownRequestException();\n+  }\n+\n+  return request;\n+}\n+\n+void PubSubData::setShouldClaim(bool shouldClaim) {\n+  this->shouldClaim = shouldClaim;\n+}\n+\n+void PubSubData::addTriedServer(HostAddress& h) {\n+  triedservers.insert(h);\n+}\n+\n+bool PubSubData::hasTriedServer(HostAddress& h) {\n+  return triedservers.count(h) > 0;\n+}\n+\n+void PubSubData::clearTriedServers() {\n+  triedservers.clear();\n+}\n+\n+OperationCallbackPtr& PubSubData::getCallback() {\n+  return callback;\n+}\n+\n+void PubSubData::setCallback(const OperationCallbackPtr& callback) {\n+  this->callback = callback;\n+}\n+\n+const std::string& PubSubData::getSubscriberId() const {\n+  return subscriberid;\n+}\n+\n+SubscribeRequest::CreateOrAttach PubSubData::getMode() const {\n+  return mode;\n+}"},{"sha":"3d5fe5fc35df1611d619e0cbd6193197f8b95921","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"added","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#ifndef DATA_H\n+#define DATA_H\n+\n+#include <hedwig/protocol.h>\n+#include <hedwig/callback.h>\n+\n+#include <pthread.h>\n+#include <tr1/unordered_set>\n+#include \"util.h\"\n+#include <boost/shared_ptr.hpp>\n+#include <boost/thread/mutex.hpp>\n+\n+namespace Hedwig {\n+  /**\n+     Simple counter for transaction ids from the client\n+  */\n+  class ClientTxnCounter {\n+  public:\n+    ClientTxnCounter();\n+    ~ClientTxnCounter();\n+    long next();\n+    \n+  private:\n+    long counter;\n+    boost::mutex mutex;\n+  };\n+\n+  class PubSubData;\n+  typedef boost::shared_ptr<PubSubData> PubSubDataPtr;\n+  typedef boost::shared_ptr<PubSubRequest> PubSubRequestPtr;\n+  typedef boost::shared_ptr<PubSubResponse> PubSubResponsePtr;\n+\n+  /**\n+     Data structure to hold information about requests and build request messages.\n+     Used to store requests which may need to be resent to another server. \n+   */\n+  class PubSubData {\n+  public:\n+    // to be used for publish\n+    static PubSubDataPtr forPublishRequest(long txnid, const std::string& topic, const std::string& body, const OperationCallbackPtr& callback);\n+    static PubSubDataPtr forSubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback, SubscribeRequest::CreateOrAttach mode);\n+    static PubSubDataPtr forUnsubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback);\n+    static PubSubDataPtr forConsumeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const MessageSeqId msgid);\n+\n+    ~PubSubData();\n+\n+    OperationType getType() const;\n+    long getTxnId() const;\n+    const std::string& getSubscriberId() const;\n+    const std::string& getTopic() const;\n+    const std::string& getBody() const;\n+    const MessageSeqId getMessageSeqId() const;\n+\n+    void setShouldClaim(bool shouldClaim);\n+\n+    const PubSubRequestPtr getRequest();\n+    void setCallback(const OperationCallbackPtr& callback);\n+    OperationCallbackPtr& getCallback();\n+    SubscribeRequest::CreateOrAttach getMode() const;\n+\n+    void addTriedServer(HostAddress& h);\n+    bool hasTriedServer(HostAddress& h);\n+    void clearTriedServers();\n+  private:\n+\n+    PubSubData();\n+    \n+    OperationType type;\n+    long txnid;\n+    std::string subscriberid;\n+    std::string topic;\n+    std::string body;\n+    bool shouldClaim;\n+    OperationCallbackPtr callback;\n+    SubscribeRequest::CreateOrAttach mode;\n+    MessageSeqId msgid;\n+    std::tr1::unordered_set<HostAddress, HostAddressHash > triedservers;\n+  };\n+  \n+};\n+#endif"},{"sha":"47a87bd1383c074a2b22dd52bf523b9fbbcb6d0b","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,72 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"eventdispatcher.h\"\n+\n+#include <log4cxx/logger.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+EventDispatcher::EventDispatcher() : service(), dummy_work(NULL), t(NULL) {\n+}\n+\n+void EventDispatcher::run_forever() {\n+  LOG4CXX_DEBUG(logger, \"Starting event dispatcher\");\n+\n+  while (true) {\n+    try {\n+      service.run();\n+      break;\n+    } catch (std::exception &e) {\n+    LOG4CXX_ERROR(logger, \"Exception in dispatch handler. \" << e.what());\n+    }\n+  }\n+  LOG4CXX_DEBUG(logger, \"Event dispatcher done\");\n+}\n+\n+void EventDispatcher::start() {\n+  if (t) {\n+    return;\n+  }\n+  dummy_work = new boost::asio::io_service::work(service);\n+  t = new boost::thread(boost::bind(&EventDispatcher::run_forever, this));\n+}\n+\n+void EventDispatcher::stop() {\n+  if (!t) {\n+    return;\n+  }\n+  delete dummy_work;\n+  dummy_work = NULL;\n+  \n+  service.stop();\n+  \n+  t->join();\n+  delete t;\n+  t = NULL;\n+}\n+\n+EventDispatcher::~EventDispatcher() {\n+  delete dummy_work;\n+}\n+\n+boost::asio::io_service& EventDispatcher::getService() {\n+  return service;\n+}"},{"sha":"192dbf5f21a7489aa7e89c8ab1ad3bab38c25f80","filename":"hedwig-client/src/main/cpp/lib/eventdispatcher.h","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/eventdispatcher.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/eventdispatcher.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/eventdispatcher.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef EVENTDISPATCHER_H\n+#define EVENTDISPATCHER_H\n+\n+#include <boost/asio.hpp>\n+#include <boost/thread.hpp>\n+\n+namespace Hedwig {\n+  class EventDispatcher {\n+  public:  \n+    EventDispatcher();\n+    ~EventDispatcher();\n+    \n+    void start();\n+    void stop();\n+    \n+    boost::asio::io_service& getService();\n+    \n+  private:\n+    void run_forever();\n+\n+    boost::asio::io_service service;\n+    boost::asio::io_service::work* dummy_work;\n+    boost::thread* t;\n+  };\n+}\n+\n+#endif"},{"sha":"b46178a901323b4efc39cbfc62a88b7d287ff905","filename":"hedwig-client/src/main/cpp/lib/exceptions.cpp","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/exceptions.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/exceptions.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/exceptions.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <hedwig/exceptions.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+using namespace Hedwig;\n+\n+\n+\n+  "},{"sha":"2573664d30e2fa719f625b7104ef8307533570f2","filename":"hedwig-client/src/main/cpp/lib/publisherimpl.cpp","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/publisherimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/publisherimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/publisherimpl.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,83 @@\n+ /**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"publisherimpl.h\"\n+#include \"channel.h\"\n+\n+#include <log4cxx/logger.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+PublishWriteCallback::PublishWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n+\n+void PublishWriteCallback::operationComplete() {\n+  LOG4CXX_DEBUG(logger, \"Successfully wrote transaction: \" << data->getTxnId());\n+}\n+\n+void PublishWriteCallback::operationFailed(const std::exception& exception) {\n+  LOG4CXX_ERROR(logger, \"Error writing to publisher \" << exception.what());\n+  \n+  data->getCallback()->operationFailed(exception);\n+}\n+\n+PublisherImpl::PublisherImpl(const ClientImplPtr& client) \n+  : client(client) {\n+}\n+\n+void PublisherImpl::publish(const std::string& topic, const std::string& message) {\n+  SyncOperationCallback* cb = new SyncOperationCallback(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n+\t\t\t\t\t\t\t\t\t\t\t  DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  OperationCallbackPtr callback(cb);\n+  asyncPublish(topic, message, callback);\n+  cb->wait();\n+  \n+  cb->throwExceptionIfNeeded();  \n+}\n+\n+void PublisherImpl::asyncPublish(const std::string& topic, const std::string& message, const OperationCallbackPtr& callback) {\n+  // use release after callback to release the channel after the callback is called\n+  PubSubDataPtr data = PubSubData::forPublishRequest(client->counter().next(), topic, message, callback);\n+  \n+  DuplexChannelPtr channel = client->getChannel(topic);\n+  doPublish(channel, data);\n+}\n+\n+void PublisherImpl::doPublish(const DuplexChannelPtr& channel, const PubSubDataPtr& data) {\n+  channel->storeTransaction(data);\n+  \n+  OperationCallbackPtr writecb(new PublishWriteCallback(client, data));\n+  channel->writeRequest(data->getRequest(), writecb);\n+}\n+\n+void PublisherImpl::messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn) {\n+  switch (m->statuscode()) {\n+  case SUCCESS:\n+    txn->getCallback()->operationComplete();\n+    break;\n+  case SERVICE_DOWN:\n+    LOG4CXX_ERROR(logger, \"Server responsed with SERVICE_DOWN for \" << txn->getTxnId());\n+    txn->getCallback()->operationFailed(ServiceDownException());\n+    break;\n+  default:\n+    LOG4CXX_ERROR(logger, \"Unexpected response \" << m->statuscode() << \" for \" << txn->getTxnId());\n+    txn->getCallback()->operationFailed(UnexpectedResponseException());\n+    break;\n+  }\n+}"},{"sha":"1620ab9099bb3460982a462ea6579592b692e451","filename":"hedwig-client/src/main/cpp/lib/publisherimpl.h","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/publisherimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/publisherimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/publisherimpl.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef PUBLISHER_IMPL_H\n+#define PUBLISHER_IMPL_H\n+\n+#include <hedwig/publish.h>\n+#include <hedwig/callback.h>\n+#include \"clientimpl.h\"\n+\n+namespace Hedwig {\n+  class PublishWriteCallback : public OperationCallback {\n+  public:\n+    PublishWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n+\n+    void operationComplete();\n+    void operationFailed(const std::exception& exception);\n+  private:\n+    ClientImplPtr client;\n+    PubSubDataPtr data;\n+  };\n+\n+  class PublisherImpl : public Publisher {\n+  public:\n+    PublisherImpl(const ClientImplPtr& client);\n+\n+    void publish(const std::string& topic, const std::string& message);\n+    void asyncPublish(const std::string& topic, const std::string& message, const OperationCallbackPtr& callback);\n+    \n+    void messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn);\n+\n+    void doPublish(const DuplexChannelPtr& channel, const PubSubDataPtr& data);\n+\n+  private:\n+    ClientImplPtr client;\n+  };\n+\n+};\n+\n+#endif"},{"sha":"25219318341430bff8ac56fcc5778ff1fec9a223","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"added","additions":434,"deletions":0,"changes":434,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,434 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"subscriberimpl.h\"\n+#include \"util.h\"\n+#include \"channel.h\"\n+\n+#include <boost/asio.hpp>\n+#include <boost/date_time/posix_time/posix_time.hpp>\n+\n+#include <log4cxx/logger.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+const int DEFAULT_MESSAGE_CONSUME_RETRY_WAIT_TIME = 5000;\n+const int DEFAULT_SUBSCRIBER_CONSUME_RETRY_WAIT_TIME = 5000;\n+const int DEFAULT_MAX_MESSAGE_QUEUE_SIZE = 10;\n+const int DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME = 5000;\n+const bool DEFAULT_SUBSCRIBER_AUTOCONSUME = true;\n+\n+SubscriberWriteCallback::SubscriberWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n+\n+void SubscriberWriteCallback::operationComplete() {\n+  LOG4CXX_DEBUG(logger, \"Successfully wrote subscribe transaction: \" << data->getTxnId());\n+}\n+\n+void SubscriberWriteCallback::operationFailed(const std::exception& exception) {\n+  LOG4CXX_ERROR(logger, \"Error writing to subscriber \" << exception.what());\n+  \n+  //remove txn from channel pending list\n+  data->getCallback()->operationFailed(exception);\n+  client->getSubscriberImpl().closeSubscription(data->getTopic(), data->getSubscriberId());\n+}\n+\n+UnsubscribeWriteCallback::UnsubscribeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n+\n+void UnsubscribeWriteCallback::operationComplete() {\n+  LOG4CXX_DEBUG(logger, \"Successfully wrote unsubscribe transaction: \" << data->getTxnId());\n+}\n+\n+void UnsubscribeWriteCallback::operationFailed(const std::exception& exception) {\n+  data->getCallback()->operationFailed(exception);\n+}\n+  \n+ConsumeWriteCallback::ConsumeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) \n+  : client(client), data(data) {\n+}\n+\n+ConsumeWriteCallback::~ConsumeWriteCallback() {\n+}\n+\n+/* static */ void ConsumeWriteCallback::timerComplete(const ClientImplPtr& client, const PubSubDataPtr& data,\n+\t\t\t\t\t\t      const boost::system::error_code& error) {\n+  if (error) {\n+    // shutting down\n+    return;\n+  }\n+\n+  client->getSubscriberImpl().consume(data->getTopic(), data->getSubscriberId(), data->getMessageSeqId());\n+}\n+\n+\n+void ConsumeWriteCallback::operationComplete() {\n+  LOG4CXX_DEBUG(logger, \"Successfully wrote consume transaction: \" << data->getTxnId());\n+}\n+\n+void ConsumeWriteCallback::operationFailed(const std::exception& exception) {\n+  int retrywait = client->getConfiguration().getInt(Configuration::MESSAGE_CONSUME_RETRY_WAIT_TIME, \n+\t\t\t\t\t\t    DEFAULT_MESSAGE_CONSUME_RETRY_WAIT_TIME);\n+  LOG4CXX_ERROR(logger, \"Error writing consume transaction: \" << data->getTxnId() << \" error: \" << exception.what() \n+\t\t<< \" retrying in \" << retrywait << \" Microseconds\");\n+\n+  boost::asio::deadline_timer t(client->getService(), boost::posix_time::milliseconds(retrywait));\n+\n+  t.async_wait(boost::bind(&ConsumeWriteCallback::timerComplete, client, data, boost::asio::placeholders::error));  \n+}\n+\n+SubscriberConsumeCallback::SubscriberConsumeCallback(const ClientImplPtr& client, \n+\t\t\t\t\t\t     const SubscriberClientChannelHandlerPtr& handler, \n+\t\t\t\t\t\t     const PubSubDataPtr& data, const PubSubResponsePtr& m) \n+  : client(client), handler(handler), data(data), m(m)\n+{\n+}\n+\n+void SubscriberConsumeCallback::operationComplete() {\n+  LOG4CXX_DEBUG(logger, \"ConsumeCallback::operationComplete \" << data->getTopic() << \" - \" << data->getSubscriberId());\n+\n+  if (client->getConfiguration().getBool(Configuration::SUBSCRIBER_AUTOCONSUME, DEFAULT_SUBSCRIBER_AUTOCONSUME)) {\n+    client->getSubscriber().consume(data->getTopic(), data->getSubscriberId(), m->message().msgid());\n+  }\n+}\n+\n+/* static */ void SubscriberConsumeCallback::timerComplete(const SubscriberClientChannelHandlerPtr handler, \n+\t\t\t\t\t\t\t   const PubSubResponsePtr m, \n+\t\t\t\t\t\t\t   const boost::system::error_code& error) {\n+  if (error) {\n+    return;\n+  }\n+  handler->messageReceived(handler->getChannel(), m);\n+}\n+\n+void SubscriberConsumeCallback::operationFailed(const std::exception& exception) {\n+  LOG4CXX_ERROR(logger, \"ConsumeCallback::operationFailed  \" << data->getTopic() << \" - \" << data->getSubscriberId());\n+  \n+  int retrywait = client->getConfiguration().getInt(Configuration::SUBSCRIBER_CONSUME_RETRY_WAIT_TIME,\n+\t\t\t\t\t\t    DEFAULT_SUBSCRIBER_CONSUME_RETRY_WAIT_TIME);\n+\n+  LOG4CXX_ERROR(logger, \"Error passing message to client transaction: \" << data->getTxnId() << \" error: \" << exception.what() \n+\t\t<< \" retrying in \" << retrywait << \" Microseconds\");\n+\n+  boost::asio::deadline_timer t(client->getService(), boost::posix_time::milliseconds(retrywait));\n+\n+  t.async_wait(boost::bind(&SubscriberConsumeCallback::timerComplete, handler, m, boost::asio::placeholders::error));  \n+}\n+\n+SubscriberReconnectCallback::SubscriberReconnectCallback(const ClientImplPtr& client, const PubSubDataPtr& origData) \n+  : client(client), origData(origData) {\n+}\n+\n+void SubscriberReconnectCallback::operationComplete() {\n+}\n+\n+void SubscriberReconnectCallback::operationFailed(const std::exception& exception) {\n+  LOG4CXX_ERROR(logger, \"Error writing to new subscriber. Channel should pick this up disconnect the channel and try to connect again \" << exception.what());\n+\n+}\n+\n+SubscriberClientChannelHandler::SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber, const PubSubDataPtr& data)\n+  : HedwigClientChannelHandler(client), subscriber(subscriber), origData(data), closed(false), should_wait(true)  {\n+  LOG4CXX_DEBUG(logger, \"Creating SubscriberClientChannelHandler \" << this);\n+}\n+\n+SubscriberClientChannelHandler::~SubscriberClientChannelHandler() {\n+  LOG4CXX_DEBUG(logger, \"Cleaning up SubscriberClientChannelHandler \" << this);\n+}\n+\n+void SubscriberClientChannelHandler::messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m) {\n+  if (m->has_message()) {\n+    LOG4CXX_DEBUG(logger, \"Message received (topic:\" << origData->getTopic() << \", subscriberId:\" << origData->getSubscriberId() << \")\");\n+\n+    if (this->handler.get()) {\n+      OperationCallbackPtr callback(new SubscriberConsumeCallback(client, shared_from_this(), origData, m));\n+      this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n+    } else {\n+      queue.push_back(m);\n+      if (queue.size() >= (std::size_t)client->getConfiguration().getInt(Configuration::MAX_MESSAGE_QUEUE_SIZE,\n+\t\t\t\t\t\t\t\t\t DEFAULT_MAX_MESSAGE_QUEUE_SIZE)) {\n+\tchannel->stopReceiving();\n+      }\n+    }\n+  } else {\n+    HedwigClientChannelHandler::messageReceived(channel, m);\n+  }\n+}\n+\n+void SubscriberClientChannelHandler::close() {\n+  closed = true;\n+\n+  if (channel) {\n+    channel->kill();\n+  }\n+}\n+\n+/*static*/ void SubscriberClientChannelHandler::reconnectTimerComplete(const SubscriberClientChannelHandlerPtr handler,\n+\t\t\t\t\t\t\t\t       const DuplexChannelPtr channel, const std::exception e, \n+\t\t\t\t\t\t\t\t       const boost::system::error_code& error) {\n+  if (error) {\n+    return;\n+  }\n+  handler->should_wait = false;\n+  handler->channelDisconnected(channel, e);\n+}\n+\n+void SubscriberClientChannelHandler::channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e) {\n+  // has subscription been closed\n+  if (closed) {\n+    return;\n+  }\n+\n+  // Clean up the channel from all maps\n+  client->channelDied(channel);\n+  if (client->shuttingDown()) {\n+    return;\n+  }\n+\n+  if (should_wait) {\n+    int retrywait = client->getConfiguration().getInt(Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME,\n+\t\t\t\t\t\t      DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME);\n+    \n+    boost::asio::deadline_timer t(client->getService(), boost::posix_time::milliseconds(retrywait));\n+    t.async_wait(boost::bind(&SubscriberClientChannelHandler::reconnectTimerComplete, shared_from_this(), \n+\t\t\t     channel, e, boost::asio::placeholders::error));  \n+    return;\n+  }\n+  should_wait = true;\n+\n+  // setup pubsub data for reconnection attempt\n+  origData->clearTriedServers();\n+  OperationCallbackPtr newcallback(new SubscriberReconnectCallback(client, origData));\n+  origData->setCallback(newcallback);\n+\n+  // Create a new handler for the new channel\n+  SubscriberClientChannelHandlerPtr newhandler(new SubscriberClientChannelHandler(client, subscriber, origData));  \n+  ChannelHandlerPtr baseptr = newhandler;\n+  \n+  DuplexChannelPtr newchannel = client->createChannel(origData->getTopic(), baseptr);\n+  newhandler->setChannel(newchannel);\n+  handoverDelivery(newhandler);\n+  \n+  // remove record of the failed channel from the subscriber\n+  client->getSubscriberImpl().closeSubscription(origData->getTopic(), origData->getSubscriberId());\n+  \n+  // subscriber\n+  client->getSubscriberImpl().doSubscribe(newchannel, origData, newhandler);\n+}\n+\n+void SubscriberClientChannelHandler::startDelivery(const MessageHandlerCallbackPtr& handler) {\n+  this->handler = handler;\n+  \n+  while (!queue.empty()) {    \n+    PubSubResponsePtr m = queue.front();\n+    queue.pop_front();\n+\n+    OperationCallbackPtr callback(new SubscriberConsumeCallback(client, shared_from_this(), origData, m));\n+\n+    this->handler->consume(origData->getTopic(), origData->getSubscriberId(), m->message(), callback);\n+  }\n+  channel->startReceiving();\n+}\n+\n+void SubscriberClientChannelHandler::stopDelivery() {\n+  channel->stopReceiving();\n+\n+  this->handler = MessageHandlerCallbackPtr();\n+}\n+\n+\n+void SubscriberClientChannelHandler::handoverDelivery(const SubscriberClientChannelHandlerPtr& newHandler) {\n+  LOG4CXX_DEBUG(logger, \"Messages in queue \" << queue.size());\n+  MessageHandlerCallbackPtr handler = this->handler;\n+  stopDelivery(); // resets old handler\n+  newHandler->startDelivery(handler);\n+}\n+\n+void SubscriberClientChannelHandler::setChannel(const DuplexChannelPtr& channel) {\n+  this->channel = channel;\n+}\n+\n+DuplexChannelPtr& SubscriberClientChannelHandler::getChannel() {\n+  return channel;\n+}\n+\n+SubscriberImpl::SubscriberImpl(const ClientImplPtr& client) \n+  : client(client) \n+{\n+}\n+\n+SubscriberImpl::~SubscriberImpl() \n+{\n+  LOG4CXX_DEBUG(logger, \"deleting subscriber\" << this);\n+}\n+\n+\n+void SubscriberImpl::subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode) {\n+  SyncOperationCallback* cb = new SyncOperationCallback(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n+\t\t\t\t\t\t\t\t\t\t\t  DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  OperationCallbackPtr callback(cb);\n+  asyncSubscribe(topic, subscriberId, mode, callback);\n+  cb->wait();\n+  \n+  cb->throwExceptionIfNeeded();  \n+}\n+\n+void SubscriberImpl::asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback) {\n+  PubSubDataPtr data = PubSubData::forSubscribeRequest(client->counter().next(), subscriberId, topic, callback, mode);\n+\n+  SubscriberClientChannelHandlerPtr handler(new SubscriberClientChannelHandler(client, *this, data));\n+  ChannelHandlerPtr baseptr = handler;\n+\n+  DuplexChannelPtr channel = client->createChannel(topic, handler);\n+  handler->setChannel(channel);\n+  doSubscribe(channel, data, handler);\n+}\n+\n+void SubscriberImpl::doSubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data, const SubscriberClientChannelHandlerPtr& handler) {\n+  channel->storeTransaction(data);\n+\n+  OperationCallbackPtr writecb(new SubscriberWriteCallback(client, data));\n+  channel->writeRequest(data->getRequest(), writecb);\n+\n+  boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+  TopicSubscriber t(data->getTopic(), data->getSubscriberId());\n+  SubscriberClientChannelHandlerPtr oldhandler = topicsubscriber2handler[t];\n+  if (oldhandler != NULL) {\n+    oldhandler->handoverDelivery(handler);\n+  }\n+  topicsubscriber2handler[t] = handler;\n+  \n+  LOG4CXX_DEBUG(logger, \"Set topic subscriber for topic(\" << data->getTopic() << \") subscriberId(\" << data->getSubscriberId() << \") to \" << handler.get() << \" topicsubscriber2topic(\" << &topicsubscriber2handler << \")\");\n+}\n+\n+void SubscriberImpl::unsubscribe(const std::string& topic, const std::string& subscriberId) {\n+  SyncOperationCallback* cb = new SyncOperationCallback(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n+\t\t\t\t\t\t\t\t\t\t\t  DEFAULT_SYNC_REQUEST_TIMEOUT));\n+  OperationCallbackPtr callback(cb);\n+  asyncUnsubscribe(topic, subscriberId, callback);\n+  cb->wait();\n+  \n+  cb->throwExceptionIfNeeded();\n+}\n+\n+void SubscriberImpl::asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback) {\n+  closeSubscription(topic, subscriberId);\n+\n+  PubSubDataPtr data = PubSubData::forUnsubscribeRequest(client->counter().next(), subscriberId, topic, callback);\n+  \n+  DuplexChannelPtr channel = client->getChannel(topic);\n+  doUnsubscribe(channel, data);\n+}\n+\n+void SubscriberImpl::doUnsubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data) {\n+  channel->storeTransaction(data);\n+  OperationCallbackPtr writecb(new UnsubscribeWriteCallback(client, data));\n+  channel->writeRequest(data->getRequest(), writecb);\n+}\n+\n+void SubscriberImpl::consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId) {\n+  TopicSubscriber t(topic, subscriberId);\n+  \n+  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+  SubscriberClientChannelHandlerPtr handler = topicsubscriber2handler[t];\n+\n+  if (handler.get() == 0) {\n+    LOG4CXX_ERROR(logger, \"Cannot consume. Bad handler for topic(\" << topic << \") subscriberId(\" << subscriberId << \") topicsubscriber2topic(\" << &topicsubscriber2handler << \")\");\n+    return;\n+  }\n+\n+  DuplexChannelPtr channel = handler->getChannel();\n+  if (channel.get() == 0) {\n+    LOG4CXX_ERROR(logger, \"Trying to consume a message on a topic/subscriber pair that don't have a channel. Something fishy going on. Topic: \" << topic << \" SubscriberId: \" << subscriberId << \" MessageSeqId: \" << messageSeqId.localcomponent());\n+  }\n+  \n+  PubSubDataPtr data = PubSubData::forConsumeRequest(client->counter().next(), subscriberId, topic, messageSeqId);  \n+  OperationCallbackPtr writecb(new ConsumeWriteCallback(client, data));\n+  channel->writeRequest(data->getRequest(), writecb);\n+}\n+\n+void SubscriberImpl::startDelivery(const std::string& topic, const std::string& subscriberId, const MessageHandlerCallbackPtr& callback) {\n+  TopicSubscriber t(topic, subscriberId);\n+\n+  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+  SubscriberClientChannelHandlerPtr handler = topicsubscriber2handler[t];\n+\n+  if (handler.get() == 0) {\n+    LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+  }\n+  handler->startDelivery(callback);\n+}\n+\n+void SubscriberImpl::stopDelivery(const std::string& topic, const std::string& subscriberId) {\n+  TopicSubscriber t(topic, subscriberId);\n+  \n+  boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+  SubscriberClientChannelHandlerPtr handler = topicsubscriber2handler[t];\n+\n+  if (handler.get() == 0) {\n+    LOG4CXX_ERROR(logger, \"Trying to start deliver on a non existant handler topic = \" << topic << \", subscriber = \" << subscriberId);\n+  }\n+  handler->stopDelivery();\n+}\n+\n+void SubscriberImpl::closeSubscription(const std::string& topic, const std::string& subscriberId) {\n+  LOG4CXX_DEBUG(logger, \"closeSubscription (\" << topic << \",  \" << subscriberId << \")\");\n+\n+  TopicSubscriber t(topic, subscriberId);\n+\n+  SubscriberClientChannelHandlerPtr handler;\n+  {\n+    boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n+    handler = topicsubscriber2handler[t];\n+    topicsubscriber2handler.erase(t);\n+  }\n+  \n+  if (handler.get() != 0) {\n+    handler->close();\n+  }\n+}\n+\n+/**\n+   takes ownership of txn\n+*/\n+void SubscriberImpl::messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn) {\n+  if (!txn.get()) {\n+    LOG4CXX_ERROR(logger, \"Invalid transaction\");\n+    return;\n+  }\n+\n+  LOG4CXX_DEBUG(logger, \"message received with status \" << m->statuscode());\n+\n+  switch (m->statuscode()) {\n+  case SUCCESS:\n+    txn->getCallback()->operationComplete();\n+    break;\n+  case SERVICE_DOWN:\n+    txn->getCallback()->operationFailed(ServiceDownException());\n+    break;\n+  case CLIENT_ALREADY_SUBSCRIBED:\n+  case TOPIC_BUSY:\n+    txn->getCallback()->operationFailed(AlreadySubscribedException());\n+    break;\n+  case CLIENT_NOT_SUBSCRIBED:\n+    txn->getCallback()->operationFailed(NotSubscribedException());\n+    break;\n+  default:\n+    txn->getCallback()->operationFailed(UnexpectedResponseException());\n+    break;\n+  }\n+}"},{"sha":"1412940fc0a2f7ff8459fbef42876d705ef37cec","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef SUBSCRIBE_IMPL_H\n+#define SUBSCRIBE_IMPL_H\n+\n+#include <hedwig/subscribe.h>\n+#include <hedwig/callback.h>\n+#include \"clientimpl.h\"\n+#include <utility>\n+#include <tr1/memory>\n+#include <deque>\n+\n+#include <boost/shared_ptr.hpp>\n+#include <boost/enable_shared_from_this.hpp>\n+#include <boost/thread/shared_mutex.hpp>\n+\n+namespace Hedwig {\n+  class SubscriberWriteCallback : public OperationCallback {\n+  public:\n+    SubscriberWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n+\n+    void operationComplete();\n+    void operationFailed(const std::exception& exception);\n+  private:\n+    const ClientImplPtr client;\n+    const PubSubDataPtr data;\n+  };\n+  \n+  class UnsubscribeWriteCallback : public OperationCallback {\n+  public:\n+    UnsubscribeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n+\n+    void operationComplete();\n+    void operationFailed(const std::exception& exception);\n+  private:\n+    const ClientImplPtr client;\n+    const PubSubDataPtr data;\n+  };\n+\n+  class ConsumeWriteCallback : public OperationCallback {\n+  public:\n+    ConsumeWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data);\n+    ~ConsumeWriteCallback();\n+\n+    void operationComplete();\n+    void operationFailed(const std::exception& exception);\n+    \n+    static void timerComplete(const ClientImplPtr& client, const PubSubDataPtr& data, const boost::system::error_code& error);\n+  private:\n+    const ClientImplPtr client;\n+    const PubSubDataPtr data;\n+    };\n+\n+  class SubscriberReconnectCallback : public OperationCallback {\n+  public: \n+    SubscriberReconnectCallback(const ClientImplPtr& client, const PubSubDataPtr& origData);\n+\n+    void operationComplete();\n+    void operationFailed(const std::exception& exception);\n+  private:\n+    const ClientImplPtr client;\n+    const PubSubDataPtr origData;\n+  };\n+\n+  class SubscriberClientChannelHandler;\n+  typedef boost::shared_ptr<SubscriberClientChannelHandler> SubscriberClientChannelHandlerPtr;\n+\n+  class SubscriberConsumeCallback : public OperationCallback {\n+  public: \n+    SubscriberConsumeCallback(const ClientImplPtr& client, const SubscriberClientChannelHandlerPtr& handler, const PubSubDataPtr& data, const PubSubResponsePtr& m);\n+\n+    void operationComplete();\n+    void operationFailed(const std::exception& exception);\n+    static void timerComplete(const SubscriberClientChannelHandlerPtr handler, \n+\t\t\t      const PubSubResponsePtr m, \n+\t\t\t      const boost::system::error_code& error);\n+\n+  private:\n+    const ClientImplPtr client;\n+    const SubscriberClientChannelHandlerPtr handler;\n+    \n+    const PubSubDataPtr data;\n+    const PubSubResponsePtr m;\n+  };\n+\n+  class SubscriberClientChannelHandler : public HedwigClientChannelHandler, \n+\t\t\t\t\t public boost::enable_shared_from_this<SubscriberClientChannelHandler> {\n+  public: \n+    SubscriberClientChannelHandler(const ClientImplPtr& client, SubscriberImpl& subscriber, const PubSubDataPtr& data);\n+    ~SubscriberClientChannelHandler();\n+\n+    void messageReceived(const DuplexChannelPtr& channel, const PubSubResponsePtr& m);\n+    void channelDisconnected(const DuplexChannelPtr& channel, const std::exception& e);\n+\n+    void startDelivery(const MessageHandlerCallbackPtr& handler);\n+    void stopDelivery();\n+\n+    void handoverDelivery(const SubscriberClientChannelHandlerPtr& newHandler);\n+\n+    void setChannel(const DuplexChannelPtr& channel);\n+    DuplexChannelPtr& getChannel();\n+\n+    static void reconnectTimerComplete(const SubscriberClientChannelHandlerPtr handler, const DuplexChannelPtr channel, const std::exception e, \n+\t\t\t\t       const boost::system::error_code& error);\n+\n+    void close();\n+  private:\n+\n+    SubscriberImpl& subscriber;\n+    std::deque<PubSubResponsePtr> queue;\n+    \n+    MessageHandlerCallbackPtr handler;\n+    PubSubDataPtr origData;\n+    DuplexChannelPtr channel;\n+    bool closed;\n+    bool should_wait;\n+  };\n+\n+  class SubscriberImpl : public Subscriber {\n+  public:\n+    SubscriberImpl(const ClientImplPtr& client);\n+    ~SubscriberImpl();\n+\n+    void subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode);\n+    void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback);\n+    \n+    void unsubscribe(const std::string& topic, const std::string& subscriberId);\n+    void asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback);\n+\n+    void consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId);\n+\n+    void startDelivery(const std::string& topic, const std::string& subscriberId, const MessageHandlerCallbackPtr& callback);\n+    void stopDelivery(const std::string& topic, const std::string& subscriberId);\n+\n+    void closeSubscription(const std::string& topic, const std::string& subscriberId);\n+\n+    void messageHandler(const PubSubResponsePtr& m, const PubSubDataPtr& txn);\n+\n+    void doSubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data, const SubscriberClientChannelHandlerPtr& handler);\n+    void doUnsubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data);\n+\n+  private:\n+    const ClientImplPtr client;\n+    \n+    std::tr1::unordered_map<TopicSubscriber, SubscriberClientChannelHandlerPtr, TopicSubscriberHash > topicsubscriber2handler;\n+    boost::shared_mutex topicsubscriber2handler_lock;\t    \n+  };\n+\n+};\n+\n+#endif"},{"sha":"0ae5a3eb08e53578930c178457aafe8db2177a55","filename":"hedwig-client/src/main/cpp/lib/util.cpp","status":"added","additions":141,"deletions":0,"changes":141,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/util.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/util.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,141 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#include <string>\n+\n+#include <netdb.h>\n+#include <errno.h>\n+#include \"util.h\"\n+#include \"channel.h\"\n+#include <log4cxx/logger.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace Hedwig;\n+\n+#define MAX_HOSTNAME_LENGTH 256\n+const std::string UNITIALISED_HOST(\"UNINITIALISED HOST\");\n+\n+const int DEFAULT_PORT = 4080;\n+const int DEFAULT_SSL_PORT = 9876;\n+\n+HostAddress::HostAddress() : initialised(false), address_str() {\n+  memset(&socket_addr, 0, sizeof(struct sockaddr_in));\n+}\n+\n+HostAddress::~HostAddress() {\n+}\n+\n+bool HostAddress::isNullHost() const {\n+  return !initialised;\n+}\n+\n+bool HostAddress::operator==(const HostAddress& other) const {\n+  return (other.ip() == ip() && other.port() == port());\n+}\n+\n+const std::string& HostAddress::getAddressString() const {\n+  if (!isNullHost()) {\n+    return address_str;\n+  } else {\n+    return UNITIALISED_HOST;\n+  }\n+}\n+   \n+uint32_t HostAddress::ip() const {\n+  return ntohl(socket_addr.sin_addr.s_addr);;\n+}\n+\n+uint16_t HostAddress::port() const {\n+  return ntohs(socket_addr.sin_port);\n+}\n+\n+const struct sockaddr_in& HostAddress::socketAddress() const {\n+  return socket_addr;\n+}\n+\n+\n+void HostAddress::parse_string() {\n+  char* url = strdup(address_str.c_str());\n+\n+  if (url == NULL) {\n+    LOG4CXX_ERROR(logger, \"You seems to be out of memory\");\n+    throw OomException();\n+  }\n+  int port = DEFAULT_PORT;\n+  int sslport = DEFAULT_SSL_PORT;\n+\n+  char *colon = strchr(url, ':');\n+  if (colon) {\n+    *colon = 0;\n+    colon++;\n+    \n+    char* sslcolon = strchr(colon, ':');\n+    if (sslcolon) {\n+      *sslcolon = 0;\n+      sslcolon++;\n+      \n+      sslport = strtol(sslcolon, NULL, 10);\n+      if (sslport == 0) {\n+        LOG4CXX_ERROR(logger, \"Invalid SSL port given: [\" << sslcolon << \"]\");\n+\tfree((void*)url);\n+\tthrow InvalidPortException();\n+      }\n+    }\n+    \n+    port = strtol(colon, NULL, 10);\n+    if (port == 0) {\n+      LOG4CXX_ERROR(logger, \"Invalid port given: [\" << colon << \"]\");\n+      free((void*)url);\n+      throw InvalidPortException();\n+    }\n+  }\n+\n+  int err = 0;\n+  \n+  struct addrinfo *addr;\n+  struct addrinfo hints;\n+\n+  memset(&hints, 0, sizeof(struct addrinfo));\n+  hints.ai_family = AF_INET;\n+\n+  err = getaddrinfo(url, NULL, &hints, &addr);\n+  if (err != 0) {\n+    LOG4CXX_ERROR(logger, \"Couldn't resolve host [\" << url << \"]:\" << hstrerror(err));\n+    free((void*)url);\n+    throw HostResolutionException();\n+  }\n+\n+  sockaddr_in* sa_ptr = (sockaddr_in*)addr->ai_addr;\n+  socket_addr = *sa_ptr;\n+  socket_addr.sin_port = htons(port); \n+  //socket_addr.sin_family = AF_INET;\n+\n+  free((void*)url);\n+  free((void*)addr);\n+}\n+\n+HostAddress HostAddress::fromString(std::string str) {\n+  HostAddress h;\n+  h.address_str = str;\n+  h.parse_string();\n+  h.initialised = true;\n+  return h;\n+}\n+"},{"sha":"79137e8de2c010839d33c89e1087f72f74e14725","filename":"hedwig-client/src/main/cpp/lib/util.h","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/lib/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/util.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,86 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#ifndef HEDWIG_UTIL_H\n+#define HEDWIG_UTIL_H\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <list>\n+#include <iostream>\n+#include <utility>\n+#include <tr1/functional>\n+#include <semaphore.h>\n+#include <pthread.h>\n+\n+namespace Hedwig {\n+  typedef std::pair<const std::string, const std::string> TopicSubscriber;\n+\n+  /**\n+     Representation of a hosts address\n+  */\n+  class HostAddress {\n+  public:\n+    HostAddress();\n+    ~HostAddress();\n+\n+    bool operator==(const HostAddress& other) const;\n+    \n+    bool isNullHost() const;\n+    const std::string& getAddressString() const;\n+    uint32_t ip() const;\n+    uint16_t port() const;\n+    const sockaddr_in& socketAddress() const;\n+\n+    static HostAddress fromString(std::string host);\n+\n+  private:\n+\n+    void parse_string();\n+    \n+    bool initialised;\n+    std::string address_str;\n+    struct sockaddr_in socket_addr;\n+  };\n+\n+  /**\n+     Hash a host address. Takes the least significant 16-bits of the address and the 16-bits of the\n+     port and packs them into one 32-bit number. While collisons are theoretically very possible, they\n+     shouldn't happen as the hedwig servers should be in the same subnet.\n+  */\n+  struct HostAddressHash : public std::unary_function<Hedwig::HostAddress, size_t> {\n+    size_t operator()(const Hedwig::HostAddress& address) const {\n+        return (address.ip() << 16) & (address.port());\n+    }\n+  };\n+\n+\n+  /**\n+     Hash a channel pointer, just returns the pointer.\n+  */\n+  struct TopicSubscriberHash : public std::unary_function<Hedwig::TopicSubscriber, size_t> {\n+    size_t operator()(const Hedwig::TopicSubscriber& topicsub) const {\n+      std::string fullstr = topicsub.first + topicsub.second;\n+      return std::tr1::hash<std::string>()(fullstr);\n+    }\n+  };\n+};\n+\n+#endif"},{"sha":"5651e25269f5e9962fd6bd0f1c1196127095dc56","filename":"hedwig-client/src/main/cpp/log4cpp.conf","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/log4cpp.conf","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/log4cpp.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/log4cpp.conf?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,49 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+log4j.appender.rootAppender=org.apache.log4j.ConsoleAppender\n+log4j.appender.rootAppender.layout=org.apache.log4j.BasicLayout\n+\n+#log4j.appender.hedwig=org.apache.log4j.RollingFileAppender\n+log4j.appender.hedwig=org.apache.log4j.ConsoleAppender\n+#log4j.appender.hedwig.fileName=./testLog.log\n+log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwig.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %c %p - %m%n\n+log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwig.layout.ConversionPattern=%.5m%n\n+\n+log4j.appender.hedwigtest=org.apache.log4j.ConsoleAppender\n+#log4j.appender.hedwig.fileName=./testLog.log\n+log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwigtest.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %c %p - %m%n\n+log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwigtest.layout.ConversionPattern=%.5m%n\n+\n+# category\n+log4j.category.hedwig=DEBUG, hedwig\n+log4j.rootCategory=DEBUG\n+\n+log4j.category.hedwig.channel=ERROR\n+log4j.category.hedwig.util=ERROR\n+log4j.category.hedwigtest.servercontrol=ERROR\n+\n+log4j.category.hedwigtest=DEBUG, hedwigtest\n+log4j.rootCategory=DEBUG"},{"sha":"8cc46662f6229fea2ccf523e19eb504af87aa66b","filename":"hedwig-client/src/main/cpp/m4/ax_boost_asio.m4","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_boost_asio.m4","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_boost_asio.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_boost_asio.m4?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,111 @@\n+# ===========================================================================\n+#       http://www.gnu.org/software/autoconf-archive/ax_boost_asio.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_BOOST_ASIO\n+#\n+# DESCRIPTION\n+#\n+#   Test for Asio library from the Boost C++ libraries. The macro requires a\n+#   preceding call to AX_BOOST_BASE. Further documentation is available at\n+#   <http://randspringer.de/boost/index.html>.\n+#\n+#   This macro calls:\n+#\n+#     AC_SUBST(BOOST_ASIO_LIB)\n+#\n+#   And sets:\n+#\n+#     HAVE_BOOST_ASIO\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Thomas Porschberg <thomas@randspringer.de>\n+#   Copyright (c) 2008 Pete Greenwell <pete@mu.org>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 9\n+\n+AC_DEFUN([AX_BOOST_ASIO],\n+[\n+\tAC_ARG_WITH([boost-asio],\n+\tAS_HELP_STRING([--with-boost-asio@<:@=special-lib@:>@],\n+                   [use the ASIO library from boost - it is possible to specify a certain library for the linker\n+                        e.g. --with-boost-asio=boost_system-gcc41-mt-1_34 ]),\n+        [\n+        if test \"$withval\" = \"no\"; then\n+\t\t\twant_boost=\"no\"\n+        elif test \"$withval\" = \"yes\"; then\n+            want_boost=\"yes\"\n+            ax_boost_user_asio_lib=\"\"\n+        else\n+\t\t    want_boost=\"yes\"\n+        \tax_boost_user_asio_lib=\"$withval\"\n+\t\tfi\n+        ],\n+        [want_boost=\"yes\"]\n+\t)\n+\n+\tif test \"x$want_boost\" = \"xyes\"; then\n+        AC_REQUIRE([AC_PROG_CC])\n+\t\tCPPFLAGS_SAVED=\"$CPPFLAGS\"\n+\t\tCPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n+\t\texport CPPFLAGS\n+\n+\t\tLDFLAGS_SAVED=\"$LDFLAGS\"\n+\t\tLDFLAGS=\"$LDFLAGS $BOOST_LDFLAGS\"\n+\t\texport LDFLAGS\n+\n+        AC_CACHE_CHECK(whether the Boost::ASIO library is available,\n+\t\t\t\t\t   ax_cv_boost_asio,\n+        [AC_LANG_PUSH([C++])\n+\t\t AC_COMPILE_IFELSE(AC_LANG_PROGRAM([[ @%:@include <boost/asio.hpp>\n+\t\t\t\t\t\t\t\t\t\t\t]],\n+                                  [[\n+\n+                                    boost::asio::io_service io;\n+                                    boost::system::error_code timer_result;\n+                                    boost::asio::deadline_timer t(io);\n+                                    t.cancel();\n+                                    io.run_one();\n+\t\t\t\t\t\t\t\t\treturn 0;\n+                                   ]]),\n+                             ax_cv_boost_asio=yes, ax_cv_boost_asio=no)\n+         AC_LANG_POP([C++])\n+\t\t])\n+\t\tif test \"x$ax_cv_boost_asio\" = \"xyes\"; then\n+\t\t\tAC_DEFINE(HAVE_BOOST_ASIO,,[define if the Boost::ASIO library is available])\n+\t\t\tBN=boost_system\n+            if test \"x$ax_boost_user_asio_lib\" = \"x\"; then\n+\t\t\t\tfor ax_lib in $BN $BN-$CC $BN-$CC-mt $BN-$CC-mt-s $BN-$CC-s \\\n+                              lib$BN lib$BN-$CC lib$BN-$CC-mt lib$BN-$CC-mt-s lib$BN-$CC-s \\\n+                              $BN-mgw $BN-mgw $BN-mgw-mt $BN-mgw-mt-s $BN-mgw-s ; do\n+\t\t\t\t    AC_CHECK_LIB($ax_lib, main, [BOOST_ASIO_LIB=\"-l$ax_lib\" AC_SUBST(BOOST_ASIO_LIB) link_thread=\"yes\" break],\n+                                 [link_thread=\"no\"])\n+  \t\t\t\tdone\n+            else\n+               for ax_lib in $ax_boost_user_asio_lib $BN-$ax_boost_user_asio_lib; do\n+\t\t\t\t      AC_CHECK_LIB($ax_lib, main,\n+                                   [BOOST_ASIO_LIB=\"-l$ax_lib\" AC_SUBST(BOOST_ASIO_LIB) link_asio=\"yes\" break],\n+                                   [link_asio=\"no\"])\n+                  done\n+\n+            fi\n+            if test \"x$ax_lib\" = \"x\"; then\n+                AC_MSG_ERROR(Could not find a version of the library!)\n+            fi\n+\t\t\tif test \"x$link_asio\" = \"xno\"; then\n+\t\t\t\tAC_MSG_ERROR(Could not link against $ax_lib !)\n+\t\t\tfi\n+\t\tfi\n+\n+\t\tCPPFLAGS=\"$CPPFLAGS_SAVED\"\n+    \tLDFLAGS=\"$LDFLAGS_SAVED\"\n+\tfi\n+])"},{"sha":"8f935f6bc61377ff824f9af0a1d3f44bdd9d8d20","filename":"hedwig-client/src/main/cpp/m4/ax_boost_base.m4","status":"added","additions":252,"deletions":0,"changes":252,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_boost_base.m4","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_boost_base.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_boost_base.m4?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,252 @@\n+# ===========================================================================\n+#       http://www.gnu.org/software/autoconf-archive/ax_boost_base.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_BOOST_BASE([MINIMUM-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\n+#\n+# DESCRIPTION\n+#\n+#   Test for the Boost C++ libraries of a particular version (or newer)\n+#\n+#   If no path to the installed boost library is given the macro searchs\n+#   under /usr, /usr/local, /opt and /opt/local and evaluates the\n+#   $BOOST_ROOT environment variable. Further documentation is available at\n+#   <http://randspringer.de/boost/index.html>.\n+#\n+#   This macro calls:\n+#\n+#     AC_SUBST(BOOST_CPPFLAGS) / AC_SUBST(BOOST_LDFLAGS)\n+#\n+#   And sets:\n+#\n+#     HAVE_BOOST\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Thomas Porschberg <thomas@randspringer.de>\n+#   Copyright (c) 2009 Peter Adolphs\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 17\n+\n+AC_DEFUN([AX_BOOST_BASE],\n+[\n+AC_ARG_WITH([boost],\n+  [AS_HELP_STRING([--with-boost@<:@=ARG@:>@],\n+    [use Boost library from a standard location (ARG=yes),\n+     from the specified location (ARG=<path>),\n+     or disable it (ARG=no)\n+     @<:@ARG=yes@:>@ ])],\n+    [\n+    if test \"$withval\" = \"no\"; then\n+        want_boost=\"no\"\n+    elif test \"$withval\" = \"yes\"; then\n+        want_boost=\"yes\"\n+        ac_boost_path=\"\"\n+    else\n+        want_boost=\"yes\"\n+        ac_boost_path=\"$withval\"\n+    fi\n+    ],\n+    [want_boost=\"yes\"])\n+\n+\n+AC_ARG_WITH([boost-libdir],\n+        AS_HELP_STRING([--with-boost-libdir=LIB_DIR],\n+        [Force given directory for boost libraries. Note that this will overwrite library path detection, so use this parameter only if default library detection fails and you know exactly where your boost libraries are located.]),\n+        [\n+        if test -d \"$withval\"\n+        then\n+                ac_boost_lib_path=\"$withval\"\n+        else\n+                AC_MSG_ERROR(--with-boost-libdir expected directory name)\n+        fi\n+        ],\n+        [ac_boost_lib_path=\"\"]\n+)\n+\n+if test \"x$want_boost\" = \"xyes\"; then\n+    boost_lib_version_req=ifelse([$1], ,1.20.0,$1)\n+    boost_lib_version_req_shorten=`expr $boost_lib_version_req : '\\([[0-9]]*\\.[[0-9]]*\\)'`\n+    boost_lib_version_req_major=`expr $boost_lib_version_req : '\\([[0-9]]*\\)'`\n+    boost_lib_version_req_minor=`expr $boost_lib_version_req : '[[0-9]]*\\.\\([[0-9]]*\\)'`\n+    boost_lib_version_req_sub_minor=`expr $boost_lib_version_req : '[[0-9]]*\\.[[0-9]]*\\.\\([[0-9]]*\\)'`\n+    if test \"x$boost_lib_version_req_sub_minor\" = \"x\" ; then\n+        boost_lib_version_req_sub_minor=\"0\"\n+        fi\n+    WANT_BOOST_VERSION=`expr $boost_lib_version_req_major \\* 100000 \\+  $boost_lib_version_req_minor \\* 100 \\+ $boost_lib_version_req_sub_minor`\n+    AC_MSG_CHECKING(for boostlib >= $boost_lib_version_req)\n+    succeeded=no\n+\n+    dnl On x86_64 systems check for system libraries in both lib64 and lib.\n+    dnl The former is specified by FHS, but e.g. Debian does not adhere to\n+    dnl this (as it rises problems for generic multi-arch support).\n+    dnl The last entry in the list is chosen by default when no libraries\n+    dnl are found, e.g. when only header-only libraries are installed!\n+    libsubdirs=\"lib\"\n+    if test `uname -m` = x86_64; then\n+        libsubdirs=\"lib64 lib lib64\"\n+    fi\n+\n+    dnl first we check the system location for boost libraries\n+    dnl this location ist chosen if boost libraries are installed with the --layout=system option\n+    dnl or if you install boost with RPM\n+    if test \"$ac_boost_path\" != \"\"; then\n+        BOOST_LDFLAGS=\"-L$ac_boost_path/$libsubdir\"\n+        BOOST_CPPFLAGS=\"-I$ac_boost_path/include\"\n+    elif test \"$cross_compiling\" != yes; then\n+        for ac_boost_path_tmp in /usr /usr/local /opt /opt/local ; do\n+            if test -d \"$ac_boost_path_tmp/include/boost\" && test -r \"$ac_boost_path_tmp/include/boost\"; then\n+                for libsubdir in $libsubdirs ; do\n+                    if ls \"$ac_boost_path_tmp/$libsubdir/libboost_\"* >/dev/null 2>&1 ; then break; fi\n+                done\n+                BOOST_LDFLAGS=\"-L$ac_boost_path_tmp/$libsubdir\"\n+                BOOST_CPPFLAGS=\"-I$ac_boost_path_tmp/include\"\n+                break;\n+            fi\n+        done\n+    fi\n+\n+    dnl overwrite ld flags if we have required special directory with\n+    dnl --with-boost-libdir parameter\n+    if test \"$ac_boost_lib_path\" != \"\"; then\n+       BOOST_LDFLAGS=\"-L$ac_boost_lib_path\"\n+    fi\n+\n+    CPPFLAGS_SAVED=\"$CPPFLAGS\"\n+    CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n+    export CPPFLAGS\n+\n+    LDFLAGS_SAVED=\"$LDFLAGS\"\n+    LDFLAGS=\"$LDFLAGS $BOOST_LDFLAGS\"\n+    export LDFLAGS\n+\n+    AC_REQUIRE([AC_PROG_CXX])\n+    AC_LANG_PUSH(C++)\n+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+    @%:@include <boost/version.hpp>\n+    ]], [[\n+    #if BOOST_VERSION >= $WANT_BOOST_VERSION\n+    // Everything is okay\n+    #else\n+    #  error Boost version is too old\n+    #endif\n+    ]])],[\n+        AC_MSG_RESULT(yes)\n+    succeeded=yes\n+    found_system=yes\n+        ],[\n+        ])\n+    AC_LANG_POP([C++])\n+\n+\n+\n+    dnl if we found no boost with system layout we search for boost libraries\n+    dnl built and installed without the --layout=system option or for a staged(not installed) version\n+    if test \"x$succeeded\" != \"xyes\"; then\n+        _version=0\n+        if test \"$ac_boost_path\" != \"\"; then\n+            if test -d \"$ac_boost_path\" && test -r \"$ac_boost_path\"; then\n+                for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do\n+                    _version_tmp=`echo $i | sed \"s#$ac_boost_path##\" | sed 's/\\/include\\/boost-//' | sed 's/_/./'`\n+                    V_CHECK=`expr $_version_tmp \\> $_version`\n+                    if test \"$V_CHECK\" = \"1\" ; then\n+                        _version=$_version_tmp\n+                    fi\n+                    VERSION_UNDERSCORE=`echo $_version | sed 's/\\./_/'`\n+                    BOOST_CPPFLAGS=\"-I$ac_boost_path/include/boost-$VERSION_UNDERSCORE\"\n+                done\n+            fi\n+        else\n+            if test \"$cross_compiling\" != yes; then\n+                for ac_boost_path in /usr /usr/local /opt /opt/local ; do\n+                    if test -d \"$ac_boost_path\" && test -r \"$ac_boost_path\"; then\n+                        for i in `ls -d $ac_boost_path/include/boost-* 2>/dev/null`; do\n+                            _version_tmp=`echo $i | sed \"s#$ac_boost_path##\" | sed 's/\\/include\\/boost-//' | sed 's/_/./'`\n+                            V_CHECK=`expr $_version_tmp \\> $_version`\n+                            if test \"$V_CHECK\" = \"1\" ; then\n+                                _version=$_version_tmp\n+                                best_path=$ac_boost_path\n+                            fi\n+                        done\n+                    fi\n+                done\n+\n+                VERSION_UNDERSCORE=`echo $_version | sed 's/\\./_/'`\n+                BOOST_CPPFLAGS=\"-I$best_path/include/boost-$VERSION_UNDERSCORE\"\n+                if test \"$ac_boost_lib_path\" = \"\"; then\n+                    for libsubdir in $libsubdirs ; do\n+                        if ls \"$best_path/$libsubdir/libboost_\"* >/dev/null 2>&1 ; then break; fi\n+                    done\n+                    BOOST_LDFLAGS=\"-L$best_path/$libsubdir\"\n+                fi\n+            fi\n+\n+            if test \"x$BOOST_ROOT\" != \"x\"; then\n+                for libsubdir in $libsubdirs ; do\n+                    if ls \"$BOOST_ROOT/stage/$libsubdir/libboost_\"* >/dev/null 2>&1 ; then break; fi\n+                done\n+                if test -d \"$BOOST_ROOT\" && test -r \"$BOOST_ROOT\" && test -d \"$BOOST_ROOT/stage/$libsubdir\" && test -r \"$BOOST_ROOT/stage/$libsubdir\"; then\n+                    version_dir=`expr //$BOOST_ROOT : '.*/\\(.*\\)'`\n+                    stage_version=`echo $version_dir | sed 's/boost_//' | sed 's/_/./g'`\n+                        stage_version_shorten=`expr $stage_version : '\\([[0-9]]*\\.[[0-9]]*\\)'`\n+                    V_CHECK=`expr $stage_version_shorten \\>\\= $_version`\n+                    if test \"$V_CHECK\" = \"1\" -a \"$ac_boost_lib_path\" = \"\" ; then\n+                        AC_MSG_NOTICE(We will use a staged boost library from $BOOST_ROOT)\n+                        BOOST_CPPFLAGS=\"-I$BOOST_ROOT\"\n+                        BOOST_LDFLAGS=\"-L$BOOST_ROOT/stage/$libsubdir\"\n+                    fi\n+                fi\n+            fi\n+        fi\n+\n+        CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n+        export CPPFLAGS\n+        LDFLAGS=\"$LDFLAGS $BOOST_LDFLAGS\"\n+        export LDFLAGS\n+\n+        AC_LANG_PUSH(C++)\n+            AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+        @%:@include <boost/version.hpp>\n+        ]], [[\n+        #if BOOST_VERSION >= $WANT_BOOST_VERSION\n+        // Everything is okay\n+        #else\n+        #  error Boost version is too old\n+        #endif\n+        ]])],[\n+            AC_MSG_RESULT(yes)\n+        succeeded=yes\n+        found_system=yes\n+            ],[\n+            ])\n+        AC_LANG_POP([C++])\n+    fi\n+\n+    if test \"$succeeded\" != \"yes\" ; then\n+        if test \"$_version\" = \"0\" ; then\n+            AC_MSG_NOTICE([[We could not detect the boost libraries (version $boost_lib_version_req_shorten or higher). If you have a staged boost library (still not installed) please specify \\$BOOST_ROOT in your environment and do not give a PATH to --with-boost option.  If you are sure you have boost installed, then check your version number looking in <boost/version.hpp>. See http://randspringer.de/boost for more documentation.]])\n+        else\n+            AC_MSG_NOTICE([Your boost libraries seems to old (version $_version).])\n+        fi\n+        # execute ACTION-IF-NOT-FOUND (if present):\n+        ifelse([$3], , :, [$3])\n+    else\n+        AC_SUBST(BOOST_CPPFLAGS)\n+        AC_SUBST(BOOST_LDFLAGS)\n+        AC_DEFINE(HAVE_BOOST,,[define if the Boost library is available])\n+        # execute ACTION-IF-FOUND (if present):\n+        ifelse([$2], , :, [$2])\n+    fi\n+\n+    CPPFLAGS=\"$CPPFLAGS_SAVED\"\n+    LDFLAGS=\"$LDFLAGS_SAVED\"\n+fi\n+\n+])"},{"sha":"fb7e5308610737a97b1e20b71e1cc174dc71cb26","filename":"hedwig-client/src/main/cpp/m4/ax_boost_thread.m4","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_boost_thread.m4","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_boost_thread.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_boost_thread.m4?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,149 @@\n+# ===========================================================================\n+#      http://www.gnu.org/software/autoconf-archive/ax_boost_thread.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_BOOST_THREAD\n+#\n+# DESCRIPTION\n+#\n+#   Test for Thread library from the Boost C++ libraries. The macro requires\n+#   a preceding call to AX_BOOST_BASE. Further documentation is available at\n+#   <http://randspringer.de/boost/index.html>.\n+#\n+#   This macro calls:\n+#\n+#     AC_SUBST(BOOST_THREAD_LIB)\n+#\n+#   And sets:\n+#\n+#     HAVE_BOOST_THREAD\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2009 Thomas Porschberg <thomas@randspringer.de>\n+#   Copyright (c) 2009 Michael Tindal\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 17\n+\n+AC_DEFUN([AX_BOOST_THREAD],\n+[\n+\tAC_ARG_WITH([boost-thread],\n+\tAS_HELP_STRING([--with-boost-thread@<:@=special-lib@:>@],\n+                   [use the Thread library from boost - it is possible to specify a certain library for the linker\n+                        e.g. --with-boost-thread=boost_thread-gcc-mt ]),\n+        [\n+        if test \"$withval\" = \"no\"; then\n+\t\t\twant_boost=\"no\"\n+        elif test \"$withval\" = \"yes\"; then\n+            want_boost=\"yes\"\n+            ax_boost_user_thread_lib=\"\"\n+        else\n+\t\t    want_boost=\"yes\"\n+        \tax_boost_user_thread_lib=\"$withval\"\n+\t\tfi\n+        ],\n+        [want_boost=\"yes\"]\n+\t)\n+\n+\tif test \"x$want_boost\" = \"xyes\"; then\n+        AC_REQUIRE([AC_PROG_CC])\n+        AC_REQUIRE([AC_CANONICAL_BUILD])\n+\t\tCPPFLAGS_SAVED=\"$CPPFLAGS\"\n+\t\tCPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n+\t\texport CPPFLAGS\n+\n+\t\tLDFLAGS_SAVED=\"$LDFLAGS\"\n+\t\tLDFLAGS=\"$LDFLAGS $BOOST_LDFLAGS\"\n+\t\texport LDFLAGS\n+\n+        AC_CACHE_CHECK(whether the Boost::Thread library is available,\n+\t\t\t\t\t   ax_cv_boost_thread,\n+        [AC_LANG_PUSH([C++])\n+\t\t\t CXXFLAGS_SAVE=$CXXFLAGS\n+\n+\t\t\t if test \"x$build_os\" = \"xsolaris\" ; then\n+  \t\t\t\t CXXFLAGS=\"-pthreads $CXXFLAGS\"\n+\t\t\t elif test \"x$build_os\" = \"xming32\" ; then\n+\t\t\t\t CXXFLAGS=\"-mthreads $CXXFLAGS\"\n+\t\t\t else\n+\t\t\t\tCXXFLAGS=\"-pthread $CXXFLAGS\"\n+\t\t\t fi\n+\t\t\t AC_COMPILE_IFELSE(AC_LANG_PROGRAM([[@%:@include <boost/thread/thread.hpp>]],\n+                                   [[boost::thread_group thrds;\n+                                   return 0;]]),\n+                   ax_cv_boost_thread=yes, ax_cv_boost_thread=no)\n+\t\t\t CXXFLAGS=$CXXFLAGS_SAVE\n+             AC_LANG_POP([C++])\n+\t\t])\n+\t\tif test \"x$ax_cv_boost_thread\" = \"xyes\"; then\n+           if test \"x$build_os\" = \"xsolaris\" ; then\n+\t\t\t  BOOST_CPPFLAGS=\"-pthreads $BOOST_CPPFLAGS\"\n+\t\t   elif test \"x$build_os\" = \"xming32\" ; then\n+\t\t\t  BOOST_CPPFLAGS=\"-mthreads $BOOST_CPPFLAGS\"\n+\t\t   else\n+\t\t\t  BOOST_CPPFLAGS=\"-pthread $BOOST_CPPFLAGS\"\n+\t\t   fi\n+\n+\t\t\tAC_SUBST(BOOST_CPPFLAGS)\n+\n+\t\t\tAC_DEFINE(HAVE_BOOST_THREAD,,[define if the Boost::Thread library is available])\n+            BOOSTLIBDIR=`echo $BOOST_LDFLAGS | sed -e 's/@<:@^\\/@:>@*//'`\n+\n+\t\t\tLDFLAGS_SAVE=$LDFLAGS\n+                        case \"x$build_os\" in\n+                          *bsd* )\n+                               LDFLAGS=\"-pthread $LDFLAGS\"\n+                          break;\n+                          ;;\n+                        esac\n+            if test \"x$ax_boost_user_thread_lib\" = \"x\"; then\n+                for libextension in `ls $BOOSTLIBDIR/libboost_thread*.so* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^lib\\(boost_thread.*\\)\\.so.*$;\\1;'` `ls $BOOSTLIBDIR/libboost_thread*.a* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^lib\\(boost_thread.*\\)\\.a*$;\\1;'`; do\n+                     ax_lib=${libextension}\n+\t\t\t\t    AC_CHECK_LIB($ax_lib, exit,\n+                                 [BOOST_THREAD_LIB=\"-l$ax_lib\"; AC_SUBST(BOOST_THREAD_LIB) link_thread=\"yes\"; break],\n+                                 [link_thread=\"no\"])\n+  \t\t\t\tdone\n+                if test \"x$link_thread\" != \"xyes\"; then\n+                for libextension in `ls $BOOSTLIBDIR/boost_thread*.dll* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^\\(boost_thread.*\\)\\.dll.*$;\\1;'` `ls $BOOSTLIBDIR/boost_thread*.a* 2>/dev/null | sed 's,.*/,,' | sed -e 's;^\\(boost_thread.*\\)\\.a*$;\\1;'` ; do\n+                     ax_lib=${libextension}\n+\t\t\t\t    AC_CHECK_LIB($ax_lib, exit,\n+                                 [BOOST_THREAD_LIB=\"-l$ax_lib\"; AC_SUBST(BOOST_THREAD_LIB) link_thread=\"yes\"; break],\n+                                 [link_thread=\"no\"])\n+  \t\t\t\tdone\n+                fi\n+\n+            else\n+               for ax_lib in $ax_boost_user_thread_lib boost_thread-$ax_boost_user_thread_lib; do\n+\t\t\t\t      AC_CHECK_LIB($ax_lib, exit,\n+                                   [BOOST_THREAD_LIB=\"-l$ax_lib\"; AC_SUBST(BOOST_THREAD_LIB) link_thread=\"yes\"; break],\n+                                   [link_thread=\"no\"])\n+                  done\n+\n+            fi\n+            if test \"x$ax_lib\" = \"x\"; then\n+                AC_MSG_ERROR(Could not find a version of the library!)\n+            fi\n+\t\t\tif test \"x$link_thread\" = \"xno\"; then\n+\t\t\t\tAC_MSG_ERROR(Could not link against $ax_lib !)\n+                        else\n+                           case \"x$build_os\" in\n+                              *bsd* )\n+\t\t\t        BOOST_LDFLAGS=\"-pthread $BOOST_LDFLAGS\"\n+                              break;\n+                              ;;\n+                           esac\n+\n+\t\t\tfi\n+\t\tfi\n+\n+\t\tCPPFLAGS=\"$CPPFLAGS_SAVED\"\n+    \tLDFLAGS=\"$LDFLAGS_SAVED\"\n+\tfi\n+])"},{"sha":"6334fd41223259652f99dc0b9206b65a0eef4fb5","filename":"hedwig-client/src/main/cpp/m4/ax_doxygen.m4","status":"added","additions":533,"deletions":0,"changes":533,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_doxygen.m4","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/m4/ax_doxygen.m4","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/m4/ax_doxygen.m4?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,533 @@\n+# ===========================================================================\n+#      http://www.gnu.org/software/autoconf-archive/ax_prog_doxygen.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   DX_INIT_DOXYGEN(PROJECT-NAME, DOXYFILE-PATH, [OUTPUT-DIR])\n+#   DX_DOXYGEN_FEATURE(ON|OFF)\n+#   DX_DOT_FEATURE(ON|OFF)\n+#   DX_HTML_FEATURE(ON|OFF)\n+#   DX_CHM_FEATURE(ON|OFF)\n+#   DX_CHI_FEATURE(ON|OFF)\n+#   DX_MAN_FEATURE(ON|OFF)\n+#   DX_RTF_FEATURE(ON|OFF)\n+#   DX_XML_FEATURE(ON|OFF)\n+#   DX_PDF_FEATURE(ON|OFF)\n+#   DX_PS_FEATURE(ON|OFF)\n+#\n+# DESCRIPTION\n+#\n+#   The DX_*_FEATURE macros control the default setting for the given\n+#   Doxygen feature. Supported features are 'DOXYGEN' itself, 'DOT' for\n+#   generating graphics, 'HTML' for plain HTML, 'CHM' for compressed HTML\n+#   help (for MS users), 'CHI' for generating a seperate .chi file by the\n+#   .chm file, and 'MAN', 'RTF', 'XML', 'PDF' and 'PS' for the appropriate\n+#   output formats. The environment variable DOXYGEN_PAPER_SIZE may be\n+#   specified to override the default 'a4wide' paper size.\n+#\n+#   By default, HTML, PDF and PS documentation is generated as this seems to\n+#   be the most popular and portable combination. MAN pages created by\n+#   Doxygen are usually problematic, though by picking an appropriate subset\n+#   and doing some massaging they might be better than nothing. CHM and RTF\n+#   are specific for MS (note that you can't generate both HTML and CHM at\n+#   the same time). The XML is rather useless unless you apply specialized\n+#   post-processing to it.\n+#\n+#   The macros mainly control the default state of the feature. The use can\n+#   override the default by specifying --enable or --disable. The macros\n+#   ensure that contradictory flags are not given (e.g.,\n+#   --enable-doxygen-html and --enable-doxygen-chm,\n+#   --enable-doxygen-anything with --disable-doxygen, etc.) Finally, each\n+#   feature will be automatically disabled (with a warning) if the required\n+#   programs are missing.\n+#\n+#   Once all the feature defaults have been specified, call DX_INIT_DOXYGEN\n+#   with the following parameters: a one-word name for the project for use\n+#   as a filename base etc., an optional configuration file name (the\n+#   default is 'Doxyfile', the same as Doxygen's default), and an optional\n+#   output directory name (the default is 'doxygen-doc').\n+#\n+#   Automake Support\n+#\n+#   The following is a template aminclude.am file for use with Automake.\n+#   Make targets and variables values are controlled by the various\n+#   DX_COND_* conditionals set by autoconf.\n+#\n+#   The provided targets are:\n+#\n+#     doxygen-doc: Generate all doxygen documentation.\n+#\n+#     doxygen-run: Run doxygen, which will generate some of the\n+#                  documentation (HTML, CHM, CHI, MAN, RTF, XML)\n+#                  but will not do the post processing required\n+#                  for the rest of it (PS, PDF, and some MAN).\n+#\n+#     doxygen-man: Rename some doxygen generated man pages.\n+#\n+#     doxygen-ps:  Generate doxygen PostScript documentation.\n+#\n+#     doxygen-pdf: Generate doxygen PDF documentation.\n+#\n+#   Note that by default these are not integrated into the automake targets.\n+#   If doxygen is used to generate man pages, you can achieve this\n+#   integration by setting man3_MANS to the list of man pages generated and\n+#   then adding the dependency:\n+#\n+#     $(man3_MANS): doxygen-doc\n+#\n+#   This will cause make to run doxygen and generate all the documentation.\n+#\n+#   The following variable is intended for use in Makefile.am:\n+#\n+#     DX_CLEANFILES = everything to clean.\n+#\n+#   Then add this variable to MOSTLYCLEANFILES.\n+#\n+#     ----- begin aminclude.am -------------------------------------\n+#\n+#     ## --------------------------------- ##\n+#     ## Format-independent Doxygen rules. ##\n+#     ## --------------------------------- ##\n+#\n+#     if DX_COND_doc\n+#\n+#     ## ------------------------------- ##\n+#     ## Rules specific for HTML output. ##\n+#     ## ------------------------------- ##\n+#\n+#     if DX_COND_html\n+#\n+#     DX_CLEAN_HTML = @DX_DOCDIR@/html\n+#\n+#     endif DX_COND_html\n+#\n+#     ## ------------------------------ ##\n+#     ## Rules specific for CHM output. ##\n+#     ## ------------------------------ ##\n+#\n+#     if DX_COND_chm\n+#\n+#     DX_CLEAN_CHM = @DX_DOCDIR@/chm\n+#\n+#     if DX_COND_chi\n+#\n+#     DX_CLEAN_CHI = @DX_DOCDIR@/@PACKAGE@.chi\n+#\n+#     endif DX_COND_chi\n+#\n+#     endif DX_COND_chm\n+#\n+#     ## ------------------------------ ##\n+#     ## Rules specific for MAN output. ##\n+#     ## ------------------------------ ##\n+#\n+#     if DX_COND_man\n+#\n+#     DX_CLEAN_MAN = @DX_DOCDIR@/man\n+#\n+#     endif DX_COND_man\n+#\n+#     ## ------------------------------ ##\n+#     ## Rules specific for RTF output. ##\n+#     ## ------------------------------ ##\n+#\n+#     if DX_COND_rtf\n+#\n+#     DX_CLEAN_RTF = @DX_DOCDIR@/rtf\n+#\n+#     endif DX_COND_rtf\n+#\n+#     ## ------------------------------ ##\n+#     ## Rules specific for XML output. ##\n+#     ## ------------------------------ ##\n+#\n+#     if DX_COND_xml\n+#\n+#     DX_CLEAN_XML = @DX_DOCDIR@/xml\n+#\n+#     endif DX_COND_xml\n+#\n+#     ## ----------------------------- ##\n+#     ## Rules specific for PS output. ##\n+#     ## ----------------------------- ##\n+#\n+#     if DX_COND_ps\n+#\n+#     DX_CLEAN_PS = @DX_DOCDIR@/@PACKAGE@.ps\n+#\n+#     DX_PS_GOAL = doxygen-ps\n+#\n+#     doxygen-ps: @DX_DOCDIR@/@PACKAGE@.ps\n+#\n+#     @DX_DOCDIR@/@PACKAGE@.ps: @DX_DOCDIR@/@PACKAGE@.tag\n+#         cd @DX_DOCDIR@/latex; \\\n+#         rm -f *.aux *.toc *.idx *.ind *.ilg *.log *.out; \\\n+#         $(DX_LATEX) refman.tex; \\\n+#         $(MAKEINDEX_PATH) refman.idx; \\\n+#         $(DX_LATEX) refman.tex; \\\n+#         countdown=5; \\\n+#         while $(DX_EGREP) 'Rerun (LaTeX|to get cross-references right)' \\\n+#                           refman.log > /dev/null 2>&1 \\\n+#            && test $$countdown -gt 0; do \\\n+#             $(DX_LATEX) refman.tex; \\\n+#             countdown=`expr $$countdown - 1`; \\\n+#         done; \\\n+#         $(DX_DVIPS) -o ../@PACKAGE@.ps refman.dvi\n+#\n+#     endif DX_COND_ps\n+#\n+#     ## ------------------------------ ##\n+#     ## Rules specific for PDF output. ##\n+#     ## ------------------------------ ##\n+#\n+#     if DX_COND_pdf\n+#\n+#     DX_CLEAN_PDF = @DX_DOCDIR@/@PACKAGE@.pdf\n+#\n+#     DX_PDF_GOAL = doxygen-pdf\n+#\n+#     doxygen-pdf: @DX_DOCDIR@/@PACKAGE@.pdf\n+#\n+#     @DX_DOCDIR@/@PACKAGE@.pdf: @DX_DOCDIR@/@PACKAGE@.tag\n+#         cd @DX_DOCDIR@/latex; \\\n+#         rm -f *.aux *.toc *.idx *.ind *.ilg *.log *.out; \\\n+#         $(DX_PDFLATEX) refman.tex; \\\n+#         $(DX_MAKEINDEX) refman.idx; \\\n+#         $(DX_PDFLATEX) refman.tex; \\\n+#         countdown=5; \\\n+#         while $(DX_EGREP) 'Rerun (LaTeX|to get cross-references right)' \\\n+#                           refman.log > /dev/null 2>&1 \\\n+#            && test $$countdown -gt 0; do \\\n+#             $(DX_PDFLATEX) refman.tex; \\\n+#             countdown=`expr $$countdown - 1`; \\\n+#         done; \\\n+#         mv refman.pdf ../@PACKAGE@.pdf\n+#\n+#     endif DX_COND_pdf\n+#\n+#     ## ------------------------------------------------- ##\n+#     ## Rules specific for LaTeX (shared for PS and PDF). ##\n+#     ## ------------------------------------------------- ##\n+#\n+#     if DX_COND_latex\n+#\n+#     DX_CLEAN_LATEX = @DX_DOCDIR@/latex\n+#\n+#     endif DX_COND_latex\n+#\n+#     .PHONY: doxygen-run doxygen-doc $(DX_PS_GOAL) $(DX_PDF_GOAL)\n+#\n+#     .INTERMEDIATE: doxygen-run $(DX_PS_GOAL) $(DX_PDF_GOAL)\n+#\n+#     doxygen-run: @DX_DOCDIR@/@PACKAGE@.tag\n+#\n+#     doxygen-doc: doxygen-run $(DX_PS_GOAL) $(DX_PDF_GOAL)\n+#\n+#     @DX_DOCDIR@/@PACKAGE@.tag: $(DX_CONFIG) $(pkginclude_HEADERS)\n+#         rm -rf @DX_DOCDIR@\n+#         $(DX_ENV) $(DX_DOXYGEN) $(srcdir)/$(DX_CONFIG)\n+#\n+#     DX_CLEANFILES = \\\n+#         @DX_DOCDIR@/@PACKAGE@.tag \\\n+#         -r \\\n+#         $(DX_CLEAN_HTML) \\\n+#         $(DX_CLEAN_CHM) \\\n+#         $(DX_CLEAN_CHI) \\\n+#         $(DX_CLEAN_MAN) \\\n+#         $(DX_CLEAN_RTF) \\\n+#         $(DX_CLEAN_XML) \\\n+#         $(DX_CLEAN_PS) \\\n+#         $(DX_CLEAN_PDF) \\\n+#         $(DX_CLEAN_LATEX)\n+#\n+#     endif DX_COND_doc\n+#\n+#     ----- end aminclude.am ---------------------------------------\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2009 Oren Ben-Kiki <oren@ben-kiki.org>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 10\n+\n+## ----------##\n+## Defaults. ##\n+## ----------##\n+\n+DX_ENV=\"\"\n+AC_DEFUN([DX_FEATURE_doc],  ON)\n+AC_DEFUN([DX_FEATURE_dot],  ON)\n+AC_DEFUN([DX_FEATURE_man],  OFF)\n+AC_DEFUN([DX_FEATURE_html], ON)\n+AC_DEFUN([DX_FEATURE_chm],  OFF)\n+AC_DEFUN([DX_FEATURE_chi],  OFF)\n+AC_DEFUN([DX_FEATURE_rtf],  OFF)\n+AC_DEFUN([DX_FEATURE_xml],  OFF)\n+AC_DEFUN([DX_FEATURE_pdf],  ON)\n+AC_DEFUN([DX_FEATURE_ps],   ON)\n+\n+## --------------- ##\n+## Private macros. ##\n+## --------------- ##\n+\n+# DX_ENV_APPEND(VARIABLE, VALUE)\n+# ------------------------------\n+# Append VARIABLE=\"VALUE\" to DX_ENV for invoking doxygen.\n+AC_DEFUN([DX_ENV_APPEND], [AC_SUBST([DX_ENV], [\"$DX_ENV $1='$2'\"])])\n+\n+# DX_DIRNAME_EXPR\n+# ---------------\n+# Expand into a shell expression prints the directory part of a path.\n+AC_DEFUN([DX_DIRNAME_EXPR],\n+         [[expr \".$1\" : '\\(\\.\\)[^/]*$' \\| \"x$1\" : 'x\\(.*\\)/[^/]*$']])\n+\n+# DX_IF_FEATURE(FEATURE, IF-ON, IF-OFF)\n+# -------------------------------------\n+# Expands according to the M4 (static) status of the feature.\n+AC_DEFUN([DX_IF_FEATURE], [ifelse(DX_FEATURE_$1, ON, [$2], [$3])])\n+\n+# DX_REQUIRE_PROG(VARIABLE, PROGRAM)\n+# ----------------------------------\n+# Require the specified program to be found for the DX_CURRENT_FEATURE to work.\n+AC_DEFUN([DX_REQUIRE_PROG], [\n+AC_PATH_TOOL([$1], [$2])\n+if test \"$DX_FLAG_[]DX_CURRENT_FEATURE$$1\" = 1; then\n+    AC_MSG_WARN([$2 not found - will not DX_CURRENT_DESCRIPTION])\n+    AC_SUBST(DX_FLAG_[]DX_CURRENT_FEATURE, 0)\n+fi\n+])\n+\n+# DX_TEST_FEATURE(FEATURE)\n+# ------------------------\n+# Expand to a shell expression testing whether the feature is active.\n+AC_DEFUN([DX_TEST_FEATURE], [test \"$DX_FLAG_$1\" = 1])\n+\n+# DX_CHECK_DEPEND(REQUIRED_FEATURE, REQUIRED_STATE)\n+# -------------------------------------------------\n+# Verify that a required features has the right state before trying to turn on\n+# the DX_CURRENT_FEATURE.\n+AC_DEFUN([DX_CHECK_DEPEND], [\n+test \"$DX_FLAG_$1\" = \"$2\" \\\n+|| AC_MSG_ERROR([doxygen-DX_CURRENT_FEATURE ifelse([$2], 1,\n+                            requires, contradicts) doxygen-DX_CURRENT_FEATURE])\n+])\n+\n+# DX_CLEAR_DEPEND(FEATURE, REQUIRED_FEATURE, REQUIRED_STATE)\n+# ----------------------------------------------------------\n+# Turn off the DX_CURRENT_FEATURE if the required feature is off.\n+AC_DEFUN([DX_CLEAR_DEPEND], [\n+test \"$DX_FLAG_$1\" = \"$2\" || AC_SUBST(DX_FLAG_[]DX_CURRENT_FEATURE, 0)\n+])\n+\n+# DX_FEATURE_ARG(FEATURE, DESCRIPTION,\n+#                CHECK_DEPEND, CLEAR_DEPEND,\n+#                REQUIRE, DO-IF-ON, DO-IF-OFF)\n+# --------------------------------------------\n+# Parse the command-line option controlling a feature. CHECK_DEPEND is called\n+# if the user explicitly turns the feature on (and invokes DX_CHECK_DEPEND),\n+# otherwise CLEAR_DEPEND is called to turn off the default state if a required\n+# feature is disabled (using DX_CLEAR_DEPEND). REQUIRE performs additional\n+# requirement tests (DX_REQUIRE_PROG). Finally, an automake flag is set and\n+# DO-IF-ON or DO-IF-OFF are called according to the final state of the feature.\n+AC_DEFUN([DX_ARG_ABLE], [\n+    AC_DEFUN([DX_CURRENT_FEATURE], [$1])\n+    AC_DEFUN([DX_CURRENT_DESCRIPTION], [$2])\n+    AC_ARG_ENABLE(doxygen-$1,\n+                  [AS_HELP_STRING(DX_IF_FEATURE([$1], [--disable-doxygen-$1],\n+                                                      [--enable-doxygen-$1]),\n+                                  DX_IF_FEATURE([$1], [don't $2], [$2]))],\n+                  [\n+case \"$enableval\" in\n+#(\n+y|Y|yes|Yes|YES)\n+    AC_SUBST([DX_FLAG_$1], 1)\n+    $3\n+;; #(\n+n|N|no|No|NO)\n+    AC_SUBST([DX_FLAG_$1], 0)\n+;; #(\n+*)\n+    AC_MSG_ERROR([invalid value '$enableval' given to doxygen-$1])\n+;;\n+esac\n+], [\n+AC_SUBST([DX_FLAG_$1], [DX_IF_FEATURE([$1], 1, 0)])\n+$4\n+])\n+if DX_TEST_FEATURE([$1]); then\n+    $5\n+    :\n+fi\n+if DX_TEST_FEATURE([$1]); then\n+    AM_CONDITIONAL(DX_COND_$1, :)\n+    $6\n+    :\n+else\n+    AM_CONDITIONAL(DX_COND_$1, false)\n+    $7\n+    :\n+fi\n+])\n+\n+## -------------- ##\n+## Public macros. ##\n+## -------------- ##\n+\n+# DX_XXX_FEATURE(DEFAULT_STATE)\n+# -----------------------------\n+AC_DEFUN([DX_DOXYGEN_FEATURE], [AC_DEFUN([DX_FEATURE_doc],  [$1])])\n+AC_DEFUN([DX_MAN_FEATURE],     [AC_DEFUN([DX_FEATURE_man],  [$1])])\n+AC_DEFUN([DX_HTML_FEATURE],    [AC_DEFUN([DX_FEATURE_html], [$1])])\n+AC_DEFUN([DX_CHM_FEATURE],     [AC_DEFUN([DX_FEATURE_chm],  [$1])])\n+AC_DEFUN([DX_CHI_FEATURE],     [AC_DEFUN([DX_FEATURE_chi],  [$1])])\n+AC_DEFUN([DX_RTF_FEATURE],     [AC_DEFUN([DX_FEATURE_rtf],  [$1])])\n+AC_DEFUN([DX_XML_FEATURE],     [AC_DEFUN([DX_FEATURE_xml],  [$1])])\n+AC_DEFUN([DX_XML_FEATURE],     [AC_DEFUN([DX_FEATURE_xml],  [$1])])\n+AC_DEFUN([DX_PDF_FEATURE],     [AC_DEFUN([DX_FEATURE_pdf],  [$1])])\n+AC_DEFUN([DX_PS_FEATURE],      [AC_DEFUN([DX_FEATURE_ps],   [$1])])\n+\n+# DX_INIT_DOXYGEN(PROJECT, [CONFIG-FILE], [OUTPUT-DOC-DIR])\n+# ---------------------------------------------------------\n+# PROJECT also serves as the base name for the documentation files.\n+# The default CONFIG-FILE is \"Doxyfile\" and OUTPUT-DOC-DIR is \"doxygen-doc\".\n+AC_DEFUN([DX_INIT_DOXYGEN], [\n+\n+# Files:\n+AC_SUBST([DX_PROJECT], [$1])\n+AC_SUBST([DX_CONFIG], [ifelse([$2], [], Doxyfile, [$2])])\n+AC_SUBST([DX_DOCDIR], [ifelse([$3], [], doxygen-doc, [$3])])\n+\n+# Environment variables used inside doxygen.cfg:\n+DX_ENV_APPEND(SRCDIR, $srcdir)\n+DX_ENV_APPEND(PROJECT, $DX_PROJECT)\n+DX_ENV_APPEND(DOCDIR, $DX_DOCDIR)\n+DX_ENV_APPEND(VERSION, $PACKAGE_VERSION)\n+\n+# Doxygen itself:\n+DX_ARG_ABLE(doc, [generate any doxygen documentation],\n+            [],\n+            [],\n+            [DX_REQUIRE_PROG([DX_DOXYGEN], doxygen)\n+             DX_REQUIRE_PROG([DX_PERL], perl)],\n+            [DX_ENV_APPEND(PERL_PATH, $DX_PERL)])\n+\n+# Dot for graphics:\n+DX_ARG_ABLE(dot, [generate graphics for doxygen documentation],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [DX_REQUIRE_PROG([DX_DOT], dot)],\n+            [DX_ENV_APPEND(HAVE_DOT, YES)\n+             DX_ENV_APPEND(DOT_PATH, [`DX_DIRNAME_EXPR($DX_DOT)`])],\n+            [DX_ENV_APPEND(HAVE_DOT, NO)])\n+\n+# Man pages generation:\n+DX_ARG_ABLE(man, [generate doxygen manual pages],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [],\n+            [DX_ENV_APPEND(GENERATE_MAN, YES)],\n+            [DX_ENV_APPEND(GENERATE_MAN, NO)])\n+\n+# RTF file generation:\n+DX_ARG_ABLE(rtf, [generate doxygen RTF documentation],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [],\n+            [DX_ENV_APPEND(GENERATE_RTF, YES)],\n+            [DX_ENV_APPEND(GENERATE_RTF, NO)])\n+\n+# XML file generation:\n+DX_ARG_ABLE(xml, [generate doxygen XML documentation],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [],\n+            [DX_ENV_APPEND(GENERATE_XML, YES)],\n+            [DX_ENV_APPEND(GENERATE_XML, NO)])\n+\n+# (Compressed) HTML help generation:\n+DX_ARG_ABLE(chm, [generate doxygen compressed HTML help documentation],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [DX_REQUIRE_PROG([DX_HHC], hhc)],\n+            [DX_ENV_APPEND(HHC_PATH, $DX_HHC)\n+             DX_ENV_APPEND(GENERATE_HTML, YES)\n+             DX_ENV_APPEND(GENERATE_HTMLHELP, YES)],\n+            [DX_ENV_APPEND(GENERATE_HTMLHELP, NO)])\n+\n+# Seperate CHI file generation.\n+DX_ARG_ABLE(chi, [generate doxygen seperate compressed HTML help index file],\n+            [DX_CHECK_DEPEND(chm, 1)],\n+            [DX_CLEAR_DEPEND(chm, 1)],\n+            [],\n+            [DX_ENV_APPEND(GENERATE_CHI, YES)],\n+            [DX_ENV_APPEND(GENERATE_CHI, NO)])\n+\n+# Plain HTML pages generation:\n+DX_ARG_ABLE(html, [generate doxygen plain HTML documentation],\n+            [DX_CHECK_DEPEND(doc, 1) DX_CHECK_DEPEND(chm, 0)],\n+            [DX_CLEAR_DEPEND(doc, 1) DX_CLEAR_DEPEND(chm, 0)],\n+            [],\n+            [DX_ENV_APPEND(GENERATE_HTML, YES)],\n+            [DX_TEST_FEATURE(chm) || DX_ENV_APPEND(GENERATE_HTML, NO)])\n+\n+# PostScript file generation:\n+DX_ARG_ABLE(ps, [generate doxygen PostScript documentation],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [DX_REQUIRE_PROG([DX_LATEX], latex)\n+             DX_REQUIRE_PROG([DX_MAKEINDEX], makeindex)\n+             DX_REQUIRE_PROG([DX_DVIPS], dvips)\n+             DX_REQUIRE_PROG([DX_EGREP], egrep)])\n+\n+# PDF file generation:\n+DX_ARG_ABLE(pdf, [generate doxygen PDF documentation],\n+            [DX_CHECK_DEPEND(doc, 1)],\n+            [DX_CLEAR_DEPEND(doc, 1)],\n+            [DX_REQUIRE_PROG([DX_PDFLATEX], pdflatex)\n+             DX_REQUIRE_PROG([DX_MAKEINDEX], makeindex)\n+             DX_REQUIRE_PROG([DX_EGREP], egrep)])\n+\n+# LaTeX generation for PS and/or PDF:\n+if DX_TEST_FEATURE(ps) || DX_TEST_FEATURE(pdf); then\n+    AM_CONDITIONAL(DX_COND_latex, :)\n+    DX_ENV_APPEND(GENERATE_LATEX, YES)\n+else\n+    AM_CONDITIONAL(DX_COND_latex, false)\n+    DX_ENV_APPEND(GENERATE_LATEX, NO)\n+fi\n+\n+# Paper size for PS and/or PDF:\n+AC_ARG_VAR(DOXYGEN_PAPER_SIZE,\n+           [a4wide (default), a4, letter, legal or executive])\n+case \"$DOXYGEN_PAPER_SIZE\" in\n+#(\n+\"\")\n+    AC_SUBST(DOXYGEN_PAPER_SIZE, \"\")\n+;; #(\n+a4wide|a4|letter|legal|executive)\n+    DX_ENV_APPEND(PAPER_SIZE, $DOXYGEN_PAPER_SIZE)\n+;; #(\n+*)\n+    AC_MSG_ERROR([unknown DOXYGEN_PAPER_SIZE='$DOXYGEN_PAPER_SIZE'])\n+;;\n+esac\n+\n+#For debugging:\n+#echo DX_FLAG_doc=$DX_FLAG_doc\n+#echo DX_FLAG_dot=$DX_FLAG_dot\n+#echo DX_FLAG_man=$DX_FLAG_man\n+#echo DX_FLAG_html=$DX_FLAG_html\n+#echo DX_FLAG_chm=$DX_FLAG_chm\n+#echo DX_FLAG_chi=$DX_FLAG_chi\n+#echo DX_FLAG_rtf=$DX_FLAG_rtf\n+#echo DX_FLAG_xml=$DX_FLAG_xml\n+#echo DX_FLAG_pdf=$DX_FLAG_pdf\n+#echo DX_FLAG_ps=$DX_FLAG_ps\n+#echo DX_ENV=$DX_ENV\n+])"},{"sha":"fc1084cdb82b1f5e2e61b369a02e05e5e49e5bba","filename":"hedwig-client/src/main/cpp/scripts/log4cxx.conf","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/log4cxx.conf","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/log4cxx.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/log4cxx.conf?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,49 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+log4j.appender.rootAppender=org.apache.log4j.ConsoleAppender\n+log4j.appender.rootAppender.layout=org.apache.log4j.BasicLayout\n+\n+#log4j.appender.hedwig=org.apache.log4j.RollingFileAppender\n+log4j.appender.hedwig=org.apache.log4j.ConsoleAppender\n+#log4j.appender.hedwig.fileName=./testLog.log\n+log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwig.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %c %p - %m%n\n+log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwig.layout.ConversionPattern=%.5m%n\n+\n+log4j.appender.hedwigtest=org.apache.log4j.ConsoleAppender\n+#log4j.appender.hedwig.fileName=./testLog.log\n+log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwigtest.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %c %p - %m%n\n+log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n+log4j.appender.hedwigtest.layout.ConversionPattern=%.5m%n\n+\n+# category\n+log4j.category.hedwig=DEBUG, hedwig\n+log4j.rootCategory=DEBUG\n+\n+#log4j.category.hedwig.channel=ERROR\n+log4j.category.hedwig.util=ERROR\n+log4j.category.hedwigtest.servercontrol=ERROR\n+\n+log4j.category.hedwigtest=DEBUG, hedwigtest\n+log4j.rootCategory=DEBUG"},{"sha":"f56609860b60f8dc3762b35230b979d7130398f4","filename":"hedwig-client/src/main/cpp/scripts/network-delays.sh","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/network-delays.sh","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/network-delays.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/network-delays.sh?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,64 @@\n+#!/bin/bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+setup_delays() {\n+\n+    UNAME=`uname -s`\n+\n+    echo \"Setting delay to ${1}ms\"\n+    case \"$UNAME\" in\n+\tDarwin|FreeBSD)\n+\t    sudo ipfw pipe 1 config delay ${1}ms\n+\t    sudo ipfw add pipe 1 dst-port 12349 \n+\t    sudo ipfw add pipe 1 dst-port 12350\n+\t    sudo ipfw add pipe 1 src-port 12349 \n+\t    sudo ipfw add pipe 1 src-port 12350 \n+            ;;\n+\tLinux)\n+\t    sudo tc qdisc add dev lo root handle 1: prio\n+\t    sudo tc qdisc add dev lo parent 1:3 handle 30: netem delay ${1}ms \n+\t    sudo tc filter add dev lo protocol ip parent 1:0 prio 3 u32 match ip dport 12349 0xffff flowid 1:3\n+\t    sudo tc filter add dev lo protocol ip parent 1:0 prio 3 u32 match ip dport 12350 0xffff flowid 1:3\n+\t    sudo tc filter add dev lo protocol ip parent 1:0 prio 3 u32 match ip sport 12349 0xffff flowid 1:3\n+\t    sudo tc filter add dev lo protocol ip parent 1:0 prio 3 u32 match ip sport 12350 0xffff flowid 1:3\n+\t    ;;\n+\t*)\n+\t    echo \"Unknown system type, $UNAME, only Linux, Darwin & FreeBSD supported\"\n+\t    ;;\n+    esac\n+}\n+\n+clear_delays() {\n+    UNAME=`uname -s`\n+\n+    case \"$UNAME\" in\n+\tDarwin|FreeBSD)\n+\t    echo \"Flushing ipfw\"\n+\t    sudo ipfw -f -q flush\n+            ;;\n+\tLinux)\n+\t    echo \"Clearing delay\"\n+\t    sudo tc qdisc del dev lo root\n+\t    ;;\n+\t*)\n+\t    echo \"Unknown system type, $UNAME, only Linux, Darwin & FreeBSD supported\"\n+\t    ;;\n+    esac\n+}\n+"},{"sha":"fa7f1c1a2733c245f77742ec775be9996772e64b","filename":"hedwig-client/src/main/cpp/scripts/server-control.sh","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/server-control.sh","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/server-control.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/server-control.sh?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,49 @@\n+#!/bin/bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+HEDWIGBASE=../../../../..\n+\n+HEDWIGJAR=`ls $HEDWIGBASE/server/target/server-*-with-dependencies.jar`\n+if [ ! $? -eq 0 ]; then\n+    echo \"\\n\\nCould not find server-VERSION-with-dependencies.jar. \\nYou need to build the java part of hedwig. \\nRun mvn package in the toplevel hedwig directory.\\n\\n\"\n+    exit 1;\n+fi\n+\n+HEDWIGSERVERTESTS=$HEDWIGBASE/server/target/test-classes/\n+if [ ! -e $HEDWIGSERVERTESTS ]; then\n+    echo \"\\n\\nThe hedwig java server tests need to be build.\\b\\b\"\n+    exit 1;\n+fi\n+\n+export CP=.:$HEDWIGJAR:$HEDWIGSERVERTESTS\n+\n+start_control_server() {\n+    if [ -e server-control.pid ]; then\n+\tkill -9 `cat server-control.pid`\n+\trm server-control.pid\n+    fi\n+    java -cp $CP  -Dlog4j.configuration=log4j.properties org.apache.hedwig.ServerControlDaemon  <&-  1> servercontrol.out  2>&1  &\n+    echo $! > server-control.pid\n+    sleep 5\n+}\n+\n+stop_control_server() {\n+    kill -9 `cat server-control.pid`\n+    rm server-control.pid\n+}"},{"sha":"c2880765d9f8e6255953184a7d15cecd2ba417d4","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,95 @@\n+#!/bin/bash\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+cd `dirname $0`;\n+\n+source network-delays.sh\n+source server-control.sh\n+\n+all() {\n+    if [ \"z$HEDWIG_NETWORK_DELAY\" != \"z\" ]; then\n+\tsetup_delays $HEDWIG_NETWORK_DELAY\n+    fi\n+\n+    start_control_server;\n+\n+    ../test/hedwigtest \n+    RESULT=$?\n+    stop_control_server;\n+\n+    if [ \"z$HEDWIG_NETWORK_DELAY\" != \"z\" ]; then\n+\tclear_delays\n+    else\n+\tcat <<EOF\n+\n+The environment variable HEDWIG_NETWORK_DELAY is not set, so the tests were run directly \n+with a localhost server. This isn't quite realistic as usually there will be some delay between \n+the client and the hedwig server. Set HEDWIG_NETWORK_DELAY to the number of milliseconds you want\n+to delay the packets between the server and client. \n+\n+ $ export HEDWIG_NETWORK_DELAY=500\n+\n+Requires root privileges.\n+\n+WARNING!!! This will modify your traffic shaping and firewall rules. If you do run with delays, \n+check your firewall rules afterwards.\n+\n+EOF\n+    fi\n+\n+    exit $RESULT\n+}\n+\n+case \"$1\" in\n+    start-control-server)\n+\tstart_control_server\n+\t;;\n+    stop-control-server)\n+\tstop_control_server\n+\t;;\n+    setup-delays)\n+\tsetup_delays $2\n+\t;;\n+    clear-delays)\n+\tclear_delays\n+\t;;\n+    all)\n+\tall\n+\t;;\n+    *)\n+\tcat <<EOF\n+Usage: tester.sh [command]\n+\n+tester.sh all\n+   Run through the tests, setting up and cleaning up all prerequisites.\n+\n+tester.sh start-control-server\n+   Starts the deamon which the tests use to start and stop hedwig/zookeeper/bookeeper servers\n+\n+tester.sh stop-control-server\n+   Stops the aforementioned daemon\n+\n+tester.sh setup-delays <delay>\n+   Set the millisecond delay for accessing the hedwig servers for the tests.\n+\n+tester.sh clear-delays\n+   Clear the delay for accessing the hedwig servers.\n+EOF\n+\t;;\n+esac"},{"sha":"84db87fa67109e4859a2eca8fbf8565227446157","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,26 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+bin_PROGRAMS = hedwigtest\n+hedwigtest_SOURCES = main.cpp utiltest.cpp pubsubdatatest.cpp publishtest.cpp subscribetest.cpp servercontrol.cpp pubsubtest.cpp\n+hedwigtest_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS) $(BOOST_CPPFLAGS) \n+hedwigtest_LDADD = $(DEPS_LIBS) -L$(top_builddir)/lib -lhedwig01 \n+hedwigtest_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)\n+\n+check: hedwigtest\n+\tbash ../scripts/tester.sh all"},{"sha":"ef9190ef408b3f71f1d8b888ca5858c9548e8f7f","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#include \"../lib/channel.h\"\n+#include \"../lib/util.h\"\n+#include <hedwig/protocol.h>\n+#include <hedwig/callback.h>\n+#include <iostream>\n+\n+#include <log4cxx/logger.h>\n+#include <log4cxx/basicconfigurator.h>\n+#include <log4cxx/propertyconfigurator.h>\n+#include <log4cxx/helpers/exception.h>\n+\n+#include \"servercontrol.h\"\n+#include \"util.h\"\n+\n+#include <cppunit/extensions/TestFactoryRegistry.h>\n+#include <cppunit/ui/text/TextTestRunner.h>\n+\n+#include <cppunit/TextTestProgressListener.h>\n+#include <cppunit/TestResult.h>\n+\n+HedwigCppTextTestProgressListener gprogress;\n+\n+int main( int argc, char **argv)\n+{\n+  try {\n+    if (getenv(\"LOG4CXX_CONF\") == NULL) {\n+      std::cerr << \"Set LOG4CXX_CONF in your environment to get logging.\" << std::endl;\n+      log4cxx::BasicConfigurator::configure();\n+    } else {\n+      log4cxx::PropertyConfigurator::configure(getenv(\"LOG4CXX_CONF\"));\n+    }\n+  } catch (std::exception &e) {\n+    std::cerr << \"exception caught while configuring log4cpp via : \" << e.what() << std::endl;\n+  } catch (...) {\n+    std::cerr << \"unknown exception while configuring log4cpp vi'.\" << std::endl;\n+  }\n+  std::string testPath = (argc > 2) ? std::string(argv[2]) : \"\";\n+\n+  CppUnit::TextTestRunner runner;\n+\n+  if (argc > 1) {\n+    CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry(argv[1]);\n+    \n+    runner.addTest( registry.makeTest() );\n+  } else {\n+    CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry(\"*\");\n+    registry.addRegistry(\"Util\");\n+    registry.addRegistry(\"Subscribe\");\n+    registry.addRegistry(\"Publish\"); \n+    registry.addRegistry(\"PubSub\");\n+    \n+    runner.addTest( registry.makeTest() );\n+  }\n+  \n+  runner.eventManager().addListener( &gprogress );\n+\n+  bool ret = runner.run(testPath);\n+  google::protobuf::ShutdownProtobufLibrary();\n+  \n+  return (ret == true) ? 0 : 1;\n+}"},{"sha":"95599d7415553d05c816e2e682a10aa9ab146290","filename":"hedwig-client/src/main/cpp/test/publishtest.cpp","status":"added","additions":286,"deletions":0,"changes":286,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/publishtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/publishtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/publishtest.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,286 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#include <cppunit/Test.h>\n+#include <cppunit/TestSuite.h>\n+#include <cppunit/extensions/HelperMacros.h>\n+\n+#include \"../lib/clientimpl.h\"\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <stdexcept>\n+#include <pthread.h>\n+\n+#include <log4cxx/logger.h>\n+\n+#include \"servercontrol.h\"\n+#include \"util.h\"\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+using namespace CppUnit;\n+\n+class PublishTestSuite : public CppUnit::TestFixture {\n+private:\n+  HedwigTest::ServerControl* control;\n+  HedwigTest::TestServerPtr zk;\n+  HedwigTest::TestServerPtr bk1;\n+  HedwigTest::TestServerPtr bk2;\n+  HedwigTest::TestServerPtr bk3;\n+  HedwigTest::TestServerPtr hw1;\n+  HedwigTest::TestServerPtr hw2;\n+\n+  CPPUNIT_TEST_SUITE( PublishTestSuite );\n+  CPPUNIT_TEST(testSyncPublish);\n+  CPPUNIT_TEST(testAsyncPublish);\n+  CPPUNIT_TEST(testMultipleAsyncPublish);\n+  //  CPPUNIT_TEST(simplePublish);\n+  //CPPUNIT_TEST(simplePublishAndSubscribe);\n+  //CPPUNIT_TEST(publishAndSubscribeWithRedirect);\n+  CPPUNIT_TEST_SUITE_END();\n+\n+public:\n+  PublishTestSuite() : control(NULL) {\n+  }\n+\n+  ~PublishTestSuite() {\n+  }\n+\n+  void setUp()\n+  {\n+    control = new HedwigTest::ServerControl(HedwigTest::DEFAULT_CONTROLSERVER_PORT);\n+    zk = control->startZookeeperServer(12345);\n+    bk1 = control->startBookieServer(12346, zk);\n+    bk2 = control->startBookieServer(12347, zk);\n+    bk3 = control->startBookieServer(12348, zk);\n+    \n+    std::string region(\"testRegion\");\n+    hw1 = control->startPubSubServer(12349, region, zk);\n+    hw2 = control->startPubSubServer(12350, region, zk);\n+  }\n+  \n+  void tearDown() \n+  {\n+    if (hw2.get()) {\n+      hw2->kill();\n+    }\n+    if (hw1.get()) {\n+      hw1->kill();\n+    }\n+    \n+    if (bk1.get()) {\n+      bk1->kill();\n+    }\n+    if (bk2.get()) {\n+      bk2->kill();\n+    }\n+    if (bk3.get()) {\n+      bk3->kill();\n+    }\n+    \n+    if (zk.get()) {\n+      zk->kill();\n+    }\n+    if (control) {\n+      delete control;\n+    }\n+  }\n+\n+  void testSyncPublish() {\n+    Hedwig::Configuration* conf = new TestServerConfiguration(hw1);\n+    \n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    Hedwig::Publisher& pub = client->getPublisher();\n+    \n+    pub.publish(\"testTopic\", \"testMessage 1\");\n+    \n+    delete client;\n+    delete conf;\n+  }\n+\n+  void testAsyncPublish() {\n+    SimpleWaitCondition* cond = new SimpleWaitCondition();\n+\n+    Hedwig::Configuration* conf = new TestServerConfiguration(hw1);\n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    Hedwig::Publisher& pub = client->getPublisher();\n+    \n+    Hedwig::OperationCallbackPtr testcb(new TestCallback(cond));\n+    pub.asyncPublish(\"testTopic\", \"async test message\", testcb);\n+    \n+    cond->wait();\n+\n+    CPPUNIT_ASSERT(cond->wasSuccess());\n+\n+    delete cond;\n+    delete client;\n+    delete conf;\n+  }\n+\n+  void testMultipleAsyncPublish() {\n+    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond3 = new SimpleWaitCondition();\n+\n+    Hedwig::Configuration* conf = new TestServerConfiguration(hw1);\n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    Hedwig::Publisher& pub = client->getPublisher();\n+   \n+    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+    Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond2));\n+    Hedwig::OperationCallbackPtr testcb3(new TestCallback(cond3));\n+\n+    pub.asyncPublish(\"testTopic\", \"async test message #1\", testcb1);\n+    pub.asyncPublish(\"testTopic\", \"async test message #2\", testcb2);\n+    pub.asyncPublish(\"testTopic\", \"async test message #3\", testcb3);\n+    \n+    cond3->wait();\n+    CPPUNIT_ASSERT(cond3->wasSuccess());\n+    cond2->wait();\n+    CPPUNIT_ASSERT(cond2->wasSuccess());\n+    cond1->wait();\n+    CPPUNIT_ASSERT(cond1->wasSuccess());\n+    \n+    delete cond3; delete cond2; delete cond1;\n+    delete client;\n+    delete conf;\n+  }\n+  /*  void simplePublish() {\n+    LOG4CXX_DEBUG(logger, \">>> simplePublish\");\n+    SimpleWaitCondition* cond = new SimpleWaitCondition();\n+\n+    Hedwig::Configuration* conf = new Configuration1();\n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    Hedwig::Publisher& pub = client->getPublisher();\n+    \n+    Hedwig::OperationCallbackPtr testcb(new TestCallback(cond));\n+    pub.asyncPublish(\"foobar\", \"barfoo\", testcb);\n+    \n+    LOG4CXX_DEBUG(logger, \"wait for response\");\n+    cond->wait();\n+    delete cond;\n+    LOG4CXX_DEBUG(logger, \"got response\");\n+    \n+\n+    delete client;\n+    delete conf;\n+    LOG4CXX_DEBUG(logger, \"<<< simplePublish\");\n+  }\n+\n+  class MyMessageHandler : public Hedwig::MessageHandlerCallback {\n+  public:\n+    MyMessageHandler(SimpleWaitCondition* cond) : cond(cond) {}\n+\n+    void consume(const std::string& topic, const std::string& subscriberId, const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+      LOG4CXX_DEBUG(logger, \"Topic: \" << topic << \"  subscriberId: \" << subscriberId);\n+      LOG4CXX_DEBUG(logger, \" Message: \" << msg.body());\n+      \n+      callback->operationComplete();\n+      cond->setTrue();\n+      cond->signal();\n+    }\n+  private:\n+    SimpleWaitCondition* cond;\n+    };*/\n+  /*\n+  void simplePublishAndSubscribe() {\n+    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond3 = new SimpleWaitCondition();\n+\n+    Hedwig::Configuration* conf = new Configuration1();\n+    Hedwig::Client* client = new Hedwig::Client(*conf);\n+    Hedwig::Publisher& pub = client->getPublisher();\n+    Hedwig::Subscriber& sub = client->getSubscriber();\n+    \n+    std::string topic(\"foobar\");\n+    std::string sid(\"mysubscriber\");\n+    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+    sub.asyncSubscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n+    Hedwig::MessageHandlerCallbackPtr messagecb(new MyMessageHandler(cond2));\n+    sub.startDelivery(topic, sid, messagecb);\n+    cond1->wait();\n+    \n+    Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond3));\n+    pub.asyncPublish(\"foobar\", \"barfoo\", testcb2);\n+    cond3->wait();\n+    cond2->wait();\n+\n+    delete cond1;\n+    delete cond3;\n+    delete cond2;\n+\n+    delete client;\n+    delete conf;\n+  }\n+\n+  void publishAndSubscribeWithRedirect() {\n+    SimpleWaitCondition* cond1 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond2 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond3 = new SimpleWaitCondition();\n+    SimpleWaitCondition* cond4 = new SimpleWaitCondition();\n+\n+    Hedwig::Configuration* publishconf = new Configuration1();\n+    Hedwig::Configuration* subscribeconf = new Configuration2();\n+\n+    Hedwig::Client* publishclient = new Hedwig::Client(*publishconf);\n+    Hedwig::Publisher& pub = publishclient->getPublisher();\n+\n+    Hedwig::Client* subscribeclient = new Hedwig::Client(*subscribeconf);\n+    Hedwig::Subscriber& sub = subscribeclient->getSubscriber();\n+    \n+    LOG4CXX_DEBUG(logger, \"publishing\");\n+    Hedwig::OperationCallbackPtr testcb2(new TestCallback(cond3));\n+    pub.asyncPublish(\"foobar\", \"barfoo\", testcb2);\n+    cond3->wait();\n+    \n+    LOG4CXX_DEBUG(logger, \"Subscribing\");\n+    std::string topic(\"foobar\");\n+    std::string sid(\"mysubscriber\");\n+    Hedwig::OperationCallbackPtr testcb1(new TestCallback(cond1));\n+    sub.asyncSubscribe(topic, sid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH, testcb1);\n+    LOG4CXX_DEBUG(logger, \"Starting delivery\");\n+    Hedwig::MessageHandlerCallbackPtr messagecb(new MyMessageHandler(cond2));\n+    sub.startDelivery(topic, sid, messagecb);\n+\n+    LOG4CXX_DEBUG(logger, \"Subscribe wait\");\n+    cond1->wait();\n+\n+    Hedwig::OperationCallbackPtr testcb3(new TestCallback(cond4));\n+    pub.asyncPublish(\"foobar\", \"barfoo\", testcb3);\n+    cond4->wait();\n+\n+\n+    LOG4CXX_DEBUG(logger, \"Delivery wait\");\n+\n+    cond2->wait();\n+\n+    sub.stopDelivery(topic, sid);\n+\n+    delete cond1;\n+    delete cond3;\n+    delete cond2;\n+    delete cond4;\n+\n+    delete subscribeclient;\n+    delete publishclient;\n+    delete publishconf;\n+    delete subscribeconf;\n+    }*/\n+};\n+\n+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( PublishTestSuite, \"Publish\");"},{"sha":"bb7484b890e3815532c3696bf55761d382fa6eb1","filename":"hedwig-client/src/main/cpp/test/pubsubdatatest.cpp","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/pubsubdatatest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/pubsubdatatest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubdatatest.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9","patch":"@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#include <cppunit/Test.h>\n+#include <cppunit/TestSuite.h>\n+#include <cppunit/extensions/HelperMacros.h>\n+\n+#include \"../lib/clientimpl.h\"\n+#include <hedwig/exceptions.h>\n+#include <stdexcept>\n+\n+using namespace CppUnit;\n+\n+class PubSubDataTestSuite : public CppUnit::TestFixture {\n+  CPPUNIT_TEST_SUITE( PubSubDataTestSuite );\n+  CPPUNIT_TEST(createPubSubData);\n+  CPPUNIT_TEST_SUITE_END();\n+\n+public:\n+  void setUp()\n+  {\n+  }\n+\n+  void tearDown() \n+  {\n+  }\n+\n+  void createPubSubData() {\n+    \n+  }\n+};\n+\n+CPPUNIT_TEST_SUITE_REGISTRATION( PubSubDataTestSuite );"},{"sha":"c0feade815bc01933581bc3d97d9b5268d2c7178","filename":"hedwig-client/src/main/cpp/test/pubsubtest.cpp","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/pubsubtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/pubsubtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/pubsubtest.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"49696b76ede6e45f4ed3d1d4cc634103f8d9d3e5","filename":"hedwig-client/src/main/cpp/test/servercontrol.cpp","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/servercontrol.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/servercontrol.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/servercontrol.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"cac09e6ef417f754a4922f1966ba9b812d64aad9","filename":"hedwig-client/src/main/cpp/test/servercontrol.h","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/servercontrol.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/servercontrol.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/servercontrol.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"41da339d3a49614035ff139d3269375b16bdd007","filename":"hedwig-client/src/main/cpp/test/subscribetest.cpp","status":"added","additions":238,"deletions":0,"changes":238,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/subscribetest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/subscribetest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/subscribetest.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c75bc3f1fb1155d44c2a9aefb2214a5197209a64","filename":"hedwig-client/src/main/cpp/test/test.sh","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/test.sh","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/test.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/test.sh?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"2d9224486a0de7e8a3861a60a27ef7f6da51efe6","filename":"hedwig-client/src/main/cpp/test/util.h","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/util.h","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/util.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/util.h?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"99ef5f38f621728f59ee7706801312548ba5fe9d","filename":"hedwig-client/src/main/cpp/test/utiltest.cpp","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/utiltest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/cpp/test/utiltest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/utiltest.cpp?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"07fa4be650887a190699212c3751de63241f0d4d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/MessageHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a714eb54af8fcd32f422375716fd88848500dcd8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Publisher.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f1e35e5e4d7afd76a177b7b151d4434b012c70bc","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","status":"added","additions":237,"deletions":0,"changes":237,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6815249bffb178fa5653d1db103e4af139be36f6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"0244a2bddff23ddfbaef248349ef4fbe81c2b29b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","status":"added","additions":136,"deletions":0,"changes":136,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"cb4d92a02a4c86b57c4142d0002a748a83b57221","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","status":"added","additions":176,"deletions":0,"changes":176,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"093454fa42d4d71d51cba0c3fbc2d017fdd47703","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkWorker.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"077ac56b37d5cbc71716fe08f026c0fa423cb7ce","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f284d778fab089a072fe3b87d8846099968c17ff","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"50a9a8e1ec8359b3708f54c9ea0c4a4720f6995b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"047017d6648acbc3ade9f4f1b8306fbead41d127","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3e6468d927cc41d5deb1c9588ad19f6bba8d7c2f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3e543569f09f1dab37b23542115faeb85c088e85","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"9c58bb02e815ee731377a36a40abf578b63c951f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"47c5408b4c4f0b200ce8443c1f4780fa5016c519","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"cc916aa00d94817e1d17eb44c3c7563a9190912e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"74914f64c67c09e038d14ffc26ed5305ffe6590e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"69477167fc3671440e5302079dbd00cc8479a1ce","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3db17b914f709227c2717215d880471bfa5bb9ca","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"e34360547e9fec4c477b8dd8e32925b68ec01191","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"added","additions":329,"deletions":0,"changes":329,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"182518e5d81ef943cef93f0ceced8f3de128fded","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3d3b8bc66add6a042053c1e5dbf9153a45ab2b6e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"9929ae003cc19eace32ce95e326bc3506caccdb9","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","status":"added","additions":122,"deletions":0,"changes":122,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6984a59665347b461bd9d2f20de1e158149497bc","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java","status":"added","additions":359,"deletions":0,"changes":359,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"458ab9fa45ecbc430da0490ed973e75cd672b7f3","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"added","additions":224,"deletions":0,"changes":224,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"0343c3ef7b06117afcdbf5884ccbd87e3c7bd95a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"added","additions":585,"deletions":0,"changes":585,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"599de8c2d6cea472f4f1d93234445ea0e6e4b447","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","status":"added","additions":365,"deletions":0,"changes":365,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"2ee5ed60061c6c51a652cea657e997d9c2741935","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"ee488ba56f882a3194753fa02de54dc2aaf2cf36","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"16fa136a4a034ac794bc92196dfaf82c7f1fb835","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"12b3ec8e70cbfcc9425168bf66e42c84c6d6271d","filename":"hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8c4299377f613017ff0f4490fd0d7ad812e055b8","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"319d9a428872c193b7e4fa4012a50bc87579e685","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8f5f1cae9c5788524b1fb1bb57922f63a652737a","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b8ae82ffbb99899a109396cb19b747d1e1652092","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"98e41e1b0c7347b23d13b76b7b38d27925ce4a85","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java","status":"added","additions":97,"deletions":0,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a6cf89e8fbbc1bd825e83e7906904382bdf02f27","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6a347823f2c73f85c4efce37ca48864c434fbf17","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Option.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f0582b5e0210c4a05ee4c6ec65dc6c33d8377cd0","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b9890575cd8c4afb72c37b34ce115c082ba7c03b","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"377afb46485f7b0b4cbaeb319cd9c7d22183fbf5","filename":"hedwig-client/src/main/resources/log4j.properties","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/main/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/resources/log4j.properties?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"19cba7a0c4044241fd7ffaf17476b131d1cdd3b4","filename":"hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/test/java/org/apache/hedwig/client/AppTest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8803d871e0ca69fe1d5d5b2251887bd44572d39b","filename":"hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f8573d13b6720f12bedee01e1fa49b017d8e5ba3","filename":"hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"db1e61fe076095f6735caaced6007676abd5ddbf","filename":"hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"45a5353a4fef296886541dbd665e2175535020a2","filename":"hedwig-protocol/Makefile","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/Makefile","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/Makefile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/Makefile?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"1627c29543d42e3f2e3be520d03b6be5954973f3","filename":"hedwig-protocol/pom.xml","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/pom.xml?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"56a24064564e895bc11cde9dbad27200e3293e19","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"83a3fbf222f8054081ebd883ddf69dbe54c5a631","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8660544be6f0ebeae47e1319fd200df1578991dc","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a22e8c12823b5d3d403200635913739d078cbd94","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"e44d9818d8b74059d014e0ef5a2fa6c52341988b","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"e9930a260f624b4e05948922b762c4ead94320ac","filename":"hedwig-server/lib/README","status":"added","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/lib/README","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/lib/README","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/lib/README?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8cb0873e966ce92d46036351812d0bffbbb624d8","filename":"hedwig-server/pom.xml","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/pom.xml?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c73ec2ff0b16fd7f8efa30ac383275829962ae35","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b9a94af07875bae9f35b55c9574cc652213f6a58","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"2b9b1ca6f65a25350d2e30c7eb363322540767d9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"7c499eab068e7992f171b60842cadb48dfb06977","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"2f93a2e8c0768e77578c0f6f1d632ed27aee5bb5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"0a47470ffdaa2f2c25272c5b16d1f86559b584e8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"added","additions":289,"deletions":0,"changes":289,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"419b9b04d4ec711acf6bd1374e367fea94f61cc3","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3c4a56286f76bdc08602177c004da5de5f4ed990","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b7a4404e4b83d7c2695c8b53dbee9bb57cad625c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b5e9922737bbadb117ff894bee5072dfdcd96fe9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"9ee63f154f94cef14e71a6fb400ac7d6b4d3bcce","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"077480122194b7e28d326084585d890a69f77a4a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"805d71be830e60ec7b3adea7143592ab4877994a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8eede899a916ce6b4fad7615d3f6c115a4c96b18","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"added","additions":561,"deletions":0,"changes":561,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"82a559e957e837b4d596f365817b3387cca9d8ba","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"44552bc1dd2616d8868f8f8969a949aca3e29911","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b840dd3b6d5fc5e948ddf9c034082c946e9c410f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"d43d345f2816168dc146e6c280095f54b8493d9b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a3aec02b56bdbaf881b4bb24e8274e5264f1978d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"cedc13b11825dcb9e9c446a188e89aedaed2189e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f293d7354e5f4e2173161312008c334e1fe602c9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"cdcc07416ec21573e5b078cecc032cbd9fff69bf","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"added","additions":364,"deletions":0,"changes":364,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"fa71b17712bb768b4d36cc2f8bf611db15cab897","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f302f53e5a9a5980a0f0abfd83877b83290d7b46","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","status":"added","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"540910234a8f4c3c518549a693998bb400e18a57","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"added","additions":736,"deletions":0,"changes":736,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"92de5eb3aa5029fa30dd13beab635cb89c15d7e7","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"320e86db817dbe2e074c41400a5749de22c452f7","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c1ee24ccfcd1c440533183366fb9ab92005afe6b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b257d9d6a58e69a2608cf75c60af9cbd79c7ed43","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","status":"added","additions":426,"deletions":0,"changes":426,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f640723514d6b88839705a6e248d8bb5b35138cb","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"ee284e45e834bbc3ddeb776e090ef23dcdf30968","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"49f2c99f6f5370e3c660d75a6066072af8be0344","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"09cb96d0ee0568537db49a2e653600b906e85726","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"47bb0dfb8e290c79ac1213e7cb93be0a40f62988","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3cff829dcd67310c1e2f2b7c009360a0c9e67d77","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"added","additions":703,"deletions":0,"changes":703,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8c171d73dfadb960bdb807a69cfc1d74e2e3410c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"df31d818c85a7906c0d8882f62fd11b81d40f5e8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"792bfe1b899e146b6f10f20e403a0b8cc43fae92","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8d2be4e446a47421250cc9d4a4466698ab1dcdeb","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"cafe6e6d286ee7cc9c83b40024690cd6f50beb08","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","status":"added","additions":159,"deletions":0,"changes":159,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"aca54d7a12a697d046d8a262bc6e780af26e926b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"8bbd68ad1b553973c62889c7c8015cebe9c2226e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"7ffdb92492be9d112a7081ddae6cf21a8ba280bb","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"bdb82fcde71c9fe97bfaca61008eb599b0666192","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6f5eb20843563f1c7abcff98074008240a86f92c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"178c7fa5973f895e2693b04535d434508fec5eed","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f6119056d871aa515e6e17755b15068014c34134","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"0289c1685d0d1d529cf6340dc76a8a65629f5caf","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"9e4f61b12da42d88b36eb219f5ecbaa05700a516","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c4047dcf0ebe7157abde3d5c9fff60551aca6b25","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"08704de9c270ef9da0a0c37bd147510dd2c98570","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","status":"added","additions":180,"deletions":0,"changes":180,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"83d6961698d9289940b0477823b2e6efb98e54f5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"d73cf7ba47d85177b4a2d919a98cee7461392614","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"added","additions":450,"deletions":0,"changes":450,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"acdbf050f86833a0bca05a57c38111468cf95147","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"4a2439537bd46607f17d5be20864c2f2dd58ce85","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"0420d70053f22ac6d1c3763fc1fad07dcc82d71c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6aead601a730e55d7526421c72d34be652a2469b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MessageFilter.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b8eae5b1d76020d607c1795c5dbb0849b5c7d69b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"796343dbc1b2a9b8beea92ea9987c7618d795697","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"3804705d69e5e12e9f2407aaabbcd27651a6bd7d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a08011735b67cecc7ab26de03b6f11aae09c6570","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","status":"added","additions":226,"deletions":0,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c77d5f1b47d3fb5d24f37ddd696cf700368ee6a5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"66bc531457608e2e3a74c123dc9f961ed38580d0","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b0fe2c9f152726ae14f4961c9338e92f9a45dea5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f4d66ff90aa493aaef264478b1d263f2abfe48bb","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"9b2ba83878c7f65c6759356600a12d2a958564af","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","status":"added","additions":428,"deletions":0,"changes":428,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"4e2038f540e1d5ee4b6080b99cfe557c764c2338","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"d1f755e6fef08e186acc6d42d7126537281de1f7","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"45973ffc34c9426fd1a80f694dcccc7a1dc3f008","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"dc9ade2bf6d24036b5fbbb908cad4514be30a139","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"e7a8bf7e7f6d23bcaacd69c4c4e54671712ac06f","filename":"hedwig-server/src/main/resources/p12.pass","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/resources/p12.pass","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/resources/p12.pass","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/resources/p12.pass?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b7043b85630c8988c6b20bff335fb6f6589c7621","filename":"hedwig-server/src/main/resources/server.p12","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/resources/server.p12","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/main/resources/server.p12","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/resources/server.p12?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"b855f9a0bf377ac1c39e8c999bf9cd0a872dc8db","filename":"hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"9ec9e966d6b51f11902e814e53dda661bc9b109d","filename":"hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java","status":"added","additions":231,"deletions":0,"changes":231,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/ServerControl.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"7d732f29935bd7f6d15c971a7ea9d7e86bcebf66","filename":"hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java","status":"added","additions":171,"deletions":0,"changes":171,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/ServerControlDaemon.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"89790aab4e24530e499e676bfc0db5108ee449e1","filename":"hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"776a7f50a79a4a1470b3f39634d93aefee5ea08b","filename":"hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c5f7c622f146e60c1f83b71aff760532ecddccb9","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"added","additions":230,"deletions":0,"changes":230,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"5ab97a7c0b573cae02608e0b7fb082cc0a097238","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"7c621c2c57f61fa148d06e02b7cb577f4a3b461f","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","status":"added","additions":221,"deletions":0,"changes":221,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"1e3d5dd29ab981af1bca63cdaca16238ffbb58ed","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"25b2ace6d5dafafe1f032b8151785e398e4471f3","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"14a24beed4301439a5f3d8f88d87ff9aa6c87249","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"dc4b4d1d4e34afa338fee5b60bc302f6168e72ef","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c24b226a01ca3b8b99b32cba30e1abfe96bb9b6e","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","status":"added","additions":692,"deletions":0,"changes":692,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"c8edb616715eaa547ba9460acb4dddc9e25a3142","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"66edbaaeaf5d842120863b68f714645ed995b0ef","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","status":"added","additions":260,"deletions":0,"changes":260,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"7ea9aff369f654fa849fa8593a14827036c2e5f5","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java","status":"added","additions":170,"deletions":0,"changes":170,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a1e2b0de68045e8621139c7da7f22b6789febbd3","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","status":"added","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"5fa0a1acf8e465d26a3e94e05af5cee981fc7667","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"4ef31984485a31b4d69fdcf9c3246ba919448ae7","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"daab792f4cd8c22df2c8cfd87050ab0f4741c8e9","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"fcefaa332a4aa3a746700a3a3d67fc5b68268b48","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"d80f17aa6d8b23c043b2990f73520a953abd0fbb","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"f015799074413773a67283afa23af9652e452956","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","status":"added","additions":305,"deletions":0,"changes":305,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"ffb297f5bbdd184cc1bb8a61111486dd0a92a2d2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"317481b77461a6f62e153e7bf3b8ebc371a82891","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","status":"added","additions":268,"deletions":0,"changes":268,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"850d64cc42e799b5da7444c04a8ff00806eba5f0","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"4b48497702fb11d2b952f9d443c19ae73da26ee4","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","status":"added","additions":206,"deletions":0,"changes":206,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"26b403f61f4a349caccb34239efb468b25750ad3","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"caaa08db3cafea67e69eaa707600e2067f53ef71","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","status":"added","additions":311,"deletions":0,"changes":311,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"94a2d61a015a35c61e4b523a01da68fc262f00df","filename":"hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"a2c9d76d935c74da65aaa38acb12ae97065f8899","filename":"hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"32f43b1a6e40d9408785a36234f9a51646e51ff6","filename":"pom.xml","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/pom.xml?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"346da2ccfb4794f6c084b1409b188af077251f83","filename":"scripts/README.txt","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/README.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/README.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/scripts/README.txt?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6a468c9c406dddb72ca0557db9041dd929ea4e60","filename":"scripts/analyze.py","status":"added","additions":201,"deletions":0,"changes":201,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/analyze.py","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/analyze.py","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/scripts/analyze.py?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"d31d73f4ebd0c928894754c878a83de972690b6e","filename":"scripts/hw.bash","status":"added","additions":734,"deletions":0,"changes":734,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/hw.bash","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/hw.bash","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/scripts/hw.bash?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"face753a907fdd4dc01d226ba60a588db99b4169","filename":"scripts/hwServer.sh","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/hwServer.sh","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/hwServer.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/scripts/hwServer.sh?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"},{"sha":"6fe3e1765523f55a1e0e9304ba5492743a192388","filename":"scripts/quote","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/quote","raw_url":"https://github.com/apache/bookkeeper/raw/c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9/scripts/quote","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/scripts/quote?ref=c1c8bef6125cb70ed2da68e92bb49e45f4ea64a9"}]}

