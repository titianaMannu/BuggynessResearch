{"sha":"c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjMmVmZDBhNDhjNWQxZWE0ZWRkN2JmMzNjNjlhN2U1MjcwOTQyZWI0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-07-11T17:11:06Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-07-11T17:11:06Z"},"message":"BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1360300 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d59560ee0ba2d11566cd72e6a3e5d33f7b0f8577","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d59560ee0ba2d11566cd72e6a3e5d33f7b0f8577"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","html_url":"https://github.com/apache/bookkeeper/commit/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"fbcc0b583fd698cfa9ca232f4be5b0d584bb3ee5","url":"https://api.github.com/repos/apache/bookkeeper/commits/fbcc0b583fd698cfa9ca232f4be5b0d584bb3ee5","html_url":"https://github.com/apache/bookkeeper/commit/fbcc0b583fd698cfa9ca232f4be5b0d584bb3ee5"}],"stats":{"total":3016,"additions":2643,"deletions":373},"files":[{"sha":"b25e1fd21fc26293148a4663635e7e5d6f00ca3e","filename":"CHANGES.txt","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -54,6 +54,10 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-328: Bookie DeathWatcher is missing thread name (Rakesh via sijie)\n \n+      hedwig-server:\n+\n+        BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"750471b027ed1505731545b061bceb3bc8ebe83d","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","status":"modified","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -50,6 +50,18 @@ public static PubSubException create(StatusCode code, String msg) {\n             return new ServiceDownException(msg);\n         } else if (code == StatusCode.COULD_NOT_CONNECT) {\n             return new CouldNotConnectException(msg);\n+        } else if (code == StatusCode.TOPIC_BUSY) {\n+            return new TopicBusyException(msg);\n+        } else if (code == StatusCode.BAD_VERSION) {\n+            return new BadVersionException(msg);\n+        } else if (code == StatusCode.NO_TOPIC_PERSISTENCE_INFO) {\n+            return new NoTopicPersistenceInfoException(msg);\n+        } else if (code == StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS) {\n+            return new TopicPersistenceInfoExistsException(msg);\n+        } else if (code == StatusCode.NO_SUBSCRIPTION_STATE) {\n+            return new NoSubscriptionStateException(msg);\n+        } else if (code == StatusCode.SUBSCRIPTION_STATE_EXISTS) {\n+            return new SubscriptionStateExistsException(msg);\n         }\n         /*\n          * Insert new ones here\n@@ -120,6 +132,36 @@ public CouldNotConnectException(String msg) {\n         }\n     }\n \n+    public static class BadVersionException extends PubSubException {\n+        public BadVersionException(String msg) {\n+            super(StatusCode.BAD_VERSION, msg);\n+        }\n+    }\n+\n+    public static class NoTopicPersistenceInfoException extends PubSubException {\n+        public NoTopicPersistenceInfoException(String msg) {\n+            super(StatusCode.NO_TOPIC_PERSISTENCE_INFO, msg);\n+        }\n+    }\n+\n+    public static class TopicPersistenceInfoExistsException extends PubSubException {\n+        public TopicPersistenceInfoExistsException(String msg) {\n+            super(StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS, msg);\n+        }\n+    }\n+\n+    public static class NoSubscriptionStateException extends PubSubException {\n+        public NoSubscriptionStateException(String msg) {\n+            super(StatusCode.NO_SUBSCRIPTION_STATE, msg);\n+        }\n+    }\n+\n+    public static class SubscriptionStateExistsException extends PubSubException {\n+        public SubscriptionStateExistsException(String msg) {\n+            super(StatusCode.SUBSCRIPTION_STATE_EXISTS, msg);\n+        }\n+    }\n+\n     /*\n      * Insert new ones here\n      */"},{"sha":"330441d8c0d4ed2b0cca95bcccbf948b5478041f","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":497,"deletions":16,"changes":513,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -167,8 +167,13 @@ private OperationType(int index, int value) {\n     NOT_RESPONSIBLE_FOR_TOPIC(7, 501),\n     SERVICE_DOWN(8, 502),\n     UNCERTAIN_STATE(9, 503),\n-    UNEXPECTED_CONDITION(10, 600),\n-    COMPOSITE(11, 700),\n+    BAD_VERSION(10, 520),\n+    NO_TOPIC_PERSISTENCE_INFO(11, 521),\n+    TOPIC_PERSISTENCE_INFO_EXISTS(12, 522),\n+    NO_SUBSCRIPTION_STATE(13, 523),\n+    SUBSCRIPTION_STATE_EXISTS(14, 524),\n+    UNEXPECTED_CONDITION(15, 600),\n+    COMPOSITE(16, 700),\n     ;\n     \n     public static final int SUCCESS_VALUE = 0;\n@@ -181,6 +186,11 @@ private OperationType(int index, int value) {\n     public static final int NOT_RESPONSIBLE_FOR_TOPIC_VALUE = 501;\n     public static final int SERVICE_DOWN_VALUE = 502;\n     public static final int UNCERTAIN_STATE_VALUE = 503;\n+    public static final int BAD_VERSION_VALUE = 520;\n+    public static final int NO_TOPIC_PERSISTENCE_INFO_VALUE = 521;\n+    public static final int TOPIC_PERSISTENCE_INFO_EXISTS_VALUE = 522;\n+    public static final int NO_SUBSCRIPTION_STATE_VALUE = 523;\n+    public static final int SUBSCRIPTION_STATE_EXISTS_VALUE = 524;\n     public static final int UNEXPECTED_CONDITION_VALUE = 600;\n     public static final int COMPOSITE_VALUE = 700;\n     \n@@ -199,6 +209,11 @@ public static StatusCode valueOf(int value) {\n         case 501: return NOT_RESPONSIBLE_FOR_TOPIC;\n         case 502: return SERVICE_DOWN;\n         case 503: return UNCERTAIN_STATE;\n+        case 520: return BAD_VERSION;\n+        case 521: return NO_TOPIC_PERSISTENCE_INFO;\n+        case 522: return TOPIC_PERSISTENCE_INFO_EXISTS;\n+        case 523: return NO_SUBSCRIPTION_STATE;\n+        case 524: return SUBSCRIPTION_STATE_EXISTS;\n         case 600: return UNEXPECTED_CONDITION;\n         case 700: return COMPOSITE;\n         default: return null;\n@@ -231,7 +246,7 @@ public StatusCode findValueByNumber(int number) {\n     }\n     \n     private static final StatusCode[] VALUES = {\n-      SUCCESS, MALFORMED_REQUEST, NO_SUCH_TOPIC, CLIENT_ALREADY_SUBSCRIBED, CLIENT_NOT_SUBSCRIBED, COULD_NOT_CONNECT, TOPIC_BUSY, NOT_RESPONSIBLE_FOR_TOPIC, SERVICE_DOWN, UNCERTAIN_STATE, UNEXPECTED_CONDITION, COMPOSITE, \n+      SUCCESS, MALFORMED_REQUEST, NO_SUCH_TOPIC, CLIENT_ALREADY_SUBSCRIBED, CLIENT_NOT_SUBSCRIBED, COULD_NOT_CONNECT, TOPIC_BUSY, NOT_RESPONSIBLE_FOR_TOPIC, SERVICE_DOWN, UNCERTAIN_STATE, BAD_VERSION, NO_TOPIC_PERSISTENCE_INFO, TOPIC_PERSISTENCE_INFO_EXISTS, NO_SUBSCRIPTION_STATE, SUBSCRIPTION_STATE_EXISTS, UNEXPECTED_CONDITION, COMPOSITE, \n     };\n     \n     public static StatusCode valueOf(\n@@ -8933,6 +8948,454 @@ public Builder removeRanges(int index) {\n     // @@protoc_insertion_point(class_scope:Hedwig.LedgerRanges)\n   }\n   \n+  public interface ManagerMetaOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required string managerImpl = 2;\n+    boolean hasManagerImpl();\n+    String getManagerImpl();\n+    \n+    // required uint32 managerVersion = 3;\n+    boolean hasManagerVersion();\n+    int getManagerVersion();\n+  }\n+  public static final class ManagerMeta extends\n+      com.google.protobuf.GeneratedMessage\n+      implements ManagerMetaOrBuilder {\n+    // Use ManagerMeta.newBuilder() to construct.\n+    private ManagerMeta(Builder builder) {\n+      super(builder);\n+    }\n+    private ManagerMeta(boolean noInit) {}\n+    \n+    private static final ManagerMeta defaultInstance;\n+    public static ManagerMeta getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public ManagerMeta getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_ManagerMeta_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_ManagerMeta_fieldAccessorTable;\n+    }\n+    \n+    private int bitField0_;\n+    // required string managerImpl = 2;\n+    public static final int MANAGERIMPL_FIELD_NUMBER = 2;\n+    private java.lang.Object managerImpl_;\n+    public boolean hasManagerImpl() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public String getManagerImpl() {\n+      java.lang.Object ref = managerImpl_;\n+      if (ref instanceof String) {\n+        return (String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs = \n+            (com.google.protobuf.ByteString) ref;\n+        String s = bs.toStringUtf8();\n+        if (com.google.protobuf.Internal.isValidUtf8(bs)) {\n+          managerImpl_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    private com.google.protobuf.ByteString getManagerImplBytes() {\n+      java.lang.Object ref = managerImpl_;\n+      if (ref instanceof String) {\n+        com.google.protobuf.ByteString b = \n+            com.google.protobuf.ByteString.copyFromUtf8((String) ref);\n+        managerImpl_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+    \n+    // required uint32 managerVersion = 3;\n+    public static final int MANAGERVERSION_FIELD_NUMBER = 3;\n+    private int managerVersion_;\n+    public boolean hasManagerVersion() {\n+      return ((bitField0_ & 0x00000002) == 0x00000002);\n+    }\n+    public int getManagerVersion() {\n+      return managerVersion_;\n+    }\n+    \n+    private void initFields() {\n+      managerImpl_ = \"\";\n+      managerVersion_ = 0;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasManagerImpl()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      if (!hasManagerVersion()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeBytes(2, getManagerImplBytes());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        output.writeUInt32(3, managerVersion_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(2, getManagerImplBytes());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeUInt32Size(3, managerVersion_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.hedwig.protocol.PubSubProtocol.ManagerMetaOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_ManagerMeta_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_ManagerMeta_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        managerImpl_ = \"\";\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        managerVersion_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.getDescriptor();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta getDefaultInstanceForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.getDefaultInstance();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta build() {\n+        org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta buildPartial() {\n+        org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta result = new org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.managerImpl_ = managerImpl_;\n+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.managerVersion_ = managerVersion_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta) {\n+          return mergeFrom((org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta other) {\n+        if (other == org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.getDefaultInstance()) return this;\n+        if (other.hasManagerImpl()) {\n+          setManagerImpl(other.getManagerImpl());\n+        }\n+        if (other.hasManagerVersion()) {\n+          setManagerVersion(other.getManagerVersion());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasManagerImpl()) {\n+          \n+          return false;\n+        }\n+        if (!hasManagerVersion()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 18: {\n+              bitField0_ |= 0x00000001;\n+              managerImpl_ = input.readBytes();\n+              break;\n+            }\n+            case 24: {\n+              bitField0_ |= 0x00000002;\n+              managerVersion_ = input.readUInt32();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required string managerImpl = 2;\n+      private java.lang.Object managerImpl_ = \"\";\n+      public boolean hasManagerImpl() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public String getManagerImpl() {\n+        java.lang.Object ref = managerImpl_;\n+        if (!(ref instanceof String)) {\n+          String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();\n+          managerImpl_ = s;\n+          return s;\n+        } else {\n+          return (String) ref;\n+        }\n+      }\n+      public Builder setManagerImpl(String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000001;\n+        managerImpl_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearManagerImpl() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        managerImpl_ = getDefaultInstance().getManagerImpl();\n+        onChanged();\n+        return this;\n+      }\n+      void setManagerImpl(com.google.protobuf.ByteString value) {\n+        bitField0_ |= 0x00000001;\n+        managerImpl_ = value;\n+        onChanged();\n+      }\n+      \n+      // required uint32 managerVersion = 3;\n+      private int managerVersion_ ;\n+      public boolean hasManagerVersion() {\n+        return ((bitField0_ & 0x00000002) == 0x00000002);\n+      }\n+      public int getManagerVersion() {\n+        return managerVersion_;\n+      }\n+      public Builder setManagerVersion(int value) {\n+        bitField0_ |= 0x00000002;\n+        managerVersion_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearManagerVersion() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        managerVersion_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:Hedwig.ManagerMeta)\n+    }\n+    \n+    static {\n+      defaultInstance = new ManagerMeta(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:Hedwig.ManagerMeta)\n+  }\n+  \n   private static com.google.protobuf.Descriptors.Descriptor\n     internal_static_Hedwig_Message_descriptor;\n   private static\n@@ -9008,6 +9471,11 @@ public Builder removeRanges(int index) {\n   private static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_Hedwig_LedgerRanges_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_Hedwig_ManagerMeta_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_Hedwig_ManagerMeta_fieldAccessorTable;\n   \n   public static com.google.protobuf.Descriptors.FileDescriptor\n       getDescriptor() {\n@@ -9062,19 +9530,24 @@ public Builder removeRanges(int index) {\n       \"Id\\022\\024\\n\\014messageBound\\030\\002 \\001(\\r\\\"O\\n\\013LedgerRange\\022\" +\n       \"\\020\\n\\010ledgerId\\030\\001 \\002(\\004\\022.\\n\\020endSeqIdIncluded\\030\\002 \" +\n       \"\\001(\\0132\\024.Hedwig.MessageSeqId\\\"3\\n\\014LedgerRange\" +\n-      \"s\\022#\\n\\006ranges\\030\\001 \\003(\\0132\\023.Hedwig.LedgerRange*\\\"\" +\n-      \"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_ONE\\020\\001*p\\n\\rOp\" +\n-      \"erationType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\\022\" +\n-      \"\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\\022\\022\\n\\016START_D\" +\n-      \"ELIVERY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005*\\236\\002\\n\\nStatusC\",\n-      \"ode\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\" +\n-      \"\\022\\022\\n\\rNO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_S\" +\n-      \"UBSCRIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\" +\n-      \"\\022\\026\\n\\021COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\" +\n-      \"\\003\\022\\036\\n\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SER\" +\n-      \"VICE_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\031\\n\\024UN\" +\n-      \"EXPECTED_CONDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\" +\n-      \"\\032org.apache.hedwig.protocolH\\001\"\n+      \"s\\022#\\n\\006ranges\\030\\001 \\003(\\0132\\023.Hedwig.LedgerRange\\\":\" +\n+      \"\\n\\013ManagerMeta\\022\\023\\n\\013managerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016ma\" +\n+      \"nagerVersion\\030\\003 \\002(\\r*\\\"\\n\\017ProtocolVersion\\022\\017\\n\" +\n+      \"\\013VERSION_ONE\\020\\001*p\\n\\rOperationType\\022\\013\\n\\007PUBLI\" +\n+      \"SH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013UNSU\",\n+      \"BSCRIBE\\020\\003\\022\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rSTOP_DE\" +\n+      \"LIVERY\\020\\005*\\260\\003\\n\\nStatusCode\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021\" +\n+      \"MALFORMED_REQUEST\\020\\221\\003\\022\\022\\n\\rNO_SUCH_TOPIC\\020\\222\\003\" +\n+      \"\\022\\036\\n\\031CLIENT_ALREADY_SUBSCRIBED\\020\\223\\003\\022\\032\\n\\025CLIE\" +\n+      \"NT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\\n\\021COULD_NOT_CONNEC\" +\n+      \"T\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\\036\\n\\031NOT_RESPONSIBLE\" +\n+      \"_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVICE_DOWN\\020\\366\\003\\022\\024\\n\\017UNCE\" +\n+      \"RTAIN_STATE\\020\\367\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\\036\\n\\031NO_T\" +\n+      \"OPIC_PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC_PERSIS\" +\n+      \"TENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCRIPTION_\",\n+      \"STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EXISTS\\020\\214\\004\" +\n+      \"\\022\\031\\n\\024UNEXPECTED_CONDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\" +\n+      \"\\020\\274\\005B\\036\\n\\032org.apache.hedwig.protocolH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -9201,6 +9674,14 @@ public Builder removeRanges(int index) {\n               new java.lang.String[] { \"Ranges\", },\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges.class,\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges.Builder.class);\n+          internal_static_Hedwig_ManagerMeta_descriptor =\n+            getDescriptor().getMessageTypes().get(15);\n+          internal_static_Hedwig_ManagerMeta_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_Hedwig_ManagerMeta_descriptor,\n+              new java.lang.String[] { \"ManagerImpl\", \"ManagerVersion\", },\n+              org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.class,\n+              org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.Builder.class);\n           return null;\n         }\n       };"},{"sha":"d29cfe9cfa4de809e0ab7b7c00a3d9524e1cbcb9","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":12,"deletions":1,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -156,7 +156,14 @@ enum StatusCode{\n     NOT_RESPONSIBLE_FOR_TOPIC = 501;\n     SERVICE_DOWN = 502;\n     UNCERTAIN_STATE = 503;\n-    \n+\n+    //server-side meta manager errors (52x)\n+    BAD_VERSION = 520;\n+    NO_TOPIC_PERSISTENCE_INFO = 521;\n+    TOPIC_PERSISTENCE_INFO_EXISTS = 522;\n+    NO_SUBSCRIPTION_STATE = 523;\n+    SUBSCRIPTION_STATE_EXISTS = 524;\n+\n     //For all unexpected error conditions\n     UNEXPECTED_CONDITION = 600;\n     \n@@ -180,3 +187,7 @@ message LedgerRanges{\n     repeated LedgerRange ranges = 1;\n }\n \n+message ManagerMeta {\n+    required string managerImpl = 2;\n+    required uint32 managerVersion = 3;\n+}"},{"sha":"cf52ae8672e1693228568e7732a36ca7f70058be","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -30,7 +30,9 @@\n import org.apache.commons.configuration.ConfigurationException;\n \n import com.google.protobuf.ByteString;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.hedwig.conf.AbstractConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.util.HedwigSocketAddress;\n \n public class ServerConfiguration extends AbstractConfiguration {\n@@ -60,6 +62,17 @@\n     protected final static String BK_QUORUM_SIZE = \"bk_quorum_size\";\n     protected final static String RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL = \"retry_remote_subscribe_thread_run_interval\";\n \n+    // manager related settings\n+    protected final static String METADATA_MANAGER_FACTORY_CLASS = \"metadata_manager_factory_class\";\n+\n+    private static ClassLoader defaultLoader;\n+    static {\n+        defaultLoader = Thread.currentThread().getContextClassLoader();\n+        if (null == defaultLoader) {\n+            defaultLoader = ServerConfiguration.class.getClassLoader();\n+        }\n+    }\n+\n     // these are the derived attributes\n     protected ByteString myRegionByteString = null;\n     protected HedwigSocketAddress myServerAddress = null;\n@@ -153,6 +166,17 @@ public StringBuilder getZkRegionPrefix(StringBuilder sb) {\n         return sb.append(getZkPrefix()).append(\"/\").append(getMyRegion());\n     }\n \n+    /**\n+     * Get znode path to store manager layouts.\n+     *\n+     * @param sb\n+     *          StringBuilder to store znode path to store manager layouts.\n+     * @return znode path to store manager layouts.\n+     */\n+    public StringBuilder getZkManagersPrefix(StringBuilder sb) {\n+        return getZkRegionPrefix(sb).append(\"/managers\");\n+    }\n+\n     public StringBuilder getZkTopicsPrefix(StringBuilder sb) {\n         return getZkRegionPrefix(sb).append(\"/topics\");\n     }\n@@ -296,4 +320,28 @@ public void validate() throws ConfigurationException {\n \n         // add other checks here\n     }\n+\n+    /**\n+     * Get metadata manager factory class.\n+     *\n+     * @return manager class\n+     */\n+    public Class<? extends MetadataManagerFactory> getMetadataManagerFactoryClass()\n+    throws ConfigurationException {\n+        return ReflectionUtils.getClass(conf, METADATA_MANAGER_FACTORY_CLASS,\n+                                        null, MetadataManagerFactory.class,\n+                                        defaultLoader);\n+    }\n+\n+    /**\n+     * Set metadata manager factory class name\n+     *\n+     * @param managerClsName\n+     *          Manager Class Name\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setMetadataManagerFactoryName(String managerClsName) {\n+        conf.setProperty(METADATA_MANAGER_FACTORY_CLASS, managerClsName);\n+        return this;\n+    }\n }"},{"sha":"fc9e0928d3a8682c1dbe181e6d4aeb2503770b4b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,149 @@\n+package org.apache.hedwig.server.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.TextFormat;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.zookeeper.ZkUtils;\n+\n+/**\n+ * This class encapsulates metadata manager layout information\n+ * that is persistently stored in zookeeper.\n+ * It provides parsing and serialization methods of such information.\n+ *\n+ */\n+public class FactoryLayout {\n+    static final Logger logger = LoggerFactory.getLogger(FactoryLayout.class);\n+\n+    // metadata manager name\n+    public static final String NAME = \"METADATA\";\n+    // Znode name to store layout information\n+    public static final String LAYOUT_ZNODE = \"LAYOUT\";\n+    public static final String LSEP = \"\\n\";\n+\n+    private ManagerMeta managerMeta;\n+\n+    /**\n+     * Construct metadata manager factory layout.\n+     *\n+     * @param meta\n+     *          Meta describes what kind of factory used.\n+     */\n+    public FactoryLayout(ManagerMeta meta) {\n+        this.managerMeta = meta;\n+    }\n+\n+    public static String getFactoryLayoutPath(StringBuilder sb, ServerConfiguration cfg) {\n+        return cfg.getZkManagersPrefix(sb).append(\"/\").append(NAME)\n+               .append(\"/\").append(LAYOUT_ZNODE).toString();\n+    }\n+\n+    public ManagerMeta getManagerMeta() {\n+        return managerMeta;\n+    }\n+\n+    /**\n+     * Store the factory layout into zookeeper\n+     *\n+     * @param zk\n+     *          ZooKeeper Handle\n+     * @param cfg\n+     *          Server Configuration Object\n+     * @throws KeeperException\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    public void store(ZooKeeper zk, ServerConfiguration cfg)\n+    throws KeeperException, IOException, InterruptedException {\n+        String factoryLayoutPath = getFactoryLayoutPath(new StringBuilder(), cfg);\n+\n+        byte[] layoutData = TextFormat.printToString(managerMeta).getBytes();\n+        ZkUtils.createFullPathOptimistic(zk, factoryLayoutPath, layoutData,\n+                                         Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return managerMeta.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (null == o ||\n+            !(o instanceof FactoryLayout)) {\n+            return false;\n+        }\n+        FactoryLayout other = (FactoryLayout)o;\n+        return managerMeta.equals(other.managerMeta);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return TextFormat.printToString(managerMeta);\n+    }\n+\n+    /**\n+     * Read factory layout from zookeeper\n+     *\n+     * @param zk\n+     *          ZooKeeper Client\n+     * @param cfg\n+     *          Server configuration object\n+     * @return Factory layout, or null if none set in zookeeper\n+     */\n+    public static FactoryLayout readLayout(final ZooKeeper zk,\n+                                           final ServerConfiguration cfg)\n+    throws IOException, KeeperException {\n+        String factoryLayoutPath = getFactoryLayoutPath(new StringBuilder(), cfg);\n+        byte[] layoutData;\n+        try {\n+            layoutData = zk.getData(factoryLayoutPath, false, null);\n+        } catch (KeeperException.NoNodeException nne) {\n+            return null;\n+        } catch (InterruptedException ie) {\n+            throw new IOException(ie);\n+        }\n+        ManagerMeta meta;\n+        try {\n+            BufferedReader reader = new BufferedReader(\n+                new StringReader(new String(layoutData)));\n+            ManagerMeta.Builder metaBuilder = ManagerMeta.newBuilder();\n+            TextFormat.merge(reader, metaBuilder);\n+            meta = metaBuilder.build();\n+        } catch (InvalidProtocolBufferException ipbe) {\n+            throw new IOException(\"Corrupted factory layout : \", ipbe);\n+        }\n+\n+        return new FactoryLayout(meta);\n+    }\n+}"},{"sha":"21b4577f403574852593c6959a36b471f80bd1b4","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Metadata Manager used to manage metadata used by hedwig.\n+ */\n+public abstract class MetadataManagerFactory {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(MetadataManagerFactory.class);\n+\n+    /**\n+     * Return current factory version.\n+     *\n+     * @return current version used by factory.\n+     */\n+    public abstract int getCurrentVersion();\n+\n+    /**\n+     * Initialize the metadata manager factory with given\n+     * configuration and version.\n+     *\n+     * @param cfg\n+     *          Server configuration object\n+     * @param zk\n+     *          ZooKeeper handler\n+     * @param version\n+     *          Manager version\n+     * @return metadata manager factory\n+     * @throws IOException when fail to initialize the manager.\n+     */\n+    protected abstract MetadataManagerFactory initialize(\n+        ServerConfiguration cfg, ZooKeeper zk, int version)\n+    throws IOException;\n+\n+    /**\n+     * Uninitialize the factory.\n+     *\n+     * @throws IOException when fail to shutdown the factory.\n+     */\n+    public abstract void shutdown() throws IOException;\n+\n+    /**\n+     * Create topic persistence manager.\n+     *\n+     * @return topic persistence manager\n+     */\n+    public abstract TopicPersistenceManager newTopicPersistenceManager();\n+\n+    /**\n+     * Create subscription data manager.\n+     *\n+     * @return subscription data manager.\n+     */\n+    public abstract SubscriptionDataManager newSubscriptionDataManager();\n+\n+    /**\n+     * Create new Metadata Manager Factory.\n+     *\n+     * @param conf\n+     *          Configuration Object.\n+     * @param zk\n+     *          ZooKeeper Client Handle, talk to zk to know which manager factory is used.\n+     * @return new manager factory.\n+     * @throws IOException\n+     */\n+    public static MetadataManagerFactory newMetadataManagerFactory(\n+        final ServerConfiguration conf, final ZooKeeper zk)\n+    throws IOException, KeeperException, InterruptedException {\n+        Class<? extends MetadataManagerFactory> factoryClass;\n+        try {\n+            factoryClass = conf.getMetadataManagerFactoryClass();\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get metadata manager factory class from configuration : \", e);\n+        }\n+\n+        MetadataManagerFactory managerFactory;\n+\n+        // check that the configured manager is\n+        // compatible with the existing layout\n+        FactoryLayout layout = FactoryLayout.readLayout(zk, conf);\n+        if (layout == null) { // no existing layout\n+            // use default manager if no one provided\n+            if (factoryClass == null) {\n+                factoryClass = ZkMetadataManagerFactory.class;\n+            }\n+            try {\n+                managerFactory = ReflectionUtils.newInstance(factoryClass);\n+            } catch (Throwable t) {\n+                throw new IOException(\"Fail to instantiate metadata manager factory : \" + factoryClass, t);\n+            }\n+            ManagerMeta managerMeta = ManagerMeta.newBuilder()\n+                                      .setManagerImpl(factoryClass.getName())\n+                                      .setManagerVersion(managerFactory.getCurrentVersion())\n+                                      .build();\n+            layout = new FactoryLayout(managerMeta);\n+            try {\n+                layout.store(zk, conf);\n+            } catch (KeeperException.NodeExistsException nee) {\n+                FactoryLayout layout2 = FactoryLayout.readLayout(zk, conf);\n+                if (!layout2.equals(layout)) {\n+                    throw new IOException(\"Contention writing to layout to zookeeper, \"\n+                            + \" other layout \" + layout2 + \" is incompatible with our \"\n+                            + \"layout \" + layout);\n+                }\n+            }\n+            return managerFactory.initialize(conf, zk, layout.getManagerMeta().getManagerVersion());\n+        }\n+        LOG.debug(\"read meta layout {}\", layout);\n+\n+        if (factoryClass != null &&\n+            !layout.getManagerMeta().getManagerImpl().equals(factoryClass.getName())) {\n+            throw new IOException(\"Configured metadata manager factory \" + factoryClass.getName()\n+                                + \" does not match existing factory \"  + layout.getManagerMeta().getManagerImpl());\n+        }\n+        if (factoryClass == null) {\n+            // no factory specified in configuration\n+            String factoryClsName = layout.getManagerMeta().getManagerImpl();\n+            try {\n+                Class<?> theCls = Class.forName(factoryClsName);\n+                if (!MetadataManagerFactory.class.isAssignableFrom(theCls)) {\n+                    throw new IOException(\"Wrong metadata manager factory \" + factoryClsName);\n+                }\n+                factoryClass = theCls.asSubclass(MetadataManagerFactory.class);\n+            } catch (ClassNotFoundException cnfe) {\n+                throw new IOException(\"No class found to instantiate metadata manager factory \" + factoryClsName);\n+            }\n+        }\n+        // instantiate the metadata manager factory\n+        try {\n+            managerFactory = ReflectionUtils.newInstance(factoryClass);\n+        } catch (Throwable t) {\n+            throw new IOException(\"Failed to instantiate metadata manager factory : \" + factoryClass, t);\n+        }\n+        return managerFactory.initialize(conf, zk, layout.getManagerMeta().getManagerVersion());\n+    }\n+}"},{"sha":"f83344f27c27fd42408ad1575005a02af43fc01f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,118 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Manage subscription data.\n+ */\n+public interface SubscriptionDataManager extends Closeable {\n+\n+    /**\n+     * Create subscription state.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param state\n+     *          Subscription state\n+     * @param callback\n+     *          Callback when subscription state created.\n+     *          {@link PubSubException.SubscriptionStateExistsException} is returned when subscription state\n+     *          existed before.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void createSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n+                                        Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Update subscription state.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param state\n+     *          Subscription state\n+     * @param callback\n+     *          Callback when subscription state updated.\n+     *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n+     *          is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void updateSubscriptionState(ByteString topic, ByteString subscriberId, SubscriptionState state,\n+                                        Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Remove subscription state.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param callback\n+     *          Callback when subscription state deleted\n+     *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n+     *          is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void deleteSubscriptionState(ByteString topic, ByteString subscriberId,\n+                                        Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Read subscription state.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param callback\n+     *          Callback when subscription state read.\n+     *          Null is returned when no subscription state is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void readSubscriptionState(ByteString topic, ByteString subscriberId,\n+                                      Callback<SubscriptionState> callback, Object ctx);\n+\n+    /**\n+     * Read all subscriptions of a topic.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param callback\n+     *          Callback to return subscriptions\n+     * @param ctx\n+     *          Contxt of the callback\n+     */\n+    public void readSubscriptions(ByteString topic, Callback<Map<ByteString, InMemorySubscriptionState>> cb,\n+                                  Object ctx);\n+}"},{"sha":"f0a54005f33898c1e5291ff077691042b64df3d5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.Closeable;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Manage topic persistence metadata.\n+ */\n+public interface TopicPersistenceManager extends Closeable {\n+\n+    /**\n+     * Read persistence info of a specified topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param callback\n+     *          Callback when read persistence info.\n+     *          If no persistence info found, return null.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void readTopicPersistenceInfo(ByteString topic,\n+                                         Callback<Versioned<LedgerRanges>> callback, Object ctx);\n+\n+    /**\n+     * Update persistence info of a specified topic.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param ranges\n+     *          Persistence info\n+     * @param version\n+     *          Current version of persistence info.\n+     *          If <code>version</code> is null, create persistence info;\n+     *          {@link PubSubException.TopicPersistenceInfoExistsException} is returned when\n+     *          persistence info existed before.\n+     *          If <code>version</code> is not null, the persitence info is updated only when\n+     *          provided version equals to its current version.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoTopicPersistenceInfoException} is returned when no\n+     *          persistence info found to update.\n+     * @param callback\n+     *          Callback when persistence info updated. New version would be returned.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void writeTopicPersistenceInfo(ByteString topic, LedgerRanges ranges, Version version,\n+                                          Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Delete persistence info of a specified topic.\n+     * Currently used in test cases.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param version\n+     *          Current version of persistence info\n+     *          If <code>version</code> is null, delete persistence info no matter its current version.\n+     *          If <code>version</code> is not null, the persitence info is deleted only when\n+     *          provided version equals to its current version.\n+     * @param callback\n+     *          Callback return whether the deletion succeed.\n+     *          {@link PubSubException.NoTopicPersistenceInfoException} is returned when no persistence.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match.\n+     *          info found to delete.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void deleteTopicPersistenceInfo(ByteString topic, Version version,\n+                                           Callback<Void> callback, Object ctx);\n+\n+}"},{"sha":"8a850af93ad227d41044e748aeb8370abed4f195","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","status":"added","additions":559,"deletions":0,"changes":559,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,559 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.data.Stat;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.bookkeeper.meta.ZkVersion;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n+import org.apache.hedwig.zookeeper.ZkUtils;\n+\n+/**\n+ * ZooKeeper-based Metadata Manager.\n+ */\n+public class ZkMetadataManagerFactory extends MetadataManagerFactory {\n+    protected final static Logger logger = LoggerFactory.getLogger(ZkMetadataManagerFactory.class);\n+\n+    static final int CUR_VERSION = 1;\n+\n+    ZooKeeper zk;\n+    ServerConfiguration cfg;\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public MetadataManagerFactory initialize(ServerConfiguration cfg,\n+                                             ZooKeeper zk,\n+                                             int version)\n+    throws IOException {\n+        if (CUR_VERSION != version) {\n+            throw new IOException(\"Incompatible ZkMetadataManagerFactory version \" + version\n+                                + \" found, expected version \" + CUR_VERSION);\n+        }\n+        this.cfg = cfg;\n+        this.zk = zk;\n+        return this;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        // do nothing here, because zookeeper handle is passed from outside\n+        // we don't need to stop it.\n+    }\n+\n+    @Override\n+    public TopicPersistenceManager newTopicPersistenceManager() {\n+        return new ZkTopicPersistenceManagerImpl(cfg, zk);\n+    }\n+\n+    @Override\n+    public SubscriptionDataManager newSubscriptionDataManager() {\n+        return new ZkSubscriptionDataManagerImpl(cfg, zk);\n+    }\n+\n+    /**\n+     * ZooKeeper based topic persistence manager.\n+     */\n+    static class ZkTopicPersistenceManagerImpl implements TopicPersistenceManager {\n+\n+        ZooKeeper zk;\n+        ServerConfiguration cfg;\n+\n+        ZkTopicPersistenceManagerImpl(ServerConfiguration conf, ZooKeeper zk) {\n+            this.cfg = conf;\n+            this.zk = zk;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing in zookeeper based impl\n+        }\n+\n+        /**\n+         * Get znode path to store persistence info of a topic.\n+         *\n+         * @param topic\n+         *          Topic name\n+         * @return znode path to store persistence info.\n+         */\n+        private String ledgersPath(ByteString topic) {\n+            return cfg.getZkTopicPath(new StringBuilder(), topic).append(\"/ledgers\").toString();\n+        }\n+\n+        /**\n+         * Parse ledger ranges data and return it thru callback.\n+         *\n+         * @param topic\n+         *          Topic name\n+         * @param data\n+         *          Topic Ledger Ranges data\n+         * @param version\n+         *          Version of the topic ledger ranges data\n+         * @param callback\n+         *          Callback to return ledger ranges\n+         * @param ctx\n+         *          Context of the callback\n+         */\n+        private void parseAndReturnTopicLedgerRanges(ByteString topic, byte[] data, int version,\n+                                                     Callback<Versioned<LedgerRanges>> callback, Object ctx) {\n+            try {\n+                Versioned<LedgerRanges> ranges = new Versioned<LedgerRanges>(LedgerRanges.parseFrom(data),\n+                                                                             new ZkVersion(version));\n+                callback.operationFinished(ctx, ranges);\n+                return;\n+            } catch (InvalidProtocolBufferException e) {\n+                String msg = \"Ledger ranges for topic:\" + topic.toStringUtf8() + \" could not be deserialized\";\n+                logger.error(msg, e);\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                return;\n+            }\n+        }\n+\n+        @Override\n+        public void readTopicPersistenceInfo(final ByteString topic,\n+                                             final Callback<Versioned<LedgerRanges>> callback,\n+                                             Object ctx) {\n+            // read topic ledgers node data\n+            final String zNodePath = ledgersPath(topic);\n+\n+            zk.getData(zNodePath, false, new SafeAsyncZKCallback.DataCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    if (rc == Code.OK.intValue()) {\n+                        parseAndReturnTopicLedgerRanges(topic, data, stat.getVersion(), callback, ctx);\n+                        return;\n+                    }\n+\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // we don't create the znode until we first write it.\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    // otherwise some other error\n+                    KeeperException ke =\n+                        ZkUtils.logErrorAndCreateZKException(\"Could not read ledgers node for topic: \"\n+                                                             + topic.toStringUtf8(), path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                }\n+            }, ctx);\n+        }\n+\n+        private void createTopicPersistenceInfo(final ByteString topic, LedgerRanges ranges,\n+                                                final Callback<Version> callback, Object ctx) {\n+            final String zNodePath = ledgersPath(topic);\n+            final byte[] data = ranges.toByteArray();\n+            // create it\n+            ZkUtils.createFullPathOptimistic(zk, zNodePath, data, Ids.OPEN_ACL_UNSAFE,\n+            CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                    if (rc == Code.NODEEXISTS.intValue()) {\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS,\n+                                                      \"Persistence info of topic \" + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    }\n+                    if (rc != Code.OK.intValue()) {\n+                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                             \"Could not create ledgers node for topic: \" + topic.toStringUtf8(),\n+                                             path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                        return;\n+                    }\n+                    // initial version is version 0\n+                    callback.operationFinished(ctx, new ZkVersion(0));\n+                }\n+            }, ctx);\n+            return;\n+        }\n+\n+        @Override\n+        public void writeTopicPersistenceInfo(final ByteString topic, LedgerRanges ranges, final Version version,\n+                                              final Callback<Version> callback, Object ctx) {\n+            if (null == version) {\n+                createTopicPersistenceInfo(topic, ranges, callback, ctx);\n+                return;\n+            }\n+\n+            final String zNodePath = ledgersPath(topic);\n+            final byte[] data = ranges.toByteArray();\n+\n+            if (!(version instanceof ZkVersion)) {\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                              \"Invalid version provided to update persistence info for topic \" + topic.toStringUtf8()));\n+                return;\n+            }\n+\n+            int znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+            zk.setData(zNodePath, data, znodeVersion, new SafeAsyncZKCallback.StatCallback() {\n+                    @Override\n+                    public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                        if (rc == Code.NONODE.intValue()) {\n+                            // no node\n+                            callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                                          \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                            return;\n+                        } else if (rc == Code.BadVersion) {\n+                            // bad version\n+                            callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                          \"Bad version provided to update persistence info of topic \" + topic.toStringUtf8()));\n+                            return;\n+                        } else if (rc == Code.OK.intValue()) {\n+                            callback.operationFinished(ctx, new ZkVersion(stat.getVersion()));\n+                            return;\n+                        } else {\n+                            KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                    \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n+                            callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                            return;\n+                        }\n+                    }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteTopicPersistenceInfo(final ByteString topic, final Version version,\n+                                               final Callback<Void> callback, Object ctx) {\n+            final String zNodePath = ledgersPath(topic);\n+\n+            int znodeVersion = -1;\n+            if (null != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to delete persistence info for topic \" + topic.toStringUtf8()));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+            zk.delete(zNodePath, znodeVersion, new SafeAsyncZKCallback.VoidCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx) {\n+                    if (rc == Code.OK.intValue()) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                                      \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (rc == Code.BadVersion) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to delete persistence info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    }\n+\n+                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                        + \" failed to delete persistence info @version \" + version + \" : \", path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    /**\n+     * ZooKeeper based subscription data manager.\n+     */\n+    static class ZkSubscriptionDataManagerImpl implements SubscriptionDataManager {\n+\n+        ZooKeeper zk;\n+        ServerConfiguration cfg;\n+\n+        ZkSubscriptionDataManagerImpl(ServerConfiguration conf, ZooKeeper zk) {\n+            this.cfg = conf;\n+            this.zk = zk;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing in zookeeper based impl\n+        }\n+\n+        /**\n+         * Get znode path to store subscription states.\n+         *\n+         * @param sb\n+         *          String builder to store the znode path.\n+         * @param topic\n+         *          Topic name.\n+         *\n+         * @return string builder to store znode path.\n+         */\n+        private StringBuilder topicSubscribersPath(StringBuilder sb, ByteString topic) {\n+            return cfg.getZkTopicPath(sb, topic).append(\"/subscribers\");\n+        }\n+\n+        /**\n+         * Get znode path to store subscription state for a specified subscriber.\n+         *\n+         * @param topic\n+         *          Topic name.\n+         * @param subscriber\n+         *          Subscriber id.\n+         * @return znode path to store subscription state.\n+         */\n+        private String topicSubscriberPath(ByteString topic, ByteString subscriber) {\n+            return topicSubscribersPath(new StringBuilder(), topic).append(\"/\").append(subscriber.toStringUtf8())\n+                   .toString();\n+        }\n+\n+        @Override\n+        public void createSubscriptionState(final ByteString topic, final ByteString subscriberId, final SubscriptionState state,\n+                                            final Callback<Void> callback, final Object ctx) {\n+            ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), state.toByteArray(),\n+            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+\n+                    if (rc == Code.NODEEXISTS.intValue()) {\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.SUBSCRIPTION_STATE_EXISTS,\n+                                                      \"Subscription state for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                                      + subscriberId.toStringUtf8() + \") existed.\"));\n+                        return;\n+                    } else if (rc == Code.OK.intValue()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully recorded subscription for topic: \" + topic.toStringUtf8()\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n+                                         + SubscriptionStateUtils.toString(state));\n+                        }\n+                        callback.operationFinished(ctx, null);\n+                    } else {\n+                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                                 \"Could not record new subscription for topic: \" + topic.toStringUtf8()\n+                                                 + \" subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void updateSubscriptionState(final ByteString topic, final ByteString subscriberId, final SubscriptionState state,\n+                                            final Callback<Void> callback, final Object ctx) {\n+            zk.setData(topicSubscriberPath(topic, subscriberId), state.toByteArray(), -1,\n+            new SafeAsyncZKCallback.StatCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                                      \"No subscription state found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                                      + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else if (rc != Code.OK.intValue()) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                            + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                            + \" could not set subscription state: \" + SubscriptionStateUtils.toString(state),\n+                                            path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                    } else {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully updated subscription for topic: \" + topic.toStringUtf8()\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n+                                         + SubscriptionStateUtils.toString(state));\n+                        }\n+\n+                        callback.operationFinished(ctx, null);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteSubscriptionState(final ByteString topic, final ByteString subscriberId,\n+                                            final Callback<Void> callback, Object ctx) {\n+            zk.delete(topicSubscriberPath(topic, subscriberId), -1, new SafeAsyncZKCallback.VoidCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                                      \"No subscription state found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                                      + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else if (rc == Code.OK.intValue()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully deleted subscription for topic: \" + topic.toStringUtf8()\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8());\n+                        }\n+\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                        + \" subscriberId: \" + subscriberId.toStringUtf8() + \" failed to delete subscription\", path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void readSubscriptionState(final ByteString topic, final ByteString subscriberId,\n+                                          final Callback<SubscriptionState> callback, final Object ctx) {\n+            zk.getData(topicSubscriberPath(topic, subscriberId), false, new SafeAsyncZKCallback.DataCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+                    if (rc != Code.OK.intValue()) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                                + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+\n+                    SubscriptionState state;\n+                    try {\n+                        state = SubscriptionState.parseFrom(data);\n+                    } catch (InvalidProtocolBufferException ex) {\n+                        String msg = \"Failed to deserialize state for topic: \" + topic.toStringUtf8()\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8();\n+                        logger.error(msg, ex);\n+                        callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                        return;\n+                    }\n+\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                     + \"state: \" + SubscriptionStateUtils.toString(state));\n+                    }\n+                    callback.operationFinished(ctx, state);\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void readSubscriptions(final ByteString topic,\n+                                      final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n+            String topicSubscribersPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n+            zk.getChildren(topicSubscribersPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, final Object ctx, final List<String> children) {\n+\n+                    if (rc != Code.OK.intValue() && rc != Code.NONODE.intValue()) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read subscribers for topic \"\n+                                            + topic.toStringUtf8(), path, rc);\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+\n+                    final Map<ByteString, InMemorySubscriptionState> topicSubs = new ConcurrentHashMap<ByteString, InMemorySubscriptionState>();\n+\n+                    if (rc == Code.NONODE.intValue() || children.size() == 0) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"No subscriptions found while acquiring topic: \" + topic.toStringUtf8());\n+                        }\n+                        cb.operationFinished(ctx, topicSubs);\n+                        return;\n+                    }\n+\n+                    final AtomicBoolean failed = new AtomicBoolean();\n+                    final AtomicInteger count = new AtomicInteger();\n+\n+                    for (final String child : children) {\n+\n+                        final ByteString subscriberId = ByteString.copyFromUtf8(child);\n+                        final String childPath = path + \"/\" + child;\n+\n+                        zk.getData(childPath, false, new SafeAsyncZKCallback.DataCallback() {\n+                            @Override\n+                            public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+\n+                                if (rc != Code.OK.intValue()) {\n+                                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                            \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                                            + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                                    reportFailure(new PubSubException.ServiceDownException(e));\n+                                    return;\n+                                }\n+\n+                                if (failed.get()) {\n+                                    return;\n+                                }\n+\n+                                SubscriptionState state;\n+\n+                                try {\n+                                    state = SubscriptionState.parseFrom(data);\n+                                } catch (InvalidProtocolBufferException ex) {\n+                                    String msg = \"Failed to deserialize state for topic: \" + topic.toStringUtf8()\n+                                                 + \" subscriberId: \" + subscriberId.toStringUtf8();\n+                                    logger.error(msg, ex);\n+                                    reportFailure(new PubSubException.UnexpectedConditionException(msg));\n+                                    return;\n+                                }\n+\n+                                if (logger.isDebugEnabled()) {\n+                                    logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n+                                                 + \" subscriberId: \" + child + \"state: \"\n+                                                 + SubscriptionStateUtils.toString(state));\n+                                }\n+\n+                                topicSubs.put(subscriberId, new InMemorySubscriptionState(state));\n+                                if (count.incrementAndGet() == children.size()) {\n+                                    assert topicSubs.size() == count.get();\n+                                    cb.operationFinished(ctx, topicSubs);\n+                                }\n+                            }\n+\n+                            private void reportFailure(PubSubException e) {\n+                                if (failed.compareAndSet(false, true))\n+                                    cb.operationFailed(ctx, e);\n+                            }\n+                        }, ctx);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+}"},{"sha":"b0e8e07f577876898de71ff064cf7019d4f7e02a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":27,"deletions":5,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -63,6 +63,7 @@\n import org.apache.hedwig.server.handlers.SubscribeHandler;\n import org.apache.hedwig.server.handlers.UnsubscribeHandler;\n import org.apache.hedwig.server.jmx.HedwigMBeanRegistry;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.persistence.BookkeeperPersistenceManager;\n import org.apache.hedwig.server.persistence.LocalDBPersistenceManager;\n import org.apache.hedwig.server.persistence.PersistenceManager;\n@@ -73,7 +74,7 @@\n import org.apache.hedwig.server.ssl.SslServerContextFactory;\n import org.apache.hedwig.server.subscriptions.InMemorySubscriptionManager;\n import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n-import org.apache.hedwig.server.subscriptions.ZkSubscriptionManager;\n+import org.apache.hedwig.server.subscriptions.MMSubscriptionManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.server.topics.ZkTopicManager;\n@@ -98,6 +99,9 @@\n     SubscriptionManager sm;\n     RegionManager rm;\n \n+    // Metadata Manager Factory\n+    MetadataManagerFactory mm;\n+\n     ZooKeeper zk; // null if we are in standalone mode\n     BookKeeper bk; // null if we are in standalone mode\n \n@@ -127,7 +131,7 @@ protected PersistenceManager instantiatePersistenceManager(TopicManager topicMgr\n                 logger.error(\"Could not instantiate bookkeeper client\", e);\n                 throw new IOException(e);\n             }\n-            underlyingPM = new BookkeeperPersistenceManager(bk, zk, topicMgr, conf, scheduler);\n+            underlyingPM = new BookkeeperPersistenceManager(bk, mm, topicMgr, conf, scheduler);\n \n         }\n \n@@ -144,7 +148,7 @@ protected SubscriptionManager instantiateSubscriptionManager(TopicManager tm, Pe\n         if (conf.isStandalone()) {\n             return new InMemorySubscriptionManager(tm, pm, conf, scheduler);\n         } else {\n-            return new ZkSubscriptionManager(zk, tm, pm, conf, scheduler);\n+            return new MMSubscriptionManager(mm, tm, pm, conf, scheduler);\n         }\n \n     }\n@@ -175,6 +179,13 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n+    protected void instantiateMetadataManagerFactory() throws Exception {\n+        if (conf.isStandalone()) {\n+            return;\n+        }\n+        mm = MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+    }\n+\n     protected TopicManager instantiateTopicManager() throws IOException {\n         TopicManager tm;\n \n@@ -233,10 +244,20 @@ public void shutdown() {\n         // Stop the DeliveryManager and ReadAheadCache threads (if\n         // applicable).\n         dm.stop();\n+        pm.stop();\n \n         // Stop the SubscriptionManager if needed.\n         sm.stop();\n \n+        // Shutdown metadata manager if needed\n+        if (null != mm) {\n+            try {\n+                mm.shutdown();\n+            } catch (IOException ie) {\n+                logger.error(\"Error while shutdown metadata manager factory!\", ie);\n+            }\n+        }\n+\n         // Shutdown the ZooKeeper and BookKeeper clients only if we are\n         // not in stand-alone mode.\n         try {\n@@ -245,9 +266,9 @@ public void shutdown() {\n             if (zk != null)\n                 zk.close();\n         } catch (InterruptedException e) {\n-            logger.error(\"Error while closing ZooKeeper client!\");\n+            logger.error(\"Error while closing ZooKeeper client : \", e);\n         } catch (BKException bke) {\n-            logger.error(\"Error while closing BookKeeper client\");\n+            logger.error(\"Error while closing BookKeeper client : \", bke);\n         }\n \n         // Close and release the Netty channels and resources\n@@ -350,6 +371,7 @@ public void run() {\n                             .newCachedThreadPool());\n \n                     instantiateZookeeperClient();\n+                    instantiateMetadataManagerFactory();\n                     tm = instantiateTopicManager();\n                     pm = instantiatePersistenceManager(tm);\n                     dm = new FIFODeliveryManager(pm, conf);"},{"sha":"6c9850fc7c4dd1aa9950f35ed9e5ba2309007ebd","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":68,"deletions":115,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -33,14 +33,10 @@\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZooDefs;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.KeeperException.Code;\n-import org.apache.zookeeper.data.Stat;\n \n import com.google.protobuf.ByteString;\n import com.google.protobuf.InvalidProtocolBufferException;\n@@ -54,13 +50,13 @@\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.common.TopicOpQueuer;\n import org.apache.hedwig.server.common.UnexpectedError;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.TopicPersistenceManager;\n import org.apache.hedwig.server.persistence.ScanCallback.ReasonForFinish;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TopicOwnershipChangeListener;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.zookeeper.SafeAsynBKCallback;\n-import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n-import org.apache.hedwig.zookeeper.ZkUtils;\n \n /**\n  * This persistence manager uses zookeeper and bookkeeper to store messages.\n@@ -78,7 +74,7 @@\n     static Logger logger = LoggerFactory.getLogger(BookkeeperPersistenceManager.class);\n     static byte[] passwd = \"sillysecret\".getBytes();\n     private BookKeeper bk;\n-    private ZooKeeper zk;\n+    private TopicPersistenceManager tpManager;\n     private ServerConfiguration cfg;\n     private TopicManager tm;\n \n@@ -122,7 +118,7 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n          * include the current ledger\n          */\n         TreeMap<Long, InMemoryLedgerRange> ledgerRanges = new TreeMap<Long, InMemoryLedgerRange>();\n-        int ledgerRangesZnodeVersion = -1;\n+        Version ledgerRangesVersion = null;\n \n         /**\n          * This is the handle of the current ledger that is being used to write\n@@ -148,17 +144,20 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n      *\n      * @param bk\n      *            a reference to bookkeeper to use.\n-     * @param zk\n-     *            a zookeeper handle to use.\n-     * @param zkPrefix\n-     *            the zookeeper subtree that stores the topic to ledger\n-     *            information. if this prefix does not exist, it will be\n-     *            created.\n+     * @param metaManagerFactory\n+     *            a metadata manager factory handle to use.\n+     * @param tm\n+     *            a reference to topic manager.\n+     * @param cfg\n+     *            Server configuration object\n+     * @param executor\n+     *            A executor\n      */\n-    public BookkeeperPersistenceManager(BookKeeper bk, ZooKeeper zk, TopicManager tm, ServerConfiguration cfg,\n+    public BookkeeperPersistenceManager(BookKeeper bk, MetadataManagerFactory metaManagerFactory,\n+                                        TopicManager tm, ServerConfiguration cfg,\n                                         ScheduledExecutorService executor) {\n         this.bk = bk;\n-        this.zk = zk;\n+        this.tpManager = metaManagerFactory.newTopicPersistenceManager();\n         this.cfg = cfg;\n         this.tm = tm;\n         queuer = new TopicOpQueuer(executor);\n@@ -357,20 +356,20 @@ public void run() {\n \n             if (needsUpdate) {\n                 final LedgerRanges newRanges = builder.build();\n-                updateLedgerRangesNode(topic, newRanges, topicInfo.ledgerRangesZnodeVersion,\n-                                       new Callback<Integer>() {\n-                                           public void operationFinished(Object ctx, Integer newVersion) {\n-                                               // Finally, all done\n-                                               for (Long k : keysToRemove) {\n-                                                   topicInfo.ledgerRanges.remove(k);\n-                                               }\n-                                               topicInfo.ledgerRangesZnodeVersion = newVersion;\n-                                               cb.operationFinished(ctx, null);\n-                                           }\n-                                           public void operationFailed(Object ctx, PubSubException exception) {\n-                                               cb.operationFailed(ctx, exception);\n-                                           }\n-                                       }, ctx);\n+                tpManager.writeTopicPersistenceInfo(\n+                topic, newRanges, topicInfo.ledgerRangesVersion, new Callback<Version>() {\n+                    public void operationFinished(Object ctx, Version newVersion) {\n+                        // Finally, all done\n+                        for (Long k : keysToRemove) {\n+                            topicInfo.ledgerRanges.remove(k);\n+                        }\n+                        topicInfo.ledgerRangesVersion = newVersion;\n+                        cb.operationFinished(ctx, null);\n+                    }\n+                    public void operationFailed(Object ctx, PubSubException exception) {\n+                        cb.operationFailed(ctx, exception);\n+                    }\n+                }, ctx);\n             } else {\n                 cb.operationFinished(ctx, null);\n             }\n@@ -558,10 +557,6 @@ public void safeCloseComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n         };\n     };\n \n-    String ledgersPath(ByteString topic) {\n-        return cfg.getZkTopicPath(new StringBuilder(), topic).append(\"/ledgers\").toString();\n-    }\n-\n     class AcquireOp extends TopicOpQueuer.AsynchronousOp<Void> {\n         public AcquireOp(ByteString topic, Callback<Void> cb, Object ctx) {\n             queuer.super(topic, cb, ctx);\n@@ -574,60 +569,25 @@ public void run() {\n                 cb.operationFinished(ctx, null);\n                 return;\n             }\n-            // read topic ledgers node data\n-            final String zNodePath = ledgersPath(topic);\n \n-            zk.getData(zNodePath, false, new SafeAsyncZKCallback.DataCallback() {\n+            // read persistence info\n+            tpManager.readTopicPersistenceInfo(topic, new Callback<Versioned<LedgerRanges>>() {\n                 @Override\n-                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n-                    if (rc == Code.OK.intValue()) {\n-                        processTopicLedgersNodeData(data, stat.getVersion());\n-                        return;\n-                    }\n-\n-                    if (rc == Code.NONODE.intValue()) {\n-                        // create it\n-                        final byte[] initialData = LedgerRanges.getDefaultInstance().toByteArray();\n-                        ZkUtils.createFullPathOptimistic(zk, zNodePath, initialData, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n-                        CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n-                            @Override\n-                            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                                if (rc != Code.OK.intValue()) {\n-                                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                                             \"Could not create ledgers node for topic: \" + topic.toStringUtf8(),\n-                                                             path, rc);\n-                                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                                    return;\n-                                }\n-                                // initial version is version 1\n-                                // (guessing)\n-                                processTopicLedgersNodeData(initialData, 0);\n-                            }\n-                        }, ctx);\n-                        return;\n+                public void operationFinished(Object ctx, Versioned<LedgerRanges> ranges) {\n+                    if (null != ranges) {\n+                        processTopicLedgerRanges(ranges.getValue(), ranges.getVersion());\n+                    } else {\n+                        processTopicLedgerRanges(LedgerRanges.getDefaultInstance(), null);\n                     }\n-\n-                    // otherwise some other error\n-                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\"Could not read ledgers node for topic: \"\n-                                         + topic.toStringUtf8(), path, rc);\n-                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-\n+                }\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    cb.operationFailed(ctx, exception);\n                 }\n             }, ctx);\n         }\n \n-        void processTopicLedgersNodeData(byte[] data, int version) {\n-\n-            final LedgerRanges ranges;\n-            try {\n-                ranges = LedgerRanges.parseFrom(data);\n-            } catch (InvalidProtocolBufferException e) {\n-                String msg = \"Ledger ranges for topic:\" + topic.toStringUtf8() + \" could not be deserialized\";\n-                logger.error(msg, e);\n-                cb.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n-                return;\n-            }\n-\n+        void processTopicLedgerRanges(final LedgerRanges ranges, final Version version) {\n             Iterator<LedgerRange> lrIterator = ranges.getRangesList().iterator();\n             TopicInfo topicInfo = new TopicInfo();\n \n@@ -670,7 +630,7 @@ void processTopicLedgersNodeData(byte[] data, int version) {\n          * @param ledgerId\n          *            Ledger to be recovered\n          */\n-        private void recoverLastTopicLedgerAndOpenNewOne(final long ledgerId, final int expectedVersionOfLedgerNode,\n+        private void recoverLastTopicLedgerAndOpenNewOne(final long ledgerId, final Version expectedVersionOfLedgerNode,\n                 final TopicInfo topicInfo) {\n \n             bk.asyncOpenLedger(ledgerId, DigestType.CRC32, passwd, new SafeAsynBKCallback.OpenCallback() {\n@@ -748,7 +708,7 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n          *            The version of the ledgers node when we read it, should be\n          *            the same when we try to write\n          */\n-        private void openNewTopicLedger(final int expectedVersionOfLedgersNode, final TopicInfo topicInfo) {\n+        private void openNewTopicLedger(final Version expectedVersionOfLedgersNode, final TopicInfo topicInfo) {\n             bk.asyncCreateLedger(cfg.getBkEnsembleSize(), cfg.getBkQuorumSize(), DigestType.CRC32, passwd,\n             new SafeAsynBKCallback.CreateCallback() {\n                 boolean processed = false;\n@@ -786,42 +746,26 @@ public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n                     }\n                     builder.addRanges(lastRange);\n \n-                    updateLedgerRangesNode(topic, builder.build(), expectedVersionOfLedgersNode,\n-                                           new Callback<Integer>() {\n-                                               public void operationFinished(Object ctx, Integer newVersion) {\n-                                                   // Finally, all done\n-                                                   topicInfo.ledgerRangesZnodeVersion = newVersion;\n-                                                   topicInfos.put(topic, topicInfo);\n-                                                   cb.operationFinished(ctx, null);\n-                                               }\n-                                               public void operationFailed(Object ctx, PubSubException exception) {\n-                                                   cb.operationFailed(ctx, exception);\n-                                               }\n-                                           }, ctx);\n+                    tpManager.writeTopicPersistenceInfo(\n+                    topic, builder.build(), expectedVersionOfLedgersNode, new Callback<Version>() {\n+                        @Override\n+                        public void operationFinished(Object ctx, Version newVersion) {\n+                            // Finally, all done\n+                            topicInfo.ledgerRangesVersion = newVersion;\n+                            topicInfos.put(topic, topicInfo);\n+                            cb.operationFinished(ctx, null);\n+                        }\n+                        @Override\n+                        public void operationFailed(Object ctx, PubSubException exception) {\n+                            cb.operationFailed(ctx, exception);\n+                        }\n+                    }, ctx);\n                     return;\n                 }\n             }, ctx);\n         }\n     }\n \n-    public void updateLedgerRangesNode(final ByteString topic, LedgerRanges ranges,\n-                                       int version, final Callback<Integer> callback, Object ctx) {\n-        final String zNodePath = ledgersPath(topic);\n-\n-        zk.setData(zNodePath, ranges.toByteArray(), version, new SafeAsyncZKCallback.StatCallback() {\n-                @Override\n-                public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n-                    if (rc != KeeperException.Code.OK.intValue()) {\n-                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n-                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                        return;\n-                    }\n-                    callback.operationFinished(ctx, stat.getVersion());\n-                }\n-            }, ctx);\n-    }\n-\n     /**\n      * acquire ownership of a topic, doing whatever is needed to be able to\n      * perform reads and writes on that topic from here on\n@@ -905,4 +849,13 @@ public void setMessageBound(ByteString topic, Integer bound) {\n     public void clearMessageBound(ByteString topic) {\n         queuer.pushAndMaybeRun(topic, new SetMessageBoundOp(topic, TopicInfo.UNLIMITED));\n     }\n+\n+    @Override\n+    public void stop() {\n+        try {\n+            tpManager.close();\n+        } catch (IOException ioe) {\n+            logger.warn(\"Exception closing topic persistence manager : \", ioe);\n+        }\n+    }\n }"},{"sha":"95c4e740f816b2188e0c22eed7e1b6115fadb183","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -128,6 +128,11 @@ private LocalDBPersistenceManager() {\n         }\n     }\n \n+    @Override\n+    public void stop() {\n+        // do nothing\n+    }\n+\n     /**\n      * Ensures that at least the default seq-id exists in the map for the given\n      * topic. Checks for race conditions (.e.g, another thread inserts the"},{"sha":"a295fc755d0a8d0af4d64776257d4a9925bc26ec","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -91,4 +91,9 @@\n     public void setMessageBound(ByteString topic, Integer bound);\n     public void clearMessageBound(ByteString topic);\n     public void consumeToBound(ByteString topic);\n+\n+    /**\n+     * Stop persistence manager.\n+     */\n+    public void stop();\n }"},{"sha":"f5459c96d6a1d4bce4f19ab27536d90a5c66f6c0","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.subscriptions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.SubscriptionDataManager;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * MetaManager-based subscription manager.\n+ */\n+public class MMSubscriptionManager extends AbstractSubscriptionManager {\n+\n+    SubscriptionDataManager subManager;\n+\n+    public MMSubscriptionManager(MetadataManagerFactory metaManagerFactory,\n+                                 TopicManager topicMgr, PersistenceManager pm,\n+                                 ServerConfiguration cfg,\n+                                 ScheduledExecutorService scheduler) {\n+        super(cfg, topicMgr, pm, scheduler);\n+        this.subManager = metaManagerFactory.newSubscriptionDataManager();\n+    }\n+\n+    @Override\n+    protected void readSubscriptions(final ByteString topic,\n+                                     final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n+        subManager.readSubscriptions(topic, cb, ctx);\n+    }\n+\n+    @Override\n+    protected void createSubscriptionState(final ByteString topic, final ByteString subscriberId,\n+                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n+        subManager.createSubscriptionState(topic, subscriberId, state, callback, ctx);\n+    }\n+\n+    @Override\n+    protected void updateSubscriptionState(final ByteString topic, final ByteString subscriberId,\n+                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n+        subManager.updateSubscriptionState(topic, subscriberId, state, callback, ctx);\n+    }\n+\n+    @Override\n+    protected void deleteSubscriptionState(final ByteString topic, final ByteString subscriberId,\n+                                           final Callback<Void> callback, final Object ctx) {\n+        subManager.deleteSubscriptionState(topic, subscriberId, callback, ctx);\n+    }\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        try {\n+            subManager.close();\n+        } catch (IOException ioe) {\n+            logger.warn(\"Exception closing subscription data manager : \", ioe);\n+        }\n+    }\n+}"},{"sha":"4d39335f7d727ea21f3d0e924287a1bb451c82e6","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","status":"removed","additions":0,"deletions":227,"changes":227,"blob_url":"https://github.com/apache/bookkeeper/blob/fbcc0b583fd698cfa9ca232f4be5b0d584bb3ee5/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fbcc0b583fd698cfa9ca232f4be5b0d584bb3ee5/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/ZkSubscriptionManager.java?ref=fbcc0b583fd698cfa9ca232f4be5b0d584bb3ee5","patch":"@@ -1,227 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.server.subscriptions;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.KeeperException.Code;\n-import org.apache.zookeeper.ZooDefs.Ids;\n-import org.apache.zookeeper.data.Stat;\n-import com.google.protobuf.ByteString;\n-import com.google.protobuf.InvalidProtocolBufferException;\n-import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n-import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n-import org.apache.hedwig.server.common.ServerConfiguration;\n-import org.apache.hedwig.server.persistence.PersistenceManager;\n-import org.apache.hedwig.server.topics.TopicManager;\n-import org.apache.hedwig.util.Callback;\n-import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n-import org.apache.hedwig.zookeeper.ZkUtils;\n-\n-public class ZkSubscriptionManager extends AbstractSubscriptionManager {\n-\n-    ZooKeeper zk;\n-\n-    protected final static Logger logger = LoggerFactory.getLogger(ZkSubscriptionManager.class);\n-\n-    public ZkSubscriptionManager(ZooKeeper zk, TopicManager topicMgr, PersistenceManager pm, ServerConfiguration cfg,\n-                                 ScheduledExecutorService scheduler) {\n-        super(cfg, topicMgr, pm, scheduler);\n-        this.zk = zk;\n-    }\n-\n-    private StringBuilder topicSubscribersPath(StringBuilder sb, ByteString topic) {\n-        return cfg.getZkTopicPath(sb, topic).append(\"/subscribers\");\n-    }\n-\n-    private String topicSubscriberPath(ByteString topic, ByteString subscriber) {\n-        return topicSubscribersPath(new StringBuilder(), topic).append(\"/\").append(subscriber.toStringUtf8())\n-               .toString();\n-    }\n-\n-    @Override\n-    protected void readSubscriptions(final ByteString topic,\n-                                     final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n-\n-        String topicSubscribersPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n-        zk.getChildren(topicSubscribersPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n-            @Override\n-            public void safeProcessResult(int rc, String path, final Object ctx, final List<String> children) {\n-\n-                if (rc != Code.OK.intValue() && rc != Code.NONODE.intValue()) {\n-                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read subscribers for topic \"\n-                                        + topic.toStringUtf8(), path, rc);\n-                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n-                    return;\n-                }\n-\n-                final Map<ByteString, InMemorySubscriptionState> topicSubs = new ConcurrentHashMap<ByteString, InMemorySubscriptionState>();\n-\n-                if (rc == Code.NONODE.intValue() || children.size() == 0) {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"No subscriptions found while acquiring topic: \" + topic.toStringUtf8());\n-                    }\n-                    cb.operationFinished(ctx, topicSubs);\n-                    return;\n-                }\n-\n-                final AtomicBoolean failed = new AtomicBoolean();\n-                final AtomicInteger count = new AtomicInteger();\n-\n-                for (final String child : children) {\n-\n-                    final ByteString subscriberId = ByteString.copyFromUtf8(child);\n-                    final String childPath = path + \"/\" + child;\n-\n-                    zk.getData(childPath, false, new SafeAsyncZKCallback.DataCallback() {\n-                        @Override\n-                        public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n-\n-                            if (rc != Code.OK.intValue()) {\n-                                KeeperException e = ZkUtils.logErrorAndCreateZKException(\n-                                                        \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n-                                                        + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n-                                reportFailure(new PubSubException.ServiceDownException(e));\n-                                return;\n-                            }\n-\n-                            if (failed.get()) {\n-                                return;\n-                            }\n-\n-                            SubscriptionState state;\n-\n-                            try {\n-                                state = SubscriptionState.parseFrom(data);\n-                            } catch (InvalidProtocolBufferException ex) {\n-                                String msg = \"Failed to deserialize state for topic: \" + topic.toStringUtf8()\n-                                             + \" subscriberId: \" + subscriberId.toStringUtf8();\n-                                logger.error(msg, ex);\n-                                reportFailure(new PubSubException.UnexpectedConditionException(msg));\n-                                return;\n-                            }\n-\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n-                                             + \" subscriberId: \" + child + \"state: \"\n-                                             + SubscriptionStateUtils.toString(state));\n-                            }\n-\n-                            topicSubs.put(subscriberId, new InMemorySubscriptionState(state));\n-                            if (count.incrementAndGet() == children.size()) {\n-                                assert topicSubs.size() == count.get();\n-                                cb.operationFinished(ctx, topicSubs);\n-                            }\n-                        }\n-\n-                        private void reportFailure(PubSubException e) {\n-                            if (failed.compareAndSet(false, true))\n-                                cb.operationFailed(ctx, e);\n-                        }\n-                    }, ctx);\n-                }\n-            }\n-        }, ctx);\n-    }\n-\n-    @Override\n-    protected void createSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n-        ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), state.toByteArray(),\n-        Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n-\n-            @Override\n-            public void safeProcessResult(int rc, String path, Object ctx, String name) {\n-                if (rc == Code.OK.intValue()) {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Successfully recorded subscription for topic: \" + topic.toStringUtf8()\n-                                     + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n-                                     + SubscriptionStateUtils.toString(state));\n-                    }\n-                    callback.operationFinished(ctx, null);\n-                } else {\n-                    KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                             \"Could not record new subscription for topic: \" + topic.toStringUtf8()\n-                                             + \" subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n-                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n-                }\n-            }\n-        }, ctx);\n-    }\n-\n-    @Override\n-    protected void updateSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                           final SubscriptionState state, final Callback<Void> callback, final Object ctx) {\n-        zk.setData(topicSubscriberPath(topic, subscriberId), state.toByteArray(), -1,\n-        new SafeAsyncZKCallback.StatCallback() {\n-            @Override\n-            public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n-                if (rc != Code.OK.intValue()) {\n-                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n-                                        + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                                        + \" could not set subscription state: \" + SubscriptionStateUtils.toString(state),\n-                                        path, rc);\n-                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n-                } else {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Successfully updated subscription for topic: \" + topic.toStringUtf8()\n-                                     + \" subscriberId: \" + subscriberId.toStringUtf8() + \" state: \"\n-                                     + SubscriptionStateUtils.toString(state));\n-                    }\n-\n-                    callback.operationFinished(ctx, null);\n-                }\n-            }\n-        }, ctx);\n-    }\n-\n-    @Override\n-    protected void deleteSubscriptionState(final ByteString topic, final ByteString subscriberId,\n-                                           final Callback<Void> callback, final Object ctx) {\n-        zk.delete(topicSubscriberPath(topic, subscriberId), -1, new SafeAsyncZKCallback.VoidCallback() {\n-            @Override\n-            public void safeProcessResult(int rc, String path, Object ctx) {\n-                if (rc == Code.OK.intValue()) {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Successfully deleted subscription for topic: \" + topic.toStringUtf8()\n-                                     + \" subscriberId: \" + subscriberId.toStringUtf8());\n-                    }\n-\n-                    callback.operationFinished(ctx, null);\n-                    return;\n-                }\n-\n-                KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n-                                    + \" subscriberId: \" + subscriberId.toStringUtf8() + \" failed to delete subscription\", path, rc);\n-                callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n-            }\n-        }, ctx);\n-    }\n-\n-}"},{"sha":"04ba379e40ceddc29d4df7de8484e73a1834fa63","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","status":"modified","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -17,6 +17,7 @@\n  */\n package org.apache.hedwig.zookeeper;\n \n+import java.io.IOException;\n import java.util.List;\n \n import org.slf4j.Logger;\n@@ -34,6 +35,43 @@\n \n     static Logger logger = LoggerFactory.getLogger(ZkUtils.class);\n \n+    static class SyncObject {\n+        int rc;\n+        String path;\n+        boolean called = false;\n+    }\n+\n+    public static void createFullPathOptimistic(final ZooKeeper zk, final String originalPath, final byte[] data,\n+            final List<ACL> acl, final CreateMode createMode)\n+    throws KeeperException, IOException, InterruptedException {\n+        final SyncObject syncObj = new SyncObject();\n+\n+        createFullPathOptimistic(\n+            zk, originalPath, data, acl, createMode,\n+            new SafeAsyncZKCallback.StringCallback() {\n+                @Override\n+                public void safeProcessResult(final int rc, String path, Object ctx, String name) {\n+                    synchronized (syncObj) {\n+                        syncObj.rc = rc;\n+                        syncObj.path = path;\n+                        syncObj.called = true;\n+                        syncObj.notify();\n+                    }\n+                }\n+            }, syncObj\n+        );\n+\n+        synchronized (syncObj) {\n+            while (!syncObj.called) {\n+                syncObj.wait();\n+            }\n+        }\n+\n+        if (Code.OK.intValue() != syncObj.rc) {\n+            throw KeeperException.create(syncObj.rc, syncObj.path);\n+        }\n+    }\n+\n     public static void createFullPathOptimistic(final ZooKeeper zk, final String originalPath, final byte[] data,\n             final List<ACL> acl, final CreateMode createMode, final AsyncCallback.StringCallback callback,\n             final Object ctx) {"},{"sha":"e33b315c3d7f39f0b3281f30c3631d8cdd759b2f","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,75 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.ZkMetadataManagerFactory;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.zookeeper.ZooKeeperTestBase;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(Parameterized.class)\n+public abstract class MetadataManagerFactoryTestCase extends ZooKeeperTestBase {\n+    static Logger LOG = LoggerFactory.getLogger(MetadataManagerFactoryTestCase.class);\n+\n+    protected MetadataManagerFactory metadataManagerFactory;\n+    protected ServerConfiguration conf;\n+\n+    public MetadataManagerFactoryTestCase(String metadataManagerFactoryCls) {\n+        super();\n+        conf = new ServerConfiguration();\n+        conf.setMetadataManagerFactoryName(metadataManagerFactoryCls);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] {\n+            { ZkMetadataManagerFactory.class.getName() }\n+        });\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        metadataManagerFactory = MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        metadataManagerFactory.shutdown();\n+        super.tearDown();\n+    }\n+\n+}"},{"sha":"5b59e56a949deff0381f922bef85bfceaf0295ca","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,84 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.zookeeper.ZooKeeperTestBase;\n+import org.apache.hedwig.zookeeper.ZkUtils;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class TestFactoryLayout extends ZooKeeperTestBase {\n+\n+    @Test\n+    public void testFactoryLayout() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration();\n+        conf.setMetadataManagerFactoryName(\n+            \"org.apache.hedwig.server.meta.ZkMetadataManager\");\n+\n+        FactoryLayout layout = FactoryLayout.readLayout(zk, conf);\n+        Assert.assertTrue(\"Layout should be null\", layout == null);\n+\n+        String testName = \"foobar\";\n+        int testVersion = 0xdeadbeef;\n+        // use layout defined in configuration also create it in zookeeper\n+        writeFactoryLayout(conf, testName, testVersion);\n+\n+        layout = FactoryLayout.readLayout(zk, conf);\n+        Assert.assertEquals(testName, layout.getManagerMeta().getManagerImpl());\n+        Assert.assertEquals(testVersion, layout.getManagerMeta().getManagerVersion());\n+    }\n+\n+    private void writeFactoryLayout(ServerConfiguration conf, String managerCls,\n+                                    int managerVersion)\n+        throws Exception {\n+        ManagerMeta managerMeta = ManagerMeta.newBuilder()\n+                                             .setManagerImpl(managerCls)\n+                                             .setManagerVersion(managerVersion)\n+                                             .build();\n+        FactoryLayout layout = new FactoryLayout(managerMeta);\n+        layout.store(zk, conf);\n+    }\n+\n+    @Test\n+    public void testCorruptedFactoryLayout() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration();\n+        StringBuilder msb = new StringBuilder();\n+        String factoryLayoutPath = FactoryLayout.getFactoryLayoutPath(msb, conf);\n+        // write corrupted manager layout\n+        ZkUtils.createFullPathOptimistic(zk, factoryLayoutPath, \"BadLayout\".getBytes(),\n+                                         Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+\n+        try {\n+            FactoryLayout.readLayout(zk, conf);\n+            Assert.fail(\"Shouldn't reach here!\");\n+        } catch (IOException ie) {\n+        }\n+    }\n+}"},{"sha":"6ab704ff016c7f850a9ac3f3a727b53c49ff4422","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","status":"added","additions":237,"deletions":0,"changes":237,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,237 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.util.Map;\n+import java.util.concurrent.SynchronousQueue;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.StubCallback;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.util.Either;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class TestMetadataManager extends MetadataManagerFactoryTestCase {\n+\n+    public TestMetadataManager(String metadataManagerFactoryCls) {\n+        super(metadataManagerFactoryCls);\n+    }\n+\n+    @Test\n+    public void testPersistenceInfo() throws Exception {\n+        TopicPersistenceManager tpManager = metadataManagerFactory.newTopicPersistenceManager();\n+\n+        ByteString topic = ByteString.copyFromUtf8(\"testPersistenceInfo\");\n+        StubCallback<Versioned<LedgerRanges>> readCallback = new StubCallback<Versioned<LedgerRanges>>();\n+        StubCallback<Version> writeCallback = new StubCallback<Version>();\n+        StubCallback<Void> deleteCallback = new StubCallback<Void>();\n+\n+        // Write non-existed persistence info\n+        tpManager.writeTopicPersistenceInfo(topic, LedgerRanges.getDefaultInstance(), null,\n+                                            writeCallback, null);\n+        Either<Version, PubSubException> res = writeCallback.queue.take();\n+        Assert.assertEquals(null, res.right());\n+        Version v1 = res.left();\n+\n+        // read persistence info\n+        tpManager.readTopicPersistenceInfo(topic, readCallback, null);\n+        Versioned<LedgerRanges> ranges = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v1.compare(ranges.getVersion()));\n+        Assert.assertEquals(LedgerRanges.getDefaultInstance(), ranges.getValue());\n+\n+        LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(1).build();\n+        LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n+        builder.addRanges(lastRange);\n+        LedgerRanges newRanges = builder.build();\n+\n+        // write existed persistence info with null version\n+        tpManager.writeTopicPersistenceInfo(topic, newRanges, null, writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertNotNull(res.right());\n+        Assert.assertTrue(res.right() instanceof PubSubException.TopicPersistenceInfoExistsException);\n+\n+        // write existed persistence info with right version\n+        tpManager.writeTopicPersistenceInfo(topic, newRanges, v1,\n+                                            writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertEquals(null, res.right());\n+        Version v2 = res.left();\n+        Assert.assertEquals(Version.Occurred.AFTER, v2.compare(v1));\n+\n+        // read persistence info\n+        tpManager.readTopicPersistenceInfo(topic, readCallback, null);\n+        ranges = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(ranges.getVersion()));\n+        Assert.assertEquals(newRanges, ranges.getValue());\n+\n+        lastRange = LedgerRange.newBuilder().setLedgerId(2).build();\n+        builder = LedgerRanges.newBuilder();\n+        builder.addRanges(lastRange);\n+        LedgerRanges newRanges2 = builder.build();\n+\n+        // write existed persistence info with bad version\n+        tpManager.writeTopicPersistenceInfo(topic, newRanges2, v1,\n+                                            writeCallback, null);\n+        res = writeCallback.queue.take();\n+        Assert.assertNotNull(res.right());\n+        Assert.assertTrue(res.right() instanceof PubSubException.BadVersionException);\n+\n+        // read persistence info\n+        tpManager.readTopicPersistenceInfo(topic, readCallback, null);\n+        ranges = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(ranges.getVersion()));\n+        Assert.assertEquals(newRanges, ranges.getValue());\n+\n+        // delete with bad version\n+        tpManager.deleteTopicPersistenceInfo(topic, v1, deleteCallback, null);\n+        Assert.assertTrue(deleteCallback.queue.take().right() instanceof\n+                          PubSubException.BadVersionException);\n+\n+        // read persistence info\n+        tpManager.readTopicPersistenceInfo(topic, readCallback, null);\n+        ranges = readCallback.queue.take().left();\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(ranges.getVersion()));\n+        Assert.assertEquals(newRanges, ranges.getValue());\n+\n+        // delete existed persistence info with right version\n+        tpManager.deleteTopicPersistenceInfo(topic, v2, deleteCallback, null);\n+        Assert.assertEquals(null, deleteCallback.queue.take().right());\n+\n+        // read empty persistence info\n+        tpManager.readTopicPersistenceInfo(topic, readCallback, null);\n+        Assert.assertEquals(null, readCallback.queue.take().left());\n+\n+        // delete non-existed persistence info\n+        tpManager.deleteTopicPersistenceInfo(topic, null, deleteCallback, null);\n+        Assert.assertTrue(deleteCallback.queue.take().right() instanceof\n+                          PubSubException.NoTopicPersistenceInfoException);\n+\n+        tpManager.close();\n+    }\n+\n+    @Test\n+    public void testSubscriptionState() throws Exception {\n+        SubscriptionDataManager subManager = metadataManagerFactory.newSubscriptionDataManager();\n+\n+        ByteString topic = ByteString.copyFromUtf8(\"testSubscriptionState\");\n+        ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n+\n+        StubCallback<Void> callback = new StubCallback<Void>();\n+        StubCallback<SubscriptionState> readCallback = new StubCallback<SubscriptionState>();\n+        StubCallback<Map<ByteString, InMemorySubscriptionState>> subsCallback\n+            = new StubCallback<Map<ByteString, InMemorySubscriptionState>>();\n+\n+        subManager.readSubscriptionState(topic, subid, readCallback, null);\n+        Either<SubscriptionState, PubSubException> readRes = readCallback.queue.take();\n+        Assert.assertEquals(\"Found inconsistent subscription state\", null, readRes.left());\n+        Assert.assertEquals(\"Should not fail with PubSubException\", null, readRes.right());\n+\n+        // read non-existed subscription state\n+        subManager.readSubscriptions(topic, subsCallback, null);\n+        Either<Map<ByteString, InMemorySubscriptionState>, PubSubException> res = subsCallback.queue.take();\n+        Assert.assertEquals(\"Found more than 0 subscribers\", 0, res.left().size());\n+        Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n+\n+        // update non-existed subscription state\n+        subManager.updateSubscriptionState(topic, subid, SubscriptionState.getDefaultInstance(),\n+                                            callback, null);\n+        Assert.assertTrue(\"Should fail to update a non-existed subscriber with PubSubException\",\n+                          callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);\n+\n+        // delete non-existed subscription state\n+        subManager.deleteSubscriptionState(topic, subid, callback, null);\n+        Assert.assertTrue(\"Should fail to delete a non-existed subscriber with PubSubException\",\n+                          callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);\n+\n+        long seqId = 10;\n+        MessageSeqId.Builder builder = MessageSeqId.newBuilder();\n+        builder.setLocalComponent(seqId);\n+        MessageSeqId msgId = builder.build();\n+\n+        SubscriptionState state = SubscriptionState.newBuilder(SubscriptionState.getDefaultInstance()).setMsgId(msgId).build();\n+\n+        // create a subscription state\n+        subManager.createSubscriptionState(topic, subid, state, callback, null);\n+        Assert.assertEquals(\"Should not fail with PubSubException\",\n+                            null, callback.queue.take().right());\n+\n+        // read subscriptions\n+        subManager.readSubscriptions(topic, subsCallback, null);\n+        res = subsCallback.queue.take();\n+        Assert.assertEquals(\"Should find just 1 subscriber\", 1, res.left().size());\n+        Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n+        InMemorySubscriptionState imss = res.left().get(subid);\n+        Assert.assertEquals(\"Found inconsistent subscription state\",\n+                            state, imss.getSubscriptionState());\n+        Assert.assertEquals(\"Found inconsistent last consumed seq id\",\n+                            seqId, imss.getLastConsumeSeqId().getLocalComponent());\n+\n+        // move consume seq id\n+        seqId = 99;\n+        builder = MessageSeqId.newBuilder();\n+        builder.setLocalComponent(seqId);\n+        msgId = builder.build();\n+\n+        state = SubscriptionState.newBuilder(state).setMsgId(msgId).build();\n+\n+        // update subscription state\n+        subManager.updateSubscriptionState(topic, subid, state, callback, null);\n+        Assert.assertEquals(\"Fail to update a subscription state\", null, callback.queue.take().right());\n+\n+        // read subscription state\n+        subManager.readSubscriptionState(topic, subid, readCallback, null);\n+        Assert.assertEquals(\"Found inconsistent subscription state\",\n+                            state, readCallback.queue.take().left());\n+\n+        // read subscriptions again\n+        subManager.readSubscriptions(topic, subsCallback, null);\n+        res = subsCallback.queue.take();\n+        Assert.assertEquals(\"Should find just 1 subscriber\", 1, res.left().size());\n+        Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n+        imss = res.left().get(subid);\n+        Assert.assertEquals(\"Found inconsistent subscription state\",\n+                            state, imss.getSubscriptionState());\n+        Assert.assertEquals(\"Found inconsistent last consumed seq id\",\n+                            seqId, imss.getLastConsumeSeqId().getLocalComponent());\n+\n+        subManager.deleteSubscriptionState(topic, subid, callback, null);\n+        Assert.assertEquals(\"Fail to delete an existed subscriber\", null, callback.queue.take().right());\n+\n+        // read subscription states again\n+        subManager.readSubscriptions(topic, subsCallback, null);\n+        res = subsCallback.queue.take();\n+        Assert.assertEquals(\"Found more than 0 subscribers\", 0, res.left().size());\n+        Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n+\n+        subManager.close();\n+    }\n+}"},{"sha":"412e8484bc66edb043d4286052beb5a2aa4ae012","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","status":"added","additions":291,"deletions":0,"changes":291,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -0,0 +1,291 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import java.io.IOException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.zookeeper.ZooKeeperTestBase;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestMetadataManagerFactory extends ZooKeeperTestBase {\n+    static Logger LOG = LoggerFactory.getLogger(TestMetadataManagerFactory.class);\n+\n+    static class TestServerConfiguration extends ServerConfiguration {\n+        String hedwigPrefix = \"/hedwig\";\n+\n+        @Override\n+        public String getZkPrefix() {\n+            return hedwigPrefix;\n+        }\n+\n+        public void setZkPrefix(String prefix) {\n+            this.hedwigPrefix = prefix;\n+        }\n+    }\n+\n+    static class DummyMetadataManagerFactory extends MetadataManagerFactory {\n+        static int VERSION = 10;\n+\n+        public int getCurrentVersion() { return VERSION; }\n+\n+\n+        public MetadataManagerFactory initialize(ServerConfiguration cfg,\n+                                                 ZooKeeper zk,\n+                                                 int version)\n+        throws IOException {\n+            if (version != VERSION) {\n+                throw new IOException(\"unmatched manager version\");\n+            }\n+            // do nothing\n+            return this;\n+        }\n+\n+        public void shutdown() {}\n+\n+        public TopicPersistenceManager newTopicPersistenceManager() {\n+            return null;\n+        }\n+\n+        public SubscriptionDataManager newSubscriptionDataManager() {\n+            return null;\n+        }\n+    }\n+\n+    private void writeFactoryLayout(ServerConfiguration conf,\n+                                    String factoryCls,\n+                                    int factoryVersion)\n+        throws Exception {\n+        ManagerMeta meta = ManagerMeta.newBuilder()\n+                                      .setManagerImpl(factoryCls)\n+                                      .setManagerVersion(factoryVersion).build();\n+        new FactoryLayout(meta).store(zk, conf);\n+    }\n+\n+    /**\n+     * Test bad server configuration\n+     */\n+    @Test\n+    public void testBadConf() throws Exception {\n+        TestServerConfiguration conf = new TestServerConfiguration();\n+\n+        String root0 = \"/goodconf\";\n+        conf.setZkPrefix(root0);\n+\n+        MetadataManagerFactory m =\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+        Assert.assertTrue(\"MetadataManagerFactory is unexpected type\",\n+                          (m instanceof ZkMetadataManagerFactory));\n+\n+        // mismatching conf\n+        conf.setMetadataManagerFactoryName(DummyMetadataManagerFactory.class.getName());\n+        try {\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+            Assert.fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            Assert.assertTrue(\"Invalid exception\",\n+                              e.getMessage().contains(\"does not match existing factory\"));\n+        }\n+\n+        // invalid metadata manager\n+        String root1 = \"/badconf1\";\n+        conf.setZkPrefix(root1);\n+        conf.setMetadataManagerFactoryName(\"DoesNotExist\");\n+        try {\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+            Assert.fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            Assert.assertTrue(\"Invalid exception\",\n+                              e.getMessage().contains(\"Failed to get metadata manager factory class from configuration\"));\n+        }\n+    }\n+\n+    /**\n+     * Test bad zk configuration\n+     */\n+    @Test\n+    public void testBadZkContents() throws Exception {\n+        TestServerConfiguration conf = new TestServerConfiguration();\n+\n+        // bad type in zookeeper\n+        String root0 = \"/badzk0\";\n+        conf.setZkPrefix(root0);\n+\n+        writeFactoryLayout(conf, \"DoesNotExist\", 0xdeadbeef);\n+        try {\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+            Assert.fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            Assert.assertTrue(\"Invalid exception\",\n+                              e.getMessage().contains(\"No class found to instantiate metadata manager factory\"));\n+        }\n+\n+        // bad version in zookeeper\n+        String root1 = \"/badzk1\";\n+        conf.setZkPrefix(root1);\n+\n+        writeFactoryLayout(conf, ZkMetadataManagerFactory.class.getName(), 0xdeadbeef);\n+        try {\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+            Assert.fail(\"Shouldn't reach here\");\n+        } catch (Exception e) {\n+            Assert.assertTrue(\"Invalid exception\",\n+                              e.getMessage().contains(\"Incompatible ZkMetadataManagerFactory version\"));\n+        }\n+    }\n+\n+    private class CreateMMThread extends Thread {\n+        private boolean success = false;\n+        private final String factoryCls;\n+        private final String root;\n+        private final CyclicBarrier barrier;\n+        private ZooKeeper zkc;\n+\n+        CreateMMThread(String root, String factoryCls, CyclicBarrier barrier) throws Exception {\n+            this.factoryCls = factoryCls;\n+            this.barrier = barrier;\n+            this.root = root;\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            zkc = new ZooKeeper(hostPort, 10000, new Watcher() {\n+                public void process(WatchedEvent event) {\n+                    latch.countDown();\n+                }\n+            });\n+            latch.await();\n+        }\n+\n+        public void run() {\n+            TestServerConfiguration conf = new TestServerConfiguration();\n+            conf.setZkPrefix(root);\n+            conf.setMetadataManagerFactoryName(factoryCls);\n+\n+            try {\n+                barrier.await();\n+                MetadataManagerFactory.newMetadataManagerFactory(conf, zkc);\n+                success = true;\n+            } catch (Exception e) {\n+                LOG.error(\"Failed to create metadata manager factory\", e);\n+            }\n+        }\n+\n+        public boolean isSuccessful() {\n+            return success;\n+        }\n+\n+        public void close() throws Exception {\n+            zkc.close();\n+        }\n+    }\n+\n+    // test concurrent\n+    @Test\n+    public void testConcurrent1() throws Exception {\n+        /// everyone creates the same\n+        int numThreads = 50;\n+\n+        // bad version in zookeeper\n+        String root0 = \"/lmroot0\";\n+\n+        CyclicBarrier barrier = new CyclicBarrier(numThreads+1);\n+        List<CreateMMThread> threads = new ArrayList<CreateMMThread>(numThreads);\n+        for (int i = 0; i < numThreads; i++) {\n+            CreateMMThread t = new CreateMMThread(root0, ZkMetadataManagerFactory.class.getName(), barrier);\n+            t.start();\n+            threads.add(t);\n+        }\n+\n+        barrier.await();\n+\n+        boolean success = true;\n+        for (CreateMMThread t : threads) {\n+            t.join();\n+            t.close();\n+            success = t.isSuccessful() && success;\n+        }\n+        Assert.assertTrue(\"Not all metadata manager factories created\", success);\n+    }\n+\n+    @Test\n+    public void testConcurrent2() throws Exception {\n+        /// odd create different\n+        int numThreadsEach = 25;\n+\n+        // bad version in zookeeper\n+        String root0 = \"/lmroot0\";\n+\n+        CyclicBarrier barrier = new CyclicBarrier(numThreadsEach*2+1);\n+        List<CreateMMThread> threadsA = new ArrayList<CreateMMThread>(numThreadsEach);\n+        for (int i = 0; i < numThreadsEach; i++) {\n+            CreateMMThread t = new CreateMMThread(root0, ZkMetadataManagerFactory.class.getName(), barrier);\n+            t.start();\n+            threadsA.add(t);\n+        }\n+        List<CreateMMThread> threadsB = new ArrayList<CreateMMThread>(numThreadsEach);\n+        for (int i = 0; i < numThreadsEach; i++) {\n+            CreateMMThread t = new CreateMMThread(root0, DummyMetadataManagerFactory.class.getName(), barrier);\n+            t.start();\n+            threadsB.add(t);\n+        }\n+\n+        barrier.await();\n+\n+        int numSuccess = 0;\n+        int numFails = 0;\n+        for (CreateMMThread t : threadsA) {\n+            t.join();\n+            t.close();\n+            if (t.isSuccessful()) {\n+                numSuccess++;\n+            } else {\n+                numFails++;\n+            }\n+        }\n+\n+        for (CreateMMThread t : threadsB) {\n+            t.join();\n+            t.close();\n+            if (t.isSuccessful()) {\n+                numSuccess++;\n+            } else {\n+                numFails++;\n+            }\n+        }\n+        Assert.assertEquals(\"Incorrect number of successes\", numThreadsEach, numSuccess);\n+        Assert.assertEquals(\"Incorrect number of failures\", numThreadsEach, numFails);\n+    }\n+}"},{"sha":"9d386981c549465e3606246ef9757d4e4603a0ba","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -121,4 +121,9 @@ public void scanMessages(RangeScanRequest request) {\n         request.getCallback().scanFinished(request.getCtx(), ReasonForFinish.NUM_MESSAGES_LIMIT_EXCEEDED);\n \n     }\n+\n+    @Override\n+    public void stop() {\n+        // do nothing\n+    }\n }"},{"sha":"f187cd62cedfbd24c15e68e5fad765b0dd216ff3","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","status":"modified","additions":9,"deletions":1,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -32,6 +32,7 @@\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.util.Callback;\n@@ -56,6 +57,7 @@\n     TopicManager tm;\n     BookkeeperPersistenceManager manager;\n     PubSubException failureException = null;\n+    MetadataManagerFactory metadataManagerFactory;\n \n     @Override\n     @Before\n@@ -73,15 +75,21 @@ protected void setUp() throws Exception {\n         .setThrottleValue(3);\n         conf.addConf(bkClientConf);\n \n+        metadataManagerFactory =\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, bktb.getZooKeeperClient());\n+\n         scheduler = Executors.newScheduledThreadPool(1);\n         tm = new TrivialOwnAllTopicManager(conf, scheduler);\n-        manager = new BookkeeperPersistenceManager(bktb.bk, bktb.getZooKeeperClient(), tm, conf, scheduler);\n+        manager = new BookkeeperPersistenceManager(bktb.bk, metadataManagerFactory,\n+                                                   tm, conf, scheduler);\n     }\n \n     @Override\n     @After\n     protected void tearDown() throws Exception {\n         tm.stop();\n+        manager.stop();\n+        metadataManagerFactory.shutdown();\n         scheduler.shutdown();\n         bktb.tearDown();\n         super.tearDown();"},{"sha":"9303e4cf3b8bb70ccd0ce9b82c58ecd7d805ea99","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","status":"modified","additions":12,"deletions":2,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -27,12 +27,15 @@\n import org.junit.Before;\n \n import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n \n public class TestBookKeeperPersistenceManagerBlackBox extends TestPersistenceManagerBlackBox {\n     BookKeeperTestBase bktb;\n     private final int numBookies = 3;\n \n+    MetadataManagerFactory metadataManagerFactory = null;\n+\n     @Override\n     @Before\n     protected void setUp() throws Exception {\n@@ -48,6 +51,9 @@ protected void setUp() throws Exception {\n     protected void tearDown() throws Exception {\n         bktb.tearDown();\n         super.tearDown();\n+        if (null != metadataManagerFactory) {\n+            metadataManagerFactory.shutdown();\n+        }\n     }\n \n     @Override\n@@ -60,8 +66,12 @@ PersistenceManager instantiatePersistenceManager() throws Exception {\n         ServerConfiguration conf = new ServerConfiguration();\n         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n \n-        return new BookkeeperPersistenceManager(bktb.bk, bktb.getZooKeeperClient(), new TrivialOwnAllTopicManager(conf,\n-                                                scheduler), conf, scheduler);\n+        metadataManagerFactory =\n+            MetadataManagerFactory.newMetadataManagerFactory(conf, bktb.getZooKeeperClient());\n+\n+        return new BookkeeperPersistenceManager(bktb.bk, metadataManagerFactory,\n+                                                new TrivialOwnAllTopicManager(conf, scheduler),\n+                                                conf, scheduler);\n     }\n \n     @Override"},{"sha":"8f2767ee25c5ce466a00a6ece89bf2e975040e89","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -35,6 +35,7 @@\n import org.apache.hedwig.StubCallback;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.util.ConcurrencyUtils;\n@@ -44,6 +45,7 @@\n     BookKeeperTestBase bktb;\n     private final int numBookies = 3;\n     BookkeeperPersistenceManager bkpm;\n+    MetadataManagerFactory mm;\n     ServerConfiguration conf;\n     ScheduledExecutorService scheduler;\n     TopicManager tm;\n@@ -60,12 +62,15 @@ protected void setUp() throws Exception {\n         scheduler = Executors.newScheduledThreadPool(1);\n         tm = new TrivialOwnAllTopicManager(conf, scheduler);\n \n-        bkpm = new BookkeeperPersistenceManager(bktb.bk, bktb.getZooKeeperClient(), tm, conf, scheduler);\n+        mm = MetadataManagerFactory.newMetadataManagerFactory(conf, bktb.getZooKeeperClient());\n+\n+        bkpm = new BookkeeperPersistenceManager(bktb.bk, mm, tm, conf, scheduler);\n     }\n \n     @Override\n     @After\n     protected void tearDown() throws Exception {\n+        mm.shutdown();\n         bktb.tearDown();\n         super.tearDown();\n     }\n@@ -78,7 +83,7 @@ public void testEmptyDirtyLedger() throws Exception {\n         assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n         // now abandon, and try another time, the prev ledger should be dirty\n \n-        bkpm = new BookkeeperPersistenceManager(new BookKeeper(bktb.getZkHostPort()), bktb.getZooKeeperClient(), tm,\n+        bkpm = new BookkeeperPersistenceManager(new BookKeeper(bktb.getZkHostPort()), mm, tm,\n                                                 conf, scheduler);\n         bkpm.acquiredTopic(topic, stubCallback, null);\n         assertNull(ConcurrencyUtils.take(stubCallback.queue).right());"},{"sha":"f5ac30d38814ce1e1318283ca1a489d72bf03652","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -229,6 +229,7 @@ protected void setUp() throws Exception {\n     @Override\n     protected void tearDown() throws Exception {\n         logger.info(\"tearDown starting\");\n+        persistenceManager.stop();\n         super.tearDown();\n         logger.info(\"FINISHED \" + getName());\n     }"},{"sha":"b0e4bfa7915acf0d672e2df37a6225e72f497889","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","status":"renamed","additions":9,"deletions":4,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java?ref=c2efd0a48c5d1ea4edd7bf33c69a7e5270942eb4","patch":"@@ -23,35 +23,40 @@\n \n import org.junit.Assert;\n import org.junit.Test;\n+import org.junit.Before;\n \n import com.google.protobuf.ByteString;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.server.common.ServerConfiguration;\n-import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.server.persistence.LocalDBPersistenceManager;\n+import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.util.ConcurrencyUtils;\n import org.apache.hedwig.util.Either;\n import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.zookeeper.ZooKeeperTestBase;\n \n-public class TestZkSubscriptionManager extends ZooKeeperTestBase {\n-    ZkSubscriptionManager sm;\n+public class TestMMSubscriptionManager extends ZooKeeperTestBase {\n+    MetadataManagerFactory mm;\n+    MMSubscriptionManager sm;\n     ServerConfiguration cfg = new ServerConfiguration();\n     SynchronousQueue<Either<MessageSeqId, PubSubException>> msgIdCallbackQueue = new SynchronousQueue<Either<MessageSeqId, PubSubException>>();\n     SynchronousQueue<Either<Boolean, PubSubException>> BooleanCallbackQueue = new SynchronousQueue<Either<Boolean, PubSubException>>();\n \n     Callback<Void> voidCallback;\n     Callback<MessageSeqId> msgIdCallback;\n \n+    @Before\n     @Override\n     public void setUp() throws Exception {\n         super.setUp();\n         cfg = new ServerConfiguration();\n         final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n-        sm = new ZkSubscriptionManager(zk, new TrivialOwnAllTopicManager(cfg, scheduler),\n+        mm = MetadataManagerFactory.newMetadataManagerFactory(cfg, zk);\n+        sm = new MMSubscriptionManager(mm, new TrivialOwnAllTopicManager(cfg, scheduler),\n                                        LocalDBPersistenceManager.instance(), cfg, scheduler);\n         msgIdCallback = new Callback<MessageSeqId>() {\n             @Override","previous_filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java"}]}

