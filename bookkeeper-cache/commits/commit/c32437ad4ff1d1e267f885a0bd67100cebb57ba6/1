{"sha":"c32437ad4ff1d1e267f885a0bd67100cebb57ba6","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjMzI0MzdhZDRmZjFkMWUyNjdmODg1YTBiZDY3MTAwY2ViYjU3YmE2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-07T16:27:20Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-07T16:27:20Z"},"message":"BOOKKEEPER-444: Refactor pending read op to make speculative reads possible (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1406707 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4bad86e7fe3db76379fd1598c2b8e84e1bd8a64b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4bad86e7fe3db76379fd1598c2b8e84e1bd8a64b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c32437ad4ff1d1e267f885a0bd67100cebb57ba6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c32437ad4ff1d1e267f885a0bd67100cebb57ba6","html_url":"https://github.com/apache/bookkeeper/commit/c32437ad4ff1d1e267f885a0bd67100cebb57ba6","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"da1b308ba8eb4dc0cd93b5ad19065067c354f242","url":"https://api.github.com/repos/apache/bookkeeper/commits/da1b308ba8eb4dc0cd93b5ad19065067c354f242","html_url":"https://github.com/apache/bookkeeper/commit/da1b308ba8eb4dc0cd93b5ad19065067c354f242"}],"stats":{"total":159,"additions":99,"deletions":60},"files":[{"sha":"d4931c5046c52c95bdbd9ea563963d081d9eae43","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=c32437ad4ff1d1e267f885a0bd67100cebb57ba6","patch":"@@ -178,6 +178,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-346: Detect IOExceptions in LedgerCache and bookie should look at next ledger dir(if any) (Vinay via ivank)\n \n+        BOOKKEEPER-444: Refactor pending read op to make speculative reads possible (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"283045a9871fc79f24e653cc2b07e33ef8976d34","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","raw_url":"https://github.com/apache/bookkeeper/raw/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java?ref=c32437ad4ff1d1e267f885a0bd67100cebb57ba6","patch":"@@ -42,8 +42,6 @@\n     long length;\n     ChannelBufferInputStream entryDataStream;\n \n-    int nextReplicaIndexToReadFrom = 0;\n-\n     LedgerEntry(long lId, long eId) {\n         this.ledgerId = lId;\n         this.entryId = eId;"},{"sha":"3b46bf9a261e301516effa41c495930c2fb67403","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":97,"deletions":58,"changes":155,"blob_url":"https://github.com/apache/bookkeeper/blob/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c32437ad4ff1d1e267f885a0bd67100cebb57ba6/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=c32437ad4ff1d1e267f885a0bd67100cebb57ba6","patch":"@@ -20,53 +20,127 @@\n  * under the License.\n  *\n  */\n-\n import java.net.InetSocketAddress;\n-import java.nio.ByteBuffer;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.NoSuchElementException;\n import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.buffer.ChannelBufferInputStream;\n \n-import java.io.IOException;\n-\n /**\n  * Sequence of entries of a ledger that represents a pending read operation.\n  * When all the data read has come back, the application callback is called.\n  * This class could be improved because we could start pushing data to the\n  * application as soon as it arrives rather than waiting for the whole thing.\n  *\n  */\n-\n class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     Logger LOG = LoggerFactory.getLogger(PendingReadOp.class);\n \n-    Queue<LedgerEntry> seq;\n+    Queue<LedgerEntryRequest> seq;\n     ReadCallback cb;\n     Object ctx;\n     LedgerHandle lh;\n-    long numPendingReads;\n+    long numPendingEntries;\n     long startEntryId;\n     long endEntryId;\n \n+    private class LedgerEntryRequest extends LedgerEntry {\n+        int nextReplicaIndexToReadFrom = 0;\n+        AtomicBoolean complete = new AtomicBoolean(false);\n+\n+        int firstError = BKException.Code.OK;\n+\n+        final ArrayList<InetSocketAddress> ensemble;\n+\n+        LedgerEntryRequest(ArrayList<InetSocketAddress> ensemble, long lId, long eId) {\n+            super(lId, eId);\n+\n+            this.ensemble = ensemble;\n+        }\n+\n+        void sendNextRead() {\n+            if (nextReplicaIndexToReadFrom >= lh.metadata.getWriteQuorumSize()) {\n+                // we are done, the read has failed from all replicas, just fail the\n+                // read\n+                submitCallback(firstError);\n+                return;\n+            }\n+\n+            int bookieIndex = lh.distributionSchedule.getWriteSet(entryId).get(nextReplicaIndexToReadFrom);\n+            nextReplicaIndexToReadFrom++;\n+\n+            try {\n+                sendReadTo(ensemble.get(bookieIndex), this);\n+            } catch (InterruptedException ie) {\n+                LOG.error(\"Interrupted reading entry \" + this, ie);\n+                Thread.currentThread().interrupt();\n+                submitCallback(BKException.Code.ReadException);\n+            }\n+        }\n+\n+        void logErrorAndReattemptRead(String errMsg, int rc) {\n+            if (firstError == BKException.Code.OK) {\n+                firstError = rc;\n+            }\n+\n+            int bookieIndex = lh.distributionSchedule.getWriteSet(entryId).get(nextReplicaIndexToReadFrom - 1);\n+            LOG.error(errMsg + \" while reading entry: \" + entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n+                      + ensemble.get(bookieIndex));\n+\n+            sendNextRead();\n+        }\n+\n+        // return true if we managed to complete the entry\n+        boolean complete(final ChannelBuffer buffer) {\n+            ChannelBufferInputStream is;\n+            try {\n+                is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n+            } catch (BKDigestMatchException e) {\n+                logErrorAndReattemptRead(\"Mac mismatch\", BKException.Code.DigestMatchException);\n+                return false;\n+            }\n+\n+            if (!complete.getAndSet(true)) {\n+                entryDataStream = is;\n+\n+                /*\n+                 * The length is a long and it is the last field of the metadata of an entry.\n+                 * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n+                 */\n+                length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean isComplete() {\n+            return complete.get();\n+        }\n+\n+        public String toString() {\n+            return String.format(\"L%d-E%d\", ledgerId, entryId);\n+        }\n+    }\n+\n     PendingReadOp(LedgerHandle lh, long startEntryId, long endEntryId, ReadCallback cb, Object ctx) {\n \n-        seq = new ArrayDeque<LedgerEntry>((int) (endEntryId - startEntryId));\n+        seq = new ArrayDeque<LedgerEntryRequest>((int) (endEntryId - startEntryId));\n         this.cb = cb;\n         this.ctx = ctx;\n         this.lh = lh;\n         this.startEntryId = startEntryId;\n         this.endEntryId = endEntryId;\n-        numPendingReads = endEntryId - startEntryId + 1;\n+        numPendingEntries = endEntryId - startEntryId + 1;\n     }\n \n     public void initiate() throws InterruptedException {\n@@ -76,47 +150,30 @@ public void initiate() throws InterruptedException {\n         do {\n             LOG.debug(\"Acquiring lock: {}\", i);\n \n-            lh.opCounterSem.acquire();\n-\n             if (i == nextEnsembleChange) {\n                 ensemble = lh.metadata.getEnsemble(i);\n                 nextEnsembleChange = lh.metadata.getNextEnsembleChange(i);\n             }\n-            LedgerEntry entry = new LedgerEntry(lh.ledgerId, i);\n+            LedgerEntryRequest entry = new LedgerEntryRequest(ensemble, lh.ledgerId, i);\n             seq.add(entry);\n             i++;\n-            sendRead(ensemble, entry, BKException.Code.ReadException);\n \n+            entry.sendNextRead();\n         } while (i <= endEntryId);\n     }\n \n-    void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int lastErrorCode) {\n-        if (entry.nextReplicaIndexToReadFrom >= lh.metadata.getWriteQuorumSize()) {\n-            // we are done, the read has failed from all replicas, just fail the\n-            // read\n-            lh.opCounterSem.release();\n-            submitCallback(lastErrorCode);\n-            return;\n-        }\n+    void sendReadTo(InetSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n+        lh.opCounterSem.acquire();\n \n-        int bookieIndex = lh.distributionSchedule.getWriteSet(entry.entryId).get(entry.nextReplicaIndexToReadFrom);\n-        entry.nextReplicaIndexToReadFrom++;\n-        lh.bk.bookieClient.readEntry(ensemble.get(bookieIndex), lh.ledgerId, entry.entryId, \n+        lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId, \n                                      this, entry);\n     }\n \n-    void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n-        ArrayList<InetSocketAddress> ensemble = lh.metadata.getEnsemble(entry.entryId);\n-        int bookeIndex = lh.distributionSchedule.getWriteSet(entry.entryId).get(entry.nextReplicaIndexToReadFrom - 1);\n-        LOG.error(errMsg + \" while reading entry: \" + entry.entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n-                  + ensemble.get(bookeIndex));\n-        sendRead(ensemble, entry, rc);\n-        return;\n-    }\n-\n     @Override\n     public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n-        final LedgerEntry entry = (LedgerEntry) ctx;\n+        final LedgerEntryRequest entry = (LedgerEntryRequest) ctx;\n+\n+        lh.opCounterSem.release();\n \n         // if we just read only one entry, and this entry is not existed (in recoveryRead case)\n         // we don't need to do ReattemptRead, otherwise we could not handle following case:\n@@ -127,43 +184,25 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n         if (startEntryId == endEntryId) {\n             if (BKException.Code.NoSuchLedgerExistsException == rc ||\n                 BKException.Code.NoSuchEntryException == rc) {\n-                lh.opCounterSem.release();\n                 submitCallback(rc);\n                 return;\n             }\n         }\n \n         if (rc != BKException.Code.OK) {\n-            logErrorAndReattemptRead(entry, \"Error: \" + BKException.getMessage(rc), rc);\n+            entry.logErrorAndReattemptRead(\"Error: \" + BKException.getMessage(rc), rc);\n             return;\n         }\n \n-        ChannelBufferInputStream is;\n-        try {\n-            is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n-        } catch (BKDigestMatchException e) {\n-            logErrorAndReattemptRead(entry, \"Mac mismatch\", BKException.Code.DigestMatchException);\n-            return;\n+        if (entry.complete(buffer)) {\n+            numPendingEntries--;\n         }\n \n-        entry.entryDataStream = is;\n-\n-        /*\n-         * The length is a long and it is the last field of the metadata of an entry.\n-         * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n-         */\n-        entry.length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n-\n-        numPendingReads--;\n-        if (numPendingReads == 0) {\n+        if (numPendingEntries == 0) {\n             submitCallback(BKException.Code.OK);\n         }\n \n-        LOG.debug(\"Releasing lock: {}\", entryId);\n-\n-        lh.opCounterSem.release();\n-\n-        if(numPendingReads < 0)\n+        if(numPendingEntries < 0)\n             LOG.error(\"Read too many values\");\n     }\n "}]}

