{"sha":"c81076e4d9521bc67653a917e9fb9edbe27bf073","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjODEwNzZlNGQ5NTIxYmM2NzY1M2E5MTdlOWZiOWVkYmUyN2JmMDcz","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-07-24T22:34:19Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2014-07-24T22:34:19Z"},"message":"BOOKKEEPER-582: Make bookie and client use protobuf for requests (non-wire part)\n(sijie via fpj)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1613315 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d83d0e5168bb347efae558c4af8eb106a74d083b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d83d0e5168bb347efae558c4af8eb106a74d083b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c81076e4d9521bc67653a917e9fb9edbe27bf073","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c81076e4d9521bc67653a917e9fb9edbe27bf073","html_url":"https://github.com/apache/bookkeeper/commit/c81076e4d9521bc67653a917e9fb9edbe27bf073","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c81076e4d9521bc67653a917e9fb9edbe27bf073/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"8f09334e24deaa8e80674a702c498d802986f3c8","url":"https://api.github.com/repos/apache/bookkeeper/commits/8f09334e24deaa8e80674a702c498d802986f3c8","html_url":"https://github.com/apache/bookkeeper/commit/8f09334e24deaa8e80674a702c498d802986f3c8"}],"stats":{"total":7052,"additions":6437,"deletions":615},"files":[{"sha":"20a04ca2c91c57c76ca969a8eae0910b754e9993","filename":"CHANGES.txt","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -303,6 +303,9 @@ Trunk (unreleased changes)\n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)\n \n       BOOKKEEPER-257: Ability to list all ledgers (fpj via ivank)\n+  \n+      BOOKKEEPER-582: Make bookie and client use protobuf for requests (non-wire part)\n+      (sijie via fpj)\n \n Release 4.2.0 - 2013-01-14\n "},{"sha":"56a3fc889d36b5017576b65282ee893d1a6b3cc2","filename":"bookkeeper-server/pom.xml","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/pom.xml?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -161,6 +161,18 @@\n         </exclusion>\n       </exclusions>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>bookkeeper-server-compat420</artifactId>\n+      <version>4.2.0</version>\n+      <scope>test</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>bookkeeper-server</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n   </dependencies>\n   <build>\n     <plugins>\n@@ -249,6 +261,7 @@\n           <excludes>\n             <!-- exclude generated file //-->\n             <exclude>**/DataFormats.java</exclude>\n+            <exclude>**/BookkeeperProtocol.java</exclude>\n           </excludes>\n         </configuration>\n       </plugin>"},{"sha":"3f2580fd2d16de8cd716dad0e5fae608ebd888ac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -127,7 +127,8 @@ private void verifyLedgerFragment(LedgerFragment fragment,\n \n         public void readEntryComplete(int rc, long ledgerId, long entryId,\n                                       ChannelBuffer buffer, Object ctx) {\n-            if (rc != BKException.Code.NoSuchEntryException) {\n+            if (BKException.Code.NoSuchEntryException != rc &&\n+                BKException.Code.NoSuchLedgerExistsException != rc) {\n                 entryMayExist.set(true);\n             }\n "},{"sha":"e548f3d456a2a1d9d0ace577a870c8a99bb65912","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -186,15 +186,19 @@ synchronized BookieSocketAddress sendNextRead() {\n \n         synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n             if (BKException.Code.OK == firstError ||\n-                BKException.Code.NoSuchEntryException == firstError) {\n+                BKException.Code.NoSuchEntryException == firstError ||\n+                BKException.Code.NoSuchLedgerExistsException == firstError) {\n                 firstError = rc;\n             } else if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n-                       BKException.Code.NoSuchEntryException != rc) {\n-                // if other exception rather than NoSuchEntryException is returned\n-                // we need to update firstError to indicate that it might be a valid read but just failed.\n+                       BKException.Code.NoSuchEntryException != rc &&\n+                       BKException.Code.NoSuchLedgerExistsException != rc) {\n+                // if other exception rather than NoSuchEntryException or NoSuchLedgerExistsException is\n+                // returned we need to update firstError to indicate that it might be a valid read but just\n+                // failed.\n                 firstError = rc;\n             }\n-            if (BKException.Code.NoSuchEntryException == rc) {\n+            if (BKException.Code.NoSuchEntryException == rc ||\n+                BKException.Code.NoSuchLedgerExistsException == rc) {\n                 ++numMissedEntryReads;\n                 LOG.debug(\"No such entry found on bookie.  L{} E{} bookie: {}\",\n                         new Object[] { lh.ledgerId, entryId, host });"},{"sha":"d785d29eef71b4c5388a8cf8abdf4dfaca04a095","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -20,7 +20,6 @@\n  */\n package org.apache.bookkeeper.processor;\n \n-import org.apache.bookkeeper.proto.BookieProtocol;\n import org.jboss.netty.channel.Channel;\n \n public interface RequestProcessor {\n@@ -38,6 +37,6 @@\n      * @param channel\n      *          channel received the given request <i>r</i>\n      */\n-    public void processRequest(BookieProtocol.Request r, Channel channel);\n+    public void processRequest(Object r, Channel channel);\n \n }"},{"sha":"d69d4a812bc16e4d51256ae7bbbf0712d257cc76","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":9,"deletions":12,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -118,9 +118,11 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n                 PerChannelBookieClientPool oldClientPool = channels.putIfAbsent(addr, newClientPool);\n                 if (null == oldClientPool) {\n                     clientPool = newClientPool;\n+                    // initialize the pool only after we put the pool into the map\n+                    clientPool.intialize();\n                 } else {\n                     clientPool = oldClientPool;\n-                    newClientPool.close();\n+                    newClientPool.close(false);\n                 }\n             } finally {\n                 closeLock.readLock().unlock();\n@@ -130,10 +132,10 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n     }\n \n     public void closeClients(Set<BookieSocketAddress> addrs) {\n+        final HashSet<PerChannelBookieClientPool> clients =\n+                new HashSet<PerChannelBookieClientPool>();\n         closeLock.readLock().lock();\n         try {\n-            final HashSet<PerChannelBookieClientPool> clients =\n-                    new HashSet<PerChannelBookieClientPool>();\n             for (BookieSocketAddress a : addrs) {\n                 PerChannelBookieClientPool c = channels.get(a);\n                 if (c != null) {\n@@ -144,17 +146,12 @@ public void closeClients(Set<BookieSocketAddress> addrs) {\n             if (clients.size() == 0) {\n                 return;\n             }\n-            executor.submit(new SafeRunnable() {\n-                    @Override\n-                    public void safeRun() {\n-                        for (PerChannelBookieClientPool c : clients) {\n-                            c.disconnect();\n-                        }\n-                    }\n-                });\n         } finally {\n             closeLock.readLock().unlock();\n         }\n+        for (PerChannelBookieClientPool c : clients) {\n+            c.disconnect(false);\n+        }\n     }\n \n     public void addEntry(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n@@ -279,7 +276,7 @@ public void close() {\n         try {\n             closed = true;\n             for (PerChannelBookieClientPool pool : channels.values()) {\n-                pool.close();\n+                pool.close(true);\n             }\n             channels.clear();\n         } finally {"},{"sha":"6ece56ea329504af677d86f650abccc02c2a94bc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"modified","additions":164,"deletions":28,"changes":192,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -20,6 +20,9 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.jboss.netty.buffer.ChannelBufferFactory;\n+import org.jboss.netty.buffer.ChannelBufferInputStream;\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.channel.Channel;\n@@ -35,9 +38,38 @@\n public class BookieProtoEncoding {\n     private final static Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n \n-    public static class RequestEncoder extends OneToOneEncoder {\n+    static final EnDecoder REQ_PREV3 = new RequestEnDeCoderPreV3();\n+    static final EnDecoder REP_PREV3 = new ResponseEnDeCoderPreV3();\n+    static final EnDecoder REQ_V3 = new RequestEnDecoderV3();\n+    static final EnDecoder REP_V3 = new ResponseEnDecoderV3();\n+\n+    static interface EnDecoder {\n+\n+        /**\n+         * Encode a <i>object</i> into channel buffer.\n+         *\n+         * @param object\n+         *          object.\n+         * @return encode buffer.\n+         * @throws Exception\n+         */\n+        public Object encode(Object object, ChannelBufferFactory factory) throws Exception;\n+\n+        /**\n+         * Decode a <i>packet</i> into an object.\n+         *\n+         * @param packet\n+         *          received packet.\n+         * @return parsed object.\n+         * @throws Exception\n+         */\n+        public Object decode(ChannelBuffer packet) throws Exception;\n+\n+    }\n+\n+    static class RequestEnDeCoderPreV3 implements EnDecoder {\n         @Override\n-        public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+        public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 throws Exception {\n             if (!(msg instanceof BookieProtocol.Request)) {\n                 return msg;\n@@ -47,7 +79,7 @@ public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 BookieProtocol.AddRequest ar = (BookieProtocol.AddRequest)r;\n                 int totalHeaderSize = 4 // for the header\n                     + BookieProtocol.MASTER_KEY_LENGTH; // for the master key\n-                ChannelBuffer buf = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+                ChannelBuffer buf = bufferFactory.getBuffer(totalHeaderSize);\n                 buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n                 buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);\n                 return ChannelBuffers.wrappedBuffer(buf, ar.getData());\n@@ -60,7 +92,7 @@ public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                     totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;\n                 }\n \n-                ChannelBuffer buf = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+                ChannelBuffer buf = bufferFactory.getBuffer(totalHeaderSize);\n                 buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n                 buf.writeLong(r.getLedgerId());\n                 buf.writeLong(r.getEntryId());\n@@ -71,17 +103,10 @@ public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 return buf;\n             }\n         }\n-    }\n \n-    public static class RequestDecoder extends OneToOneDecoder {\n         @Override\n-        public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+        public Object decode(ChannelBuffer packet)\n                 throws Exception {\n-            if (!(msg instanceof ChannelBuffer)) {\n-                return msg;\n-            }\n-            ChannelBuffer packet = (ChannelBuffer)msg;\n-\n             PacketHeader h = PacketHeader.fromInt(packet.readInt());\n \n             // packet format is different between ADDENTRY and READENTRY\n@@ -117,20 +142,19 @@ public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                     return new BookieProtocol.ReadRequest(h.getVersion(), ledgerId, entryId, flags);\n                 }\n             }\n-            return msg;\n+            return packet;\n         }\n     }\n \n-    public static class ResponseEncoder extends OneToOneEncoder {\n+    static class ResponseEnDeCoderPreV3 implements EnDecoder {\n         @Override\n-        public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+        public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 throws Exception {\n             if (!(msg instanceof BookieProtocol.Response)) {\n                 return msg;\n             }\n             BookieProtocol.Response r = (BookieProtocol.Response)msg;\n-            ChannelBuffer buf = ctx.getChannel().getConfig().getBufferFactory()\n-                .getBuffer(24);\n+            ChannelBuffer buf = bufferFactory.getBuffer(24);\n             buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n                                           r.getOpCode(), (short)0).toInt());\n             buf.writeInt(r.getErrorCode());\n@@ -153,17 +177,9 @@ public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                 return msg;\n             }\n         }\n-    }\n-\n-    public static class ResponseDecoder extends OneToOneDecoder {\n         @Override\n-        public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+        public Object decode(ChannelBuffer buffer)\n                 throws Exception {\n-            if (!(msg instanceof ChannelBuffer)) {\n-                return msg;\n-            }\n-\n-            final ChannelBuffer buffer = (ChannelBuffer)msg;\n             final int rc;\n             final long ledgerId, entryId;\n             final PacketHeader header;\n@@ -185,10 +201,130 @@ public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n                                                            ledgerId, entryId);\n                 }\n             default:\n-                LOG.error(\"Unexpected response of type {} received from {}\",\n-                          header.getOpCode(), channel.getRemoteAddress());\n+                return buffer;\n+            }\n+        }\n+    }\n+\n+    static class RequestEnDecoderV3 implements EnDecoder {\n+\n+        @Override\n+        public Object decode(ChannelBuffer packet) throws Exception {\n+            return BookkeeperProtocol.Request.parseFrom(new ChannelBufferInputStream(packet));\n+        }\n+\n+        @Override\n+        public Object encode(Object msg, ChannelBufferFactory factory) throws Exception {\n+            BookkeeperProtocol.Request request = (BookkeeperProtocol.Request) msg;\n+            return ChannelBuffers.wrappedBuffer(request.toByteArray());\n+        }\n+\n+    }\n+\n+    static class ResponseEnDecoderV3 implements EnDecoder {\n+\n+        @Override\n+        public Object decode(ChannelBuffer packet) throws Exception {\n+            return BookkeeperProtocol.Response.parseFrom(new ChannelBufferInputStream(packet));\n+        }\n+\n+        @Override\n+        public Object encode(Object msg, ChannelBufferFactory factory) throws Exception {\n+            BookkeeperProtocol.Response response = (BookkeeperProtocol.Response) msg;\n+            return ChannelBuffers.wrappedBuffer(response.toByteArray());\n+        }\n+\n+    }\n+\n+    public static class RequestEncoder extends OneToOneEncoder {\n+\n+        @Override\n+        protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Encode request {} to channel {}.\", msg, channel);\n+            }\n+            if (msg instanceof BookkeeperProtocol.Request) {\n+                return REQ_V3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+            } else if (msg instanceof BookieProtocol.Request) {\n+                return REQ_PREV3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+            } else {\n+                LOG.error(\"Invalid request to encode to {}: {}\", channel, msg.getClass().getName());\n+                return msg;\n+            }\n+        }\n+    }\n+\n+    public static class RequestDecoder extends OneToOneDecoder {\n+\n+        @Override\n+        protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Received request {} from channel {} to decode.\", msg, channel);\n+            }\n+            if (!(msg instanceof ChannelBuffer)) {\n                 return msg;\n             }\n+            ChannelBuffer buffer = (ChannelBuffer) msg;\n+            try {\n+                buffer.markReaderIndex();\n+                try {\n+                    return REQ_V3.decode(buffer);\n+                } catch (InvalidProtocolBufferException e) {\n+                    buffer.resetReaderIndex();\n+                    return REQ_PREV3.decode(buffer);\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Failed to decode a request from {} : \", channel, e);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public static class ResponseEncoder extends OneToOneEncoder {\n+\n+        @Override\n+        protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Encode response {} to channel {}.\", msg, channel);\n+            }\n+            if (msg instanceof BookkeeperProtocol.Response) {\n+                return REP_V3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+            } else if (msg instanceof BookieProtocol.Response) {\n+                return REP_PREV3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+            } else {\n+                LOG.error(\"Invalid response to encode to {}: {}\", channel, msg.getClass().getName());\n+                return msg;\n+            }\n+        }\n+    }\n+\n+    public static class ResponseDecoder extends OneToOneDecoder {\n+\n+        @Override\n+        protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+                throws Exception {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Received response {} from channel {} to decode.\", msg, channel);\n+            }\n+            if (!(msg instanceof ChannelBuffer)) {\n+                return msg;\n+            }\n+            ChannelBuffer buffer = (ChannelBuffer) msg;\n+            try {\n+                buffer.markReaderIndex();\n+                try {\n+                    return REP_V3.decode(buffer);\n+                } catch (InvalidProtocolBufferException e) {\n+                    buffer.resetReaderIndex();\n+                    return REP_PREV3.decode(buffer);\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Failed to decode a response from channel {} : \", channel, e);\n+                throw e;\n+            }\n         }\n     }\n }"},{"sha":"3c5f128497eabf3eecda74e3c50d73ebabab0dc2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"modified","additions":4,"deletions":6,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -22,7 +22,6 @@\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.processor.RequestProcessor;\n-import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelHandlerContext;\n import org.jboss.netty.channel.ChannelStateEvent;\n import org.jboss.netty.channel.ExceptionEvent;\n@@ -71,21 +70,20 @@ public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n         LOG.debug(\"Channel connected {}\", e);\n     }\n \n+    @Override\n     public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n             throws Exception {\n         LOG.debug(\"Channel disconnected {}\", e);\n     }\n \n     @Override\n     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-        if (!(e.getMessage() instanceof BookieProtocol.Request)) {\n+        Object event = e.getMessage();\n+        if (!(event instanceof BookkeeperProtocol.Request || event instanceof BookieProtocol.Request)) {\n             ctx.sendUpstream(e);\n             return;\n         }\n-        BookieProtocol.Request r = (BookieProtocol.Request)e.getMessage();\n-        Channel c = ctx.getChannel();\n-        requestProcessor.processRequest(r, c);\n+        requestProcessor.processRequest(event, ctx.getChannel());\n     }\n \n-\n }"},{"sha":"b1c090f4b271812fbc3c65825def765d4803c0d1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":59,"deletions":218,"changes":277,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -21,26 +21,18 @@\n package org.apache.bookkeeper.proto;\n \n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n \n import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.processor.RequestProcessor;\n-import org.apache.bookkeeper.util.MathUtils;\n import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class BookieRequestProcessor implements RequestProcessor, BookkeeperInternalCallbacks.WriteCallback {\n+public class BookieRequestProcessor implements RequestProcessor {\n \n     private final static Logger LOG = LoggerFactory.getLogger(BookieRequestProcessor.class);\n     /**\n@@ -101,234 +93,83 @@ private void shutdownExecutor(ExecutorService service) {\n     }\n \n     @Override\n-    public void processRequest(BookieProtocol.Request r, Channel c) {\n-        if (r.getProtocolVersion() < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n-                        || r.getProtocolVersion() > BookieProtocol.CURRENT_PROTOCOL_VERSION) {\n-            LOG.error(\"Invalid protocol version, expected something between \"\n-                            + BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n-                            + \" & \" + BookieProtocol.CURRENT_PROTOCOL_VERSION\n-                            + \". got \" + r.getProtocolVersion());\n-            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, r));\n-            return;\n-        }\n-\n-        switch (r.getOpCode()) {\n-        case BookieProtocol.ADDENTRY:\n-            processAddRequest(r, c);\n-            break;\n-        case BookieProtocol.READENTRY:\n-            processReadRequest(r, c);\n-            break;\n-        default:\n-            LOG.error(\"Unknown op type {}, sending error\", r.getOpCode());\n-            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n+    public void processRequest(Object msg, Channel c) {\n+        // If we can decode this packet as a Request protobuf packet, process\n+        // it as a version 3 packet. Else, just use the old protocol.\n+        if (msg instanceof BookkeeperProtocol.Request) {\n+            BookkeeperProtocol.Request r = (BookkeeperProtocol.Request) msg;\n+            BookkeeperProtocol.BKPacketHeader header = r.getHeader();\n+            switch (header.getOperation()) {\n+                case ADD_ENTRY:\n+                    processAddRequestV3(r, c);\n+                    break;\n+                case READ_ENTRY:\n+                    processReadRequestV3(r, c);\n+                    break;\n+                default:\n+                    BookkeeperProtocol.Response.Builder response =\n+                            BookkeeperProtocol.Response.newBuilder().setHeader(r.getHeader())\n+                            .setStatus(BookkeeperProtocol.StatusCode.EBADREQ);\n+                    c.write(response.build());\n+                    if (statsEnabled) {\n+                        bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n+                    }\n+                    break;\n             }\n-            break;\n-        }\n-    }\n-\n-    class AddCtx {\n-        final Channel c;\n-        final BookieProtocol.AddRequest r;\n-        final long startTime;\n-\n-        AddCtx(Channel c, BookieProtocol.AddRequest r) {\n-            this.c = c;\n-            this.r = r;\n-\n-            if (statsEnabled) {\n-                startTime = MathUtils.now();\n-            } else {\n-                startTime = 0;\n+        } else {\n+            BookieProtocol.Request r = (BookieProtocol.Request) msg;\n+            // process packet\n+            switch (r.getOpCode()) {\n+                case BookieProtocol.ADDENTRY:\n+                    processAddRequest(r, c);\n+                    break;\n+                case BookieProtocol.READENTRY:\n+                    processReadRequest(r, c);\n+                    break;\n+                default:\n+                    LOG.error(\"Unknown op type {}, sending error\", r.getOpCode());\n+                    c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n+                    if (statsEnabled) {\n+                        bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n+                    }\n+                    break;\n             }\n         }\n     }\n \n-    private void processAddRequest(final BookieProtocol.Request r, final Channel c) {\n+    private void processAddRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        WriteEntryProcessorV3 write = new WriteEntryProcessorV3(r, c, bookie);\n         if (null == writeThreadPool) {\n-            handleAdd(r, c);\n+            write.run();\n         } else {\n-            writeThreadPool.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    handleAdd(r, c);\n-                }\n-            });\n+            writeThreadPool.submit(write);\n         }\n     }\n \n-    private void handleAdd(BookieProtocol.Request r, Channel c) {\n-        assert (r instanceof BookieProtocol.AddRequest);\n-        BookieProtocol.AddRequest add = (BookieProtocol.AddRequest) r;\n-\n-        if (bookie.isReadOnly()) {\n-            LOG.warn(\"BookieServer is running as readonly mode,\"\n-                            + \" so rejecting the request from the client!\");\n-            c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n-            }\n-            return;\n-        }\n-\n-        int rc = BookieProtocol.EOK;\n-        try {\n-            if (add.isRecoveryAdd()) {\n-                bookie.recoveryAddEntry(add.getDataAsByteBuffer(), this, new AddCtx(c, add),\n-                                add.getMasterKey());\n-            } else {\n-                bookie.addEntry(add.getDataAsByteBuffer(),\n-                                this, new AddCtx(c, add), add.getMasterKey());\n-            }\n-        } catch (IOException e) {\n-            LOG.error(\"Error writing \" + add, e);\n-            rc = BookieProtocol.EIO;\n-        } catch (BookieException.LedgerFencedException lfe) {\n-            LOG.error(\"Attempt to write to fenced ledger\", lfe);\n-            rc = BookieProtocol.EFENCED;\n-        } catch (BookieException e) {\n-            LOG.error(\"Unauthorized access to ledger \" + add.getLedgerId(), e);\n-            rc = BookieProtocol.EUA;\n-        }\n-        if (rc != BookieProtocol.EOK) {\n-            c.write(ResponseBuilder.buildErrorResponse(rc, add));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n-            }\n+    private void processReadRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        ReadEntryProcessorV3 read = new ReadEntryProcessorV3(r, c, bookie);\n+        if (null == readThreadPool) {\n+            read.run();\n+        } else {\n+            readThreadPool.submit(read);\n         }\n     }\n \n-    @Override\n-    public void writeComplete(int rc, long ledgerId, long entryId,\n-                              BookieSocketAddress addr, Object ctx) {\n-        assert (ctx instanceof AddCtx);\n-        AddCtx addctx = (AddCtx) ctx;\n-        addctx.c.write(ResponseBuilder.buildAddResponse(addctx.r));\n-\n-        if (statsEnabled) {\n-            // compute the latency\n-            if (0 == rc) {\n-                // for add operations, we compute latency in writeComplete callbacks.\n-                long elapsedTime = MathUtils.now() - addctx.startTime;\n-                bkStats.getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n-            } else {\n-                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n-            }\n+    private void processAddRequest(final BookieProtocol.Request r, final Channel c) {\n+        WriteEntryProcessor write = new WriteEntryProcessor(r, c, bookie);\n+        if (null == writeThreadPool) {\n+            write.run();\n+        } else {\n+            writeThreadPool.submit(write);\n         }\n     }\n \n     private void processReadRequest(final BookieProtocol.Request r, final Channel c) {\n+        ReadEntryProcessor read = new ReadEntryProcessor(r, c, bookie);\n         if (null == readThreadPool) {\n-            handleRead(r, c);\n-        } else {\n-            readThreadPool.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    handleRead(r, c);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void handleRead(BookieProtocol.Request r, Channel c) {\n-        assert (r instanceof BookieProtocol.ReadRequest);\n-        BookieProtocol.ReadRequest read = (BookieProtocol.ReadRequest) r;\n-\n-        LOG.debug(\"Received new read request: {}\", r);\n-        int errorCode = BookieProtocol.EIO;\n-        long startTime = 0;\n-        if (statsEnabled) {\n-            startTime = MathUtils.now();\n-        }\n-        ByteBuffer data = null;\n-        try {\n-            Future<Boolean> fenceResult = null;\n-            if (read.isFencingRequest()) {\n-                LOG.warn(\"Ledger \" + r.getLedgerId() + \" fenced by \" + c.getRemoteAddress());\n-\n-                if (read.hasMasterKey()) {\n-                    fenceResult = bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n-                } else {\n-                    LOG.error(\"Password not provided, Not safe to fence {}\", read.getLedgerId());\n-                    if (statsEnabled) {\n-                        bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n-                    }\n-                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n-                }\n-            }\n-            data = bookie.readEntry(r.getLedgerId(), r.getEntryId());\n-            LOG.debug(\"##### Read entry ##### {}\", data.remaining());\n-            if (null != fenceResult) {\n-                // TODO:\n-                // currently we don't have readCallback to run in separated read\n-                // threads. after BOOKKEEPER-429 is complete, we could improve\n-                // following code to make it not wait here\n-                //\n-                // For now, since we only try to wait after read entry. so writing\n-                // to journal and read entry are executed in different thread\n-                // it would be fine.\n-                try {\n-                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n-                    if (null == fenced || !fenced) {\n-                        // if failed to fence, fail the read request to make it retry.\n-                        errorCode = BookieProtocol.EIO;\n-                        data = null;\n-                    } else {\n-                        errorCode = BookieProtocol.EOK;\n-                    }\n-                } catch (InterruptedException ie) {\n-                    LOG.error(\"Interrupting fence read entry \" + read, ie);\n-                    errorCode = BookieProtocol.EIO;\n-                    data = null;\n-                } catch (ExecutionException ee) {\n-                    LOG.error(\"Failed to fence read entry \" + read, ee);\n-                    errorCode = BookieProtocol.EIO;\n-                    data = null;\n-                } catch (TimeoutException te) {\n-                    LOG.error(\"Timeout to fence read entry \" + read, te);\n-                    errorCode = BookieProtocol.EIO;\n-                    data = null;\n-                }\n-            } else {\n-                errorCode = BookieProtocol.EOK;\n-            }\n-        } catch (Bookie.NoLedgerException e) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.error(\"Error reading \" + read, e);\n-            }\n-            errorCode = BookieProtocol.ENOLEDGER;\n-        } catch (Bookie.NoEntryException e) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.error(\"Error reading \" + read, e);\n-            }\n-            errorCode = BookieProtocol.ENOENTRY;\n-        } catch (IOException e) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.error(\"Error reading \" + read, e);\n-            }\n-            errorCode = BookieProtocol.EIO;\n-        } catch (BookieException e) {\n-            LOG.error(\"Unauthorized access to ledger \" + read.getLedgerId(), e);\n-            errorCode = BookieProtocol.EUA;\n-        }\n-\n-        LOG.trace(\"Read entry rc = {} for {}\",\n-                        new Object[] { errorCode, read });\n-        if (errorCode == BookieProtocol.EOK) {\n-            assert data != null;\n-\n-            c.write(ResponseBuilder.buildReadResponse(data, read));\n-            if (statsEnabled) {\n-                long elapsedTime = MathUtils.now() - startTime;\n-                bkStats.getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n-            }\n+            read.run();\n         } else {\n-            c.write(ResponseBuilder.buildErrorResponse(errorCode, read));\n-            if (statsEnabled) {\n-                bkStats.getOpStats(BKStats.STATS_READ).incrementFailedOps();\n-            }\n+            readThreadPool.submit(read);\n         }\n     }\n "},{"sha":"57d350328e11dffd224382828ab26abcaafaa8b6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","status":"added","additions":4774,"deletions":0,"changes":4774,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073"},{"sha":"920515ba098f078bb067034db267d98101b5301c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","status":"modified","additions":11,"deletions":6,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -52,8 +52,6 @@\n         this.clients = new PerChannelBookieClient[coreSize];\n         for (int i = 0; i < coreSize; i++) {\n             this.clients[i] = factory.create(address);\n-            // connect proactively\n-            this.clients[i].connectIfNeededAndDoOp(this);\n         }\n     }\n \n@@ -62,6 +60,13 @@ public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n         // nop\n     }\n \n+    @Override\n+    public void intialize() {\n+        for (PerChannelBookieClient pcbc : this.clients) {\n+            pcbc.connectIfNeededAndDoOp(this);\n+        }\n+    }\n+\n     @Override\n     public void obtain(GenericCallback<PerChannelBookieClient> callback) {\n         if (1 == clients.length) {\n@@ -73,16 +78,16 @@ public void obtain(GenericCallback<PerChannelBookieClient> callback) {\n     }\n \n     @Override\n-    public void disconnect() {\n+    public void disconnect(boolean wait) {\n         for (PerChannelBookieClient pcbc : clients) {\n-            pcbc.disconnect();\n+            pcbc.disconnect(wait);\n         }\n     }\n \n     @Override\n-    public void close() {\n+    public void close(boolean wait) {\n         for (PerChannelBookieClient pcbc : clients) {\n-            pcbc.close();\n+            pcbc.close(wait);\n         }\n     }\n }"},{"sha":"4469399c0d167c9759d9365dcb4f7ef9ce51b1b4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,61 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.proto.BookieProtocol.Request;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+abstract class PacketProcessorBase implements Runnable {\n+    private final static Logger logger = LoggerFactory.getLogger(PacketProcessorBase.class);\n+    final Request request;\n+    final Channel channel;\n+    final Bookie bookie;\n+\n+    PacketProcessorBase(Request request, Channel channel, Bookie bookie) {\n+        this.request = request;\n+        this.channel = channel;\n+        this.bookie = bookie;\n+    }\n+\n+    protected boolean isVersionCompatible() {\n+        byte version = request.getProtocolVersion();\n+        if (version < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n+                || version > BookieProtocol.CURRENT_PROTOCOL_VERSION) {\n+            logger.error(\"Invalid protocol version, expected something between \"\n+                    + BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n+                    + \" & \" + BookieProtocol.CURRENT_PROTOCOL_VERSION\n+                    + \". got \" + request.getProtocolVersion());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (!isVersionCompatible()) {\n+            channel.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADVERSION, request));\n+            return;\n+        }\n+        processPacket();\n+    }\n+\n+    protected abstract void processPacket();\n+}"},{"sha":"6189235f7534dfa099daf7be0fbfc9d48dddace4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,58 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.jboss.netty.channel.Channel;\n+\n+public abstract class PacketProcessorBaseV3 {\n+\n+    final Request request;\n+    final Channel channel;\n+    final Bookie  bookie;\n+\n+    public PacketProcessorBaseV3(Request request, Channel channel, Bookie bookie) {\n+        this.request = request;\n+        this.channel = channel;\n+        this.bookie = bookie;\n+    }\n+\n+    protected boolean isVersionCompatible() {\n+        return this.request.getHeader().getVersion().equals(ProtocolVersion.VERSION_THREE);\n+    }\n+\n+    /**\n+     * Build a header with protocol version 3 and the operation type same as what was in the\n+     * request.\n+     * @return\n+     */\n+    protected BKPacketHeader getHeader() {\n+        BKPacketHeader.Builder header = BKPacketHeader.newBuilder();\n+        header.setVersion(ProtocolVersion.VERSION_THREE);\n+        header.setOperation(request.getHeader().getOperation());\n+        header.setTxnId(request.getHeader().getTxnId());\n+        return header.build();\n+    }\n+\n+}"},{"sha":"deef9f48f66819280cf496feabaeb08b1564faa7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":291,"deletions":197,"changes":488,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -23,12 +23,24 @@\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import com.google.protobuf.ByteString;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -40,6 +52,7 @@\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.jboss.netty.bootstrap.ClientBootstrap;\n import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelFuture;\n import org.jboss.netty.channel.ChannelFutureListener;\n@@ -73,6 +86,7 @@\n     static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);\n \n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n+    public static final AtomicLong txnIdGenerator = new AtomicLong(0);\n \n     final BookieSocketAddress addr;\n     final ClientSocketChannelFactory channelFactory;\n@@ -81,8 +95,7 @@\n     final int addEntryTimeout;\n     final int readEntryTimeout;\n \n-    ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n-    ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n+    private final ConcurrentHashMap<CompletionKey, CompletionValue> completionObjects = new ConcurrentHashMap<CompletionKey, CompletionValue>();\n \n     private final StatsLogger statsLogger;\n     private final OpStatsLogger readEntryOpLogger;\n@@ -150,7 +163,7 @@ private void completeOperation(GenericCallback<PerChannelBookieClient> op, int r\n     }\n \n     private void connect() {\n-        LOG.info(\"Connecting to bookie: {}\", addr);\n+        LOG.debug(\"Connecting to bookie: {}\", addr);\n \n         // Set up the ClientBootStrap so we can create a new Channel connection\n         // to the bookie.\n@@ -277,19 +290,41 @@ void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n-        BookieProtocol.AddRequest r = new BookieProtocol.AddRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                ledgerId, entryId, (short)options, masterKey, toSend);\n+        final long txnId = getTxnId();\n         final int entrySize = toSend.readableBytes();\n-        final CompletionKey completionKey = new CompletionKey(ledgerId, entryId, BookieProtocol.ADDENTRY);\n-        addCompletions.put(completionKey,\n-                new AddCompletion(addEntryOpLogger, cb, ctx, scheduleTimeout(completionKey, addEntryTimeout)));\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.ADD_ENTRY);\n+        completionObjects.put(completionKey,\n+                new AddCompletion(addEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                                  scheduleTimeout(completionKey, addEntryTimeout)));\n+\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.ADD_ENTRY)\n+                .setTxnId(txnId);\n+\n+        AddRequest.Builder addBuilder = AddRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId)\n+                .setMasterKey(ByteString.copyFrom(masterKey))\n+                .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n+\n+        if (((short)options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n+            addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);\n+        }\n+\n+        final Request addRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setAddRequest(addBuilder)\n+                .build();\n+\n         final Channel c = channel;\n         if (c == null) {\n             errorOutAddKey(completionKey);\n             return;\n         }\n         try {\n-            ChannelFuture future = c.write(r);\n+            ChannelFuture future = c.write(addRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n@@ -317,96 +352,134 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n                                         final long entryId,\n                                         ReadEntryCallback cb, Object ctx) {\n-        final CompletionKey key = new CompletionKey(ledgerId, entryId, BookieProtocol.READENTRY);\n-        readCompletions.put(key,\n-                new ReadCompletion(readEntryOpLogger, cb, ctx, scheduleTimeout(key, readEntryTimeout)));\n-\n-        final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n-                BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n-                BookieProtocol.FLAG_DO_FENCING, masterKey);\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n+        completionObjects.put(completionKey,\n+                new ReadCompletion(readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                                   scheduleTimeout(completionKey, readEntryTimeout)));\n+\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.READ_ENTRY)\n+                .setTxnId(txnId);\n+\n+        ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId)\n+                .setMasterKey(ByteString.copyFrom(masterKey))\n+                .setFlag(ReadRequest.Flag.FENCE_LEDGER);\n+\n+        final Request readRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setReadRequest(readBuilder)\n+                .build();\n \n         final Channel c = channel;\n         if (c == null) {\n-            errorOutReadKey(key);\n+            errorOutReadKey(completionKey);\n             return;\n         }\n \n         try {\n-            ChannelFuture future = c.write(r);\n+            ChannelFuture future = c.write(readRequest);\n             future.addListener(new ChannelFutureListener() {\n                     @Override\n                     public void operationComplete(ChannelFuture future) throws Exception {\n                         if (future.isSuccess()) {\n                             if (LOG.isDebugEnabled()) {\n                                 LOG.debug(\"Successfully wrote request {} to {}\",\n-                                          r, c.getRemoteAddress());\n+                                          readRequest, c.getRemoteAddress());\n                             }\n                         } else {\n                             if (!(future.getCause() instanceof ClosedChannelException)) {\n                                 LOG.warn(\"Writing readEntryAndFenceLedger(lid={}, eid={}) to channel {} failed : \",\n                                         new Object[] { ledgerId, entryId, c, future.getCause() });\n                             }\n-                            errorOutReadKey(key);\n+                            errorOutReadKey(completionKey);\n                         }\n                     }\n                 });\n         } catch(Throwable e) {\n-            LOG.warn(\"Read entry operation \" + r + \" failed\", e);\n-            errorOutReadKey(key);\n+            LOG.warn(\"Read entry operation {} failed\", completionKey, e);\n+            errorOutReadKey(completionKey);\n         }\n     }\n \n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n-        final CompletionKey key = new CompletionKey(ledgerId, entryId, BookieProtocol.READENTRY);\n-        readCompletions.put(key,\n-                new ReadCompletion(readEntryOpLogger, cb, ctx, scheduleTimeout(key, readEntryTimeout)));\n-\n-        final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n-                BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n-                BookieProtocol.FLAG_NONE);\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n+        completionObjects.put(completionKey,\n+                new ReadCompletion(readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                                   scheduleTimeout(completionKey, readEntryTimeout)));\n+\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.READ_ENTRY)\n+                .setTxnId(txnId);\n+\n+        ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId);\n+\n+        final Request readRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setReadRequest(readBuilder)\n+                .build();\n \n         final Channel c = channel;\n         if (c == null) {\n-            errorOutReadKey(key);\n+            errorOutReadKey(completionKey);\n             return;\n         }\n \n         try{\n-            ChannelFuture future = c.write(r);\n+            ChannelFuture future = c.write(readRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Successfully wrote request {} to {}\",\n-                                      r, c.getRemoteAddress());\n+                                      readRequest, c.getRemoteAddress());\n                         }\n                     } else {\n                         if (!(future.getCause() instanceof ClosedChannelException)) {\n                             LOG.warn(\"Writing readEntry(lid={}, eid={}) to channel {} failed : \",\n                                     new Object[] { ledgerId, entryId, c, future.getCause() });\n                         }\n-                        errorOutReadKey(key);\n+                        errorOutReadKey(completionKey);\n                     }\n                 }\n             });\n         } catch(Throwable e) {\n-            LOG.warn(\"Read entry operation \" + r + \" failed\", e);\n-            errorOutReadKey(key);\n+            LOG.warn(\"Read entry operation {} failed\", readRequest, e);\n+            errorOutReadKey(completionKey);\n         }\n     }\n \n     /**\n      * Disconnects the bookie client. It can be reused.\n      */\n     public void disconnect() {\n-        closeInternal(false);\n+        disconnect(true);\n+    }\n+\n+    public void disconnect(boolean wait) {\n+        LOG.info(\"Disconnecting the per channel bookie client for {}\", addr);\n+        closeInternal(false, wait);\n     }\n \n     /**\n      * Closes the bookie client permanently. It cannot be reused.\n      */\n     public void close() {\n+        close(true);\n+    }\n+\n+    public void close(boolean wait) {\n+        LOG.info(\"Closing the per channel bookie client for {}\", addr);\n         closeLock.writeLock().lock();\n         try {\n             if (ConnectionState.CLOSED == state) {\n@@ -417,10 +490,10 @@ public void close() {\n         } finally {\n             closeLock.writeLock().unlock();\n         }\n-        closeInternal(true);\n+        closeInternal(true, wait);\n     }\n \n-    private void closeInternal(boolean permanent) {\n+    private void closeInternal(boolean permanent, boolean wait) {\n         Channel toClose = null;\n         synchronized (this) {\n             if (permanent) {\n@@ -432,7 +505,10 @@ private void closeInternal(boolean permanent) {\n             channel = null;\n         }\n         if (toClose != null) {\n-            closeChannel(toClose).awaitUninterruptibly();\n+            ChannelFuture cf = closeChannel(toClose);\n+            if (wait) {\n+                cf.awaitUninterruptibly();\n+            }\n         }\n     }\n \n@@ -450,27 +526,25 @@ void errorOutReadKey(final CompletionKey key) {\n     }\n \n     void errorOutReadKey(final CompletionKey key, final int rc) {\n-        executor.submitOrdered(key.ledgerId, new SafeRunnable() {\n+        final ReadCompletion readCompletion = (ReadCompletion)completionObjects.remove(key);\n+        if (null == readCompletion) {\n+            return;\n+        }\n+        executor.submitOrdered(readCompletion.ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n-\n-                ReadCompletion readCompletion = readCompletions.remove(key);\n                 String bAddress = \"null\";\n                 Channel c = channel;\n-                if(c != null) {\n+                if (c != null) {\n                     bAddress = c.getRemoteAddress().toString();\n                 }\n \n-                if (readCompletion != null) {\n-                    LOG.debug(\"Could not write request for reading entry: {}\"\n-                              + \" ledger-id: {} bookie: {}\",\n-                              new Object[] { key.entryId, key.ledgerId, bAddress });\n+                LOG.debug(\"Could not write request for reading entry: {} ledger-id: {} bookie: {}\",\n+                          new Object[]{ readCompletion.entryId, readCompletion.ledgerId, bAddress });\n \n-                    readCompletion.cb.readEntryComplete(rc,\n-                                                        key.ledgerId, key.entryId, null, readCompletion.ctx);\n-                }\n+                readCompletion.cb.readEntryComplete(rc, readCompletion.ledgerId, readCompletion.entryId,\n+                                                    null, readCompletion.ctx);\n             }\n-\n         });\n     }\n \n@@ -479,29 +553,26 @@ void errorOutAddKey(final CompletionKey key) {\n     }\n \n     void errorOutAddKey(final CompletionKey key, final int rc) {\n-        executor.submitOrdered(key.ledgerId, new SafeRunnable() {\n+        final AddCompletion addCompletion = (AddCompletion)completionObjects.remove(key);\n+        if (null == addCompletion) {\n+            return;\n+        }\n+        executor.submitOrdered(addCompletion.ledgerId, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n-\n-                AddCompletion addCompletion = addCompletions.remove(key);\n-\n-                if (addCompletion != null) {\n-                    String bAddress = \"null\";\n-                    Channel c = channel;\n-                    if(c != null) {\n-                        bAddress = c.getRemoteAddress().toString();\n-                    }\n-                    LOG.debug(\"Could not write request for adding entry: {} ledger-id: {} bookie: {}\",\n-                              new Object[] { key.entryId, key.ledgerId, bAddress });\n-\n-                    addCompletion.cb.writeComplete(rc, key.ledgerId,\n-                                                   key.entryId, addr, addCompletion.ctx);\n-                    LOG.debug(\"Invoked callback method: {}\", key.entryId);\n+                String bAddress = \"null\";\n+                Channel c = channel;\n+                if(c != null) {\n+                    bAddress = c.getRemoteAddress().toString();\n                 }\n-            }\n+                LOG.debug(\"Could not write request for adding entry: {} ledger-id: {} bookie: {}\",\n+                          new Object[] { addCompletion.entryId, addCompletion.ledgerId, bAddress });\n \n+                addCompletion.cb.writeComplete(rc, addCompletion.ledgerId, addCompletion.entryId,\n+                                               addr, addCompletion.ctx);\n+                LOG.debug(\"Invoked callback method: {}\", addCompletion.entryId);\n+            }\n         });\n-\n     }\n \n     /**\n@@ -519,13 +590,17 @@ void errorOutOutstandingEntries(int rc) {\n         // in case they get a write failure on the socket. The one who\n         // successfully removes the key from the map is the one responsible for\n         // calling the application callback.\n-\n-        for (CompletionKey key : addCompletions.keySet()) {\n-            errorOutAddKey(key, rc);\n-        }\n-\n-        for (CompletionKey key : readCompletions.keySet()) {\n-            errorOutReadKey(key, rc);\n+        for (CompletionKey key : completionObjects.keySet()) {\n+            switch (key.operationType) {\n+                case ADD_ENTRY:\n+                    errorOutAddKey(key, rc);\n+                    break;\n+                case READ_ENTRY:\n+                    errorOutReadKey(key, rc);\n+                    break;\n+                default:\n+                    break;\n+            }\n         }\n     }\n \n@@ -543,8 +618,6 @@ public ChannelPipeline getPipeline() throws Exception {\n         pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n         pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder());\n         pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.ResponseDecoder());\n-\n-\n         pipeline.addLast(\"mainhandler\", this);\n         return pipeline;\n     }\n@@ -609,125 +682,101 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n      */\n     @Override\n     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-        if (!(e.getMessage() instanceof BookieProtocol.Response)) {\n+        if (!(e.getMessage() instanceof Response)) {\n             ctx.sendUpstream(e);\n             return;\n         }\n-        final BookieProtocol.Response r = (BookieProtocol.Response)e.getMessage();\n \n-        executor.submitOrdered(r.getLedgerId(), new SafeRunnable() {\n-            @Override\n-            public void safeRun() {\n-                switch (r.getOpCode()) {\n-                case BookieProtocol.ADDENTRY:\n-                    BookieProtocol.AddResponse a = (BookieProtocol.AddResponse)r;\n-                    handleAddResponse(a);\n-                    break;\n-                case BookieProtocol.READENTRY:\n-                    BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse)r;\n-                    handleReadResponse(rr);\n-                    break;\n-                default:\n-                    LOG.error(\"Unexpected response, type: {}\", r);\n-                }\n+        final Response response = (Response) e.getMessage();\n+        final BKPacketHeader header = response.getHeader();\n+\n+        final CompletionValue completionValue = completionObjects.remove(newCompletionKey(header.getTxnId(),\n+                header.getOperation()));\n+\n+        if (null == completionValue) {\n+            // Unexpected response, so log it. The txnId should have been present.\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Unexpected response received from bookie : \" + addr + \" for type : \" + header.             getOperation() +\n+                        \" and txnId : \" + header.getTxnId());\n             }\n-        });\n+\n+        } else {\n+            long orderingKey = completionValue.ledgerId;\n+            executor.submitOrdered(orderingKey, new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    OperationType type = header.getOperation();\n+                    switch (type) {\n+                        case ADD_ENTRY:\n+                            handleAddResponse(response.getAddResponse(), completionValue);\n+                            break;\n+                        case READ_ENTRY:\n+                            handleReadResponse(response.getReadResponse(), completionValue);\n+                            break;\n+                        default:\n+                            LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n+                                      type, addr);\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n     }\n \n-    void handleAddResponse(BookieProtocol.AddResponse a) {\n+    void handleAddResponse(AddResponse response, CompletionValue completionValue) {\n+        // The completion value should always be an instance of an AddCompletion object when we reach here.\n+        AddCompletion ac = (AddCompletion)completionValue;\n+\n+        long ledgerId = response.getLedgerId();\n+        long entryId = response.getEntryId();\n+        StatusCode status = response.getStatus();\n+\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Got response for add request from bookie: {} for ledger: {}\", addr, a);\n+            LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n+                    + entryId + \" rc: \" + status);\n         }\n-\n         // convert to BKException code because thats what the uppper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n-        int rc = BKException.Code.WriteException;\n-        switch (a.getErrorCode()) {\n-        case BookieProtocol.EOK:\n-            rc = BKException.Code.OK;\n-            break;\n-        case BookieProtocol.EBADVERSION:\n-            rc = BKException.Code.ProtocolVersionException;\n-            break;\n-        case BookieProtocol.EFENCED:\n-            rc = BKException.Code.LedgerFencedException;\n-            break;\n-        case BookieProtocol.EUA:\n-            rc = BKException.Code.UnauthorizedAccessException;\n-            break;\n-        case BookieProtocol.EREADONLY:\n-            rc = BKException.Code.WriteOnReadOnlyBookieException;\n-            break;\n-        default:\n-            LOG.warn(\"Add failed {}\", a);\n-            rc = BKException.Code.WriteException;\n-            break;\n-        }\n-\n-        AddCompletion ac;\n-        ac = addCompletions.remove(new CompletionKey(a.getLedgerId(),\n-                                                     a.getEntryId(), BookieProtocol.ADDENTRY));\n-        if (ac == null) {\n-            LOG.debug(\"Unexpected add response from bookie {} for {}\", addr, a);\n-            return;\n+        Integer rcToRet = statusCodeToExceptionCode(status);\n+        if (null == rcToRet) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Add for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n+                        + \" with code:\" + status);\n+            }\n+            rcToRet = BKException.Code.WriteException;\n         }\n-\n-        ac.cb.writeComplete(rc, a.getLedgerId(), a.getEntryId(), addr, ac.ctx);\n+        ac.cb.writeComplete(rcToRet, ledgerId, entryId, addr, ac.ctx);\n     }\n \n-    void handleReadResponse(BookieProtocol.ReadResponse rr) {\n+    void handleReadResponse(ReadResponse response, CompletionValue completionValue) {\n+        // The completion value should always be an instance of a ReadCompletion object when we reach here.\n+        ReadCompletion rc = (ReadCompletion)completionValue;\n+\n+        long ledgerId = response.getLedgerId();\n+        long entryId = response.getEntryId();\n+        StatusCode status = response.getStatus();\n+        ChannelBuffer buffer = ChannelBuffers.buffer(0);\n+\n+        if (response.hasBody()) {\n+            buffer = ChannelBuffers.copiedBuffer(response.getBody().asReadOnlyByteBuffer());\n+        }\n+\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Got response for read request {} entry length: {}\", rr,\n-                    rr.getData() != null ? rr.getData().readableBytes() : -1);\n+            LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n+                    + entryId + \" rc: \" + rc + \" entry length: \" + buffer.readableBytes());\n         }\n \n         // convert to BKException code because thats what the uppper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n-        int rc = BKException.Code.ReadException;\n-        switch (rr.getErrorCode()) {\n-        case BookieProtocol.EOK:\n-            rc = BKException.Code.OK;\n-            break;\n-        case BookieProtocol.ENOENTRY:\n-        case BookieProtocol.ENOLEDGER:\n-            rc = BKException.Code.NoSuchEntryException;\n-            break;\n-        case BookieProtocol.EBADVERSION:\n-            rc = BKException.Code.ProtocolVersionException;\n-            break;\n-        case BookieProtocol.EUA:\n-            rc = BKException.Code.UnauthorizedAccessException;\n-            break;\n-        default:\n-            LOG.warn(\"Read error for {}\", rr);\n-            rc = BKException.Code.ReadException;\n-            break;\n-        }\n-\n-        CompletionKey key = new CompletionKey(rr.getLedgerId(), rr.getEntryId(), BookieProtocol.READENTRY);\n-        ReadCompletion readCompletion = readCompletions.remove(key);\n-\n-        if (readCompletion == null) {\n-            /*\n-             * This is a special case. When recovering a ledger, a client\n-             * submits a read request with id -1, and receives a response with a\n-             * different entry id.\n-             */\n-\n-            readCompletion = readCompletions.remove(new CompletionKey(rr.getLedgerId(),\n-                                                                      BookieProtocol.LAST_ADD_CONFIRMED,\n-                                                                      BookieProtocol.READENTRY));\n-        }\n-\n-        if (readCompletion == null) {\n-            LOG.debug(\"Unexpected read response received from bookie: {} for {}\", addr, rr);\n-            return;\n+        Integer rcToRet = statusCodeToExceptionCode(status);\n+        if (null == rcToRet) {\n+            LOG.error(\"Read entry for ledger:{}, entry:{} failed on bookie:{} with code:{}\",\n+                      new Object[] { ledgerId, entryId, addr, status });\n+            rcToRet = BKException.Code.ReadException;\n         }\n-\n-        readCompletion.cb.readEntryComplete(rc, rr.getLedgerId(), rr.getEntryId(),\n-                                            rr.getData(), readCompletion.ctx);\n+        rc.cb.readEntryComplete(rcToRet, ledgerId, entryId, buffer.slice(), rc.ctx);\n     }\n \n     /**\n@@ -738,10 +787,15 @@ void handleReadResponse(BookieProtocol.ReadResponse rr) {\n     // visible for testing\n     static abstract class CompletionValue {\n         final Object ctx;\n+        protected final long ledgerId;\n+        protected final long entryId;\n         protected final Timeout timeout;\n \n-        public CompletionValue(Object ctx, Timeout timeout) {\n+        public CompletionValue(Object ctx, long ledgerId, long entryId,\n+                               Timeout timeout) {\n             this.ctx = ctx;\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n             this.timeout = timeout;\n         }\n \n@@ -756,14 +810,16 @@ void cancelTimeout() {\n     static class ReadCompletion extends CompletionValue {\n         final ReadEntryCallback cb;\n \n-        public ReadCompletion(ReadEntryCallback cb, Object ctx) {\n-            this(null, cb, ctx, null);\n+        public ReadCompletion(ReadEntryCallback cb, Object ctx,\n+                              long ledgerId, long entryId) {\n+            this(null, cb, ctx, ledgerId, entryId, null);\n         }\n \n         public ReadCompletion(final OpStatsLogger readEntryOpLogger,\n                               final ReadEntryCallback originalCallback,\n-                              final Object originalCtx, final Timeout timeout) {\n-            super(originalCtx, timeout);\n+                              final Object originalCtx, final long ledgerId, final long entryId,\n+                              final Timeout timeout) {\n+            super(originalCtx, ledgerId, entryId, timeout);\n             final long requestTimeMillis = MathUtils.now();\n             this.cb = null == readEntryOpLogger ? originalCallback : new ReadEntryCallback() {\n                 @Override\n@@ -785,15 +841,16 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n     static class AddCompletion extends CompletionValue {\n         final WriteCallback cb;\n \n-        public AddCompletion(WriteCallback cb, Object ctx) {\n-            this(null, cb, ctx, null);\n+        public AddCompletion(WriteCallback cb, Object ctx,\n+                             long ledgerId, long entryId) {\n+            this(null, cb, ctx, ledgerId, entryId, null);\n         }\n \n         public AddCompletion(final OpStatsLogger addEntryOpLogger,\n                              final WriteCallback originalCallback,\n-                             final Object originalCtx,\n+                             final Object originalCtx, final long ledgerId, final long entryId,\n                              final Timeout timeout) {\n-            super(originalCtx, timeout);\n+            super(originalCtx, ledgerId, entryId, timeout);\n             final long requestTimeMillis = MathUtils.now();\n             this.cb = null == addEntryOpLogger ? originalCallback : new WriteCallback() {\n                 @Override\n@@ -812,8 +869,8 @@ public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddre\n     }\n \n     // visable for testing\n-    CompletionKey newCompletionKey(long ledgerId, long entryId, byte operationType) {\n-        return new CompletionKey(ledgerId, entryId, operationType);\n+    CompletionKey newCompletionKey(long txnId, OperationType operationType) {\n+        return new CompletionKey(txnId, operationType);\n     }\n \n     Timeout scheduleTimeout(CompletionKey key, long timeout) {\n@@ -825,16 +882,14 @@ Timeout scheduleTimeout(CompletionKey key, long timeout) {\n     }\n \n     class CompletionKey implements TimerTask {\n-        final long ledgerId;\n-        final long entryId;\n+        final long txnId;\n+        final OperationType operationType;\n         final long requestAt;\n-        final byte operationType;\n \n-        CompletionKey(long ledgerId, long entryId, byte opType) {\n-            this.ledgerId = ledgerId;\n-            this.entryId = entryId;\n+        CompletionKey(long txnId, OperationType operationType) {\n+            this.txnId = txnId;\n+            this.operationType = operationType;\n             this.requestAt = MathUtils.nowInNano();\n-            this.operationType = opType;\n         }\n \n         @Override\n@@ -843,17 +898,17 @@ public boolean equals(Object obj) {\n                 return false;\n             }\n             CompletionKey that = (CompletionKey) obj;\n-            return this.ledgerId == that.ledgerId && this.entryId == that.entryId;\n+            return this.txnId == that.txnId && this.operationType == that.operationType;\n         }\n \n         @Override\n         public int hashCode() {\n-            return ((int) ledgerId << 16) ^ ((int) entryId);\n+            return ((int) txnId);\n         }\n \n         @Override\n         public String toString() {\n-            return String.format(\"LedgerEntry(%d, %d)\", ledgerId, entryId);\n+            return String.format(\"TxnId(%d), OperationType(%s)\", txnId, operationType);\n         }\n \n         private long elapsedTime() {\n@@ -865,7 +920,7 @@ public void run(Timeout timeout) throws Exception {\n             if (timeout.isCancelled()) {\n                 return;\n             }\n-            if (BookieProtocol.ADDENTRY == operationType) {\n+            if (OperationType.ADD_ENTRY == operationType) {\n                 errorOutAddKey(this);\n                 addTimeoutOpLogger.registerSuccessfulEvent(elapsedTime());\n             } else {\n@@ -875,4 +930,43 @@ public void run(Timeout timeout) throws Exception {\n         }\n     }\n \n+    /**\n+     * Note : Helper functions follow\n+     */\n+\n+    /**\n+     * @param status\n+     * @return null if the statuscode is unknown.\n+     */\n+    private Integer statusCodeToExceptionCode(StatusCode status) {\n+        Integer rcToRet = null;\n+        switch (status) {\n+            case EOK:\n+                rcToRet = BKException.Code.OK;\n+                break;\n+            case ENOENTRY:\n+                rcToRet = BKException.Code.NoSuchEntryException;\n+                break;\n+            case ENOLEDGER:\n+                rcToRet = BKException.Code.NoSuchLedgerExistsException;\n+                break;\n+            case EBADVERSION:\n+                rcToRet = BKException.Code.ProtocolVersionException;\n+                break;\n+            case EUA:\n+                rcToRet = BKException.Code.UnauthorizedAccessException;\n+                break;\n+            case EFENCED:\n+                rcToRet = BKException.Code.LedgerFencedException;\n+                break;\n+            default:\n+                break;\n+        }\n+        return rcToRet;\n+    }\n+\n+    private long getTxnId() {\n+        return txnIdGenerator.incrementAndGet();\n+    }\n+\n }"},{"sha":"81b3ba7b10edb226187ed464e7812fb210f168c7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","status":"modified","additions":13,"deletions":2,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -27,6 +27,11 @@\n  */\n interface PerChannelBookieClientPool {\n \n+    /**\n+     * intialize the pool. the implementation should not be blocked.\n+     */\n+    void intialize();\n+\n     /**\n      * Obtain a channel from channel pool to execute operations.\n      *\n@@ -37,12 +42,18 @@\n \n     /**\n      * Disconnect the connections in the pool.\n+     *\n+     * @param wait\n+     *          whether need to wait until pool disconnected.\n      */\n-    void disconnect();\n+    void disconnect(boolean wait);\n \n     /**\n      * Close the pool.\n+     *\n+     * @param wait\n+     *          whether need to wait until pool closed.\n      */\n-    void close();\n+    void close(boolean wait);\n \n }"},{"sha":"2ce6e81321d88459859257b9fbd8f5c2a0f4f5f4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,133 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.BookieProtocol.Request;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class ReadEntryProcessor extends PacketProcessorBase {\n+    private final static Logger LOG = LoggerFactory.getLogger(ReadEntryProcessor.class);\n+\n+    public ReadEntryProcessor(Request request, Channel channel, Bookie bookie) {\n+        super(request, channel, bookie);\n+    }\n+\n+    @Override\n+    protected void processPacket() {\n+        assert (request instanceof BookieProtocol.ReadRequest);\n+        BookieProtocol.ReadRequest read = (BookieProtocol.ReadRequest) request;\n+\n+        LOG.debug(\"Received new read request: {}\", request);\n+        int errorCode = BookieProtocol.EIO;\n+        long startTime = MathUtils.now();\n+        ByteBuffer data = null;\n+        try {\n+            Future<Boolean> fenceResult = null;\n+            if (read.isFencingRequest()) {\n+                LOG.warn(\"Ledger \" + request.getLedgerId() + \" fenced by \" + channel.getRemoteAddress());\n+\n+                if (read.hasMasterKey()) {\n+                    fenceResult = bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());\n+                } else {\n+                    LOG.error(\"Password not provided, Not safe to fence {}\", read.getLedgerId());\n+                    BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+                }\n+            }\n+            data = bookie.readEntry(request.getLedgerId(), request.getEntryId());\n+            LOG.debug(\"##### Read entry ##### {}\", data.remaining());\n+            if (null != fenceResult) {\n+                // TODO:\n+                // currently we don't have readCallback to run in separated read\n+                // threads. after BOOKKEEPER-429 is complete, we could improve\n+                // following code to make it not wait here\n+                //\n+                // For now, since we only try to wait after read entry. so writing\n+                // to journal and read entry are executed in different thread\n+                // it would be fine.\n+                try {\n+                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n+                    if (null == fenced || !fenced) {\n+                        // if failed to fence, fail the read request to make it retry.\n+                        errorCode = BookieProtocol.EIO;\n+                        data = null;\n+                    } else {\n+                        errorCode = BookieProtocol.EOK;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupting fence read entry \" + read, ie);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                } catch (ExecutionException ee) {\n+                    LOG.error(\"Failed to fence read entry \" + read, ee);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                } catch (TimeoutException te) {\n+                    LOG.error(\"Timeout to fence read entry \" + read, te);\n+                    errorCode = BookieProtocol.EIO;\n+                    data = null;\n+                }\n+            } else {\n+                errorCode = BookieProtocol.EOK;\n+            }\n+        } catch (Bookie.NoLedgerException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.ENOLEDGER;\n+        } catch (Bookie.NoEntryException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.ENOENTRY;\n+        } catch (IOException e) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.error(\"Error reading \" + read, e);\n+            }\n+            errorCode = BookieProtocol.EIO;\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger \" + read.getLedgerId(), e);\n+            errorCode = BookieProtocol.EUA;\n+        }\n+\n+        LOG.trace(\"Read entry rc = {} for {}\",\n+                new Object[] { errorCode, read });\n+        if (errorCode == BookieProtocol.EOK) {\n+            assert data != null;\n+\n+            channel.write(ResponseBuilder.buildReadResponse(data, read));\n+            long elapsedTime = MathUtils.now() - startTime;\n+            BKStats.getInstance().getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n+        } else {\n+            channel.write(ResponseBuilder.buildErrorResponse(errorCode, read));\n+            BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+        }\n+    }\n+}"},{"sha":"1462715aa023b2cc476b0b2dea934bc2e4ef870d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+\n+class ReadEntryProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n+\n+    private final static Logger LOG = LoggerFactory.getLogger(ReadEntryProcessorV3.class);\n+\n+    public ReadEntryProcessorV3(Request request, Channel channel, Bookie bookie) {\n+        super(request, channel, bookie);\n+    }\n+\n+    private ReadResponse getReadResponse() {\n+        long startTime = MathUtils.now();\n+        ReadRequest readRequest = request.getReadRequest();\n+        long ledgerId = readRequest.getLedgerId();\n+        long entryId = readRequest.getEntryId();\n+\n+        ReadResponse.Builder readResponse = ReadResponse.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId);\n+\n+        if (!isVersionCompatible()) {\n+            readResponse.setStatus(StatusCode.EBADVERSION);\n+            BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+            return readResponse.build();\n+        }\n+\n+        LOG.debug(\"Received new read request: {}\", request);\n+        StatusCode status;\n+        ByteBuffer entryBody;\n+        try {\n+            Future<Boolean> fenceResult = null;\n+            if (readRequest.hasFlag() && readRequest.getFlag().equals(ReadRequest.Flag.FENCE_LEDGER)) {\n+                LOG.warn(\"Ledger fence request received for ledger: {} from address: {}\", ledgerId,\n+                         channel.getRemoteAddress());\n+\n+                if (readRequest.hasMasterKey()) {\n+                    byte[] masterKey = readRequest.getMasterKey().toByteArray();\n+                    fenceResult = bookie.fenceLedger(ledgerId, masterKey);\n+                } else {\n+                    LOG.error(\"Fence ledger request received without master key for ledger:{} from address: {}\",\n+                              ledgerId, channel.getRemoteAddress());\n+                    BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+                }\n+            }\n+            entryBody = bookie.readEntry(ledgerId, entryId);\n+            if (null != fenceResult) {\n+                // TODO:\n+                // currently we don't have readCallback to run in separated read\n+                // threads. after BOOKKEEPER-429 is complete, we could improve\n+                // following code to make it not wait here\n+                //\n+                // For now, since we only try to wait after read entry. so writing\n+                // to journal and read entry are executed in different thread\n+                // it would be fine.\n+                try {\n+                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n+                    if (null == fenced || !fenced) {\n+                        // if failed to fence, fail the read request to make it retry.\n+                        status = StatusCode.EIO;\n+                    } else {\n+                        status = StatusCode.EOK;\n+                        readResponse.setBody(ByteString.copyFrom(entryBody));\n+                    }\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupting fence read entry (lid: {}, eid: {})\",\n+                              new Object[] { ledgerId, entryId, ie });\n+                    status = StatusCode.EIO;\n+                } catch (ExecutionException ee) {\n+                    LOG.error(\"Failed to fence read entry (lid: {}, eid: {})\",\n+                              new Object[] { ledgerId, entryId, ee });\n+                    status = StatusCode.EIO;\n+                } catch (TimeoutException te) {\n+                    LOG.error(\"Timeout to fence read entry (lid: {}, eid: {})\",\n+                              new Object[] { ledgerId, entryId, te });\n+                    status = StatusCode.EIO;\n+                }\n+            } else {\n+                readResponse.setBody(ByteString.copyFrom(entryBody));\n+                status = StatusCode.EOK;\n+            }\n+        } catch (Bookie.NoLedgerException e) {\n+            status = StatusCode.ENOLEDGER;\n+            LOG.error(\"No ledger found while reading entry:{} from ledger: {}\", entryId, ledgerId);\n+        } catch (Bookie.NoEntryException e) {\n+            status = StatusCode.ENOENTRY;\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No entry found while reading entry:{} from ledger:{}\", entryId, ledgerId);\n+            }\n+        } catch (IOException e) {\n+            status = StatusCode.EIO;\n+            LOG.error(\"IOException while reading entry:{} from ledger:{}\", entryId, ledgerId);\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger:{} while reading entry:{} in request from address: {}\",\n+                    new Object[]{ledgerId, entryId, channel.getRemoteAddress()});\n+            status = StatusCode.EUA;\n+        }\n+\n+        if (status == StatusCode.EOK) {\n+            long elapsedTime = MathUtils.now() - startTime;\n+            BKStats.getInstance().getOpStats(BKStats.STATS_READ).updateLatency(elapsedTime);\n+        } else {\n+            BKStats.getInstance().getOpStats(BKStats.STATS_READ).incrementFailedOps();\n+        }\n+\n+        // Finally set status and return. The body would have been updated if\n+        // a read went through.\n+        readResponse.setStatus(status);\n+        return readResponse.build();\n+    }\n+\n+    @Override\n+    public void run() {\n+        ReadResponse readResponse = getReadResponse();\n+        Response.Builder response = Response.newBuilder()\n+                .setHeader(getHeader())\n+                .setStatus(readResponse.getStatus())\n+                .setReadResponse(readResponse);\n+        channel.write(response.build());\n+    }\n+}\n+"},{"sha":"1157a96c18ce9694cc31327befd527c6726d998d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,98 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Processes add entry requests\n+ */\n+class WriteEntryProcessor extends PacketProcessorBase implements WriteCallback {\n+\n+    private final static Logger LOG = LoggerFactory.getLogger(WriteEntryProcessor.class);\n+\n+    long startTime;\n+\n+    public WriteEntryProcessor(Request request, Channel channel, Bookie bookie) {\n+        super(request, channel, bookie);\n+    }\n+\n+    @Override\n+    protected void processPacket() {\n+        assert (request instanceof BookieProtocol.AddRequest);\n+        BookieProtocol.AddRequest add = (BookieProtocol.AddRequest) request;\n+\n+        if (bookie.isReadOnly()) {\n+            LOG.warn(\"BookieServer is running in readonly mode,\"\n+                    + \" so rejecting the request from the client!\");\n+            channel.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EREADONLY, add));\n+            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+            return;\n+        }\n+\n+        startTime = MathUtils.now();\n+        int rc = BookieProtocol.EOK;\n+        try {\n+            if (add.isRecoveryAdd()) {\n+                bookie.recoveryAddEntry(add.getDataAsByteBuffer(),\n+                                        this, channel, add.getMasterKey());\n+            } else {\n+                bookie.addEntry(add.getDataAsByteBuffer(),\n+                                this, channel, add.getMasterKey());\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Error writing \" + add, e);\n+            rc = BookieProtocol.EIO;\n+        } catch (BookieException.LedgerFencedException lfe) {\n+            LOG.error(\"Attempt to write to fenced ledger\", lfe);\n+            rc = BookieProtocol.EFENCED;\n+        } catch (BookieException e) {\n+            LOG.error(\"Unauthorized access to ledger \" + add.getLedgerId(), e);\n+            rc = BookieProtocol.EUA;\n+        }\n+        if (rc != BookieProtocol.EOK) {\n+            channel.write(ResponseBuilder.buildErrorResponse(rc, add));\n+            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+        }\n+    }\n+\n+    @Override\n+    public void writeComplete(int rc, long ledgerId, long entryId,\n+                              BookieSocketAddress addr, Object ctx) {\n+        channel.write(ResponseBuilder.buildAddResponse(request));\n+\n+        // compute the latency\n+        if (0 == rc) {\n+            // for add operations, we compute latency in writeComplete callbacks.\n+            long elapsedTime = MathUtils.now() - startTime;\n+            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n+        } else {\n+            BKStats.getInstance().getOpStats(BKStats.STATS_ADD).incrementFailedOps();\n+        }\n+    }\n+}"},{"sha":"620de902005a6897cc7cd4bfb55a9f021fc70f8b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","status":"added","additions":143,"deletions":0,"changes":143,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,143 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class WriteEntryProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n+    private final static Logger logger = LoggerFactory.getLogger(WriteEntryProcessorV3.class);\n+\n+    public WriteEntryProcessorV3(Request request, Channel channel, Bookie bookie) {\n+        super(request, channel, bookie);\n+    }\n+\n+    // Returns null if there is no exception thrown\n+    private AddResponse getAddResponse() {\n+        AddRequest addRequest = request.getAddRequest();\n+        long ledgerId = addRequest.getLedgerId();\n+        long entryId = addRequest.getEntryId();\n+\n+        final AddResponse.Builder addResponse = AddResponse.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId);\n+\n+        if (!isVersionCompatible()) {\n+            addResponse.setStatus(StatusCode.EBADVERSION);\n+            return addResponse.build();\n+        }\n+\n+        if (bookie.isReadOnly()) {\n+            logger.warn(\"BookieServer is running as readonly mode, so rejecting the request from the client!\");\n+            addResponse.setStatus(StatusCode.EREADONLY);\n+            return addResponse.build();\n+        }\n+\n+        BookkeeperInternalCallbacks.WriteCallback wcb = new BookkeeperInternalCallbacks.WriteCallback() {\n+            @Override\n+            public void writeComplete(int rc, long ledgerId, long entryId,\n+                                      BookieSocketAddress addr, Object ctx) {\n+                Channel conn = (Channel) ctx;\n+                StatusCode status;\n+                switch (rc) {\n+                    case BookieProtocol.EOK:\n+                        status = StatusCode.EOK;\n+                        break;\n+                    case BookieProtocol.EIO:\n+                        status = StatusCode.EIO;\n+                        break;\n+                    default:\n+                        status = StatusCode.EUA;\n+                        break;\n+                }\n+                addResponse.setStatus(status);\n+                Response.Builder response = Response.newBuilder()\n+                        .setHeader(getHeader())\n+                        .setStatus(addResponse.getStatus())\n+                        .setAddResponse(addResponse);\n+                Response resp = response.build();\n+                conn.write(resp);\n+            }\n+        };\n+        StatusCode status = null;\n+        byte[] masterKey = addRequest.getMasterKey().toByteArray();\n+        ByteBuffer entryToAdd = addRequest.getBody().asReadOnlyByteBuffer();\n+        try {\n+            if (addRequest.hasFlag() && addRequest.getFlag().equals(AddRequest.Flag.RECOVERY_ADD)) {\n+                bookie.recoveryAddEntry(entryToAdd, wcb, channel, masterKey);\n+            } else {\n+                bookie.addEntry(entryToAdd, wcb, channel, masterKey);\n+            }\n+            status = StatusCode.EOK;\n+        } catch (IOException e) {\n+            logger.error(\"Error writing entry:{} to ledger:{}\",\n+                         new Object[] { entryId, ledgerId, e });\n+            status = StatusCode.EIO;\n+        } catch (BookieException.LedgerFencedException e) {\n+            logger.debug(\"Ledger fenced while writing entry:{} to ledger:{}\",\n+                         entryId, ledgerId);\n+            status = StatusCode.EFENCED;\n+        } catch (BookieException e) {\n+            logger.error(\"Unauthorized access to ledger:{} while writing entry:{}\",\n+                         ledgerId, entryId);\n+            status = StatusCode.EUA;\n+        } catch (Throwable t) {\n+            logger.error(\"Unexpected exception while writing {}@{} : \",\n+                         new Object[] { entryId, ledgerId, t });\n+            // some bad request which cause unexpected exception\n+            status = StatusCode.EBADREQ;\n+        }\n+\n+        // If everything is okay, we return null so that the calling function\n+        // doesn't return a response back to the caller.\n+        if (!status.equals(StatusCode.EOK)) {\n+            addResponse.setStatus(status);\n+            return addResponse.build();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void run() {\n+        AddResponse addResponse = getAddResponse();\n+        if (null != addResponse) {\n+            // This means there was an error and we should send this back.\n+            Response.Builder response = Response.newBuilder()\n+                    .setHeader(getHeader())\n+                    .setStatus(addResponse.getStatus())\n+                    .setAddResponse(addResponse);\n+            Response resp = response.build();\n+            channel.write(resp);\n+        }\n+    }\n+}"},{"sha":"56ba5817577e260fe94d188d0f537d0543b5c926","filename":"bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","status":"added","additions":122,"deletions":0,"changes":122,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/proto/BookkeeperProtocol.proto?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+ option java_package = \"org.apache.bookkeeper.proto\";\n+ option optimize_for = SPEED;\n+\n+/**\n+ * Protocol Versions.\n+ */\n+enum ProtocolVersion {\n+    VERSION_ONE = 1;\n+    VERSION_TWO = 2;\n+    VERSION_THREE = 3;\n+}\n+\n+/**\n+ * Status codes.\n+ */\n+enum StatusCode {\n+    EOK = 0;\n+\n+    // Server side Errors 4xx\n+    ENOLEDGER = 402;\n+    ENOENTRY = 403;\n+    EBADREQ = 404;\n+\n+    // IO/access errors 5xx\n+    EIO = 501;\n+    EUA = 502;\n+    EBADVERSION = 503;\n+    EFENCED = 504;\n+    EREADONLY = 505;\n+}\n+\n+/**\n+ * Supported operations by this protocol.\n+ */\n+enum OperationType {\n+    READ_ENTRY = 1;\n+    ADD_ENTRY = 2;\n+    // Not supported yet.\n+    RANGE_READ_ENTRY = 3;\n+    RANGE_ADD_ENTRY = 4;\n+}\n+\n+/**\n+ * Packet header for all requests.\n+ */\n+message BKPacketHeader {\n+    required ProtocolVersion version = 1;\n+    required OperationType operation = 2;\n+    required uint64 txnId = 3;\n+}\n+\n+message Request {\n+    required BKPacketHeader header = 1;\n+    // Requests\n+    optional ReadRequest readRequest = 100;\n+    optional AddRequest addRequest = 101;\n+}\n+\n+message ReadRequest {\n+    enum Flag {\n+        FENCE_LEDGER = 1;\n+    }\n+    optional Flag flag = 100;\n+    required int64 ledgerId = 1;\n+    // entryId will be -1 for reading the LAST_ADD_CONFIRMED entry.\n+    required int64 entryId = 2;\n+    // Used while fencing a ledger.\n+    optional bytes masterKey = 3;\n+}\n+\n+message AddRequest {\n+    enum Flag {\n+        RECOVERY_ADD = 1;\n+    }\n+    optional Flag flag = 100;\n+    required int64 ledgerId = 1;\n+    required int64 entryId = 2;\n+    required bytes masterKey = 3;\n+    required bytes body = 4;\n+}\n+\n+message Response {\n+\n+    required BKPacketHeader header = 1;\n+    // EOK if the underlying request succeeded. Each individual response\n+    // has a more meaningful status. EBADREQ if we have an unsupported request.\n+    required StatusCode status = 2;\n+    // Response\n+    optional ReadResponse readResponse = 100;\n+    optional AddResponse addResponse = 101;\n+\n+}\n+\n+message ReadResponse {\n+    required StatusCode status = 1;\n+    required int64 ledgerId = 2;\n+    required int64 entryId = 3;\n+    optional bytes body = 4;\n+}\n+\n+message AddResponse {\n+    required StatusCode status = 1;\n+    required int64 ledgerId = 2;\n+    required int64 entryId = 3;\n+}"},{"sha":"bff9431175c62fbee3c41423a264642e153a68da","filename":"bookkeeper-server/src/main/resources/findbugsExclude.xml","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/resources/findbugsExclude.xml?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -20,6 +20,10 @@\n     <!-- generated code, we can't be held responsible for findbugs in it //-->\n     <Class name=\"~org\\.apache\\.bookkeeper\\.proto\\.DataFormats.*\" />\n   </Match>\n+  <Match>\n+    <!-- generated code, we can't be held responsible for findbugs in it //-->\n+    <Class name=\"~org\\.apache\\.bookkeeper\\.proto\\.BookkeeperProtocol.*\" />\n+  </Match>\n   <Match>\n     <!-- it is safe to store external bytes reference here. since we are using\n          bytes from a slab. //-->"},{"sha":"69729ccc95a34f73846f36b0bc9ae349cdaa85cf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/8f09334e24deaa8e80674a702c498d802986f3c8/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","raw_url":"https://github.com/apache/bookkeeper/raw/8f09334e24deaa8e80674a702c498d802986f3c8/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java?ref=8f09334e24deaa8e80674a702c498d802986f3c8","patch":"@@ -1,96 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.proto;\n-\n-import static org.junit.Assert.assertEquals;\n-\n-import java.net.InetAddress;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.test.BookieClientTest;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-public class TestProtoVersions {\n-    private BookieClientTest base;\n-\n-    @Before\n-    public void setup() throws Exception {\n-        base = new BookieClientTest();\n-        base.setUp();\n-    }\n-\n-    @After\n-    public void teardown() throws Exception {\n-        base.tearDown();\n-    }\n-\n-    private void testVersion(byte version, int expectedresult) throws Exception {\n-        PerChannelBookieClient bc = new PerChannelBookieClient(base.executor, base.channelFactory,\n-                new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), base.port));\n-        final AtomicInteger outerrc = new AtomicInteger(-1);\n-        final CountDownLatch connectLatch = new CountDownLatch(1);\n-        bc.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>() {\n-                public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n-                    outerrc.set(rc);\n-                    connectLatch.countDown();\n-                }\n-            });\n-        connectLatch.await(5, TimeUnit.SECONDS);\n-\n-        assertEquals(\"client not connected\", BKException.Code.OK, outerrc.get());\n-        outerrc.set(-1000);\n-        final CountDownLatch readLatch = new CountDownLatch(1);\n-        ReadEntryCallback cb = new ReadEntryCallback() {\n-                public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n-                    outerrc.set(rc);\n-                    readLatch.countDown();\n-                }\n-            };\n-        bc.readCompletions.put(bc.newCompletionKey(1, 1, BookieProtocol.READENTRY),\n-                               new PerChannelBookieClient.ReadCompletion(cb, this));\n-\n-        BookieProtocol.ReadRequest req = new BookieProtocol.ReadRequest(version, 1L, 1L, (short)0);\n-\n-        bc.channel.write(req).awaitUninterruptibly();\n-        readLatch.await(5, TimeUnit.SECONDS);\n-        assertEquals(\"Expected result differs\", expectedresult, outerrc.get());\n-\n-        bc.close();\n-    }\n-\n-    @Test(timeout=60000)\n-    public void testVersions() throws Exception {\n-        testVersion((byte)(BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION-1), BKException.Code.ProtocolVersionException);\n-        testVersion(BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION, BKException.Code.NoSuchEntryException);\n-        testVersion(BookieProtocol.CURRENT_PROTOCOL_VERSION, BKException.Code.NoSuchEntryException);\n-        testVersion((byte)(BookieProtocol.CURRENT_PROTOCOL_VERSION+1), BKException.Code.ProtocolVersionException);\n-    }\n-}"},{"sha":"fd605a74370fc8fc9c541d9f1a8154453d1e6310","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -226,7 +226,9 @@ public void testPeriodicCheckWhenDisabled() throws Exception {\n             for (int j = 0; j < 100; j++) {\n                 lh.asyncAddEntry(\"testdata\".getBytes(), new AddCallback() {\n                         public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n-                            rc.compareAndSet(BKException.Code.OK, rc2);\n+                            if (rc.compareAndSet(BKException.Code.OK, rc2)) {\n+                                LOG.info(\"Failed to add entry : {}\", BKException.getMessage(rc2));\n+                            }\n                             completeLatch.countDown();\n                         }\n                     }, null);"},{"sha":"c860bef4bd0752d3945ddcb419cd8b219b88f2bf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -240,7 +240,7 @@ public void testNoLedger() throws Exception {\n         synchronized (arc) {\n             bc.readEntry(addr, 2, 13, recb, arc);\n             arc.wait(1000);\n-            assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n+            assertEquals(BKException.Code.NoSuchLedgerExistsException, arc.rc);\n         }\n     }\n }"},{"sha":"89939b414736f201ed1f6659a6ccb982f0d00d7a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","status":"modified","additions":135,"deletions":15,"changes":150,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -258,6 +258,103 @@ void close() throws Exception {\n         }\n     }\n \n+    /**\n+     * Version 4.2.0 classes\n+     */\n+    static class Server420 {\n+        org.apache.bk_v4_2_0.bookkeeper.conf.ServerConfiguration conf;\n+        org.apache.bk_v4_2_0.bookkeeper.proto.BookieServer server = null;\n+\n+        Server420(File journalDir, File ledgerDir, int port) throws Exception {\n+            conf = new org.apache.bk_v4_2_0.bookkeeper.conf.ServerConfiguration();\n+            conf.setBookiePort(port);\n+            conf.setZkServers(zkUtil.getZooKeeperConnectString());\n+            conf.setJournalDirName(journalDir.getPath());\n+            conf.setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+        }\n+\n+        void start() throws Exception {\n+            server = new org.apache.bk_v4_2_0.bookkeeper.proto.BookieServer(conf);\n+            server.start();\n+            waitUp(conf.getBookiePort());\n+        }\n+\n+        org.apache.bk_v4_2_0.bookkeeper.conf.ServerConfiguration getConf() {\n+            return conf;\n+        }\n+\n+        void stop() throws Exception {\n+            if (server != null) {\n+                server.shutdown();\n+            }\n+        }\n+    }\n+\n+    static class Ledger420 {\n+        org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper bk;\n+        org.apache.bk_v4_2_0.bookkeeper.client.LedgerHandle lh;\n+\n+        private Ledger420(org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper bk,\n+                          org.apache.bk_v4_2_0.bookkeeper.client.LedgerHandle lh) {\n+            this.bk = bk;\n+            this.lh = lh;\n+        }\n+\n+        static Ledger420 newLedger() throws Exception {\n+            org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper newbk\n+                = new org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper(zkUtil.getZooKeeperConnectString());\n+            org.apache.bk_v4_2_0.bookkeeper.client.LedgerHandle newlh\n+                = newbk.createLedger(1, 1,\n+                                  org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper.DigestType.CRC32,\n+                                  \"foobar\".getBytes());\n+            return new Ledger420(newbk, newlh);\n+        }\n+\n+        static Ledger420 openLedger(long id) throws Exception {\n+            org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper newbk\n+                = new org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper(zkUtil.getZooKeeperConnectString());\n+            org.apache.bk_v4_2_0.bookkeeper.client.LedgerHandle newlh\n+                = newbk.openLedger(id,\n+                                org.apache.bk_v4_2_0.bookkeeper.client.BookKeeper.DigestType.CRC32,\n+                                \"foobar\".getBytes());\n+            return new Ledger420(newbk, newlh);\n+        }\n+\n+        long getId() {\n+            return lh.getId();\n+        }\n+\n+        void write100() throws Exception {\n+            for (int i = 0; i < 100; i++) {\n+                lh.addEntry(ENTRY_DATA);\n+            }\n+        }\n+\n+        long readAll() throws Exception {\n+            long count = 0;\n+            Enumeration<org.apache.bk_v4_2_0.bookkeeper.client.LedgerEntry> entries\n+                = lh.readEntries(0, lh.getLastAddConfirmed());\n+            while (entries.hasMoreElements()) {\n+                assertTrue(\"entry data doesn't match\",\n+                           Arrays.equals(entries.nextElement().getEntry(), ENTRY_DATA));\n+                count++;\n+            }\n+            return count;\n+        }\n+\n+        void close() throws Exception {\n+            try {\n+                if (lh != null) {\n+                    lh.close();\n+                }\n+            } finally {\n+                if (bk != null) {\n+                    bk.close();\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Current verion classes\n      */\n@@ -527,7 +624,12 @@ public void testCompat410() throws Exception {\n \n         // Check that current client can to write to old server\n         LedgerCurrent lcur = LedgerCurrent.newLedger();\n-        lcur.write100();\n+        try {\n+            lcur.write100();\n+            fail(\"Shouldn't be able to write\");\n+        } catch (Exception e) {\n+            // correct behaviour\n+        }\n         lcur.close();\n \n         s410.stop();\n@@ -619,12 +721,12 @@ public void testCompat410() throws Exception {\n     }\n \n     /**\n-     * Test compatability between version 4.1.0 and the current version. - 4.1.0\n-     * server restarts with useHostNameAsBookieID=true. Read ledgers with old\n-     * and new clients\n+     * Test compatability between old versions and the current version.\n+     * - old server restarts with useHostNameAsBookieID=true.\n+     * - Read ledgers with old and new clients\n      */\n     @Test(timeout = 60000)\n-    public void testCompat410ReadLedgerOnRestartedServer() throws Exception {\n+    public void testCompatReads() throws Exception {\n         File journalDir = File.createTempFile(\"bookie\", \"journal\");\n         journalDir.delete();\n         journalDir.mkdir();\n@@ -642,10 +744,11 @@ public void testCompat410ReadLedgerOnRestartedServer() throws Exception {\n         long oldLedgerId = l410.getId();\n         l410.close();\n \n-        // Check that current client can to write to old server\n-        LedgerCurrent lcur = LedgerCurrent.newLedger();\n-        lcur.write100();\n-        lcur.close();\n+        // Check that 420 client can to write to 410 server\n+        Ledger420 l420 = Ledger420.newLedger();\n+        l420.write100();\n+        long lid420 = l420.getId();\n+        l420.close();\n \n         s410.stop();\n \n@@ -659,19 +762,25 @@ public void testCompat410ReadLedgerOnRestartedServer() throws Exception {\n         assertEquals(100, l410.readAll());\n         l410.close();\n \n+        // Check that 420 client can read old ledgers on new server\n+        l420 = Ledger420.openLedger(lid420);\n+        assertEquals(\"Failed to read entries!\", 100, l420.readAll());\n+        l420.close();\n+\n         // Check that current client can read old ledgers on new server\n-        final LedgerCurrent curledger = LedgerCurrent.openLedger(lcur.getId());\n+        final LedgerCurrent curledger = LedgerCurrent.openLedger(lid420);\n         assertEquals(\"Failed to read entries!\", 100, curledger.readAll());\n         curledger.close();\n     }\n \n     /**\n-     * Test compatability between version 4.1.0 and the current version. - 4.1.0\n-     * server restarts with useHostNameAsBookieID=true. Write ledgers with old\n-     * and new clients\n+     * Test compatability between version old version and the current version.\n+     * - 4.1.0 server restarts with useHostNameAsBookieID=true.\n+     * - Write ledgers with old and new clients\n+     * - Read ledgers written by old clients.\n      */\n     @Test(timeout = 60000)\n-    public void testCompat410WriteLedgerOnRestartedServer() throws Exception {\n+    public void testCompatWrites() throws Exception {\n         File journalDir = File.createTempFile(\"bookie\", \"journal\");\n         journalDir.delete();\n         journalDir.mkdir();\n@@ -697,15 +806,26 @@ public void testCompat410WriteLedgerOnRestartedServer() throws Exception {\n         final LedgerCurrent curledger = LedgerCurrent.openLedger(lcur.getId());\n         assertEquals(\"Failed to read entries!\", 100, curledger.readAll());\n \n-        // Check that current client can write to server\n+        // Check that 410 client can write to server\n         Ledger410 l410 = Ledger410.newLedger();\n         l410.write100();\n         long oldLedgerId = l410.getId();\n         l410.close();\n \n+        // Check that 420 client can write to server\n+        Ledger410 l420 = Ledger410.newLedger();\n+        l420.write100();\n+        long lid420 = l420.getId();\n+        l420.close();\n+\n         // check that new client can read old ledgers on new server\n         LedgerCurrent oldledger = LedgerCurrent.openLedger(oldLedgerId);\n         assertEquals(\"Failed to read entries!\", 100, oldledger.readAll());\n         oldledger.close();\n+\n+        // check that new client can read old ledgers on new server\n+        oldledger = LedgerCurrent.openLedger(lid420);\n+        assertEquals(\"Failed to read entries!\", 100, oldledger.readAll());\n+        oldledger.close();\n     }\n }"},{"sha":"a55e9d2bffc3c53c67f44ec62d2141b57719ec7a","filename":"compat-deps/pom.xml","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/compat-deps/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/compat-deps/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/compat-deps/pom.xml?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -33,8 +33,10 @@\n   <modules>\n     <module>bookkeeper-server-compat-4.0.0</module>\n     <module>bookkeeper-server-compat-4.1.0</module>\n+    <module>bookkeeper-server-compat-4.2.0</module>\n     <module>hedwig-server-compat-4.0.0</module>\n     <module>hedwig-server-compat-4.1.0</module>\n+    <module>hedwig-server-compat-4.2.0</module>\n   </modules>\n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>"},{"sha":"35b6707fe1ae5730600efde81dc07f17110d9a60","filename":"hedwig-server/pom.xml","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/hedwig-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/hedwig-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/pom.xml?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -123,6 +123,30 @@\n       <artifactId>jline</artifactId>\n       <version>0.9.94</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-server-compat420</artifactId>\n+      <version>4.2.0</version>\n+      <scope>test</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>bookkeeper-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-protocol</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-client</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n     <dependency>\n       <groupId>org.apache.bookkeeper</groupId>\n       <artifactId>hedwig-server-compat410</artifactId>"},{"sha":"f4e806d67dce41ff6824eb0c09bbf25a68360f55","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","status":"modified","additions":140,"deletions":25,"changes":165,"blob_url":"https://github.com/apache/bookkeeper/blob/c81076e4d9521bc67653a917e9fb9edbe27bf073/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","raw_url":"https://github.com/apache/bookkeeper/raw/c81076e4d9521bc67653a917e9fb9edbe27bf073/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java?ref=c81076e4d9521bc67653a917e9fb9edbe27bf073","patch":"@@ -458,6 +458,121 @@ void receiveInts(ByteString topic, ByteString subscriberId, int start, int num)\n         }\n     }\n \n+    /**\n+     * 4.2.0 Version\n+     */\n+    static class BookKeeperCluster420{\n+\n+        int numBookies;\n+        List<org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration> bkConfs;\n+        List<org.apache.hw_v4_2_0.bookkeeper.proto.BookieServer> bks;\n+\n+\n+        BookKeeperCluster420(int numBookies) {\n+            this.numBookies = numBookies;\n+        }\n+\n+        public void start() throws Exception {\n+            zkUtil.startServer();\n+\n+            bks = new LinkedList<org.apache.hw_v4_2_0.bookkeeper.proto.BookieServer>();\n+            bkConfs = new LinkedList<org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration>();\n+\n+            for (int i=0; i<numBookies; i++) {\n+                startBookieServer();\n+            }\n+        }\n+\n+        public void stop() throws Exception {\n+            for (org.apache.hw_v4_2_0.bookkeeper.proto.BookieServer bs : bks) {\n+                bs.shutdown();\n+            }\n+            bks.clear();\n+\n+            zkUtil.killServer();\n+        }\n+\n+        protected void startBookieServer() throws Exception {\n+            int port = PortManager.nextFreePort();\n+            File tmpDir = org.apache.hw_v4_2_0.hedwig.util.FileUtils.createTempDirectory(\n+                getClass().getName() + port, \"test\");\n+            org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration conf = newServerConfiguration(\n+                port, zkUtil.getZooKeeperConnectString(), tmpDir, new File[] { tmpDir });\n+            bks.add(startBookie(conf));\n+            bkConfs.add(conf);\n+        }\n+\n+        protected org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration newServerConfiguration(\n+            int port, String zkServers, File journalDir, File[] ledgerDirs) {\n+            org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration conf =\n+                new org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration();\n+            conf.setBookiePort(port);\n+            conf.setZkServers(zkServers);\n+            conf.setJournalDirName(journalDir.getPath());\n+            String[] ledgerDirNames = new String[ledgerDirs.length];\n+            for (int i=0; i<ledgerDirs.length; i++) {\n+                ledgerDirNames[i] = ledgerDirs[i].getPath();\n+            }\n+            conf.setLedgerDirNames(ledgerDirNames);\n+            return conf;\n+        }\n+\n+        protected org.apache.hw_v4_2_0.bookkeeper.proto.BookieServer startBookie(\n+            org.apache.hw_v4_2_0.bookkeeper.conf.ServerConfiguration conf) throws Exception {\n+            org.apache.hw_v4_2_0.bookkeeper.proto.BookieServer server\n+                = new org.apache.hw_v4_2_0.bookkeeper.proto.BookieServer(conf);\n+            server.start();\n+\n+            int port = conf.getBookiePort();\n+            while (zkUtil.getZooKeeperClient().exists(\n+                    \"/ledgers/available/\" + InetAddress.getLocalHost().getHostAddress() + \":\" + port,\n+                    false) == null) {\n+                Thread.sleep(500);\n+            }\n+            return server;\n+        }\n+    }\n+\n+    static class Server420 {\n+        org.apache.hw_v4_2_0.hedwig.server.common.ServerConfiguration conf;\n+        org.apache.hw_v4_2_0.hedwig.server.netty.PubSubServer server;\n+\n+        Server420(final String zkHosts, final int port, final int sslPort) {\n+            conf = new org.apache.hw_v4_2_0.hedwig.server.common.ServerConfiguration() {\n+                @Override\n+                public int getConsumeInterval() {\n+                    return CONSUMEINTERVAL;\n+                }\n+\n+                @Override\n+                public String getZkHost() {\n+                    return zkHosts;\n+                }\n+\n+                @Override\n+                public int getServerPort() {\n+                    return port;\n+                }\n+\n+                @Override\n+                public int getSSLServerPort() {\n+                    return sslPort;\n+                }\n+            };\n+        }\n+\n+        void start() throws Exception {\n+            server = new org.apache.hw_v4_2_0.hedwig.server.netty.PubSubServer(conf);\n+            server.start();\n+        }\n+\n+        void stop() throws Exception {\n+            if (null != server) {\n+                server.shutdown();\n+            }\n+        }\n+    }\n+\n     /**\n      * Current Version\n      */\n@@ -928,20 +1043,20 @@ public void testMessageBoundCompat() throws Exception {\n         bkc410.stop();\n \n         // start bookkeeper current\n-        BookKeeperClusterCurrent bkccur = new BookKeeperClusterCurrent(3);\n-        bkccur.start();\n+        BookKeeperCluster420 bkc420 = new BookKeeperCluster420(3);\n+        bkc420.start();\n \n-        // start current server\n-        ServerCurrent scur = new ServerCurrent(zkUtil.getZooKeeperConnectString(), port, sslPort);\n-        scur.start();\n+        // start 420 server\n+        Server420 s420 = new Server420(zkUtil.getZooKeeperConnectString(), port, sslPort);\n+        s420.start();\n \n         ccur.subscribe(topic, subid, options5cur);\n         ccur.closeSubscription(topic, subid);\n         ccur.sendXExpectLastY(topic, subid, 50, 5);\n \n-        // stop current servers\n-        scur.stop();\n-        bkccur.stop();\n+        // stop 420 server\n+        s420.stop();\n+        bkc420.stop();\n \n         ccur.close();\n     }\n@@ -982,9 +1097,9 @@ public void testPublishCompat410() throws Exception {\n         // stop 410 server\n         s410.stop();\n \n-        // start current server\n-        ServerCurrent scur = new ServerCurrent(zkUtil.getZooKeeperConnectString(), port, sslPort);\n-        scur.start();\n+        // start 420 server\n+        Server420 s420 = new Server420(zkUtil.getZooKeeperConnectString(), port, sslPort);\n+        s420.start();\n \n         // client c410 could publish message to 410 server\n         // but no message seq id would be returned\n@@ -995,8 +1110,8 @@ public void testPublishCompat410() throws Exception {\n         ccur.close();\n         c410.close();\n \n-        // stop current server\n-        scur.stop();\n+        // stop 420 server\n+        s420.stop();\n         bkc410.stop();\n     }\n \n@@ -1036,10 +1151,10 @@ public void testSubscriptionDataCompat410() throws Exception {\n         // stop 410 server\n         s410.stop();\n \n-        // start current server\n-        ServerCurrent scur = new ServerCurrent(zkUtil.getZooKeeperConnectString(),\n+        // start 420 server\n+        Server420 s420 = new Server420(zkUtil.getZooKeeperConnectString(),\n                                                port, sslPort);\n-        scur.start();\n+        s420.start();\n \n         c410.subscribe(topic, sub410);\n         c410.receiveInts(topic, sub410, 0, 10);\n@@ -1053,8 +1168,8 @@ public void testSubscriptionDataCompat410() throws Exception {\n         c410.receiveInts(topic, sub410, 10, 10);\n         ccur.receiveInts(topic, subcur, 10, 10);\n \n-        // stop current server\n-        scur.stop();\n+        // stop 420 server\n+        s420.stop();\n \n         c410.close();\n         ccur.close();\n@@ -1074,16 +1189,16 @@ public void testUpdateMessageBoundCompat410() throws Exception {\n         ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n \n         // start bookkeeper\n-        BookKeeperClusterCurrent bkccur= new BookKeeperClusterCurrent(3);\n-        bkccur.start();\n+        BookKeeperCluster420 bkc420 = new BookKeeperCluster420(3);\n+        bkc420.start();\n \n         int port = PortManager.nextFreePort();\n         int sslPort = PortManager.nextFreePort();\n \n         // start hub server\n-        ServerCurrent scur = new ServerCurrent(zkUtil.getZooKeeperConnectString(),\n+        Server420 s420 = new Server420(zkUtil.getZooKeeperConnectString(),\n                                                port, sslPort);\n-        scur.start();\n+        s420.start();\n \n         org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions options5cur =\n             org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions.newBuilder()\n@@ -1120,14 +1235,14 @@ public void testUpdateMessageBoundCompat410() throws Exception {\n         // the message bound should be updated.\n         c410.sendXExpectLastY(topic, subid, 50, 5);\n \n-        // stop current server\n-        scur.stop();\n+        // stop 420 server\n+        s420.stop();\n \n         c410.close();\n         ccur.close();\n \n         // stop bookkeeper cluster\n-        bkccur.stop();\n+        bkc420.stop();\n     }\n \n     /**"}]}

