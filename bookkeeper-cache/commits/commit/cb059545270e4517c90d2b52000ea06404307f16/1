{"sha":"cb059545270e4517c90d2b52000ea06404307f16","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjYjA1OTU0NTI3MGU0NTE3YzkwZDJiNTIwMDBlYTA2NDA0MzA3ZjE2","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-10-17T09:19:49Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-10-17T09:19:49Z"},"message":"BOOKKEEPER-422: Simplify AbstractSubscriptionManager (stu via fpj)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1399159 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"96336ff9480da55dd6f4be7f34348db522e7aae1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/96336ff9480da55dd6f4be7f34348db522e7aae1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cb059545270e4517c90d2b52000ea06404307f16","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cb059545270e4517c90d2b52000ea06404307f16","html_url":"https://github.com/apache/bookkeeper/commit/cb059545270e4517c90d2b52000ea06404307f16","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cb059545270e4517c90d2b52000ea06404307f16/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"2385d7a7054dd7e4c3241374b1f5f57360a5a468","url":"https://api.github.com/repos/apache/bookkeeper/commits/2385d7a7054dd7e4c3241374b1f5f57360a5a468","html_url":"https://github.com/apache/bookkeeper/commit/2385d7a7054dd7e4c3241374b1f5f57360a5a468"}],"stats":{"total":65,"additions":28,"deletions":37},"files":[{"sha":"f00d4f9aaf9eb5f5ac6245db7cf8043ac89466af","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/cb059545270e4517c90d2b52000ea06404307f16/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/cb059545270e4517c90d2b52000ea06404307f16/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=cb059545270e4517c90d2b52000ea06404307f16","patch":"@@ -182,6 +182,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-415: Rename DeliveryThrottle to MessageWindowSize (ivank via sijie)\n \n+\tBOOKKEEPER-422: Simplify AbstractSubscriptionManager (stu via fpj)\n+\n       hedwig-client:\n \n         BOOKKEEPER-306: Change C++ client to use gtest for testing (ivank via sijie)"},{"sha":"dd48a9ad34eefa62cb3a3e15782a0951c7da015c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":26,"deletions":37,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/cb059545270e4517c90d2b52000ea06404307f16/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/cb059545270e4517c90d2b52000ea06404307f16/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=cb059545270e4517c90d2b52000ea06404307f16","patch":"@@ -52,13 +52,13 @@\n \n public abstract class AbstractSubscriptionManager implements SubscriptionManager, TopicOwnershipChangeListener {\n \n-    ServerConfiguration cfg;\n-    ConcurrentHashMap<ByteString, Map<ByteString, InMemorySubscriptionState>> top2sub2seq = new ConcurrentHashMap<ByteString, Map<ByteString, InMemorySubscriptionState>>();\n     static Logger logger = LoggerFactory.getLogger(AbstractSubscriptionManager.class);\n \n-    TopicOpQueuer queuer;\n+    protected final ServerConfiguration cfg;\n+    protected final ConcurrentHashMap<ByteString, Map<ByteString, InMemorySubscriptionState>> top2sub2seq =\n+      new ConcurrentHashMap<ByteString, Map<ByteString, InMemorySubscriptionState>>();\n+    protected final TopicOpQueuer queuer;\n     private final ArrayList<SubscriptionEventListener> listeners = new ArrayList<SubscriptionEventListener>();\n-    private final ConcurrentHashMap<ByteString, AtomicInteger> topic2LocalCounts = new ConcurrentHashMap<ByteString, AtomicInteger>();\n \n     // Handle to the DeliveryManager for the server so we can stop serving subscribers\n     // when losing topics\n@@ -75,7 +75,7 @@\n     // for all subscribers to the topic.\n     private final ConcurrentHashMap<ByteString, Long> topic2MinConsumedMessagesMap = new ConcurrentHashMap<ByteString, Long>();\n \n-    Callback<Void> noopCallback = new NoopCallback<Void>();\n+    protected final Callback<Void> noopCallback = new NoopCallback<Void>();\n \n     static class NoopCallback<T> implements Callback<T> {\n         @Override\n@@ -177,15 +177,6 @@ public void operationFinished(final Object ctx,\n                     // number for bookkeeping so that future\n                     // subscribes/unsubscribes can efficiently notify listeners.\n \n-                    // Count the number of local subscribers we just inherited.\n-                    // This loop is OK since the number of subscribers per topic\n-                    // is expected to be small.\n-                    int localCount = 0;\n-                    for (ByteString subscriberId : resultOfOperation.keySet())\n-                        if (!SubscriptionStateUtils.isHubSubscriber(subscriberId))\n-                            localCount++;\n-                    topic2LocalCounts.put(topic, new AtomicInteger(localCount));\n-\n                     // The final \"commit\" (and \"abort\") operations.\n                     final Callback<Void> cb2 = new Callback<Void>() {\n \n@@ -206,8 +197,8 @@ public void operationFinished(Object ctx, Void voidObj) {\n                     };\n \n                     // Notify listeners if necessary.\n-                    if (localCount > 0) {\n-                        notifySubscribe(topic, false, cb2, ctx);\n+                    if (hasLocalSubscriptions(resultOfOperation)) {\n+                        notifyFirstLocalSubscribe(topic, false, cb2, ctx);\n                     } else {\n                         cb2.operationFinished(ctx, null);\n                     }\n@@ -221,7 +212,7 @@ public void operationFinished(Object ctx, Void voidObj) {\n \n     }\n \n-    private void notifySubscribe(ByteString topic, boolean synchronous, final Callback<Void> cb, final Object ctx) {\n+    private void notifyFirstLocalSubscribe(ByteString topic, boolean synchronous, final Callback<Void> cb, final Object ctx) {\n         Callback<Void> mcb = CallbackUtils.multiCallback(listeners.size(), cb, ctx);\n         for (SubscriptionEventListener listener : listeners) {\n             listener.onFirstLocalSubscribe(topic, synchronous, mcb);\n@@ -292,11 +283,10 @@ private void finish() {\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Stop serving topic \" + topic.toStringUtf8());\n                     }\n-                    topic2LocalCounts.remove(topic);\n                     // Since we decrement local count when some of remote subscriptions failed,\n                     // while we don't unsubscribe those succeed subscriptions. so we can't depends\n                     // on local count, just try to notify unsubscribe.\n-                    notifyUnsubcribe(topic);\n+                    notifyLastLocalUnsubscribe(topic);\n                     cb.operationFinished(ctx, null);\n                 }\n             };\n@@ -333,7 +323,7 @@ public void lostTopic(ByteString topic) {\n         queuer.pushAndMaybeRun(topic, new ReleaseOp(topic, noopCallback, null, true));\n     }\n \n-    private void notifyUnsubcribe(ByteString topic) {\n+    private void notifyLastLocalUnsubscribe(ByteString topic) {\n         for (SubscriptionEventListener listener : listeners)\n             listener.onLastLocalUnsubscribe(topic);\n     }\n@@ -454,7 +444,6 @@ public void operationFailed(Object ctx, PubSubException exception) {\n                 @Override\n                 public void operationFinished(Object ctx, Void resultOfOperation) {\n                     Callback<Void> cb2 = new Callback<Void>() {\n-\n                         @Override\n                         public void operationFailed(final Object ctx, final PubSubException exception) {\n                             logger.error(\"subscription for subscriber \" + subscriberId.toStringUtf8() + \" to topic \"\n@@ -474,15 +463,6 @@ public void operationFailed(Object context,\n                                     finish();\n                                 }\n                                 private void finish() {\n-                                    // we should decrement local count when remote subscription failed\n-                                    if (!SubscriptionStateUtils.isHubSubscriber(subRequest.getSubscriberId())) {\n-                                        // since the subscribe op is executed one by one in queue order,\n-                                        // so the following codes only happened when remote subscription failed.\n-                                        // it is safe to decrement the local count so next subscribe op\n-                                        // could have the chance to subscribe remote.\n-                                        AtomicInteger count = topic2LocalCounts.get(topic);\n-                                        if (count != null) { count.decrementAndGet(); }\n-                                    }\n                                     cb.operationFailed(ctx, exception);\n                                 }\n                             }, ctx);\n@@ -499,18 +479,28 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n \n                     };\n \n-                    AtomicInteger count = topic2LocalCounts.get(topic);\n+                    // if this will be the first local subscription, notifyFirstLocalSubscribe\n                     if (!SubscriptionStateUtils.isHubSubscriber(subRequest.getSubscriberId())\n-                        && count != null\n-                        && count.incrementAndGet() == 1)\n-                        notifySubscribe(topic, subRequest.getSynchronous(), cb2, ctx);\n+                        && !hasLocalSubscriptions(topicSubscriptions))\n+                        notifyFirstLocalSubscribe(topic, subRequest.getSynchronous(), cb2, ctx);\n                     else\n                         cb2.operationFinished(ctx, resultOfOperation);\n                 }\n             }, ctx);\n         }\n     }\n \n+    /**\n+     * @return True if the given subscriberId-to-subscriberState map contains a local subscription:\n+     * the vast majority of subscriptions are local, so we will quickly encounter one if it exists.\n+     */\n+    private static boolean hasLocalSubscriptions(Map<ByteString, InMemorySubscriptionState> topicSubscriptions) {\n+      for (ByteString subId : topicSubscriptions.keySet())\n+        if (!SubscriptionStateUtils.isHubSubscriber(subId))\n+          return true;\n+      return false;\n+    }\n+\n     public void updateMessageBound(ByteString topic) {\n         final Map<ByteString, InMemorySubscriptionState> topicSubscriptions = top2sub2seq.get(topic);\n         if (topicSubscriptions == null) {\n@@ -619,10 +609,9 @@ public void operationFailed(Object ctx, PubSubException exception) {\n                 public void operationFinished(Object ctx, Void resultOfOperation) {\n                     topicSubscriptions.remove(subscriberId);\n                     // Notify listeners if necessary.\n-                    AtomicInteger count = topic2LocalCounts.get(topic);\n                     if (!SubscriptionStateUtils.isHubSubscriber(subscriberId)\n-                        && count != null && count.decrementAndGet() == 0)\n-                        notifyUnsubcribe(topic);\n+                        && !hasLocalSubscriptions(topicSubscriptions))\n+                        notifyLastLocalUnsubscribe(topic);\n \n                     updateMessageBound(topic);\n                     cb.operationFinished(ctx, null);"}]}

