{"sha":"cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjYjg0MTVkNWRlZmIyN2VmZWI4ZmE3YWIxYzkyYTYwZDRmNWMzMWFm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-28T08:51:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-28T08:51:17Z"},"message":"BOOKKEEPER-337: Add entry fails with MetadataVersionException when last ensemble has morethan one bookie failures (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1378023 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9e7e723608ca7387e6323516ec2fafdad7f8e80b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9e7e723608ca7387e6323516ec2fafdad7f8e80b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","html_url":"https://github.com/apache/bookkeeper/commit/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"6379ae858d11bac62a95ccb06675e2bd511f822a","url":"https://api.github.com/repos/apache/bookkeeper/commits/6379ae858d11bac62a95ccb06675e2bd511f822a","html_url":"https://github.com/apache/bookkeeper/commit/6379ae858d11bac62a95ccb06675e2bd511f822a"}],"stats":{"total":449,"additions":386,"deletions":63},"files":[{"sha":"9129f8c017e9a67be0f13131362c3830df00256f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","patch":"@@ -66,6 +66,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-382: space missed at concatenations in GarbageCollectorThread logging (Brahma via sijie)\n \n+        BOOKKEEPER-337: Add entry fails with MetadataVersionException when last ensemble has morethan one bookie failures (rakeshr via ivank)\n+\n       hedwig-client:\n \n         BOOKKEEPER-274: Hedwig cpp client library should not link to cppunit which is just used for test. (sijie via ivank)"},{"sha":"90fbfdbe9fadd7cae0e21a616a027d0d425995ac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":154,"deletions":63,"changes":217,"blob_url":"https://github.com/apache/bookkeeper/blob/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","patch":"@@ -21,7 +21,6 @@\n  *\n  */\n \n-import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -653,88 +652,180 @@ void sendAddSuccessCallbacks() {\n \n     }\n \n-    void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n+    void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n         InetSocketAddress newBookie;\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Handling failure of bookie: \" + addr + \" index: \"\n                       + bookieIndex);\n         }\n+        final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>();\n+        final long newEnsembleStartEntry = lastAddConfirmed + 1;\n \n-        try {\n-            newBookie = bk.bookieWatcher\n+        // avoid parallel ensemble changes to same ensemble.\n+        synchronized (metadata) {\n+            try {\n+                newBookie = bk.bookieWatcher\n                         .getAdditionalBookie(metadata.currentEnsemble);\n-        } catch (BKNotEnoughBookiesException e) {\n-            LOG\n-            .error(\"Could not get additional bookie to remake ensemble, closing ledger: \"\n-                   + ledgerId);\n-            handleUnrecoverableErrorDuringAdd(e.getCode());\n-            return;\n+            } catch (BKNotEnoughBookiesException e) {\n+                LOG.error(\"Could not get additional bookie to \"\n+                        + \"remake ensemble, closing ledger: \" + ledgerId);\n+                handleUnrecoverableErrorDuringAdd(e.getCode());\n+                return;\n+            }\n+\n+            newEnsemble.addAll(metadata.currentEnsemble);\n+            newEnsemble.set(bookieIndex, newBookie);\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble\n+                        + \" to: \" + newEnsemble + \" for ledger: \" + ledgerId\n+                        + \" starting at entry: \" + (lastAddConfirmed + 1));\n+            }\n+\n+            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n         }\n \n-        final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>(\n-            metadata.currentEnsemble);\n-        newEnsemble.set(bookieIndex, newBookie);\n+        EnsembleInfo ensembleInfo = new EnsembleInfo(newEnsemble, bookieIndex,\n+                addr);\n+        writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo));\n+    }\n+\n+    // Contains newly reformed ensemble, bookieIndex, failedBookieAddress\n+    private static final class EnsembleInfo {\n+        private final ArrayList<InetSocketAddress> newEnsemble;\n+        private final int bookieIndex;\n+        private final InetSocketAddress addr;\n \n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble + \" to: \"\n-                      + newEnsemble + \" for ledger: \" + ledgerId + \" starting at entry: \"\n-                      + (lastAddConfirmed + 1));\n+        public EnsembleInfo(ArrayList<InetSocketAddress> newEnsemble,\n+                int bookieIndex, InetSocketAddress addr) {\n+            this.newEnsemble = newEnsemble;\n+            this.bookieIndex = bookieIndex;\n+            this.addr = addr;\n         }\n+    }\n \n-        final long newEnsembleStartEntry = lastAddConfirmed + 1;\n-        metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n+    /**\n+     * Callback which is updating the ledgerMetadata in zk with the newly\n+     * reformed ensemble. On MetadataVersionException, will reread latest\n+     * ledgerMetadata and act upon.\n+     */\n+    private final class ChangeEnsembleCb implements GenericCallback<Void> {\n+        private final EnsembleInfo ensembleInfo;\n \n-        final class ChangeEnsembleCb implements GenericCallback<Void> {\n-            @Override\n-            public void operationComplete(final int rc, Void result) {\n+        ChangeEnsembleCb(EnsembleInfo ensembleInfo) {\n+            this.ensembleInfo = ensembleInfo;\n+        }\n \n-                bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-                    @Override\n-                    public void safeRun() {\n-                        if (rc == BKException.Code.MetadataVersionException) {\n-                            rereadMetadata(new GenericCallback<LedgerMetadata>() {\n-                                @Override\n-                                public void operationComplete(int newrc, LedgerMetadata newMeta) {\n-                                    if (newrc != BKException.Code.OK) {\n-                                        LOG.error(\"Error reading new metadata from ledger after changing ensemble, code=\" + newrc);\n-                                        handleUnrecoverableErrorDuringAdd(rc);\n-                                    } else {\n-                                        // a new ensemble is added only when the start entry is larger than zero\n-                                        if (newEnsembleStartEntry > 0) {\n-                                            metadata.getEnsembles().remove(newEnsembleStartEntry);\n-                                        }\n-                                        if (metadata.resolveConflict(newMeta)) {\n-                                            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n-                                            writeLedgerConfig(new ChangeEnsembleCb());\n-                                            return;\n-                                        } else {\n-                                            LOG.error(\"Could not resolve ledger metadata conflict while changing ensemble to: \"\n-                                                      + newEnsemble + \", old meta data is \\n\" + new String(metadata.serialize())\n-                                                      + \"\\n, new meta data is \\n\" + new String(newMeta.serialize()) + \"\\n ,closing ledger\");\n-                                            handleUnrecoverableErrorDuringAdd(rc);\n-                                        }\n-                                    }\n-                                }\n-                            });\n-                            return;\n-                        } else if (rc != BKException.Code.OK) {\n-                            LOG.error(\"Could not persist ledger metadata while changing ensemble to: \"\n-                                    + newEnsemble + \" , closing ledger\");\n-                            handleUnrecoverableErrorDuringAdd(rc);\n-                            return;\n-                        }\n+        @Override\n+        public void operationComplete(final int rc, Void result) {\n \n-                        for (PendingAddOp pendingAddOp : pendingAddOps) {\n-                            pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n-                        }\n+            bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    if (rc == BKException.Code.MetadataVersionException) {\n+                        rereadMetadata(new ReReadLedgerMetadataCb(rc,\n+                                ensembleInfo));\n+                        return;\n+                    } else if (rc != BKException.Code.OK) {\n+                        LOG.error(\"Could not persist ledger metadata while \"\n+                                + \"changing ensemble to: \"\n+                                + ensembleInfo.newEnsemble\n+                                + \" , closing ledger\");\n+                        handleUnrecoverableErrorDuringAdd(rc);\n+                        return;\n                     }\n-                });\n+                    // the failed bookie has been replaced\n+                    unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n+                }\n+            });\n+        }\n+    };\n+\n+    /**\n+     * Callback which is reading the ledgerMetadata present in zk. This will try\n+     * to resolve the version conflicts.\n+     */\n+    private final class ReReadLedgerMetadataCb implements\n+            GenericCallback<LedgerMetadata> {\n+        private final int rc;\n+        private final EnsembleInfo ensembleInfo;\n \n+        ReReadLedgerMetadataCb(int rc, EnsembleInfo ensembleInfo) {\n+            this.rc = rc;\n+            this.ensembleInfo = ensembleInfo;\n+        }\n+\n+        @Override\n+        public void operationComplete(int newrc, LedgerMetadata newMeta) {\n+            if (newrc != BKException.Code.OK) {\n+                LOG.error(\"Error reading new metadata from ledger \"\n+                        + \"after changing ensemble, code=\" + newrc);\n+                handleUnrecoverableErrorDuringAdd(rc);\n+            } else {\n+                if (!resolveConflict(newMeta)) {\n+                    LOG.error(\"Could not resolve ledger metadata conflict \"\n+                            + \"while changing ensemble to: \"\n+                            + ensembleInfo.newEnsemble\n+                            + \", old meta data is \\n\"\n+                            + new String(metadata.serialize())\n+                            + \"\\n, new meta data is \\n\"\n+                            + new String(newMeta.serialize())\n+                            + \"\\n ,closing ledger\");\n+                    handleUnrecoverableErrorDuringAdd(rc);\n+                }\n             }\n-        };\n+        }\n \n-        writeLedgerConfig(new ChangeEnsembleCb());\n+        /**\n+         * Resolving the version conflicts between local ledgerMetadata and zk\n+         * ledgerMetadata. This will do the following:\n+         * <ul>\n+         * <li>\n+         * check whether ledgerMetadata state matches of local and zk</li>\n+         * <li>\n+         * if the zk ledgerMetadata still contains the failed bookie, then\n+         * update zookeeper with the newBookie otherwise send write request</li>\n+         * </ul>\n+         */\n+        private boolean resolveConflict(LedgerMetadata newMeta) {\n+            // close have changed, another client has opened\n+            // the ledger, can't resolve this conflict.\n+            if (metadata.getState() != newMeta.getState()) {\n+                return false;\n+            }\n+            // update znode version\n+            metadata.setVersion(newMeta.getVersion());\n+            // Resolve the conflicts if zk metadata still contains failed\n+            // bookie.\n+            if (newMeta.currentEnsemble.get(ensembleInfo.bookieIndex).equals(\n+                    ensembleInfo.addr)) {\n+                // Update ledger metadata in zk, if in-memory metadata doesn't\n+                // contains the failed bookie.\n+                if (!metadata.currentEnsemble.get(ensembleInfo.bookieIndex)\n+                        .equals(ensembleInfo.addr)) {\n+                    LOG.info(\"Resolve ledger metadata conflict \"\n+                            + \"while changing ensemble to: \"\n+                            + ensembleInfo.newEnsemble\n+                            + \", old meta data is \\n\"\n+                            + new String(metadata.serialize())\n+                            + \"\\n, new meta data is \\n\"\n+                            + new String(newMeta.serialize()));\n+                    writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo));\n+                }\n+            } else {\n+                // the failed bookie has been replaced\n+                unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n+            }\n+            return true;\n+        }\n+\n+    };\n+\n+    private void unsetSuccessAndSendWriteRequest(final int bookieIndex) {\n+        for (PendingAddOp pendingAddOp : pendingAddOps) {\n+            pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n+        }\n     }\n \n     void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {"},{"sha":"3606126beeec5db6101172d8e37bd7ee666b05bd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","status":"added","additions":230,"deletions":0,"changes":230,"blob_url":"https://github.com/apache/bookkeeper/blob/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java?ref=cb8415d5defb27efeb8fa7ab1c92a60d4f5c31af","patch":"@@ -0,0 +1,230 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Random;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Testing ledger write entry cases\n+ */\n+public class BookieWriteLedgerTest extends\n+        MultiLedgerManagerMultiDigestTestCase implements AddCallback {\n+\n+    private static Logger LOG = LoggerFactory\n+            .getLogger(BookieWriteLedgerTest.class);\n+\n+    byte[] ledgerPassword = \"aaa\".getBytes();\n+    LedgerHandle lh, lh2;\n+    Enumeration<LedgerEntry> ls;\n+\n+    // test related variables\n+    int numEntriesToWrite = 100;\n+    int maxInt = Integer.MAX_VALUE;\n+    Random rng; // Random Number Generator\n+    ArrayList<byte[]> entries1; // generated entries\n+    ArrayList<byte[]> entries2; // generated entries\n+\n+    DigestType digestType;\n+\n+    private static class SyncObj {\n+        volatile int counter;\n+\n+        public SyncObj() {\n+            counter = 0;\n+        }\n+    }\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+        // Number Generator\n+        entries1 = new ArrayList<byte[]>(); // initialize the entries list\n+        entries2 = new ArrayList<byte[]>(); // initialize the entries list\n+    }\n+\n+    public BookieWriteLedgerTest(String ledgerManagerFactory,\n+            DigestType digestType) {\n+        super(5);\n+        this.digestType = digestType;\n+        // set ledger manager\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+    }\n+\n+    /**\n+     * Verify write when few bookie failures in last ensemble and forcing\n+     * ensemble reformation\n+     */\n+    @Test\n+    public void testWithMultipleBookieFailuresInLastEnsemble() throws Exception {\n+        // Create a ledger\n+        lh = bkc.createLedger(5, 4, digestType, ledgerPassword);\n+        LOG.info(\"Ledger ID: \" + lh.getId());\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(entry.array());\n+        }\n+        // Start three more bookies\n+        startNewBookie();\n+        startNewBookie();\n+        startNewBookie();\n+\n+        // Shutdown three bookies in the last ensemble and continue writing\n+        ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+                .getEnsembles().entrySet().iterator().next().getValue();\n+        killBookie(ensemble.get(0));\n+        killBookie(ensemble.get(1));\n+        killBookie(ensemble.get(2));\n+\n+        int i = numEntriesToWrite;\n+        numEntriesToWrite = numEntriesToWrite + 50;\n+        for (; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(entry.array());\n+        }\n+\n+        readEntries(lh, entries1);\n+        lh.close();\n+    }\n+\n+    /**\n+     * Verify asynchronous writing when few bookie failures in last ensemble.\n+     */\n+    @Test\n+    public void testAsyncWritesWithMultipleFailuresInLastEnsemble()\n+            throws Exception {\n+        // Create ledgers\n+        lh = bkc.createLedger(5, 4, digestType, ledgerPassword);\n+        lh2 = bkc.createLedger(5, 4, digestType, ledgerPassword);\n+\n+        LOG.info(\"Ledger ID-1: \" + lh.getId());\n+        LOG.info(\"Ledger ID-2: \" + lh2.getId());\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            entries2.add(entry.array());\n+            lh.addEntry(entry.array());\n+            lh2.addEntry(entry.array());\n+        }\n+        // Start three more bookies\n+        startNewBookie();\n+        startNewBookie();\n+        startNewBookie();\n+\n+        // Shutdown three bookies in the last ensemble and continue writing\n+        ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+                .getEnsembles().entrySet().iterator().next().getValue();\n+        killBookie(ensemble.get(0));\n+        killBookie(ensemble.get(1));\n+        killBookie(ensemble.get(2));\n+\n+        // adding one more entry to both the ledgers async after multiple bookie\n+        // failures. This will do asynchronously modifying the ledger metadata\n+        // simultaneously.\n+        numEntriesToWrite++;\n+        ByteBuffer entry = ByteBuffer.allocate(4);\n+        entry.putInt(rng.nextInt(maxInt));\n+        entry.position(0);\n+        entries1.add(entry.array());\n+        entries2.add(entry.array());\n+\n+        SyncObj syncObj1 = new SyncObj();\n+        SyncObj syncObj2 = new SyncObj();\n+        lh.asyncAddEntry(entry.array(), this, syncObj1);\n+        lh2.asyncAddEntry(entry.array(), this, syncObj2);\n+\n+        // wait for all entries to be acknowledged for the first ledger\n+        synchronized (syncObj1) {\n+            while (syncObj1.counter < 1) {\n+                LOG.debug(\"Entries counter = \" + syncObj1.counter);\n+                syncObj1.wait();\n+            }\n+        }\n+        // wait for all entries to be acknowledged for the second ledger\n+        synchronized (syncObj2) {\n+            while (syncObj2.counter < 1) {\n+                LOG.debug(\"Entries counter = \" + syncObj2.counter);\n+                syncObj2.wait();\n+            }\n+        }\n+\n+        // reading ledger till the last entry\n+        readEntries(lh, entries1);\n+        readEntries(lh2, entries2);\n+        lh.close();\n+        lh2.close();\n+    }\n+\n+    private void readEntries(LedgerHandle lh, ArrayList<byte[]> entries)\n+            throws InterruptedException, BKException {\n+        ls = lh.readEntries(0, numEntriesToWrite - 1);\n+        int index = 0;\n+        while (ls.hasMoreElements()) {\n+            ByteBuffer origbb = ByteBuffer.wrap(entries.get(index++));\n+            Integer origEntry = origbb.getInt();\n+            ByteBuffer result = ByteBuffer.wrap(ls.nextElement().getEntry());\n+            LOG.debug(\"Length of result: \" + result.capacity());\n+            LOG.debug(\"Original entry: \" + origEntry);\n+            Integer retrEntry = result.getInt();\n+            LOG.debug(\"Retrieved entry: \" + retrEntry);\n+            assertTrue(\"Checking entry \" + index + \" for equality\", origEntry\n+                    .equals(retrEntry));\n+        }\n+    }\n+\n+    @Override\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        if (rc != BKException.Code.OK)\n+            fail(\"Return code is not OK: \" + rc);\n+\n+        SyncObj x = (SyncObj) ctx;\n+\n+        synchronized (x) {\n+            x.counter++;\n+            x.notify();\n+        }\n+    }\n+}"}]}

