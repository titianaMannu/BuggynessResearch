{"sha":"ccc9545c4565c337ef6ea06004149de75b4dd3af","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjY2M5NTQ1YzQ1NjVjMzM3ZWY2ZWEwNjAwNDE0OWRlNzViNGRkM2Fm","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-05-31T10:02:59Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-05-31T10:02:59Z"},"message":"BOOKKEEPER-611: Speed up bookkeeper tests (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1488138 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a0e8e61e70c6490381760787dcbca2111e4827f7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a0e8e61e70c6490381760787dcbca2111e4827f7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ccc9545c4565c337ef6ea06004149de75b4dd3af","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ccc9545c4565c337ef6ea06004149de75b4dd3af","html_url":"https://github.com/apache/bookkeeper/commit/ccc9545c4565c337ef6ea06004149de75b4dd3af","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ccc9545c4565c337ef6ea06004149de75b4dd3af/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"4c89310f8b8e09f2ad394a7e7fd5fffc8f51e701","url":"https://api.github.com/repos/apache/bookkeeper/commits/4c89310f8b8e09f2ad394a7e7fd5fffc8f51e701","html_url":"https://github.com/apache/bookkeeper/commit/4c89310f8b8e09f2ad394a7e7fd5fffc8f51e701"}],"stats":{"total":347,"additions":223,"deletions":124},"files":[{"sha":"de4f4652e2a73daf136b450efb3230f5392417d1","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -80,6 +80,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-583: Read from a ReadOnlyBookie fails if index fileinfo is not in ledger cache (vinay via sijie)\n \n+      BOOKKEEPER-611: Speed up bookkeeper tests (ivank via fpj)\n+\n     NEW FEATURE:\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)"},{"sha":"22d3463f3ca62b94439c25f6cced7ab2853cb18c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":19,"deletions":7,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -30,9 +30,11 @@\n import java.util.Map;\n import java.util.Random;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -174,10 +176,7 @@ public void testRestartBookie() throws Exception {\n         ledgerList.add(lh2.getId());\n         LOG.debug(\"Created following ledgers : \" + ledgerList);\n \n-        // 2 is added to the latch, since after the ledger reformation, again\n-        // the reformed bookie is stopped. So auditor will modify the zk\n-        // underreplicated metadata\n-        int count = ledgerList.size() + 2;\n+        int count = ledgerList.size();\n         final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(count);\n \n         int bkShutdownIndex = bs.size() - 1;\n@@ -190,7 +189,7 @@ public void testRestartBookie() throws Exception {\n \n         // grace period for publishing the bk-ledger\n         LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n-        underReplicaLatch.await(5, TimeUnit.SECONDS);\n+        assertTrue(\"latch should have completed\", underReplicaLatch.await(5, TimeUnit.SECONDS));\n         Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n \n         assertEquals(\"Missed identifying under replicated ledgers\", 2,\n@@ -272,7 +271,7 @@ public void testToggleLedgerReplication() throws Exception {\n         shutdownBookieList.add(shutdownBookie(bs.size() - 1));\n \n         assertFalse(\"Ledger replication is not disabled!\", urReplicaLatch\n-                .await(5, TimeUnit.SECONDS));\n+                .await(1, TimeUnit.SECONDS));\n \n         // enabling ledger replication\n         urLedgerMgr.enableLedgerReplication();\n@@ -345,12 +344,25 @@ private LedgerHandle createAndAddEntriesToLedger() throws BKException,\n \n     private void addEntry(int numEntriesToWrite, LedgerHandle lh)\n             throws InterruptedException, BKException {\n+        final CountDownLatch completeLatch = new CountDownLatch(numEntriesToWrite);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+\n         for (int i = 0; i < numEntriesToWrite; i++) {\n             ByteBuffer entry = ByteBuffer.allocate(4);\n             entry.putInt(rng.nextInt(Integer.MAX_VALUE));\n             entry.position(0);\n-            lh.addEntry(entry.array());\n+            lh.asyncAddEntry(entry.array(), new AddCallback() {\n+                    public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n+                        rc.compareAndSet(BKException.Code.OK, rc2);\n+                        completeLatch.countDown();\n+                    }\n+                }, null);\n         }\n+        completeLatch.await();\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+\n     }\n \n     private Map<Long, String> getUrLedgerData(Set<Long> urLedgerList)"},{"sha":"554e21c53160806ae8aa15f2588f2145478e611f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","status":"modified","additions":23,"deletions":3,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorPeriodicCheckTest.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -27,6 +27,7 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.ArrayList;\n import java.util.LinkedList;\n import java.io.File;\n import java.io.FileOutputStream;\n@@ -39,6 +40,8 @@\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n@@ -66,7 +69,7 @@\n     private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n     private List<ZooKeeper> zkClients = new LinkedList<ZooKeeper>();\n \n-    private final static int CHECK_INTERVAL = 1000; // run every second\n+    private final static int CHECK_INTERVAL = 100; // run every 100ms\n \n     public AuditorPeriodicCheckTest() {\n         super(3);\n@@ -215,15 +218,32 @@ public void testPeriodicCheckWhenDisabled() throws Exception {\n         LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bsConfs.get(0), zkc);\n         final LedgerUnderreplicationManager underReplicationManager = mFactory.newLedgerUnderreplicationManager();\n         final int numLedgers = 100;\n+        final int numMsgs = 100;\n+        final CountDownLatch completeLatch = new CountDownLatch(numMsgs*numLedgers);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n \n+        List<LedgerHandle> lhs = new ArrayList<LedgerHandle>();\n         for (int i = 0; i < numLedgers; i++) {\n             LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, \"passwd\".getBytes());\n-\n+            lhs.add(lh);\n             for (int j = 0; j < 100; j++) {\n-                lh.addEntry(\"testdata\".getBytes());\n+                lh.asyncAddEntry(\"testdata\".getBytes(), new AddCallback() {\n+                        public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n+                            rc.compareAndSet(BKException.Code.OK, rc2);\n+                            completeLatch.countDown();\n+                        }\n+                    }, null);\n             }\n+        }\n+        completeLatch.await();\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+\n+        for (LedgerHandle lh : lhs) {\n             lh.close();\n         }\n+\n         underReplicationManager.disableLedgerReplication();\n \n         final AtomicInteger numReads = new AtomicInteger(0);"},{"sha":"403f771a2cf46eb45f74f3c669934d1dcb6abe29","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -186,7 +186,7 @@ public void testBasicInteraction() throws Exception {\n \n         Future<Long> f = getLedgerToReplicate(m);\n         try {\n-            f.get(5, TimeUnit.SECONDS);\n+            f.get(1, TimeUnit.SECONDS);\n             fail(\"Shouldn't be able to find a ledger to replicate\");\n         } catch (TimeoutException te) {\n             // correct behaviour\n@@ -218,7 +218,7 @@ public void testLocking() throws Exception {\n \n         f = getLedgerToReplicate(m2);\n         try {\n-            f.get(5, TimeUnit.SECONDS);\n+            f.get(1, TimeUnit.SECONDS);\n             fail(\"Shouldn't be able to find a ledger to replicate\");\n         } catch (TimeoutException te) {\n             // correct behaviour\n@@ -264,7 +264,7 @@ public void testMarkingAsReplicated() throws Exception {\n \n         Future<Long> f = getLedgerToReplicate(m2);\n         try {\n-            f.get(5, TimeUnit.SECONDS);\n+            f.get(1, TimeUnit.SECONDS);\n             fail(\"Shouldn't be able to find a ledger to replicate\");\n         } catch (TimeoutException te) {\n             // correct behaviour\n@@ -308,7 +308,7 @@ public void testRelease() throws Exception {\n \n         Future<Long> f = getLedgerToReplicate(m2);\n         try {\n-            f.get(5, TimeUnit.SECONDS);\n+            f.get(1, TimeUnit.SECONDS);\n             fail(\"Shouldn't be able to find a ledger to replicate\");\n         } catch (TimeoutException te) {\n             // correct behaviour\n@@ -388,7 +388,7 @@ public void test2reportSame() throws Exception {\n \n         Future<Long> f = getLedgerToReplicate(m2);\n         try {\n-            f.get(5, TimeUnit.SECONDS);\n+            f.get(1, TimeUnit.SECONDS);\n             fail(\"Shouldn't be able to find a ledger to replicate\");\n         } catch (TimeoutException te) {\n             // correct behaviour\n@@ -506,7 +506,7 @@ public void testDisableLedegerReplication() throws Exception {\n \n         Future<Long> fA = getLedgerToReplicate(replicaMgr);\n         try {\n-            fA.get(5, TimeUnit.SECONDS);\n+            fA.get(1, TimeUnit.SECONDS);\n             fail(\"Shouldn't be able to find a ledger to replicate\");\n         } catch (TimeoutException te) {\n             // expected behaviour, as the replication is disabled\n@@ -522,7 +522,7 @@ public void testDisableLedegerReplication() throws Exception {\n      * should continue getLedgerToRereplicate() task\n      */\n     @Test(timeout = 20000)\n-    public void testEnableLedegerReplication() throws Exception {\n+    public void testEnableLedgerReplication() throws Exception {\n         isLedgerReplicationDisabled = true;\n         final LedgerUnderreplicationManager replicaMgr = lmf1\n                 .newLedgerUnderreplicationManager();\n@@ -574,7 +574,7 @@ public void run() {\n         thread1.start();\n \n         try {\n-            znodeLatch.await(5, TimeUnit.SECONDS);\n+            assertFalse(\"shouldn't complete\", znodeLatch.await(1, TimeUnit.SECONDS));\n             assertTrue(\"Ledger replication is not disabled!\",\n                     isLedgerReplicationDisabled);\n             assertEquals(\"Failed to disable ledger replication!\", 2, znodeLatch\n@@ -645,7 +645,7 @@ public void testHierarchyCleanupInterference() throws Exception {\n         final LedgerUnderreplicationManager replicaMgr2 = lmf2\n             .newLedgerUnderreplicationManager();\n \n-        final int iterations = 1000;\n+        final int iterations = 100;\n         final AtomicBoolean threadFailed = new AtomicBoolean(false);\n         Thread markUnder = new Thread() {\n                 public void run() {"},{"sha":"4884d5bd16c864cf522e57246a9be3c009d48fc2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -173,7 +173,7 @@ public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication()\n         try {\n             underReplicationManager.markLedgerUnderreplicated(lh.getId(),\n                     replicaToKill.toString());\n-            int counter = 100;\n+            int counter = 30;\n             while (counter-- > 0) {\n                 assertTrue(\"Expecting that replication should not complete\",\n                         ReplicationTestUtil.isLedgerInUnderReplication(zkc, lh\n@@ -398,6 +398,8 @@ public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsUR()\n                 .getLocalHost().getHostAddress(), startNewBookie);\n         LOG.info(\"New Bookie addr :\" + newBkAddr);\n \n+        // set to 3s instead of default 30s\n+        baseConf.setOpenLedgerRereplicationGracePeriod(\"3000\");\n         ReplicationWorker rw = new ReplicationWorker(zkc, baseConf, newBkAddr);\n \n         LedgerManagerFactory mFactory = LedgerManagerFactory"},{"sha":"f10172d9a8b21f5c06b3ac82b74b7dd7672db144","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","status":"modified","additions":22,"deletions":5,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -22,14 +22,17 @@\n  */\n import java.io.File;\n import java.util.Enumeration;\n-import java.util.List;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -48,7 +51,7 @@\n     DigestType digestType;\n \n     public BookieJournalRollingTest() {\n-        super(3);\n+        super(1);\n         this.digestType = DigestType.CRC32;\n     }\n \n@@ -75,7 +78,7 @@ public void tearDown() throws Exception {\n         LedgerHandle[] lhs = new LedgerHandle[numLedgers];\n         long[] ledgerIds = new long[numLedgers];\n         for (int i = 0; i < numLedgers; i++) {\n-            lhs[i] = bkc.createLedger(digestType, \"\".getBytes());\n+            lhs[i] = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n             ledgerIds[i] = lhs[i].getId();\n         }\n         writeLedgerEntries(lhs, msgSize, numMsgs);\n@@ -91,15 +94,27 @@ private void writeLedgerEntries(LedgerHandle[] lhs, int msgSize, int numMsgs) th\n         }\n         String msg = msgSB.toString();\n \n+        final CountDownLatch completeLatch = new CountDownLatch(numMsgs*lhs.length);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+\n         // Write all of the entries for all of the ledgers\n         for (int i = 0; i < numMsgs; i++) {\n             for (int j = 0; j < lhs.length; j++) {\n                 StringBuilder sb = new StringBuilder();\n                 sb.append(lhs[j].getId()).append('-').append(i).append('-')\n                   .append(msg);\n-                lhs[j].addEntry(sb.toString().getBytes());\n+                lhs[j].asyncAddEntry(sb.toString().getBytes(), new AddCallback() {\n+                        public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n+                            rc.compareAndSet(BKException.Code.OK, rc2);\n+                            completeLatch.countDown();\n+                        }\n+                    }, null);\n             }\n         }\n+        completeLatch.await();\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n     }\n \n     private void validLedgerEntries(long[] ledgerIds, int msgSize, int numMsgs) throws Exception {\n@@ -163,6 +178,7 @@ public void testJournalRolling() throws Exception {\n         long[] ledgerIds = new long[lhs.length];\n         for (int i=0; i<lhs.length; i++) {\n             ledgerIds[i] = lhs[i].getId();\n+            lhs[i].close();\n         }\n \n         // Sleep for a while to ensure data are flushed\n@@ -210,6 +226,7 @@ public void testJournalRollingWithoutSyncup() throws Exception {\n         long[] ledgerIds = new long[lhs.length];\n         for (int i=0; i<lhs.length; i++) {\n             ledgerIds[i] = lhs[i].getId();\n+            lhs[i].close();\n         }\n \n         // ledger indexes are not flushed"},{"sha":"0a3e4e6ae3a354be059b04db870d4b1c9d13e61d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":127,"deletions":95,"changes":222,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -34,6 +34,7 @@\n import java.util.Set;\n import java.util.Arrays;\n import java.util.concurrent.Semaphore;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n@@ -541,8 +542,20 @@ public void testReadWriteZero() throws IOException {\n             // bkc.initMessageDigest(\"SHA1\");\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n+            final CountDownLatch completeLatch = new CountDownLatch(numEntriesToWrite);\n+            final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+\n             for (int i = 0; i < numEntriesToWrite; i++) {\n-                lh.addEntry(new byte[0]);\n+                lh.asyncAddEntry(new byte[0], new AddCallback() {\n+                        public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {\n+                            rc.compareAndSet(BKException.Code.OK, rccb);\n+                            completeLatch.countDown();\n+                        }\n+                    }, null);\n+            }\n+            completeLatch.await();\n+            if (rc.get() != BKException.Code.OK) {\n+                throw BKException.create(rc.get());\n             }\n \n             /*\n@@ -587,11 +600,28 @@ public void testMultiLedger() throws IOException {\n             long ledgerId = lh.getId();\n             long ledgerId2 = lh2.getId();\n \n+            final CountDownLatch completeLatch = new CountDownLatch(numEntriesToWrite*2);\n+            final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+\n             // bkc.initMessageDigest(\"SHA1\");\n             LOG.info(\"Ledger ID 1: \" + lh.getId() + \", Ledger ID 2: \" + lh2.getId());\n             for (int i = 0; i < numEntriesToWrite; i++) {\n-                lh.addEntry(new byte[0]);\n-                lh2.addEntry(new byte[0]);\n+                lh.asyncAddEntry(new byte[0], new AddCallback() {\n+                        public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n+                            rc.compareAndSet(BKException.Code.OK, rc2);\n+                            completeLatch.countDown();\n+                        }\n+                    }, null);\n+                lh2.asyncAddEntry(new byte[0], new AddCallback() {\n+                        public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n+                            rc.compareAndSet(BKException.Code.OK, rc2);\n+                            completeLatch.countDown();\n+                        }\n+                    }, null);\n+            }\n+            completeLatch.await();\n+            if (rc.get() != BKException.Code.OK) {\n+                throw BKException.create(rc.get());\n             }\n \n             lh.close();\n@@ -684,49 +714,81 @@ public void testReadWriteAsyncLength() throws IOException {\n         }\n     }\n \n+    private long writeNEntriesLastWriteSync(LedgerHandle lh, int numToWrite) throws Exception {\n+        final CountDownLatch completeLatch = new CountDownLatch(numToWrite - 1);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+\n+        ByteBuffer entry = ByteBuffer.allocate(4);\n+        for (int i = 0; i < numToWrite - 1; i++) {\n+            entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries.add(entry.array());\n+            entriesSize.add(entry.array().length);\n+            lh.asyncAddEntry(entry.array(), new AddCallback() {\n+                    public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {\n+                        rc.compareAndSet(BKException.Code.OK, rccb);\n+                        completeLatch.countDown();\n+                    }\n+                }, null);\n+        }\n+        completeLatch.await();\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+\n+        entry = ByteBuffer.allocate(4);\n+        entry.putInt(rng.nextInt(maxInt));\n+        entry.position(0);\n+\n+        entries.add(entry.array());\n+        entriesSize.add(entry.array().length);\n+        lh.addEntry(entry.array());\n+        return lh.getLastAddConfirmed();\n+    }\n+\n     @Test(timeout=60000)\n-    public void testReadFromOpenLedger() throws IOException {\n+    public void testReadFromOpenLedger() throws Exception {\n         try {\n             // Create a ledger\n             lh = bkc.createLedger(digestType, ledgerPassword);\n             // bkc.initMessageDigest(\"SHA1\");\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n-            for (int i = 0; i < numEntriesToWrite; i++) {\n+\n+            long lac = writeNEntriesLastWriteSync(lh, numEntriesToWrite);\n+\n+            LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n+            // no recovery opened ledger 's last confirmed entry id is less than written\n+            // and it just can read until (i-1)\n+            long toRead = lac - 1;\n+\n+            Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n+            assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n+            LedgerEntry e = readEntry.nextElement();\n+            assertEquals(toRead, e.getEntryId());\n+            Assert.assertArrayEquals(entries.get((int)toRead), e.getEntry());\n+            // should not written to a read only ledger\n+            try {\n                 ByteBuffer entry = ByteBuffer.allocate(4);\n                 entry.putInt(rng.nextInt(maxInt));\n                 entry.position(0);\n \n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.addEntry(entry.array());\n-                if(i == numEntriesToWrite/2) {\n-                    LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n-                    // no recovery opened ledger 's last confirmed entry id is less than written\n-                    // and it just can read until (i-1)\n-                    int toRead = i - 1;\n-                    Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n-                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n-                    LedgerEntry e = readEntry.nextElement();\n-                    assertEquals(toRead, e.getEntryId());\n-                    Assert.assertArrayEquals(entries.get(toRead), e.getEntry());\n-                    // should not written to a read only ledger\n-                    try {\n-                        lhOpen.addEntry(entry.array());\n-                        fail(\"Should have thrown an exception here\");\n-                    } catch (BKException.BKIllegalOpException bkioe) {\n-                        // this is the correct response\n-                    } catch (Exception ex) {\n-                        LOG.error(\"Unexpected exception\", ex);\n-                        fail(\"Unexpected exception\");\n-                    }\n-                    // close read only ledger should not change metadata\n-                    lhOpen.close();\n-                }\n+                lhOpen.addEntry(entry.array());\n+                fail(\"Should have thrown an exception here\");\n+            } catch (BKException.BKIllegalOpException bkioe) {\n+                // this is the correct response\n+            } catch (Exception ex) {\n+                LOG.error(\"Unexpected exception\", ex);\n+                fail(\"Unexpected exception\");\n             }\n+            // close read only ledger should not change metadata\n+            lhOpen.close();\n \n-            long last = lh.readLastConfirmed();\n-            assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n+            lac = writeNEntriesLastWriteSync(lh, numEntriesToWrite);\n+\n+            assertEquals(\"Last confirmed add: \", lac, (numEntriesToWrite * 2) - 1);\n \n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n@@ -737,17 +799,8 @@ public void testReadFromOpenLedger() throws IOException {\n             lh = bkc.createLedger(digestType, ledgerPassword);\n             // bkc.initMessageDigest(\"SHA1\");\n             ledgerId = lh.getId();\n-            LOG.info(\"Ledger ID: \" + lh.getId());\n-            for (int i = 0; i < numEntriesToWrite; i++) {\n-                ByteBuffer entry = ByteBuffer.allocate(4);\n-                entry.putInt(rng.nextInt(maxInt));\n-                entry.position(0);\n-\n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.addEntry(entry.array());\n-            }\n \n+            writeNEntriesLastWriteSync(lh, numEntriesToWrite);\n \n             SyncObj sync = new SyncObj();\n             lh.asyncReadLastConfirmed(this, sync);\n@@ -761,7 +814,7 @@ public void testReadFromOpenLedger() throws IOException {\n                 assertEquals(\"Error reading\", BKException.Code.OK, sync.getReturnCode());\n             }\n \n-            assertTrue(\"Last confirmed add: \" + sync.lastConfirmed, sync.lastConfirmed == (numEntriesToWrite - 2));\n+            assertEquals(\"Last confirmed add\", sync.lastConfirmed, (numEntriesToWrite - 2));\n \n             LOG.debug(\"*** WRITE COMPLETE ***\");\n             // close ledger\n@@ -784,40 +837,36 @@ public void testReadFromOpenLedgerOpenOnce() throws Exception {\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n             LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n-            for (int i = 0; i < numEntriesToWrite; i++) {\n-                ByteBuffer entry = ByteBuffer.allocate(4);\n-                entry.putInt(rng.nextInt(maxInt));\n-                entry.position(0);\n+            writeNEntriesLastWriteSync(lh, numEntriesToWrite/2);\n \n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.addEntry(entry.array());\n-                if (i == numEntriesToWrite / 2) {\n-                    // no recovery opened ledger 's last confirmed entry id is\n-                    // less than written\n-                    // and it just can read until (i-1)\n-                    int toRead = i - 1;\n-\n-                    long readLastConfirmed = lhOpen.readLastConfirmed();\n-                    assertTrue(readLastConfirmed != 0);\n-                    Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n-                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n-                    LedgerEntry e = readEntry.nextElement();\n-                    assertEquals(toRead, e.getEntryId());\n-                    Assert.assertArrayEquals(entries.get(toRead), e.getEntry());\n-                    // should not written to a read only ledger\n-                    try {\n-                        lhOpen.addEntry(entry.array());\n-                        fail(\"Should have thrown an exception here\");\n-                    } catch (BKException.BKIllegalOpException bkioe) {\n-                        // this is the correct response\n-                    } catch (Exception ex) {\n-                        LOG.error(\"Unexpected exception\", ex);\n-                        fail(\"Unexpected exception\");\n-                    }\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n \n-                }\n+            // no recovery opened ledger 's last confirmed entry id is\n+            // less than written\n+            // and it just can read until (i-1)\n+            int toRead = numEntriesToWrite/2 - 2;\n+\n+            long readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(readLastConfirmed != 0);\n+            Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n+            assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n+            LedgerEntry e = readEntry.nextElement();\n+            assertEquals(toRead, e.getEntryId());\n+            Assert.assertArrayEquals(entries.get(toRead), e.getEntry());\n+            // should not written to a read only ledger\n+            try {\n+                lhOpen.addEntry(entry.array());\n+                fail(\"Should have thrown an exception here\");\n+            } catch (BKException.BKIllegalOpException bkioe) {\n+                // this is the correct response\n+            } catch (Exception ex) {\n+                LOG.error(\"Unexpected exception\", ex);\n+                fail(\"Unexpected exception\");\n             }\n+            writeNEntriesLastWriteSync(lh, numEntriesToWrite/2);\n+\n             long last = lh.readLastConfirmed();\n             assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n \n@@ -904,23 +953,15 @@ public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n \n \n     @Test(timeout=60000)\n-    public void testLastConfirmedAdd() throws IOException {\n+    public void testLastConfirmedAdd() throws Exception {\n         try {\n             // Create a ledger\n             lh = bkc.createLedger(digestType, ledgerPassword);\n             // bkc.initMessageDigest(\"SHA1\");\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n-            for (int i = 0; i < numEntriesToWrite; i++) {\n-                ByteBuffer entry = ByteBuffer.allocate(4);\n-                entry.putInt(rng.nextInt(maxInt));\n-                entry.position(0);\n-\n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.addEntry(entry.array());\n-            }\n \n+            writeNEntriesLastWriteSync(lh, numEntriesToWrite);\n             long last = lh.readLastConfirmed();\n             assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n \n@@ -934,16 +975,7 @@ public void testLastConfirmedAdd() throws IOException {\n             // bkc.initMessageDigest(\"SHA1\");\n             ledgerId = lh.getId();\n             LOG.info(\"Ledger ID: \" + lh.getId());\n-            for (int i = 0; i < numEntriesToWrite; i++) {\n-                ByteBuffer entry = ByteBuffer.allocate(4);\n-                entry.putInt(rng.nextInt(maxInt));\n-                entry.position(0);\n-\n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.addEntry(entry.array());\n-            }\n-\n+            writeNEntriesLastWriteSync(lh, numEntriesToWrite);\n \n             SyncObj sync = new SyncObj();\n             lh.asyncReadLastConfirmed(this, sync);"},{"sha":"7c3dd0b519c81eb6778bd8a44a50c3759fd0332d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","status":"modified","additions":18,"deletions":4,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ccc9545c4565c337ef6ea06004149de75b4dd3af/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java?ref=ccc9545c4565c337ef6ea06004149de75b4dd3af","patch":"@@ -22,7 +22,11 @@\n  */\n \n import java.io.File;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.util.TestUtils;\n import org.slf4j.Logger;\n@@ -39,7 +43,7 @@\n     DigestType digestType;\n \n     public LedgerDeleteTest(String ledgerManagerFactory) {\n-        super(3);\n+        super(1);\n         LOG.info(\"Running test case using ledger manager : \" + ledgerManagerFactory);\n         this.digestType = DigestType.CRC32;\n         // set ledger manager name\n@@ -63,7 +67,7 @@ public void setUp() throws Exception {\n         // Create the ledgers\n         LedgerHandle[] lhs = new LedgerHandle[numLedgers];\n         for (int i = 0; i < numLedgers; i++) {\n-            lhs[i] = bkc.createLedger(digestType, \"\".getBytes());\n+            lhs[i] = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n         }\n \n         // Create a dummy message string to write as ledger entries\n@@ -72,13 +76,23 @@ public void setUp() throws Exception {\n             msgSB.append(\"a\");\n         }\n         String msg = msgSB.toString();\n-\n+        final CountDownLatch completeLatch = new CountDownLatch(numMsgs*numLedgers);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n         // Write all of the entries for all of the ledgers\n         for (int i = 0; i < numMsgs; i++) {\n             for (int j = 0; j < numLedgers; j++) {\n-                lhs[j].addEntry(msg.getBytes());\n+                lhs[j].asyncAddEntry(msg.getBytes(), new AddCallback() {\n+                    public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {\n+                        rc.compareAndSet(BKException.Code.OK, rc2);\n+                        completeLatch.countDown();\n+                    }\n+                }, null);\n             }\n         }\n+        completeLatch.await();\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n \n         // Return the ledger handles to the inserted ledgers and entries\n         return lhs;"}]}

