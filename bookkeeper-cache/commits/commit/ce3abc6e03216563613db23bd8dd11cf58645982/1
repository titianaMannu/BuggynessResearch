{"sha":"ce3abc6e03216563613db23bd8dd11cf58645982","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjZTNhYmM2ZTAzMjE2NTYzNjEzZGIyM2JkOGRkMTFjZjU4NjQ1OTgy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-05-27T11:56:01Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-05-27T11:56:01Z"},"message":"BOOKKEEPER-756: Use HashedwheelTimer for request timeouts for PCBC (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1597752 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"54478650ccc7acd747f50d16d198ac1e5242dfe3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/54478650ccc7acd747f50d16d198ac1e5242dfe3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ce3abc6e03216563613db23bd8dd11cf58645982","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ce3abc6e03216563613db23bd8dd11cf58645982","html_url":"https://github.com/apache/bookkeeper/commit/ce3abc6e03216563613db23bd8dd11cf58645982","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ce3abc6e03216563613db23bd8dd11cf58645982/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d67f3a752d291b1f55e5b9597eca6b135d3626ee","url":"https://api.github.com/repos/apache/bookkeeper/commits/d67f3a752d291b1f55e5b9597eca6b135d3626ee","html_url":"https://github.com/apache/bookkeeper/commit/d67f3a752d291b1f55e5b9597eca6b135d3626ee"}],"stats":{"total":615,"additions":423,"deletions":192},"files":[{"sha":"160a87ebb8baf01b6f7146b5a2b5b0f1eb0c0834","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -192,6 +192,8 @@ Trunk (unreleased changes)\n \t\n \tBOOKKEEPER-750: Flake in BookieAutoRecoveryTest#testEmptyLedgerLosesQuorumEventually (ivank via fpj)\n \n+        BOOKKEEPER-756: Use HashedwheelTimer for request timeouts for PCBC (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"50d0d1c1889a1139496e1f249167407f4a81c2dd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":92,"deletions":5,"changes":97,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -48,12 +48,16 @@\n \n     // NIO Parameters\n     protected final static String CLIENT_TCP_NODELAY = \"clientTcpNoDelay\";\n+    protected final static String NUM_CHANNELS_PER_BOOKIE = \"numChannelsPerBookie\";\n+    // Read Parameters\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n     // Timeout Setting\n     protected final static String ADD_ENTRY_TIMEOUT_SEC = \"addEntryTimeoutSec\";\n     protected final static String READ_ENTRY_TIMEOUT_SEC = \"readEntryTimeoutSec\";\n     protected final static String TIMEOUT_TASK_INTERVAL_MILLIS = \"timeoutTaskIntervalMillis\";\n+    protected final static String PCBC_TIMEOUT_TIMER_TICK_DURATION_MS = \"pcbcTimeoutTimerTickDurationMs\";\n+    protected final static String PCBC_TIMEOUT_TIMER_NUM_TICKS = \"pcbcTimeoutTimerNumTicks\";\n \n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n@@ -92,7 +96,7 @@ public int getThrottleValue() {\n     /**\n      * Set throttle value.\n      *\n-     * Since BookKeeper process requests in asynchrous way, it will holds \n+     * Since BookKeeper process requests in asynchrous way, it will holds\n      * those pending request in queue. You may easily run it out of memory\n      * if producing too many requests than the capability of bookie servers can handle.\n      * To prevent that from happeding, you can set a throttle value here.\n@@ -179,7 +183,7 @@ public boolean getClientTcpNoDelay() {\n      *\n      * This settings is used to enabled/disabled Nagle's algorithm, which is a means of\n      * improving the efficiency of TCP/IP networks by reducing the number of packets\n-     * that need to be sent over the network. If you are sending many small messages, \n+     * that need to be sent over the network. If you are sending many small messages,\n      * such that more than one can fit in a single IP packet, setting client.tcpnodelay\n      * to false to enable Nagle algorithm can provide better performance.\n      * <br>\n@@ -194,6 +198,27 @@ public ClientConfiguration setClientTcpNoDelay(boolean noDelay) {\n         return this;\n     }\n \n+    /**\n+     * Get num channels per bookie.\n+     *\n+     * @return num channels per bookie.\n+     */\n+    public int getNumChannelsPerBookie() {\n+        return getInt(NUM_CHANNELS_PER_BOOKIE, 1);\n+    }\n+\n+    /**\n+     * Set num channels per bookie.\n+     *\n+     * @param numChannelsPerBookie\n+     *          num channels per bookie.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setNumChannelsPerBookie(int numChannelsPerBookie) {\n+        setProperty(NUM_CHANNELS_PER_BOOKIE, numChannelsPerBookie);\n+        return this;\n+    }\n+\n     /**\n      * Get zookeeper servers to connect\n      *\n@@ -247,7 +272,7 @@ public ClientConfiguration setZkTimeout(int zkTimeout) {\n      * The default is 5 seconds.\n      *\n      * @return the current read timeout in seconds\n-     * @deprecated use {@link getReadEntryTimeout()} or {@link getAddEntryTimeout()} instead\n+     * @deprecated use {@link #getReadEntryTimeout()} or {@link #getAddEntryTimeout()} instead\n      */\n     @Deprecated\n     public int getReadTimeout() {\n@@ -259,7 +284,7 @@ public int getReadTimeout() {\n      * @see #getReadTimeout()\n      * @param timeout The new read timeout in seconds\n      * @return client configuration\n-     * @deprecated use {@link setReadEntryTimeout(int)} or {@link setAddEntryTimeout(int)} instead\n+     * @deprecated use {@link #setReadEntryTimeout(int)} or {@link #setAddEntryTimeout(int)} instead\n      */\n     @Deprecated\n     public ClientConfiguration setReadTimeout(int timeout) {\n@@ -326,16 +351,78 @@ public ClientConfiguration setReadEntryTimeout(int timeout) {\n      * We do it more aggressive to not accumulate pending requests due to slow responses.\n      * @return\n      */\n+    @Deprecated\n     public long getTimeoutTaskIntervalMillis() {\n         return getLong(TIMEOUT_TASK_INTERVAL_MILLIS,\n-                TimeUnit.SECONDS.toMillis(Math.min(getAddEntryTimeout(), getReadEntryTimeout())));\n+                TimeUnit.SECONDS.toMillis(Math.min(getAddEntryTimeout(), getReadEntryTimeout())) / 2);\n     }\n \n+    @Deprecated\n     public ClientConfiguration setTimeoutTaskIntervalMillis(long timeoutMillis) {\n         setProperty(TIMEOUT_TASK_INTERVAL_MILLIS, Long.toString(timeoutMillis));\n         return this;\n     }\n \n+    /**\n+     * Get the tick duration in milliseconds that used for the\n+     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout\n+     * requests.\n+     *\n+     * @see org.jboss.netty.util.HashedWheelTimer\n+     *\n+     * @return tick duration in milliseconds\n+     */\n+    public long getPCBCTimeoutTimerTickDurationMs() {\n+        return getLong(PCBC_TIMEOUT_TIMER_TICK_DURATION_MS, 100);\n+    }\n+\n+    /**\n+     * Set the tick duration in milliseconds that used for\n+     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout\n+     * requests. Be aware of {@link org.jboss.netty.util.HashedWheelTimer} if you\n+     * are going to modify this setting.\n+     *\n+     * @see #getPCBCTimeoutTimerTickDurationMs()\n+     *\n+     * @param tickDuration\n+     *          tick duration in milliseconds.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setPCBCTimeoutTimerTickDurationMs(long tickDuration) {\n+        setProperty(PCBC_TIMEOUT_TIMER_TICK_DURATION_MS, tickDuration);\n+        return this;\n+    }\n+\n+    /**\n+     * Get number of ticks that used for\n+     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout\n+     * requests.\n+     *\n+     * @see org.jboss.netty.util.HashedWheelTimer\n+     *\n+     * @return number of ticks that used for timeout timer.\n+     */\n+    public int getPCBCTimeoutTimerNumTicks() {\n+        return getInt(PCBC_TIMEOUT_TIMER_NUM_TICKS, 1024);\n+    }\n+\n+    /**\n+     * Set number of ticks that used for\n+     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout request.\n+     * Be aware of {@link org.jboss.netty.util.HashedWheelTimer} if you are going to modify\n+     * this setting.\n+     *\n+     * @see #getPCBCTimeoutTimerNumTicks()\n+     *\n+     * @param numTicks\n+     *          number of ticks that used for timeout timer.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setPCBCTimeoutTimerNumTicks(int numTicks) {\n+        setProperty(PCBC_TIMEOUT_TIMER_NUM_TICKS, numTicks);\n+        return this;\n+    }\n+\n     /**\n      * Get the number of worker threads. This is the number of\n      * worker threads used by bookkeeper client to submit operations."},{"sha":"40c4ef31e4387b91c19fff0ea4d37f490e0e721c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -28,11 +28,10 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -47,31 +46,27 @@\n import org.jboss.netty.buffer.ChannelBuffers;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n /**\n  * Implements the client-side part of the BookKeeper protocol.\n  *\n  */\n-public class BookieClient {\n+public class BookieClient implements PerChannelBookieClientFactory {\n     static final Logger LOG = LoggerFactory.getLogger(BookieClient.class);\n \n-    // This is global state that should be across all BookieClients\n-    final AtomicLong totalBytesOutstanding = new AtomicLong();\n-\n     final OrderedSafeExecutor executor;\n     final ClientSocketChannelFactory channelFactory;\n-    final ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClient> channels =\n-        new ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClient>();\n-    final ScheduledExecutorService timeoutExecutor = Executors\n-            .newSingleThreadScheduledExecutor(new ThreadFactoryBuilder()\n-                    .setNameFormat(\"BKClient-TimeoutTaskExecutor-%d\").build());\n+    final ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClientPool> channels =\n+            new ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClientPool>();\n+    final HashedWheelTimer requestTimer;\n     private final ClientConfiguration conf;\n     private volatile boolean closed;\n     private final ReentrantReadWriteLock closeLock;\n     private final StatsLogger statsLogger;\n+    private final int numConnectionsPerBookie;\n \n     public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n         this(conf, channelFactory, executor, NullStatsLogger.INSTANCE);\n@@ -85,6 +80,11 @@ public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channel\n         this.closed = false;\n         this.closeLock = new ReentrantReadWriteLock();\n         this.statsLogger = statsLogger;\n+        this.numConnectionsPerBookie = conf.getNumChannelsPerBookie();\n+        this.requestTimer = new HashedWheelTimer(\n+                new ThreadFactoryBuilder().setNameFormat(\"BookieClientTimer-%d\").build(),\n+                conf.getPCBCTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n+                conf.getPCBCTimeoutTimerNumTicks());\n     }\n \n     private int getRc(int rc) {\n@@ -99,35 +99,43 @@ private int getRc(int rc) {\n         }\n     }\n \n-    private PerChannelBookieClient lookupClient(BookieSocketAddress addr) {\n-        PerChannelBookieClient channel = channels.get(addr);\n+    @Override\n+    public PerChannelBookieClient create(BookieSocketAddress address) {\n+        return new PerChannelBookieClient(conf, executor, channelFactory, address,\n+                                          requestTimer, statsLogger);\n+    }\n \n-        if (channel == null) {\n+    private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object key) {\n+        PerChannelBookieClientPool clientPool = channels.get(addr);\n+        if (null == clientPool) {\n             closeLock.readLock().lock();\n             try {\n                 if (closed) {\n                     return null;\n                 }\n-                channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding,\n-                        timeoutExecutor, statsLogger);\n-                PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n-                if (prevChannel != null) {\n-                    channel = prevChannel;\n+                PerChannelBookieClientPool newClientPool =\n+                        new DefaultPerChannelBookieClientPool(this, addr, numConnectionsPerBookie);\n+                PerChannelBookieClientPool oldClientPool = channels.putIfAbsent(addr, newClientPool);\n+                if (null == oldClientPool) {\n+                    clientPool = newClientPool;\n+                } else {\n+                    clientPool = oldClientPool;\n+                    newClientPool.close();\n                 }\n             } finally {\n                 closeLock.readLock().unlock();\n             }\n         }\n-\n-        return channel;\n+        return clientPool;\n     }\n \n     public void closeClients(Set<BookieSocketAddress> addrs) {\n         closeLock.readLock().lock();\n         try {\n-            final HashSet<PerChannelBookieClient> clients = new HashSet<PerChannelBookieClient>();\n+            final HashSet<PerChannelBookieClientPool> clients =\n+                    new HashSet<PerChannelBookieClientPool>();\n             for (BookieSocketAddress a : addrs) {\n-                PerChannelBookieClient c = channels.get(a);\n+                PerChannelBookieClientPool c = channels.get(a);\n                 if (c != null) {\n                     clients.add(c);\n                 }\n@@ -139,7 +147,7 @@ public void closeClients(Set<BookieSocketAddress> addrs) {\n             executor.submit(new SafeRunnable() {\n                     @Override\n                     public void safeRun() {\n-                        for (PerChannelBookieClient c : clients) {\n+                        for (PerChannelBookieClientPool c : clients) {\n                             c.disconnect();\n                         }\n                     }\n@@ -154,16 +162,16 @@ public void addEntry(final BookieSocketAddress addr, final long ledgerId, final\n             final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n         closeLock.readLock().lock();\n         try {\n-            final PerChannelBookieClient client = lookupClient(addr);\n+            final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n             if (client == null) {\n                 cb.writeComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n                                  ledgerId, entryId, addr, ctx);\n                 return;\n             }\n \n-            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n                 @Override\n-                public void operationComplete(final int rc, Void result) {\n+                public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                     if (rc != BKException.Code.OK) {\n                         try {\n                             executor.submitOrdered(ledgerId, new SafeRunnable() {\n@@ -178,7 +186,7 @@ public void safeRun() {\n                         }\n                         return;\n                     }\n-                    client.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n+                    pcbc.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n                 }\n             });\n         } finally {\n@@ -194,16 +202,16 @@ public void readEntryAndFenceLedger(final BookieSocketAddress addr,\n                                         final Object ctx) {\n         closeLock.readLock().lock();\n         try {\n-            final PerChannelBookieClient client = lookupClient(addr);\n+            final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n             if (client == null) {\n                 cb.readEntryComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n                                      ledgerId, entryId, null, ctx);\n                 return;\n             }\n \n-            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n                 @Override\n-                public void operationComplete(final int rc, Void result) {\n+                public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                     if (rc != BKException.Code.OK) {\n                         try {\n                             executor.submitOrdered(ledgerId, new SafeRunnable() {\n@@ -218,7 +226,7 @@ public void safeRun() {\n                         }\n                         return;\n                     }\n-                    client.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n+                    pcbc.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n                 }\n             });\n         } finally {\n@@ -230,16 +238,16 @@ public void readEntry(final BookieSocketAddress addr, final long ledgerId, final\n                           final ReadEntryCallback cb, final Object ctx) {\n         closeLock.readLock().lock();\n         try {\n-            final PerChannelBookieClient client = lookupClient(addr);\n+            final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n             if (client == null) {\n                 cb.readEntryComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n                                      ledgerId, entryId, null, ctx);\n                 return;\n             }\n \n-            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n                 @Override\n-                public void operationComplete(final int rc, Void result) {\n+                public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                     if (rc != BKException.Code.OK) {\n                         try {\n                             executor.submitOrdered(ledgerId, new SafeRunnable() {\n@@ -254,7 +262,7 @@ public void safeRun() {\n                         }\n                         return;\n                     }\n-                    client.readEntry(ledgerId, entryId, cb, ctx);\n+                    pcbc.readEntry(ledgerId, entryId, cb, ctx);\n                 }\n             });\n         } finally {\n@@ -270,23 +278,15 @@ public void close() {\n         closeLock.writeLock().lock();\n         try {\n             closed = true;\n-            for (PerChannelBookieClient channel: channels.values()) {\n-                channel.close();\n+            for (PerChannelBookieClientPool pool : channels.values()) {\n+                pool.close();\n             }\n             channels.clear();\n         } finally {\n             closeLock.writeLock().unlock();\n         }\n-        timeoutExecutor.shutdown();\n-        try {\n-            if (!timeoutExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n-                LOG.warn(\"BKClient-TimeoutTaskExecutor did not shutdown cleanly!\");\n-            }\n-        } catch (InterruptedException ie) {\n-            LOG.warn(\n-                    \"Interrupted when shutting down BKClient-TimeoutTaskExecutor\",\n-                    ie);\n-        }\n+        // Shut down the timeout executor.\n+        this.requestTimer.stop();\n     }\n \n     private static class Counter {"},{"sha":"a31b8c428a5eb4978ab108a18d3ea3dcbdb6235e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -0,0 +1,88 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ *  Provide a simple round-robin style channel pool. We could improve it later to do more\n+ *  fantastic things.\n+ */\n+class DefaultPerChannelBookieClientPool implements PerChannelBookieClientPool,\n+        GenericCallback<PerChannelBookieClient> {\n+\n+    static final Logger logger = LoggerFactory.getLogger(DefaultPerChannelBookieClientPool.class);\n+\n+    final PerChannelBookieClientFactory factory;\n+    final BookieSocketAddress address;\n+    final PerChannelBookieClient[] clients;\n+    final AtomicInteger counter = new AtomicInteger(0);\n+\n+    DefaultPerChannelBookieClientPool(PerChannelBookieClientFactory factory,\n+                                      BookieSocketAddress address,\n+                                      int coreSize) {\n+        Preconditions.checkArgument(coreSize > 0);\n+        this.factory = factory;\n+        this.address = address;\n+        this.clients = new PerChannelBookieClient[coreSize];\n+        for (int i = 0; i < coreSize; i++) {\n+            this.clients[i] = factory.create(address);\n+            // connect proactively\n+            this.clients[i].connectIfNeededAndDoOp(this);\n+        }\n+    }\n+\n+    @Override\n+    public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n+        // nop\n+    }\n+\n+    @Override\n+    public void obtain(GenericCallback<PerChannelBookieClient> callback) {\n+        if (1 == clients.length) {\n+            clients[0].connectIfNeededAndDoOp(callback);\n+            return;\n+        }\n+        int idx = MathUtils.signSafeMod(counter.getAndIncrement(), clients.length);\n+        clients[idx].connectIfNeededAndDoOp(callback);\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        for (PerChannelBookieClient pcbc : clients) {\n+            pcbc.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        for (PerChannelBookieClient pcbc : clients) {\n+            pcbc.close();\n+        }\n+    }\n+}"},{"sha":"34f20ba28ad129996bff6b376a593e3b87252fbc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":85,"deletions":106,"changes":191,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -22,9 +22,7 @@\n import java.util.ArrayDeque;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.apache.bookkeeper.client.BKException;\n@@ -59,6 +57,9 @@\n import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n import org.jboss.netty.handler.timeout.ReadTimeoutHandler;\n+import org.jboss.netty.util.HashedWheelTimer;\n+import org.jboss.netty.util.Timeout;\n+import org.jboss.netty.util.TimerTask;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -73,11 +74,12 @@\n \n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n \n-    BookieSocketAddress addr;\n-    AtomicLong totalBytesOutstanding;\n-    ClientSocketChannelFactory channelFactory;\n-    OrderedSafeExecutor executor;\n-    ScheduledExecutorService timeoutExecutor;\n+    final BookieSocketAddress addr;\n+    final ClientSocketChannelFactory channelFactory;\n+    final OrderedSafeExecutor executor;\n+    final HashedWheelTimer requestTimer;\n+    final int addEntryTimeout;\n+    final int readEntryTimeout;\n \n     ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n     ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n@@ -92,16 +94,10 @@\n      * The following member variables do not need to be concurrent, or volatile\n      * because they are always updated under a lock\n      */\n-    Queue<GenericCallback<Void>> pendingOps = new ArrayDeque<GenericCallback<Void>>();\n+    private volatile Queue<GenericCallback<PerChannelBookieClient>> pendingOps =\n+            new ArrayDeque<GenericCallback<PerChannelBookieClient>>();\n     volatile Channel channel = null;\n \n-    private class TimeoutTask implements Runnable {\n-        @Override\n-        public void run() {\n-            errorOutTimedOutEntries();\n-        }\n-    }\n-\n     enum ConnectionState {\n         DISCONNECTED, CONNECTING, CONNECTED, CLOSED\n     }\n@@ -110,66 +106,22 @@ public void run() {\n     final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n     private final ClientConfiguration conf;\n \n-    /**\n-     * Error out any entries that have timed out.\n-     */\n-    private void errorOutTimedOutEntries() {\n-        int numAdd = 0, numRead = 0;\n-        int total = 0;\n-        try {\n-            for (CompletionKey key : addCompletions.keySet()) {\n-                total++;\n-                long elapsedTime = key.elapsedTime();\n-                if (elapsedTime < conf.getAddEntryTimeout() * 1000) {\n-                    continue;\n-                }\n-                errorOutAddKey(key);\n-                numAdd++;\n-                addTimeoutOpLogger.registerSuccessfulEvent(elapsedTime);\n-            }\n-            for (CompletionKey key : readCompletions.keySet()) {\n-                total++;\n-                long elapsedTime = key.elapsedTime();\n-                if (elapsedTime < conf.getReadEntryTimeout() * 1000) {\n-                    continue;\n-                }\n-                errorOutReadKey(key);\n-                numRead++;\n-                readTimeoutOpLogger.registerSuccessfulEvent(elapsedTime);\n-            }\n-        } catch (Throwable t) {\n-            LOG.error(\"Caught RuntimeException while erroring out timed out entries : \", t);\n-        }\n-        if (numAdd + numRead > 0) {\n-            LOG.info(\"Timeout task iterated through a total of {} keys.\", total);\n-            LOG.info(\"Timeout Task errored out {} add entry requests.\", numAdd);\n-            LOG.info(\"Timeout Task errored out {} read entry requests.\", numRead);\n-        }\n-    }\n-\n-    public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n-                                  BookieSocketAddress addr, AtomicLong totalBytesOutstanding,\n-                                  ScheduledExecutorService timeoutExecutor) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, timeoutExecutor,\n-                NullStatsLogger.INSTANCE);\n-    }\n-\n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n-                                  BookieSocketAddress addr, AtomicLong totalBytesOutstanding) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, totalBytesOutstanding, null,\n-                NullStatsLogger.INSTANCE);\n+                                  BookieSocketAddress addr) {\n+        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n                                   ClientSocketChannelFactory channelFactory, BookieSocketAddress addr,\n-                                  AtomicLong totalBytesOutstanding, ScheduledExecutorService timeoutExecutor,\n-                                  StatsLogger parentStatsLogger) {\n+                                  HashedWheelTimer requestTimer, StatsLogger parentStatsLogger) {\n         this.conf = conf;\n         this.addr = addr;\n         this.executor = executor;\n-        this.totalBytesOutstanding = totalBytesOutstanding;\n         this.channelFactory = channelFactory;\n         this.state = ConnectionState.DISCONNECTED;\n+        this.requestTimer = requestTimer;\n+        this.addEntryTimeout = conf.getAddEntryTimeout();\n+        this.readEntryTimeout = conf.getReadEntryTimeout();\n \n         StringBuilder nameBuilder = new StringBuilder();\n         nameBuilder.append(addr.getHostname().replace('.', '_').replace('-', '_'))\n@@ -182,22 +134,15 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);\n         readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);\n         addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);\n-\n-        this.timeoutExecutor = timeoutExecutor;\n-        // scheudle the timeout task\n-        if (null != this.timeoutExecutor) {\n-            this.timeoutExecutor.scheduleWithFixedDelay(new TimeoutTask(), conf.getTimeoutTaskIntervalMillis(),\n-                    conf.getTimeoutTaskIntervalMillis(), TimeUnit.MILLISECONDS);\n-        }\n     }\n \n-    private void completeOperation(GenericCallback<Void> op, int rc) {\n+    private void completeOperation(GenericCallback<PerChannelBookieClient> op, int rc) {\n         closeLock.readLock().lock();\n         try {\n             if (ConnectionState.CLOSED == state) {\n-                op.operationComplete(BKException.Code.ClientClosedException, null);\n+                op.operationComplete(BKException.Code.ClientClosedException, this);\n             } else {\n-                op.operationComplete(rc, null);\n+                op.operationComplete(rc, this);\n             }\n         } finally {\n             closeLock.readLock().unlock();\n@@ -220,7 +165,7 @@ private void connect() {\n             public void operationComplete(ChannelFuture future) throws Exception {\n                 LOG.debug(\"Channel connected ({}) {}\", future.isSuccess(), future.getChannel());\n                 int rc;\n-                Queue<GenericCallback<Void>> oldPendingOps;\n+                Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;\n \n                 synchronized (PerChannelBookieClient.this) {\n                     if (future.isSuccess() && state == ConnectionState.CONNECTING) {\n@@ -257,17 +202,17 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     // emptying the pending ops by just assigning it to a new\n                     // list\n                     oldPendingOps = pendingOps;\n-                    pendingOps = new ArrayDeque<GenericCallback<Void>>();\n+                    pendingOps = new ArrayDeque<GenericCallback<PerChannelBookieClient>>();\n                 }\n \n-                for (GenericCallback<Void> pendingOp : oldPendingOps) {\n+                for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {\n                     completeOperation(pendingOp, rc);\n                 }\n             }\n         });\n     }\n \n-    void connectIfNeededAndDoOp(GenericCallback<Void> op) {\n+    void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n         boolean completeOpNow = false;\n         int opRc = BKException.Code.OK;\n         // common case without lock first\n@@ -335,8 +280,9 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n         BookieProtocol.AddRequest r = new BookieProtocol.AddRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n                 ledgerId, entryId, (short)options, masterKey, toSend);\n         final int entrySize = toSend.readableBytes();\n-        final CompletionKey completionKey = new CompletionKey(ledgerId, entryId);\n-        addCompletions.put(completionKey, new AddCompletion(addEntryOpLogger, cb, ctx));\n+        final CompletionKey completionKey = new CompletionKey(ledgerId, entryId, BookieProtocol.ADDENTRY);\n+        addCompletions.put(completionKey,\n+                new AddCompletion(addEntryOpLogger, cb, ctx, scheduleTimeout(completionKey, addEntryTimeout)));\n         final Channel c = channel;\n         if (c == null) {\n             errorOutAddKey(completionKey);\n@@ -371,8 +317,9 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n                                         final long entryId,\n                                         ReadEntryCallback cb, Object ctx) {\n-        final CompletionKey key = new CompletionKey(ledgerId, entryId);\n-        readCompletions.put(key, new ReadCompletion(readEntryOpLogger, cb, ctx));\n+        final CompletionKey key = new CompletionKey(ledgerId, entryId, BookieProtocol.READENTRY);\n+        readCompletions.put(key,\n+                new ReadCompletion(readEntryOpLogger, cb, ctx, scheduleTimeout(key, readEntryTimeout)));\n \n         final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n                 BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n@@ -410,8 +357,9 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n-        final CompletionKey key = new CompletionKey(ledgerId, entryId);\n-        readCompletions.put(key, new ReadCompletion(readEntryOpLogger, cb, ctx));\n+        final CompletionKey key = new CompletionKey(ledgerId, entryId, BookieProtocol.READENTRY);\n+        readCompletions.put(key,\n+                new ReadCompletion(readEntryOpLogger, cb, ctx, scheduleTimeout(key, readEntryTimeout)));\n \n         final BookieProtocol.ReadRequest r = new BookieProtocol.ReadRequest(\n                 BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n@@ -719,7 +667,7 @@ void handleAddResponse(BookieProtocol.AddResponse a) {\n \n         AddCompletion ac;\n         ac = addCompletions.remove(new CompletionKey(a.getLedgerId(),\n-                                                     a.getEntryId()));\n+                                                     a.getEntryId(), BookieProtocol.ADDENTRY));\n         if (ac == null) {\n             LOG.debug(\"Unexpected add response from bookie {} for {}\", addr, a);\n             return;\n@@ -758,7 +706,7 @@ void handleReadResponse(BookieProtocol.ReadResponse rr) {\n             break;\n         }\n \n-        CompletionKey key = new CompletionKey(rr.getLedgerId(), rr.getEntryId());\n+        CompletionKey key = new CompletionKey(rr.getLedgerId(), rr.getEntryId(), BookieProtocol.READENTRY);\n         ReadCompletion readCompletion = readCompletions.remove(key);\n \n         if (readCompletion == null) {\n@@ -769,7 +717,8 @@ void handleReadResponse(BookieProtocol.ReadResponse rr) {\n              */\n \n             readCompletion = readCompletions.remove(new CompletionKey(rr.getLedgerId(),\n-                                                                      BookieProtocol.LAST_ADD_CONFIRMED));\n+                                                                      BookieProtocol.LAST_ADD_CONFIRMED,\n+                                                                      BookieProtocol.READENTRY));\n         }\n \n         if (readCompletion == null) {\n@@ -789,9 +738,17 @@ void handleReadResponse(BookieProtocol.ReadResponse rr) {\n     // visible for testing\n     static abstract class CompletionValue {\n         final Object ctx;\n+        protected final Timeout timeout;\n \n-        public CompletionValue(Object ctx) {\n+        public CompletionValue(Object ctx, Timeout timeout) {\n             this.ctx = ctx;\n+            this.timeout = timeout;\n+        }\n+\n+        void cancelTimeout() {\n+            if (null != timeout) {\n+                timeout.cancel();\n+            }\n         }\n     }\n \n@@ -800,17 +757,18 @@ public CompletionValue(Object ctx) {\n         final ReadEntryCallback cb;\n \n         public ReadCompletion(ReadEntryCallback cb, Object ctx) {\n-            this(null, cb, ctx);\n+            this(null, cb, ctx, null);\n         }\n \n         public ReadCompletion(final OpStatsLogger readEntryOpLogger,\n                               final ReadEntryCallback originalCallback,\n-                              final Object originalCtx) {\n-            super(originalCtx);\n+                              final Object originalCtx, final Timeout timeout) {\n+            super(originalCtx, timeout);\n             final long requestTimeMillis = MathUtils.now();\n             this.cb = null == readEntryOpLogger ? originalCallback : new ReadEntryCallback() {\n                 @Override\n                 public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n+                    cancelTimeout();\n                     long latencyMillis = MathUtils.now() - requestTimeMillis;\n                     if (rc != BKException.Code.OK) {\n                         readEntryOpLogger.registerFailedEvent(latencyMillis);\n@@ -828,17 +786,19 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n         final WriteCallback cb;\n \n         public AddCompletion(WriteCallback cb, Object ctx) {\n-            this(null, cb, ctx);\n+            this(null, cb, ctx, null);\n         }\n \n         public AddCompletion(final OpStatsLogger addEntryOpLogger,\n                              final WriteCallback originalCallback,\n-                             final Object originalCtx) {\n-            super(originalCtx);\n+                             final Object originalCtx,\n+                             final Timeout timeout) {\n+            super(originalCtx, timeout);\n             final long requestTimeMillis = MathUtils.now();\n             this.cb = null == addEntryOpLogger ? originalCallback : new WriteCallback() {\n                 @Override\n                 public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n+                    cancelTimeout();\n                     long latencyMillis = MathUtils.now() - requestTimeMillis;\n                     if (rc != BKException.Code.OK) {\n                         addEntryOpLogger.registerFailedEvent(latencyMillis);\n@@ -852,20 +812,29 @@ public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddre\n     }\n \n     // visable for testing\n-    CompletionKey newCompletionKey(long ledgerId, long entryId) {\n-        return new CompletionKey(ledgerId, entryId);\n+    CompletionKey newCompletionKey(long ledgerId, long entryId, byte operationType) {\n+        return new CompletionKey(ledgerId, entryId, operationType);\n     }\n \n-    // visable for testing\n-    static class CompletionKey {\n-        long ledgerId;\n-        long entryId;\n+    Timeout scheduleTimeout(CompletionKey key, long timeout) {\n+        if (null != requestTimer) {\n+            return requestTimer.newTimeout(key, timeout, TimeUnit.SECONDS);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    class CompletionKey implements TimerTask {\n+        final long ledgerId;\n+        final long entryId;\n         final long requestAt;\n+        final byte operationType;\n \n-        CompletionKey(long ledgerId, long entryId) {\n+        CompletionKey(long ledgerId, long entryId, byte opType) {\n             this.ledgerId = ledgerId;\n             this.entryId = entryId;\n             this.requestAt = MathUtils.nowInNano();\n+            this.operationType = opType;\n         }\n \n         @Override\n@@ -887,12 +856,22 @@ public String toString() {\n             return String.format(\"LedgerEntry(%d, %d)\", ledgerId, entryId);\n         }\n \n-        public boolean shouldTimeout(long timeout) {\n-            return elapsedTime() >= timeout;\n+        private long elapsedTime() {\n+            return MathUtils.elapsedMSec(requestAt);\n         }\n \n-        public long elapsedTime() {\n-            return MathUtils.elapsedMSec(requestAt);\n+        @Override\n+        public void run(Timeout timeout) throws Exception {\n+            if (timeout.isCancelled()) {\n+                return;\n+            }\n+            if (BookieProtocol.ADDENTRY == operationType) {\n+                errorOutAddKey(this);\n+                addTimeoutOpLogger.registerSuccessfulEvent(elapsedTime());\n+            } else {\n+                errorOutReadKey(this);\n+                readTimeoutOpLogger.registerSuccessfulEvent(elapsedTime());\n+            }\n         }\n     }\n "},{"sha":"bd45e9209d6372d68794c59a637f36bc6c56892d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -0,0 +1,37 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+\n+/**\n+ * Factory to create {@link org.apache.bookkeeper.proto.PerChannelBookieClient}.\n+ */\n+interface PerChannelBookieClientFactory {\n+\n+    /**\n+     * Create a {@link org.apache.bookkeeper.proto.PerChannelBookieClient} to\n+     * <i>address</i>.\n+     *\n+     * @return the client connected to address.\n+     */\n+    PerChannelBookieClient create(BookieSocketAddress address);\n+}"},{"sha":"06818ccb69f0bd7211a7eb2e6891771fdd8b23e5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -0,0 +1,48 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+\n+/**\n+ * An interface to manage channel pooling for bookie client.\n+ */\n+interface PerChannelBookieClientPool {\n+\n+    /**\n+     * Obtain a channel from channel pool to execute operations.\n+     *\n+     * @param callback\n+     *          callback to return channel from channel pool.\n+     */\n+    void obtain(GenericCallback<PerChannelBookieClient> callback);\n+\n+    /**\n+     * Disconnect the connections in the pool.\n+     */\n+    void disconnect();\n+\n+    /**\n+     * Close the pool.\n+     */\n+    void close();\n+\n+}"},{"sha":"dec4d588f0c1a5c15d6a62fa6592746882f0e8bd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":13,"deletions":21,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -44,7 +44,6 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Tests for PerChannelBookieClient. Historically, this class has\n@@ -73,13 +72,11 @@ public void testConnectCloseRace() throws Exception {\n                 \"BKClientOrderedSafeExecutor\");\n \n         BookieSocketAddress addr = getBookie(0);\n-        AtomicLong bytesOutstanding = new AtomicLong(0);\n         for (int i = 0; i < 1000; i++) {\n-            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n-                                                                       addr, bytesOutstanding);\n-            client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n+            client.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>() {\n                     @Override\n-                    public void operationComplete(int rc, Void result) {\n+                    public void operationComplete(int rc, PerChannelBookieClient client) {\n                         // do nothing, we don't care about doing anything with the connection,\n                         // we just want to trigger it connecting.\n                     }\n@@ -97,9 +94,9 @@ public void operationComplete(int rc, Void result) {\n      */\n     @Test(timeout=60000)\n     public void testConnectRace() throws Exception {\n-        GenericCallback<Void> nullop = new GenericCallback<Void>() {\n+        GenericCallback<PerChannelBookieClient> nullop = new GenericCallback<PerChannelBookieClient>() {\n             @Override\n-            public void operationComplete(int rc, Void result) {\n+            public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n                 // do nothing, we don't care about doing anything with the connection,\n                 // we just want to trigger it connecting.\n             }\n@@ -111,10 +108,8 @@ public void operationComplete(int rc, Void result) {\n                 \"BKClientOrderedSafeExecutor\");\n \n         BookieSocketAddress addr = getBookie(0);\n-        AtomicLong bytesOutstanding = new AtomicLong(0);\n         for (int i = 0; i < 100; i++) {\n-            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n-                                                                       addr, bytesOutstanding);\n+            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n             for (int j = i; j < 10; j++) {\n                 client.connectIfNeededAndDoOp(nullop);\n             }\n@@ -132,9 +127,9 @@ public void operationComplete(int rc, Void result) {\n      */\n     @Test(timeout=60000)\n     public void testDisconnectRace() throws Exception {\n-        final GenericCallback<Void> nullop = new GenericCallback<Void>() {\n+        final GenericCallback<PerChannelBookieClient> nullop = new GenericCallback<PerChannelBookieClient>() {\n             @Override\n-            public void operationComplete(int rc, Void result) {\n+            public void operationComplete(int rc, PerChannelBookieClient client) {\n                 // do nothing, we don't care about doing anything with the connection,\n                 // we just want to trigger it connecting.\n             }\n@@ -147,10 +142,9 @@ public void operationComplete(int rc, Void result) {\n                 \"BKClientOrderedSafeExecutor\");\n         BookieSocketAddress addr = getBookie(0);\n \n-        AtomicLong bytesOutstanding = new AtomicLong(0);\n-        final PerChannelBookieClient client = new PerChannelBookieClient(executor,\n-                channelFactory, addr, bytesOutstanding);\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n         final AtomicBoolean shouldFail = new AtomicBoolean(false);\n+        final AtomicBoolean inconsistent = new AtomicBoolean(false);\n         final AtomicBoolean running = new AtomicBoolean(true);\n         final CountDownLatch disconnectRunning = new CountDownLatch(1);\n         Thread connectThread = new Thread() {\n@@ -245,10 +239,8 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n         final OrderedSafeExecutor executor = new OrderedSafeExecutor(1,\n                 \"BKClientOrderedSafeExecutor\");\n         BookieSocketAddress addr = getBookie(0);\n-        AtomicLong bytesOutstanding = new AtomicLong(0);\n \n-        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n-                                                                         addr, bytesOutstanding);\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr);\n         final CountDownLatch completion = new CountDownLatch(1);\n         final ReadEntryCallback cb = new ReadEntryCallback() {\n                 @Override\n@@ -258,9 +250,9 @@ public void readEntryComplete(int rc, long ledgerId, long entryId,\n                 }\n             };\n \n-        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+        client.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>() {\n             @Override\n-            public void operationComplete(final int rc, Void result) {\n+            public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                 if (rc != BKException.Code.OK) {\n                     executor.submitOrdered(1, new SafeRunnable() {\n                         @Override"},{"sha":"69729ccc95a34f73846f36b0bc9ae349cdaa85cf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","status":"modified","additions":9,"deletions":11,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","raw_url":"https://github.com/apache/bookkeeper/raw/ce3abc6e03216563613db23bd8dd11cf58645982/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java?ref=ce3abc6e03216563613db23bd8dd11cf58645982","patch":"@@ -27,7 +27,6 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -54,19 +53,18 @@ public void teardown() throws Exception {\n     }\n \n     private void testVersion(byte version, int expectedresult) throws Exception {\n-        PerChannelBookieClient bc = new PerChannelBookieClient(base.executor, base.channelFactory, \n-                new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), base.port),\n-                new AtomicLong(0));\n+        PerChannelBookieClient bc = new PerChannelBookieClient(base.executor, base.channelFactory,\n+                new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), base.port));\n         final AtomicInteger outerrc = new AtomicInteger(-1);\n         final CountDownLatch connectLatch = new CountDownLatch(1);\n-        bc.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n-                public void operationComplete(int rc, Void result) {\n+        bc.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>() {\n+                public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n                     outerrc.set(rc);\n                     connectLatch.countDown();\n                 }\n             });\n         connectLatch.await(5, TimeUnit.SECONDS);\n-        \n+\n         assertEquals(\"client not connected\", BKException.Code.OK, outerrc.get());\n         outerrc.set(-1000);\n         final CountDownLatch readLatch = new CountDownLatch(1);\n@@ -76,15 +74,15 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n                     readLatch.countDown();\n                 }\n             };\n-        bc.readCompletions.put(bc.newCompletionKey(1, 1),\n+        bc.readCompletions.put(bc.newCompletionKey(1, 1, BookieProtocol.READENTRY),\n                                new PerChannelBookieClient.ReadCompletion(cb, this));\n-        \n+\n         BookieProtocol.ReadRequest req = new BookieProtocol.ReadRequest(version, 1L, 1L, (short)0);\n-        \n+\n         bc.channel.write(req).awaitUninterruptibly();\n         readLatch.await(5, TimeUnit.SECONDS);\n         assertEquals(\"Expected result differs\", expectedresult, outerrc.get());\n-        \n+\n         bc.close();\n     }\n "}]}

