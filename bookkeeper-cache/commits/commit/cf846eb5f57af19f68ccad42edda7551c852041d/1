{"sha":"cf846eb5f57af19f68ccad42edda7551c852041d","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjZjg0NmViNWY1N2FmMTlmNjhjY2FkNDJlZGRhNzU1MWM4NTIwNDFk","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-17T11:16:26Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-17T11:16:26Z"},"message":"BOOKKEEPER-218: Provide journal manager to manage journal related operations (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1327045 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"11c27988bbab8bb6fe012065eedbc7dc6e384830","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/11c27988bbab8bb6fe012065eedbc7dc6e384830"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cf846eb5f57af19f68ccad42edda7551c852041d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cf846eb5f57af19f68ccad42edda7551c852041d","html_url":"https://github.com/apache/bookkeeper/commit/cf846eb5f57af19f68ccad42edda7551c852041d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cf846eb5f57af19f68ccad42edda7551c852041d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4a94ce1d8184f5f38def015d80777a8113b96690","url":"https://api.github.com/repos/apache/bookkeeper/commits/4a94ce1d8184f5f38def015d80777a8113b96690","html_url":"https://github.com/apache/bookkeeper/commit/4a94ce1d8184f5f38def015d80777a8113b96690"}],"stats":{"total":987,"additions":605,"deletions":382},"files":[{"sha":"d2a82669d4da32c115fecd90995b4b979b277b5f","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -130,6 +130,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-188: Garbage collection code is in the wrong place (ivank via sijie)\n \n+        BOOKKEEPER-218: Provide journal manager to manage journal related operations (sijie)\n+\n       hedwig-server/\n \n         BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)"},{"sha":"947ba6ab5d0a23f5efdedc4c627fc15df371a3f1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":43,"deletions":370,"changes":413,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -21,34 +21,25 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.io.BufferedReader;\n-import java.io.BufferedWriter;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n-import java.io.RandomAccessFile;\n import java.io.FilenameFilter;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.UnknownHostException;\n import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Map;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n-import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n@@ -70,21 +61,14 @@\n public class Bookie extends Thread {\n     static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n \n-    final static long MB = 1024 * 1024L;\n-    // max journal file size\n-    final long maxJournalSize;\n-    // number journal files kept before marked journal\n-    final int maxBackupJournals;\n-\n     final File journalDirectory;\n-\n     final File ledgerDirectories[];\n-\n     final ServerConfiguration conf;\n \n     final SyncThread syncThread;\n     final LedgerManager ledgerManager;\n     final LedgerStorage ledgerStorage;\n+    final Journal journal;\n     final HandleFactory handles;\n \n     static final long METAENTRY_ID_LEDGER_KEY = -0x1000;\n@@ -138,6 +122,15 @@ public long getEntry() {\n         }\n     }\n \n+    // Write Callback do nothing\n+    class NopWriteCallback implements WriteCallback {\n+        @Override\n+        public void writeComplete(int rc, long ledgerId, long entryId,\n+                                  InetSocketAddress addr, Object ctx) {\n+            LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n+                      new Object[] { entryId, ledgerId, addr, rc });\n+        }\n+    }\n \n     /**\n      * SyncThread is a background thread which flushes ledger index pages periodically.\n@@ -199,7 +192,8 @@ public void run() {\n                     break;\n                 }\n \n-                lastLogMark.markLog();\n+                // journal mark log\n+                journal.markLog();\n \n                 boolean flushFailed = false;\n                 try {\n@@ -212,35 +206,8 @@ public void run() {\n                 // if flush failed, we should not roll last mark, otherwise we would\n                 // have some ledgers are not flushed and their journal entries were lost\n                 if (!flushFailed) {\n-\n-                    lastLogMark.rollLog();\n-\n-                    // list the journals that have been marked\n-                    List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n-                        @Override\n-                        public boolean accept(long journalId) {\n-                            if (journalId < lastLogMark.lastMark.txnLogId) {\n-                                return true;\n-                            } else {\n-                                return false;\n-                            }\n-                        }\n-                    });\n-\n-                    // keep MAX_BACKUP_JOURNALS journal files before marked journal\n-                    if (logs.size() >= maxBackupJournals) {\n-                        int maxIdx = logs.size() - maxBackupJournals;\n-                        for (int i=0; i<maxIdx; i++) {\n-                            long id = logs.get(i);\n-                            // make sure the journal id is smaller than marked journal id\n-                            if (id < lastLogMark.lastMark.txnLogId) {\n-                                File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n-                                journalFile.delete();\n-                                LOG.info(\"garbage collected journal \" + journalFile.getName());\n-                            }\n-                        }\n-                    }\n-\n+                    journal.rollLog();\n+                    journal.gcJournals();\n                 }\n \n                 // clear flushing flag\n@@ -374,8 +341,6 @@ public Bookie(ServerConfiguration conf)\n         this.conf = conf;\n         this.journalDirectory = getCurrentDirectory(conf.getJournalDir());\n         this.ledgerDirectories = getCurrentDirectories(conf.getLedgerDirs());\n-        this.maxJournalSize = conf.getMaxJournalSize() * MB;\n-        this.maxBackupJournals = conf.getMaxBackupJournals();\n \n         // instantiate zookeeper client to initialize ledger manager\n         this.zk = instantiateZookeeperClient(conf);\n@@ -385,88 +350,32 @@ public Bookie(ServerConfiguration conf)\n \n         syncThread = new SyncThread(conf);\n         ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager);\n-\n         handles = new HandleFactoryImpl(ledgerStorage);\n+        // instantiate the journal\n+        journal = new Journal(conf);\n \n         // replay journals\n         readJournal();\n     }\n \n     private void readJournal() throws IOException, BookieException {\n-        lastLogMark.readLog();\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Last Log Mark : \" + lastLogMark);\n-        }\n-        final long markedLogId = lastLogMark.txnLogId;\n-        List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n+        journal.replay(new JournalScanner() {\n             @Override\n-            public boolean accept(long journalId) {\n-                if (journalId < markedLogId) {\n-                    return false;\n-                }\n-                return true;\n-            }\n-        });\n-        // last log mark may be missed due to no sync up before\n-        // validate filtered log ids only when we have markedLogId\n-        if (markedLogId > 0) {\n-            if (logs.size() == 0 || logs.get(0) != markedLogId) {\n-                throw new IOException(\"Recovery log \" + markedLogId + \" is missing\");\n-            }\n-        }\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Try to relay journal logs : \" + logs);\n-        }\n-        // TODO: When reading in the journal logs that need to be synced, we\n-        // should use BufferedChannels instead to minimize the amount of\n-        // system calls done.\n-        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-        ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n-        for(Long id: logs) {\n-            JournalChannel recLog;\n-            if(id == markedLogId) {\n-                long markedLogPosition = lastLogMark.txnLogPosition;\n-                recLog = new JournalChannel(journalDirectory, id, markedLogPosition);\n-            } else {\n-                recLog = new JournalChannel(journalDirectory, id);\n-            }\n-\n-            while(true) {\n-                lenBuff.clear();\n-                fullRead(recLog, lenBuff);\n-                if (lenBuff.remaining() != 0) {\n-                    break;\n-                }\n-                lenBuff.flip();\n-                int len = lenBuff.getInt();\n-                if (len == 0) {\n-                    break;\n-                }\n-                recBuff.clear();\n-                if (recBuff.remaining() < len) {\n-                    recBuff = ByteBuffer.allocate(len);\n-                }\n-                recBuff.limit(len);\n-                if (fullRead(recLog, recBuff) != len) {\n-                    // This seems scary, but it just means that this is where we\n-                    // left off writing\n-                    break;\n-                }\n-                recBuff.flip();\n+            public void process(int journalVersion, long offset, ByteBuffer recBuff) throws IOException {\n                 long ledgerId = recBuff.getLong();\n                 long entryId = recBuff.getLong();\n                 try {\n                     LOG.debug(\"Replay journal - ledger id : {}, entry id : {}.\", ledgerId, entryId);\n                     if (entryId == METAENTRY_ID_LEDGER_KEY) {\n-                        if (recLog.getFormatVersion() >= 3) {\n+                        if (journalVersion >= 3) {\n                             int masterKeyLen = recBuff.getInt();\n                             byte[] masterKey = new byte[masterKeyLen];\n \n                             recBuff.get(masterKey);\n                             masterKeyCache.put(ledgerId, masterKey);\n                         } else {\n                             throw new IOException(\"Invalid journal. Contains journalKey \"\n-                                    + \" but layout version (\" + recLog.getFormatVersion()\n+                                    + \" but layout version (\" + journalVersion\n                                     + \") is too old to hold this\");\n                         }\n                     } else {\n@@ -481,16 +390,17 @@ public boolean accept(long journalId) {\n                     }\n                 } catch (NoLedgerException nsle) {\n                     LOG.debug(\"Skip replaying entries of ledger {} since it was deleted.\", ledgerId);\n-                    continue;\n+                } catch (BookieException be) {\n+                    throw new IOException(be);\n                 }\n             }\n-            recLog.close();\n-        }\n+        });\n     }\n \n     synchronized public void start() {\n         setDaemon(true);\n         LOG.debug(\"I'm starting a bookie with journal directory \" + journalDirectory.getName());\n+        // start bookie thread\n         super.start();\n         syncThread.start();\n \n@@ -507,39 +417,6 @@ synchronized public void start() {\n         }\n     }\n \n-    public static interface JournalIdFilter {\n-        public boolean accept(long journalId);\n-    }\n-\n-    /**\n-     * List all journal ids by a specified journal id filer\n-     *\n-     * @param journalDir journal dir\n-     * @param filter journal id filter\n-     * @return list of filtered ids\n-     */\n-    public static List<Long> listJournalIds(File journalDir, JournalIdFilter filter) {\n-        File logFiles[] = journalDir.listFiles();\n-        List<Long> logs = new ArrayList<Long>();\n-        for(File f: logFiles) {\n-            String name = f.getName();\n-            if (!name.endsWith(\".txn\")) {\n-                continue;\n-            }\n-            String idString = name.split(\"\\\\.\")[0];\n-            long id = Long.parseLong(idString, 16);\n-            if (filter != null) {\n-                if (filter.accept(id)) {\n-                    logs.add(id);\n-                }\n-            } else {\n-                logs.add(id);\n-            }\n-        }\n-        Collections.sort(logs);\n-        return logs;\n-    }\n-\n     /**\n      * Register jmx with parent\n      *\n@@ -670,224 +547,27 @@ public void process(WatchedEvent event) {\n         return newZk;\n     }\n \n-    private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException {\n-        int total = 0;\n-        while(bb.remaining() > 0) {\n-            int rc = fc.read(bb);\n-            if (rc <= 0) {\n-                return total;\n-            }\n-            total += rc;\n-        }\n-        return total;\n-    }\n-\n-    static class QueueEntry {\n-        QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n-                   WriteCallback cb, Object ctx) {\n-            this.entry = entry.duplicate();\n-            this.cb = cb;\n-            this.ctx = ctx;\n-            this.ledgerId = ledgerId;\n-            this.entryId = entryId;\n-        }\n-\n-        ByteBuffer entry;\n-\n-        long ledgerId;\n-\n-        long entryId;\n-\n-        WriteCallback cb;\n-\n-        Object ctx;\n-    }\n-\n-    LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n-\n-    class LastLogMark {\n-        long txnLogId;\n-        long txnLogPosition;\n-        LastLogMark lastMark;\n-        LastLogMark(long logId, long logPosition) {\n-            this.txnLogId = logId;\n-            this.txnLogPosition = logPosition;\n-        }\n-        synchronized void setLastLogMark(long logId, long logPosition) {\n-            txnLogId = logId;\n-            txnLogPosition = logPosition;\n-        }\n-        synchronized void markLog() {\n-            lastMark = new LastLogMark(txnLogId, txnLogPosition);\n-        }\n-        synchronized void rollLog() {\n-            byte buff[] = new byte[16];\n-            ByteBuffer bb = ByteBuffer.wrap(buff);\n-            // we should record <logId, logPosition> marked in markLog\n-            // which is safe since records before lastMark have been\n-            // persisted to disk (both index & entry logger)\n-            bb.putLong(lastMark.txnLogId);\n-            bb.putLong(lastMark.txnLogPosition);\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"RollLog to persist last marked log : \" + lastMark);\n-            }\n-            for(File dir: ledgerDirectories) {\n-                File file = new File(dir, \"lastMark\");\n-                try {\n-                    FileOutputStream fos = new FileOutputStream(file);\n-                    fos.write(buff);\n-                    fos.getChannel().force(true);\n-                    fos.close();\n-                } catch (IOException e) {\n-                    LOG.error(\"Problems writing to \" + file, e);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Read last mark from lastMark file.\n-         * The last mark should first be max journal log id,\n-         * and then max log position in max journal log.\n-         */\n-        synchronized void readLog() {\n-            byte buff[] = new byte[16];\n-            ByteBuffer bb = ByteBuffer.wrap(buff);\n-            for(File dir: ledgerDirectories) {\n-                File file = new File(dir, \"lastMark\");\n-                try {\n-                    FileInputStream fis = new FileInputStream(file);\n-                    fis.read(buff);\n-                    fis.close();\n-                    bb.clear();\n-                    long i = bb.getLong();\n-                    long p = bb.getLong();\n-                    if (i > txnLogId) {\n-                        txnLogId = i;\n-                        if(p > txnLogPosition) {\n-                          txnLogPosition = p;\n-                        }\n-                    }\n-                } catch (IOException e) {\n-                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            \n-            sb.append(\"LastMark: logId - \").append(txnLogId)\n-              .append(\" , position - \").append(txnLogPosition);\n-            \n-            return sb.toString();\n-        }\n-    }\n-\n-    private LastLogMark lastLogMark = new LastLogMark(0, 0);\n-\n-    LastLogMark getLastLogMark() {\n-        return lastLogMark;\n-    }\n-\n     public boolean isRunning() {\n         return running;\n     }\n \n-    /**\n-     * A thread used for persisting journal entries to journal files.\n-     * \n-     * <p>\n-     * Besides persisting journal entries, it also takes responsibility of\n-     * rolling journal files when a journal file reaches journal file size\n-     * limitation.\n-     * </p>\n-     * <p>\n-     * During journal rolling, it first closes the writing journal, generates\n-     * new journal file using current timestamp, and continue persistence logic.\n-     * Those journals will be garbage collected in SyncThread.\n-     * </p>\n-     */\n     @Override\n     public void run() {\n-        LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n-        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+        // bookie thread wait for journal thread\n         try {\n-            long logId = 0;\n-            JournalChannel logFile = null;\n-            BufferedChannel bc = null;\n-            long nextPrealloc = 0;\n-            long lastFlushPosition = 0;\n-\n-            QueueEntry qe = null;\n-            while (true) {\n-                // new journal file to write\n-                if (null == logFile) {\n-                    logId = System.currentTimeMillis();\n-                    logFile = new JournalChannel(journalDirectory, logId);\n-                    bc = logFile.getBufferedChannel();\n-\n-                    lastFlushPosition = 0;\n-                }\n-\n-                if (qe == null) {\n-                    if (toFlush.isEmpty()) {\n-                        qe = queue.take();\n-                    } else {\n-                        qe = queue.poll();\n-                        if (qe == null || bc.position() > lastFlushPosition + 512*1024) {\n-                            //logFile.force(false);\n-                            bc.flush(true);\n-                            lastFlushPosition = bc.position();\n-                            lastLogMark.setLastLogMark(logId, lastFlushPosition);\n-                            for (QueueEntry e : toFlush) {\n-                                e.cb.writeComplete(0, e.ledgerId, e.entryId, null, e.ctx);\n-                            }\n-                            toFlush.clear();\n-\n-                            // check whether journal file is over file limit\n-                            if (bc.position() > maxJournalSize) {\n-                                logFile.close();\n-                                logFile = null;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (isZkExpired) {\n-                    LOG.warn(\"Exiting... zk client has expired.\");\n-                    break;\n-                }\n-                if (qe == null) { // no more queue entry\n-                    continue;\n-                }\n-                lenBuff.clear();\n-                lenBuff.putInt(qe.entry.remaining());\n-                lenBuff.flip();\n-                //\n-                // we should be doing the following, but then we run out of\n-                // direct byte buffers\n-                // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n-                bc.write(lenBuff);\n-                bc.write(qe.entry);\n-\n-                logFile.preAllocIfNeeded();\n-\n-                toFlush.add(qe);\n-                qe = null;\n-            }\n-        } catch (Exception e) {\n-            // if the bookie thread quits due to shutting down, it is ok\n-            if (shuttingdown) {\n-                LOG.warn(\"Bookie thread exits when shutting down\", e);\n-            } else {\n-                // some error found in bookie thread and it quits\n-                // following add operations to it would hang unit client timeout\n-                // so we should let bookie server exists\n-                LOG.error(\"Exception occurred in bookie thread and it quits : \", e);\n-                shutdown(ExitCode.BOOKIE_EXCEPTION);\n-            }\n+            // start journal\n+            journal.start();\n+            // wait until journal quits\n+            journal.join();\n+        } catch (InterruptedException ie) {\n+        }\n+        // if the journal thread quits due to shutting down, it is ok\n+        if (!shuttingdown) {\n+            // some error found in journal thread and it quits\n+            // following add operations to it would hang unit client timeout\n+            // so we should let bookie server exists\n+            LOG.error(\"Journal manager quits unexpectedly.\");\n+            shutdown(ExitCode.BOOKIE_EXCEPTION);\n         }\n     }\n \n@@ -912,7 +592,8 @@ synchronized int shutdown(int exitCode) {\n \n                 // Shutdown the ZK client\n                 if(zk != null) zk.close();\n-                this.interrupt();\n+                // Shutdown journal\n+                journal.shutdown();\n                 this.join();\n                 syncThread.shutdown();\n \n@@ -947,15 +628,7 @@ private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey)\n             bb.put(masterKey);\n             bb.flip();\n \n-            queue.add(new QueueEntry(bb,\n-                                     ledgerId, METAENTRY_ID_LEDGER_KEY,\n-                                     new WriteCallback() {\n-                                         public void writeComplete(int rc, long ledgerId, \n-                                                 long entryId, InetSocketAddress addr,\n-                                                 Object ctx) {\n-                                             // do nothing\n-                                         }\n-                                     }, null));\n+            journal.logAddEntry(bb, new NopWriteCallback(), null);\n             masterKeyCache.put(ledgerId, masterKey);\n         }\n         return l;\n@@ -981,7 +654,7 @@ private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCa\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Adding \" + entryId + \"@\" + ledgerId);\n         }\n-        queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n+        journal.logAddEntry(entry, cb, ctx);\n     }\n \n     /**"},{"sha":"9ad7c9c123863555a6cfcaf1566d95d50c78c591","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -20,7 +20,6 @@\n \n import java.io.File;\n \n-import org.apache.bookkeeper.bookie.Bookie.LastLogMark;\n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n \n /**\n@@ -46,7 +45,7 @@ public boolean isHidden() {\n \n     @Override\n     public int getQueueLength() {\n-        return bk.queue.size();\n+        return bk.journal.getJournalQueueLength();\n     }\n \n }"},{"sha":"24f299cc5ca38db1df20917e371517b646107deb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -20,8 +20,6 @@\n \n import java.io.File;\n \n-import org.apache.bookkeeper.bookie.Bookie.LastLogMark;\n-\n /**\n  * Bookie MBean\n  */"},{"sha":"65d6947e6238586b897553e9fef5f0f4bc83b6b8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"added","additions":550,"deletions":0,"changes":550,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -0,0 +1,550 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provide journal related management.\n+ */\n+class Journal extends Thread {\n+\n+    static Logger LOG = LoggerFactory.getLogger(Journal.class);\n+\n+    /**\n+     * Filter to pickup journals\n+     */\n+    private static interface JournalIdFilter {\n+        public boolean accept(long journalId);\n+    }\n+\n+    /**\n+     * List all journal ids by a specified journal id filer\n+     *\n+     * @param journalDir journal dir\n+     * @param filter journal id filter\n+     * @return list of filtered ids\n+     */\n+    private static List<Long> listJournalIds(File journalDir, JournalIdFilter filter) {\n+        File logFiles[] = journalDir.listFiles();\n+        List<Long> logs = new ArrayList<Long>();\n+        for(File f: logFiles) {\n+            String name = f.getName();\n+            if (!name.endsWith(\".txn\")) {\n+                continue;\n+            }\n+            String idString = name.split(\"\\\\.\")[0];\n+            long id = Long.parseLong(idString, 16);\n+            if (filter != null) {\n+                if (filter.accept(id)) {\n+                    logs.add(id);\n+                }\n+            } else {\n+                logs.add(id);\n+            }\n+        }\n+        Collections.sort(logs);\n+        return logs;\n+    }\n+\n+    /**\n+     * Last Log Mark\n+     */\n+    class LastLogMark {\n+        long txnLogId;\n+        long txnLogPosition;\n+        LastLogMark lastMark;\n+        LastLogMark(long logId, long logPosition) {\n+            this.txnLogId = logId;\n+            this.txnLogPosition = logPosition;\n+        }\n+        synchronized void setLastLogMark(long logId, long logPosition) {\n+            txnLogId = logId;\n+            txnLogPosition = logPosition;\n+        }\n+        synchronized void markLog() {\n+            lastMark = new LastLogMark(txnLogId, txnLogPosition);\n+        }\n+        synchronized void rollLog() {\n+            byte buff[] = new byte[16];\n+            ByteBuffer bb = ByteBuffer.wrap(buff);\n+            // we should record <logId, logPosition> marked in markLog\n+            // which is safe since records before lastMark have been\n+            // persisted to disk (both index & entry logger)\n+            bb.putLong(lastMark.txnLogId);\n+            bb.putLong(lastMark.txnLogPosition);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"RollLog to persist last marked log : \" + lastMark);\n+            }\n+            for(File dir: ledgerDirectories) {\n+                File file = new File(dir, \"lastMark\");\n+                try {\n+                    FileOutputStream fos = new FileOutputStream(file);\n+                    fos.write(buff);\n+                    fos.getChannel().force(true);\n+                    fos.close();\n+                } catch (IOException e) {\n+                    LOG.error(\"Problems writing to \" + file, e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Read last mark from lastMark file.\n+         * The last mark should first be max journal log id,\n+         * and then max log position in max journal log.\n+         */\n+        synchronized void readLog() {\n+            byte buff[] = new byte[16];\n+            ByteBuffer bb = ByteBuffer.wrap(buff);\n+            for(File dir: ledgerDirectories) {\n+                File file = new File(dir, \"lastMark\");\n+                try {\n+                    FileInputStream fis = new FileInputStream(file);\n+                    fis.read(buff);\n+                    fis.close();\n+                    bb.clear();\n+                    long i = bb.getLong();\n+                    long p = bb.getLong();\n+                    if (i > txnLogId) {\n+                        txnLogId = i;\n+                        if(p > txnLogPosition) {\n+                          txnLogPosition = p;\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+\n+            sb.append(\"LastMark: logId - \").append(txnLogId)\n+              .append(\" , position - \").append(txnLogPosition);\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    /**\n+     * Filter to return list of journals for rolling\n+     */\n+    private class JournalRollingFilter implements JournalIdFilter {\n+        @Override\n+        public boolean accept(long journalId) {\n+            if (journalId < lastLogMark.lastMark.txnLogId) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Scanner used to scan a journal\n+     */\n+    public static interface JournalScanner {\n+        /**\n+         * Process a journal entry.\n+         *\n+         * @param journalVersion\n+         *          Journal Version\n+         * @param offset\n+         *          File offset of the journal entry\n+         * @param entry\n+         *          Journal Entry\n+         * @throws IOException\n+         */\n+        public void process(int journalVersion, long offset, ByteBuffer entry) throws IOException;\n+    }\n+\n+    /**\n+     * Journal Entry to Record\n+     */\n+    private static class QueueEntry {\n+        QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n+                   WriteCallback cb, Object ctx) {\n+            this.entry = entry.duplicate();\n+            this.cb = cb;\n+            this.ctx = ctx;\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+        }\n+\n+        ByteBuffer entry;\n+\n+        long ledgerId;\n+\n+        long entryId;\n+\n+        WriteCallback cb;\n+\n+        Object ctx;\n+    }\n+\n+    final static long MB = 1024 * 1024L;\n+    // max journal file size\n+    final long maxJournalSize;\n+    // number journal files kept before marked journal\n+    final int maxBackupJournals;\n+\n+    final File journalDirectory;\n+    final File ledgerDirectories[];\n+    final ServerConfiguration conf;\n+\n+    private LastLogMark lastLogMark = new LastLogMark(0, 0);\n+\n+    // journal entry queue to commit\n+    LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n+\n+    volatile boolean running = true;\n+\n+    public Journal(ServerConfiguration conf) {\n+        super(\"BookieJournal-\" + conf.getBookiePort());\n+        this.conf = conf;\n+        this.journalDirectory = Bookie.getCurrentDirectory(conf.getJournalDir());\n+        this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n+        this.maxJournalSize = conf.getMaxJournalSize() * MB;\n+        this.maxBackupJournals = conf.getMaxBackupJournals();\n+\n+        // read last log mark\n+        lastLogMark.readLog();\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Last Log Mark : \" + lastLogMark);\n+        }\n+    }\n+\n+    LastLogMark getLastLogMark() {\n+        return lastLogMark;\n+    }\n+\n+    /**\n+     * Records a <i>LastLogMark</i> in memory.\n+     *\n+     * <p>\n+     * The <i>LastLogMark</i> contains two parts: first one is <i>txnLogId</i>\n+     * (file id of a journal) and the second one is <i>txnLogPos</i> (offset in\n+     *  a journal). The <i>LastLogMark</i> indicates that those entries before\n+     * it have been persisted to both index and entry log files.\n+     * </p>\n+     *\n+     * <p>\n+     * This method is called before flushing entry log files and ledger cache.\n+     * </p>\n+     */\n+    public void markLog() {\n+        lastLogMark.markLog();\n+    }\n+\n+    /**\n+     * Persists the <i>LastLogMark</i> marked by #markLog() to disk.\n+     *\n+     * <p>\n+     * This action means entries added before <i>LastLogMark</i> whose entry data\n+     * and index pages were already persisted to disk. It is the time to safely\n+     * remove journal files created earlier than <i>LastLogMark.txnLogId</i>.\n+     * </p>\n+     * <p>\n+     * If the bookie has crashed before persisting <i>LastLogMark</i> to disk,\n+     * it still has journal files contains entries for which index pages may not\n+     * have been persisted. Consequently, when the bookie restarts, it inspects\n+     * journal files to restore those entries; data isn't lost.\n+     * </p>\n+     * <p>\n+     * This method is called after flushing entry log files and ledger cache successfully, which is to ensure <i>LastLogMark</i> is pesisted.\n+     * </p>\n+     * @see #markLog()\n+     */\n+    public void rollLog() {\n+        lastLogMark.rollLog();\n+    }\n+\n+    /**\n+     * Garbage collect older journals\n+     */\n+    public void gcJournals() {\n+        // list the journals that have been marked\n+        List<Long> logs = listJournalIds(journalDirectory, new JournalRollingFilter());\n+        // keep MAX_BACKUP_JOURNALS journal files before marked journal\n+        if (logs.size() >= maxBackupJournals) {\n+            int maxIdx = logs.size() - maxBackupJournals;\n+            for (int i=0; i<maxIdx; i++) {\n+                long id = logs.get(i);\n+                // make sure the journal id is smaller than marked journal id\n+                if (id < lastLogMark.lastMark.txnLogId) {\n+                    File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n+                    journalFile.delete();\n+                    LOG.info(\"garbage collected journal \" + journalFile.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Scan the journal\n+     *\n+     * @param journalId\n+     *          Journal Log Id\n+     * @param journalPos\n+     *          Offset to start scanning\n+     * @param scanner\n+     *          Scanner to handle entries\n+     * @throws IOException\n+     */\n+    public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n+        throws IOException {\n+        JournalChannel recLog;\n+        if (journalPos <= 0) {\n+            recLog = new JournalChannel(journalDirectory, journalId);\n+        } else {\n+            recLog = new JournalChannel(journalDirectory, journalId, journalPos);\n+        }\n+        int journalVersion = recLog.getFormatVersion();\n+        try {\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n+            while(true) {\n+                // entry start offset\n+                long offset = recLog.fc.position();\n+                // start reading entry\n+                lenBuff.clear();\n+                fullRead(recLog, lenBuff);\n+                if (lenBuff.remaining() != 0) {\n+                    break;\n+                }\n+                lenBuff.flip();\n+                int len = lenBuff.getInt();\n+                if (len == 0) {\n+                    break;\n+                }\n+                recBuff.clear();\n+                if (recBuff.remaining() < len) {\n+                    recBuff = ByteBuffer.allocate(len);\n+                }\n+                recBuff.limit(len);\n+                if (fullRead(recLog, recBuff) != len) {\n+                    // This seems scary, but it just means that this is where we\n+                    // left off writing\n+                    break;\n+                }\n+                recBuff.flip();\n+                scanner.process(journalVersion, offset, recBuff);\n+            }\n+        } finally {\n+            recLog.close();\n+        }\n+    }\n+\n+    /**\n+     * Replay journal files\n+     *\n+     * @param scanner\n+     *          Scanner to process replayed entries.\n+     * @throws IOException\n+     */\n+    public void replay(JournalScanner scanner) throws IOException {\n+        final long markedLogId = lastLogMark.txnLogId;\n+        List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n+            @Override\n+            public boolean accept(long journalId) {\n+                if (journalId < markedLogId) {\n+                    return false;\n+                }\n+                return true;\n+            }\n+        });\n+        // last log mark may be missed due to no sync up before\n+        // validate filtered log ids only when we have markedLogId\n+        if (markedLogId > 0) {\n+            if (logs.size() == 0 || logs.get(0) != markedLogId) {\n+                throw new IOException(\"Recovery log \" + markedLogId + \" is missing\");\n+            }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Try to relay journal logs : \" + logs);\n+        }\n+        // TODO: When reading in the journal logs that need to be synced, we\n+        // should use BufferedChannels instead to minimize the amount of\n+        // system calls done.\n+        for(Long id: logs) {\n+            long logPosition = 0L;\n+            if(id == markedLogId) {\n+                logPosition = lastLogMark.txnLogPosition;\n+            }\n+            scanJournal(id, logPosition, scanner);\n+        }\n+    }\n+\n+    /**\n+     * record an add entry operation in journal\n+     */\n+    public void logAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx) {\n+        long ledgerId = entry.getLong();\n+        long entryId = entry.getLong();\n+        entry.rewind();\n+        queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n+    }\n+\n+    /**\n+     * Get the length of journal entries queue.\n+     *\n+     * @return length of journal entry queue.\n+     */\n+    public int getJournalQueueLength() {\n+        return queue.size();\n+    }\n+\n+    /**\n+     * A thread used for persisting journal entries to journal files.\n+     *\n+     * <p>\n+     * Besides persisting journal entries, it also takes responsibility of\n+     * rolling journal files when a journal file reaches journal file size\n+     * limitation.\n+     * </p>\n+     * <p>\n+     * During journal rolling, it first closes the writing journal, generates\n+     * new journal file using current timestamp, and continue persistence logic.\n+     * Those journals will be garbage collected in SyncThread.\n+     * </p>\n+     * @see Bookie#SyncThread\n+     */\n+    @Override\n+    public void run() {\n+        LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n+        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+        try {\n+            long logId = 0;\n+            JournalChannel logFile = null;\n+            BufferedChannel bc = null;\n+            long nextPrealloc = 0;\n+            long lastFlushPosition = 0;\n+\n+            QueueEntry qe = null;\n+            while (true) {\n+                // new journal file to write\n+                if (null == logFile) {\n+                    logId = System.currentTimeMillis();\n+                    logFile = new JournalChannel(journalDirectory, logId);\n+                    bc = logFile.getBufferedChannel();\n+\n+                    lastFlushPosition = 0;\n+                }\n+\n+                if (qe == null) {\n+                    if (toFlush.isEmpty()) {\n+                        qe = queue.take();\n+                    } else {\n+                        qe = queue.poll();\n+                        if (qe == null || bc.position() > lastFlushPosition + 512*1024) {\n+                            //logFile.force(false);\n+                            bc.flush(true);\n+                            lastFlushPosition = bc.position();\n+                            lastLogMark.setLastLogMark(logId, lastFlushPosition);\n+                            for (QueueEntry e : toFlush) {\n+                                e.cb.writeComplete(0, e.ledgerId, e.entryId, null, e.ctx);\n+                            }\n+                            toFlush.clear();\n+\n+                            // check whether journal file is over file limit\n+                            if (bc.position() > maxJournalSize) {\n+                                logFile.close();\n+                                logFile = null;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (!running) {\n+                    LOG.info(\"Journal Manager is asked to shut down, quit.\");\n+                    break;\n+                }\n+\n+                if (qe == null) { // no more queue entry\n+                    continue;\n+                }\n+                lenBuff.clear();\n+                lenBuff.putInt(qe.entry.remaining());\n+                lenBuff.flip();\n+                //\n+                // we should be doing the following, but then we run out of\n+                // direct byte buffers\n+                // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n+                bc.write(lenBuff);\n+                bc.write(qe.entry);\n+\n+                logFile.preAllocIfNeeded();\n+\n+                toFlush.add(qe);\n+                qe = null;\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"Journal exits when shutting down\", e);\n+        }\n+    }\n+\n+    /**\n+     * Shuts down the journal.\n+     */\n+    public synchronized void shutdown() {\n+        try {\n+            if (!running) {\n+                return;\n+            }\n+            running = false;\n+            this.interrupt();\n+            this.join();\n+        } catch (InterruptedException ie) {\n+            LOG.warn(\"Interrupted during shutting down journal : \", ie);\n+        }\n+    }\n+\n+    private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException {\n+        int total = 0;\n+        while(bb.remaining() > 0) {\n+            int rc = fc.read(bb);\n+            if (rc <= 0) {\n+                return total;\n+            }\n+            total += rc;\n+        }\n+        return total;\n+    }\n+}"},{"sha":"a81067de7047fce9a51f459121b3c23a51e4dd7a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -224,7 +224,7 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n     public void sleepBookie(InetSocketAddress addr, final int seconds,\n                             final CountDownLatch l)\n             throws InterruptedException, IOException {\n-        final String name = \"Bookie-\" + addr.getPort();\n+        final String name = \"BookieJournal-\" + addr.getPort();\n         Thread[] allthreads = new Thread[Thread.activeCount()];\n         Thread.enumerate(allthreads);\n         for (final Thread t : allthreads) {"},{"sha":"d1c4b334eedd67bd519425ded3f7c5dd197e52aa","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/cf846eb5f57af19f68ccad42edda7551c852041d/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java?ref=cf846eb5f57af19f68ccad42edda7551c852041d","patch":"@@ -26,7 +26,6 @@\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.bookie.Bookie.JournalIdFilter;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -171,13 +170,15 @@ public void testJournalRolling() throws Exception {\n \n         // verify that we only keep at most journal files \n         for (File journalDir : tmpDirs) {\n-            List<Long> logs = Bookie.listJournalIds(journalDir, new JournalIdFilter() {\n-                @Override\n-                public boolean accept(long journalId) {\n-                    return true;\n+            File[] journals = journalDir.listFiles();\n+            int numJournals = 0;\n+            for (File f : journals) {\n+                if (!f.getName().endsWith(\".txn\")) {\n+                    continue;\n                 }\n-            });\n-            assertTrue(logs.size() <= 2);\n+                ++numJournals;\n+            }\n+            assertTrue(numJournals <= 2);\n         }\n \n         // restart bookies "}]}

