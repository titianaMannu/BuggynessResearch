{"sha":"d11665de31b5ee6969128062569f2081b5d9cf79","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkMTE2NjVkZTMxYjVlZTY5NjkxMjgwNjI1NjlmMjA4MWI1ZDljZjc5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-05-30T13:07:14Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-05-30T13:07:14Z"},"message":"BOOKKEEPER-751: Ensure all the bookkeeper callbacks not run under ledger handle lock (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1598585 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1af0ee3ef25c2d438f11c88b629e903cdeafdde5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1af0ee3ef25c2d438f11c88b629e903cdeafdde5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d11665de31b5ee6969128062569f2081b5d9cf79","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d11665de31b5ee6969128062569f2081b5d9cf79","html_url":"https://github.com/apache/bookkeeper/commit/d11665de31b5ee6969128062569f2081b5d9cf79","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d11665de31b5ee6969128062569f2081b5d9cf79/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"64d0170510849e29de9762957a7107d1a7f07284","url":"https://api.github.com/repos/apache/bookkeeper/commits/64d0170510849e29de9762957a7107d1a7f07284","html_url":"https://github.com/apache/bookkeeper/commit/64d0170510849e29de9762957a7107d1a7f07284"}],"stats":{"total":85,"additions":62,"deletions":23},"files":[{"sha":"933f0ebd5d79ad79d0c2bee7f53b020d8cf364dc","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d11665de31b5ee6969128062569f2081b5d9cf79/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d11665de31b5ee6969128062569f2081b5d9cf79/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=d11665de31b5ee6969128062569f2081b5d9cf79","patch":"@@ -198,6 +198,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-758: Add TryReadLastAddConfirmed API (sijie via ivank)\n \n+        BOOKKEEPER-751: Ensure all the bookkeeper callbacks not run under ledger handle lock (sijie via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"d16084443da66589d9246ca6833f894c9827a110","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":60,"deletions":23,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/d11665de31b5ee6969128062569f2081b5d9cf79/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/d11665de31b5ee6969128062569f2081b5d9cf79/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=d11665de31b5ee6969128062569f2081b5d9cf79","patch":"@@ -26,6 +26,7 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Enumeration;\n+import java.util.List;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.RejectedExecutionException;\n@@ -255,9 +256,7 @@ void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc)\n             doAsyncCloseInternal(cb, ctx, rc);\n         } catch (RejectedExecutionException re) {\n             LOG.debug(\"Failed to close ledger {} : \", ledgerId, re);\n-            synchronized (this) {\n-                errorOutPendingAdds(bk.getReturnRc(rc));\n-            }\n+            errorOutPendingAdds(bk.getReturnRc(rc));\n             cb.closeComplete(bk.getReturnRc(BKException.Code.InterruptedException), this, ctx);\n         }\n     }\n@@ -278,6 +277,7 @@ public void safeRun() {\n                 final long prevLastEntryId;\n                 final long prevLength;\n                 final State prevState;\n+                List<PendingAddOp> pendingAdds;\n \n                 synchronized(LedgerHandle.this) {\n                     // if the metadata is already closed, we don't need to proceed the process\n@@ -290,8 +290,8 @@ public void safeRun() {\n                     prevLastEntryId = metadata.getLastEntryId();\n                     prevLength = metadata.getLength();\n \n-                    // error out pending adds first\n-                    errorOutPendingAdds(rc);\n+                    // drain pending adds first\n+                    pendingAdds = drainPendingAddsToErrorOut();\n \n                     // synchronized on LedgerHandle.this to ensure that\n                     // lastAddPushed can not be updated after the metadata\n@@ -301,6 +301,10 @@ public void safeRun() {\n                     lastAddPushed = lastAddConfirmed;\n                 }\n \n+                // error out all pending adds during closing, the callbacks shouldn't be\n+                // running under any bk locks.\n+                errorOutPendingAdds(rc, pendingAdds);\n+\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n                               + metadata.getLastEntryId() + \" with this many bytes: \" + metadata.getLength());\n@@ -520,21 +524,28 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n \n         final long entryId;\n         final long currentLength;\n+        boolean wasClosed = false;\n         synchronized(this) {\n             // synchronized on this to ensure that\n             // the ledger isn't closed between checking and\n             // updating lastAddPushed\n             if (metadata.isClosed()) {\n-                LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                cb.addComplete(BKException.Code.LedgerClosedException,\n-                               LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n-                return;\n+                wasClosed = true;\n+                entryId = -1;\n+                currentLength = 0;\n+            } else {\n+                entryId = ++lastAddPushed;\n+                currentLength = addToLength(length);\n+                op.setEntryId(entryId);\n+                pendingAddOps.add(op);\n             }\n+        }\n \n-            entryId = ++lastAddPushed;\n-            currentLength = addToLength(length);\n-            op.setEntryId(entryId);\n-            pendingAddOps.add(op);\n+        if (wasClosed) {\n+            LOG.warn(\"Attempt to add to closed ledger: {}\", ledgerId);\n+            cb.addComplete(BKException.Code.LedgerClosedException,\n+                           LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+            return;\n         }\n \n         try {\n@@ -748,10 +759,22 @@ void handleUnrecoverableErrorDuringAdd(int rc) {\n     }\n \n     void errorOutPendingAdds(int rc) {\n+        errorOutPendingAdds(rc, drainPendingAddsToErrorOut());\n+    }\n+\n+    synchronized List<PendingAddOp> drainPendingAddsToErrorOut() {\n         PendingAddOp pendingAddOp;\n+        List<PendingAddOp> opsDrained = new ArrayList<PendingAddOp>(pendingAddOps.size());\n         while ((pendingAddOp = pendingAddOps.poll()) != null) {\n             addToLength(-pendingAddOp.entryLength);\n-            pendingAddOp.submitCallback(rc);\n+            opsDrained.add(pendingAddOp);\n+        }\n+        return opsDrained;\n+    }\n+\n+    void errorOutPendingAdds(int rc, List<PendingAddOp> ops) {\n+        for (PendingAddOp op : ops) {\n+            op.submitCallback(rc);\n         }\n     }\n \n@@ -1007,25 +1030,39 @@ void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n         bk.getLedgerManager().readLedgerMetadata(ledgerId, cb);\n     }\n \n-    synchronized void recover(final GenericCallback<Void> cb) {\n-        if (metadata.isClosed()) {\n-            lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n-            length = metadata.getLength();\n+    void recover(final GenericCallback<Void> cb) {\n+        boolean wasClosed = false;\n+        boolean wasInRecovery = false;\n+\n+        synchronized (this) {\n+            if (metadata.isClosed()) {\n+                lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n+                length = metadata.getLength();\n+                wasClosed = true;\n+            } else {\n+                wasClosed = false;\n+                if (metadata.isInRecovery()) {\n+                    wasInRecovery = true;\n+                } else {\n+                    wasInRecovery = false;\n+                    metadata.markLedgerInRecovery();\n+                }\n+            }\n+        }\n \n+        if (wasClosed) {\n             // We are already closed, nothing to do\n             cb.operationComplete(BKException.Code.OK, null);\n             return;\n         }\n \n-        // if metadata is already in recover, dont try to write again,\n-        // just do the recovery from the starting point\n-        if (metadata.isInRecovery()) {\n+        if (wasInRecovery) {\n+            // if metadata is already in recover, dont try to write again,\n+            // just do the recovery from the starting point\n             new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n             return;\n         }\n \n-        metadata.markLedgerInRecovery();\n-\n         writeLedgerConfig(new OrderedSafeGenericCallback<Void>(bk.mainWorkerPool, ledgerId) {\n             @Override\n             public void safeOperationComplete(final int rc, Void result) {"}]}

