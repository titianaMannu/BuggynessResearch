{"sha":"d169f8843e819e7ef49c1fdfe69a85308f420a4a","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkMTY5Zjg4NDNlODE5ZTdlZjQ5YzFmZGZlNjlhODUzMDhmNDIwYTRh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-03T15:27:11Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-03T15:27:11Z"},"message":"BOOKKEEPER-335: client-side message filter for cpp client. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1380273 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0274ae3f9b18bc8047db93f3adbea6b167c33172","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0274ae3f9b18bc8047db93f3adbea6b167c33172"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d169f8843e819e7ef49c1fdfe69a85308f420a4a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d169f8843e819e7ef49c1fdfe69a85308f420a4a","html_url":"https://github.com/apache/bookkeeper/commit/d169f8843e819e7ef49c1fdfe69a85308f420a4a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d169f8843e819e7ef49c1fdfe69a85308f420a4a/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"2ffc123e5ffb37163512a89301a128f07f05750c","url":"https://api.github.com/repos/apache/bookkeeper/commits/2ffc123e5ffb37163512a89301a128f07f05750c","html_url":"https://github.com/apache/bookkeeper/commit/2ffc123e5ffb37163512a89301a128f07f05750c"}],"stats":{"total":454,"additions":448,"deletions":6},"files":[{"sha":"e9167b2d25ce63065c88e84797f1fc674e327889","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -136,6 +136,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-334: client-side message filter for java client. (sijie via ivank)\n \n+        BOOKKEEPER-335: client-side message filter for cpp client. (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"8d47018726a1ff85903e99613a34c2121aeb242d","filename":"hedwig-client/src/main/cpp/inc/hedwig/callback.h","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/inc/hedwig/callback.h","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/inc/hedwig/callback.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/callback.h?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -55,6 +55,18 @@ namespace Hedwig {\n     virtual ~MessageHandlerCallback() {};\n   };\n   typedef std::tr1::shared_ptr<MessageHandlerCallback> MessageHandlerCallbackPtr;\n+\n+  typedef std::tr1::shared_ptr<SubscriptionPreferences> SubscriptionPreferencesPtr;\n+\n+  class ClientMessageFilter {\n+  public:\n+    virtual void setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n+                                            const SubscriptionPreferencesPtr& preferences) = 0;\n+    virtual bool testMessage(const Message& message) = 0;\n+\n+    virtual ~ClientMessageFilter() {};\n+  };\n+  typedef std::tr1::shared_ptr<ClientMessageFilter> ClientMessageFilterPtr;\n }\n \n #endif"},{"sha":"93cf7f2af675ba02c54af67ef0ca7366945d90a0","filename":"hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/exceptions.h?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -39,6 +39,8 @@ namespace Hedwig {\n   class SubscriberException : public ClientException { };\n   class AlreadySubscribedException : public SubscriberException {};\n   class NotSubscribedException : public SubscriberException {};\n+  class NullMessageHandlerException : public SubscriberException {};\n+  class NullMessageFilterException : public SubscriberException {};\n \n   class ConfigurationException : public ClientException { };\n   class InvalidPortException : public ConfigurationException {};"},{"sha":"8ca5b2b210269a0406fec7fa215b2376ca25feb2","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -42,7 +42,13 @@ namespace Hedwig {\n \n     virtual void consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId) = 0;\n \n-    virtual void startDelivery(const std::string& topic, const std::string& subscriberId, const MessageHandlerCallbackPtr& callback) = 0;\n+    virtual void startDelivery(const std::string& topic, const std::string& subscriberId,\n+                               const MessageHandlerCallbackPtr& callback) = 0;\n+    virtual void startDeliveryWithFilter(const std::string& topic,\n+                                         const std::string& subscriberId,\n+                                         const MessageHandlerCallbackPtr& callback,\n+                                         const ClientMessageFilterPtr& filter) = 0;\n+\n     virtual void stopDelivery(const std::string& topic, const std::string& subscriberId) = 0;\n \n     virtual void closeSubscription(const std::string& topic, const std::string& subscriberId) = 0;"},{"sha":"03ffc999afaf72788b8565a33be8640d75f0336d","filename":"hedwig-client/src/main/cpp/lib/Makefile.am","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/Makefile.am?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -19,7 +19,7 @@\n PROTODEF = ../../../../../hedwig-protocol/src/main/protobuf/PubSubProtocol.proto\n \n lib_LTLIBRARIES = libhedwig01.la\n-libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp\n+libhedwig01_la_SOURCES = protocol.cpp channel.cpp client.cpp util.cpp clientimpl.cpp publisherimpl.cpp subscriberimpl.cpp eventdispatcher.cpp data.cpp filterablemessagehandler.cpp\n libhedwig01_la_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS)\n libhedwig01_la_LIBADD = $(DEPS_LIBS) $(BOOST_CPPFLAGS) \n libhedwig01_la_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)"},{"sha":"07d884c2ce43ad8f3781dc2f76eb009319fa8558","filename":"hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/filterablemessagehandler.cpp?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include \"filterablemessagehandler.h\"\n+\n+using namespace Hedwig;\n+\n+FilterableMessageHandler::FilterableMessageHandler(const MessageHandlerCallbackPtr& msgHandler,\n+                                                   const ClientMessageFilterPtr& msgFilter)\n+  : msgHandler(msgHandler), msgFilter(msgFilter) {\n+}\n+\n+FilterableMessageHandler::~FilterableMessageHandler() {\n+}\n+\n+void FilterableMessageHandler::consume(const std::string& topic, const std::string& subscriberId,\n+                                       const Message& msg, OperationCallbackPtr& callback) {\n+  bool deliver = true;\n+  if (0 != msgFilter.get()) {\n+    deliver = msgFilter->testMessage(msg);\n+  }\n+  if (deliver) {\n+    msgHandler->consume(topic, subscriberId, msg, callback);\n+  } else {\n+    callback->operationComplete();\n+  }\n+}"},{"sha":"2d24bd5c9763e02e324df3ec76fa86f81a16e74d","filename":"hedwig-client/src/main/cpp/lib/filterablemessagehandler.h","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/filterablemessagehandler.h","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/filterablemessagehandler.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/filterablemessagehandler.h?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifndef FILTERABLE_MESSAGE_HANDLER_H\n+#define FILTERABLE_MESSAGE_HANDLER_H\n+\n+#include <hedwig/callback.h>\n+#include <hedwig/protocol.h>\n+\n+#ifdef USE_BOOST_TR1\n+#include <boost/tr1/memory.hpp>\n+#else \n+#include <tr1/memory>\n+#endif\n+\n+namespace Hedwig {\n+\n+  class FilterableMessageHandler : public MessageHandlerCallback {\n+  public:\n+    FilterableMessageHandler(const MessageHandlerCallbackPtr& msgHandler,\n+                             const ClientMessageFilterPtr& msgFilter);\n+\n+    virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                         const Message& msg, OperationCallbackPtr& callback);\n+\n+    virtual ~FilterableMessageHandler();\n+  private:\n+    const MessageHandlerCallbackPtr msgHandler;\n+    const ClientMessageFilterPtr msgFilter;\n+  };\n+\n+};\n+\n+#endif\n+"},{"sha":"6d7506beecaadfe766a79edb83cbc8b9696a3a05","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":52,"deletions":1,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -22,6 +22,7 @@\n #include \"subscriberimpl.h\"\n #include \"util.h\"\n #include \"channel.h\"\n+#include \"filterablemessagehandler.h\"\n \n #include <boost/asio.hpp>\n #include <boost/date_time/posix_time/posix_time.hpp>\n@@ -405,7 +406,28 @@ void SubscriberImpl::consume(const std::string& topic, const std::string& subscr\n   channel->writeRequest(data->getRequest(), writecb);\n }\n \n-void SubscriberImpl::startDelivery(const std::string& topic, const std::string& subscriberId, const MessageHandlerCallbackPtr& callback) {\n+void SubscriberImpl::startDeliveryWithFilter(const std::string& topic,\n+                                             const std::string& subscriberId,\n+                                             const MessageHandlerCallbackPtr& callback,\n+                                             const ClientMessageFilterPtr& filter) {\n+  if (0 == filter.get()) {\n+    throw NullMessageFilterException();\n+  }\n+  if (0 == callback.get()) {\n+    throw NullMessageHandlerException();\n+  }\n+  const SubscriptionPreferencesPtr& preferences =\n+    getSubscriptionPreferences(topic, subscriberId);\n+  if (0 == preferences.get()) {\n+    throw NotSubscribedException();\n+  }\n+  filter->setSubscriptionPreferences(topic, subscriberId, preferences);\n+  MessageHandlerCallbackPtr filterableHandler(new FilterableMessageHandler(callback, filter));\n+  startDelivery(topic, subscriberId, filterableHandler);\n+}\n+\n+void SubscriberImpl::startDelivery(const std::string& topic, const std::string& subscriberId,\n+                                   const MessageHandlerCallbackPtr& callback) {\n   TopicSubscriber t(topic, subscriberId);\n \n   boost::shared_lock<boost::shared_mutex> lock(topicsubscriber2handler_lock);\n@@ -446,6 +468,22 @@ void SubscriberImpl::closeSubscription(const std::string& topic, const std::stri\n   }\n }\n \n+void SubscriberImpl::setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n+                                                const SubscriptionPreferences& preferences) {\n+  boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2preferences_lock);\n+  TopicSubscriber t(topic, subscriberId);\n+  SubscriptionPreferencesPtr newPreferences(new SubscriptionPreferences(preferences));\n+  topicsubscriber2preferences[t] = newPreferences;\n+}\n+\n+const SubscriptionPreferencesPtr& SubscriberImpl::getSubscriptionPreferences(\n+    const std::string& topic, const std::string& subscriberId) {\n+  boost::lock_guard<boost::shared_mutex> lock(topicsubscriber2preferences_lock);\n+  TopicSubscriber t(topic, subscriberId);\n+  const SubscriptionPreferencesPtr &preferences = topicsubscriber2preferences[t];\n+  return preferences;\n+}\n+\n /**\n    takes ownership of txn\n */\n@@ -459,6 +497,19 @@ void SubscriberImpl::messageHandler(const PubSubResponsePtr& m, const PubSubData\n \n   switch (m->statuscode()) {\n   case SUCCESS:\n+    // for subscribe request, check whether is any subscription preferences received\n+    if (SUBSCRIBE == txn->getType()) {\n+      if (m->has_responsebody()) {\n+        const ResponseBody& respBody = m->responsebody();\n+        if (respBody.has_subscriberesponse()) {\n+          const SubscribeResponse& resp = respBody.subscriberesponse();\n+          if (resp.has_preferences()) {\n+            setSubscriptionPreferences(txn->getTopic(), txn->getSubscriberId(),\n+                                       resp.preferences());\n+          }\n+        }\n+      }\n+    }\n     if (m->has_responsebody()) {\n       txn->getCallback()->operationComplete(m->responsebody());\n     } else {"},{"sha":"beba5474aca492fd4ba50c0b078ac5af6827723f","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":14,"deletions":2,"changes":16,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -153,7 +153,11 @@ namespace Hedwig {\n \n     void consume(const std::string& topic, const std::string& subscriberId, const MessageSeqId& messageSeqId);\n \n-    void startDelivery(const std::string& topic, const std::string& subscriberId, const MessageHandlerCallbackPtr& callback);\n+    void startDelivery(const std::string& topic, const std::string& subscriberId,\n+                       const MessageHandlerCallbackPtr& callback);\n+    void startDeliveryWithFilter(const std::string& topic, const std::string& subscriberId,\n+                                 const MessageHandlerCallbackPtr& callback,\n+                                 const ClientMessageFilterPtr& filter);\n     void stopDelivery(const std::string& topic, const std::string& subscriberId);\n \n     void closeSubscription(const std::string& topic, const std::string& subscriberId);\n@@ -163,11 +167,19 @@ namespace Hedwig {\n     void doSubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data, const SubscriberClientChannelHandlerPtr& handler);\n     void doUnsubscribe(const DuplexChannelPtr& channel, const PubSubDataPtr& data);\n \n+  private:\n+    void setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n+                                    const SubscriptionPreferences& preferences);\n+    const SubscriptionPreferencesPtr& getSubscriptionPreferences(\n+                                    const std::string& topic, const std::string& subscriberId);\n+\n   private:\n     const ClientImplPtr client;\n-    \n+\n     std::tr1::unordered_map<TopicSubscriber, SubscriberClientChannelHandlerPtr, TopicSubscriberHash > topicsubscriber2handler;\n     boost::shared_mutex topicsubscriber2handler_lock;\t    \n+    std::tr1::unordered_map<TopicSubscriber, SubscriptionPreferencesPtr, TopicSubscriberHash> topicsubscriber2preferences;\n+    boost::shared_mutex topicsubscriber2preferences_lock;\t    \n   };\n \n };"},{"sha":"530f674fae8ad1ca2d36b16dc68d8e1258f2906f","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -18,7 +18,7 @@\n \n if HAVE_GTEST\n bin_PROGRAMS = hedwigtest\n-hedwigtest_SOURCES = main.cpp utiltest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp\n+hedwigtest_SOURCES = main.cpp utiltest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp messagefiltertest.cpp\n hedwigtest_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS) $(GTEST_CPPFLAGS) $(BOOST_CPPFLAGS)\n hedwigtest_CXXFLAGS = $(GTEST_CXXFLAGS)\n hedwigtest_LDADD = $(DEPS_LIBS) $(GTEST_LIBS) -L$(top_builddir)/lib -lhedwig01"},{"sha":"f4782f1291fe2bd11773062844805a77c6a0b156","filename":"hedwig-client/src/main/cpp/test/messagefiltertest.cpp","status":"added","additions":263,"deletions":0,"changes":263,"blob_url":"https://github.com/apache/bookkeeper/blob/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/test/messagefiltertest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d169f8843e819e7ef49c1fdfe69a85308f420a4a/hedwig-client/src/main/cpp/test/messagefiltertest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messagefiltertest.cpp?ref=d169f8843e819e7ef49c1fdfe69a85308f420a4a","patch":"@@ -0,0 +1,263 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include \"gtest/gtest.h\"\n+\n+#include \"../lib/clientimpl.h\"\n+#include <hedwig/exceptions.h>\n+#include <hedwig/callback.h>\n+#include <stdexcept>\n+#include <pthread.h>\n+\n+#include <log4cxx/logger.h>\n+\n+#include \"util.h\"\n+\n+static log4cxx::LoggerPtr logger(log4cxx::Logger::getLogger(\"hedwig.\"__FILE__));\n+\n+class MessageFilterConfiguration : public Hedwig::Configuration {\n+public:\n+  MessageFilterConfiguration() : address(\"localhost:4081\") {}\n+  \n+  virtual int getInt(const std::string& key, int defaultVal) const {\n+    return defaultVal;\n+  }\n+\n+  virtual const std::string get(const std::string& key, const std::string& defaultVal) const {\n+    if (key == Configuration::DEFAULT_SERVER) {\n+      return address;\n+    } else {\n+      return defaultVal;\n+    }\n+  }\n+  \n+  virtual bool getBool(const std::string& key, bool defaultVal) const {\n+    if (key == Configuration::SUBSCRIBER_AUTOCONSUME) {\n+      return false;\n+    } else {\n+      return defaultVal;\n+    }\n+  }\n+\n+  protected:\n+  const std::string address;\n+};\n+    \n+class ModMessageFilter : public Hedwig::ClientMessageFilter {\n+public:\n+  ModMessageFilter() : mod(0) {\n+  }\n+\n+  virtual void setSubscriptionPreferences(const std::string& topic, const std::string& subscriberId,\n+                                          const Hedwig::SubscriptionPreferencesPtr& preferences) {\n+    if (!preferences->has_options()) {\n+      return;\n+    }\n+\n+    const Hedwig::Map& userOptions = preferences->options();\n+    int numOpts = userOptions.entries_size();\n+    for (int i=0; i<numOpts; i++) {\n+      const Hedwig::Map_Entry& opt = userOptions.entries(i);\n+      const std::string& key = opt.key();\n+      if (\"MOD\" != key) {\n+        continue;\n+      }\n+      const std::string& value = opt.value();\n+      mod = atoi(value.c_str());\n+      break;\n+    }\n+    return; \n+  }\n+  virtual bool testMessage(const Hedwig::Message& message) {\n+    int value = atoi(message.body().c_str());\n+    return 0 == value % mod;\n+  }\n+private:\n+  int mod;\n+};\n+\n+class GapCheckingMessageHandlerCallback : public Hedwig::MessageHandlerCallback {\n+public:\n+  GapCheckingMessageHandlerCallback(Hedwig::Subscriber& sub,\n+                                    const int start, const int nextValue,\n+                                    const int gap, bool doConsume)\n+    : sub(sub), start(start), nextValue(nextValue), gap(gap), doConsume(doConsume) {\n+  }\n+\n+  virtual void consume(const std::string& topic, const std::string& subscriberId,\n+                       const Hedwig::Message& msg, Hedwig::OperationCallbackPtr& callback) {\n+    boost::lock_guard<boost::mutex> lock(mutex);\n+    \n+    int value = atoi(msg.body().c_str());\n+    if(value > start) {\n+      LOG4CXX_DEBUG(logger, \"received message \" << value);\n+      if (value == nextValue) {\n+        nextValue += gap;\n+      }\n+    }\n+    callback->operationComplete();\n+    if (doConsume) {\n+      sub.consume(topic, subscriberId, msg.msgid());\n+    }\n+  }\n+\n+  int nextExpected() {\n+    return nextValue;\n+  }\n+\n+protected:\n+  boost::mutex mutex;\n+  Hedwig::Subscriber& sub;\n+  int start;\n+  int nextValue;\n+  int gap;\n+  bool doConsume;\n+};\n+\n+void publishNums(Hedwig::Publisher& pub, const std::string& topic,\n+                 int start, int num, int M) {\n+  for (int i=1; i<=num; i++) {\n+    int value = start + i;\n+    int mod = value % M;\n+\n+    std::stringstream valSS;\n+    valSS << value;\n+\n+    std::stringstream modSS;\n+    modSS << mod;\n+\n+    Hedwig::Message msg;\n+    msg.set_body(valSS.str());\n+    Hedwig::MessageHeader* header = msg.mutable_header();\n+    Hedwig::Map* properties = header->mutable_properties();\n+    Hedwig::Map_Entry* entry = properties->add_entries();\n+    entry->set_key(\"mod\");\n+    entry->set_value(modSS.str());\n+\n+    pub.publish(topic, msg);\n+  }\n+}\n+\n+void receiveNumModM(Hedwig::Subscriber& sub,\n+                    const std::string& topic, const std::string& subid,\n+                    int start, int num, int M, bool consume) {\n+  Hedwig::SubscriptionOptions options;\n+  options.set_createorattach(Hedwig::SubscribeRequest::ATTACH);\n+  Hedwig::Map* userOptions = options.mutable_options();\n+  Hedwig::Map_Entry* opt = userOptions->add_entries();\n+  opt->set_key(\"MOD\");\n+\n+  std::stringstream modSS;\n+  modSS << M;\n+  opt->set_value(modSS.str());\n+\n+  sub.subscribe(topic, subid, options);\n+\n+  int base = start + M - start % M;\n+  int end = base + num * M;\n+\n+  GapCheckingMessageHandlerCallback * cb =\n+    new GapCheckingMessageHandlerCallback(sub, start, base, M, consume);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  Hedwig::ClientMessageFilterPtr filter(new ModMessageFilter());\n+\n+  sub.startDeliveryWithFilter(topic, subid, handler, filter);\n+\n+  for (int i = 0; i < 100; i++) {\n+    if (cb->nextExpected() == end) {\n+      break;\n+    } else {\n+      sleep(1);\n+    }\n+  }\n+  ASSERT_TRUE(cb->nextExpected() == end);\n+\n+  sub.stopDelivery(topic, subid);\n+  sub.closeSubscription(topic, subid);\n+}\n+\n+TEST(MessageFilterTest, testNullMessageFilter) {\n+  Hedwig::Configuration* conf = new MessageFilterConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+\n+  std::string topic = \"testNullMessageFilter\";\n+  std::string subid = \"myTestSubid\";\n+\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+\n+  GapCheckingMessageHandlerCallback * cb =\n+    new GapCheckingMessageHandlerCallback(sub, 0, 0, 0, true);\n+  Hedwig::MessageHandlerCallbackPtr handler(cb);\n+  Hedwig::ClientMessageFilterPtr filter(new ModMessageFilter());\n+\n+  ASSERT_THROW(sub.startDeliveryWithFilter(topic, subid, handler,\n+                                           Hedwig::ClientMessageFilterPtr()),\n+               Hedwig::NullMessageFilterException);\n+  ASSERT_THROW(sub.startDeliveryWithFilter(topic, subid, \n+                                           Hedwig::MessageHandlerCallbackPtr(), filter),\n+               Hedwig::NullMessageHandlerException);\n+}\n+\n+TEST(MessageFilterTest, testMessageFilter) {\n+  Hedwig::Configuration* conf = new MessageFilterConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+  \n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+\n+  std::string topic = \"testMessageFilter\";\n+  std::string subid = \"myTestSubid\";\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.closeSubscription(topic, subid);\n+\n+  publishNums(pub, topic, 0, 100, 2);\n+  receiveNumModM(sub, topic, subid, 0, 50, 2, true);\n+}\n+\n+TEST(MessageFilterTest, testUpdateMessageFilter) {\n+  Hedwig::Configuration* conf = new MessageFilterConfiguration();\n+  std::auto_ptr<Hedwig::Configuration> confptr(conf);\n+\n+  Hedwig::Client* client = new Hedwig::Client(*conf);\n+  std::auto_ptr<Hedwig::Client> clientptr(client);\n+\n+  Hedwig::Subscriber& sub = client->getSubscriber();\n+  Hedwig::Publisher& pub = client->getPublisher();\n+  \n+  std::string topic = \"testUpdateMessageFilter\";\n+  std::string subid = \"myTestSubid\";\n+\n+  sub.subscribe(topic, subid, Hedwig::SubscribeRequest::CREATE_OR_ATTACH);\n+  sub.closeSubscription(topic, subid);\n+\n+  publishNums(pub, topic, 0, 100, 2);\n+  receiveNumModM(sub, topic, subid, 0, 50, 2, false);\n+  receiveNumModM(sub, topic, subid, 0, 25, 4, false);\n+  receiveNumModM(sub, topic, subid, 0, 33, 3, false);\n+}"}]}

