{"sha":"d5caab3aae143352f2d8c3faea71dce11fdb6b45","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkNWNhYWIzYWFlMTQzMzUyZjJkOGMzZmFlYTcxZGNlMTFmZGI2YjQ1","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-06T16:13:56Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-06T16:13:56Z"},"message":"BOOKKEEPER-287: NoSuchElementException in LedgerCacheImpl (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1346966 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"afbb44507dc3eefc42d9710af095631641923771","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/afbb44507dc3eefc42d9710af095631641923771"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d5caab3aae143352f2d8c3faea71dce11fdb6b45","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d5caab3aae143352f2d8c3faea71dce11fdb6b45","html_url":"https://github.com/apache/bookkeeper/commit/d5caab3aae143352f2d8c3faea71dce11fdb6b45","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d5caab3aae143352f2d8c3faea71dce11fdb6b45/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"25552d910c5d32307bda64cc3ae022e607850b7c","url":"https://api.github.com/repos/apache/bookkeeper/commits/25552d910c5d32307bda64cc3ae022e607850b7c","html_url":"https://github.com/apache/bookkeeper/commit/25552d910c5d32307bda64cc3ae022e607850b7c"}],"stats":{"total":83,"additions":67,"deletions":16},"files":[{"sha":"2f65d8fc845f23e2b776f22db805e7309cea4fff","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d5caab3aae143352f2d8c3faea71dce11fdb6b45/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d5caab3aae143352f2d8c3faea71dce11fdb6b45/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=d5caab3aae143352f2d8c3faea71dce11fdb6b45","patch":"@@ -140,6 +140,8 @@ Release 4.1.0 - 2012-05-31\n \n         BOOKKEEPER-286: Compilation warning (ivank via sijie)\n \n+        BOOKKEEPER-287: NoSuchElementException in LedgerCacheImpl (sijie)\n+\n       hedwig-client/\n \n         BOOKKEEPER-217: NPE in hedwig client when enable DEBUG (sijie via ivank)"},{"sha":"c0b8121ae6a9709dc942b6b5a40b1a3e65588f35","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":30,"deletions":16,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/d5caab3aae143352f2d8c3faea71dce11fdb6b45/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d5caab3aae143352f2d8c3faea71dce11fdb6b45/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=d5caab3aae143352f2d8c3faea71dce11fdb6b45","patch":"@@ -176,7 +176,7 @@ private LedgerEntryPage grabLedgerEntryPage(long ledger, long pageEntry) throws\n             }   \n         } catch (IOException ie) {\n             // if we grab a clean page, but failed to update the page\n-            // we are exhuasting the count of ledger entry pages.\n+            // we are exhausting the count of ledger entry pages.\n             // since this page will be never used, so we need to decrement\n             // page count of ledger cache.\n             lep.releasePage();\n@@ -317,7 +317,7 @@ public void flushLedger(boolean doAll) throws IOException {\n                 if (!doAll) {\n                     break;\n                 }\n-                // Yeild. if we are doing all the ledgers we don't want to block other flushes that\n+                // Yield. if we are doing all the ledgers we don't want to block other flushes that\n                 // need to happen\n                 try {\n                     dirtyLedgers.wait(1);\n@@ -449,22 +449,22 @@ private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOExceptio\n         if (entry % entriesPerPage != 0) {\n             throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n         }\n-        synchronized(this) {\n-            if (pageCount  < pageLimit) {\n-                // let's see if we can allocate something\n-                LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n-                lep.setLedger(ledger);\n-                lep.setFirstEntry(entry);\n+        outerLoop:\n+        while(true) {\n+            synchronized(this) {\n+                if (pageCount  < pageLimit) {\n+                    // let's see if we can allocate something\n+                    LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n+                    lep.setLedger(ledger);\n+                    lep.setFirstEntry(entry);\n \n-                // note, this will not block since it is a new page\n-                lep.usePage();\n-                pageCount++;\n-                return lep;\n+                    // note, this will not block since it is a new page\n+                    lep.usePage();\n+                    pageCount++;\n+                    return lep;\n+                }\n             }\n-        }\n \n-        outerLoop:\n-        while(true) {\n             synchronized(cleanLedgers) {\n                 if (cleanLedgers.isEmpty()) {\n                     flushLedger(false);\n@@ -475,6 +475,14 @@ private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOExceptio\n                     }\n                 }\n                 synchronized(this) {\n+                    // if ledgers deleted between checking pageCount and putting\n+                    // ledgers into cleanLedgers list, the cleanLedgers list would be empty.\n+                    // so give it a chance to go back to check pageCount again because\n+                    // deleteLedger would decrement pageCount to return the number of pages\n+                    // occupied by deleted ledgers.\n+                    if (cleanLedgers.isEmpty()) {\n+                        continue outerLoop;\n+                    }\n                     Long cleanLedger = cleanLedgers.getFirst();\n                     Map<Long, LedgerEntryPage> map = pages.get(cleanLedger);\n                     while (map == null || map.isEmpty()) {\n@@ -610,7 +618,13 @@ public void deleteLedger(long ledgerId) throws IOException {\n \n         // remove pages first to avoid page flushed when deleting file info\n         synchronized(this) {\n-            pages.remove(ledgerId);\n+            Map<Long, LedgerEntryPage> lpages = pages.remove(ledgerId);\n+            if (null != lpages) {\n+                pageCount -= lpages.size();\n+                if (pageCount < 0) {\n+                    LOG.error(\"Page count of ledger cache has been decremented to be less than zero.\");\n+                }\n+            }\n         }\n         // Delete the ledger's index file and close the FileInfo\n         FileInfo fi = null;"},{"sha":"3720bb886dbff1baf433ab8ff0320dde7c182dc1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d5caab3aae143352f2d8c3faea71dce11fdb6b45/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d5caab3aae143352f2d8c3faea71dce11fdb6b45/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=d5caab3aae143352f2d8c3faea71dce11fdb6b45","patch":"@@ -125,6 +125,41 @@ public void testLedgerEviction() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testDeleteLedger() throws Exception {\n+        int numEntries = 10;\n+        // limit open files & pages\n+        conf.setOpenFileLimit(999).setPageLimit(2)\n+            .setPageSize(8 * numEntries);\n+        // create ledger cache\n+        newLedgerCache();\n+        try {\n+            int numLedgers = 2;\n+            byte[] masterKey = \"blah\".getBytes();\n+            for (int i=1; i<=numLedgers; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                for (int j=0; j<numEntries; j++) {\n+                    ledgerCache.putEntryOffset(i, j, i*numEntries + j);\n+                }\n+            }\n+            // ledger cache is exhausted\n+            // delete ledgers\n+            for (int i=1; i<=numLedgers; i++) {\n+                ledgerCache.deleteLedger((long)i);\n+            }\n+            // create num ledgers to add entries\n+            for (int i=numLedgers+1; i<=2*numLedgers; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                for (int j=0; j<numEntries; j++) {\n+                    ledgerCache.putEntryOffset(i, j, i*numEntries + j);\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Got Exception.\", e);\n+            fail(\"Failed to add entry.\");\n+        }\n+    }\n+\n     @Test\n     public void testPageEviction() throws Exception {\n         int numLedgers = 10;"}]}

