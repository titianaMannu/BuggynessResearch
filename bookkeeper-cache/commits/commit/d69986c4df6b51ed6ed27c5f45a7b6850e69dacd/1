{"sha":"d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkNjk5ODZjNGRmNmI1MWVkNmVkMjdjNWY0NWE3YjY4NTBlNjlkYWNk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-18T12:04:51Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-18T12:04:51Z"},"message":"BOOKKEEPER-500: Fencing doesn't work when restarting bookies. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1423419 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3ec5a619b9e7997e43d8ddc18999ae8a9b4ff733","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3ec5a619b9e7997e43d8ddc18999ae8a9b4ff733"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","html_url":"https://github.com/apache/bookkeeper/commit/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"e5b0dd0d9e47394202f5a20cedf409f487d90beb","url":"https://api.github.com/repos/apache/bookkeeper/commits/e5b0dd0d9e47394202f5a20cedf409f487d90beb","html_url":"https://github.com/apache/bookkeeper/commit/e5b0dd0d9e47394202f5a20cedf409f487d90beb"}],"stats":{"total":322,"additions":306,"deletions":16},"files":[{"sha":"21a05a54a0c3984f2e643d50fded78c77bd63237","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -148,6 +148,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-496: Ensure that the auditor and replication worker will shutdown if they lose their ZK session (ivank)\n \n+        BOOKKEEPER-500: Fencing doesn't work when restarting bookies. (sijie via ivank)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"e96f880f58b1bbb0a5002b198dcb0992c3893a8d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":102,"deletions":2,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -35,6 +35,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -89,6 +90,7 @@\n     final HandleFactory handles;\n \n     static final long METAENTRY_ID_LEDGER_KEY = -0x1000;\n+    static final long METAENTRY_ID_FENCE_KEY  = -0x2000;\n \n     // ZK registration path for this bookie\n     private final String bookieRegistrationPath;\n@@ -155,6 +157,75 @@ public void writeComplete(int rc, long ledgerId, long entryId,\n         }\n     }\n \n+    final static Future<Boolean> SUCCESS_FUTURE = new Future<Boolean>() {\n+        @Override\n+        public boolean cancel(boolean mayInterruptIfRunning) { return false; }\n+        @Override\n+        public Boolean get() { return true; }\n+        @Override\n+        public Boolean get(long timeout, TimeUnit unit) { return true; }\n+        @Override\n+        public boolean isCancelled() { return false; }\n+        @Override\n+        public boolean isDone() {\n+            return true;\n+        }\n+    };\n+\n+    static class CountDownLatchFuture<T> implements Future<T> {\n+\n+        T value = null;\n+        volatile boolean done = false;\n+        CountDownLatch latch = new CountDownLatch(1);\n+\n+        @Override\n+        public boolean cancel(boolean mayInterruptIfRunning) { return false; }\n+        @Override\n+        public T get() throws InterruptedException {\n+            latch.await();\n+            return value;\n+        }\n+        @Override\n+        public T get(long timeout, TimeUnit unit) throws InterruptedException {\n+            latch.await(timeout, unit);\n+            return value;\n+        }\n+\n+        @Override\n+        public boolean isCancelled() { return false; }\n+\n+        @Override\n+        public boolean isDone() {\n+            return done;\n+        }\n+\n+        void setDone(T value) {\n+            this.value = value;\n+            done = true;\n+            latch.countDown();\n+        }\n+    }\n+\n+    static class FutureWriteCallback implements WriteCallback {\n+\n+        CountDownLatchFuture<Boolean> result =\n+            new CountDownLatchFuture<Boolean>();\n+\n+        @Override\n+        public void writeComplete(int rc, long ledgerId, long entryId,\n+                                  InetSocketAddress addr, Object ctx) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n+                          new Object[] { entryId, ledgerId, addr, rc });\n+            }\n+            result.setDone(0 == rc);\n+        }\n+\n+        public Future<Boolean> getResult() {\n+            return result;\n+        }\n+    }\n+\n     /**\n      * SyncThread is a background thread which flushes ledger index pages periodically.\n      * Also it takes responsibility of garbage collecting journal files.\n@@ -451,6 +522,19 @@ public void process(int journalVersion, long offset, ByteBuffer recBuff) throws\n                                     + \" but layout version (\" + journalVersion\n                                     + \") is too old to hold this\");\n                         }\n+                    } else if (entryId == METAENTRY_ID_FENCE_KEY) {\n+                        if (journalVersion >= 4) {\n+                            byte[] key = masterKeyCache.get(ledgerId);\n+                            if (key == null) {\n+                                key = ledgerStorage.readMasterKey(ledgerId);\n+                            }\n+                            LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n+                            handle.setFenced();\n+                        } else {\n+                            throw new IOException(\"Invalid journal. Contains fenceKey \"\n+                                    + \" but layout version (\" + journalVersion\n+                                    + \") is too old to hold this\");\n+                        }\n                     } else {\n                         byte[] key = masterKeyCache.get(ledgerId);\n                         if (key == null) {\n@@ -934,10 +1018,26 @@ public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] mast\n      * This method is idempotent. Once a ledger is fenced, it can\n      * never be unfenced. Fencing a fenced ledger has no effect.\n      */\n-    public void fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n+    public Future<Boolean> fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n         LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);\n+        boolean success;\n         synchronized (handle) {\n-            handle.setFenced();\n+            success = handle.setFenced();\n+        }\n+        if (success) {\n+            // fenced first time, we should add the key to journal ensure we can rebuild\n+            ByteBuffer bb = ByteBuffer.allocate(8 + 8);\n+            bb.putLong(ledgerId);\n+            bb.putLong(METAENTRY_ID_FENCE_KEY);\n+            bb.flip();\n+\n+            FutureWriteCallback fwc = new FutureWriteCallback();\n+            LOG.debug(\"record fenced state for ledger {} in journal.\", ledgerId);\n+            journal.logAddEntry(bb, fwc, null);\n+            return fwc.getResult();\n+        } else {\n+            // already fenced\n+            return SUCCESS_FUTURE;\n         }\n     }\n "},{"sha":"b554ab1065751afcbf7617cd55caf5d9a8ca105e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"modified","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -44,6 +44,7 @@\n  * <li>magic bytes: 4 bytes, 'BKLE', version: 4 bytes\n  * <li>len of master key: indicates length of master key. -1 means no master key stored in header.\n  * <li>master key: master key\n+ * <li>state: bit map to indicate the state, 32 bits.\n  * </ul>\n  * <b>Index page</b> is a fixed-length page, which contains serveral entries which point to the offsets of data stored in entry loggers.\n  * </p>\n@@ -52,6 +53,7 @@\n     static Logger LOG = LoggerFactory.getLogger(FileInfo.class);\n \n     static final int NO_MASTER_KEY = -1;\n+    static final int STATE_FENCED_BIT = 0x1;\n \n     private FileChannel fc;\n     private File lf;\n@@ -69,6 +71,10 @@\n     private boolean isClosed;\n     private long sizeSinceLastwrite;\n \n+    // bit map for states of the ledger.\n+    private int stateBits;\n+    private boolean needFlushHeader = false;\n+\n     // file access mode\n     protected String mode;\n \n@@ -118,6 +124,8 @@ synchronized public void readHeader() throws IOException {\n             }\n             masterKey = new byte[length];\n             bb.get(masterKey);\n+            stateBits = bb.getInt();\n+            needFlushHeader = false;\n         } else {\n             throw new IOException(\"Ledger index file does not exist\");\n         }\n@@ -163,11 +171,43 @@ private void writeHeader() throws IOException {\n         bb.putInt(headerVersion);\n         bb.putInt(masterKey.length);\n         bb.put(masterKey);\n+        bb.putInt(stateBits);\n         bb.rewind();\n         fc.position(0);\n         fc.write(bb);\n     }\n \n+    synchronized public boolean isFenced() throws IOException {\n+        checkOpen(false);\n+        return (stateBits & STATE_FENCED_BIT) == STATE_FENCED_BIT;\n+    }\n+\n+    /**\n+     * @return true if set fence succeed, otherwise false when\n+     * it already fenced or failed to set fenced.\n+     */\n+    synchronized public boolean setFenced() throws IOException {\n+        checkOpen(false);\n+        LOG.debug(\"Try to set fenced state in file info {} : state bits {}.\", lf, stateBits);\n+        if ((stateBits & STATE_FENCED_BIT) != STATE_FENCED_BIT) {\n+            // not fenced yet\n+            stateBits |= STATE_FENCED_BIT;\n+            needFlushHeader = true;\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    // flush the header when header is changed\n+    synchronized public void flushHeader() throws IOException {\n+        if (needFlushHeader) {\n+            checkOpen(true);\n+            writeHeader();\n+            needFlushHeader = false;\n+        }\n+    }\n+\n     synchronized public long size() throws IOException {\n         checkOpen(false);\n         long rc = size-START_OF_DATA;"},{"sha":"fcb8aa053aa51f2675ef09c496e0bdb7bffba08f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -77,6 +77,16 @@ public void shutdown() throws InterruptedException {\n         }\n     }\n \n+    @Override\n+    public boolean setFenced(long ledgerId) throws IOException {\n+        return ledgerCache.setFenced(ledgerId);\n+    }\n+\n+    @Override\n+    public boolean isFenced(long ledgerId) throws IOException {\n+        return ledgerCache.isFenced(ledgerId);\n+    }\n+\n     @Override\n     public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n         ledgerCache.setMasterKey(ledgerId, masterKey);"},{"sha":"360b9889be1824cdb1c1d62e1312e299039058c3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -51,7 +51,7 @@\n \n     int HEADER_SIZE = 8; // 4byte magic word, 4 byte version\n     int MIN_COMPAT_JOURNAL_FORMAT_VERSION = 1;\n-    int CURRENT_JOURNAL_FORMAT_VERSION = 3;\n+    int CURRENT_JOURNAL_FORMAT_VERSION = 4;\n \n     public final static long preAllocSize = 4*1024*1024;\n     public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n@@ -155,4 +155,4 @@ int read(ByteBuffer dst)\n     public void close() throws IOException {\n         fc.close();\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"b2f8a9114e591d8de375b5cfc7e347490baaff27","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -30,6 +30,10 @@\n  * head scheduling.\n  */\n interface LedgerCache extends Closeable {\n+\n+    boolean setFenced(long ledgerId) throws IOException;\n+    boolean isFenced(long ledgerId) throws IOException;\n+\n     void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n     byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n     boolean ledgerExists(long ledgerId) throws IOException;"},{"sha":"ebdf5838141d2527df3f4b87bb62dfcdb0fe6683","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -414,6 +414,15 @@ private void flushLedger(long l) throws IOException {\n         synchronized(this) {\n             HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n             if (pageMap == null || pageMap.isEmpty()) {\n+                FileInfo fi = null;\n+                try {\n+                    fi = getFileInfo(l, null);\n+                    fi.flushHeader();\n+                } finally {\n+                    if (null != fi) {\n+                        fi.release();\n+                    }\n+                }\n                 return;\n             }\n             firstEntryList = new LinkedList<Long>();\n@@ -451,6 +460,8 @@ public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n                     });\n             ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n             fi = getFileInfo(l, null);\n+            // flush the header if necessary\n+            fi.flushHeader();\n             int start = 0;\n             long lastOffset = -1;\n             for(int i = 0; i < entries.size(); i++) {\n@@ -789,6 +800,38 @@ private void evictFileInfoIfNecessary() throws IOException {\n         }\n     }\n \n+    @Override\n+    public boolean setFenced(long ledgerId) throws IOException {\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            if (null != fi) {\n+                return fi.setFenced();\n+            }\n+            return false;\n+        } finally {\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isFenced(long ledgerId) throws IOException {\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            if (null != fi) {\n+                return fi.isFenced();\n+            }\n+            return false;\n+        } finally {\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n     @Override\n     public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n         FileInfo fi = null;"},{"sha":"02850d13b2fdad773d2aa4fdae55bb62996c7bcc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -54,8 +54,8 @@ static LedgerDescriptor createReadOnly(long ledgerId,\n \n     abstract long getLedgerId();\n \n-    abstract void setFenced() throws IOException;\n-    abstract boolean isFenced();\n+    abstract boolean setFenced() throws IOException;\n+    abstract boolean isFenced() throws IOException;\n \n     abstract long addEntry(ByteBuffer entry) throws IOException;\n     abstract ByteBuffer readEntry(long entryId) throws IOException;"},{"sha":"82d95ebc01efb19be72a82eeeae882638c3731b7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -38,7 +38,6 @@\n     final LedgerStorage ledgerStorage;\n     private long ledgerId;\n \n-    volatile private boolean fenced = false;\n     final byte[] masterKey;\n \n     LedgerDescriptorImpl(byte[] masterKey, long ledgerId, LedgerStorage ledgerStorage) {\n@@ -60,13 +59,13 @@ public long getLedgerId() {\n     }\n \n     @Override\n-    void setFenced() throws IOException {\n-        fenced = true;\n+    boolean setFenced() throws IOException {\n+        return ledgerStorage.setFenced(ledgerId);\n     }\n \n     @Override\n-    boolean isFenced() {\n-        return fenced;\n+    boolean isFenced() throws IOException {\n+        return ledgerStorage.isFenced(ledgerId);\n     }\n \n     @Override"},{"sha":"29dcfaf2a0f0716c19779b2a0d6cdd91c667aa0b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -33,7 +33,7 @@\n     }\n \n     @Override\n-    void setFenced() throws IOException {\n+    boolean setFenced() throws IOException {\n         assert false;\n         throw new IOException(\"Invalid action on read only descriptor\");\n     }"},{"sha":"f622834a4e934a7bae8ecdec1dff866c0848fcb4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","status":"modified","additions":19,"deletions":1,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -49,6 +49,24 @@\n      */\n     boolean ledgerExists(long ledgerId) throws IOException;\n \n+    /**\n+     * Fenced the ledger id in ledger storage.\n+     *\n+     * @param ledgerId\n+     *          Ledger Id.\n+     * @throws IOException when failed to fence the ledger.\n+     */\n+    boolean setFenced(long ledgerId) throws IOException;\n+\n+    /**\n+     * Check whether the ledger is fenced in ledger storage or not.\n+     *\n+     * @param ledgerId\n+     *          Ledger ID.\n+     * @throws IOException\n+     */\n+    boolean isFenced(long ledgerId) throws IOException;\n+\n     /**\n      * Set the master key for a ledger\n      */\n@@ -88,4 +106,4 @@\n      * Get the JMX management bean for this LedgerStorage\n      */\n     BKMBeanInfo getJMXBean();\n-}\n\\ No newline at end of file\n+}"},{"sha":"8756db495a3a7817c25f1f8a7567dca55412b7bb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":49,"deletions":3,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -26,6 +26,10 @@\n import java.net.MalformedURLException;\n import java.net.UnknownHostException;\n import java.nio.ByteBuffer;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n import org.apache.zookeeper.KeeperException;\n \n@@ -399,22 +403,64 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n             LOG.debug(\"Received new read request: {}, {}\", ledgerId, entryId);\n             int errorCode = BookieProtocol.EIO;\n             try {\n+                Future<Boolean> fenceResult = null;\n                 if ((flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {\n                     LOG.warn(\"Ledger \" + ledgerId + \" fenced by \" + src.getPeerName());\n                     if (h.getVersion() >= 2) {\n                         masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n                         packet.get(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n \n-                        bookie.fenceLedger(ledgerId, masterKey);\n+                        fenceResult = bookie.fenceLedger(ledgerId, masterKey);\n                     } else {\n                         LOG.error(\"Password not provided, Not safe to fence {}\", ledgerId);\n                         throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n                     }\n                 }\n                 rsp[1] = bookie.readEntry(ledgerId, entryId);\n                 LOG.debug(\"##### Read entry ##### {}\", rsp[1].remaining());\n-                errorCode = BookieProtocol.EOK;\n-                success = true;\n+                if (null != fenceResult) {\n+                    // TODO:\n+                    // currently we don't have readCallback to run in separated read\n+                    // threads. after BOOKKEEPER-429 is complete, we could improve\n+                    // following code to make it not wait here\n+                    //\n+                    // For now, since we only try to wait after read entry. so writing\n+                    // to journal and read entry are executed in different thread\n+                    // it would be fine.\n+                    try {\n+                        Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n+                        if (null == fenced || !fenced) {\n+                            // if failed to fence, fail the read request to make it retry.\n+                            errorCode = BookieProtocol.EIO;\n+                            success = false;\n+                            rsp[1] = null;\n+                        } else {\n+                            errorCode = BookieProtocol.EOK;\n+                            success = true;\n+                        }\n+                    } catch (InterruptedException ie) {\n+                        LOG.error(\"Interrupting fence read entry (lid:\" + ledgerId\n+                                  + \", eid:\" + entryId + \") :\", ie);\n+                        errorCode = BookieProtocol.EIO;\n+                        success = false;\n+                        rsp[1] = null;\n+                    } catch (ExecutionException ee) {\n+                        LOG.error(\"Failed to fence read entry (lid:\" + ledgerId\n+                                  + \", eid:\" + entryId + \") :\", ee);\n+                        errorCode = BookieProtocol.EIO;\n+                        success = false;\n+                        rsp[1] = null;\n+                    } catch (TimeoutException te) {\n+                        LOG.error(\"Timeout to fence read entry (lid:\" + ledgerId\n+                                  + \", eid:\" + entryId + \") :\", te);\n+                        errorCode = BookieProtocol.EIO;\n+                        success = false;\n+                        rsp[1] = null;\n+                    }\n+                } else {\n+                    errorCode = BookieProtocol.EOK;\n+                    success = true;\n+                }\n             } catch (Bookie.NoLedgerException e) {\n                 if (LOG.isTraceEnabled()) {\n                     LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);"},{"sha":"e65bc7f5d2d64ff133ad2f630c1f8d04a2a6df5c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"modified","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/d69986c4df6b51ed6ed27c5f45a7b6850e69dacd/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=d69986c4df6b51ed6ed27c5f45a7b6850e69dacd","patch":"@@ -377,4 +377,32 @@ public void testFencingBadPassword() throws Exception {\n         writelh.addEntry(tmp.getBytes());\n     }\n \n+    @Test\n+    public void testFencingAndRestartBookies() throws Exception {\n+        LedgerHandle writelh = null;\n+        writelh = bkc.createLedger(digestType, \"password\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i = 0; i < 10; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        /*\n+         * Try to open ledger.\n+         */\n+        LedgerHandle readlh = bkc.openLedger(writelh.getId(), digestType,\n+                                             \"password\".getBytes());\n+\n+        restartBookies();\n+\n+        try {\n+            writelh.addEntry(tmp.getBytes());\n+            LOG.error(\"Should have thrown an exception\");\n+            fail(\"Should have thrown an exception when trying to write\");\n+        } catch (BKException.BKLedgerFencedException e) {\n+            // correct behaviour\n+        }\n+\n+        readlh.close();\n+    }\n }"}]}

